import {
  CreateApiKeyCommandInput,
  CreateApiKeyCommandOutput,
} from "../commands/CreateApiKeyCommand";
import {
  CreateAuthorizerCommandInput,
  CreateAuthorizerCommandOutput,
} from "../commands/CreateAuthorizerCommand";
import {
  CreateBasePathMappingCommandInput,
  CreateBasePathMappingCommandOutput,
} from "../commands/CreateBasePathMappingCommand";
import {
  CreateDeploymentCommandInput,
  CreateDeploymentCommandOutput,
} from "../commands/CreateDeploymentCommand";
import {
  CreateDocumentationPartCommandInput,
  CreateDocumentationPartCommandOutput,
} from "../commands/CreateDocumentationPartCommand";
import {
  CreateDocumentationVersionCommandInput,
  CreateDocumentationVersionCommandOutput,
} from "../commands/CreateDocumentationVersionCommand";
import {
  CreateDomainNameCommandInput,
  CreateDomainNameCommandOutput,
} from "../commands/CreateDomainNameCommand";
import {
  CreateModelCommandInput,
  CreateModelCommandOutput,
} from "../commands/CreateModelCommand";
import {
  CreateRequestValidatorCommandInput,
  CreateRequestValidatorCommandOutput,
} from "../commands/CreateRequestValidatorCommand";
import {
  CreateResourceCommandInput,
  CreateResourceCommandOutput,
} from "../commands/CreateResourceCommand";
import {
  CreateRestApiCommandInput,
  CreateRestApiCommandOutput,
} from "../commands/CreateRestApiCommand";
import {
  CreateStageCommandInput,
  CreateStageCommandOutput,
} from "../commands/CreateStageCommand";
import {
  CreateUsagePlanCommandInput,
  CreateUsagePlanCommandOutput,
} from "../commands/CreateUsagePlanCommand";
import {
  CreateUsagePlanKeyCommandInput,
  CreateUsagePlanKeyCommandOutput,
} from "../commands/CreateUsagePlanKeyCommand";
import {
  CreateVpcLinkCommandInput,
  CreateVpcLinkCommandOutput,
} from "../commands/CreateVpcLinkCommand";
import {
  DeleteApiKeyCommandInput,
  DeleteApiKeyCommandOutput,
} from "../commands/DeleteApiKeyCommand";
import {
  DeleteAuthorizerCommandInput,
  DeleteAuthorizerCommandOutput,
} from "../commands/DeleteAuthorizerCommand";
import {
  DeleteBasePathMappingCommandInput,
  DeleteBasePathMappingCommandOutput,
} from "../commands/DeleteBasePathMappingCommand";
import {
  DeleteClientCertificateCommandInput,
  DeleteClientCertificateCommandOutput,
} from "../commands/DeleteClientCertificateCommand";
import {
  DeleteDeploymentCommandInput,
  DeleteDeploymentCommandOutput,
} from "../commands/DeleteDeploymentCommand";
import {
  DeleteDocumentationPartCommandInput,
  DeleteDocumentationPartCommandOutput,
} from "../commands/DeleteDocumentationPartCommand";
import {
  DeleteDocumentationVersionCommandInput,
  DeleteDocumentationVersionCommandOutput,
} from "../commands/DeleteDocumentationVersionCommand";
import {
  DeleteDomainNameCommandInput,
  DeleteDomainNameCommandOutput,
} from "../commands/DeleteDomainNameCommand";
import {
  DeleteGatewayResponseCommandInput,
  DeleteGatewayResponseCommandOutput,
} from "../commands/DeleteGatewayResponseCommand";
import {
  DeleteIntegrationCommandInput,
  DeleteIntegrationCommandOutput,
} from "../commands/DeleteIntegrationCommand";
import {
  DeleteIntegrationResponseCommandInput,
  DeleteIntegrationResponseCommandOutput,
} from "../commands/DeleteIntegrationResponseCommand";
import {
  DeleteMethodCommandInput,
  DeleteMethodCommandOutput,
} from "../commands/DeleteMethodCommand";
import {
  DeleteMethodResponseCommandInput,
  DeleteMethodResponseCommandOutput,
} from "../commands/DeleteMethodResponseCommand";
import {
  DeleteModelCommandInput,
  DeleteModelCommandOutput,
} from "../commands/DeleteModelCommand";
import {
  DeleteRequestValidatorCommandInput,
  DeleteRequestValidatorCommandOutput,
} from "../commands/DeleteRequestValidatorCommand";
import {
  DeleteResourceCommandInput,
  DeleteResourceCommandOutput,
} from "../commands/DeleteResourceCommand";
import {
  DeleteRestApiCommandInput,
  DeleteRestApiCommandOutput,
} from "../commands/DeleteRestApiCommand";
import {
  DeleteStageCommandInput,
  DeleteStageCommandOutput,
} from "../commands/DeleteStageCommand";
import {
  DeleteUsagePlanCommandInput,
  DeleteUsagePlanCommandOutput,
} from "../commands/DeleteUsagePlanCommand";
import {
  DeleteUsagePlanKeyCommandInput,
  DeleteUsagePlanKeyCommandOutput,
} from "../commands/DeleteUsagePlanKeyCommand";
import {
  DeleteVpcLinkCommandInput,
  DeleteVpcLinkCommandOutput,
} from "../commands/DeleteVpcLinkCommand";
import {
  FlushStageAuthorizersCacheCommandInput,
  FlushStageAuthorizersCacheCommandOutput,
} from "../commands/FlushStageAuthorizersCacheCommand";
import {
  FlushStageCacheCommandInput,
  FlushStageCacheCommandOutput,
} from "../commands/FlushStageCacheCommand";
import {
  GenerateClientCertificateCommandInput,
  GenerateClientCertificateCommandOutput,
} from "../commands/GenerateClientCertificateCommand";
import {
  GetAccountCommandInput,
  GetAccountCommandOutput,
} from "../commands/GetAccountCommand";
import {
  GetApiKeyCommandInput,
  GetApiKeyCommandOutput,
} from "../commands/GetApiKeyCommand";
import {
  GetApiKeysCommandInput,
  GetApiKeysCommandOutput,
} from "../commands/GetApiKeysCommand";
import {
  GetAuthorizerCommandInput,
  GetAuthorizerCommandOutput,
} from "../commands/GetAuthorizerCommand";
import {
  GetAuthorizersCommandInput,
  GetAuthorizersCommandOutput,
} from "../commands/GetAuthorizersCommand";
import {
  GetBasePathMappingCommandInput,
  GetBasePathMappingCommandOutput,
} from "../commands/GetBasePathMappingCommand";
import {
  GetBasePathMappingsCommandInput,
  GetBasePathMappingsCommandOutput,
} from "../commands/GetBasePathMappingsCommand";
import {
  GetClientCertificateCommandInput,
  GetClientCertificateCommandOutput,
} from "../commands/GetClientCertificateCommand";
import {
  GetClientCertificatesCommandInput,
  GetClientCertificatesCommandOutput,
} from "../commands/GetClientCertificatesCommand";
import {
  GetDeploymentCommandInput,
  GetDeploymentCommandOutput,
} from "../commands/GetDeploymentCommand";
import {
  GetDeploymentsCommandInput,
  GetDeploymentsCommandOutput,
} from "../commands/GetDeploymentsCommand";
import {
  GetDocumentationPartCommandInput,
  GetDocumentationPartCommandOutput,
} from "../commands/GetDocumentationPartCommand";
import {
  GetDocumentationPartsCommandInput,
  GetDocumentationPartsCommandOutput,
} from "../commands/GetDocumentationPartsCommand";
import {
  GetDocumentationVersionCommandInput,
  GetDocumentationVersionCommandOutput,
} from "../commands/GetDocumentationVersionCommand";
import {
  GetDocumentationVersionsCommandInput,
  GetDocumentationVersionsCommandOutput,
} from "../commands/GetDocumentationVersionsCommand";
import {
  GetDomainNameCommandInput,
  GetDomainNameCommandOutput,
} from "../commands/GetDomainNameCommand";
import {
  GetDomainNamesCommandInput,
  GetDomainNamesCommandOutput,
} from "../commands/GetDomainNamesCommand";
import {
  GetExportCommandInput,
  GetExportCommandOutput,
} from "../commands/GetExportCommand";
import {
  GetGatewayResponseCommandInput,
  GetGatewayResponseCommandOutput,
} from "../commands/GetGatewayResponseCommand";
import {
  GetGatewayResponsesCommandInput,
  GetGatewayResponsesCommandOutput,
} from "../commands/GetGatewayResponsesCommand";
import {
  GetIntegrationCommandInput,
  GetIntegrationCommandOutput,
} from "../commands/GetIntegrationCommand";
import {
  GetIntegrationResponseCommandInput,
  GetIntegrationResponseCommandOutput,
} from "../commands/GetIntegrationResponseCommand";
import {
  GetMethodCommandInput,
  GetMethodCommandOutput,
} from "../commands/GetMethodCommand";
import {
  GetMethodResponseCommandInput,
  GetMethodResponseCommandOutput,
} from "../commands/GetMethodResponseCommand";
import {
  GetModelCommandInput,
  GetModelCommandOutput,
} from "../commands/GetModelCommand";
import {
  GetModelTemplateCommandInput,
  GetModelTemplateCommandOutput,
} from "../commands/GetModelTemplateCommand";
import {
  GetModelsCommandInput,
  GetModelsCommandOutput,
} from "../commands/GetModelsCommand";
import {
  GetRequestValidatorCommandInput,
  GetRequestValidatorCommandOutput,
} from "../commands/GetRequestValidatorCommand";
import {
  GetRequestValidatorsCommandInput,
  GetRequestValidatorsCommandOutput,
} from "../commands/GetRequestValidatorsCommand";
import {
  GetResourceCommandInput,
  GetResourceCommandOutput,
} from "../commands/GetResourceCommand";
import {
  GetResourcesCommandInput,
  GetResourcesCommandOutput,
} from "../commands/GetResourcesCommand";
import {
  GetRestApiCommandInput,
  GetRestApiCommandOutput,
} from "../commands/GetRestApiCommand";
import {
  GetRestApisCommandInput,
  GetRestApisCommandOutput,
} from "../commands/GetRestApisCommand";
import {
  GetSdkCommandInput,
  GetSdkCommandOutput,
} from "../commands/GetSdkCommand";
import {
  GetSdkTypeCommandInput,
  GetSdkTypeCommandOutput,
} from "../commands/GetSdkTypeCommand";
import {
  GetSdkTypesCommandInput,
  GetSdkTypesCommandOutput,
} from "../commands/GetSdkTypesCommand";
import {
  GetStageCommandInput,
  GetStageCommandOutput,
} from "../commands/GetStageCommand";
import {
  GetStagesCommandInput,
  GetStagesCommandOutput,
} from "../commands/GetStagesCommand";
import {
  GetTagsCommandInput,
  GetTagsCommandOutput,
} from "../commands/GetTagsCommand";
import {
  GetUsageCommandInput,
  GetUsageCommandOutput,
} from "../commands/GetUsageCommand";
import {
  GetUsagePlanCommandInput,
  GetUsagePlanCommandOutput,
} from "../commands/GetUsagePlanCommand";
import {
  GetUsagePlanKeyCommandInput,
  GetUsagePlanKeyCommandOutput,
} from "../commands/GetUsagePlanKeyCommand";
import {
  GetUsagePlanKeysCommandInput,
  GetUsagePlanKeysCommandOutput,
} from "../commands/GetUsagePlanKeysCommand";
import {
  GetUsagePlansCommandInput,
  GetUsagePlansCommandOutput,
} from "../commands/GetUsagePlansCommand";
import {
  GetVpcLinkCommandInput,
  GetVpcLinkCommandOutput,
} from "../commands/GetVpcLinkCommand";
import {
  GetVpcLinksCommandInput,
  GetVpcLinksCommandOutput,
} from "../commands/GetVpcLinksCommand";
import {
  ImportApiKeysCommandInput,
  ImportApiKeysCommandOutput,
} from "../commands/ImportApiKeysCommand";
import {
  ImportDocumentationPartsCommandInput,
  ImportDocumentationPartsCommandOutput,
} from "../commands/ImportDocumentationPartsCommand";
import {
  ImportRestApiCommandInput,
  ImportRestApiCommandOutput,
} from "../commands/ImportRestApiCommand";
import {
  PutGatewayResponseCommandInput,
  PutGatewayResponseCommandOutput,
} from "../commands/PutGatewayResponseCommand";
import {
  PutIntegrationCommandInput,
  PutIntegrationCommandOutput,
} from "../commands/PutIntegrationCommand";
import {
  PutIntegrationResponseCommandInput,
  PutIntegrationResponseCommandOutput,
} from "../commands/PutIntegrationResponseCommand";
import {
  PutMethodCommandInput,
  PutMethodCommandOutput,
} from "../commands/PutMethodCommand";
import {
  PutMethodResponseCommandInput,
  PutMethodResponseCommandOutput,
} from "../commands/PutMethodResponseCommand";
import {
  PutRestApiCommandInput,
  PutRestApiCommandOutput,
} from "../commands/PutRestApiCommand";
import {
  TagResourceCommandInput,
  TagResourceCommandOutput,
} from "../commands/TagResourceCommand";
import {
  TestInvokeAuthorizerCommandInput,
  TestInvokeAuthorizerCommandOutput,
} from "../commands/TestInvokeAuthorizerCommand";
import {
  TestInvokeMethodCommandInput,
  TestInvokeMethodCommandOutput,
} from "../commands/TestInvokeMethodCommand";
import {
  UntagResourceCommandInput,
  UntagResourceCommandOutput,
} from "../commands/UntagResourceCommand";
import {
  UpdateAccountCommandInput,
  UpdateAccountCommandOutput,
} from "../commands/UpdateAccountCommand";
import {
  UpdateApiKeyCommandInput,
  UpdateApiKeyCommandOutput,
} from "../commands/UpdateApiKeyCommand";
import {
  UpdateAuthorizerCommandInput,
  UpdateAuthorizerCommandOutput,
} from "../commands/UpdateAuthorizerCommand";
import {
  UpdateBasePathMappingCommandInput,
  UpdateBasePathMappingCommandOutput,
} from "../commands/UpdateBasePathMappingCommand";
import {
  UpdateClientCertificateCommandInput,
  UpdateClientCertificateCommandOutput,
} from "../commands/UpdateClientCertificateCommand";
import {
  UpdateDeploymentCommandInput,
  UpdateDeploymentCommandOutput,
} from "../commands/UpdateDeploymentCommand";
import {
  UpdateDocumentationPartCommandInput,
  UpdateDocumentationPartCommandOutput,
} from "../commands/UpdateDocumentationPartCommand";
import {
  UpdateDocumentationVersionCommandInput,
  UpdateDocumentationVersionCommandOutput,
} from "../commands/UpdateDocumentationVersionCommand";
import {
  UpdateDomainNameCommandInput,
  UpdateDomainNameCommandOutput,
} from "../commands/UpdateDomainNameCommand";
import {
  UpdateGatewayResponseCommandInput,
  UpdateGatewayResponseCommandOutput,
} from "../commands/UpdateGatewayResponseCommand";
import {
  UpdateIntegrationCommandInput,
  UpdateIntegrationCommandOutput,
} from "../commands/UpdateIntegrationCommand";
import {
  UpdateIntegrationResponseCommandInput,
  UpdateIntegrationResponseCommandOutput,
} from "../commands/UpdateIntegrationResponseCommand";
import {
  UpdateMethodCommandInput,
  UpdateMethodCommandOutput,
} from "../commands/UpdateMethodCommand";
import {
  UpdateMethodResponseCommandInput,
  UpdateMethodResponseCommandOutput,
} from "../commands/UpdateMethodResponseCommand";
import {
  UpdateModelCommandInput,
  UpdateModelCommandOutput,
} from "../commands/UpdateModelCommand";
import {
  UpdateRequestValidatorCommandInput,
  UpdateRequestValidatorCommandOutput,
} from "../commands/UpdateRequestValidatorCommand";
import {
  UpdateResourceCommandInput,
  UpdateResourceCommandOutput,
} from "../commands/UpdateResourceCommand";
import {
  UpdateRestApiCommandInput,
  UpdateRestApiCommandOutput,
} from "../commands/UpdateRestApiCommand";
import {
  UpdateStageCommandInput,
  UpdateStageCommandOutput,
} from "../commands/UpdateStageCommand";
import {
  UpdateUsageCommandInput,
  UpdateUsageCommandOutput,
} from "../commands/UpdateUsageCommand";
import {
  UpdateUsagePlanCommandInput,
  UpdateUsagePlanCommandOutput,
} from "../commands/UpdateUsagePlanCommand";
import {
  UpdateVpcLinkCommandInput,
  UpdateVpcLinkCommandOutput,
} from "../commands/UpdateVpcLinkCommand";
import {
  AccessLogSettings,
  ApiKey,
  ApiStage,
  Authorizer,
  BadRequestException,
  BasePathMapping,
  CanarySettings,
  ClientCertificate,
  ConflictException,
  Deployment,
  DeploymentCanarySettings,
  DocumentationPart,
  DocumentationPartLocation,
  DocumentationVersion,
  DomainName,
  EndpointConfiguration,
  EndpointType,
  GatewayResponse,
  Integration,
  IntegrationResponse,
  LimitExceededException,
  Method,
  MethodResponse,
  MethodSetting,
  MethodSnapshot,
  Model,
  NotFoundException,
  PatchOperation,
  QuotaSettings,
  RequestValidator,
  Resource,
  RestApi,
  SdkConfigurationProperty,
  SdkType,
  ServiceUnavailableException,
  Stage,
  StageKey,
  ThrottleSettings,
  TooManyRequestsException,
  UnauthorizedException,
  UsagePlan,
  UsagePlanKey,
  VpcLink,
} from "../models/index";
import {
  HttpRequest as __HttpRequest,
  HttpResponse as __HttpResponse,
} from "@aws-sdk/protocol-http";
import { SmithyException as __SmithyException } from "@aws-sdk/smithy-client";
import {
  Endpoint as __Endpoint,
  MetadataBearer as __MetadataBearer,
  ResponseMetadata as __ResponseMetadata,
  SerdeContext as __SerdeContext,
} from "@aws-sdk/types";

export async function serializeAws_restJson1_1CreateApiKeyCommand(
  input: CreateApiKeyCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/apikeys";
  let body: any = {};
  const bodyParams: any = {};
  if (input.customerId !== undefined) {
    bodyParams['customerId'] = input.customerId;
  }
  if (input.description !== undefined) {
    bodyParams['description'] = input.description;
  }
  if (input.enabled !== undefined) {
    bodyParams['enabled'] = input.enabled;
  }
  if (input.generateDistinctId !== undefined) {
    bodyParams['generateDistinctId'] = input.generateDistinctId;
  }
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.stageKeys !== undefined) {
    bodyParams['stageKeys'] = serializeAws_restJson1_1ListOfStageKeys(input.stageKeys, context);
  }
  if (input.tags !== undefined) {
    bodyParams['tags'] = serializeAws_restJson1_1MapOfStringToString(input.tags, context);
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  if (input.value !== undefined) {
    bodyParams['value'] = input.value;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body,
  });
}

export async function serializeAws_restJson1_1CreateAuthorizerCommand(
  input: CreateAuthorizerCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/restapis/{restApiId}/authorizers";
  if (input.restApiId !== undefined) {
    const labelValue: any = input.restApiId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: restApiId.');
    }
    resolvedPath = resolvedPath.replace('{restApiId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: restApiId.');
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.authType !== undefined) {
    bodyParams['authType'] = input.authType;
  }
  if (input.authorizerCredentials !== undefined) {
    bodyParams['authorizerCredentials'] = input.authorizerCredentials;
  }
  if (input.authorizerResultTtlInSeconds !== undefined) {
    bodyParams['authorizerResultTtlInSeconds'] = input.authorizerResultTtlInSeconds;
  }
  if (input.authorizerUri !== undefined) {
    bodyParams['authorizerUri'] = input.authorizerUri;
  }
  if (input.identitySource !== undefined) {
    bodyParams['identitySource'] = input.identitySource;
  }
  if (input.identityValidationExpression !== undefined) {
    bodyParams['identityValidationExpression'] = input.identityValidationExpression;
  }
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.providerARNs !== undefined) {
    bodyParams['providerARNs'] = serializeAws_restJson1_1ListOfARNs(input.providerARNs, context);
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  if (input.type !== undefined) {
    bodyParams['type'] = input.type;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body,
  });
}

export async function serializeAws_restJson1_1CreateBasePathMappingCommand(
  input: CreateBasePathMappingCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/domainnames/{domainName}/basepathmappings";
  if (input.domainName !== undefined) {
    const labelValue: any = input.domainName.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: domainName.');
    }
    resolvedPath = resolvedPath.replace('{domainName}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: domainName.');
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.basePath !== undefined) {
    bodyParams['basePath'] = input.basePath;
  }
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.restApiId !== undefined) {
    bodyParams['restApiId'] = input.restApiId;
  }
  if (input.stage !== undefined) {
    bodyParams['stage'] = input.stage;
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body,
  });
}

export async function serializeAws_restJson1_1CreateDeploymentCommand(
  input: CreateDeploymentCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/restapis/{restApiId}/deployments";
  if (input.restApiId !== undefined) {
    const labelValue: any = input.restApiId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: restApiId.');
    }
    resolvedPath = resolvedPath.replace('{restApiId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: restApiId.');
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.cacheClusterEnabled !== undefined) {
    bodyParams['cacheClusterEnabled'] = input.cacheClusterEnabled;
  }
  if (input.cacheClusterSize !== undefined) {
    bodyParams['cacheClusterSize'] = input.cacheClusterSize;
  }
  if (input.canarySettings !== undefined) {
    bodyParams['canarySettings'] = serializeAws_restJson1_1DeploymentCanarySettings(input.canarySettings, context);
  }
  if (input.description !== undefined) {
    bodyParams['description'] = input.description;
  }
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.stageDescription !== undefined) {
    bodyParams['stageDescription'] = input.stageDescription;
  }
  if (input.stageName !== undefined) {
    bodyParams['stageName'] = input.stageName;
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  if (input.tracingEnabled !== undefined) {
    bodyParams['tracingEnabled'] = input.tracingEnabled;
  }
  if (input.variables !== undefined) {
    bodyParams['variables'] = serializeAws_restJson1_1MapOfStringToString(input.variables, context);
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body,
  });
}

export async function serializeAws_restJson1_1CreateDocumentationPartCommand(
  input: CreateDocumentationPartCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/restapis/{restApiId}/documentation/parts";
  if (input.restApiId !== undefined) {
    const labelValue: any = input.restApiId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: restApiId.');
    }
    resolvedPath = resolvedPath.replace('{restApiId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: restApiId.');
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.location !== undefined) {
    bodyParams['location'] = serializeAws_restJson1_1DocumentationPartLocation(input.location, context);
  }
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.properties !== undefined) {
    bodyParams['properties'] = input.properties;
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body,
  });
}

export async function serializeAws_restJson1_1CreateDocumentationVersionCommand(
  input: CreateDocumentationVersionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/restapis/{restApiId}/documentation/versions";
  if (input.restApiId !== undefined) {
    const labelValue: any = input.restApiId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: restApiId.');
    }
    resolvedPath = resolvedPath.replace('{restApiId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: restApiId.');
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.description !== undefined) {
    bodyParams['description'] = input.description;
  }
  if (input.documentationVersion !== undefined) {
    bodyParams['documentationVersion'] = input.documentationVersion;
  }
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.stageName !== undefined) {
    bodyParams['stageName'] = input.stageName;
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body,
  });
}

export async function serializeAws_restJson1_1CreateDomainNameCommand(
  input: CreateDomainNameCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/domainnames";
  let body: any = {};
  const bodyParams: any = {};
  if (input.certificateArn !== undefined) {
    bodyParams['certificateArn'] = input.certificateArn;
  }
  if (input.certificateBody !== undefined) {
    bodyParams['certificateBody'] = input.certificateBody;
  }
  if (input.certificateChain !== undefined) {
    bodyParams['certificateChain'] = input.certificateChain;
  }
  if (input.certificateName !== undefined) {
    bodyParams['certificateName'] = input.certificateName;
  }
  if (input.certificatePrivateKey !== undefined) {
    bodyParams['certificatePrivateKey'] = input.certificatePrivateKey;
  }
  if (input.domainName !== undefined) {
    bodyParams['domainName'] = input.domainName;
  }
  if (input.endpointConfiguration !== undefined) {
    bodyParams['endpointConfiguration'] = serializeAws_restJson1_1EndpointConfiguration(input.endpointConfiguration, context);
  }
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.regionalCertificateArn !== undefined) {
    bodyParams['regionalCertificateArn'] = input.regionalCertificateArn;
  }
  if (input.regionalCertificateName !== undefined) {
    bodyParams['regionalCertificateName'] = input.regionalCertificateName;
  }
  if (input.securityPolicy !== undefined) {
    bodyParams['securityPolicy'] = input.securityPolicy;
  }
  if (input.tags !== undefined) {
    bodyParams['tags'] = serializeAws_restJson1_1MapOfStringToString(input.tags, context);
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body,
  });
}

export async function serializeAws_restJson1_1CreateModelCommand(
  input: CreateModelCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/restapis/{restApiId}/models";
  if (input.restApiId !== undefined) {
    const labelValue: any = input.restApiId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: restApiId.');
    }
    resolvedPath = resolvedPath.replace('{restApiId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: restApiId.');
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.contentType !== undefined) {
    bodyParams['contentType'] = input.contentType;
  }
  if (input.description !== undefined) {
    bodyParams['description'] = input.description;
  }
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.schema !== undefined) {
    bodyParams['schema'] = input.schema;
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body,
  });
}

export async function serializeAws_restJson1_1CreateRequestValidatorCommand(
  input: CreateRequestValidatorCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/restapis/{restApiId}/requestvalidators";
  if (input.restApiId !== undefined) {
    const labelValue: any = input.restApiId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: restApiId.');
    }
    resolvedPath = resolvedPath.replace('{restApiId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: restApiId.');
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  if (input.validateRequestBody !== undefined) {
    bodyParams['validateRequestBody'] = input.validateRequestBody;
  }
  if (input.validateRequestParameters !== undefined) {
    bodyParams['validateRequestParameters'] = input.validateRequestParameters;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body,
  });
}

export async function serializeAws_restJson1_1CreateResourceCommand(
  input: CreateResourceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/restapis/{restApiId}/resources/{parentId}";
  if (input.parentId !== undefined) {
    const labelValue: any = input.parentId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: parentId.');
    }
    resolvedPath = resolvedPath.replace('{parentId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: parentId.');
  }
  if (input.restApiId !== undefined) {
    const labelValue: any = input.restApiId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: restApiId.');
    }
    resolvedPath = resolvedPath.replace('{restApiId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: restApiId.');
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.pathPart !== undefined) {
    bodyParams['pathPart'] = input.pathPart;
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body,
  });
}

export async function serializeAws_restJson1_1CreateRestApiCommand(
  input: CreateRestApiCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/restapis";
  let body: any = {};
  const bodyParams: any = {};
  if (input.apiKeySource !== undefined) {
    bodyParams['apiKeySource'] = input.apiKeySource;
  }
  if (input.binaryMediaTypes !== undefined) {
    bodyParams['binaryMediaTypes'] = serializeAws_restJson1_1ListOfString(input.binaryMediaTypes, context);
  }
  if (input.cloneFrom !== undefined) {
    bodyParams['cloneFrom'] = input.cloneFrom;
  }
  if (input.description !== undefined) {
    bodyParams['description'] = input.description;
  }
  if (input.endpointConfiguration !== undefined) {
    bodyParams['endpointConfiguration'] = serializeAws_restJson1_1EndpointConfiguration(input.endpointConfiguration, context);
  }
  if (input.minimumCompressionSize !== undefined) {
    bodyParams['minimumCompressionSize'] = input.minimumCompressionSize;
  }
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.policy !== undefined) {
    bodyParams['policy'] = input.policy;
  }
  if (input.tags !== undefined) {
    bodyParams['tags'] = serializeAws_restJson1_1MapOfStringToString(input.tags, context);
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  if (input.version !== undefined) {
    bodyParams['version'] = input.version;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body,
  });
}

export async function serializeAws_restJson1_1CreateStageCommand(
  input: CreateStageCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/restapis/{restApiId}/stages";
  if (input.restApiId !== undefined) {
    const labelValue: any = input.restApiId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: restApiId.');
    }
    resolvedPath = resolvedPath.replace('{restApiId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: restApiId.');
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.cacheClusterEnabled !== undefined) {
    bodyParams['cacheClusterEnabled'] = input.cacheClusterEnabled;
  }
  if (input.cacheClusterSize !== undefined) {
    bodyParams['cacheClusterSize'] = input.cacheClusterSize;
  }
  if (input.canarySettings !== undefined) {
    bodyParams['canarySettings'] = serializeAws_restJson1_1CanarySettings(input.canarySettings, context);
  }
  if (input.deploymentId !== undefined) {
    bodyParams['deploymentId'] = input.deploymentId;
  }
  if (input.description !== undefined) {
    bodyParams['description'] = input.description;
  }
  if (input.documentationVersion !== undefined) {
    bodyParams['documentationVersion'] = input.documentationVersion;
  }
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.stageName !== undefined) {
    bodyParams['stageName'] = input.stageName;
  }
  if (input.tags !== undefined) {
    bodyParams['tags'] = serializeAws_restJson1_1MapOfStringToString(input.tags, context);
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  if (input.tracingEnabled !== undefined) {
    bodyParams['tracingEnabled'] = input.tracingEnabled;
  }
  if (input.variables !== undefined) {
    bodyParams['variables'] = serializeAws_restJson1_1MapOfStringToString(input.variables, context);
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body,
  });
}

export async function serializeAws_restJson1_1CreateUsagePlanCommand(
  input: CreateUsagePlanCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/usageplans";
  let body: any = {};
  const bodyParams: any = {};
  if (input.apiStages !== undefined) {
    bodyParams['apiStages'] = serializeAws_restJson1_1ListOfApiStage(input.apiStages, context);
  }
  if (input.description !== undefined) {
    bodyParams['description'] = input.description;
  }
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.quota !== undefined) {
    bodyParams['quota'] = serializeAws_restJson1_1QuotaSettings(input.quota, context);
  }
  if (input.tags !== undefined) {
    bodyParams['tags'] = serializeAws_restJson1_1MapOfStringToString(input.tags, context);
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.throttle !== undefined) {
    bodyParams['throttle'] = serializeAws_restJson1_1ThrottleSettings(input.throttle, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body,
  });
}

export async function serializeAws_restJson1_1CreateUsagePlanKeyCommand(
  input: CreateUsagePlanKeyCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/usageplans/{usagePlanId}/keys";
  if (input.usagePlanId !== undefined) {
    const labelValue: any = input.usagePlanId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: usagePlanId.');
    }
    resolvedPath = resolvedPath.replace('{usagePlanId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: usagePlanId.');
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.keyId !== undefined) {
    bodyParams['keyId'] = input.keyId;
  }
  if (input.keyType !== undefined) {
    bodyParams['keyType'] = input.keyType;
  }
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body,
  });
}

export async function serializeAws_restJson1_1CreateVpcLinkCommand(
  input: CreateVpcLinkCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/vpclinks";
  let body: any = {};
  const bodyParams: any = {};
  if (input.description !== undefined) {
    bodyParams['description'] = input.description;
  }
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.tags !== undefined) {
    bodyParams['tags'] = serializeAws_restJson1_1MapOfStringToString(input.tags, context);
  }
  if (input.targetArns !== undefined) {
    bodyParams['targetArns'] = serializeAws_restJson1_1ListOfString(input.targetArns, context);
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body,
  });
}

export async function serializeAws_restJson1_1DeleteApiKeyCommand(
  input: DeleteApiKeyCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/apikeys/{apiKey}";
  if (input.apiKey !== undefined) {
    const labelValue: any = input.apiKey.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: apiKey.');
    }
    resolvedPath = resolvedPath.replace('{apiKey}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: apiKey.');
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath,
    body: body,
  });
}

export async function serializeAws_restJson1_1DeleteAuthorizerCommand(
  input: DeleteAuthorizerCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/restapis/{restApiId}/authorizers/{authorizerId}";
  if (input.authorizerId !== undefined) {
    const labelValue: any = input.authorizerId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: authorizerId.');
    }
    resolvedPath = resolvedPath.replace('{authorizerId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: authorizerId.');
  }
  if (input.restApiId !== undefined) {
    const labelValue: any = input.restApiId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: restApiId.');
    }
    resolvedPath = resolvedPath.replace('{restApiId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: restApiId.');
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath,
    body: body,
  });
}

export async function serializeAws_restJson1_1DeleteBasePathMappingCommand(
  input: DeleteBasePathMappingCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/domainnames/{domainName}/basepathmappings/{basePath}";
  if (input.basePath !== undefined) {
    const labelValue: any = input.basePath.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: basePath.');
    }
    resolvedPath = resolvedPath.replace('{basePath}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: basePath.');
  }
  if (input.domainName !== undefined) {
    const labelValue: any = input.domainName.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: domainName.');
    }
    resolvedPath = resolvedPath.replace('{domainName}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: domainName.');
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath,
    body: body,
  });
}

export async function serializeAws_restJson1_1DeleteClientCertificateCommand(
  input: DeleteClientCertificateCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/clientcertificates/{clientCertificateId}";
  if (input.clientCertificateId !== undefined) {
    const labelValue: any = input.clientCertificateId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: clientCertificateId.');
    }
    resolvedPath = resolvedPath.replace('{clientCertificateId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: clientCertificateId.');
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath,
    body: body,
  });
}

export async function serializeAws_restJson1_1DeleteDeploymentCommand(
  input: DeleteDeploymentCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/restapis/{restApiId}/deployments/{deploymentId}";
  if (input.deploymentId !== undefined) {
    const labelValue: any = input.deploymentId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: deploymentId.');
    }
    resolvedPath = resolvedPath.replace('{deploymentId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: deploymentId.');
  }
  if (input.restApiId !== undefined) {
    const labelValue: any = input.restApiId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: restApiId.');
    }
    resolvedPath = resolvedPath.replace('{restApiId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: restApiId.');
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath,
    body: body,
  });
}

export async function serializeAws_restJson1_1DeleteDocumentationPartCommand(
  input: DeleteDocumentationPartCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/restapis/{restApiId}/documentation/parts/{documentationPartId}";
  if (input.documentationPartId !== undefined) {
    const labelValue: any = input.documentationPartId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: documentationPartId.');
    }
    resolvedPath = resolvedPath.replace('{documentationPartId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: documentationPartId.');
  }
  if (input.restApiId !== undefined) {
    const labelValue: any = input.restApiId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: restApiId.');
    }
    resolvedPath = resolvedPath.replace('{restApiId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: restApiId.');
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath,
    body: body,
  });
}

export async function serializeAws_restJson1_1DeleteDocumentationVersionCommand(
  input: DeleteDocumentationVersionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/restapis/{restApiId}/documentation/versions/{documentationVersion}";
  if (input.documentationVersion !== undefined) {
    const labelValue: any = input.documentationVersion.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: documentationVersion.');
    }
    resolvedPath = resolvedPath.replace('{documentationVersion}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: documentationVersion.');
  }
  if (input.restApiId !== undefined) {
    const labelValue: any = input.restApiId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: restApiId.');
    }
    resolvedPath = resolvedPath.replace('{restApiId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: restApiId.');
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath,
    body: body,
  });
}

export async function serializeAws_restJson1_1DeleteDomainNameCommand(
  input: DeleteDomainNameCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/domainnames/{domainName}";
  if (input.domainName !== undefined) {
    const labelValue: any = input.domainName.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: domainName.');
    }
    resolvedPath = resolvedPath.replace('{domainName}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: domainName.');
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath,
    body: body,
  });
}

export async function serializeAws_restJson1_1DeleteGatewayResponseCommand(
  input: DeleteGatewayResponseCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/restapis/{restApiId}/gatewayresponses/{responseType}";
  if (input.responseType !== undefined) {
    const labelValue: any = input.responseType.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: responseType.');
    }
    resolvedPath = resolvedPath.replace('{responseType}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: responseType.');
  }
  if (input.restApiId !== undefined) {
    const labelValue: any = input.restApiId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: restApiId.');
    }
    resolvedPath = resolvedPath.replace('{restApiId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: restApiId.');
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath,
    body: body,
  });
}

export async function serializeAws_restJson1_1DeleteIntegrationCommand(
  input: DeleteIntegrationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}/integration";
  if (input.httpMethod !== undefined) {
    const labelValue: any = input.httpMethod.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: httpMethod.');
    }
    resolvedPath = resolvedPath.replace('{httpMethod}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: httpMethod.');
  }
  if (input.resourceId !== undefined) {
    const labelValue: any = input.resourceId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: resourceId.');
    }
    resolvedPath = resolvedPath.replace('{resourceId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: resourceId.');
  }
  if (input.restApiId !== undefined) {
    const labelValue: any = input.restApiId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: restApiId.');
    }
    resolvedPath = resolvedPath.replace('{restApiId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: restApiId.');
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath,
    body: body,
  });
}

export async function serializeAws_restJson1_1DeleteIntegrationResponseCommand(
  input: DeleteIntegrationResponseCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}/integration/responses/{statusCode}";
  if (input.httpMethod !== undefined) {
    const labelValue: any = input.httpMethod.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: httpMethod.');
    }
    resolvedPath = resolvedPath.replace('{httpMethod}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: httpMethod.');
  }
  if (input.resourceId !== undefined) {
    const labelValue: any = input.resourceId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: resourceId.');
    }
    resolvedPath = resolvedPath.replace('{resourceId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: resourceId.');
  }
  if (input.restApiId !== undefined) {
    const labelValue: any = input.restApiId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: restApiId.');
    }
    resolvedPath = resolvedPath.replace('{restApiId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: restApiId.');
  }
  if (input.statusCode !== undefined) {
    const labelValue: any = input.statusCode.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: statusCode.');
    }
    resolvedPath = resolvedPath.replace('{statusCode}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: statusCode.');
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath,
    body: body,
  });
}

export async function serializeAws_restJson1_1DeleteMethodCommand(
  input: DeleteMethodCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}";
  if (input.httpMethod !== undefined) {
    const labelValue: any = input.httpMethod.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: httpMethod.');
    }
    resolvedPath = resolvedPath.replace('{httpMethod}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: httpMethod.');
  }
  if (input.resourceId !== undefined) {
    const labelValue: any = input.resourceId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: resourceId.');
    }
    resolvedPath = resolvedPath.replace('{resourceId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: resourceId.');
  }
  if (input.restApiId !== undefined) {
    const labelValue: any = input.restApiId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: restApiId.');
    }
    resolvedPath = resolvedPath.replace('{restApiId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: restApiId.');
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath,
    body: body,
  });
}

export async function serializeAws_restJson1_1DeleteMethodResponseCommand(
  input: DeleteMethodResponseCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}/responses/{statusCode}";
  if (input.httpMethod !== undefined) {
    const labelValue: any = input.httpMethod.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: httpMethod.');
    }
    resolvedPath = resolvedPath.replace('{httpMethod}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: httpMethod.');
  }
  if (input.resourceId !== undefined) {
    const labelValue: any = input.resourceId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: resourceId.');
    }
    resolvedPath = resolvedPath.replace('{resourceId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: resourceId.');
  }
  if (input.restApiId !== undefined) {
    const labelValue: any = input.restApiId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: restApiId.');
    }
    resolvedPath = resolvedPath.replace('{restApiId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: restApiId.');
  }
  if (input.statusCode !== undefined) {
    const labelValue: any = input.statusCode.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: statusCode.');
    }
    resolvedPath = resolvedPath.replace('{statusCode}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: statusCode.');
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath,
    body: body,
  });
}

export async function serializeAws_restJson1_1DeleteModelCommand(
  input: DeleteModelCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/restapis/{restApiId}/models/{modelName}";
  if (input.modelName !== undefined) {
    const labelValue: any = input.modelName.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: modelName.');
    }
    resolvedPath = resolvedPath.replace('{modelName}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: modelName.');
  }
  if (input.restApiId !== undefined) {
    const labelValue: any = input.restApiId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: restApiId.');
    }
    resolvedPath = resolvedPath.replace('{restApiId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: restApiId.');
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath,
    body: body,
  });
}

export async function serializeAws_restJson1_1DeleteRequestValidatorCommand(
  input: DeleteRequestValidatorCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/restapis/{restApiId}/requestvalidators/{requestValidatorId}";
  if (input.requestValidatorId !== undefined) {
    const labelValue: any = input.requestValidatorId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: requestValidatorId.');
    }
    resolvedPath = resolvedPath.replace('{requestValidatorId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: requestValidatorId.');
  }
  if (input.restApiId !== undefined) {
    const labelValue: any = input.restApiId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: restApiId.');
    }
    resolvedPath = resolvedPath.replace('{restApiId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: restApiId.');
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath,
    body: body,
  });
}

export async function serializeAws_restJson1_1DeleteResourceCommand(
  input: DeleteResourceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/restapis/{restApiId}/resources/{resourceId}";
  if (input.resourceId !== undefined) {
    const labelValue: any = input.resourceId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: resourceId.');
    }
    resolvedPath = resolvedPath.replace('{resourceId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: resourceId.');
  }
  if (input.restApiId !== undefined) {
    const labelValue: any = input.restApiId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: restApiId.');
    }
    resolvedPath = resolvedPath.replace('{restApiId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: restApiId.');
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath,
    body: body,
  });
}

export async function serializeAws_restJson1_1DeleteRestApiCommand(
  input: DeleteRestApiCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/restapis/{restApiId}";
  if (input.restApiId !== undefined) {
    const labelValue: any = input.restApiId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: restApiId.');
    }
    resolvedPath = resolvedPath.replace('{restApiId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: restApiId.');
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath,
    body: body,
  });
}

export async function serializeAws_restJson1_1DeleteStageCommand(
  input: DeleteStageCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/restapis/{restApiId}/stages/{stageName}";
  if (input.restApiId !== undefined) {
    const labelValue: any = input.restApiId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: restApiId.');
    }
    resolvedPath = resolvedPath.replace('{restApiId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: restApiId.');
  }
  if (input.stageName !== undefined) {
    const labelValue: any = input.stageName.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: stageName.');
    }
    resolvedPath = resolvedPath.replace('{stageName}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: stageName.');
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath,
    body: body,
  });
}

export async function serializeAws_restJson1_1DeleteUsagePlanCommand(
  input: DeleteUsagePlanCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/usageplans/{usagePlanId}";
  if (input.usagePlanId !== undefined) {
    const labelValue: any = input.usagePlanId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: usagePlanId.');
    }
    resolvedPath = resolvedPath.replace('{usagePlanId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: usagePlanId.');
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath,
    body: body,
  });
}

export async function serializeAws_restJson1_1DeleteUsagePlanKeyCommand(
  input: DeleteUsagePlanKeyCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/usageplans/{usagePlanId}/keys/{keyId}";
  if (input.keyId !== undefined) {
    const labelValue: any = input.keyId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: keyId.');
    }
    resolvedPath = resolvedPath.replace('{keyId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: keyId.');
  }
  if (input.usagePlanId !== undefined) {
    const labelValue: any = input.usagePlanId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: usagePlanId.');
    }
    resolvedPath = resolvedPath.replace('{usagePlanId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: usagePlanId.');
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath,
    body: body,
  });
}

export async function serializeAws_restJson1_1DeleteVpcLinkCommand(
  input: DeleteVpcLinkCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/vpclinks/{vpcLinkId}";
  if (input.vpcLinkId !== undefined) {
    const labelValue: any = input.vpcLinkId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: vpcLinkId.');
    }
    resolvedPath = resolvedPath.replace('{vpcLinkId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: vpcLinkId.');
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath,
    body: body,
  });
}

export async function serializeAws_restJson1_1FlushStageAuthorizersCacheCommand(
  input: FlushStageAuthorizersCacheCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/restapis/{restApiId}/stages/{stageName}/cache/authorizers";
  if (input.restApiId !== undefined) {
    const labelValue: any = input.restApiId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: restApiId.');
    }
    resolvedPath = resolvedPath.replace('{restApiId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: restApiId.');
  }
  if (input.stageName !== undefined) {
    const labelValue: any = input.stageName.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: stageName.');
    }
    resolvedPath = resolvedPath.replace('{stageName}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: stageName.');
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath,
    body: body,
  });
}

export async function serializeAws_restJson1_1FlushStageCacheCommand(
  input: FlushStageCacheCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/restapis/{restApiId}/stages/{stageName}/cache/data";
  if (input.restApiId !== undefined) {
    const labelValue: any = input.restApiId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: restApiId.');
    }
    resolvedPath = resolvedPath.replace('{restApiId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: restApiId.');
  }
  if (input.stageName !== undefined) {
    const labelValue: any = input.stageName.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: stageName.');
    }
    resolvedPath = resolvedPath.replace('{stageName}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: stageName.');
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath,
    body: body,
  });
}

export async function serializeAws_restJson1_1GenerateClientCertificateCommand(
  input: GenerateClientCertificateCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/clientcertificates";
  let body: any = {};
  const bodyParams: any = {};
  if (input.description !== undefined) {
    bodyParams['description'] = input.description;
  }
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.tags !== undefined) {
    bodyParams['tags'] = serializeAws_restJson1_1MapOfStringToString(input.tags, context);
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body,
  });
}

export async function serializeAws_restJson1_1GetAccountCommand(
  input: GetAccountCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/account";
  let body: any = {};
  const bodyParams: any = {};
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    body: body,
  });
}

export async function serializeAws_restJson1_1GetApiKeyCommand(
  input: GetApiKeyCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/apikeys/{apiKey}";
  if (input.apiKey !== undefined) {
    const labelValue: any = input.apiKey.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: apiKey.');
    }
    resolvedPath = resolvedPath.replace('{apiKey}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: apiKey.');
  }
  const query: any = {};
  if (input.includeValue !== undefined) {
    query['includeValue'] = input.includeValue.toString();
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body,
  });
}

export async function serializeAws_restJson1_1GetApiKeysCommand(
  input: GetApiKeysCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/apikeys";
  const query: any = {};
  if (input.customerId !== undefined) {
    query['customerId'] = input.customerId.toString();
  }
  if (input.includeValues !== undefined) {
    query['includeValues'] = input.includeValues.toString();
  }
  if (input.limit !== undefined) {
    query['limit'] = input.limit.toString();
  }
  if (input.nameQuery !== undefined) {
    query['name'] = input.nameQuery.toString();
  }
  if (input.position !== undefined) {
    query['position'] = input.position.toString();
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body,
  });
}

export async function serializeAws_restJson1_1GetAuthorizerCommand(
  input: GetAuthorizerCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/restapis/{restApiId}/authorizers/{authorizerId}";
  if (input.authorizerId !== undefined) {
    const labelValue: any = input.authorizerId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: authorizerId.');
    }
    resolvedPath = resolvedPath.replace('{authorizerId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: authorizerId.');
  }
  if (input.restApiId !== undefined) {
    const labelValue: any = input.restApiId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: restApiId.');
    }
    resolvedPath = resolvedPath.replace('{restApiId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: restApiId.');
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    body: body,
  });
}

export async function serializeAws_restJson1_1GetAuthorizersCommand(
  input: GetAuthorizersCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/restapis/{restApiId}/authorizers";
  if (input.restApiId !== undefined) {
    const labelValue: any = input.restApiId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: restApiId.');
    }
    resolvedPath = resolvedPath.replace('{restApiId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: restApiId.');
  }
  const query: any = {};
  if (input.limit !== undefined) {
    query['limit'] = input.limit.toString();
  }
  if (input.position !== undefined) {
    query['position'] = input.position.toString();
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body,
  });
}

export async function serializeAws_restJson1_1GetBasePathMappingCommand(
  input: GetBasePathMappingCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/domainnames/{domainName}/basepathmappings/{basePath}";
  if (input.basePath !== undefined) {
    const labelValue: any = input.basePath.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: basePath.');
    }
    resolvedPath = resolvedPath.replace('{basePath}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: basePath.');
  }
  if (input.domainName !== undefined) {
    const labelValue: any = input.domainName.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: domainName.');
    }
    resolvedPath = resolvedPath.replace('{domainName}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: domainName.');
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    body: body,
  });
}

export async function serializeAws_restJson1_1GetBasePathMappingsCommand(
  input: GetBasePathMappingsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/domainnames/{domainName}/basepathmappings";
  if (input.domainName !== undefined) {
    const labelValue: any = input.domainName.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: domainName.');
    }
    resolvedPath = resolvedPath.replace('{domainName}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: domainName.');
  }
  const query: any = {};
  if (input.limit !== undefined) {
    query['limit'] = input.limit.toString();
  }
  if (input.position !== undefined) {
    query['position'] = input.position.toString();
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body,
  });
}

export async function serializeAws_restJson1_1GetClientCertificateCommand(
  input: GetClientCertificateCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/clientcertificates/{clientCertificateId}";
  if (input.clientCertificateId !== undefined) {
    const labelValue: any = input.clientCertificateId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: clientCertificateId.');
    }
    resolvedPath = resolvedPath.replace('{clientCertificateId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: clientCertificateId.');
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    body: body,
  });
}

export async function serializeAws_restJson1_1GetClientCertificatesCommand(
  input: GetClientCertificatesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/clientcertificates";
  const query: any = {};
  if (input.limit !== undefined) {
    query['limit'] = input.limit.toString();
  }
  if (input.position !== undefined) {
    query['position'] = input.position.toString();
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body,
  });
}

export async function serializeAws_restJson1_1GetDeploymentCommand(
  input: GetDeploymentCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/restapis/{restApiId}/deployments/{deploymentId}";
  if (input.deploymentId !== undefined) {
    const labelValue: any = input.deploymentId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: deploymentId.');
    }
    resolvedPath = resolvedPath.replace('{deploymentId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: deploymentId.');
  }
  if (input.restApiId !== undefined) {
    const labelValue: any = input.restApiId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: restApiId.');
    }
    resolvedPath = resolvedPath.replace('{restApiId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: restApiId.');
  }
  const query: any = {};
  if (input.embed !== undefined) {
    query['embed'] = input.embed;
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body,
  });
}

export async function serializeAws_restJson1_1GetDeploymentsCommand(
  input: GetDeploymentsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/restapis/{restApiId}/deployments";
  if (input.restApiId !== undefined) {
    const labelValue: any = input.restApiId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: restApiId.');
    }
    resolvedPath = resolvedPath.replace('{restApiId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: restApiId.');
  }
  const query: any = {};
  if (input.limit !== undefined) {
    query['limit'] = input.limit.toString();
  }
  if (input.position !== undefined) {
    query['position'] = input.position.toString();
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body,
  });
}

export async function serializeAws_restJson1_1GetDocumentationPartCommand(
  input: GetDocumentationPartCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/restapis/{restApiId}/documentation/parts/{documentationPartId}";
  if (input.documentationPartId !== undefined) {
    const labelValue: any = input.documentationPartId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: documentationPartId.');
    }
    resolvedPath = resolvedPath.replace('{documentationPartId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: documentationPartId.');
  }
  if (input.restApiId !== undefined) {
    const labelValue: any = input.restApiId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: restApiId.');
    }
    resolvedPath = resolvedPath.replace('{restApiId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: restApiId.');
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    body: body,
  });
}

export async function serializeAws_restJson1_1GetDocumentationPartsCommand(
  input: GetDocumentationPartsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/restapis/{restApiId}/documentation/parts";
  if (input.restApiId !== undefined) {
    const labelValue: any = input.restApiId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: restApiId.');
    }
    resolvedPath = resolvedPath.replace('{restApiId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: restApiId.');
  }
  const query: any = {};
  if (input.limit !== undefined) {
    query['limit'] = input.limit.toString();
  }
  if (input.locationStatus !== undefined) {
    query['locationStatus'] = input.locationStatus.toString();
  }
  if (input.nameQuery !== undefined) {
    query['name'] = input.nameQuery.toString();
  }
  if (input.path !== undefined) {
    query['path'] = input.path.toString();
  }
  if (input.position !== undefined) {
    query['position'] = input.position.toString();
  }
  if (input.type !== undefined) {
    query['type'] = input.type.toString();
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body,
  });
}

export async function serializeAws_restJson1_1GetDocumentationVersionCommand(
  input: GetDocumentationVersionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/restapis/{restApiId}/documentation/versions/{documentationVersion}";
  if (input.documentationVersion !== undefined) {
    const labelValue: any = input.documentationVersion.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: documentationVersion.');
    }
    resolvedPath = resolvedPath.replace('{documentationVersion}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: documentationVersion.');
  }
  if (input.restApiId !== undefined) {
    const labelValue: any = input.restApiId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: restApiId.');
    }
    resolvedPath = resolvedPath.replace('{restApiId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: restApiId.');
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    body: body,
  });
}

export async function serializeAws_restJson1_1GetDocumentationVersionsCommand(
  input: GetDocumentationVersionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/restapis/{restApiId}/documentation/versions";
  if (input.restApiId !== undefined) {
    const labelValue: any = input.restApiId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: restApiId.');
    }
    resolvedPath = resolvedPath.replace('{restApiId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: restApiId.');
  }
  const query: any = {};
  if (input.limit !== undefined) {
    query['limit'] = input.limit.toString();
  }
  if (input.position !== undefined) {
    query['position'] = input.position.toString();
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body,
  });
}

export async function serializeAws_restJson1_1GetDomainNameCommand(
  input: GetDomainNameCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/domainnames/{domainName}";
  if (input.domainName !== undefined) {
    const labelValue: any = input.domainName.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: domainName.');
    }
    resolvedPath = resolvedPath.replace('{domainName}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: domainName.');
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    body: body,
  });
}

export async function serializeAws_restJson1_1GetDomainNamesCommand(
  input: GetDomainNamesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/domainnames";
  const query: any = {};
  if (input.limit !== undefined) {
    query['limit'] = input.limit.toString();
  }
  if (input.position !== undefined) {
    query['position'] = input.position.toString();
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body,
  });
}

export async function serializeAws_restJson1_1GetExportCommand(
  input: GetExportCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  if (input.accepts !== undefined) {
    headers["Accept"] = input.accepts.toString();
  }
  let resolvedPath = "/restapis/{restApiId}/stages/{stageName}/exports/{exportType}";
  if (input.exportType !== undefined) {
    const labelValue: any = input.exportType.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: exportType.');
    }
    resolvedPath = resolvedPath.replace('{exportType}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: exportType.');
  }
  if (input.restApiId !== undefined) {
    const labelValue: any = input.restApiId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: restApiId.');
    }
    resolvedPath = resolvedPath.replace('{restApiId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: restApiId.');
  }
  if (input.stageName !== undefined) {
    const labelValue: any = input.stageName.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: stageName.');
    }
    resolvedPath = resolvedPath.replace('{stageName}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: stageName.');
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.parameters !== undefined) {
    bodyParams['parameters'] = serializeAws_restJson1_1MapOfStringToString(input.parameters, context);
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    body: body,
  });
}

export async function serializeAws_restJson1_1GetGatewayResponseCommand(
  input: GetGatewayResponseCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/restapis/{restApiId}/gatewayresponses/{responseType}";
  if (input.responseType !== undefined) {
    const labelValue: any = input.responseType.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: responseType.');
    }
    resolvedPath = resolvedPath.replace('{responseType}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: responseType.');
  }
  if (input.restApiId !== undefined) {
    const labelValue: any = input.restApiId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: restApiId.');
    }
    resolvedPath = resolvedPath.replace('{restApiId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: restApiId.');
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    body: body,
  });
}

export async function serializeAws_restJson1_1GetGatewayResponsesCommand(
  input: GetGatewayResponsesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/restapis/{restApiId}/gatewayresponses";
  if (input.restApiId !== undefined) {
    const labelValue: any = input.restApiId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: restApiId.');
    }
    resolvedPath = resolvedPath.replace('{restApiId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: restApiId.');
  }
  const query: any = {};
  if (input.limit !== undefined) {
    query['limit'] = input.limit.toString();
  }
  if (input.position !== undefined) {
    query['position'] = input.position.toString();
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body,
  });
}

export async function serializeAws_restJson1_1GetIntegrationCommand(
  input: GetIntegrationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}/integration";
  if (input.httpMethod !== undefined) {
    const labelValue: any = input.httpMethod.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: httpMethod.');
    }
    resolvedPath = resolvedPath.replace('{httpMethod}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: httpMethod.');
  }
  if (input.resourceId !== undefined) {
    const labelValue: any = input.resourceId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: resourceId.');
    }
    resolvedPath = resolvedPath.replace('{resourceId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: resourceId.');
  }
  if (input.restApiId !== undefined) {
    const labelValue: any = input.restApiId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: restApiId.');
    }
    resolvedPath = resolvedPath.replace('{restApiId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: restApiId.');
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    body: body,
  });
}

export async function serializeAws_restJson1_1GetIntegrationResponseCommand(
  input: GetIntegrationResponseCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}/integration/responses/{statusCode}";
  if (input.httpMethod !== undefined) {
    const labelValue: any = input.httpMethod.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: httpMethod.');
    }
    resolvedPath = resolvedPath.replace('{httpMethod}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: httpMethod.');
  }
  if (input.resourceId !== undefined) {
    const labelValue: any = input.resourceId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: resourceId.');
    }
    resolvedPath = resolvedPath.replace('{resourceId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: resourceId.');
  }
  if (input.restApiId !== undefined) {
    const labelValue: any = input.restApiId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: restApiId.');
    }
    resolvedPath = resolvedPath.replace('{restApiId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: restApiId.');
  }
  if (input.statusCode !== undefined) {
    const labelValue: any = input.statusCode.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: statusCode.');
    }
    resolvedPath = resolvedPath.replace('{statusCode}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: statusCode.');
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    body: body,
  });
}

export async function serializeAws_restJson1_1GetMethodCommand(
  input: GetMethodCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}";
  if (input.httpMethod !== undefined) {
    const labelValue: any = input.httpMethod.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: httpMethod.');
    }
    resolvedPath = resolvedPath.replace('{httpMethod}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: httpMethod.');
  }
  if (input.resourceId !== undefined) {
    const labelValue: any = input.resourceId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: resourceId.');
    }
    resolvedPath = resolvedPath.replace('{resourceId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: resourceId.');
  }
  if (input.restApiId !== undefined) {
    const labelValue: any = input.restApiId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: restApiId.');
    }
    resolvedPath = resolvedPath.replace('{restApiId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: restApiId.');
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    body: body,
  });
}

export async function serializeAws_restJson1_1GetMethodResponseCommand(
  input: GetMethodResponseCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}/responses/{statusCode}";
  if (input.httpMethod !== undefined) {
    const labelValue: any = input.httpMethod.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: httpMethod.');
    }
    resolvedPath = resolvedPath.replace('{httpMethod}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: httpMethod.');
  }
  if (input.resourceId !== undefined) {
    const labelValue: any = input.resourceId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: resourceId.');
    }
    resolvedPath = resolvedPath.replace('{resourceId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: resourceId.');
  }
  if (input.restApiId !== undefined) {
    const labelValue: any = input.restApiId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: restApiId.');
    }
    resolvedPath = resolvedPath.replace('{restApiId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: restApiId.');
  }
  if (input.statusCode !== undefined) {
    const labelValue: any = input.statusCode.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: statusCode.');
    }
    resolvedPath = resolvedPath.replace('{statusCode}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: statusCode.');
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    body: body,
  });
}

export async function serializeAws_restJson1_1GetModelCommand(
  input: GetModelCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/restapis/{restApiId}/models/{modelName}";
  if (input.modelName !== undefined) {
    const labelValue: any = input.modelName.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: modelName.');
    }
    resolvedPath = resolvedPath.replace('{modelName}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: modelName.');
  }
  if (input.restApiId !== undefined) {
    const labelValue: any = input.restApiId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: restApiId.');
    }
    resolvedPath = resolvedPath.replace('{restApiId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: restApiId.');
  }
  const query: any = {};
  if (input.flatten !== undefined) {
    query['flatten'] = input.flatten.toString();
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body,
  });
}

export async function serializeAws_restJson1_1GetModelTemplateCommand(
  input: GetModelTemplateCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/restapis/{restApiId}/models/{modelName}/default_template";
  if (input.modelName !== undefined) {
    const labelValue: any = input.modelName.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: modelName.');
    }
    resolvedPath = resolvedPath.replace('{modelName}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: modelName.');
  }
  if (input.restApiId !== undefined) {
    const labelValue: any = input.restApiId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: restApiId.');
    }
    resolvedPath = resolvedPath.replace('{restApiId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: restApiId.');
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    body: body,
  });
}

export async function serializeAws_restJson1_1GetModelsCommand(
  input: GetModelsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/restapis/{restApiId}/models";
  if (input.restApiId !== undefined) {
    const labelValue: any = input.restApiId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: restApiId.');
    }
    resolvedPath = resolvedPath.replace('{restApiId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: restApiId.');
  }
  const query: any = {};
  if (input.limit !== undefined) {
    query['limit'] = input.limit.toString();
  }
  if (input.position !== undefined) {
    query['position'] = input.position.toString();
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body,
  });
}

export async function serializeAws_restJson1_1GetRequestValidatorCommand(
  input: GetRequestValidatorCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/restapis/{restApiId}/requestvalidators/{requestValidatorId}";
  if (input.requestValidatorId !== undefined) {
    const labelValue: any = input.requestValidatorId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: requestValidatorId.');
    }
    resolvedPath = resolvedPath.replace('{requestValidatorId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: requestValidatorId.');
  }
  if (input.restApiId !== undefined) {
    const labelValue: any = input.restApiId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: restApiId.');
    }
    resolvedPath = resolvedPath.replace('{restApiId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: restApiId.');
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    body: body,
  });
}

export async function serializeAws_restJson1_1GetRequestValidatorsCommand(
  input: GetRequestValidatorsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/restapis/{restApiId}/requestvalidators";
  if (input.restApiId !== undefined) {
    const labelValue: any = input.restApiId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: restApiId.');
    }
    resolvedPath = resolvedPath.replace('{restApiId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: restApiId.');
  }
  const query: any = {};
  if (input.limit !== undefined) {
    query['limit'] = input.limit.toString();
  }
  if (input.position !== undefined) {
    query['position'] = input.position.toString();
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body,
  });
}

export async function serializeAws_restJson1_1GetResourceCommand(
  input: GetResourceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/restapis/{restApiId}/resources/{resourceId}";
  if (input.resourceId !== undefined) {
    const labelValue: any = input.resourceId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: resourceId.');
    }
    resolvedPath = resolvedPath.replace('{resourceId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: resourceId.');
  }
  if (input.restApiId !== undefined) {
    const labelValue: any = input.restApiId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: restApiId.');
    }
    resolvedPath = resolvedPath.replace('{restApiId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: restApiId.');
  }
  const query: any = {};
  if (input.embed !== undefined) {
    query['embed'] = input.embed;
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body,
  });
}

export async function serializeAws_restJson1_1GetResourcesCommand(
  input: GetResourcesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/restapis/{restApiId}/resources";
  if (input.restApiId !== undefined) {
    const labelValue: any = input.restApiId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: restApiId.');
    }
    resolvedPath = resolvedPath.replace('{restApiId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: restApiId.');
  }
  const query: any = {};
  if (input.embed !== undefined) {
    query['embed'] = input.embed;
  }
  if (input.limit !== undefined) {
    query['limit'] = input.limit.toString();
  }
  if (input.position !== undefined) {
    query['position'] = input.position.toString();
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body,
  });
}

export async function serializeAws_restJson1_1GetRestApiCommand(
  input: GetRestApiCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/restapis/{restApiId}";
  if (input.restApiId !== undefined) {
    const labelValue: any = input.restApiId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: restApiId.');
    }
    resolvedPath = resolvedPath.replace('{restApiId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: restApiId.');
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    body: body,
  });
}

export async function serializeAws_restJson1_1GetRestApisCommand(
  input: GetRestApisCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/restapis";
  const query: any = {};
  if (input.limit !== undefined) {
    query['limit'] = input.limit.toString();
  }
  if (input.position !== undefined) {
    query['position'] = input.position.toString();
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body,
  });
}

export async function serializeAws_restJson1_1GetSdkCommand(
  input: GetSdkCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/restapis/{restApiId}/stages/{stageName}/sdks/{sdkType}";
  if (input.restApiId !== undefined) {
    const labelValue: any = input.restApiId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: restApiId.');
    }
    resolvedPath = resolvedPath.replace('{restApiId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: restApiId.');
  }
  if (input.sdkType !== undefined) {
    const labelValue: any = input.sdkType.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: sdkType.');
    }
    resolvedPath = resolvedPath.replace('{sdkType}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: sdkType.');
  }
  if (input.stageName !== undefined) {
    const labelValue: any = input.stageName.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: stageName.');
    }
    resolvedPath = resolvedPath.replace('{stageName}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: stageName.');
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.parameters !== undefined) {
    bodyParams['parameters'] = serializeAws_restJson1_1MapOfStringToString(input.parameters, context);
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    body: body,
  });
}

export async function serializeAws_restJson1_1GetSdkTypeCommand(
  input: GetSdkTypeCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/sdktypes/{id}";
  if (input.id !== undefined) {
    const labelValue: any = input.id.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: id.');
    }
    resolvedPath = resolvedPath.replace('{id}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: id.');
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    body: body,
  });
}

export async function serializeAws_restJson1_1GetSdkTypesCommand(
  input: GetSdkTypesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/sdktypes";
  const query: any = {};
  if (input.limit !== undefined) {
    query['limit'] = input.limit.toString();
  }
  if (input.position !== undefined) {
    query['position'] = input.position.toString();
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body,
  });
}

export async function serializeAws_restJson1_1GetStageCommand(
  input: GetStageCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/restapis/{restApiId}/stages/{stageName}";
  if (input.restApiId !== undefined) {
    const labelValue: any = input.restApiId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: restApiId.');
    }
    resolvedPath = resolvedPath.replace('{restApiId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: restApiId.');
  }
  if (input.stageName !== undefined) {
    const labelValue: any = input.stageName.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: stageName.');
    }
    resolvedPath = resolvedPath.replace('{stageName}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: stageName.');
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    body: body,
  });
}

export async function serializeAws_restJson1_1GetStagesCommand(
  input: GetStagesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/restapis/{restApiId}/stages";
  if (input.restApiId !== undefined) {
    const labelValue: any = input.restApiId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: restApiId.');
    }
    resolvedPath = resolvedPath.replace('{restApiId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: restApiId.');
  }
  const query: any = {};
  if (input.deploymentId !== undefined) {
    query['deploymentId'] = input.deploymentId.toString();
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body,
  });
}

export async function serializeAws_restJson1_1GetTagsCommand(
  input: GetTagsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/tags/{resourceArn}";
  if (input.resourceArn !== undefined) {
    const labelValue: any = input.resourceArn.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: resourceArn.');
    }
    resolvedPath = resolvedPath.replace('{resourceArn}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: resourceArn.');
  }
  const query: any = {};
  if (input.limit !== undefined) {
    query['limit'] = input.limit.toString();
  }
  if (input.position !== undefined) {
    query['position'] = input.position.toString();
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body,
  });
}

export async function serializeAws_restJson1_1GetUsageCommand(
  input: GetUsageCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/usageplans/{usagePlanId}/usage";
  if (input.usagePlanId !== undefined) {
    const labelValue: any = input.usagePlanId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: usagePlanId.');
    }
    resolvedPath = resolvedPath.replace('{usagePlanId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: usagePlanId.');
  }
  const query: any = {};
  if (input.endDate !== undefined) {
    query['endDate'] = input.endDate.toString();
  }
  if (input.keyId !== undefined) {
    query['keyId'] = input.keyId.toString();
  }
  if (input.limit !== undefined) {
    query['limit'] = input.limit.toString();
  }
  if (input.position !== undefined) {
    query['position'] = input.position.toString();
  }
  if (input.startDate !== undefined) {
    query['startDate'] = input.startDate.toString();
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body,
  });
}

export async function serializeAws_restJson1_1GetUsagePlanCommand(
  input: GetUsagePlanCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/usageplans/{usagePlanId}";
  if (input.usagePlanId !== undefined) {
    const labelValue: any = input.usagePlanId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: usagePlanId.');
    }
    resolvedPath = resolvedPath.replace('{usagePlanId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: usagePlanId.');
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    body: body,
  });
}

export async function serializeAws_restJson1_1GetUsagePlanKeyCommand(
  input: GetUsagePlanKeyCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/usageplans/{usagePlanId}/keys/{keyId}";
  if (input.keyId !== undefined) {
    const labelValue: any = input.keyId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: keyId.');
    }
    resolvedPath = resolvedPath.replace('{keyId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: keyId.');
  }
  if (input.usagePlanId !== undefined) {
    const labelValue: any = input.usagePlanId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: usagePlanId.');
    }
    resolvedPath = resolvedPath.replace('{usagePlanId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: usagePlanId.');
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    body: body,
  });
}

export async function serializeAws_restJson1_1GetUsagePlanKeysCommand(
  input: GetUsagePlanKeysCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/usageplans/{usagePlanId}/keys";
  if (input.usagePlanId !== undefined) {
    const labelValue: any = input.usagePlanId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: usagePlanId.');
    }
    resolvedPath = resolvedPath.replace('{usagePlanId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: usagePlanId.');
  }
  const query: any = {};
  if (input.limit !== undefined) {
    query['limit'] = input.limit.toString();
  }
  if (input.nameQuery !== undefined) {
    query['name'] = input.nameQuery.toString();
  }
  if (input.position !== undefined) {
    query['position'] = input.position.toString();
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body,
  });
}

export async function serializeAws_restJson1_1GetUsagePlansCommand(
  input: GetUsagePlansCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/usageplans";
  const query: any = {};
  if (input.keyId !== undefined) {
    query['keyId'] = input.keyId.toString();
  }
  if (input.limit !== undefined) {
    query['limit'] = input.limit.toString();
  }
  if (input.position !== undefined) {
    query['position'] = input.position.toString();
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body,
  });
}

export async function serializeAws_restJson1_1GetVpcLinkCommand(
  input: GetVpcLinkCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/vpclinks/{vpcLinkId}";
  if (input.vpcLinkId !== undefined) {
    const labelValue: any = input.vpcLinkId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: vpcLinkId.');
    }
    resolvedPath = resolvedPath.replace('{vpcLinkId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: vpcLinkId.');
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    body: body,
  });
}

export async function serializeAws_restJson1_1GetVpcLinksCommand(
  input: GetVpcLinksCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/vpclinks";
  const query: any = {};
  if (input.limit !== undefined) {
    query['limit'] = input.limit.toString();
  }
  if (input.position !== undefined) {
    query['position'] = input.position.toString();
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body,
  });
}

export async function serializeAws_restJson1_1ImportApiKeysCommand(
  input: ImportApiKeysCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/apikeys";
  const query: any = {
    "mode": "import",
  };
  if (input.failOnWarnings !== undefined) {
    query['failonwarnings'] = input.failOnWarnings.toString();
  }
  if (input.format !== undefined) {
    query['format'] = input.format.toString();
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body,
  });
}

export async function serializeAws_restJson1_1ImportDocumentationPartsCommand(
  input: ImportDocumentationPartsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/restapis/{restApiId}/documentation/parts";
  if (input.restApiId !== undefined) {
    const labelValue: any = input.restApiId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: restApiId.');
    }
    resolvedPath = resolvedPath.replace('{restApiId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: restApiId.');
  }
  const query: any = {};
  if (input.failOnWarnings !== undefined) {
    query['failonwarnings'] = input.failOnWarnings.toString();
  }
  if (input.mode !== undefined) {
    query['mode'] = input.mode.toString();
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PUT",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body,
  });
}

export async function serializeAws_restJson1_1ImportRestApiCommand(
  input: ImportRestApiCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/restapis";
  const query: any = {
    "mode": "import",
  };
  if (input.failOnWarnings !== undefined) {
    query['failonwarnings'] = input.failOnWarnings.toString();
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.parameters !== undefined) {
    bodyParams['parameters'] = serializeAws_restJson1_1MapOfStringToString(input.parameters, context);
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body,
  });
}

export async function serializeAws_restJson1_1PutGatewayResponseCommand(
  input: PutGatewayResponseCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/restapis/{restApiId}/gatewayresponses/{responseType}";
  if (input.responseType !== undefined) {
    const labelValue: any = input.responseType.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: responseType.');
    }
    resolvedPath = resolvedPath.replace('{responseType}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: responseType.');
  }
  if (input.restApiId !== undefined) {
    const labelValue: any = input.restApiId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: restApiId.');
    }
    resolvedPath = resolvedPath.replace('{restApiId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: restApiId.');
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.responseParameters !== undefined) {
    bodyParams['responseParameters'] = serializeAws_restJson1_1MapOfStringToString(input.responseParameters, context);
  }
  if (input.responseTemplates !== undefined) {
    bodyParams['responseTemplates'] = serializeAws_restJson1_1MapOfStringToString(input.responseTemplates, context);
  }
  if (input.statusCode !== undefined) {
    bodyParams['statusCode'] = input.statusCode;
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PUT",
    headers: headers,
    path: resolvedPath,
    body: body,
  });
}

export async function serializeAws_restJson1_1PutIntegrationCommand(
  input: PutIntegrationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}/integration";
  if (input.httpMethod !== undefined) {
    const labelValue: any = input.httpMethod.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: httpMethod.');
    }
    resolvedPath = resolvedPath.replace('{httpMethod}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: httpMethod.');
  }
  if (input.resourceId !== undefined) {
    const labelValue: any = input.resourceId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: resourceId.');
    }
    resolvedPath = resolvedPath.replace('{resourceId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: resourceId.');
  }
  if (input.restApiId !== undefined) {
    const labelValue: any = input.restApiId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: restApiId.');
    }
    resolvedPath = resolvedPath.replace('{restApiId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: restApiId.');
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.cacheKeyParameters !== undefined) {
    bodyParams['cacheKeyParameters'] = serializeAws_restJson1_1ListOfString(input.cacheKeyParameters, context);
  }
  if (input.cacheNamespace !== undefined) {
    bodyParams['cacheNamespace'] = input.cacheNamespace;
  }
  if (input.connectionId !== undefined) {
    bodyParams['connectionId'] = input.connectionId;
  }
  if (input.connectionType !== undefined) {
    bodyParams['connectionType'] = input.connectionType;
  }
  if (input.contentHandling !== undefined) {
    bodyParams['contentHandling'] = input.contentHandling;
  }
  if (input.credentials !== undefined) {
    bodyParams['credentials'] = input.credentials;
  }
  if (input.integrationHttpMethod !== undefined) {
    bodyParams['httpMethod'] = input.integrationHttpMethod;
  }
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.passthroughBehavior !== undefined) {
    bodyParams['passthroughBehavior'] = input.passthroughBehavior;
  }
  if (input.requestParameters !== undefined) {
    bodyParams['requestParameters'] = serializeAws_restJson1_1MapOfStringToString(input.requestParameters, context);
  }
  if (input.requestTemplates !== undefined) {
    bodyParams['requestTemplates'] = serializeAws_restJson1_1MapOfStringToString(input.requestTemplates, context);
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.timeoutInMillis !== undefined) {
    bodyParams['timeoutInMillis'] = input.timeoutInMillis;
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  if (input.type !== undefined) {
    bodyParams['type'] = input.type;
  }
  if (input.uri !== undefined) {
    bodyParams['uri'] = input.uri;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PUT",
    headers: headers,
    path: resolvedPath,
    body: body,
  });
}

export async function serializeAws_restJson1_1PutIntegrationResponseCommand(
  input: PutIntegrationResponseCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}/integration/responses/{statusCode}";
  if (input.httpMethod !== undefined) {
    const labelValue: any = input.httpMethod.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: httpMethod.');
    }
    resolvedPath = resolvedPath.replace('{httpMethod}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: httpMethod.');
  }
  if (input.resourceId !== undefined) {
    const labelValue: any = input.resourceId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: resourceId.');
    }
    resolvedPath = resolvedPath.replace('{resourceId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: resourceId.');
  }
  if (input.restApiId !== undefined) {
    const labelValue: any = input.restApiId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: restApiId.');
    }
    resolvedPath = resolvedPath.replace('{restApiId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: restApiId.');
  }
  if (input.statusCode !== undefined) {
    const labelValue: any = input.statusCode.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: statusCode.');
    }
    resolvedPath = resolvedPath.replace('{statusCode}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: statusCode.');
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.contentHandling !== undefined) {
    bodyParams['contentHandling'] = input.contentHandling;
  }
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.responseParameters !== undefined) {
    bodyParams['responseParameters'] = serializeAws_restJson1_1MapOfStringToString(input.responseParameters, context);
  }
  if (input.responseTemplates !== undefined) {
    bodyParams['responseTemplates'] = serializeAws_restJson1_1MapOfStringToString(input.responseTemplates, context);
  }
  if (input.selectionPattern !== undefined) {
    bodyParams['selectionPattern'] = input.selectionPattern;
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PUT",
    headers: headers,
    path: resolvedPath,
    body: body,
  });
}

export async function serializeAws_restJson1_1PutMethodCommand(
  input: PutMethodCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}";
  if (input.httpMethod !== undefined) {
    const labelValue: any = input.httpMethod.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: httpMethod.');
    }
    resolvedPath = resolvedPath.replace('{httpMethod}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: httpMethod.');
  }
  if (input.resourceId !== undefined) {
    const labelValue: any = input.resourceId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: resourceId.');
    }
    resolvedPath = resolvedPath.replace('{resourceId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: resourceId.');
  }
  if (input.restApiId !== undefined) {
    const labelValue: any = input.restApiId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: restApiId.');
    }
    resolvedPath = resolvedPath.replace('{restApiId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: restApiId.');
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.apiKeyRequired !== undefined) {
    bodyParams['apiKeyRequired'] = input.apiKeyRequired;
  }
  if (input.authorizationScopes !== undefined) {
    bodyParams['authorizationScopes'] = serializeAws_restJson1_1ListOfString(input.authorizationScopes, context);
  }
  if (input.authorizationType !== undefined) {
    bodyParams['authorizationType'] = input.authorizationType;
  }
  if (input.authorizerId !== undefined) {
    bodyParams['authorizerId'] = input.authorizerId;
  }
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.operationName !== undefined) {
    bodyParams['operationName'] = input.operationName;
  }
  if (input.requestModels !== undefined) {
    bodyParams['requestModels'] = serializeAws_restJson1_1MapOfStringToString(input.requestModels, context);
  }
  if (input.requestParameters !== undefined) {
    bodyParams['requestParameters'] = serializeAws_restJson1_1MapOfStringToBoolean(input.requestParameters, context);
  }
  if (input.requestValidatorId !== undefined) {
    bodyParams['requestValidatorId'] = input.requestValidatorId;
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PUT",
    headers: headers,
    path: resolvedPath,
    body: body,
  });
}

export async function serializeAws_restJson1_1PutMethodResponseCommand(
  input: PutMethodResponseCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}/responses/{statusCode}";
  if (input.httpMethod !== undefined) {
    const labelValue: any = input.httpMethod.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: httpMethod.');
    }
    resolvedPath = resolvedPath.replace('{httpMethod}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: httpMethod.');
  }
  if (input.resourceId !== undefined) {
    const labelValue: any = input.resourceId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: resourceId.');
    }
    resolvedPath = resolvedPath.replace('{resourceId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: resourceId.');
  }
  if (input.restApiId !== undefined) {
    const labelValue: any = input.restApiId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: restApiId.');
    }
    resolvedPath = resolvedPath.replace('{restApiId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: restApiId.');
  }
  if (input.statusCode !== undefined) {
    const labelValue: any = input.statusCode.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: statusCode.');
    }
    resolvedPath = resolvedPath.replace('{statusCode}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: statusCode.');
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.responseModels !== undefined) {
    bodyParams['responseModels'] = serializeAws_restJson1_1MapOfStringToString(input.responseModels, context);
  }
  if (input.responseParameters !== undefined) {
    bodyParams['responseParameters'] = serializeAws_restJson1_1MapOfStringToBoolean(input.responseParameters, context);
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PUT",
    headers: headers,
    path: resolvedPath,
    body: body,
  });
}

export async function serializeAws_restJson1_1PutRestApiCommand(
  input: PutRestApiCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/restapis/{restApiId}";
  if (input.restApiId !== undefined) {
    const labelValue: any = input.restApiId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: restApiId.');
    }
    resolvedPath = resolvedPath.replace('{restApiId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: restApiId.');
  }
  const query: any = {};
  if (input.failOnWarnings !== undefined) {
    query['failonwarnings'] = input.failOnWarnings.toString();
  }
  if (input.mode !== undefined) {
    query['mode'] = input.mode.toString();
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.parameters !== undefined) {
    bodyParams['parameters'] = serializeAws_restJson1_1MapOfStringToString(input.parameters, context);
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PUT",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body,
  });
}

export async function serializeAws_restJson1_1TagResourceCommand(
  input: TagResourceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/tags/{resourceArn}";
  if (input.resourceArn !== undefined) {
    const labelValue: any = input.resourceArn.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: resourceArn.');
    }
    resolvedPath = resolvedPath.replace('{resourceArn}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: resourceArn.');
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.tags !== undefined) {
    bodyParams['tags'] = serializeAws_restJson1_1MapOfStringToString(input.tags, context);
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PUT",
    headers: headers,
    path: resolvedPath,
    body: body,
  });
}

export async function serializeAws_restJson1_1TestInvokeAuthorizerCommand(
  input: TestInvokeAuthorizerCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/restapis/{restApiId}/authorizers/{authorizerId}";
  if (input.authorizerId !== undefined) {
    const labelValue: any = input.authorizerId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: authorizerId.');
    }
    resolvedPath = resolvedPath.replace('{authorizerId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: authorizerId.');
  }
  if (input.restApiId !== undefined) {
    const labelValue: any = input.restApiId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: restApiId.');
    }
    resolvedPath = resolvedPath.replace('{restApiId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: restApiId.');
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.additionalContext !== undefined) {
    bodyParams['additionalContext'] = serializeAws_restJson1_1MapOfStringToString(input.additionalContext, context);
  }
  if (input.body !== undefined) {
    bodyParams['body'] = input.body;
  }
  if (input.headers !== undefined) {
    bodyParams['headers'] = serializeAws_restJson1_1MapOfStringToString(input.headers, context);
  }
  if (input.multiValueHeaders !== undefined) {
    bodyParams['multiValueHeaders'] = serializeAws_restJson1_1MapOfStringToList(input.multiValueHeaders, context);
  }
  if (input.pathWithQueryString !== undefined) {
    bodyParams['pathWithQueryString'] = input.pathWithQueryString;
  }
  if (input.stageVariables !== undefined) {
    bodyParams['stageVariables'] = serializeAws_restJson1_1MapOfStringToString(input.stageVariables, context);
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body,
  });
}

export async function serializeAws_restJson1_1TestInvokeMethodCommand(
  input: TestInvokeMethodCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}";
  if (input.httpMethod !== undefined) {
    const labelValue: any = input.httpMethod.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: httpMethod.');
    }
    resolvedPath = resolvedPath.replace('{httpMethod}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: httpMethod.');
  }
  if (input.resourceId !== undefined) {
    const labelValue: any = input.resourceId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: resourceId.');
    }
    resolvedPath = resolvedPath.replace('{resourceId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: resourceId.');
  }
  if (input.restApiId !== undefined) {
    const labelValue: any = input.restApiId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: restApiId.');
    }
    resolvedPath = resolvedPath.replace('{restApiId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: restApiId.');
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.body !== undefined) {
    bodyParams['body'] = input.body;
  }
  if (input.clientCertificateId !== undefined) {
    bodyParams['clientCertificateId'] = input.clientCertificateId;
  }
  if (input.headers !== undefined) {
    bodyParams['headers'] = serializeAws_restJson1_1MapOfStringToString(input.headers, context);
  }
  if (input.multiValueHeaders !== undefined) {
    bodyParams['multiValueHeaders'] = serializeAws_restJson1_1MapOfStringToList(input.multiValueHeaders, context);
  }
  if (input.pathWithQueryString !== undefined) {
    bodyParams['pathWithQueryString'] = input.pathWithQueryString;
  }
  if (input.stageVariables !== undefined) {
    bodyParams['stageVariables'] = serializeAws_restJson1_1MapOfStringToString(input.stageVariables, context);
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body,
  });
}

export async function serializeAws_restJson1_1UntagResourceCommand(
  input: UntagResourceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/tags/{resourceArn}";
  if (input.resourceArn !== undefined) {
    const labelValue: any = input.resourceArn.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: resourceArn.');
    }
    resolvedPath = resolvedPath.replace('{resourceArn}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: resourceArn.');
  }
  const query: any = {};
  if (input.tagKeys !== undefined) {
    query['tagKeys'] = input.tagKeys;
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body,
  });
}

export async function serializeAws_restJson1_1UpdateAccountCommand(
  input: UpdateAccountCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/account";
  let body: any = {};
  const bodyParams: any = {};
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.patchOperations !== undefined) {
    bodyParams['patchOperations'] = serializeAws_restJson1_1ListOfPatchOperation(input.patchOperations, context);
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PATCH",
    headers: headers,
    path: resolvedPath,
    body: body,
  });
}

export async function serializeAws_restJson1_1UpdateApiKeyCommand(
  input: UpdateApiKeyCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/apikeys/{apiKey}";
  if (input.apiKey !== undefined) {
    const labelValue: any = input.apiKey.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: apiKey.');
    }
    resolvedPath = resolvedPath.replace('{apiKey}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: apiKey.');
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.patchOperations !== undefined) {
    bodyParams['patchOperations'] = serializeAws_restJson1_1ListOfPatchOperation(input.patchOperations, context);
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PATCH",
    headers: headers,
    path: resolvedPath,
    body: body,
  });
}

export async function serializeAws_restJson1_1UpdateAuthorizerCommand(
  input: UpdateAuthorizerCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/restapis/{restApiId}/authorizers/{authorizerId}";
  if (input.authorizerId !== undefined) {
    const labelValue: any = input.authorizerId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: authorizerId.');
    }
    resolvedPath = resolvedPath.replace('{authorizerId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: authorizerId.');
  }
  if (input.restApiId !== undefined) {
    const labelValue: any = input.restApiId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: restApiId.');
    }
    resolvedPath = resolvedPath.replace('{restApiId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: restApiId.');
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.patchOperations !== undefined) {
    bodyParams['patchOperations'] = serializeAws_restJson1_1ListOfPatchOperation(input.patchOperations, context);
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PATCH",
    headers: headers,
    path: resolvedPath,
    body: body,
  });
}

export async function serializeAws_restJson1_1UpdateBasePathMappingCommand(
  input: UpdateBasePathMappingCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/domainnames/{domainName}/basepathmappings/{basePath}";
  if (input.basePath !== undefined) {
    const labelValue: any = input.basePath.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: basePath.');
    }
    resolvedPath = resolvedPath.replace('{basePath}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: basePath.');
  }
  if (input.domainName !== undefined) {
    const labelValue: any = input.domainName.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: domainName.');
    }
    resolvedPath = resolvedPath.replace('{domainName}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: domainName.');
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.patchOperations !== undefined) {
    bodyParams['patchOperations'] = serializeAws_restJson1_1ListOfPatchOperation(input.patchOperations, context);
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PATCH",
    headers: headers,
    path: resolvedPath,
    body: body,
  });
}

export async function serializeAws_restJson1_1UpdateClientCertificateCommand(
  input: UpdateClientCertificateCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/clientcertificates/{clientCertificateId}";
  if (input.clientCertificateId !== undefined) {
    const labelValue: any = input.clientCertificateId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: clientCertificateId.');
    }
    resolvedPath = resolvedPath.replace('{clientCertificateId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: clientCertificateId.');
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.patchOperations !== undefined) {
    bodyParams['patchOperations'] = serializeAws_restJson1_1ListOfPatchOperation(input.patchOperations, context);
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PATCH",
    headers: headers,
    path: resolvedPath,
    body: body,
  });
}

export async function serializeAws_restJson1_1UpdateDeploymentCommand(
  input: UpdateDeploymentCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/restapis/{restApiId}/deployments/{deploymentId}";
  if (input.deploymentId !== undefined) {
    const labelValue: any = input.deploymentId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: deploymentId.');
    }
    resolvedPath = resolvedPath.replace('{deploymentId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: deploymentId.');
  }
  if (input.restApiId !== undefined) {
    const labelValue: any = input.restApiId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: restApiId.');
    }
    resolvedPath = resolvedPath.replace('{restApiId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: restApiId.');
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.patchOperations !== undefined) {
    bodyParams['patchOperations'] = serializeAws_restJson1_1ListOfPatchOperation(input.patchOperations, context);
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PATCH",
    headers: headers,
    path: resolvedPath,
    body: body,
  });
}

export async function serializeAws_restJson1_1UpdateDocumentationPartCommand(
  input: UpdateDocumentationPartCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/restapis/{restApiId}/documentation/parts/{documentationPartId}";
  if (input.documentationPartId !== undefined) {
    const labelValue: any = input.documentationPartId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: documentationPartId.');
    }
    resolvedPath = resolvedPath.replace('{documentationPartId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: documentationPartId.');
  }
  if (input.restApiId !== undefined) {
    const labelValue: any = input.restApiId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: restApiId.');
    }
    resolvedPath = resolvedPath.replace('{restApiId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: restApiId.');
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.patchOperations !== undefined) {
    bodyParams['patchOperations'] = serializeAws_restJson1_1ListOfPatchOperation(input.patchOperations, context);
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PATCH",
    headers: headers,
    path: resolvedPath,
    body: body,
  });
}

export async function serializeAws_restJson1_1UpdateDocumentationVersionCommand(
  input: UpdateDocumentationVersionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/restapis/{restApiId}/documentation/versions/{documentationVersion}";
  if (input.documentationVersion !== undefined) {
    const labelValue: any = input.documentationVersion.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: documentationVersion.');
    }
    resolvedPath = resolvedPath.replace('{documentationVersion}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: documentationVersion.');
  }
  if (input.restApiId !== undefined) {
    const labelValue: any = input.restApiId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: restApiId.');
    }
    resolvedPath = resolvedPath.replace('{restApiId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: restApiId.');
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.patchOperations !== undefined) {
    bodyParams['patchOperations'] = serializeAws_restJson1_1ListOfPatchOperation(input.patchOperations, context);
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PATCH",
    headers: headers,
    path: resolvedPath,
    body: body,
  });
}

export async function serializeAws_restJson1_1UpdateDomainNameCommand(
  input: UpdateDomainNameCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/domainnames/{domainName}";
  if (input.domainName !== undefined) {
    const labelValue: any = input.domainName.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: domainName.');
    }
    resolvedPath = resolvedPath.replace('{domainName}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: domainName.');
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.patchOperations !== undefined) {
    bodyParams['patchOperations'] = serializeAws_restJson1_1ListOfPatchOperation(input.patchOperations, context);
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PATCH",
    headers: headers,
    path: resolvedPath,
    body: body,
  });
}

export async function serializeAws_restJson1_1UpdateGatewayResponseCommand(
  input: UpdateGatewayResponseCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/restapis/{restApiId}/gatewayresponses/{responseType}";
  if (input.responseType !== undefined) {
    const labelValue: any = input.responseType.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: responseType.');
    }
    resolvedPath = resolvedPath.replace('{responseType}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: responseType.');
  }
  if (input.restApiId !== undefined) {
    const labelValue: any = input.restApiId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: restApiId.');
    }
    resolvedPath = resolvedPath.replace('{restApiId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: restApiId.');
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.patchOperations !== undefined) {
    bodyParams['patchOperations'] = serializeAws_restJson1_1ListOfPatchOperation(input.patchOperations, context);
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PATCH",
    headers: headers,
    path: resolvedPath,
    body: body,
  });
}

export async function serializeAws_restJson1_1UpdateIntegrationCommand(
  input: UpdateIntegrationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}/integration";
  if (input.httpMethod !== undefined) {
    const labelValue: any = input.httpMethod.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: httpMethod.');
    }
    resolvedPath = resolvedPath.replace('{httpMethod}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: httpMethod.');
  }
  if (input.resourceId !== undefined) {
    const labelValue: any = input.resourceId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: resourceId.');
    }
    resolvedPath = resolvedPath.replace('{resourceId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: resourceId.');
  }
  if (input.restApiId !== undefined) {
    const labelValue: any = input.restApiId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: restApiId.');
    }
    resolvedPath = resolvedPath.replace('{restApiId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: restApiId.');
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.patchOperations !== undefined) {
    bodyParams['patchOperations'] = serializeAws_restJson1_1ListOfPatchOperation(input.patchOperations, context);
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PATCH",
    headers: headers,
    path: resolvedPath,
    body: body,
  });
}

export async function serializeAws_restJson1_1UpdateIntegrationResponseCommand(
  input: UpdateIntegrationResponseCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}/integration/responses/{statusCode}";
  if (input.httpMethod !== undefined) {
    const labelValue: any = input.httpMethod.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: httpMethod.');
    }
    resolvedPath = resolvedPath.replace('{httpMethod}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: httpMethod.');
  }
  if (input.resourceId !== undefined) {
    const labelValue: any = input.resourceId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: resourceId.');
    }
    resolvedPath = resolvedPath.replace('{resourceId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: resourceId.');
  }
  if (input.restApiId !== undefined) {
    const labelValue: any = input.restApiId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: restApiId.');
    }
    resolvedPath = resolvedPath.replace('{restApiId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: restApiId.');
  }
  if (input.statusCode !== undefined) {
    const labelValue: any = input.statusCode.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: statusCode.');
    }
    resolvedPath = resolvedPath.replace('{statusCode}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: statusCode.');
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.patchOperations !== undefined) {
    bodyParams['patchOperations'] = serializeAws_restJson1_1ListOfPatchOperation(input.patchOperations, context);
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PATCH",
    headers: headers,
    path: resolvedPath,
    body: body,
  });
}

export async function serializeAws_restJson1_1UpdateMethodCommand(
  input: UpdateMethodCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}";
  if (input.httpMethod !== undefined) {
    const labelValue: any = input.httpMethod.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: httpMethod.');
    }
    resolvedPath = resolvedPath.replace('{httpMethod}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: httpMethod.');
  }
  if (input.resourceId !== undefined) {
    const labelValue: any = input.resourceId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: resourceId.');
    }
    resolvedPath = resolvedPath.replace('{resourceId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: resourceId.');
  }
  if (input.restApiId !== undefined) {
    const labelValue: any = input.restApiId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: restApiId.');
    }
    resolvedPath = resolvedPath.replace('{restApiId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: restApiId.');
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.patchOperations !== undefined) {
    bodyParams['patchOperations'] = serializeAws_restJson1_1ListOfPatchOperation(input.patchOperations, context);
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PATCH",
    headers: headers,
    path: resolvedPath,
    body: body,
  });
}

export async function serializeAws_restJson1_1UpdateMethodResponseCommand(
  input: UpdateMethodResponseCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}/responses/{statusCode}";
  if (input.httpMethod !== undefined) {
    const labelValue: any = input.httpMethod.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: httpMethod.');
    }
    resolvedPath = resolvedPath.replace('{httpMethod}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: httpMethod.');
  }
  if (input.resourceId !== undefined) {
    const labelValue: any = input.resourceId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: resourceId.');
    }
    resolvedPath = resolvedPath.replace('{resourceId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: resourceId.');
  }
  if (input.restApiId !== undefined) {
    const labelValue: any = input.restApiId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: restApiId.');
    }
    resolvedPath = resolvedPath.replace('{restApiId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: restApiId.');
  }
  if (input.statusCode !== undefined) {
    const labelValue: any = input.statusCode.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: statusCode.');
    }
    resolvedPath = resolvedPath.replace('{statusCode}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: statusCode.');
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.patchOperations !== undefined) {
    bodyParams['patchOperations'] = serializeAws_restJson1_1ListOfPatchOperation(input.patchOperations, context);
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PATCH",
    headers: headers,
    path: resolvedPath,
    body: body,
  });
}

export async function serializeAws_restJson1_1UpdateModelCommand(
  input: UpdateModelCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/restapis/{restApiId}/models/{modelName}";
  if (input.modelName !== undefined) {
    const labelValue: any = input.modelName.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: modelName.');
    }
    resolvedPath = resolvedPath.replace('{modelName}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: modelName.');
  }
  if (input.restApiId !== undefined) {
    const labelValue: any = input.restApiId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: restApiId.');
    }
    resolvedPath = resolvedPath.replace('{restApiId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: restApiId.');
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.patchOperations !== undefined) {
    bodyParams['patchOperations'] = serializeAws_restJson1_1ListOfPatchOperation(input.patchOperations, context);
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PATCH",
    headers: headers,
    path: resolvedPath,
    body: body,
  });
}

export async function serializeAws_restJson1_1UpdateRequestValidatorCommand(
  input: UpdateRequestValidatorCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/restapis/{restApiId}/requestvalidators/{requestValidatorId}";
  if (input.requestValidatorId !== undefined) {
    const labelValue: any = input.requestValidatorId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: requestValidatorId.');
    }
    resolvedPath = resolvedPath.replace('{requestValidatorId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: requestValidatorId.');
  }
  if (input.restApiId !== undefined) {
    const labelValue: any = input.restApiId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: restApiId.');
    }
    resolvedPath = resolvedPath.replace('{restApiId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: restApiId.');
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.patchOperations !== undefined) {
    bodyParams['patchOperations'] = serializeAws_restJson1_1ListOfPatchOperation(input.patchOperations, context);
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PATCH",
    headers: headers,
    path: resolvedPath,
    body: body,
  });
}

export async function serializeAws_restJson1_1UpdateResourceCommand(
  input: UpdateResourceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/restapis/{restApiId}/resources/{resourceId}";
  if (input.resourceId !== undefined) {
    const labelValue: any = input.resourceId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: resourceId.');
    }
    resolvedPath = resolvedPath.replace('{resourceId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: resourceId.');
  }
  if (input.restApiId !== undefined) {
    const labelValue: any = input.restApiId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: restApiId.');
    }
    resolvedPath = resolvedPath.replace('{restApiId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: restApiId.');
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.patchOperations !== undefined) {
    bodyParams['patchOperations'] = serializeAws_restJson1_1ListOfPatchOperation(input.patchOperations, context);
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PATCH",
    headers: headers,
    path: resolvedPath,
    body: body,
  });
}

export async function serializeAws_restJson1_1UpdateRestApiCommand(
  input: UpdateRestApiCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/restapis/{restApiId}";
  if (input.restApiId !== undefined) {
    const labelValue: any = input.restApiId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: restApiId.');
    }
    resolvedPath = resolvedPath.replace('{restApiId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: restApiId.');
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.patchOperations !== undefined) {
    bodyParams['patchOperations'] = serializeAws_restJson1_1ListOfPatchOperation(input.patchOperations, context);
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PATCH",
    headers: headers,
    path: resolvedPath,
    body: body,
  });
}

export async function serializeAws_restJson1_1UpdateStageCommand(
  input: UpdateStageCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/restapis/{restApiId}/stages/{stageName}";
  if (input.restApiId !== undefined) {
    const labelValue: any = input.restApiId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: restApiId.');
    }
    resolvedPath = resolvedPath.replace('{restApiId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: restApiId.');
  }
  if (input.stageName !== undefined) {
    const labelValue: any = input.stageName.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: stageName.');
    }
    resolvedPath = resolvedPath.replace('{stageName}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: stageName.');
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.patchOperations !== undefined) {
    bodyParams['patchOperations'] = serializeAws_restJson1_1ListOfPatchOperation(input.patchOperations, context);
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PATCH",
    headers: headers,
    path: resolvedPath,
    body: body,
  });
}

export async function serializeAws_restJson1_1UpdateUsageCommand(
  input: UpdateUsageCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/usageplans/{usagePlanId}/keys/{keyId}/usage";
  if (input.keyId !== undefined) {
    const labelValue: any = input.keyId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: keyId.');
    }
    resolvedPath = resolvedPath.replace('{keyId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: keyId.');
  }
  if (input.usagePlanId !== undefined) {
    const labelValue: any = input.usagePlanId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: usagePlanId.');
    }
    resolvedPath = resolvedPath.replace('{usagePlanId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: usagePlanId.');
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.patchOperations !== undefined) {
    bodyParams['patchOperations'] = serializeAws_restJson1_1ListOfPatchOperation(input.patchOperations, context);
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PATCH",
    headers: headers,
    path: resolvedPath,
    body: body,
  });
}

export async function serializeAws_restJson1_1UpdateUsagePlanCommand(
  input: UpdateUsagePlanCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/usageplans/{usagePlanId}";
  if (input.usagePlanId !== undefined) {
    const labelValue: any = input.usagePlanId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: usagePlanId.');
    }
    resolvedPath = resolvedPath.replace('{usagePlanId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: usagePlanId.');
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.patchOperations !== undefined) {
    bodyParams['patchOperations'] = serializeAws_restJson1_1ListOfPatchOperation(input.patchOperations, context);
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PATCH",
    headers: headers,
    path: resolvedPath,
    body: body,
  });
}

export async function serializeAws_restJson1_1UpdateVpcLinkCommand(
  input: UpdateVpcLinkCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers['Content-Type'] = "application/json";
  let resolvedPath = "/vpclinks/{vpcLinkId}";
  if (input.vpcLinkId !== undefined) {
    const labelValue: any = input.vpcLinkId.toString();
    if (labelValue.length <= 0) {
      throw new Error('Empty value provided for input HTTP label: vpcLinkId.');
    }
    resolvedPath = resolvedPath.replace('{vpcLinkId}', labelValue);
  } else {
    throw new Error('No value provided for input HTTP label: vpcLinkId.');
  }
  let body: any = {};
  const bodyParams: any = {};
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.patchOperations !== undefined) {
    bodyParams['patchOperations'] = serializeAws_restJson1_1ListOfPatchOperation(input.patchOperations, context);
  }
  if (input.template !== undefined) {
    bodyParams['template'] = input.template;
  }
  if (input.templateSkipList !== undefined) {
    bodyParams['templateSkipList'] = serializeAws_restJson1_1ListOfString(input.templateSkipList, context);
  }
  if (input.title !== undefined) {
    bodyParams['title'] = input.title;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PATCH",
    headers: headers,
    path: resolvedPath,
    body: body,
  });
}

export async function deserializeAws_restJson1_1CreateApiKeyCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateApiKeyCommandOutput> {
  if (output.statusCode !== 201) {
    return deserializeAws_restJson1_1CreateApiKeyCommandError(output, context);
  }
  const contents: CreateApiKeyCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ApiKey",
    createdDate: undefined,
    customerId: undefined,
    description: undefined,
    enabled: undefined,
    id: undefined,
    lastUpdatedDate: undefined,
    name: undefined,
    stageKeys: undefined,
    tags: undefined,
    value: undefined,
  };
  const data: any = await parseBody(output.body, context);
  if (data.createdDate !== undefined) {
    contents.createdDate = new Date(data.createdDate % 1 != 0 ? Math.round(data.createdDate * 1000) : data.createdDate);
  }
  if (data.customerId !== undefined) {
    contents.customerId = data.customerId;
  }
  if (data.description !== undefined) {
    contents.description = data.description;
  }
  if (data.enabled !== undefined) {
    contents.enabled = data.enabled;
  }
  if (data.id !== undefined) {
    contents.id = data.id;
  }
  if (data.lastUpdatedDate !== undefined) {
    contents.lastUpdatedDate = new Date(data.lastUpdatedDate % 1 != 0 ? Math.round(data.lastUpdatedDate * 1000) : data.lastUpdatedDate);
  }
  if (data.name !== undefined) {
    contents.name = data.name;
  }
  if (data.stageKeys !== undefined) {
    contents.stageKeys = deserializeAws_restJson1_1ListOfString(data.stageKeys, context);
  }
  if (data.tags !== undefined) {
    contents.tags = deserializeAws_restJson1_1MapOfStringToString(data.tags, context);
  }
  if (data.value !== undefined) {
    contents.value = data.value;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1CreateApiKeyCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<CreateApiKeyCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.commonapi.exceptions#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context);
      break;
    case "ConflictException":
    case "com.amazonaws.commonapi.exceptions#ConflictException":
      response = await deserializeAws_restJson1_1ConflictExceptionResponse(parsedOutput, context);
      break;
    case "LimitExceededException":
    case "com.amazonaws.commonapi.exceptions#LimitExceededException":
      response = await deserializeAws_restJson1_1LimitExceededExceptionResponse(parsedOutput, context);
      break;
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1CreateAuthorizerCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateAuthorizerCommandOutput> {
  if (output.statusCode !== 201) {
    return deserializeAws_restJson1_1CreateAuthorizerCommandError(output, context);
  }
  const contents: CreateAuthorizerCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "Authorizer",
    authType: undefined,
    authorizerCredentials: undefined,
    authorizerResultTtlInSeconds: undefined,
    authorizerUri: undefined,
    id: undefined,
    identitySource: undefined,
    identityValidationExpression: undefined,
    name: undefined,
    providerARNs: undefined,
    type: undefined,
  };
  const data: any = await parseBody(output.body, context);
  if (data.authType !== undefined) {
    contents.authType = data.authType;
  }
  if (data.authorizerCredentials !== undefined) {
    contents.authorizerCredentials = data.authorizerCredentials;
  }
  if (data.authorizerResultTtlInSeconds !== undefined) {
    contents.authorizerResultTtlInSeconds = data.authorizerResultTtlInSeconds;
  }
  if (data.authorizerUri !== undefined) {
    contents.authorizerUri = data.authorizerUri;
  }
  if (data.id !== undefined) {
    contents.id = data.id;
  }
  if (data.identitySource !== undefined) {
    contents.identitySource = data.identitySource;
  }
  if (data.identityValidationExpression !== undefined) {
    contents.identityValidationExpression = data.identityValidationExpression;
  }
  if (data.name !== undefined) {
    contents.name = data.name;
  }
  if (data.providerARNs !== undefined) {
    contents.providerARNs = deserializeAws_restJson1_1ListOfARNs(data.providerARNs, context);
  }
  if (data.type !== undefined) {
    contents.type = data.type;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1CreateAuthorizerCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<CreateAuthorizerCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.commonapi.exceptions#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context);
      break;
    case "LimitExceededException":
    case "com.amazonaws.commonapi.exceptions#LimitExceededException":
      response = await deserializeAws_restJson1_1LimitExceededExceptionResponse(parsedOutput, context);
      break;
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1CreateBasePathMappingCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateBasePathMappingCommandOutput> {
  if (output.statusCode !== 201) {
    return deserializeAws_restJson1_1CreateBasePathMappingCommandError(output, context);
  }
  const contents: CreateBasePathMappingCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "BasePathMapping",
    basePath: undefined,
    restApiId: undefined,
    stage: undefined,
  };
  const data: any = await parseBody(output.body, context);
  if (data.basePath !== undefined) {
    contents.basePath = data.basePath;
  }
  if (data.restApiId !== undefined) {
    contents.restApiId = data.restApiId;
  }
  if (data.stage !== undefined) {
    contents.stage = data.stage;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1CreateBasePathMappingCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<CreateBasePathMappingCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.commonapi.exceptions#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context);
      break;
    case "ConflictException":
    case "com.amazonaws.commonapi.exceptions#ConflictException":
      response = await deserializeAws_restJson1_1ConflictExceptionResponse(parsedOutput, context);
      break;
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1CreateDeploymentCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDeploymentCommandOutput> {
  if (output.statusCode !== 201) {
    return deserializeAws_restJson1_1CreateDeploymentCommandError(output, context);
  }
  const contents: CreateDeploymentCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "Deployment",
    apiSummary: undefined,
    createdDate: undefined,
    description: undefined,
    id: undefined,
  };
  const data: any = await parseBody(output.body, context);
  if (data.apiSummary !== undefined) {
    contents.apiSummary = deserializeAws_restJson1_1PathToMapOfMethodSnapshot(data.apiSummary, context);
  }
  if (data.createdDate !== undefined) {
    contents.createdDate = new Date(data.createdDate % 1 != 0 ? Math.round(data.createdDate * 1000) : data.createdDate);
  }
  if (data.description !== undefined) {
    contents.description = data.description;
  }
  if (data.id !== undefined) {
    contents.id = data.id;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1CreateDeploymentCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<CreateDeploymentCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.commonapi.exceptions#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context);
      break;
    case "ConflictException":
    case "com.amazonaws.commonapi.exceptions#ConflictException":
      response = await deserializeAws_restJson1_1ConflictExceptionResponse(parsedOutput, context);
      break;
    case "LimitExceededException":
    case "com.amazonaws.commonapi.exceptions#LimitExceededException":
      response = await deserializeAws_restJson1_1LimitExceededExceptionResponse(parsedOutput, context);
      break;
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.commonapi.exceptions#ServiceUnavailableException":
      response = await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1CreateDocumentationPartCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDocumentationPartCommandOutput> {
  if (output.statusCode !== 201) {
    return deserializeAws_restJson1_1CreateDocumentationPartCommandError(output, context);
  }
  const contents: CreateDocumentationPartCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DocumentationPart",
    id: undefined,
    location: undefined,
    properties: undefined,
  };
  const data: any = await parseBody(output.body, context);
  if (data.id !== undefined) {
    contents.id = data.id;
  }
  if (data.location !== undefined) {
    contents.location = deserializeAws_restJson1_1DocumentationPartLocation(data.location, context);
  }
  if (data.properties !== undefined) {
    contents.properties = data.properties;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1CreateDocumentationPartCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<CreateDocumentationPartCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.commonapi.exceptions#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context);
      break;
    case "ConflictException":
    case "com.amazonaws.commonapi.exceptions#ConflictException":
      response = await deserializeAws_restJson1_1ConflictExceptionResponse(parsedOutput, context);
      break;
    case "LimitExceededException":
    case "com.amazonaws.commonapi.exceptions#LimitExceededException":
      response = await deserializeAws_restJson1_1LimitExceededExceptionResponse(parsedOutput, context);
      break;
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1CreateDocumentationVersionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDocumentationVersionCommandOutput> {
  if (output.statusCode !== 201) {
    return deserializeAws_restJson1_1CreateDocumentationVersionCommandError(output, context);
  }
  const contents: CreateDocumentationVersionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DocumentationVersion",
    createdDate: undefined,
    description: undefined,
    version: undefined,
  };
  const data: any = await parseBody(output.body, context);
  if (data.createdDate !== undefined) {
    contents.createdDate = new Date(data.createdDate % 1 != 0 ? Math.round(data.createdDate * 1000) : data.createdDate);
  }
  if (data.description !== undefined) {
    contents.description = data.description;
  }
  if (data.version !== undefined) {
    contents.version = data.version;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1CreateDocumentationVersionCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<CreateDocumentationVersionCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.commonapi.exceptions#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context);
      break;
    case "ConflictException":
    case "com.amazonaws.commonapi.exceptions#ConflictException":
      response = await deserializeAws_restJson1_1ConflictExceptionResponse(parsedOutput, context);
      break;
    case "LimitExceededException":
    case "com.amazonaws.commonapi.exceptions#LimitExceededException":
      response = await deserializeAws_restJson1_1LimitExceededExceptionResponse(parsedOutput, context);
      break;
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1CreateDomainNameCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDomainNameCommandOutput> {
  if (output.statusCode !== 201) {
    return deserializeAws_restJson1_1CreateDomainNameCommandError(output, context);
  }
  const contents: CreateDomainNameCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DomainName",
    certificateArn: undefined,
    certificateName: undefined,
    certificateUploadDate: undefined,
    distributionDomainName: undefined,
    distributionHostedZoneId: undefined,
    domainName: undefined,
    domainNameStatus: undefined,
    domainNameStatusMessage: undefined,
    endpointConfiguration: undefined,
    regionalCertificateArn: undefined,
    regionalCertificateName: undefined,
    regionalDomainName: undefined,
    regionalHostedZoneId: undefined,
    securityPolicy: undefined,
    tags: undefined,
  };
  const data: any = await parseBody(output.body, context);
  if (data.certificateArn !== undefined) {
    contents.certificateArn = data.certificateArn;
  }
  if (data.certificateName !== undefined) {
    contents.certificateName = data.certificateName;
  }
  if (data.certificateUploadDate !== undefined) {
    contents.certificateUploadDate = new Date(data.certificateUploadDate % 1 != 0 ? Math.round(data.certificateUploadDate * 1000) : data.certificateUploadDate);
  }
  if (data.distributionDomainName !== undefined) {
    contents.distributionDomainName = data.distributionDomainName;
  }
  if (data.distributionHostedZoneId !== undefined) {
    contents.distributionHostedZoneId = data.distributionHostedZoneId;
  }
  if (data.domainName !== undefined) {
    contents.domainName = data.domainName;
  }
  if (data.domainNameStatus !== undefined) {
    contents.domainNameStatus = data.domainNameStatus;
  }
  if (data.domainNameStatusMessage !== undefined) {
    contents.domainNameStatusMessage = data.domainNameStatusMessage;
  }
  if (data.endpointConfiguration !== undefined) {
    contents.endpointConfiguration = deserializeAws_restJson1_1EndpointConfiguration(data.endpointConfiguration, context);
  }
  if (data.regionalCertificateArn !== undefined) {
    contents.regionalCertificateArn = data.regionalCertificateArn;
  }
  if (data.regionalCertificateName !== undefined) {
    contents.regionalCertificateName = data.regionalCertificateName;
  }
  if (data.regionalDomainName !== undefined) {
    contents.regionalDomainName = data.regionalDomainName;
  }
  if (data.regionalHostedZoneId !== undefined) {
    contents.regionalHostedZoneId = data.regionalHostedZoneId;
  }
  if (data.securityPolicy !== undefined) {
    contents.securityPolicy = data.securityPolicy;
  }
  if (data.tags !== undefined) {
    contents.tags = deserializeAws_restJson1_1MapOfStringToString(data.tags, context);
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1CreateDomainNameCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<CreateDomainNameCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.commonapi.exceptions#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context);
      break;
    case "ConflictException":
    case "com.amazonaws.commonapi.exceptions#ConflictException":
      response = await deserializeAws_restJson1_1ConflictExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1CreateModelCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateModelCommandOutput> {
  if (output.statusCode !== 201) {
    return deserializeAws_restJson1_1CreateModelCommandError(output, context);
  }
  const contents: CreateModelCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "Model",
    contentType: undefined,
    description: undefined,
    id: undefined,
    name: undefined,
    schema: undefined,
  };
  const data: any = await parseBody(output.body, context);
  if (data.contentType !== undefined) {
    contents.contentType = data.contentType;
  }
  if (data.description !== undefined) {
    contents.description = data.description;
  }
  if (data.id !== undefined) {
    contents.id = data.id;
  }
  if (data.name !== undefined) {
    contents.name = data.name;
  }
  if (data.schema !== undefined) {
    contents.schema = data.schema;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1CreateModelCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<CreateModelCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.commonapi.exceptions#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context);
      break;
    case "ConflictException":
    case "com.amazonaws.commonapi.exceptions#ConflictException":
      response = await deserializeAws_restJson1_1ConflictExceptionResponse(parsedOutput, context);
      break;
    case "LimitExceededException":
    case "com.amazonaws.commonapi.exceptions#LimitExceededException":
      response = await deserializeAws_restJson1_1LimitExceededExceptionResponse(parsedOutput, context);
      break;
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1CreateRequestValidatorCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateRequestValidatorCommandOutput> {
  if (output.statusCode !== 201) {
    return deserializeAws_restJson1_1CreateRequestValidatorCommandError(output, context);
  }
  const contents: CreateRequestValidatorCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "RequestValidator",
    id: undefined,
    name: undefined,
    validateRequestBody: undefined,
    validateRequestParameters: undefined,
  };
  const data: any = await parseBody(output.body, context);
  if (data.id !== undefined) {
    contents.id = data.id;
  }
  if (data.name !== undefined) {
    contents.name = data.name;
  }
  if (data.validateRequestBody !== undefined) {
    contents.validateRequestBody = data.validateRequestBody;
  }
  if (data.validateRequestParameters !== undefined) {
    contents.validateRequestParameters = data.validateRequestParameters;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1CreateRequestValidatorCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<CreateRequestValidatorCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.commonapi.exceptions#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context);
      break;
    case "LimitExceededException":
    case "com.amazonaws.commonapi.exceptions#LimitExceededException":
      response = await deserializeAws_restJson1_1LimitExceededExceptionResponse(parsedOutput, context);
      break;
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1CreateResourceCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateResourceCommandOutput> {
  if (output.statusCode !== 201) {
    return deserializeAws_restJson1_1CreateResourceCommandError(output, context);
  }
  const contents: CreateResourceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "Resource",
    id: undefined,
    parentId: undefined,
    path: undefined,
    pathPart: undefined,
    resourceMethods: undefined,
  };
  const data: any = await parseBody(output.body, context);
  if (data.id !== undefined) {
    contents.id = data.id;
  }
  if (data.parentId !== undefined) {
    contents.parentId = data.parentId;
  }
  if (data.path !== undefined) {
    contents.path = data.path;
  }
  if (data.pathPart !== undefined) {
    contents.pathPart = data.pathPart;
  }
  if (data.resourceMethods !== undefined) {
    contents.resourceMethods = deserializeAws_restJson1_1MapOfMethod(data.resourceMethods, context);
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1CreateResourceCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<CreateResourceCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.commonapi.exceptions#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context);
      break;
    case "ConflictException":
    case "com.amazonaws.commonapi.exceptions#ConflictException":
      response = await deserializeAws_restJson1_1ConflictExceptionResponse(parsedOutput, context);
      break;
    case "LimitExceededException":
    case "com.amazonaws.commonapi.exceptions#LimitExceededException":
      response = await deserializeAws_restJson1_1LimitExceededExceptionResponse(parsedOutput, context);
      break;
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1CreateRestApiCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateRestApiCommandOutput> {
  if (output.statusCode !== 201) {
    return deserializeAws_restJson1_1CreateRestApiCommandError(output, context);
  }
  const contents: CreateRestApiCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "RestApi",
    apiKeySource: undefined,
    binaryMediaTypes: undefined,
    createdDate: undefined,
    description: undefined,
    endpointConfiguration: undefined,
    id: undefined,
    minimumCompressionSize: undefined,
    name: undefined,
    policy: undefined,
    tags: undefined,
    version: undefined,
    warnings: undefined,
  };
  const data: any = await parseBody(output.body, context);
  if (data.apiKeySource !== undefined) {
    contents.apiKeySource = data.apiKeySource;
  }
  if (data.binaryMediaTypes !== undefined) {
    contents.binaryMediaTypes = deserializeAws_restJson1_1ListOfString(data.binaryMediaTypes, context);
  }
  if (data.createdDate !== undefined) {
    contents.createdDate = new Date(data.createdDate % 1 != 0 ? Math.round(data.createdDate * 1000) : data.createdDate);
  }
  if (data.description !== undefined) {
    contents.description = data.description;
  }
  if (data.endpointConfiguration !== undefined) {
    contents.endpointConfiguration = deserializeAws_restJson1_1EndpointConfiguration(data.endpointConfiguration, context);
  }
  if (data.id !== undefined) {
    contents.id = data.id;
  }
  if (data.minimumCompressionSize !== undefined) {
    contents.minimumCompressionSize = data.minimumCompressionSize;
  }
  if (data.name !== undefined) {
    contents.name = data.name;
  }
  if (data.policy !== undefined) {
    contents.policy = data.policy;
  }
  if (data.tags !== undefined) {
    contents.tags = deserializeAws_restJson1_1MapOfStringToString(data.tags, context);
  }
  if (data.version !== undefined) {
    contents.version = data.version;
  }
  if (data.warnings !== undefined) {
    contents.warnings = deserializeAws_restJson1_1ListOfString(data.warnings, context);
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1CreateRestApiCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<CreateRestApiCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.commonapi.exceptions#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context);
      break;
    case "LimitExceededException":
    case "com.amazonaws.commonapi.exceptions#LimitExceededException":
      response = await deserializeAws_restJson1_1LimitExceededExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1CreateStageCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateStageCommandOutput> {
  if (output.statusCode !== 201) {
    return deserializeAws_restJson1_1CreateStageCommandError(output, context);
  }
  const contents: CreateStageCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "Stage",
    accessLogSettings: undefined,
    cacheClusterEnabled: undefined,
    cacheClusterSize: undefined,
    cacheClusterStatus: undefined,
    canarySettings: undefined,
    clientCertificateId: undefined,
    createdDate: undefined,
    deploymentId: undefined,
    description: undefined,
    documentationVersion: undefined,
    lastUpdatedDate: undefined,
    methodSettings: undefined,
    stageName: undefined,
    tags: undefined,
    tracingEnabled: undefined,
    variables: undefined,
    webAclArn: undefined,
  };
  const data: any = await parseBody(output.body, context);
  if (data.accessLogSettings !== undefined) {
    contents.accessLogSettings = deserializeAws_restJson1_1AccessLogSettings(data.accessLogSettings, context);
  }
  if (data.cacheClusterEnabled !== undefined) {
    contents.cacheClusterEnabled = data.cacheClusterEnabled;
  }
  if (data.cacheClusterSize !== undefined) {
    contents.cacheClusterSize = data.cacheClusterSize;
  }
  if (data.cacheClusterStatus !== undefined) {
    contents.cacheClusterStatus = data.cacheClusterStatus;
  }
  if (data.canarySettings !== undefined) {
    contents.canarySettings = deserializeAws_restJson1_1CanarySettings(data.canarySettings, context);
  }
  if (data.clientCertificateId !== undefined) {
    contents.clientCertificateId = data.clientCertificateId;
  }
  if (data.createdDate !== undefined) {
    contents.createdDate = new Date(data.createdDate % 1 != 0 ? Math.round(data.createdDate * 1000) : data.createdDate);
  }
  if (data.deploymentId !== undefined) {
    contents.deploymentId = data.deploymentId;
  }
  if (data.description !== undefined) {
    contents.description = data.description;
  }
  if (data.documentationVersion !== undefined) {
    contents.documentationVersion = data.documentationVersion;
  }
  if (data.lastUpdatedDate !== undefined) {
    contents.lastUpdatedDate = new Date(data.lastUpdatedDate % 1 != 0 ? Math.round(data.lastUpdatedDate * 1000) : data.lastUpdatedDate);
  }
  if (data.methodSettings !== undefined) {
    contents.methodSettings = deserializeAws_restJson1_1MapOfMethodSettings(data.methodSettings, context);
  }
  if (data.stageName !== undefined) {
    contents.stageName = data.stageName;
  }
  if (data.tags !== undefined) {
    contents.tags = deserializeAws_restJson1_1MapOfStringToString(data.tags, context);
  }
  if (data.tracingEnabled !== undefined) {
    contents.tracingEnabled = data.tracingEnabled;
  }
  if (data.variables !== undefined) {
    contents.variables = deserializeAws_restJson1_1MapOfStringToString(data.variables, context);
  }
  if (data.webAclArn !== undefined) {
    contents.webAclArn = data.webAclArn;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1CreateStageCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<CreateStageCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.commonapi.exceptions#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context);
      break;
    case "ConflictException":
    case "com.amazonaws.commonapi.exceptions#ConflictException":
      response = await deserializeAws_restJson1_1ConflictExceptionResponse(parsedOutput, context);
      break;
    case "LimitExceededException":
    case "com.amazonaws.commonapi.exceptions#LimitExceededException":
      response = await deserializeAws_restJson1_1LimitExceededExceptionResponse(parsedOutput, context);
      break;
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1CreateUsagePlanCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateUsagePlanCommandOutput> {
  if (output.statusCode !== 201) {
    return deserializeAws_restJson1_1CreateUsagePlanCommandError(output, context);
  }
  const contents: CreateUsagePlanCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UsagePlan",
    apiStages: undefined,
    description: undefined,
    id: undefined,
    name: undefined,
    productCode: undefined,
    quota: undefined,
    tags: undefined,
    throttle: undefined,
  };
  const data: any = await parseBody(output.body, context);
  if (data.apiStages !== undefined) {
    contents.apiStages = deserializeAws_restJson1_1ListOfApiStage(data.apiStages, context);
  }
  if (data.description !== undefined) {
    contents.description = data.description;
  }
  if (data.id !== undefined) {
    contents.id = data.id;
  }
  if (data.name !== undefined) {
    contents.name = data.name;
  }
  if (data.productCode !== undefined) {
    contents.productCode = data.productCode;
  }
  if (data.quota !== undefined) {
    contents.quota = deserializeAws_restJson1_1QuotaSettings(data.quota, context);
  }
  if (data.tags !== undefined) {
    contents.tags = deserializeAws_restJson1_1MapOfStringToString(data.tags, context);
  }
  if (data.throttle !== undefined) {
    contents.throttle = deserializeAws_restJson1_1ThrottleSettings(data.throttle, context);
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1CreateUsagePlanCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<CreateUsagePlanCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.commonapi.exceptions#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context);
      break;
    case "ConflictException":
    case "com.amazonaws.commonapi.exceptions#ConflictException":
      response = await deserializeAws_restJson1_1ConflictExceptionResponse(parsedOutput, context);
      break;
    case "LimitExceededException":
    case "com.amazonaws.commonapi.exceptions#LimitExceededException":
      response = await deserializeAws_restJson1_1LimitExceededExceptionResponse(parsedOutput, context);
      break;
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1CreateUsagePlanKeyCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateUsagePlanKeyCommandOutput> {
  if (output.statusCode !== 201) {
    return deserializeAws_restJson1_1CreateUsagePlanKeyCommandError(output, context);
  }
  const contents: CreateUsagePlanKeyCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UsagePlanKey",
    id: undefined,
    name: undefined,
    type: undefined,
    value: undefined,
  };
  const data: any = await parseBody(output.body, context);
  if (data.id !== undefined) {
    contents.id = data.id;
  }
  if (data.name !== undefined) {
    contents.name = data.name;
  }
  if (data.type !== undefined) {
    contents.type = data.type;
  }
  if (data.value !== undefined) {
    contents.value = data.value;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1CreateUsagePlanKeyCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<CreateUsagePlanKeyCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.commonapi.exceptions#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context);
      break;
    case "ConflictException":
    case "com.amazonaws.commonapi.exceptions#ConflictException":
      response = await deserializeAws_restJson1_1ConflictExceptionResponse(parsedOutput, context);
      break;
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1CreateVpcLinkCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateVpcLinkCommandOutput> {
  if (output.statusCode !== 202) {
    return deserializeAws_restJson1_1CreateVpcLinkCommandError(output, context);
  }
  const contents: CreateVpcLinkCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "VpcLink",
    description: undefined,
    id: undefined,
    name: undefined,
    status: undefined,
    statusMessage: undefined,
    tags: undefined,
    targetArns: undefined,
  };
  const data: any = await parseBody(output.body, context);
  if (data.description !== undefined) {
    contents.description = data.description;
  }
  if (data.id !== undefined) {
    contents.id = data.id;
  }
  if (data.name !== undefined) {
    contents.name = data.name;
  }
  if (data.status !== undefined) {
    contents.status = data.status;
  }
  if (data.statusMessage !== undefined) {
    contents.statusMessage = data.statusMessage;
  }
  if (data.tags !== undefined) {
    contents.tags = deserializeAws_restJson1_1MapOfStringToString(data.tags, context);
  }
  if (data.targetArns !== undefined) {
    contents.targetArns = deserializeAws_restJson1_1ListOfString(data.targetArns, context);
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1CreateVpcLinkCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<CreateVpcLinkCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.commonapi.exceptions#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1DeleteApiKeyCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteApiKeyCommandOutput> {
  if (output.statusCode !== 202) {
    return deserializeAws_restJson1_1DeleteApiKeyCommandError(output, context);
  }
  const contents: DeleteApiKeyCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DeleteApiKeyCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<DeleteApiKeyCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1DeleteAuthorizerCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteAuthorizerCommandOutput> {
  if (output.statusCode !== 202) {
    return deserializeAws_restJson1_1DeleteAuthorizerCommandError(output, context);
  }
  const contents: DeleteAuthorizerCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DeleteAuthorizerCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<DeleteAuthorizerCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.commonapi.exceptions#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context);
      break;
    case "ConflictException":
    case "com.amazonaws.commonapi.exceptions#ConflictException":
      response = await deserializeAws_restJson1_1ConflictExceptionResponse(parsedOutput, context);
      break;
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1DeleteBasePathMappingCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteBasePathMappingCommandOutput> {
  if (output.statusCode !== 202) {
    return deserializeAws_restJson1_1DeleteBasePathMappingCommandError(output, context);
  }
  const contents: DeleteBasePathMappingCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DeleteBasePathMappingCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<DeleteBasePathMappingCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.commonapi.exceptions#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context);
      break;
    case "ConflictException":
    case "com.amazonaws.commonapi.exceptions#ConflictException":
      response = await deserializeAws_restJson1_1ConflictExceptionResponse(parsedOutput, context);
      break;
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1DeleteClientCertificateCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteClientCertificateCommandOutput> {
  if (output.statusCode !== 202) {
    return deserializeAws_restJson1_1DeleteClientCertificateCommandError(output, context);
  }
  const contents: DeleteClientCertificateCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DeleteClientCertificateCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<DeleteClientCertificateCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.commonapi.exceptions#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context);
      break;
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1DeleteDeploymentCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteDeploymentCommandOutput> {
  if (output.statusCode !== 202) {
    return deserializeAws_restJson1_1DeleteDeploymentCommandError(output, context);
  }
  const contents: DeleteDeploymentCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DeleteDeploymentCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<DeleteDeploymentCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.commonapi.exceptions#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context);
      break;
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1DeleteDocumentationPartCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteDocumentationPartCommandOutput> {
  if (output.statusCode !== 202) {
    return deserializeAws_restJson1_1DeleteDocumentationPartCommandError(output, context);
  }
  const contents: DeleteDocumentationPartCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DeleteDocumentationPartCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<DeleteDocumentationPartCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.commonapi.exceptions#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context);
      break;
    case "ConflictException":
    case "com.amazonaws.commonapi.exceptions#ConflictException":
      response = await deserializeAws_restJson1_1ConflictExceptionResponse(parsedOutput, context);
      break;
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1DeleteDocumentationVersionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteDocumentationVersionCommandOutput> {
  if (output.statusCode !== 202) {
    return deserializeAws_restJson1_1DeleteDocumentationVersionCommandError(output, context);
  }
  const contents: DeleteDocumentationVersionCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DeleteDocumentationVersionCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<DeleteDocumentationVersionCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.commonapi.exceptions#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context);
      break;
    case "ConflictException":
    case "com.amazonaws.commonapi.exceptions#ConflictException":
      response = await deserializeAws_restJson1_1ConflictExceptionResponse(parsedOutput, context);
      break;
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1DeleteDomainNameCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteDomainNameCommandOutput> {
  if (output.statusCode !== 202) {
    return deserializeAws_restJson1_1DeleteDomainNameCommandError(output, context);
  }
  const contents: DeleteDomainNameCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DeleteDomainNameCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<DeleteDomainNameCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.commonapi.exceptions#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context);
      break;
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1DeleteGatewayResponseCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteGatewayResponseCommandOutput> {
  if (output.statusCode !== 202) {
    return deserializeAws_restJson1_1DeleteGatewayResponseCommandError(output, context);
  }
  const contents: DeleteGatewayResponseCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DeleteGatewayResponseCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<DeleteGatewayResponseCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.commonapi.exceptions#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context);
      break;
    case "ConflictException":
    case "com.amazonaws.commonapi.exceptions#ConflictException":
      response = await deserializeAws_restJson1_1ConflictExceptionResponse(parsedOutput, context);
      break;
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1DeleteIntegrationCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteIntegrationCommandOutput> {
  if (output.statusCode !== 204) {
    return deserializeAws_restJson1_1DeleteIntegrationCommandError(output, context);
  }
  const contents: DeleteIntegrationCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DeleteIntegrationCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<DeleteIntegrationCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "ConflictException":
    case "com.amazonaws.commonapi.exceptions#ConflictException":
      response = await deserializeAws_restJson1_1ConflictExceptionResponse(parsedOutput, context);
      break;
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1DeleteIntegrationResponseCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteIntegrationResponseCommandOutput> {
  if (output.statusCode !== 204) {
    return deserializeAws_restJson1_1DeleteIntegrationResponseCommandError(output, context);
  }
  const contents: DeleteIntegrationResponseCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DeleteIntegrationResponseCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<DeleteIntegrationResponseCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.commonapi.exceptions#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context);
      break;
    case "ConflictException":
    case "com.amazonaws.commonapi.exceptions#ConflictException":
      response = await deserializeAws_restJson1_1ConflictExceptionResponse(parsedOutput, context);
      break;
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1DeleteMethodCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteMethodCommandOutput> {
  if (output.statusCode !== 204) {
    return deserializeAws_restJson1_1DeleteMethodCommandError(output, context);
  }
  const contents: DeleteMethodCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DeleteMethodCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<DeleteMethodCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "ConflictException":
    case "com.amazonaws.commonapi.exceptions#ConflictException":
      response = await deserializeAws_restJson1_1ConflictExceptionResponse(parsedOutput, context);
      break;
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1DeleteMethodResponseCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteMethodResponseCommandOutput> {
  if (output.statusCode !== 204) {
    return deserializeAws_restJson1_1DeleteMethodResponseCommandError(output, context);
  }
  const contents: DeleteMethodResponseCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DeleteMethodResponseCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<DeleteMethodResponseCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.commonapi.exceptions#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context);
      break;
    case "ConflictException":
    case "com.amazonaws.commonapi.exceptions#ConflictException":
      response = await deserializeAws_restJson1_1ConflictExceptionResponse(parsedOutput, context);
      break;
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1DeleteModelCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteModelCommandOutput> {
  if (output.statusCode !== 202) {
    return deserializeAws_restJson1_1DeleteModelCommandError(output, context);
  }
  const contents: DeleteModelCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DeleteModelCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<DeleteModelCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.commonapi.exceptions#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context);
      break;
    case "ConflictException":
    case "com.amazonaws.commonapi.exceptions#ConflictException":
      response = await deserializeAws_restJson1_1ConflictExceptionResponse(parsedOutput, context);
      break;
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1DeleteRequestValidatorCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteRequestValidatorCommandOutput> {
  if (output.statusCode !== 202) {
    return deserializeAws_restJson1_1DeleteRequestValidatorCommandError(output, context);
  }
  const contents: DeleteRequestValidatorCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DeleteRequestValidatorCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<DeleteRequestValidatorCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.commonapi.exceptions#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context);
      break;
    case "ConflictException":
    case "com.amazonaws.commonapi.exceptions#ConflictException":
      response = await deserializeAws_restJson1_1ConflictExceptionResponse(parsedOutput, context);
      break;
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1DeleteResourceCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteResourceCommandOutput> {
  if (output.statusCode !== 202) {
    return deserializeAws_restJson1_1DeleteResourceCommandError(output, context);
  }
  const contents: DeleteResourceCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DeleteResourceCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<DeleteResourceCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.commonapi.exceptions#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context);
      break;
    case "ConflictException":
    case "com.amazonaws.commonapi.exceptions#ConflictException":
      response = await deserializeAws_restJson1_1ConflictExceptionResponse(parsedOutput, context);
      break;
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1DeleteRestApiCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteRestApiCommandOutput> {
  if (output.statusCode !== 202) {
    return deserializeAws_restJson1_1DeleteRestApiCommandError(output, context);
  }
  const contents: DeleteRestApiCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DeleteRestApiCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<DeleteRestApiCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.commonapi.exceptions#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context);
      break;
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1DeleteStageCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteStageCommandOutput> {
  if (output.statusCode !== 202) {
    return deserializeAws_restJson1_1DeleteStageCommandError(output, context);
  }
  const contents: DeleteStageCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DeleteStageCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<DeleteStageCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.commonapi.exceptions#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context);
      break;
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1DeleteUsagePlanCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteUsagePlanCommandOutput> {
  if (output.statusCode !== 202) {
    return deserializeAws_restJson1_1DeleteUsagePlanCommandError(output, context);
  }
  const contents: DeleteUsagePlanCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DeleteUsagePlanCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<DeleteUsagePlanCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.commonapi.exceptions#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context);
      break;
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1DeleteUsagePlanKeyCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteUsagePlanKeyCommandOutput> {
  if (output.statusCode !== 202) {
    return deserializeAws_restJson1_1DeleteUsagePlanKeyCommandError(output, context);
  }
  const contents: DeleteUsagePlanKeyCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DeleteUsagePlanKeyCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<DeleteUsagePlanKeyCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.commonapi.exceptions#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context);
      break;
    case "ConflictException":
    case "com.amazonaws.commonapi.exceptions#ConflictException":
      response = await deserializeAws_restJson1_1ConflictExceptionResponse(parsedOutput, context);
      break;
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1DeleteVpcLinkCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteVpcLinkCommandOutput> {
  if (output.statusCode !== 202) {
    return deserializeAws_restJson1_1DeleteVpcLinkCommandError(output, context);
  }
  const contents: DeleteVpcLinkCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DeleteVpcLinkCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<DeleteVpcLinkCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.commonapi.exceptions#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context);
      break;
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1FlushStageAuthorizersCacheCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<FlushStageAuthorizersCacheCommandOutput> {
  if (output.statusCode !== 202) {
    return deserializeAws_restJson1_1FlushStageAuthorizersCacheCommandError(output, context);
  }
  const contents: FlushStageAuthorizersCacheCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1FlushStageAuthorizersCacheCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<FlushStageAuthorizersCacheCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.commonapi.exceptions#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context);
      break;
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1FlushStageCacheCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<FlushStageCacheCommandOutput> {
  if (output.statusCode !== 202) {
    return deserializeAws_restJson1_1FlushStageCacheCommandError(output, context);
  }
  const contents: FlushStageCacheCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1FlushStageCacheCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<FlushStageCacheCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.commonapi.exceptions#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context);
      break;
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1GenerateClientCertificateCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GenerateClientCertificateCommandOutput> {
  if (output.statusCode !== 201) {
    return deserializeAws_restJson1_1GenerateClientCertificateCommandError(output, context);
  }
  const contents: GenerateClientCertificateCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ClientCertificate",
    clientCertificateId: undefined,
    createdDate: undefined,
    description: undefined,
    expirationDate: undefined,
    pemEncodedCertificate: undefined,
    tags: undefined,
  };
  const data: any = await parseBody(output.body, context);
  if (data.clientCertificateId !== undefined) {
    contents.clientCertificateId = data.clientCertificateId;
  }
  if (data.createdDate !== undefined) {
    contents.createdDate = new Date(data.createdDate % 1 != 0 ? Math.round(data.createdDate * 1000) : data.createdDate);
  }
  if (data.description !== undefined) {
    contents.description = data.description;
  }
  if (data.expirationDate !== undefined) {
    contents.expirationDate = new Date(data.expirationDate % 1 != 0 ? Math.round(data.expirationDate * 1000) : data.expirationDate);
  }
  if (data.pemEncodedCertificate !== undefined) {
    contents.pemEncodedCertificate = data.pemEncodedCertificate;
  }
  if (data.tags !== undefined) {
    contents.tags = deserializeAws_restJson1_1MapOfStringToString(data.tags, context);
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GenerateClientCertificateCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<GenerateClientCertificateCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "LimitExceededException":
    case "com.amazonaws.commonapi.exceptions#LimitExceededException":
      response = await deserializeAws_restJson1_1LimitExceededExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1GetAccountCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetAccountCommandOutput> {
  if (output.statusCode !== 200) {
    return deserializeAws_restJson1_1GetAccountCommandError(output, context);
  }
  const contents: GetAccountCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "Account",
    apiKeyVersion: undefined,
    cloudwatchRoleArn: undefined,
    features: undefined,
    throttleSettings: undefined,
  };
  const data: any = await parseBody(output.body, context);
  if (data.apiKeyVersion !== undefined) {
    contents.apiKeyVersion = data.apiKeyVersion;
  }
  if (data.cloudwatchRoleArn !== undefined) {
    contents.cloudwatchRoleArn = data.cloudwatchRoleArn;
  }
  if (data.features !== undefined) {
    contents.features = deserializeAws_restJson1_1ListOfString(data.features, context);
  }
  if (data.throttleSettings !== undefined) {
    contents.throttleSettings = deserializeAws_restJson1_1ThrottleSettings(data.throttleSettings, context);
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetAccountCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<GetAccountCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1GetApiKeyCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetApiKeyCommandOutput> {
  if (output.statusCode !== 200) {
    return deserializeAws_restJson1_1GetApiKeyCommandError(output, context);
  }
  const contents: GetApiKeyCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ApiKey",
    createdDate: undefined,
    customerId: undefined,
    description: undefined,
    enabled: undefined,
    id: undefined,
    lastUpdatedDate: undefined,
    name: undefined,
    stageKeys: undefined,
    tags: undefined,
    value: undefined,
  };
  const data: any = await parseBody(output.body, context);
  if (data.createdDate !== undefined) {
    contents.createdDate = new Date(data.createdDate % 1 != 0 ? Math.round(data.createdDate * 1000) : data.createdDate);
  }
  if (data.customerId !== undefined) {
    contents.customerId = data.customerId;
  }
  if (data.description !== undefined) {
    contents.description = data.description;
  }
  if (data.enabled !== undefined) {
    contents.enabled = data.enabled;
  }
  if (data.id !== undefined) {
    contents.id = data.id;
  }
  if (data.lastUpdatedDate !== undefined) {
    contents.lastUpdatedDate = new Date(data.lastUpdatedDate % 1 != 0 ? Math.round(data.lastUpdatedDate * 1000) : data.lastUpdatedDate);
  }
  if (data.name !== undefined) {
    contents.name = data.name;
  }
  if (data.stageKeys !== undefined) {
    contents.stageKeys = deserializeAws_restJson1_1ListOfString(data.stageKeys, context);
  }
  if (data.tags !== undefined) {
    contents.tags = deserializeAws_restJson1_1MapOfStringToString(data.tags, context);
  }
  if (data.value !== undefined) {
    contents.value = data.value;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetApiKeyCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<GetApiKeyCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1GetApiKeysCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetApiKeysCommandOutput> {
  if (output.statusCode !== 200) {
    return deserializeAws_restJson1_1GetApiKeysCommandError(output, context);
  }
  const contents: GetApiKeysCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ApiKeys",
    items: undefined,
    position: undefined,
    warnings: undefined,
  };
  const data: any = await parseBody(output.body, context);
  if (data.item !== undefined) {
    contents.items = deserializeAws_restJson1_1ListOfApiKey(data.item, context);
  }
  if (data.position !== undefined) {
    contents.position = data.position;
  }
  if (data.warnings !== undefined) {
    contents.warnings = deserializeAws_restJson1_1ListOfString(data.warnings, context);
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetApiKeysCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<GetApiKeysCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.commonapi.exceptions#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1GetAuthorizerCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetAuthorizerCommandOutput> {
  if (output.statusCode !== 200) {
    return deserializeAws_restJson1_1GetAuthorizerCommandError(output, context);
  }
  const contents: GetAuthorizerCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "Authorizer",
    authType: undefined,
    authorizerCredentials: undefined,
    authorizerResultTtlInSeconds: undefined,
    authorizerUri: undefined,
    id: undefined,
    identitySource: undefined,
    identityValidationExpression: undefined,
    name: undefined,
    providerARNs: undefined,
    type: undefined,
  };
  const data: any = await parseBody(output.body, context);
  if (data.authType !== undefined) {
    contents.authType = data.authType;
  }
  if (data.authorizerCredentials !== undefined) {
    contents.authorizerCredentials = data.authorizerCredentials;
  }
  if (data.authorizerResultTtlInSeconds !== undefined) {
    contents.authorizerResultTtlInSeconds = data.authorizerResultTtlInSeconds;
  }
  if (data.authorizerUri !== undefined) {
    contents.authorizerUri = data.authorizerUri;
  }
  if (data.id !== undefined) {
    contents.id = data.id;
  }
  if (data.identitySource !== undefined) {
    contents.identitySource = data.identitySource;
  }
  if (data.identityValidationExpression !== undefined) {
    contents.identityValidationExpression = data.identityValidationExpression;
  }
  if (data.name !== undefined) {
    contents.name = data.name;
  }
  if (data.providerARNs !== undefined) {
    contents.providerARNs = deserializeAws_restJson1_1ListOfARNs(data.providerARNs, context);
  }
  if (data.type !== undefined) {
    contents.type = data.type;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetAuthorizerCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<GetAuthorizerCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1GetAuthorizersCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetAuthorizersCommandOutput> {
  if (output.statusCode !== 200) {
    return deserializeAws_restJson1_1GetAuthorizersCommandError(output, context);
  }
  const contents: GetAuthorizersCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "Authorizers",
    items: undefined,
    position: undefined,
  };
  const data: any = await parseBody(output.body, context);
  if (data.item !== undefined) {
    contents.items = deserializeAws_restJson1_1ListOfAuthorizer(data.item, context);
  }
  if (data.position !== undefined) {
    contents.position = data.position;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetAuthorizersCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<GetAuthorizersCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.commonapi.exceptions#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context);
      break;
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1GetBasePathMappingCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetBasePathMappingCommandOutput> {
  if (output.statusCode !== 200) {
    return deserializeAws_restJson1_1GetBasePathMappingCommandError(output, context);
  }
  const contents: GetBasePathMappingCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "BasePathMapping",
    basePath: undefined,
    restApiId: undefined,
    stage: undefined,
  };
  const data: any = await parseBody(output.body, context);
  if (data.basePath !== undefined) {
    contents.basePath = data.basePath;
  }
  if (data.restApiId !== undefined) {
    contents.restApiId = data.restApiId;
  }
  if (data.stage !== undefined) {
    contents.stage = data.stage;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetBasePathMappingCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<GetBasePathMappingCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1GetBasePathMappingsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetBasePathMappingsCommandOutput> {
  if (output.statusCode !== 200) {
    return deserializeAws_restJson1_1GetBasePathMappingsCommandError(output, context);
  }
  const contents: GetBasePathMappingsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "BasePathMappings",
    items: undefined,
    position: undefined,
  };
  const data: any = await parseBody(output.body, context);
  if (data.item !== undefined) {
    contents.items = deserializeAws_restJson1_1ListOfBasePathMapping(data.item, context);
  }
  if (data.position !== undefined) {
    contents.position = data.position;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetBasePathMappingsCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<GetBasePathMappingsCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1GetClientCertificateCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetClientCertificateCommandOutput> {
  if (output.statusCode !== 200) {
    return deserializeAws_restJson1_1GetClientCertificateCommandError(output, context);
  }
  const contents: GetClientCertificateCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ClientCertificate",
    clientCertificateId: undefined,
    createdDate: undefined,
    description: undefined,
    expirationDate: undefined,
    pemEncodedCertificate: undefined,
    tags: undefined,
  };
  const data: any = await parseBody(output.body, context);
  if (data.clientCertificateId !== undefined) {
    contents.clientCertificateId = data.clientCertificateId;
  }
  if (data.createdDate !== undefined) {
    contents.createdDate = new Date(data.createdDate % 1 != 0 ? Math.round(data.createdDate * 1000) : data.createdDate);
  }
  if (data.description !== undefined) {
    contents.description = data.description;
  }
  if (data.expirationDate !== undefined) {
    contents.expirationDate = new Date(data.expirationDate % 1 != 0 ? Math.round(data.expirationDate * 1000) : data.expirationDate);
  }
  if (data.pemEncodedCertificate !== undefined) {
    contents.pemEncodedCertificate = data.pemEncodedCertificate;
  }
  if (data.tags !== undefined) {
    contents.tags = deserializeAws_restJson1_1MapOfStringToString(data.tags, context);
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetClientCertificateCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<GetClientCertificateCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1GetClientCertificatesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetClientCertificatesCommandOutput> {
  if (output.statusCode !== 200) {
    return deserializeAws_restJson1_1GetClientCertificatesCommandError(output, context);
  }
  const contents: GetClientCertificatesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ClientCertificates",
    items: undefined,
    position: undefined,
  };
  const data: any = await parseBody(output.body, context);
  if (data.item !== undefined) {
    contents.items = deserializeAws_restJson1_1ListOfClientCertificate(data.item, context);
  }
  if (data.position !== undefined) {
    contents.position = data.position;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetClientCertificatesCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<GetClientCertificatesCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.commonapi.exceptions#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1GetDeploymentCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetDeploymentCommandOutput> {
  if (output.statusCode !== 200) {
    return deserializeAws_restJson1_1GetDeploymentCommandError(output, context);
  }
  const contents: GetDeploymentCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "Deployment",
    apiSummary: undefined,
    createdDate: undefined,
    description: undefined,
    id: undefined,
  };
  const data: any = await parseBody(output.body, context);
  if (data.apiSummary !== undefined) {
    contents.apiSummary = deserializeAws_restJson1_1PathToMapOfMethodSnapshot(data.apiSummary, context);
  }
  if (data.createdDate !== undefined) {
    contents.createdDate = new Date(data.createdDate % 1 != 0 ? Math.round(data.createdDate * 1000) : data.createdDate);
  }
  if (data.description !== undefined) {
    contents.description = data.description;
  }
  if (data.id !== undefined) {
    contents.id = data.id;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetDeploymentCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<GetDeploymentCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.commonapi.exceptions#ServiceUnavailableException":
      response = await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1GetDeploymentsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetDeploymentsCommandOutput> {
  if (output.statusCode !== 200) {
    return deserializeAws_restJson1_1GetDeploymentsCommandError(output, context);
  }
  const contents: GetDeploymentsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "Deployments",
    items: undefined,
    position: undefined,
  };
  const data: any = await parseBody(output.body, context);
  if (data.item !== undefined) {
    contents.items = deserializeAws_restJson1_1ListOfDeployment(data.item, context);
  }
  if (data.position !== undefined) {
    contents.position = data.position;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetDeploymentsCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<GetDeploymentsCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.commonapi.exceptions#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context);
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.commonapi.exceptions#ServiceUnavailableException":
      response = await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1GetDocumentationPartCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetDocumentationPartCommandOutput> {
  if (output.statusCode !== 200) {
    return deserializeAws_restJson1_1GetDocumentationPartCommandError(output, context);
  }
  const contents: GetDocumentationPartCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DocumentationPart",
    id: undefined,
    location: undefined,
    properties: undefined,
  };
  const data: any = await parseBody(output.body, context);
  if (data.id !== undefined) {
    contents.id = data.id;
  }
  if (data.location !== undefined) {
    contents.location = deserializeAws_restJson1_1DocumentationPartLocation(data.location, context);
  }
  if (data.properties !== undefined) {
    contents.properties = data.properties;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetDocumentationPartCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<GetDocumentationPartCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1GetDocumentationPartsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetDocumentationPartsCommandOutput> {
  if (output.statusCode !== 200) {
    return deserializeAws_restJson1_1GetDocumentationPartsCommandError(output, context);
  }
  const contents: GetDocumentationPartsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DocumentationParts",
    items: undefined,
    position: undefined,
  };
  const data: any = await parseBody(output.body, context);
  if (data.item !== undefined) {
    contents.items = deserializeAws_restJson1_1ListOfDocumentationPart(data.item, context);
  }
  if (data.position !== undefined) {
    contents.position = data.position;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetDocumentationPartsCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<GetDocumentationPartsCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.commonapi.exceptions#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context);
      break;
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1GetDocumentationVersionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetDocumentationVersionCommandOutput> {
  if (output.statusCode !== 200) {
    return deserializeAws_restJson1_1GetDocumentationVersionCommandError(output, context);
  }
  const contents: GetDocumentationVersionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DocumentationVersion",
    createdDate: undefined,
    description: undefined,
    version: undefined,
  };
  const data: any = await parseBody(output.body, context);
  if (data.createdDate !== undefined) {
    contents.createdDate = new Date(data.createdDate % 1 != 0 ? Math.round(data.createdDate * 1000) : data.createdDate);
  }
  if (data.description !== undefined) {
    contents.description = data.description;
  }
  if (data.version !== undefined) {
    contents.version = data.version;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetDocumentationVersionCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<GetDocumentationVersionCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1GetDocumentationVersionsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetDocumentationVersionsCommandOutput> {
  if (output.statusCode !== 200) {
    return deserializeAws_restJson1_1GetDocumentationVersionsCommandError(output, context);
  }
  const contents: GetDocumentationVersionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DocumentationVersions",
    items: undefined,
    position: undefined,
  };
  const data: any = await parseBody(output.body, context);
  if (data.item !== undefined) {
    contents.items = deserializeAws_restJson1_1ListOfDocumentationVersion(data.item, context);
  }
  if (data.position !== undefined) {
    contents.position = data.position;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetDocumentationVersionsCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<GetDocumentationVersionsCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.commonapi.exceptions#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context);
      break;
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1GetDomainNameCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetDomainNameCommandOutput> {
  if (output.statusCode !== 200) {
    return deserializeAws_restJson1_1GetDomainNameCommandError(output, context);
  }
  const contents: GetDomainNameCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DomainName",
    certificateArn: undefined,
    certificateName: undefined,
    certificateUploadDate: undefined,
    distributionDomainName: undefined,
    distributionHostedZoneId: undefined,
    domainName: undefined,
    domainNameStatus: undefined,
    domainNameStatusMessage: undefined,
    endpointConfiguration: undefined,
    regionalCertificateArn: undefined,
    regionalCertificateName: undefined,
    regionalDomainName: undefined,
    regionalHostedZoneId: undefined,
    securityPolicy: undefined,
    tags: undefined,
  };
  const data: any = await parseBody(output.body, context);
  if (data.certificateArn !== undefined) {
    contents.certificateArn = data.certificateArn;
  }
  if (data.certificateName !== undefined) {
    contents.certificateName = data.certificateName;
  }
  if (data.certificateUploadDate !== undefined) {
    contents.certificateUploadDate = new Date(data.certificateUploadDate % 1 != 0 ? Math.round(data.certificateUploadDate * 1000) : data.certificateUploadDate);
  }
  if (data.distributionDomainName !== undefined) {
    contents.distributionDomainName = data.distributionDomainName;
  }
  if (data.distributionHostedZoneId !== undefined) {
    contents.distributionHostedZoneId = data.distributionHostedZoneId;
  }
  if (data.domainName !== undefined) {
    contents.domainName = data.domainName;
  }
  if (data.domainNameStatus !== undefined) {
    contents.domainNameStatus = data.domainNameStatus;
  }
  if (data.domainNameStatusMessage !== undefined) {
    contents.domainNameStatusMessage = data.domainNameStatusMessage;
  }
  if (data.endpointConfiguration !== undefined) {
    contents.endpointConfiguration = deserializeAws_restJson1_1EndpointConfiguration(data.endpointConfiguration, context);
  }
  if (data.regionalCertificateArn !== undefined) {
    contents.regionalCertificateArn = data.regionalCertificateArn;
  }
  if (data.regionalCertificateName !== undefined) {
    contents.regionalCertificateName = data.regionalCertificateName;
  }
  if (data.regionalDomainName !== undefined) {
    contents.regionalDomainName = data.regionalDomainName;
  }
  if (data.regionalHostedZoneId !== undefined) {
    contents.regionalHostedZoneId = data.regionalHostedZoneId;
  }
  if (data.securityPolicy !== undefined) {
    contents.securityPolicy = data.securityPolicy;
  }
  if (data.tags !== undefined) {
    contents.tags = deserializeAws_restJson1_1MapOfStringToString(data.tags, context);
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetDomainNameCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<GetDomainNameCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.commonapi.exceptions#ServiceUnavailableException":
      response = await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1GetDomainNamesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetDomainNamesCommandOutput> {
  if (output.statusCode !== 200) {
    return deserializeAws_restJson1_1GetDomainNamesCommandError(output, context);
  }
  const contents: GetDomainNamesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DomainNames",
    items: undefined,
    position: undefined,
  };
  const data: any = await parseBody(output.body, context);
  if (data.item !== undefined) {
    contents.items = deserializeAws_restJson1_1ListOfDomainName(data.item, context);
  }
  if (data.position !== undefined) {
    contents.position = data.position;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetDomainNamesCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<GetDomainNamesCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.commonapi.exceptions#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1GetExportCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetExportCommandOutput> {
  if (output.statusCode !== 200) {
    return deserializeAws_restJson1_1GetExportCommandError(output, context);
  }
  const contents: GetExportCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ExportResponse",
    body: undefined,
    contentDisposition: undefined,
    contentType: undefined,
  };
  if (output.headers["Content-Disposition"] !== undefined) {
    contents.contentDisposition = output.headers['Content-Disposition'];
  }
  if (output.headers["Content-Type"] !== undefined) {
    contents.contentType = output.headers['Content-Type'];
  }
  const data: any = await parseBody(output.body, context);
  contents.body = data;
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetExportCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<GetExportCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.commonapi.exceptions#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context);
      break;
    case "ConflictException":
    case "com.amazonaws.commonapi.exceptions#ConflictException":
      response = await deserializeAws_restJson1_1ConflictExceptionResponse(parsedOutput, context);
      break;
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1GetGatewayResponseCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetGatewayResponseCommandOutput> {
  if (output.statusCode !== 200) {
    return deserializeAws_restJson1_1GetGatewayResponseCommandError(output, context);
  }
  const contents: GetGatewayResponseCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GatewayResponse",
    defaultResponse: undefined,
    responseParameters: undefined,
    responseTemplates: undefined,
    responseType: undefined,
    statusCode: undefined,
  };
  const data: any = await parseBody(output.body, context);
  if (data.defaultResponse !== undefined) {
    contents.defaultResponse = data.defaultResponse;
  }
  if (data.responseParameters !== undefined) {
    contents.responseParameters = deserializeAws_restJson1_1MapOfStringToString(data.responseParameters, context);
  }
  if (data.responseTemplates !== undefined) {
    contents.responseTemplates = deserializeAws_restJson1_1MapOfStringToString(data.responseTemplates, context);
  }
  if (data.responseType !== undefined) {
    contents.responseType = data.responseType;
  }
  if (data.statusCode !== undefined) {
    contents.statusCode = data.statusCode;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetGatewayResponseCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<GetGatewayResponseCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1GetGatewayResponsesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetGatewayResponsesCommandOutput> {
  if (output.statusCode !== 200) {
    return deserializeAws_restJson1_1GetGatewayResponsesCommandError(output, context);
  }
  const contents: GetGatewayResponsesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GatewayResponses",
    items: undefined,
    position: undefined,
  };
  const data: any = await parseBody(output.body, context);
  if (data.item !== undefined) {
    contents.items = deserializeAws_restJson1_1ListOfGatewayResponse(data.item, context);
  }
  if (data.position !== undefined) {
    contents.position = data.position;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetGatewayResponsesCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<GetGatewayResponsesCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.commonapi.exceptions#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context);
      break;
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1GetIntegrationCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetIntegrationCommandOutput> {
  if (output.statusCode !== 200) {
    return deserializeAws_restJson1_1GetIntegrationCommandError(output, context);
  }
  const contents: GetIntegrationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "Integration",
    cacheKeyParameters: undefined,
    cacheNamespace: undefined,
    connectionId: undefined,
    connectionType: undefined,
    contentHandling: undefined,
    credentials: undefined,
    httpMethod: undefined,
    integrationResponses: undefined,
    passthroughBehavior: undefined,
    requestParameters: undefined,
    requestTemplates: undefined,
    timeoutInMillis: undefined,
    type: undefined,
    uri: undefined,
  };
  const data: any = await parseBody(output.body, context);
  if (data.cacheKeyParameters !== undefined) {
    contents.cacheKeyParameters = deserializeAws_restJson1_1ListOfString(data.cacheKeyParameters, context);
  }
  if (data.cacheNamespace !== undefined) {
    contents.cacheNamespace = data.cacheNamespace;
  }
  if (data.connectionId !== undefined) {
    contents.connectionId = data.connectionId;
  }
  if (data.connectionType !== undefined) {
    contents.connectionType = data.connectionType;
  }
  if (data.contentHandling !== undefined) {
    contents.contentHandling = data.contentHandling;
  }
  if (data.credentials !== undefined) {
    contents.credentials = data.credentials;
  }
  if (data.httpMethod !== undefined) {
    contents.httpMethod = data.httpMethod;
  }
  if (data.integrationResponses !== undefined) {
    contents.integrationResponses = deserializeAws_restJson1_1MapOfIntegrationResponse(data.integrationResponses, context);
  }
  if (data.passthroughBehavior !== undefined) {
    contents.passthroughBehavior = data.passthroughBehavior;
  }
  if (data.requestParameters !== undefined) {
    contents.requestParameters = deserializeAws_restJson1_1MapOfStringToString(data.requestParameters, context);
  }
  if (data.requestTemplates !== undefined) {
    contents.requestTemplates = deserializeAws_restJson1_1MapOfStringToString(data.requestTemplates, context);
  }
  if (data.timeoutInMillis !== undefined) {
    contents.timeoutInMillis = data.timeoutInMillis;
  }
  if (data.type !== undefined) {
    contents.type = data.type;
  }
  if (data.uri !== undefined) {
    contents.uri = data.uri;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetIntegrationCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<GetIntegrationCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1GetIntegrationResponseCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetIntegrationResponseCommandOutput> {
  if (output.statusCode !== 200) {
    return deserializeAws_restJson1_1GetIntegrationResponseCommandError(output, context);
  }
  const contents: GetIntegrationResponseCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "IntegrationResponse",
    contentHandling: undefined,
    responseParameters: undefined,
    responseTemplates: undefined,
    selectionPattern: undefined,
    statusCode: undefined,
  };
  const data: any = await parseBody(output.body, context);
  if (data.contentHandling !== undefined) {
    contents.contentHandling = data.contentHandling;
  }
  if (data.responseParameters !== undefined) {
    contents.responseParameters = deserializeAws_restJson1_1MapOfStringToString(data.responseParameters, context);
  }
  if (data.responseTemplates !== undefined) {
    contents.responseTemplates = deserializeAws_restJson1_1MapOfStringToString(data.responseTemplates, context);
  }
  if (data.selectionPattern !== undefined) {
    contents.selectionPattern = data.selectionPattern;
  }
  if (data.statusCode !== undefined) {
    contents.statusCode = data.statusCode;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetIntegrationResponseCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<GetIntegrationResponseCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1GetMethodCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetMethodCommandOutput> {
  if (output.statusCode !== 200) {
    return deserializeAws_restJson1_1GetMethodCommandError(output, context);
  }
  const contents: GetMethodCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "Method",
    apiKeyRequired: undefined,
    authorizationScopes: undefined,
    authorizationType: undefined,
    authorizerId: undefined,
    httpMethod: undefined,
    methodIntegration: undefined,
    methodResponses: undefined,
    operationName: undefined,
    requestModels: undefined,
    requestParameters: undefined,
    requestValidatorId: undefined,
  };
  const data: any = await parseBody(output.body, context);
  if (data.apiKeyRequired !== undefined) {
    contents.apiKeyRequired = data.apiKeyRequired;
  }
  if (data.authorizationScopes !== undefined) {
    contents.authorizationScopes = deserializeAws_restJson1_1ListOfString(data.authorizationScopes, context);
  }
  if (data.authorizationType !== undefined) {
    contents.authorizationType = data.authorizationType;
  }
  if (data.authorizerId !== undefined) {
    contents.authorizerId = data.authorizerId;
  }
  if (data.httpMethod !== undefined) {
    contents.httpMethod = data.httpMethod;
  }
  if (data.methodIntegration !== undefined) {
    contents.methodIntegration = deserializeAws_restJson1_1Integration(data.methodIntegration, context);
  }
  if (data.methodResponses !== undefined) {
    contents.methodResponses = deserializeAws_restJson1_1MapOfMethodResponse(data.methodResponses, context);
  }
  if (data.operationName !== undefined) {
    contents.operationName = data.operationName;
  }
  if (data.requestModels !== undefined) {
    contents.requestModels = deserializeAws_restJson1_1MapOfStringToString(data.requestModels, context);
  }
  if (data.requestParameters !== undefined) {
    contents.requestParameters = deserializeAws_restJson1_1MapOfStringToBoolean(data.requestParameters, context);
  }
  if (data.requestValidatorId !== undefined) {
    contents.requestValidatorId = data.requestValidatorId;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetMethodCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<GetMethodCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1GetMethodResponseCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetMethodResponseCommandOutput> {
  if (output.statusCode !== 200) {
    return deserializeAws_restJson1_1GetMethodResponseCommandError(output, context);
  }
  const contents: GetMethodResponseCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "MethodResponse",
    responseModels: undefined,
    responseParameters: undefined,
    statusCode: undefined,
  };
  const data: any = await parseBody(output.body, context);
  if (data.responseModels !== undefined) {
    contents.responseModels = deserializeAws_restJson1_1MapOfStringToString(data.responseModels, context);
  }
  if (data.responseParameters !== undefined) {
    contents.responseParameters = deserializeAws_restJson1_1MapOfStringToBoolean(data.responseParameters, context);
  }
  if (data.statusCode !== undefined) {
    contents.statusCode = data.statusCode;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetMethodResponseCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<GetMethodResponseCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1GetModelCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetModelCommandOutput> {
  if (output.statusCode !== 200) {
    return deserializeAws_restJson1_1GetModelCommandError(output, context);
  }
  const contents: GetModelCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "Model",
    contentType: undefined,
    description: undefined,
    id: undefined,
    name: undefined,
    schema: undefined,
  };
  const data: any = await parseBody(output.body, context);
  if (data.contentType !== undefined) {
    contents.contentType = data.contentType;
  }
  if (data.description !== undefined) {
    contents.description = data.description;
  }
  if (data.id !== undefined) {
    contents.id = data.id;
  }
  if (data.name !== undefined) {
    contents.name = data.name;
  }
  if (data.schema !== undefined) {
    contents.schema = data.schema;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetModelCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<GetModelCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1GetModelTemplateCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetModelTemplateCommandOutput> {
  if (output.statusCode !== 200) {
    return deserializeAws_restJson1_1GetModelTemplateCommandError(output, context);
  }
  const contents: GetModelTemplateCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "Template",
    value: undefined,
  };
  const data: any = await parseBody(output.body, context);
  if (data.value !== undefined) {
    contents.value = data.value;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetModelTemplateCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<GetModelTemplateCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.commonapi.exceptions#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context);
      break;
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1GetModelsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetModelsCommandOutput> {
  if (output.statusCode !== 200) {
    return deserializeAws_restJson1_1GetModelsCommandError(output, context);
  }
  const contents: GetModelsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "Models",
    items: undefined,
    position: undefined,
  };
  const data: any = await parseBody(output.body, context);
  if (data.item !== undefined) {
    contents.items = deserializeAws_restJson1_1ListOfModel(data.item, context);
  }
  if (data.position !== undefined) {
    contents.position = data.position;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetModelsCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<GetModelsCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.commonapi.exceptions#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context);
      break;
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1GetRequestValidatorCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetRequestValidatorCommandOutput> {
  if (output.statusCode !== 200) {
    return deserializeAws_restJson1_1GetRequestValidatorCommandError(output, context);
  }
  const contents: GetRequestValidatorCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "RequestValidator",
    id: undefined,
    name: undefined,
    validateRequestBody: undefined,
    validateRequestParameters: undefined,
  };
  const data: any = await parseBody(output.body, context);
  if (data.id !== undefined) {
    contents.id = data.id;
  }
  if (data.name !== undefined) {
    contents.name = data.name;
  }
  if (data.validateRequestBody !== undefined) {
    contents.validateRequestBody = data.validateRequestBody;
  }
  if (data.validateRequestParameters !== undefined) {
    contents.validateRequestParameters = data.validateRequestParameters;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetRequestValidatorCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<GetRequestValidatorCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1GetRequestValidatorsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetRequestValidatorsCommandOutput> {
  if (output.statusCode !== 200) {
    return deserializeAws_restJson1_1GetRequestValidatorsCommandError(output, context);
  }
  const contents: GetRequestValidatorsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "RequestValidators",
    items: undefined,
    position: undefined,
  };
  const data: any = await parseBody(output.body, context);
  if (data.item !== undefined) {
    contents.items = deserializeAws_restJson1_1ListOfRequestValidator(data.item, context);
  }
  if (data.position !== undefined) {
    contents.position = data.position;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetRequestValidatorsCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<GetRequestValidatorsCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.commonapi.exceptions#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context);
      break;
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1GetResourceCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetResourceCommandOutput> {
  if (output.statusCode !== 200) {
    return deserializeAws_restJson1_1GetResourceCommandError(output, context);
  }
  const contents: GetResourceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "Resource",
    id: undefined,
    parentId: undefined,
    path: undefined,
    pathPart: undefined,
    resourceMethods: undefined,
  };
  const data: any = await parseBody(output.body, context);
  if (data.id !== undefined) {
    contents.id = data.id;
  }
  if (data.parentId !== undefined) {
    contents.parentId = data.parentId;
  }
  if (data.path !== undefined) {
    contents.path = data.path;
  }
  if (data.pathPart !== undefined) {
    contents.pathPart = data.pathPart;
  }
  if (data.resourceMethods !== undefined) {
    contents.resourceMethods = deserializeAws_restJson1_1MapOfMethod(data.resourceMethods, context);
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetResourceCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<GetResourceCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1GetResourcesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetResourcesCommandOutput> {
  if (output.statusCode !== 200) {
    return deserializeAws_restJson1_1GetResourcesCommandError(output, context);
  }
  const contents: GetResourcesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "Resources",
    items: undefined,
    position: undefined,
  };
  const data: any = await parseBody(output.body, context);
  if (data.item !== undefined) {
    contents.items = deserializeAws_restJson1_1ListOfResource(data.item, context);
  }
  if (data.position !== undefined) {
    contents.position = data.position;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetResourcesCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<GetResourcesCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.commonapi.exceptions#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context);
      break;
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1GetRestApiCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetRestApiCommandOutput> {
  if (output.statusCode !== 200) {
    return deserializeAws_restJson1_1GetRestApiCommandError(output, context);
  }
  const contents: GetRestApiCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "RestApi",
    apiKeySource: undefined,
    binaryMediaTypes: undefined,
    createdDate: undefined,
    description: undefined,
    endpointConfiguration: undefined,
    id: undefined,
    minimumCompressionSize: undefined,
    name: undefined,
    policy: undefined,
    tags: undefined,
    version: undefined,
    warnings: undefined,
  };
  const data: any = await parseBody(output.body, context);
  if (data.apiKeySource !== undefined) {
    contents.apiKeySource = data.apiKeySource;
  }
  if (data.binaryMediaTypes !== undefined) {
    contents.binaryMediaTypes = deserializeAws_restJson1_1ListOfString(data.binaryMediaTypes, context);
  }
  if (data.createdDate !== undefined) {
    contents.createdDate = new Date(data.createdDate % 1 != 0 ? Math.round(data.createdDate * 1000) : data.createdDate);
  }
  if (data.description !== undefined) {
    contents.description = data.description;
  }
  if (data.endpointConfiguration !== undefined) {
    contents.endpointConfiguration = deserializeAws_restJson1_1EndpointConfiguration(data.endpointConfiguration, context);
  }
  if (data.id !== undefined) {
    contents.id = data.id;
  }
  if (data.minimumCompressionSize !== undefined) {
    contents.minimumCompressionSize = data.minimumCompressionSize;
  }
  if (data.name !== undefined) {
    contents.name = data.name;
  }
  if (data.policy !== undefined) {
    contents.policy = data.policy;
  }
  if (data.tags !== undefined) {
    contents.tags = deserializeAws_restJson1_1MapOfStringToString(data.tags, context);
  }
  if (data.version !== undefined) {
    contents.version = data.version;
  }
  if (data.warnings !== undefined) {
    contents.warnings = deserializeAws_restJson1_1ListOfString(data.warnings, context);
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetRestApiCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<GetRestApiCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1GetRestApisCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetRestApisCommandOutput> {
  if (output.statusCode !== 200) {
    return deserializeAws_restJson1_1GetRestApisCommandError(output, context);
  }
  const contents: GetRestApisCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "RestApis",
    items: undefined,
    position: undefined,
  };
  const data: any = await parseBody(output.body, context);
  if (data.item !== undefined) {
    contents.items = deserializeAws_restJson1_1ListOfRestApi(data.item, context);
  }
  if (data.position !== undefined) {
    contents.position = data.position;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetRestApisCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<GetRestApisCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.commonapi.exceptions#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1GetSdkCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetSdkCommandOutput> {
  if (output.statusCode !== 200) {
    return deserializeAws_restJson1_1GetSdkCommandError(output, context);
  }
  const contents: GetSdkCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "SdkResponse",
    body: undefined,
    contentDisposition: undefined,
    contentType: undefined,
  };
  if (output.headers["Content-Disposition"] !== undefined) {
    contents.contentDisposition = output.headers['Content-Disposition'];
  }
  if (output.headers["Content-Type"] !== undefined) {
    contents.contentType = output.headers['Content-Type'];
  }
  const data: any = await parseBody(output.body, context);
  contents.body = data;
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetSdkCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<GetSdkCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.commonapi.exceptions#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context);
      break;
    case "ConflictException":
    case "com.amazonaws.commonapi.exceptions#ConflictException":
      response = await deserializeAws_restJson1_1ConflictExceptionResponse(parsedOutput, context);
      break;
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1GetSdkTypeCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetSdkTypeCommandOutput> {
  if (output.statusCode !== 200) {
    return deserializeAws_restJson1_1GetSdkTypeCommandError(output, context);
  }
  const contents: GetSdkTypeCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "SdkType",
    configurationProperties: undefined,
    description: undefined,
    friendlyName: undefined,
    id: undefined,
  };
  const data: any = await parseBody(output.body, context);
  if (data.configurationProperties !== undefined) {
    contents.configurationProperties = deserializeAws_restJson1_1ListOfSdkConfigurationProperty(data.configurationProperties, context);
  }
  if (data.description !== undefined) {
    contents.description = data.description;
  }
  if (data.friendlyName !== undefined) {
    contents.friendlyName = data.friendlyName;
  }
  if (data.id !== undefined) {
    contents.id = data.id;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetSdkTypeCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<GetSdkTypeCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1GetSdkTypesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetSdkTypesCommandOutput> {
  if (output.statusCode !== 200) {
    return deserializeAws_restJson1_1GetSdkTypesCommandError(output, context);
  }
  const contents: GetSdkTypesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "SdkTypes",
    items: undefined,
  };
  const data: any = await parseBody(output.body, context);
  if (data.item !== undefined) {
    contents.items = deserializeAws_restJson1_1ListOfSdkType(data.item, context);
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetSdkTypesCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<GetSdkTypesCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1GetStageCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetStageCommandOutput> {
  if (output.statusCode !== 200) {
    return deserializeAws_restJson1_1GetStageCommandError(output, context);
  }
  const contents: GetStageCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "Stage",
    accessLogSettings: undefined,
    cacheClusterEnabled: undefined,
    cacheClusterSize: undefined,
    cacheClusterStatus: undefined,
    canarySettings: undefined,
    clientCertificateId: undefined,
    createdDate: undefined,
    deploymentId: undefined,
    description: undefined,
    documentationVersion: undefined,
    lastUpdatedDate: undefined,
    methodSettings: undefined,
    stageName: undefined,
    tags: undefined,
    tracingEnabled: undefined,
    variables: undefined,
    webAclArn: undefined,
  };
  const data: any = await parseBody(output.body, context);
  if (data.accessLogSettings !== undefined) {
    contents.accessLogSettings = deserializeAws_restJson1_1AccessLogSettings(data.accessLogSettings, context);
  }
  if (data.cacheClusterEnabled !== undefined) {
    contents.cacheClusterEnabled = data.cacheClusterEnabled;
  }
  if (data.cacheClusterSize !== undefined) {
    contents.cacheClusterSize = data.cacheClusterSize;
  }
  if (data.cacheClusterStatus !== undefined) {
    contents.cacheClusterStatus = data.cacheClusterStatus;
  }
  if (data.canarySettings !== undefined) {
    contents.canarySettings = deserializeAws_restJson1_1CanarySettings(data.canarySettings, context);
  }
  if (data.clientCertificateId !== undefined) {
    contents.clientCertificateId = data.clientCertificateId;
  }
  if (data.createdDate !== undefined) {
    contents.createdDate = new Date(data.createdDate % 1 != 0 ? Math.round(data.createdDate * 1000) : data.createdDate);
  }
  if (data.deploymentId !== undefined) {
    contents.deploymentId = data.deploymentId;
  }
  if (data.description !== undefined) {
    contents.description = data.description;
  }
  if (data.documentationVersion !== undefined) {
    contents.documentationVersion = data.documentationVersion;
  }
  if (data.lastUpdatedDate !== undefined) {
    contents.lastUpdatedDate = new Date(data.lastUpdatedDate % 1 != 0 ? Math.round(data.lastUpdatedDate * 1000) : data.lastUpdatedDate);
  }
  if (data.methodSettings !== undefined) {
    contents.methodSettings = deserializeAws_restJson1_1MapOfMethodSettings(data.methodSettings, context);
  }
  if (data.stageName !== undefined) {
    contents.stageName = data.stageName;
  }
  if (data.tags !== undefined) {
    contents.tags = deserializeAws_restJson1_1MapOfStringToString(data.tags, context);
  }
  if (data.tracingEnabled !== undefined) {
    contents.tracingEnabled = data.tracingEnabled;
  }
  if (data.variables !== undefined) {
    contents.variables = deserializeAws_restJson1_1MapOfStringToString(data.variables, context);
  }
  if (data.webAclArn !== undefined) {
    contents.webAclArn = data.webAclArn;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetStageCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<GetStageCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1GetStagesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetStagesCommandOutput> {
  if (output.statusCode !== 200) {
    return deserializeAws_restJson1_1GetStagesCommandError(output, context);
  }
  const contents: GetStagesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "Stages",
    item: undefined,
  };
  const data: any = await parseBody(output.body, context);
  if (data.item !== undefined) {
    contents.item = deserializeAws_restJson1_1ListOfStage(data.item, context);
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetStagesCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<GetStagesCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1GetTagsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetTagsCommandOutput> {
  if (output.statusCode !== 200) {
    return deserializeAws_restJson1_1GetTagsCommandError(output, context);
  }
  const contents: GetTagsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "Tags",
    tags: undefined,
  };
  const data: any = await parseBody(output.body, context);
  if (data.tags !== undefined) {
    contents.tags = deserializeAws_restJson1_1MapOfStringToString(data.tags, context);
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetTagsCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<GetTagsCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.commonapi.exceptions#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context);
      break;
    case "LimitExceededException":
    case "com.amazonaws.commonapi.exceptions#LimitExceededException":
      response = await deserializeAws_restJson1_1LimitExceededExceptionResponse(parsedOutput, context);
      break;
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1GetUsageCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetUsageCommandOutput> {
  if (output.statusCode !== 200) {
    return deserializeAws_restJson1_1GetUsageCommandError(output, context);
  }
  const contents: GetUsageCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "Usage",
    endDate: undefined,
    items: undefined,
    position: undefined,
    startDate: undefined,
    usagePlanId: undefined,
  };
  const data: any = await parseBody(output.body, context);
  if (data.endDate !== undefined) {
    contents.endDate = data.endDate;
  }
  if (data.values !== undefined) {
    contents.items = deserializeAws_restJson1_1MapOfKeyUsages(data.values, context);
  }
  if (data.position !== undefined) {
    contents.position = data.position;
  }
  if (data.startDate !== undefined) {
    contents.startDate = data.startDate;
  }
  if (data.usagePlanId !== undefined) {
    contents.usagePlanId = data.usagePlanId;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetUsageCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<GetUsageCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.commonapi.exceptions#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context);
      break;
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1GetUsagePlanCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetUsagePlanCommandOutput> {
  if (output.statusCode !== 200) {
    return deserializeAws_restJson1_1GetUsagePlanCommandError(output, context);
  }
  const contents: GetUsagePlanCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UsagePlan",
    apiStages: undefined,
    description: undefined,
    id: undefined,
    name: undefined,
    productCode: undefined,
    quota: undefined,
    tags: undefined,
    throttle: undefined,
  };
  const data: any = await parseBody(output.body, context);
  if (data.apiStages !== undefined) {
    contents.apiStages = deserializeAws_restJson1_1ListOfApiStage(data.apiStages, context);
  }
  if (data.description !== undefined) {
    contents.description = data.description;
  }
  if (data.id !== undefined) {
    contents.id = data.id;
  }
  if (data.name !== undefined) {
    contents.name = data.name;
  }
  if (data.productCode !== undefined) {
    contents.productCode = data.productCode;
  }
  if (data.quota !== undefined) {
    contents.quota = deserializeAws_restJson1_1QuotaSettings(data.quota, context);
  }
  if (data.tags !== undefined) {
    contents.tags = deserializeAws_restJson1_1MapOfStringToString(data.tags, context);
  }
  if (data.throttle !== undefined) {
    contents.throttle = deserializeAws_restJson1_1ThrottleSettings(data.throttle, context);
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetUsagePlanCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<GetUsagePlanCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.commonapi.exceptions#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context);
      break;
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1GetUsagePlanKeyCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetUsagePlanKeyCommandOutput> {
  if (output.statusCode !== 200) {
    return deserializeAws_restJson1_1GetUsagePlanKeyCommandError(output, context);
  }
  const contents: GetUsagePlanKeyCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UsagePlanKey",
    id: undefined,
    name: undefined,
    type: undefined,
    value: undefined,
  };
  const data: any = await parseBody(output.body, context);
  if (data.id !== undefined) {
    contents.id = data.id;
  }
  if (data.name !== undefined) {
    contents.name = data.name;
  }
  if (data.type !== undefined) {
    contents.type = data.type;
  }
  if (data.value !== undefined) {
    contents.value = data.value;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetUsagePlanKeyCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<GetUsagePlanKeyCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.commonapi.exceptions#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context);
      break;
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1GetUsagePlanKeysCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetUsagePlanKeysCommandOutput> {
  if (output.statusCode !== 200) {
    return deserializeAws_restJson1_1GetUsagePlanKeysCommandError(output, context);
  }
  const contents: GetUsagePlanKeysCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UsagePlanKeys",
    items: undefined,
    position: undefined,
  };
  const data: any = await parseBody(output.body, context);
  if (data.item !== undefined) {
    contents.items = deserializeAws_restJson1_1ListOfUsagePlanKey(data.item, context);
  }
  if (data.position !== undefined) {
    contents.position = data.position;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetUsagePlanKeysCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<GetUsagePlanKeysCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.commonapi.exceptions#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context);
      break;
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1GetUsagePlansCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetUsagePlansCommandOutput> {
  if (output.statusCode !== 200) {
    return deserializeAws_restJson1_1GetUsagePlansCommandError(output, context);
  }
  const contents: GetUsagePlansCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UsagePlans",
    items: undefined,
    position: undefined,
  };
  const data: any = await parseBody(output.body, context);
  if (data.item !== undefined) {
    contents.items = deserializeAws_restJson1_1ListOfUsagePlan(data.item, context);
  }
  if (data.position !== undefined) {
    contents.position = data.position;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetUsagePlansCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<GetUsagePlansCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.commonapi.exceptions#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context);
      break;
    case "ConflictException":
    case "com.amazonaws.commonapi.exceptions#ConflictException":
      response = await deserializeAws_restJson1_1ConflictExceptionResponse(parsedOutput, context);
      break;
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1GetVpcLinkCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetVpcLinkCommandOutput> {
  if (output.statusCode !== 200) {
    return deserializeAws_restJson1_1GetVpcLinkCommandError(output, context);
  }
  const contents: GetVpcLinkCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "VpcLink",
    description: undefined,
    id: undefined,
    name: undefined,
    status: undefined,
    statusMessage: undefined,
    tags: undefined,
    targetArns: undefined,
  };
  const data: any = await parseBody(output.body, context);
  if (data.description !== undefined) {
    contents.description = data.description;
  }
  if (data.id !== undefined) {
    contents.id = data.id;
  }
  if (data.name !== undefined) {
    contents.name = data.name;
  }
  if (data.status !== undefined) {
    contents.status = data.status;
  }
  if (data.statusMessage !== undefined) {
    contents.statusMessage = data.statusMessage;
  }
  if (data.tags !== undefined) {
    contents.tags = deserializeAws_restJson1_1MapOfStringToString(data.tags, context);
  }
  if (data.targetArns !== undefined) {
    contents.targetArns = deserializeAws_restJson1_1ListOfString(data.targetArns, context);
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetVpcLinkCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<GetVpcLinkCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1GetVpcLinksCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetVpcLinksCommandOutput> {
  if (output.statusCode !== 200) {
    return deserializeAws_restJson1_1GetVpcLinksCommandError(output, context);
  }
  const contents: GetVpcLinksCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "VpcLinks",
    items: undefined,
    position: undefined,
  };
  const data: any = await parseBody(output.body, context);
  if (data.item !== undefined) {
    contents.items = deserializeAws_restJson1_1ListOfVpcLink(data.item, context);
  }
  if (data.position !== undefined) {
    contents.position = data.position;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetVpcLinksCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<GetVpcLinksCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.commonapi.exceptions#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1ImportApiKeysCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ImportApiKeysCommandOutput> {
  if (output.statusCode !== 201) {
    return deserializeAws_restJson1_1ImportApiKeysCommandError(output, context);
  }
  const contents: ImportApiKeysCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ApiKeyIds",
    ids: undefined,
    warnings: undefined,
  };
  const data: any = await parseBody(output.body, context);
  if (data.ids !== undefined) {
    contents.ids = deserializeAws_restJson1_1ListOfString(data.ids, context);
  }
  if (data.warnings !== undefined) {
    contents.warnings = deserializeAws_restJson1_1ListOfString(data.warnings, context);
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1ImportApiKeysCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<ImportApiKeysCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.commonapi.exceptions#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context);
      break;
    case "ConflictException":
    case "com.amazonaws.commonapi.exceptions#ConflictException":
      response = await deserializeAws_restJson1_1ConflictExceptionResponse(parsedOutput, context);
      break;
    case "LimitExceededException":
    case "com.amazonaws.commonapi.exceptions#LimitExceededException":
      response = await deserializeAws_restJson1_1LimitExceededExceptionResponse(parsedOutput, context);
      break;
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1ImportDocumentationPartsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ImportDocumentationPartsCommandOutput> {
  if (output.statusCode !== 200) {
    return deserializeAws_restJson1_1ImportDocumentationPartsCommandError(output, context);
  }
  const contents: ImportDocumentationPartsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DocumentationPartIds",
    ids: undefined,
    warnings: undefined,
  };
  const data: any = await parseBody(output.body, context);
  if (data.ids !== undefined) {
    contents.ids = deserializeAws_restJson1_1ListOfString(data.ids, context);
  }
  if (data.warnings !== undefined) {
    contents.warnings = deserializeAws_restJson1_1ListOfString(data.warnings, context);
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1ImportDocumentationPartsCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<ImportDocumentationPartsCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.commonapi.exceptions#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context);
      break;
    case "LimitExceededException":
    case "com.amazonaws.commonapi.exceptions#LimitExceededException":
      response = await deserializeAws_restJson1_1LimitExceededExceptionResponse(parsedOutput, context);
      break;
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1ImportRestApiCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ImportRestApiCommandOutput> {
  if (output.statusCode !== 201) {
    return deserializeAws_restJson1_1ImportRestApiCommandError(output, context);
  }
  const contents: ImportRestApiCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "RestApi",
    apiKeySource: undefined,
    binaryMediaTypes: undefined,
    createdDate: undefined,
    description: undefined,
    endpointConfiguration: undefined,
    id: undefined,
    minimumCompressionSize: undefined,
    name: undefined,
    policy: undefined,
    tags: undefined,
    version: undefined,
    warnings: undefined,
  };
  const data: any = await parseBody(output.body, context);
  if (data.apiKeySource !== undefined) {
    contents.apiKeySource = data.apiKeySource;
  }
  if (data.binaryMediaTypes !== undefined) {
    contents.binaryMediaTypes = deserializeAws_restJson1_1ListOfString(data.binaryMediaTypes, context);
  }
  if (data.createdDate !== undefined) {
    contents.createdDate = new Date(data.createdDate % 1 != 0 ? Math.round(data.createdDate * 1000) : data.createdDate);
  }
  if (data.description !== undefined) {
    contents.description = data.description;
  }
  if (data.endpointConfiguration !== undefined) {
    contents.endpointConfiguration = deserializeAws_restJson1_1EndpointConfiguration(data.endpointConfiguration, context);
  }
  if (data.id !== undefined) {
    contents.id = data.id;
  }
  if (data.minimumCompressionSize !== undefined) {
    contents.minimumCompressionSize = data.minimumCompressionSize;
  }
  if (data.name !== undefined) {
    contents.name = data.name;
  }
  if (data.policy !== undefined) {
    contents.policy = data.policy;
  }
  if (data.tags !== undefined) {
    contents.tags = deserializeAws_restJson1_1MapOfStringToString(data.tags, context);
  }
  if (data.version !== undefined) {
    contents.version = data.version;
  }
  if (data.warnings !== undefined) {
    contents.warnings = deserializeAws_restJson1_1ListOfString(data.warnings, context);
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1ImportRestApiCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<ImportRestApiCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.commonapi.exceptions#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context);
      break;
    case "ConflictException":
    case "com.amazonaws.commonapi.exceptions#ConflictException":
      response = await deserializeAws_restJson1_1ConflictExceptionResponse(parsedOutput, context);
      break;
    case "LimitExceededException":
    case "com.amazonaws.commonapi.exceptions#LimitExceededException":
      response = await deserializeAws_restJson1_1LimitExceededExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1PutGatewayResponseCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutGatewayResponseCommandOutput> {
  if (output.statusCode !== 201) {
    return deserializeAws_restJson1_1PutGatewayResponseCommandError(output, context);
  }
  const contents: PutGatewayResponseCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GatewayResponse",
    defaultResponse: undefined,
    responseParameters: undefined,
    responseTemplates: undefined,
    responseType: undefined,
    statusCode: undefined,
  };
  const data: any = await parseBody(output.body, context);
  if (data.defaultResponse !== undefined) {
    contents.defaultResponse = data.defaultResponse;
  }
  if (data.responseParameters !== undefined) {
    contents.responseParameters = deserializeAws_restJson1_1MapOfStringToString(data.responseParameters, context);
  }
  if (data.responseTemplates !== undefined) {
    contents.responseTemplates = deserializeAws_restJson1_1MapOfStringToString(data.responseTemplates, context);
  }
  if (data.responseType !== undefined) {
    contents.responseType = data.responseType;
  }
  if (data.statusCode !== undefined) {
    contents.statusCode = data.statusCode;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1PutGatewayResponseCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<PutGatewayResponseCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.commonapi.exceptions#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context);
      break;
    case "LimitExceededException":
    case "com.amazonaws.commonapi.exceptions#LimitExceededException":
      response = await deserializeAws_restJson1_1LimitExceededExceptionResponse(parsedOutput, context);
      break;
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1PutIntegrationCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutIntegrationCommandOutput> {
  if (output.statusCode !== 201) {
    return deserializeAws_restJson1_1PutIntegrationCommandError(output, context);
  }
  const contents: PutIntegrationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "Integration",
    cacheKeyParameters: undefined,
    cacheNamespace: undefined,
    connectionId: undefined,
    connectionType: undefined,
    contentHandling: undefined,
    credentials: undefined,
    httpMethod: undefined,
    integrationResponses: undefined,
    passthroughBehavior: undefined,
    requestParameters: undefined,
    requestTemplates: undefined,
    timeoutInMillis: undefined,
    type: undefined,
    uri: undefined,
  };
  const data: any = await parseBody(output.body, context);
  if (data.cacheKeyParameters !== undefined) {
    contents.cacheKeyParameters = deserializeAws_restJson1_1ListOfString(data.cacheKeyParameters, context);
  }
  if (data.cacheNamespace !== undefined) {
    contents.cacheNamespace = data.cacheNamespace;
  }
  if (data.connectionId !== undefined) {
    contents.connectionId = data.connectionId;
  }
  if (data.connectionType !== undefined) {
    contents.connectionType = data.connectionType;
  }
  if (data.contentHandling !== undefined) {
    contents.contentHandling = data.contentHandling;
  }
  if (data.credentials !== undefined) {
    contents.credentials = data.credentials;
  }
  if (data.httpMethod !== undefined) {
    contents.httpMethod = data.httpMethod;
  }
  if (data.integrationResponses !== undefined) {
    contents.integrationResponses = deserializeAws_restJson1_1MapOfIntegrationResponse(data.integrationResponses, context);
  }
  if (data.passthroughBehavior !== undefined) {
    contents.passthroughBehavior = data.passthroughBehavior;
  }
  if (data.requestParameters !== undefined) {
    contents.requestParameters = deserializeAws_restJson1_1MapOfStringToString(data.requestParameters, context);
  }
  if (data.requestTemplates !== undefined) {
    contents.requestTemplates = deserializeAws_restJson1_1MapOfStringToString(data.requestTemplates, context);
  }
  if (data.timeoutInMillis !== undefined) {
    contents.timeoutInMillis = data.timeoutInMillis;
  }
  if (data.type !== undefined) {
    contents.type = data.type;
  }
  if (data.uri !== undefined) {
    contents.uri = data.uri;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1PutIntegrationCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<PutIntegrationCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.commonapi.exceptions#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context);
      break;
    case "ConflictException":
    case "com.amazonaws.commonapi.exceptions#ConflictException":
      response = await deserializeAws_restJson1_1ConflictExceptionResponse(parsedOutput, context);
      break;
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1PutIntegrationResponseCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutIntegrationResponseCommandOutput> {
  if (output.statusCode !== 201) {
    return deserializeAws_restJson1_1PutIntegrationResponseCommandError(output, context);
  }
  const contents: PutIntegrationResponseCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "IntegrationResponse",
    contentHandling: undefined,
    responseParameters: undefined,
    responseTemplates: undefined,
    selectionPattern: undefined,
    statusCode: undefined,
  };
  const data: any = await parseBody(output.body, context);
  if (data.contentHandling !== undefined) {
    contents.contentHandling = data.contentHandling;
  }
  if (data.responseParameters !== undefined) {
    contents.responseParameters = deserializeAws_restJson1_1MapOfStringToString(data.responseParameters, context);
  }
  if (data.responseTemplates !== undefined) {
    contents.responseTemplates = deserializeAws_restJson1_1MapOfStringToString(data.responseTemplates, context);
  }
  if (data.selectionPattern !== undefined) {
    contents.selectionPattern = data.selectionPattern;
  }
  if (data.statusCode !== undefined) {
    contents.statusCode = data.statusCode;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1PutIntegrationResponseCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<PutIntegrationResponseCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.commonapi.exceptions#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context);
      break;
    case "ConflictException":
    case "com.amazonaws.commonapi.exceptions#ConflictException":
      response = await deserializeAws_restJson1_1ConflictExceptionResponse(parsedOutput, context);
      break;
    case "LimitExceededException":
    case "com.amazonaws.commonapi.exceptions#LimitExceededException":
      response = await deserializeAws_restJson1_1LimitExceededExceptionResponse(parsedOutput, context);
      break;
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1PutMethodCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutMethodCommandOutput> {
  if (output.statusCode !== 201) {
    return deserializeAws_restJson1_1PutMethodCommandError(output, context);
  }
  const contents: PutMethodCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "Method",
    apiKeyRequired: undefined,
    authorizationScopes: undefined,
    authorizationType: undefined,
    authorizerId: undefined,
    httpMethod: undefined,
    methodIntegration: undefined,
    methodResponses: undefined,
    operationName: undefined,
    requestModels: undefined,
    requestParameters: undefined,
    requestValidatorId: undefined,
  };
  const data: any = await parseBody(output.body, context);
  if (data.apiKeyRequired !== undefined) {
    contents.apiKeyRequired = data.apiKeyRequired;
  }
  if (data.authorizationScopes !== undefined) {
    contents.authorizationScopes = deserializeAws_restJson1_1ListOfString(data.authorizationScopes, context);
  }
  if (data.authorizationType !== undefined) {
    contents.authorizationType = data.authorizationType;
  }
  if (data.authorizerId !== undefined) {
    contents.authorizerId = data.authorizerId;
  }
  if (data.httpMethod !== undefined) {
    contents.httpMethod = data.httpMethod;
  }
  if (data.methodIntegration !== undefined) {
    contents.methodIntegration = deserializeAws_restJson1_1Integration(data.methodIntegration, context);
  }
  if (data.methodResponses !== undefined) {
    contents.methodResponses = deserializeAws_restJson1_1MapOfMethodResponse(data.methodResponses, context);
  }
  if (data.operationName !== undefined) {
    contents.operationName = data.operationName;
  }
  if (data.requestModels !== undefined) {
    contents.requestModels = deserializeAws_restJson1_1MapOfStringToString(data.requestModels, context);
  }
  if (data.requestParameters !== undefined) {
    contents.requestParameters = deserializeAws_restJson1_1MapOfStringToBoolean(data.requestParameters, context);
  }
  if (data.requestValidatorId !== undefined) {
    contents.requestValidatorId = data.requestValidatorId;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1PutMethodCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<PutMethodCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.commonapi.exceptions#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context);
      break;
    case "ConflictException":
    case "com.amazonaws.commonapi.exceptions#ConflictException":
      response = await deserializeAws_restJson1_1ConflictExceptionResponse(parsedOutput, context);
      break;
    case "LimitExceededException":
    case "com.amazonaws.commonapi.exceptions#LimitExceededException":
      response = await deserializeAws_restJson1_1LimitExceededExceptionResponse(parsedOutput, context);
      break;
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1PutMethodResponseCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutMethodResponseCommandOutput> {
  if (output.statusCode !== 201) {
    return deserializeAws_restJson1_1PutMethodResponseCommandError(output, context);
  }
  const contents: PutMethodResponseCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "MethodResponse",
    responseModels: undefined,
    responseParameters: undefined,
    statusCode: undefined,
  };
  const data: any = await parseBody(output.body, context);
  if (data.responseModels !== undefined) {
    contents.responseModels = deserializeAws_restJson1_1MapOfStringToString(data.responseModels, context);
  }
  if (data.responseParameters !== undefined) {
    contents.responseParameters = deserializeAws_restJson1_1MapOfStringToBoolean(data.responseParameters, context);
  }
  if (data.statusCode !== undefined) {
    contents.statusCode = data.statusCode;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1PutMethodResponseCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<PutMethodResponseCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.commonapi.exceptions#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context);
      break;
    case "ConflictException":
    case "com.amazonaws.commonapi.exceptions#ConflictException":
      response = await deserializeAws_restJson1_1ConflictExceptionResponse(parsedOutput, context);
      break;
    case "LimitExceededException":
    case "com.amazonaws.commonapi.exceptions#LimitExceededException":
      response = await deserializeAws_restJson1_1LimitExceededExceptionResponse(parsedOutput, context);
      break;
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1PutRestApiCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutRestApiCommandOutput> {
  if (output.statusCode !== 200) {
    return deserializeAws_restJson1_1PutRestApiCommandError(output, context);
  }
  const contents: PutRestApiCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "RestApi",
    apiKeySource: undefined,
    binaryMediaTypes: undefined,
    createdDate: undefined,
    description: undefined,
    endpointConfiguration: undefined,
    id: undefined,
    minimumCompressionSize: undefined,
    name: undefined,
    policy: undefined,
    tags: undefined,
    version: undefined,
    warnings: undefined,
  };
  const data: any = await parseBody(output.body, context);
  if (data.apiKeySource !== undefined) {
    contents.apiKeySource = data.apiKeySource;
  }
  if (data.binaryMediaTypes !== undefined) {
    contents.binaryMediaTypes = deserializeAws_restJson1_1ListOfString(data.binaryMediaTypes, context);
  }
  if (data.createdDate !== undefined) {
    contents.createdDate = new Date(data.createdDate % 1 != 0 ? Math.round(data.createdDate * 1000) : data.createdDate);
  }
  if (data.description !== undefined) {
    contents.description = data.description;
  }
  if (data.endpointConfiguration !== undefined) {
    contents.endpointConfiguration = deserializeAws_restJson1_1EndpointConfiguration(data.endpointConfiguration, context);
  }
  if (data.id !== undefined) {
    contents.id = data.id;
  }
  if (data.minimumCompressionSize !== undefined) {
    contents.minimumCompressionSize = data.minimumCompressionSize;
  }
  if (data.name !== undefined) {
    contents.name = data.name;
  }
  if (data.policy !== undefined) {
    contents.policy = data.policy;
  }
  if (data.tags !== undefined) {
    contents.tags = deserializeAws_restJson1_1MapOfStringToString(data.tags, context);
  }
  if (data.version !== undefined) {
    contents.version = data.version;
  }
  if (data.warnings !== undefined) {
    contents.warnings = deserializeAws_restJson1_1ListOfString(data.warnings, context);
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1PutRestApiCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<PutRestApiCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.commonapi.exceptions#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context);
      break;
    case "ConflictException":
    case "com.amazonaws.commonapi.exceptions#ConflictException":
      response = await deserializeAws_restJson1_1ConflictExceptionResponse(parsedOutput, context);
      break;
    case "LimitExceededException":
    case "com.amazonaws.commonapi.exceptions#LimitExceededException":
      response = await deserializeAws_restJson1_1LimitExceededExceptionResponse(parsedOutput, context);
      break;
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1TagResourceCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<TagResourceCommandOutput> {
  if (output.statusCode !== 204) {
    return deserializeAws_restJson1_1TagResourceCommandError(output, context);
  }
  const contents: TagResourceCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1TagResourceCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<TagResourceCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.commonapi.exceptions#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context);
      break;
    case "ConflictException":
    case "com.amazonaws.commonapi.exceptions#ConflictException":
      response = await deserializeAws_restJson1_1ConflictExceptionResponse(parsedOutput, context);
      break;
    case "LimitExceededException":
    case "com.amazonaws.commonapi.exceptions#LimitExceededException":
      response = await deserializeAws_restJson1_1LimitExceededExceptionResponse(parsedOutput, context);
      break;
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1TestInvokeAuthorizerCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<TestInvokeAuthorizerCommandOutput> {
  if (output.statusCode !== 200) {
    return deserializeAws_restJson1_1TestInvokeAuthorizerCommandError(output, context);
  }
  const contents: TestInvokeAuthorizerCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "TestInvokeAuthorizerResponse",
    authorization: undefined,
    claims: undefined,
    clientStatus: undefined,
    latency: undefined,
    log: undefined,
    policy: undefined,
    principalId: undefined,
  };
  const data: any = await parseBody(output.body, context);
  if (data.authorization !== undefined) {
    contents.authorization = deserializeAws_restJson1_1MapOfStringToList(data.authorization, context);
  }
  if (data.claims !== undefined) {
    contents.claims = deserializeAws_restJson1_1MapOfStringToString(data.claims, context);
  }
  if (data.clientStatus !== undefined) {
    contents.clientStatus = data.clientStatus;
  }
  if (data.latency !== undefined) {
    contents.latency = data.latency;
  }
  if (data.log !== undefined) {
    contents.log = data.log;
  }
  if (data.policy !== undefined) {
    contents.policy = data.policy;
  }
  if (data.principalId !== undefined) {
    contents.principalId = data.principalId;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1TestInvokeAuthorizerCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<TestInvokeAuthorizerCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.commonapi.exceptions#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context);
      break;
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1TestInvokeMethodCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<TestInvokeMethodCommandOutput> {
  if (output.statusCode !== 200) {
    return deserializeAws_restJson1_1TestInvokeMethodCommandError(output, context);
  }
  const contents: TestInvokeMethodCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "TestInvokeMethodResponse",
    body: undefined,
    headers: undefined,
    latency: undefined,
    log: undefined,
    multiValueHeaders: undefined,
    status: undefined,
  };
  const data: any = await parseBody(output.body, context);
  if (data.body !== undefined) {
    contents.body = data.body;
  }
  if (data.headers !== undefined) {
    contents.headers = deserializeAws_restJson1_1MapOfStringToString(data.headers, context);
  }
  if (data.latency !== undefined) {
    contents.latency = data.latency;
  }
  if (data.log !== undefined) {
    contents.log = data.log;
  }
  if (data.multiValueHeaders !== undefined) {
    contents.multiValueHeaders = deserializeAws_restJson1_1MapOfStringToList(data.multiValueHeaders, context);
  }
  if (data.status !== undefined) {
    contents.status = data.status;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1TestInvokeMethodCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<TestInvokeMethodCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.commonapi.exceptions#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context);
      break;
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1UntagResourceCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UntagResourceCommandOutput> {
  if (output.statusCode !== 204) {
    return deserializeAws_restJson1_1UntagResourceCommandError(output, context);
  }
  const contents: UntagResourceCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1UntagResourceCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<UntagResourceCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.commonapi.exceptions#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context);
      break;
    case "ConflictException":
    case "com.amazonaws.commonapi.exceptions#ConflictException":
      response = await deserializeAws_restJson1_1ConflictExceptionResponse(parsedOutput, context);
      break;
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1UpdateAccountCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateAccountCommandOutput> {
  if (output.statusCode !== 200) {
    return deserializeAws_restJson1_1UpdateAccountCommandError(output, context);
  }
  const contents: UpdateAccountCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "Account",
    apiKeyVersion: undefined,
    cloudwatchRoleArn: undefined,
    features: undefined,
    throttleSettings: undefined,
  };
  const data: any = await parseBody(output.body, context);
  if (data.apiKeyVersion !== undefined) {
    contents.apiKeyVersion = data.apiKeyVersion;
  }
  if (data.cloudwatchRoleArn !== undefined) {
    contents.cloudwatchRoleArn = data.cloudwatchRoleArn;
  }
  if (data.features !== undefined) {
    contents.features = deserializeAws_restJson1_1ListOfString(data.features, context);
  }
  if (data.throttleSettings !== undefined) {
    contents.throttleSettings = deserializeAws_restJson1_1ThrottleSettings(data.throttleSettings, context);
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1UpdateAccountCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<UpdateAccountCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.commonapi.exceptions#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context);
      break;
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1UpdateApiKeyCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateApiKeyCommandOutput> {
  if (output.statusCode !== 200) {
    return deserializeAws_restJson1_1UpdateApiKeyCommandError(output, context);
  }
  const contents: UpdateApiKeyCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ApiKey",
    createdDate: undefined,
    customerId: undefined,
    description: undefined,
    enabled: undefined,
    id: undefined,
    lastUpdatedDate: undefined,
    name: undefined,
    stageKeys: undefined,
    tags: undefined,
    value: undefined,
  };
  const data: any = await parseBody(output.body, context);
  if (data.createdDate !== undefined) {
    contents.createdDate = new Date(data.createdDate % 1 != 0 ? Math.round(data.createdDate * 1000) : data.createdDate);
  }
  if (data.customerId !== undefined) {
    contents.customerId = data.customerId;
  }
  if (data.description !== undefined) {
    contents.description = data.description;
  }
  if (data.enabled !== undefined) {
    contents.enabled = data.enabled;
  }
  if (data.id !== undefined) {
    contents.id = data.id;
  }
  if (data.lastUpdatedDate !== undefined) {
    contents.lastUpdatedDate = new Date(data.lastUpdatedDate % 1 != 0 ? Math.round(data.lastUpdatedDate * 1000) : data.lastUpdatedDate);
  }
  if (data.name !== undefined) {
    contents.name = data.name;
  }
  if (data.stageKeys !== undefined) {
    contents.stageKeys = deserializeAws_restJson1_1ListOfString(data.stageKeys, context);
  }
  if (data.tags !== undefined) {
    contents.tags = deserializeAws_restJson1_1MapOfStringToString(data.tags, context);
  }
  if (data.value !== undefined) {
    contents.value = data.value;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1UpdateApiKeyCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<UpdateApiKeyCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.commonapi.exceptions#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context);
      break;
    case "ConflictException":
    case "com.amazonaws.commonapi.exceptions#ConflictException":
      response = await deserializeAws_restJson1_1ConflictExceptionResponse(parsedOutput, context);
      break;
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1UpdateAuthorizerCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateAuthorizerCommandOutput> {
  if (output.statusCode !== 200) {
    return deserializeAws_restJson1_1UpdateAuthorizerCommandError(output, context);
  }
  const contents: UpdateAuthorizerCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "Authorizer",
    authType: undefined,
    authorizerCredentials: undefined,
    authorizerResultTtlInSeconds: undefined,
    authorizerUri: undefined,
    id: undefined,
    identitySource: undefined,
    identityValidationExpression: undefined,
    name: undefined,
    providerARNs: undefined,
    type: undefined,
  };
  const data: any = await parseBody(output.body, context);
  if (data.authType !== undefined) {
    contents.authType = data.authType;
  }
  if (data.authorizerCredentials !== undefined) {
    contents.authorizerCredentials = data.authorizerCredentials;
  }
  if (data.authorizerResultTtlInSeconds !== undefined) {
    contents.authorizerResultTtlInSeconds = data.authorizerResultTtlInSeconds;
  }
  if (data.authorizerUri !== undefined) {
    contents.authorizerUri = data.authorizerUri;
  }
  if (data.id !== undefined) {
    contents.id = data.id;
  }
  if (data.identitySource !== undefined) {
    contents.identitySource = data.identitySource;
  }
  if (data.identityValidationExpression !== undefined) {
    contents.identityValidationExpression = data.identityValidationExpression;
  }
  if (data.name !== undefined) {
    contents.name = data.name;
  }
  if (data.providerARNs !== undefined) {
    contents.providerARNs = deserializeAws_restJson1_1ListOfARNs(data.providerARNs, context);
  }
  if (data.type !== undefined) {
    contents.type = data.type;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1UpdateAuthorizerCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<UpdateAuthorizerCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.commonapi.exceptions#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context);
      break;
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1UpdateBasePathMappingCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateBasePathMappingCommandOutput> {
  if (output.statusCode !== 200) {
    return deserializeAws_restJson1_1UpdateBasePathMappingCommandError(output, context);
  }
  const contents: UpdateBasePathMappingCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "BasePathMapping",
    basePath: undefined,
    restApiId: undefined,
    stage: undefined,
  };
  const data: any = await parseBody(output.body, context);
  if (data.basePath !== undefined) {
    contents.basePath = data.basePath;
  }
  if (data.restApiId !== undefined) {
    contents.restApiId = data.restApiId;
  }
  if (data.stage !== undefined) {
    contents.stage = data.stage;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1UpdateBasePathMappingCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<UpdateBasePathMappingCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.commonapi.exceptions#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context);
      break;
    case "ConflictException":
    case "com.amazonaws.commonapi.exceptions#ConflictException":
      response = await deserializeAws_restJson1_1ConflictExceptionResponse(parsedOutput, context);
      break;
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1UpdateClientCertificateCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateClientCertificateCommandOutput> {
  if (output.statusCode !== 200) {
    return deserializeAws_restJson1_1UpdateClientCertificateCommandError(output, context);
  }
  const contents: UpdateClientCertificateCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ClientCertificate",
    clientCertificateId: undefined,
    createdDate: undefined,
    description: undefined,
    expirationDate: undefined,
    pemEncodedCertificate: undefined,
    tags: undefined,
  };
  const data: any = await parseBody(output.body, context);
  if (data.clientCertificateId !== undefined) {
    contents.clientCertificateId = data.clientCertificateId;
  }
  if (data.createdDate !== undefined) {
    contents.createdDate = new Date(data.createdDate % 1 != 0 ? Math.round(data.createdDate * 1000) : data.createdDate);
  }
  if (data.description !== undefined) {
    contents.description = data.description;
  }
  if (data.expirationDate !== undefined) {
    contents.expirationDate = new Date(data.expirationDate % 1 != 0 ? Math.round(data.expirationDate * 1000) : data.expirationDate);
  }
  if (data.pemEncodedCertificate !== undefined) {
    contents.pemEncodedCertificate = data.pemEncodedCertificate;
  }
  if (data.tags !== undefined) {
    contents.tags = deserializeAws_restJson1_1MapOfStringToString(data.tags, context);
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1UpdateClientCertificateCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<UpdateClientCertificateCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.commonapi.exceptions#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context);
      break;
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1UpdateDeploymentCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateDeploymentCommandOutput> {
  if (output.statusCode !== 200) {
    return deserializeAws_restJson1_1UpdateDeploymentCommandError(output, context);
  }
  const contents: UpdateDeploymentCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "Deployment",
    apiSummary: undefined,
    createdDate: undefined,
    description: undefined,
    id: undefined,
  };
  const data: any = await parseBody(output.body, context);
  if (data.apiSummary !== undefined) {
    contents.apiSummary = deserializeAws_restJson1_1PathToMapOfMethodSnapshot(data.apiSummary, context);
  }
  if (data.createdDate !== undefined) {
    contents.createdDate = new Date(data.createdDate % 1 != 0 ? Math.round(data.createdDate * 1000) : data.createdDate);
  }
  if (data.description !== undefined) {
    contents.description = data.description;
  }
  if (data.id !== undefined) {
    contents.id = data.id;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1UpdateDeploymentCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<UpdateDeploymentCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.commonapi.exceptions#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context);
      break;
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.commonapi.exceptions#ServiceUnavailableException":
      response = await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1UpdateDocumentationPartCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateDocumentationPartCommandOutput> {
  if (output.statusCode !== 200) {
    return deserializeAws_restJson1_1UpdateDocumentationPartCommandError(output, context);
  }
  const contents: UpdateDocumentationPartCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DocumentationPart",
    id: undefined,
    location: undefined,
    properties: undefined,
  };
  const data: any = await parseBody(output.body, context);
  if (data.id !== undefined) {
    contents.id = data.id;
  }
  if (data.location !== undefined) {
    contents.location = deserializeAws_restJson1_1DocumentationPartLocation(data.location, context);
  }
  if (data.properties !== undefined) {
    contents.properties = data.properties;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1UpdateDocumentationPartCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<UpdateDocumentationPartCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.commonapi.exceptions#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context);
      break;
    case "ConflictException":
    case "com.amazonaws.commonapi.exceptions#ConflictException":
      response = await deserializeAws_restJson1_1ConflictExceptionResponse(parsedOutput, context);
      break;
    case "LimitExceededException":
    case "com.amazonaws.commonapi.exceptions#LimitExceededException":
      response = await deserializeAws_restJson1_1LimitExceededExceptionResponse(parsedOutput, context);
      break;
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1UpdateDocumentationVersionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateDocumentationVersionCommandOutput> {
  if (output.statusCode !== 200) {
    return deserializeAws_restJson1_1UpdateDocumentationVersionCommandError(output, context);
  }
  const contents: UpdateDocumentationVersionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DocumentationVersion",
    createdDate: undefined,
    description: undefined,
    version: undefined,
  };
  const data: any = await parseBody(output.body, context);
  if (data.createdDate !== undefined) {
    contents.createdDate = new Date(data.createdDate % 1 != 0 ? Math.round(data.createdDate * 1000) : data.createdDate);
  }
  if (data.description !== undefined) {
    contents.description = data.description;
  }
  if (data.version !== undefined) {
    contents.version = data.version;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1UpdateDocumentationVersionCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<UpdateDocumentationVersionCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.commonapi.exceptions#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context);
      break;
    case "ConflictException":
    case "com.amazonaws.commonapi.exceptions#ConflictException":
      response = await deserializeAws_restJson1_1ConflictExceptionResponse(parsedOutput, context);
      break;
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1UpdateDomainNameCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateDomainNameCommandOutput> {
  if (output.statusCode !== 200) {
    return deserializeAws_restJson1_1UpdateDomainNameCommandError(output, context);
  }
  const contents: UpdateDomainNameCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DomainName",
    certificateArn: undefined,
    certificateName: undefined,
    certificateUploadDate: undefined,
    distributionDomainName: undefined,
    distributionHostedZoneId: undefined,
    domainName: undefined,
    domainNameStatus: undefined,
    domainNameStatusMessage: undefined,
    endpointConfiguration: undefined,
    regionalCertificateArn: undefined,
    regionalCertificateName: undefined,
    regionalDomainName: undefined,
    regionalHostedZoneId: undefined,
    securityPolicy: undefined,
    tags: undefined,
  };
  const data: any = await parseBody(output.body, context);
  if (data.certificateArn !== undefined) {
    contents.certificateArn = data.certificateArn;
  }
  if (data.certificateName !== undefined) {
    contents.certificateName = data.certificateName;
  }
  if (data.certificateUploadDate !== undefined) {
    contents.certificateUploadDate = new Date(data.certificateUploadDate % 1 != 0 ? Math.round(data.certificateUploadDate * 1000) : data.certificateUploadDate);
  }
  if (data.distributionDomainName !== undefined) {
    contents.distributionDomainName = data.distributionDomainName;
  }
  if (data.distributionHostedZoneId !== undefined) {
    contents.distributionHostedZoneId = data.distributionHostedZoneId;
  }
  if (data.domainName !== undefined) {
    contents.domainName = data.domainName;
  }
  if (data.domainNameStatus !== undefined) {
    contents.domainNameStatus = data.domainNameStatus;
  }
  if (data.domainNameStatusMessage !== undefined) {
    contents.domainNameStatusMessage = data.domainNameStatusMessage;
  }
  if (data.endpointConfiguration !== undefined) {
    contents.endpointConfiguration = deserializeAws_restJson1_1EndpointConfiguration(data.endpointConfiguration, context);
  }
  if (data.regionalCertificateArn !== undefined) {
    contents.regionalCertificateArn = data.regionalCertificateArn;
  }
  if (data.regionalCertificateName !== undefined) {
    contents.regionalCertificateName = data.regionalCertificateName;
  }
  if (data.regionalDomainName !== undefined) {
    contents.regionalDomainName = data.regionalDomainName;
  }
  if (data.regionalHostedZoneId !== undefined) {
    contents.regionalHostedZoneId = data.regionalHostedZoneId;
  }
  if (data.securityPolicy !== undefined) {
    contents.securityPolicy = data.securityPolicy;
  }
  if (data.tags !== undefined) {
    contents.tags = deserializeAws_restJson1_1MapOfStringToString(data.tags, context);
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1UpdateDomainNameCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<UpdateDomainNameCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.commonapi.exceptions#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context);
      break;
    case "ConflictException":
    case "com.amazonaws.commonapi.exceptions#ConflictException":
      response = await deserializeAws_restJson1_1ConflictExceptionResponse(parsedOutput, context);
      break;
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1UpdateGatewayResponseCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateGatewayResponseCommandOutput> {
  if (output.statusCode !== 200) {
    return deserializeAws_restJson1_1UpdateGatewayResponseCommandError(output, context);
  }
  const contents: UpdateGatewayResponseCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GatewayResponse",
    defaultResponse: undefined,
    responseParameters: undefined,
    responseTemplates: undefined,
    responseType: undefined,
    statusCode: undefined,
  };
  const data: any = await parseBody(output.body, context);
  if (data.defaultResponse !== undefined) {
    contents.defaultResponse = data.defaultResponse;
  }
  if (data.responseParameters !== undefined) {
    contents.responseParameters = deserializeAws_restJson1_1MapOfStringToString(data.responseParameters, context);
  }
  if (data.responseTemplates !== undefined) {
    contents.responseTemplates = deserializeAws_restJson1_1MapOfStringToString(data.responseTemplates, context);
  }
  if (data.responseType !== undefined) {
    contents.responseType = data.responseType;
  }
  if (data.statusCode !== undefined) {
    contents.statusCode = data.statusCode;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1UpdateGatewayResponseCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<UpdateGatewayResponseCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.commonapi.exceptions#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context);
      break;
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1UpdateIntegrationCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateIntegrationCommandOutput> {
  if (output.statusCode !== 200) {
    return deserializeAws_restJson1_1UpdateIntegrationCommandError(output, context);
  }
  const contents: UpdateIntegrationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "Integration",
    cacheKeyParameters: undefined,
    cacheNamespace: undefined,
    connectionId: undefined,
    connectionType: undefined,
    contentHandling: undefined,
    credentials: undefined,
    httpMethod: undefined,
    integrationResponses: undefined,
    passthroughBehavior: undefined,
    requestParameters: undefined,
    requestTemplates: undefined,
    timeoutInMillis: undefined,
    type: undefined,
    uri: undefined,
  };
  const data: any = await parseBody(output.body, context);
  if (data.cacheKeyParameters !== undefined) {
    contents.cacheKeyParameters = deserializeAws_restJson1_1ListOfString(data.cacheKeyParameters, context);
  }
  if (data.cacheNamespace !== undefined) {
    contents.cacheNamespace = data.cacheNamespace;
  }
  if (data.connectionId !== undefined) {
    contents.connectionId = data.connectionId;
  }
  if (data.connectionType !== undefined) {
    contents.connectionType = data.connectionType;
  }
  if (data.contentHandling !== undefined) {
    contents.contentHandling = data.contentHandling;
  }
  if (data.credentials !== undefined) {
    contents.credentials = data.credentials;
  }
  if (data.httpMethod !== undefined) {
    contents.httpMethod = data.httpMethod;
  }
  if (data.integrationResponses !== undefined) {
    contents.integrationResponses = deserializeAws_restJson1_1MapOfIntegrationResponse(data.integrationResponses, context);
  }
  if (data.passthroughBehavior !== undefined) {
    contents.passthroughBehavior = data.passthroughBehavior;
  }
  if (data.requestParameters !== undefined) {
    contents.requestParameters = deserializeAws_restJson1_1MapOfStringToString(data.requestParameters, context);
  }
  if (data.requestTemplates !== undefined) {
    contents.requestTemplates = deserializeAws_restJson1_1MapOfStringToString(data.requestTemplates, context);
  }
  if (data.timeoutInMillis !== undefined) {
    contents.timeoutInMillis = data.timeoutInMillis;
  }
  if (data.type !== undefined) {
    contents.type = data.type;
  }
  if (data.uri !== undefined) {
    contents.uri = data.uri;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1UpdateIntegrationCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<UpdateIntegrationCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.commonapi.exceptions#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context);
      break;
    case "ConflictException":
    case "com.amazonaws.commonapi.exceptions#ConflictException":
      response = await deserializeAws_restJson1_1ConflictExceptionResponse(parsedOutput, context);
      break;
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1UpdateIntegrationResponseCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateIntegrationResponseCommandOutput> {
  if (output.statusCode !== 200) {
    return deserializeAws_restJson1_1UpdateIntegrationResponseCommandError(output, context);
  }
  const contents: UpdateIntegrationResponseCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "IntegrationResponse",
    contentHandling: undefined,
    responseParameters: undefined,
    responseTemplates: undefined,
    selectionPattern: undefined,
    statusCode: undefined,
  };
  const data: any = await parseBody(output.body, context);
  if (data.contentHandling !== undefined) {
    contents.contentHandling = data.contentHandling;
  }
  if (data.responseParameters !== undefined) {
    contents.responseParameters = deserializeAws_restJson1_1MapOfStringToString(data.responseParameters, context);
  }
  if (data.responseTemplates !== undefined) {
    contents.responseTemplates = deserializeAws_restJson1_1MapOfStringToString(data.responseTemplates, context);
  }
  if (data.selectionPattern !== undefined) {
    contents.selectionPattern = data.selectionPattern;
  }
  if (data.statusCode !== undefined) {
    contents.statusCode = data.statusCode;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1UpdateIntegrationResponseCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<UpdateIntegrationResponseCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.commonapi.exceptions#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context);
      break;
    case "ConflictException":
    case "com.amazonaws.commonapi.exceptions#ConflictException":
      response = await deserializeAws_restJson1_1ConflictExceptionResponse(parsedOutput, context);
      break;
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1UpdateMethodCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateMethodCommandOutput> {
  if (output.statusCode !== 200) {
    return deserializeAws_restJson1_1UpdateMethodCommandError(output, context);
  }
  const contents: UpdateMethodCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "Method",
    apiKeyRequired: undefined,
    authorizationScopes: undefined,
    authorizationType: undefined,
    authorizerId: undefined,
    httpMethod: undefined,
    methodIntegration: undefined,
    methodResponses: undefined,
    operationName: undefined,
    requestModels: undefined,
    requestParameters: undefined,
    requestValidatorId: undefined,
  };
  const data: any = await parseBody(output.body, context);
  if (data.apiKeyRequired !== undefined) {
    contents.apiKeyRequired = data.apiKeyRequired;
  }
  if (data.authorizationScopes !== undefined) {
    contents.authorizationScopes = deserializeAws_restJson1_1ListOfString(data.authorizationScopes, context);
  }
  if (data.authorizationType !== undefined) {
    contents.authorizationType = data.authorizationType;
  }
  if (data.authorizerId !== undefined) {
    contents.authorizerId = data.authorizerId;
  }
  if (data.httpMethod !== undefined) {
    contents.httpMethod = data.httpMethod;
  }
  if (data.methodIntegration !== undefined) {
    contents.methodIntegration = deserializeAws_restJson1_1Integration(data.methodIntegration, context);
  }
  if (data.methodResponses !== undefined) {
    contents.methodResponses = deserializeAws_restJson1_1MapOfMethodResponse(data.methodResponses, context);
  }
  if (data.operationName !== undefined) {
    contents.operationName = data.operationName;
  }
  if (data.requestModels !== undefined) {
    contents.requestModels = deserializeAws_restJson1_1MapOfStringToString(data.requestModels, context);
  }
  if (data.requestParameters !== undefined) {
    contents.requestParameters = deserializeAws_restJson1_1MapOfStringToBoolean(data.requestParameters, context);
  }
  if (data.requestValidatorId !== undefined) {
    contents.requestValidatorId = data.requestValidatorId;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1UpdateMethodCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<UpdateMethodCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.commonapi.exceptions#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context);
      break;
    case "ConflictException":
    case "com.amazonaws.commonapi.exceptions#ConflictException":
      response = await deserializeAws_restJson1_1ConflictExceptionResponse(parsedOutput, context);
      break;
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1UpdateMethodResponseCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateMethodResponseCommandOutput> {
  if (output.statusCode !== 201) {
    return deserializeAws_restJson1_1UpdateMethodResponseCommandError(output, context);
  }
  const contents: UpdateMethodResponseCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "MethodResponse",
    responseModels: undefined,
    responseParameters: undefined,
    statusCode: undefined,
  };
  const data: any = await parseBody(output.body, context);
  if (data.responseModels !== undefined) {
    contents.responseModels = deserializeAws_restJson1_1MapOfStringToString(data.responseModels, context);
  }
  if (data.responseParameters !== undefined) {
    contents.responseParameters = deserializeAws_restJson1_1MapOfStringToBoolean(data.responseParameters, context);
  }
  if (data.statusCode !== undefined) {
    contents.statusCode = data.statusCode;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1UpdateMethodResponseCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<UpdateMethodResponseCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.commonapi.exceptions#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context);
      break;
    case "ConflictException":
    case "com.amazonaws.commonapi.exceptions#ConflictException":
      response = await deserializeAws_restJson1_1ConflictExceptionResponse(parsedOutput, context);
      break;
    case "LimitExceededException":
    case "com.amazonaws.commonapi.exceptions#LimitExceededException":
      response = await deserializeAws_restJson1_1LimitExceededExceptionResponse(parsedOutput, context);
      break;
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1UpdateModelCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateModelCommandOutput> {
  if (output.statusCode !== 200) {
    return deserializeAws_restJson1_1UpdateModelCommandError(output, context);
  }
  const contents: UpdateModelCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "Model",
    contentType: undefined,
    description: undefined,
    id: undefined,
    name: undefined,
    schema: undefined,
  };
  const data: any = await parseBody(output.body, context);
  if (data.contentType !== undefined) {
    contents.contentType = data.contentType;
  }
  if (data.description !== undefined) {
    contents.description = data.description;
  }
  if (data.id !== undefined) {
    contents.id = data.id;
  }
  if (data.name !== undefined) {
    contents.name = data.name;
  }
  if (data.schema !== undefined) {
    contents.schema = data.schema;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1UpdateModelCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<UpdateModelCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.commonapi.exceptions#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context);
      break;
    case "ConflictException":
    case "com.amazonaws.commonapi.exceptions#ConflictException":
      response = await deserializeAws_restJson1_1ConflictExceptionResponse(parsedOutput, context);
      break;
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1UpdateRequestValidatorCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateRequestValidatorCommandOutput> {
  if (output.statusCode !== 200) {
    return deserializeAws_restJson1_1UpdateRequestValidatorCommandError(output, context);
  }
  const contents: UpdateRequestValidatorCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "RequestValidator",
    id: undefined,
    name: undefined,
    validateRequestBody: undefined,
    validateRequestParameters: undefined,
  };
  const data: any = await parseBody(output.body, context);
  if (data.id !== undefined) {
    contents.id = data.id;
  }
  if (data.name !== undefined) {
    contents.name = data.name;
  }
  if (data.validateRequestBody !== undefined) {
    contents.validateRequestBody = data.validateRequestBody;
  }
  if (data.validateRequestParameters !== undefined) {
    contents.validateRequestParameters = data.validateRequestParameters;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1UpdateRequestValidatorCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<UpdateRequestValidatorCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.commonapi.exceptions#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context);
      break;
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1UpdateResourceCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateResourceCommandOutput> {
  if (output.statusCode !== 200) {
    return deserializeAws_restJson1_1UpdateResourceCommandError(output, context);
  }
  const contents: UpdateResourceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "Resource",
    id: undefined,
    parentId: undefined,
    path: undefined,
    pathPart: undefined,
    resourceMethods: undefined,
  };
  const data: any = await parseBody(output.body, context);
  if (data.id !== undefined) {
    contents.id = data.id;
  }
  if (data.parentId !== undefined) {
    contents.parentId = data.parentId;
  }
  if (data.path !== undefined) {
    contents.path = data.path;
  }
  if (data.pathPart !== undefined) {
    contents.pathPart = data.pathPart;
  }
  if (data.resourceMethods !== undefined) {
    contents.resourceMethods = deserializeAws_restJson1_1MapOfMethod(data.resourceMethods, context);
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1UpdateResourceCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<UpdateResourceCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.commonapi.exceptions#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context);
      break;
    case "ConflictException":
    case "com.amazonaws.commonapi.exceptions#ConflictException":
      response = await deserializeAws_restJson1_1ConflictExceptionResponse(parsedOutput, context);
      break;
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1UpdateRestApiCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateRestApiCommandOutput> {
  if (output.statusCode !== 200) {
    return deserializeAws_restJson1_1UpdateRestApiCommandError(output, context);
  }
  const contents: UpdateRestApiCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "RestApi",
    apiKeySource: undefined,
    binaryMediaTypes: undefined,
    createdDate: undefined,
    description: undefined,
    endpointConfiguration: undefined,
    id: undefined,
    minimumCompressionSize: undefined,
    name: undefined,
    policy: undefined,
    tags: undefined,
    version: undefined,
    warnings: undefined,
  };
  const data: any = await parseBody(output.body, context);
  if (data.apiKeySource !== undefined) {
    contents.apiKeySource = data.apiKeySource;
  }
  if (data.binaryMediaTypes !== undefined) {
    contents.binaryMediaTypes = deserializeAws_restJson1_1ListOfString(data.binaryMediaTypes, context);
  }
  if (data.createdDate !== undefined) {
    contents.createdDate = new Date(data.createdDate % 1 != 0 ? Math.round(data.createdDate * 1000) : data.createdDate);
  }
  if (data.description !== undefined) {
    contents.description = data.description;
  }
  if (data.endpointConfiguration !== undefined) {
    contents.endpointConfiguration = deserializeAws_restJson1_1EndpointConfiguration(data.endpointConfiguration, context);
  }
  if (data.id !== undefined) {
    contents.id = data.id;
  }
  if (data.minimumCompressionSize !== undefined) {
    contents.minimumCompressionSize = data.minimumCompressionSize;
  }
  if (data.name !== undefined) {
    contents.name = data.name;
  }
  if (data.policy !== undefined) {
    contents.policy = data.policy;
  }
  if (data.tags !== undefined) {
    contents.tags = deserializeAws_restJson1_1MapOfStringToString(data.tags, context);
  }
  if (data.version !== undefined) {
    contents.version = data.version;
  }
  if (data.warnings !== undefined) {
    contents.warnings = deserializeAws_restJson1_1ListOfString(data.warnings, context);
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1UpdateRestApiCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<UpdateRestApiCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.commonapi.exceptions#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context);
      break;
    case "ConflictException":
    case "com.amazonaws.commonapi.exceptions#ConflictException":
      response = await deserializeAws_restJson1_1ConflictExceptionResponse(parsedOutput, context);
      break;
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1UpdateStageCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateStageCommandOutput> {
  if (output.statusCode !== 200) {
    return deserializeAws_restJson1_1UpdateStageCommandError(output, context);
  }
  const contents: UpdateStageCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "Stage",
    accessLogSettings: undefined,
    cacheClusterEnabled: undefined,
    cacheClusterSize: undefined,
    cacheClusterStatus: undefined,
    canarySettings: undefined,
    clientCertificateId: undefined,
    createdDate: undefined,
    deploymentId: undefined,
    description: undefined,
    documentationVersion: undefined,
    lastUpdatedDate: undefined,
    methodSettings: undefined,
    stageName: undefined,
    tags: undefined,
    tracingEnabled: undefined,
    variables: undefined,
    webAclArn: undefined,
  };
  const data: any = await parseBody(output.body, context);
  if (data.accessLogSettings !== undefined) {
    contents.accessLogSettings = deserializeAws_restJson1_1AccessLogSettings(data.accessLogSettings, context);
  }
  if (data.cacheClusterEnabled !== undefined) {
    contents.cacheClusterEnabled = data.cacheClusterEnabled;
  }
  if (data.cacheClusterSize !== undefined) {
    contents.cacheClusterSize = data.cacheClusterSize;
  }
  if (data.cacheClusterStatus !== undefined) {
    contents.cacheClusterStatus = data.cacheClusterStatus;
  }
  if (data.canarySettings !== undefined) {
    contents.canarySettings = deserializeAws_restJson1_1CanarySettings(data.canarySettings, context);
  }
  if (data.clientCertificateId !== undefined) {
    contents.clientCertificateId = data.clientCertificateId;
  }
  if (data.createdDate !== undefined) {
    contents.createdDate = new Date(data.createdDate % 1 != 0 ? Math.round(data.createdDate * 1000) : data.createdDate);
  }
  if (data.deploymentId !== undefined) {
    contents.deploymentId = data.deploymentId;
  }
  if (data.description !== undefined) {
    contents.description = data.description;
  }
  if (data.documentationVersion !== undefined) {
    contents.documentationVersion = data.documentationVersion;
  }
  if (data.lastUpdatedDate !== undefined) {
    contents.lastUpdatedDate = new Date(data.lastUpdatedDate % 1 != 0 ? Math.round(data.lastUpdatedDate * 1000) : data.lastUpdatedDate);
  }
  if (data.methodSettings !== undefined) {
    contents.methodSettings = deserializeAws_restJson1_1MapOfMethodSettings(data.methodSettings, context);
  }
  if (data.stageName !== undefined) {
    contents.stageName = data.stageName;
  }
  if (data.tags !== undefined) {
    contents.tags = deserializeAws_restJson1_1MapOfStringToString(data.tags, context);
  }
  if (data.tracingEnabled !== undefined) {
    contents.tracingEnabled = data.tracingEnabled;
  }
  if (data.variables !== undefined) {
    contents.variables = deserializeAws_restJson1_1MapOfStringToString(data.variables, context);
  }
  if (data.webAclArn !== undefined) {
    contents.webAclArn = data.webAclArn;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1UpdateStageCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<UpdateStageCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.commonapi.exceptions#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context);
      break;
    case "ConflictException":
    case "com.amazonaws.commonapi.exceptions#ConflictException":
      response = await deserializeAws_restJson1_1ConflictExceptionResponse(parsedOutput, context);
      break;
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1UpdateUsageCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateUsageCommandOutput> {
  if (output.statusCode !== 200) {
    return deserializeAws_restJson1_1UpdateUsageCommandError(output, context);
  }
  const contents: UpdateUsageCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "Usage",
    endDate: undefined,
    items: undefined,
    position: undefined,
    startDate: undefined,
    usagePlanId: undefined,
  };
  const data: any = await parseBody(output.body, context);
  if (data.endDate !== undefined) {
    contents.endDate = data.endDate;
  }
  if (data.values !== undefined) {
    contents.items = deserializeAws_restJson1_1MapOfKeyUsages(data.values, context);
  }
  if (data.position !== undefined) {
    contents.position = data.position;
  }
  if (data.startDate !== undefined) {
    contents.startDate = data.startDate;
  }
  if (data.usagePlanId !== undefined) {
    contents.usagePlanId = data.usagePlanId;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1UpdateUsageCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<UpdateUsageCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.commonapi.exceptions#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context);
      break;
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1UpdateUsagePlanCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateUsagePlanCommandOutput> {
  if (output.statusCode !== 200) {
    return deserializeAws_restJson1_1UpdateUsagePlanCommandError(output, context);
  }
  const contents: UpdateUsagePlanCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UsagePlan",
    apiStages: undefined,
    description: undefined,
    id: undefined,
    name: undefined,
    productCode: undefined,
    quota: undefined,
    tags: undefined,
    throttle: undefined,
  };
  const data: any = await parseBody(output.body, context);
  if (data.apiStages !== undefined) {
    contents.apiStages = deserializeAws_restJson1_1ListOfApiStage(data.apiStages, context);
  }
  if (data.description !== undefined) {
    contents.description = data.description;
  }
  if (data.id !== undefined) {
    contents.id = data.id;
  }
  if (data.name !== undefined) {
    contents.name = data.name;
  }
  if (data.productCode !== undefined) {
    contents.productCode = data.productCode;
  }
  if (data.quota !== undefined) {
    contents.quota = deserializeAws_restJson1_1QuotaSettings(data.quota, context);
  }
  if (data.tags !== undefined) {
    contents.tags = deserializeAws_restJson1_1MapOfStringToString(data.tags, context);
  }
  if (data.throttle !== undefined) {
    contents.throttle = deserializeAws_restJson1_1ThrottleSettings(data.throttle, context);
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1UpdateUsagePlanCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<UpdateUsagePlanCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.commonapi.exceptions#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context);
      break;
    case "ConflictException":
    case "com.amazonaws.commonapi.exceptions#ConflictException":
      response = await deserializeAws_restJson1_1ConflictExceptionResponse(parsedOutput, context);
      break;
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_restJson1_1UpdateVpcLinkCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateVpcLinkCommandOutput> {
  if (output.statusCode !== 200) {
    return deserializeAws_restJson1_1UpdateVpcLinkCommandError(output, context);
  }
  const contents: UpdateVpcLinkCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "VpcLink",
    description: undefined,
    id: undefined,
    name: undefined,
    status: undefined,
    statusMessage: undefined,
    tags: undefined,
    targetArns: undefined,
  };
  const data: any = await parseBody(output.body, context);
  if (data.description !== undefined) {
    contents.description = data.description;
  }
  if (data.id !== undefined) {
    contents.id = data.id;
  }
  if (data.name !== undefined) {
    contents.name = data.name;
  }
  if (data.status !== undefined) {
    contents.status = data.status;
  }
  if (data.statusMessage !== undefined) {
    contents.statusMessage = data.statusMessage;
  }
  if (data.tags !== undefined) {
    contents.tags = deserializeAws_restJson1_1MapOfStringToString(data.tags, context);
  }
  if (data.targetArns !== undefined) {
    contents.targetArns = deserializeAws_restJson1_1ListOfString(data.targetArns, context);
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1UpdateVpcLinkCommandError(
  output: __HttpResponse,
  context: __SerdeContext,
): Promise<UpdateVpcLinkCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data,
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  errorCode = output.headers["x-amzn-errortype"].split(':')[0];
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.commonapi.exceptions#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(parsedOutput, context);
      break;
    case "ConflictException":
    case "com.amazonaws.commonapi.exceptions#ConflictException":
      response = await deserializeAws_restJson1_1ConflictExceptionResponse(parsedOutput, context);
      break;
    case "NotFoundException":
    case "com.amazonaws.commonapi.exceptions#NotFoundException":
      response = await deserializeAws_restJson1_1NotFoundExceptionResponse(parsedOutput, context);
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.commonapi.exceptions#TooManyRequestsException":
      response = await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(parsedOutput, context);
      break;
    case "UnauthorizedException":
    case "com.amazonaws.commonapi.exceptions#UnauthorizedException":
      response = await deserializeAws_restJson1_1UnauthorizedExceptionResponse(parsedOutput, context);
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.backplane.controlplane#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

const deserializeAws_restJson1_1BadRequestExceptionResponse = async (
  output: any,
  context: __SerdeContext
): Promise<BadRequestException> => {
  const contents: BadRequestException = {
    __type: "BadRequestException",
    $fault: "client",
    $metadata: deserializeMetadata(output),
    message: undefined,
  };
  const data: any = await parseBody(output.body, context);
  if (data.message !== undefined) {
    contents.message = data.message;
  }
  return contents;
};

const deserializeAws_restJson1_1ConflictExceptionResponse = async (
  output: any,
  context: __SerdeContext
): Promise<ConflictException> => {
  const contents: ConflictException = {
    __type: "ConflictException",
    $fault: "client",
    $metadata: deserializeMetadata(output),
    message: undefined,
  };
  const data: any = await parseBody(output.body, context);
  if (data.message !== undefined) {
    contents.message = data.message;
  }
  return contents;
};

const deserializeAws_restJson1_1LimitExceededExceptionResponse = async (
  output: any,
  context: __SerdeContext
): Promise<LimitExceededException> => {
  const contents: LimitExceededException = {
    __type: "LimitExceededException",
    $fault: "client",
    $metadata: deserializeMetadata(output),
    message: undefined,
    retryAfterSeconds: undefined,
  };
  if (output.headers["Retry-After"] !== undefined) {
    contents.retryAfterSeconds = output.headers['Retry-After'];
  }
  const data: any = await parseBody(output.body, context);
  if (data.message !== undefined) {
    contents.message = data.message;
  }
  return contents;
};

const deserializeAws_restJson1_1NotFoundExceptionResponse = async (
  output: any,
  context: __SerdeContext
): Promise<NotFoundException> => {
  const contents: NotFoundException = {
    __type: "NotFoundException",
    $fault: "client",
    $metadata: deserializeMetadata(output),
    message: undefined,
  };
  const data: any = await parseBody(output.body, context);
  if (data.message !== undefined) {
    contents.message = data.message;
  }
  return contents;
};

const deserializeAws_restJson1_1ServiceUnavailableExceptionResponse = async (
  output: any,
  context: __SerdeContext
): Promise<ServiceUnavailableException> => {
  const contents: ServiceUnavailableException = {
    __type: "ServiceUnavailableException",
    $fault: "server",
    $metadata: deserializeMetadata(output),
    message: undefined,
    retryAfterSeconds: undefined,
  };
  if (output.headers["Retry-After"] !== undefined) {
    contents.retryAfterSeconds = output.headers['Retry-After'];
  }
  const data: any = await parseBody(output.body, context);
  if (data.message !== undefined) {
    contents.message = data.message;
  }
  return contents;
};

const deserializeAws_restJson1_1TooManyRequestsExceptionResponse = async (
  output: any,
  context: __SerdeContext
): Promise<TooManyRequestsException> => {
  const contents: TooManyRequestsException = {
    __type: "TooManyRequestsException",
    $fault: "client",
    $metadata: deserializeMetadata(output),
    message: undefined,
    retryAfterSeconds: undefined,
  };
  if (output.headers["Retry-After"] !== undefined) {
    contents.retryAfterSeconds = output.headers['Retry-After'];
  }
  const data: any = await parseBody(output.body, context);
  if (data.message !== undefined) {
    contents.message = data.message;
  }
  return contents;
};

const deserializeAws_restJson1_1UnauthorizedExceptionResponse = async (
  output: any,
  context: __SerdeContext
): Promise<UnauthorizedException> => {
  const contents: UnauthorizedException = {
    __type: "UnauthorizedException",
    $fault: "client",
    $metadata: deserializeMetadata(output),
    message: undefined,
  };
  const data: any = await parseBody(output.body, context);
  if (data.message !== undefined) {
    contents.message = data.message;
  }
  return contents;
};

const serializeAws_restJson1_1ApiStage = (
  input: ApiStage,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.apiId !== undefined) {
    bodyParams['apiId'] = input.apiId;
  }
  if (input.stage !== undefined) {
    bodyParams['stage'] = input.stage;
  }
  if (input.throttle !== undefined) {
    bodyParams['throttle'] = serializeAws_restJson1_1MapOfApiStageThrottleSettings(input.throttle, context);
  }
  return bodyParams;
}

const serializeAws_restJson1_1CanarySettings = (
  input: CanarySettings,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.deploymentId !== undefined) {
    bodyParams['deploymentId'] = input.deploymentId;
  }
  if (input.percentTraffic !== undefined) {
    bodyParams['percentTraffic'] = input.percentTraffic;
  }
  if (input.stageVariableOverrides !== undefined) {
    bodyParams['stageVariableOverrides'] = serializeAws_restJson1_1MapOfStringToString(input.stageVariableOverrides, context);
  }
  if (input.useStageCache !== undefined) {
    bodyParams['useStageCache'] = input.useStageCache;
  }
  return bodyParams;
}

const serializeAws_restJson1_1DeploymentCanarySettings = (
  input: DeploymentCanarySettings,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.percentTraffic !== undefined) {
    bodyParams['percentTraffic'] = input.percentTraffic;
  }
  if (input.stageVariableOverrides !== undefined) {
    bodyParams['stageVariableOverrides'] = serializeAws_restJson1_1MapOfStringToString(input.stageVariableOverrides, context);
  }
  if (input.useStageCache !== undefined) {
    bodyParams['useStageCache'] = input.useStageCache;
  }
  return bodyParams;
}

const serializeAws_restJson1_1DocumentationPartLocation = (
  input: DocumentationPartLocation,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.method !== undefined) {
    bodyParams['method'] = input.method;
  }
  if (input.name !== undefined) {
    bodyParams['name'] = input.name;
  }
  if (input.path !== undefined) {
    bodyParams['path'] = input.path;
  }
  if (input.statusCode !== undefined) {
    bodyParams['statusCode'] = input.statusCode;
  }
  if (input.type !== undefined) {
    bodyParams['type'] = input.type;
  }
  return bodyParams;
}

const serializeAws_restJson1_1EndpointConfiguration = (
  input: EndpointConfiguration,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.types !== undefined) {
    bodyParams['types'] = serializeAws_restJson1_1ListOfEndpointType(input.types, context);
  }
  if (input.vpcEndpointIds !== undefined) {
    bodyParams['vpcEndpointIds'] = serializeAws_restJson1_1ListOfString(input.vpcEndpointIds, context);
  }
  return bodyParams;
}

const serializeAws_restJson1_1ListOfARNs = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry =>
    entry
  );
}

const serializeAws_restJson1_1ListOfApiStage = (
  input: Array<ApiStage>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry =>
    serializeAws_restJson1_1ApiStage(entry, context)
  );
}

const serializeAws_restJson1_1ListOfEndpointType = (
  input: Array<EndpointType | string>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry =>
    entry
  );
}

const serializeAws_restJson1_1ListOfStageKeys = (
  input: Array<StageKey>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry =>
    serializeAws_restJson1_1StageKey(entry, context)
  );
}

const serializeAws_restJson1_1MapOfApiStageThrottleSettings = (
  input: { [key: string]: ThrottleSettings },
  context: __SerdeContext
): any => {
  let mapParams: any = {};
  Object.keys(input).forEach(key => {
    mapParams[key] = serializeAws_restJson1_1ThrottleSettings(input[key], context);
  });
  return mapParams;
}

const serializeAws_restJson1_1MapOfStringToBoolean = (
  input: { [key: string]: boolean },
  context: __SerdeContext
): any => {
  let mapParams: any = {};
  Object.keys(input).forEach(key => {
    mapParams[key] = input[key];
  });
  return mapParams;
}

const serializeAws_restJson1_1MapOfStringToList = (
  input: { [key: string]: Array<string> },
  context: __SerdeContext
): any => {
  let mapParams: any = {};
  Object.keys(input).forEach(key => {
    mapParams[key] = serializeAws_restJson1_1ListOfString(input[key], context);
  });
  return mapParams;
}

const serializeAws_restJson1_1MapOfStringToString = (
  input: { [key: string]: string },
  context: __SerdeContext
): any => {
  let mapParams: any = {};
  Object.keys(input).forEach(key => {
    mapParams[key] = input[key];
  });
  return mapParams;
}

const serializeAws_restJson1_1QuotaSettings = (
  input: QuotaSettings,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.limit !== undefined) {
    bodyParams['limit'] = input.limit;
  }
  if (input.offset !== undefined) {
    bodyParams['offset'] = input.offset;
  }
  if (input.period !== undefined) {
    bodyParams['period'] = input.period;
  }
  return bodyParams;
}

const serializeAws_restJson1_1StageKey = (
  input: StageKey,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.restApiId !== undefined) {
    bodyParams['restApiId'] = input.restApiId;
  }
  if (input.stageName !== undefined) {
    bodyParams['stageName'] = input.stageName;
  }
  return bodyParams;
}

const serializeAws_restJson1_1ThrottleSettings = (
  input: ThrottleSettings,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.burstLimit !== undefined) {
    bodyParams['burstLimit'] = input.burstLimit;
  }
  if (input.rateLimit !== undefined) {
    bodyParams['rateLimit'] = input.rateLimit;
  }
  return bodyParams;
}

const serializeAws_restJson1_1ListOfPatchOperation = (
  input: Array<PatchOperation>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry =>
    serializeAws_restJson1_1PatchOperation(entry, context)
  );
}

const serializeAws_restJson1_1ListOfString = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry =>
    entry
  );
}

const serializeAws_restJson1_1PatchOperation = (
  input: PatchOperation,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.from !== undefined) {
    bodyParams['from'] = input.from;
  }
  if (input.op !== undefined) {
    bodyParams['op'] = input.op;
  }
  if (input.path !== undefined) {
    bodyParams['path'] = input.path;
  }
  if (input.value !== undefined) {
    bodyParams['value'] = input.value;
  }
  return bodyParams;
}

const deserializeAws_restJson1_1AccessLogSettings = (
  output: any,
  context: __SerdeContext
): AccessLogSettings => {
  let contents: any = {
    __type: "AccessLogSettings",
    destinationArn: undefined,
    format: undefined,
  };
  if (output.destinationArn !== undefined) {
    contents.destinationArn = output.destinationArn;
  }
  if (output.format !== undefined) {
    contents.format = output.format;
  }
  return contents;
}

const deserializeAws_restJson1_1ApiKey = (
  output: any,
  context: __SerdeContext
): ApiKey => {
  let contents: any = {
    __type: "ApiKey",
    createdDate: undefined,
    customerId: undefined,
    description: undefined,
    enabled: undefined,
    id: undefined,
    lastUpdatedDate: undefined,
    name: undefined,
    stageKeys: undefined,
    tags: undefined,
    value: undefined,
  };
  if (output.createdDate !== undefined) {
    contents.createdDate = new Date(output.createdDate % 1 != 0 ? Math.round(output.createdDate * 1000) : output.createdDate);
  }
  if (output.customerId !== undefined) {
    contents.customerId = output.customerId;
  }
  if (output.description !== undefined) {
    contents.description = output.description;
  }
  if (output.enabled !== undefined) {
    contents.enabled = output.enabled;
  }
  if (output.id !== undefined) {
    contents.id = output.id;
  }
  if (output.lastUpdatedDate !== undefined) {
    contents.lastUpdatedDate = new Date(output.lastUpdatedDate % 1 != 0 ? Math.round(output.lastUpdatedDate * 1000) : output.lastUpdatedDate);
  }
  if (output.name !== undefined) {
    contents.name = output.name;
  }
  if (output.stageKeys !== undefined) {
    contents.stageKeys = deserializeAws_restJson1_1ListOfString(output.stageKeys, context);
  }
  if (output.tags !== undefined) {
    contents.tags = deserializeAws_restJson1_1MapOfStringToString(output.tags, context);
  }
  if (output.value !== undefined) {
    contents.value = output.value;
  }
  return contents;
}

const deserializeAws_restJson1_1ApiStage = (
  output: any,
  context: __SerdeContext
): ApiStage => {
  let contents: any = {
    __type: "ApiStage",
    apiId: undefined,
    stage: undefined,
    throttle: undefined,
  };
  if (output.apiId !== undefined) {
    contents.apiId = output.apiId;
  }
  if (output.stage !== undefined) {
    contents.stage = output.stage;
  }
  if (output.throttle !== undefined) {
    contents.throttle = deserializeAws_restJson1_1MapOfApiStageThrottleSettings(output.throttle, context);
  }
  return contents;
}

const deserializeAws_restJson1_1Authorizer = (
  output: any,
  context: __SerdeContext
): Authorizer => {
  let contents: any = {
    __type: "Authorizer",
    authType: undefined,
    authorizerCredentials: undefined,
    authorizerResultTtlInSeconds: undefined,
    authorizerUri: undefined,
    id: undefined,
    identitySource: undefined,
    identityValidationExpression: undefined,
    name: undefined,
    providerARNs: undefined,
    type: undefined,
  };
  if (output.authType !== undefined) {
    contents.authType = output.authType;
  }
  if (output.authorizerCredentials !== undefined) {
    contents.authorizerCredentials = output.authorizerCredentials;
  }
  if (output.authorizerResultTtlInSeconds !== undefined) {
    contents.authorizerResultTtlInSeconds = output.authorizerResultTtlInSeconds;
  }
  if (output.authorizerUri !== undefined) {
    contents.authorizerUri = output.authorizerUri;
  }
  if (output.id !== undefined) {
    contents.id = output.id;
  }
  if (output.identitySource !== undefined) {
    contents.identitySource = output.identitySource;
  }
  if (output.identityValidationExpression !== undefined) {
    contents.identityValidationExpression = output.identityValidationExpression;
  }
  if (output.name !== undefined) {
    contents.name = output.name;
  }
  if (output.providerARNs !== undefined) {
    contents.providerARNs = deserializeAws_restJson1_1ListOfARNs(output.providerARNs, context);
  }
  if (output.type !== undefined) {
    contents.type = output.type;
  }
  return contents;
}

const deserializeAws_restJson1_1BasePathMapping = (
  output: any,
  context: __SerdeContext
): BasePathMapping => {
  let contents: any = {
    __type: "BasePathMapping",
    basePath: undefined,
    restApiId: undefined,
    stage: undefined,
  };
  if (output.basePath !== undefined) {
    contents.basePath = output.basePath;
  }
  if (output.restApiId !== undefined) {
    contents.restApiId = output.restApiId;
  }
  if (output.stage !== undefined) {
    contents.stage = output.stage;
  }
  return contents;
}

const deserializeAws_restJson1_1CanarySettings = (
  output: any,
  context: __SerdeContext
): CanarySettings => {
  let contents: any = {
    __type: "CanarySettings",
    deploymentId: undefined,
    percentTraffic: undefined,
    stageVariableOverrides: undefined,
    useStageCache: undefined,
  };
  if (output.deploymentId !== undefined) {
    contents.deploymentId = output.deploymentId;
  }
  if (output.percentTraffic !== undefined) {
    contents.percentTraffic = output.percentTraffic;
  }
  if (output.stageVariableOverrides !== undefined) {
    contents.stageVariableOverrides = deserializeAws_restJson1_1MapOfStringToString(output.stageVariableOverrides, context);
  }
  if (output.useStageCache !== undefined) {
    contents.useStageCache = output.useStageCache;
  }
  return contents;
}

const deserializeAws_restJson1_1ClientCertificate = (
  output: any,
  context: __SerdeContext
): ClientCertificate => {
  let contents: any = {
    __type: "ClientCertificate",
    clientCertificateId: undefined,
    createdDate: undefined,
    description: undefined,
    expirationDate: undefined,
    pemEncodedCertificate: undefined,
    tags: undefined,
  };
  if (output.clientCertificateId !== undefined) {
    contents.clientCertificateId = output.clientCertificateId;
  }
  if (output.createdDate !== undefined) {
    contents.createdDate = new Date(output.createdDate % 1 != 0 ? Math.round(output.createdDate * 1000) : output.createdDate);
  }
  if (output.description !== undefined) {
    contents.description = output.description;
  }
  if (output.expirationDate !== undefined) {
    contents.expirationDate = new Date(output.expirationDate % 1 != 0 ? Math.round(output.expirationDate * 1000) : output.expirationDate);
  }
  if (output.pemEncodedCertificate !== undefined) {
    contents.pemEncodedCertificate = output.pemEncodedCertificate;
  }
  if (output.tags !== undefined) {
    contents.tags = deserializeAws_restJson1_1MapOfStringToString(output.tags, context);
  }
  return contents;
}

const deserializeAws_restJson1_1Deployment = (
  output: any,
  context: __SerdeContext
): Deployment => {
  let contents: any = {
    __type: "Deployment",
    apiSummary: undefined,
    createdDate: undefined,
    description: undefined,
    id: undefined,
  };
  if (output.apiSummary !== undefined) {
    contents.apiSummary = deserializeAws_restJson1_1PathToMapOfMethodSnapshot(output.apiSummary, context);
  }
  if (output.createdDate !== undefined) {
    contents.createdDate = new Date(output.createdDate % 1 != 0 ? Math.round(output.createdDate * 1000) : output.createdDate);
  }
  if (output.description !== undefined) {
    contents.description = output.description;
  }
  if (output.id !== undefined) {
    contents.id = output.id;
  }
  return contents;
}

const deserializeAws_restJson1_1DocumentationPart = (
  output: any,
  context: __SerdeContext
): DocumentationPart => {
  let contents: any = {
    __type: "DocumentationPart",
    id: undefined,
    location: undefined,
    properties: undefined,
  };
  if (output.id !== undefined) {
    contents.id = output.id;
  }
  if (output.location !== undefined) {
    contents.location = deserializeAws_restJson1_1DocumentationPartLocation(output.location, context);
  }
  if (output.properties !== undefined) {
    contents.properties = output.properties;
  }
  return contents;
}

const deserializeAws_restJson1_1DocumentationPartLocation = (
  output: any,
  context: __SerdeContext
): DocumentationPartLocation => {
  let contents: any = {
    __type: "DocumentationPartLocation",
    method: undefined,
    name: undefined,
    path: undefined,
    statusCode: undefined,
    type: undefined,
  };
  if (output.method !== undefined) {
    contents.method = output.method;
  }
  if (output.name !== undefined) {
    contents.name = output.name;
  }
  if (output.path !== undefined) {
    contents.path = output.path;
  }
  if (output.statusCode !== undefined) {
    contents.statusCode = output.statusCode;
  }
  if (output.type !== undefined) {
    contents.type = output.type;
  }
  return contents;
}

const deserializeAws_restJson1_1DocumentationVersion = (
  output: any,
  context: __SerdeContext
): DocumentationVersion => {
  let contents: any = {
    __type: "DocumentationVersion",
    createdDate: undefined,
    description: undefined,
    version: undefined,
  };
  if (output.createdDate !== undefined) {
    contents.createdDate = new Date(output.createdDate % 1 != 0 ? Math.round(output.createdDate * 1000) : output.createdDate);
  }
  if (output.description !== undefined) {
    contents.description = output.description;
  }
  if (output.version !== undefined) {
    contents.version = output.version;
  }
  return contents;
}

const deserializeAws_restJson1_1DomainName = (
  output: any,
  context: __SerdeContext
): DomainName => {
  let contents: any = {
    __type: "DomainName",
    certificateArn: undefined,
    certificateName: undefined,
    certificateUploadDate: undefined,
    distributionDomainName: undefined,
    distributionHostedZoneId: undefined,
    domainName: undefined,
    domainNameStatus: undefined,
    domainNameStatusMessage: undefined,
    endpointConfiguration: undefined,
    regionalCertificateArn: undefined,
    regionalCertificateName: undefined,
    regionalDomainName: undefined,
    regionalHostedZoneId: undefined,
    securityPolicy: undefined,
    tags: undefined,
  };
  if (output.certificateArn !== undefined) {
    contents.certificateArn = output.certificateArn;
  }
  if (output.certificateName !== undefined) {
    contents.certificateName = output.certificateName;
  }
  if (output.certificateUploadDate !== undefined) {
    contents.certificateUploadDate = new Date(output.certificateUploadDate % 1 != 0 ? Math.round(output.certificateUploadDate * 1000) : output.certificateUploadDate);
  }
  if (output.distributionDomainName !== undefined) {
    contents.distributionDomainName = output.distributionDomainName;
  }
  if (output.distributionHostedZoneId !== undefined) {
    contents.distributionHostedZoneId = output.distributionHostedZoneId;
  }
  if (output.domainName !== undefined) {
    contents.domainName = output.domainName;
  }
  if (output.domainNameStatus !== undefined) {
    contents.domainNameStatus = output.domainNameStatus;
  }
  if (output.domainNameStatusMessage !== undefined) {
    contents.domainNameStatusMessage = output.domainNameStatusMessage;
  }
  if (output.endpointConfiguration !== undefined) {
    contents.endpointConfiguration = deserializeAws_restJson1_1EndpointConfiguration(output.endpointConfiguration, context);
  }
  if (output.regionalCertificateArn !== undefined) {
    contents.regionalCertificateArn = output.regionalCertificateArn;
  }
  if (output.regionalCertificateName !== undefined) {
    contents.regionalCertificateName = output.regionalCertificateName;
  }
  if (output.regionalDomainName !== undefined) {
    contents.regionalDomainName = output.regionalDomainName;
  }
  if (output.regionalHostedZoneId !== undefined) {
    contents.regionalHostedZoneId = output.regionalHostedZoneId;
  }
  if (output.securityPolicy !== undefined) {
    contents.securityPolicy = output.securityPolicy;
  }
  if (output.tags !== undefined) {
    contents.tags = deserializeAws_restJson1_1MapOfStringToString(output.tags, context);
  }
  return contents;
}

const deserializeAws_restJson1_1EndpointConfiguration = (
  output: any,
  context: __SerdeContext
): EndpointConfiguration => {
  let contents: any = {
    __type: "EndpointConfiguration",
    types: undefined,
    vpcEndpointIds: undefined,
  };
  if (output.types !== undefined) {
    contents.types = deserializeAws_restJson1_1ListOfEndpointType(output.types, context);
  }
  if (output.vpcEndpointIds !== undefined) {
    contents.vpcEndpointIds = deserializeAws_restJson1_1ListOfString(output.vpcEndpointIds, context);
  }
  return contents;
}

const deserializeAws_restJson1_1GatewayResponse = (
  output: any,
  context: __SerdeContext
): GatewayResponse => {
  let contents: any = {
    __type: "GatewayResponse",
    defaultResponse: undefined,
    responseParameters: undefined,
    responseTemplates: undefined,
    responseType: undefined,
    statusCode: undefined,
  };
  if (output.defaultResponse !== undefined) {
    contents.defaultResponse = output.defaultResponse;
  }
  if (output.responseParameters !== undefined) {
    contents.responseParameters = deserializeAws_restJson1_1MapOfStringToString(output.responseParameters, context);
  }
  if (output.responseTemplates !== undefined) {
    contents.responseTemplates = deserializeAws_restJson1_1MapOfStringToString(output.responseTemplates, context);
  }
  if (output.responseType !== undefined) {
    contents.responseType = output.responseType;
  }
  if (output.statusCode !== undefined) {
    contents.statusCode = output.statusCode;
  }
  return contents;
}

const deserializeAws_restJson1_1Integration = (
  output: any,
  context: __SerdeContext
): Integration => {
  let contents: any = {
    __type: "Integration",
    cacheKeyParameters: undefined,
    cacheNamespace: undefined,
    connectionId: undefined,
    connectionType: undefined,
    contentHandling: undefined,
    credentials: undefined,
    httpMethod: undefined,
    integrationResponses: undefined,
    passthroughBehavior: undefined,
    requestParameters: undefined,
    requestTemplates: undefined,
    timeoutInMillis: undefined,
    type: undefined,
    uri: undefined,
  };
  if (output.cacheKeyParameters !== undefined) {
    contents.cacheKeyParameters = deserializeAws_restJson1_1ListOfString(output.cacheKeyParameters, context);
  }
  if (output.cacheNamespace !== undefined) {
    contents.cacheNamespace = output.cacheNamespace;
  }
  if (output.connectionId !== undefined) {
    contents.connectionId = output.connectionId;
  }
  if (output.connectionType !== undefined) {
    contents.connectionType = output.connectionType;
  }
  if (output.contentHandling !== undefined) {
    contents.contentHandling = output.contentHandling;
  }
  if (output.credentials !== undefined) {
    contents.credentials = output.credentials;
  }
  if (output.httpMethod !== undefined) {
    contents.httpMethod = output.httpMethod;
  }
  if (output.integrationResponses !== undefined) {
    contents.integrationResponses = deserializeAws_restJson1_1MapOfIntegrationResponse(output.integrationResponses, context);
  }
  if (output.passthroughBehavior !== undefined) {
    contents.passthroughBehavior = output.passthroughBehavior;
  }
  if (output.requestParameters !== undefined) {
    contents.requestParameters = deserializeAws_restJson1_1MapOfStringToString(output.requestParameters, context);
  }
  if (output.requestTemplates !== undefined) {
    contents.requestTemplates = deserializeAws_restJson1_1MapOfStringToString(output.requestTemplates, context);
  }
  if (output.timeoutInMillis !== undefined) {
    contents.timeoutInMillis = output.timeoutInMillis;
  }
  if (output.type !== undefined) {
    contents.type = output.type;
  }
  if (output.uri !== undefined) {
    contents.uri = output.uri;
  }
  return contents;
}

const deserializeAws_restJson1_1IntegrationResponse = (
  output: any,
  context: __SerdeContext
): IntegrationResponse => {
  let contents: any = {
    __type: "IntegrationResponse",
    contentHandling: undefined,
    responseParameters: undefined,
    responseTemplates: undefined,
    selectionPattern: undefined,
    statusCode: undefined,
  };
  if (output.contentHandling !== undefined) {
    contents.contentHandling = output.contentHandling;
  }
  if (output.responseParameters !== undefined) {
    contents.responseParameters = deserializeAws_restJson1_1MapOfStringToString(output.responseParameters, context);
  }
  if (output.responseTemplates !== undefined) {
    contents.responseTemplates = deserializeAws_restJson1_1MapOfStringToString(output.responseTemplates, context);
  }
  if (output.selectionPattern !== undefined) {
    contents.selectionPattern = output.selectionPattern;
  }
  if (output.statusCode !== undefined) {
    contents.statusCode = output.statusCode;
  }
  return contents;
}

const deserializeAws_restJson1_1ListOfARNs = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) =>
    entry
  );
}

const deserializeAws_restJson1_1ListOfApiKey = (
  output: any,
  context: __SerdeContext
): Array<ApiKey> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1ApiKey(entry, context)
  );
}

const deserializeAws_restJson1_1ListOfApiStage = (
  output: any,
  context: __SerdeContext
): Array<ApiStage> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1ApiStage(entry, context)
  );
}

const deserializeAws_restJson1_1ListOfAuthorizer = (
  output: any,
  context: __SerdeContext
): Array<Authorizer> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1Authorizer(entry, context)
  );
}

const deserializeAws_restJson1_1ListOfBasePathMapping = (
  output: any,
  context: __SerdeContext
): Array<BasePathMapping> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1BasePathMapping(entry, context)
  );
}

const deserializeAws_restJson1_1ListOfClientCertificate = (
  output: any,
  context: __SerdeContext
): Array<ClientCertificate> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1ClientCertificate(entry, context)
  );
}

const deserializeAws_restJson1_1ListOfDeployment = (
  output: any,
  context: __SerdeContext
): Array<Deployment> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1Deployment(entry, context)
  );
}

const deserializeAws_restJson1_1ListOfDocumentationPart = (
  output: any,
  context: __SerdeContext
): Array<DocumentationPart> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1DocumentationPart(entry, context)
  );
}

const deserializeAws_restJson1_1ListOfDocumentationVersion = (
  output: any,
  context: __SerdeContext
): Array<DocumentationVersion> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1DocumentationVersion(entry, context)
  );
}

const deserializeAws_restJson1_1ListOfDomainName = (
  output: any,
  context: __SerdeContext
): Array<DomainName> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1DomainName(entry, context)
  );
}

const deserializeAws_restJson1_1ListOfEndpointType = (
  output: any,
  context: __SerdeContext
): Array<EndpointType | string> => {
  return (output || []).map((entry: any) =>
    entry
  );
}

const deserializeAws_restJson1_1ListOfGatewayResponse = (
  output: any,
  context: __SerdeContext
): Array<GatewayResponse> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1GatewayResponse(entry, context)
  );
}

const deserializeAws_restJson1_1ListOfLong = (
  output: any,
  context: __SerdeContext
): Array<number> => {
  return (output || []).map((entry: any) =>
    entry
  );
}

const deserializeAws_restJson1_1ListOfModel = (
  output: any,
  context: __SerdeContext
): Array<Model> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1Model(entry, context)
  );
}

const deserializeAws_restJson1_1ListOfRequestValidator = (
  output: any,
  context: __SerdeContext
): Array<RequestValidator> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1RequestValidator(entry, context)
  );
}

const deserializeAws_restJson1_1ListOfResource = (
  output: any,
  context: __SerdeContext
): Array<Resource> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1Resource(entry, context)
  );
}

const deserializeAws_restJson1_1ListOfRestApi = (
  output: any,
  context: __SerdeContext
): Array<RestApi> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1RestApi(entry, context)
  );
}

const deserializeAws_restJson1_1ListOfSdkConfigurationProperty = (
  output: any,
  context: __SerdeContext
): Array<SdkConfigurationProperty> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1SdkConfigurationProperty(entry, context)
  );
}

const deserializeAws_restJson1_1ListOfSdkType = (
  output: any,
  context: __SerdeContext
): Array<SdkType> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1SdkType(entry, context)
  );
}

const deserializeAws_restJson1_1ListOfStage = (
  output: any,
  context: __SerdeContext
): Array<Stage> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1Stage(entry, context)
  );
}

const deserializeAws_restJson1_1ListOfUsage = (
  output: any,
  context: __SerdeContext
): Array<Array<number>> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1ListOfLong(entry, context)
  );
}

const deserializeAws_restJson1_1ListOfUsagePlan = (
  output: any,
  context: __SerdeContext
): Array<UsagePlan> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1UsagePlan(entry, context)
  );
}

const deserializeAws_restJson1_1ListOfUsagePlanKey = (
  output: any,
  context: __SerdeContext
): Array<UsagePlanKey> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1UsagePlanKey(entry, context)
  );
}

const deserializeAws_restJson1_1ListOfVpcLink = (
  output: any,
  context: __SerdeContext
): Array<VpcLink> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1VpcLink(entry, context)
  );
}

const deserializeAws_restJson1_1MapOfApiStageThrottleSettings = (
  output: any,
  context: __SerdeContext
): { [key: string]: ThrottleSettings } => {
  let mapParams: any = {};
  Object.keys(output).forEach(key => {
    mapParams[key] = deserializeAws_restJson1_1ThrottleSettings(output[key], context);
  });
  return mapParams;
}

const deserializeAws_restJson1_1MapOfIntegrationResponse = (
  output: any,
  context: __SerdeContext
): { [key: string]: IntegrationResponse } => {
  let mapParams: any = {};
  Object.keys(output).forEach(key => {
    mapParams[key] = deserializeAws_restJson1_1IntegrationResponse(output[key], context);
  });
  return mapParams;
}

const deserializeAws_restJson1_1MapOfKeyUsages = (
  output: any,
  context: __SerdeContext
): { [key: string]: Array<Array<number>> } => {
  let mapParams: any = {};
  Object.keys(output).forEach(key => {
    mapParams[key] = deserializeAws_restJson1_1ListOfUsage(output[key], context);
  });
  return mapParams;
}

const deserializeAws_restJson1_1MapOfMethod = (
  output: any,
  context: __SerdeContext
): { [key: string]: Method } => {
  let mapParams: any = {};
  Object.keys(output).forEach(key => {
    mapParams[key] = deserializeAws_restJson1_1Method(output[key], context);
  });
  return mapParams;
}

const deserializeAws_restJson1_1MapOfMethodResponse = (
  output: any,
  context: __SerdeContext
): { [key: string]: MethodResponse } => {
  let mapParams: any = {};
  Object.keys(output).forEach(key => {
    mapParams[key] = deserializeAws_restJson1_1MethodResponse(output[key], context);
  });
  return mapParams;
}

const deserializeAws_restJson1_1MapOfMethodSettings = (
  output: any,
  context: __SerdeContext
): { [key: string]: MethodSetting } => {
  let mapParams: any = {};
  Object.keys(output).forEach(key => {
    mapParams[key] = deserializeAws_restJson1_1MethodSetting(output[key], context);
  });
  return mapParams;
}

const deserializeAws_restJson1_1MapOfMethodSnapshot = (
  output: any,
  context: __SerdeContext
): { [key: string]: MethodSnapshot } => {
  let mapParams: any = {};
  Object.keys(output).forEach(key => {
    mapParams[key] = deserializeAws_restJson1_1MethodSnapshot(output[key], context);
  });
  return mapParams;
}

const deserializeAws_restJson1_1MapOfStringToBoolean = (
  output: any,
  context: __SerdeContext
): { [key: string]: boolean } => {
  let mapParams: any = {};
  Object.keys(output).forEach(key => {
    mapParams[key] = output[key];
  });
  return mapParams;
}

const deserializeAws_restJson1_1MapOfStringToList = (
  output: any,
  context: __SerdeContext
): { [key: string]: Array<string> } => {
  let mapParams: any = {};
  Object.keys(output).forEach(key => {
    mapParams[key] = deserializeAws_restJson1_1ListOfString(output[key], context);
  });
  return mapParams;
}

const deserializeAws_restJson1_1MapOfStringToString = (
  output: any,
  context: __SerdeContext
): { [key: string]: string } => {
  let mapParams: any = {};
  Object.keys(output).forEach(key => {
    mapParams[key] = output[key];
  });
  return mapParams;
}

const deserializeAws_restJson1_1Method = (
  output: any,
  context: __SerdeContext
): Method => {
  let contents: any = {
    __type: "Method",
    apiKeyRequired: undefined,
    authorizationScopes: undefined,
    authorizationType: undefined,
    authorizerId: undefined,
    httpMethod: undefined,
    methodIntegration: undefined,
    methodResponses: undefined,
    operationName: undefined,
    requestModels: undefined,
    requestParameters: undefined,
    requestValidatorId: undefined,
  };
  if (output.apiKeyRequired !== undefined) {
    contents.apiKeyRequired = output.apiKeyRequired;
  }
  if (output.authorizationScopes !== undefined) {
    contents.authorizationScopes = deserializeAws_restJson1_1ListOfString(output.authorizationScopes, context);
  }
  if (output.authorizationType !== undefined) {
    contents.authorizationType = output.authorizationType;
  }
  if (output.authorizerId !== undefined) {
    contents.authorizerId = output.authorizerId;
  }
  if (output.httpMethod !== undefined) {
    contents.httpMethod = output.httpMethod;
  }
  if (output.methodIntegration !== undefined) {
    contents.methodIntegration = deserializeAws_restJson1_1Integration(output.methodIntegration, context);
  }
  if (output.methodResponses !== undefined) {
    contents.methodResponses = deserializeAws_restJson1_1MapOfMethodResponse(output.methodResponses, context);
  }
  if (output.operationName !== undefined) {
    contents.operationName = output.operationName;
  }
  if (output.requestModels !== undefined) {
    contents.requestModels = deserializeAws_restJson1_1MapOfStringToString(output.requestModels, context);
  }
  if (output.requestParameters !== undefined) {
    contents.requestParameters = deserializeAws_restJson1_1MapOfStringToBoolean(output.requestParameters, context);
  }
  if (output.requestValidatorId !== undefined) {
    contents.requestValidatorId = output.requestValidatorId;
  }
  return contents;
}

const deserializeAws_restJson1_1MethodResponse = (
  output: any,
  context: __SerdeContext
): MethodResponse => {
  let contents: any = {
    __type: "MethodResponse",
    responseModels: undefined,
    responseParameters: undefined,
    statusCode: undefined,
  };
  if (output.responseModels !== undefined) {
    contents.responseModels = deserializeAws_restJson1_1MapOfStringToString(output.responseModels, context);
  }
  if (output.responseParameters !== undefined) {
    contents.responseParameters = deserializeAws_restJson1_1MapOfStringToBoolean(output.responseParameters, context);
  }
  if (output.statusCode !== undefined) {
    contents.statusCode = output.statusCode;
  }
  return contents;
}

const deserializeAws_restJson1_1MethodSetting = (
  output: any,
  context: __SerdeContext
): MethodSetting => {
  let contents: any = {
    __type: "MethodSetting",
    cacheDataEncrypted: undefined,
    cacheTtlInSeconds: undefined,
    cachingEnabled: undefined,
    dataTraceEnabled: undefined,
    loggingLevel: undefined,
    metricsEnabled: undefined,
    requireAuthorizationForCacheControl: undefined,
    throttlingBurstLimit: undefined,
    throttlingRateLimit: undefined,
    unauthorizedCacheControlHeaderStrategy: undefined,
  };
  if (output.cacheDataEncrypted !== undefined) {
    contents.cacheDataEncrypted = output.cacheDataEncrypted;
  }
  if (output.cacheTtlInSeconds !== undefined) {
    contents.cacheTtlInSeconds = output.cacheTtlInSeconds;
  }
  if (output.cachingEnabled !== undefined) {
    contents.cachingEnabled = output.cachingEnabled;
  }
  if (output.dataTraceEnabled !== undefined) {
    contents.dataTraceEnabled = output.dataTraceEnabled;
  }
  if (output.loggingLevel !== undefined) {
    contents.loggingLevel = output.loggingLevel;
  }
  if (output.metricsEnabled !== undefined) {
    contents.metricsEnabled = output.metricsEnabled;
  }
  if (output.requireAuthorizationForCacheControl !== undefined) {
    contents.requireAuthorizationForCacheControl = output.requireAuthorizationForCacheControl;
  }
  if (output.throttlingBurstLimit !== undefined) {
    contents.throttlingBurstLimit = output.throttlingBurstLimit;
  }
  if (output.throttlingRateLimit !== undefined) {
    contents.throttlingRateLimit = output.throttlingRateLimit;
  }
  if (output.unauthorizedCacheControlHeaderStrategy !== undefined) {
    contents.unauthorizedCacheControlHeaderStrategy = output.unauthorizedCacheControlHeaderStrategy;
  }
  return contents;
}

const deserializeAws_restJson1_1MethodSnapshot = (
  output: any,
  context: __SerdeContext
): MethodSnapshot => {
  let contents: any = {
    __type: "MethodSnapshot",
    apiKeyRequired: undefined,
    authorizationType: undefined,
  };
  if (output.apiKeyRequired !== undefined) {
    contents.apiKeyRequired = output.apiKeyRequired;
  }
  if (output.authorizationType !== undefined) {
    contents.authorizationType = output.authorizationType;
  }
  return contents;
}

const deserializeAws_restJson1_1Model = (
  output: any,
  context: __SerdeContext
): Model => {
  let contents: any = {
    __type: "Model",
    contentType: undefined,
    description: undefined,
    id: undefined,
    name: undefined,
    schema: undefined,
  };
  if (output.contentType !== undefined) {
    contents.contentType = output.contentType;
  }
  if (output.description !== undefined) {
    contents.description = output.description;
  }
  if (output.id !== undefined) {
    contents.id = output.id;
  }
  if (output.name !== undefined) {
    contents.name = output.name;
  }
  if (output.schema !== undefined) {
    contents.schema = output.schema;
  }
  return contents;
}

const deserializeAws_restJson1_1PathToMapOfMethodSnapshot = (
  output: any,
  context: __SerdeContext
): { [key: string]: { [key: string]: MethodSnapshot } } => {
  let mapParams: any = {};
  Object.keys(output).forEach(key => {
    mapParams[key] = deserializeAws_restJson1_1MapOfMethodSnapshot(output[key], context);
  });
  return mapParams;
}

const deserializeAws_restJson1_1QuotaSettings = (
  output: any,
  context: __SerdeContext
): QuotaSettings => {
  let contents: any = {
    __type: "QuotaSettings",
    limit: undefined,
    offset: undefined,
    period: undefined,
  };
  if (output.limit !== undefined) {
    contents.limit = output.limit;
  }
  if (output.offset !== undefined) {
    contents.offset = output.offset;
  }
  if (output.period !== undefined) {
    contents.period = output.period;
  }
  return contents;
}

const deserializeAws_restJson1_1RequestValidator = (
  output: any,
  context: __SerdeContext
): RequestValidator => {
  let contents: any = {
    __type: "RequestValidator",
    id: undefined,
    name: undefined,
    validateRequestBody: undefined,
    validateRequestParameters: undefined,
  };
  if (output.id !== undefined) {
    contents.id = output.id;
  }
  if (output.name !== undefined) {
    contents.name = output.name;
  }
  if (output.validateRequestBody !== undefined) {
    contents.validateRequestBody = output.validateRequestBody;
  }
  if (output.validateRequestParameters !== undefined) {
    contents.validateRequestParameters = output.validateRequestParameters;
  }
  return contents;
}

const deserializeAws_restJson1_1Resource = (
  output: any,
  context: __SerdeContext
): Resource => {
  let contents: any = {
    __type: "Resource",
    id: undefined,
    parentId: undefined,
    path: undefined,
    pathPart: undefined,
    resourceMethods: undefined,
  };
  if (output.id !== undefined) {
    contents.id = output.id;
  }
  if (output.parentId !== undefined) {
    contents.parentId = output.parentId;
  }
  if (output.path !== undefined) {
    contents.path = output.path;
  }
  if (output.pathPart !== undefined) {
    contents.pathPart = output.pathPart;
  }
  if (output.resourceMethods !== undefined) {
    contents.resourceMethods = deserializeAws_restJson1_1MapOfMethod(output.resourceMethods, context);
  }
  return contents;
}

const deserializeAws_restJson1_1RestApi = (
  output: any,
  context: __SerdeContext
): RestApi => {
  let contents: any = {
    __type: "RestApi",
    apiKeySource: undefined,
    binaryMediaTypes: undefined,
    createdDate: undefined,
    description: undefined,
    endpointConfiguration: undefined,
    id: undefined,
    minimumCompressionSize: undefined,
    name: undefined,
    policy: undefined,
    tags: undefined,
    version: undefined,
    warnings: undefined,
  };
  if (output.apiKeySource !== undefined) {
    contents.apiKeySource = output.apiKeySource;
  }
  if (output.binaryMediaTypes !== undefined) {
    contents.binaryMediaTypes = deserializeAws_restJson1_1ListOfString(output.binaryMediaTypes, context);
  }
  if (output.createdDate !== undefined) {
    contents.createdDate = new Date(output.createdDate % 1 != 0 ? Math.round(output.createdDate * 1000) : output.createdDate);
  }
  if (output.description !== undefined) {
    contents.description = output.description;
  }
  if (output.endpointConfiguration !== undefined) {
    contents.endpointConfiguration = deserializeAws_restJson1_1EndpointConfiguration(output.endpointConfiguration, context);
  }
  if (output.id !== undefined) {
    contents.id = output.id;
  }
  if (output.minimumCompressionSize !== undefined) {
    contents.minimumCompressionSize = output.minimumCompressionSize;
  }
  if (output.name !== undefined) {
    contents.name = output.name;
  }
  if (output.policy !== undefined) {
    contents.policy = output.policy;
  }
  if (output.tags !== undefined) {
    contents.tags = deserializeAws_restJson1_1MapOfStringToString(output.tags, context);
  }
  if (output.version !== undefined) {
    contents.version = output.version;
  }
  if (output.warnings !== undefined) {
    contents.warnings = deserializeAws_restJson1_1ListOfString(output.warnings, context);
  }
  return contents;
}

const deserializeAws_restJson1_1SdkConfigurationProperty = (
  output: any,
  context: __SerdeContext
): SdkConfigurationProperty => {
  let contents: any = {
    __type: "SdkConfigurationProperty",
    defaultValue: undefined,
    description: undefined,
    friendlyName: undefined,
    name: undefined,
    required: undefined,
  };
  if (output.defaultValue !== undefined) {
    contents.defaultValue = output.defaultValue;
  }
  if (output.description !== undefined) {
    contents.description = output.description;
  }
  if (output.friendlyName !== undefined) {
    contents.friendlyName = output.friendlyName;
  }
  if (output.name !== undefined) {
    contents.name = output.name;
  }
  if (output.required !== undefined) {
    contents.required = output.required;
  }
  return contents;
}

const deserializeAws_restJson1_1SdkType = (
  output: any,
  context: __SerdeContext
): SdkType => {
  let contents: any = {
    __type: "SdkType",
    configurationProperties: undefined,
    description: undefined,
    friendlyName: undefined,
    id: undefined,
  };
  if (output.configurationProperties !== undefined) {
    contents.configurationProperties = deserializeAws_restJson1_1ListOfSdkConfigurationProperty(output.configurationProperties, context);
  }
  if (output.description !== undefined) {
    contents.description = output.description;
  }
  if (output.friendlyName !== undefined) {
    contents.friendlyName = output.friendlyName;
  }
  if (output.id !== undefined) {
    contents.id = output.id;
  }
  return contents;
}

const deserializeAws_restJson1_1Stage = (
  output: any,
  context: __SerdeContext
): Stage => {
  let contents: any = {
    __type: "Stage",
    accessLogSettings: undefined,
    cacheClusterEnabled: undefined,
    cacheClusterSize: undefined,
    cacheClusterStatus: undefined,
    canarySettings: undefined,
    clientCertificateId: undefined,
    createdDate: undefined,
    deploymentId: undefined,
    description: undefined,
    documentationVersion: undefined,
    lastUpdatedDate: undefined,
    methodSettings: undefined,
    stageName: undefined,
    tags: undefined,
    tracingEnabled: undefined,
    variables: undefined,
    webAclArn: undefined,
  };
  if (output.accessLogSettings !== undefined) {
    contents.accessLogSettings = deserializeAws_restJson1_1AccessLogSettings(output.accessLogSettings, context);
  }
  if (output.cacheClusterEnabled !== undefined) {
    contents.cacheClusterEnabled = output.cacheClusterEnabled;
  }
  if (output.cacheClusterSize !== undefined) {
    contents.cacheClusterSize = output.cacheClusterSize;
  }
  if (output.cacheClusterStatus !== undefined) {
    contents.cacheClusterStatus = output.cacheClusterStatus;
  }
  if (output.canarySettings !== undefined) {
    contents.canarySettings = deserializeAws_restJson1_1CanarySettings(output.canarySettings, context);
  }
  if (output.clientCertificateId !== undefined) {
    contents.clientCertificateId = output.clientCertificateId;
  }
  if (output.createdDate !== undefined) {
    contents.createdDate = new Date(output.createdDate % 1 != 0 ? Math.round(output.createdDate * 1000) : output.createdDate);
  }
  if (output.deploymentId !== undefined) {
    contents.deploymentId = output.deploymentId;
  }
  if (output.description !== undefined) {
    contents.description = output.description;
  }
  if (output.documentationVersion !== undefined) {
    contents.documentationVersion = output.documentationVersion;
  }
  if (output.lastUpdatedDate !== undefined) {
    contents.lastUpdatedDate = new Date(output.lastUpdatedDate % 1 != 0 ? Math.round(output.lastUpdatedDate * 1000) : output.lastUpdatedDate);
  }
  if (output.methodSettings !== undefined) {
    contents.methodSettings = deserializeAws_restJson1_1MapOfMethodSettings(output.methodSettings, context);
  }
  if (output.stageName !== undefined) {
    contents.stageName = output.stageName;
  }
  if (output.tags !== undefined) {
    contents.tags = deserializeAws_restJson1_1MapOfStringToString(output.tags, context);
  }
  if (output.tracingEnabled !== undefined) {
    contents.tracingEnabled = output.tracingEnabled;
  }
  if (output.variables !== undefined) {
    contents.variables = deserializeAws_restJson1_1MapOfStringToString(output.variables, context);
  }
  if (output.webAclArn !== undefined) {
    contents.webAclArn = output.webAclArn;
  }
  return contents;
}

const deserializeAws_restJson1_1ThrottleSettings = (
  output: any,
  context: __SerdeContext
): ThrottleSettings => {
  let contents: any = {
    __type: "ThrottleSettings",
    burstLimit: undefined,
    rateLimit: undefined,
  };
  if (output.burstLimit !== undefined) {
    contents.burstLimit = output.burstLimit;
  }
  if (output.rateLimit !== undefined) {
    contents.rateLimit = output.rateLimit;
  }
  return contents;
}

const deserializeAws_restJson1_1UsagePlan = (
  output: any,
  context: __SerdeContext
): UsagePlan => {
  let contents: any = {
    __type: "UsagePlan",
    apiStages: undefined,
    description: undefined,
    id: undefined,
    name: undefined,
    productCode: undefined,
    quota: undefined,
    tags: undefined,
    throttle: undefined,
  };
  if (output.apiStages !== undefined) {
    contents.apiStages = deserializeAws_restJson1_1ListOfApiStage(output.apiStages, context);
  }
  if (output.description !== undefined) {
    contents.description = output.description;
  }
  if (output.id !== undefined) {
    contents.id = output.id;
  }
  if (output.name !== undefined) {
    contents.name = output.name;
  }
  if (output.productCode !== undefined) {
    contents.productCode = output.productCode;
  }
  if (output.quota !== undefined) {
    contents.quota = deserializeAws_restJson1_1QuotaSettings(output.quota, context);
  }
  if (output.tags !== undefined) {
    contents.tags = deserializeAws_restJson1_1MapOfStringToString(output.tags, context);
  }
  if (output.throttle !== undefined) {
    contents.throttle = deserializeAws_restJson1_1ThrottleSettings(output.throttle, context);
  }
  return contents;
}

const deserializeAws_restJson1_1UsagePlanKey = (
  output: any,
  context: __SerdeContext
): UsagePlanKey => {
  let contents: any = {
    __type: "UsagePlanKey",
    id: undefined,
    name: undefined,
    type: undefined,
    value: undefined,
  };
  if (output.id !== undefined) {
    contents.id = output.id;
  }
  if (output.name !== undefined) {
    contents.name = output.name;
  }
  if (output.type !== undefined) {
    contents.type = output.type;
  }
  if (output.value !== undefined) {
    contents.value = output.value;
  }
  return contents;
}

const deserializeAws_restJson1_1VpcLink = (
  output: any,
  context: __SerdeContext
): VpcLink => {
  let contents: any = {
    __type: "VpcLink",
    description: undefined,
    id: undefined,
    name: undefined,
    status: undefined,
    statusMessage: undefined,
    tags: undefined,
    targetArns: undefined,
  };
  if (output.description !== undefined) {
    contents.description = output.description;
  }
  if (output.id !== undefined) {
    contents.id = output.id;
  }
  if (output.name !== undefined) {
    contents.name = output.name;
  }
  if (output.status !== undefined) {
    contents.status = output.status;
  }
  if (output.statusMessage !== undefined) {
    contents.statusMessage = output.statusMessage;
  }
  if (output.tags !== undefined) {
    contents.tags = deserializeAws_restJson1_1MapOfStringToString(output.tags, context);
  }
  if (output.targetArns !== undefined) {
    contents.targetArns = deserializeAws_restJson1_1ListOfString(output.targetArns, context);
  }
  return contents;
}

const deserializeAws_restJson1_1ListOfString = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) =>
    entry
  );
}

const deserializeMetadata = (output: __HttpResponse): __ResponseMetadata => ({
  httpStatusCode: output.statusCode,
  httpHeaders: output.headers,
  requestId: output.headers["x-amzn-requestid"]
});

const parseBody = (streamBody: any, context: __SerdeContext): any => {
  return context.streamCollector(streamBody).then((body: any) => {
    const encoded = context.utf8Encoder(body);
    if (encoded.length) {
      return JSON.parse(encoded);
    }
    return {};
  });
};
