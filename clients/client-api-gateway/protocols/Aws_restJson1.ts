import {
  CreateApiKeyCommandInput,
  CreateApiKeyCommandOutput
} from "../commands/CreateApiKeyCommand";
import {
  CreateAuthorizerCommandInput,
  CreateAuthorizerCommandOutput
} from "../commands/CreateAuthorizerCommand";
import {
  CreateBasePathMappingCommandInput,
  CreateBasePathMappingCommandOutput
} from "../commands/CreateBasePathMappingCommand";
import {
  CreateDeploymentCommandInput,
  CreateDeploymentCommandOutput
} from "../commands/CreateDeploymentCommand";
import {
  CreateDocumentationPartCommandInput,
  CreateDocumentationPartCommandOutput
} from "../commands/CreateDocumentationPartCommand";
import {
  CreateDocumentationVersionCommandInput,
  CreateDocumentationVersionCommandOutput
} from "../commands/CreateDocumentationVersionCommand";
import {
  CreateDomainNameCommandInput,
  CreateDomainNameCommandOutput
} from "../commands/CreateDomainNameCommand";
import {
  CreateModelCommandInput,
  CreateModelCommandOutput
} from "../commands/CreateModelCommand";
import {
  CreateRequestValidatorCommandInput,
  CreateRequestValidatorCommandOutput
} from "../commands/CreateRequestValidatorCommand";
import {
  CreateResourceCommandInput,
  CreateResourceCommandOutput
} from "../commands/CreateResourceCommand";
import {
  CreateRestApiCommandInput,
  CreateRestApiCommandOutput
} from "../commands/CreateRestApiCommand";
import {
  CreateStageCommandInput,
  CreateStageCommandOutput
} from "../commands/CreateStageCommand";
import {
  CreateUsagePlanCommandInput,
  CreateUsagePlanCommandOutput
} from "../commands/CreateUsagePlanCommand";
import {
  CreateUsagePlanKeyCommandInput,
  CreateUsagePlanKeyCommandOutput
} from "../commands/CreateUsagePlanKeyCommand";
import {
  CreateVpcLinkCommandInput,
  CreateVpcLinkCommandOutput
} from "../commands/CreateVpcLinkCommand";
import {
  DeleteApiKeyCommandInput,
  DeleteApiKeyCommandOutput
} from "../commands/DeleteApiKeyCommand";
import {
  DeleteAuthorizerCommandInput,
  DeleteAuthorizerCommandOutput
} from "../commands/DeleteAuthorizerCommand";
import {
  DeleteBasePathMappingCommandInput,
  DeleteBasePathMappingCommandOutput
} from "../commands/DeleteBasePathMappingCommand";
import {
  DeleteClientCertificateCommandInput,
  DeleteClientCertificateCommandOutput
} from "../commands/DeleteClientCertificateCommand";
import {
  DeleteDeploymentCommandInput,
  DeleteDeploymentCommandOutput
} from "../commands/DeleteDeploymentCommand";
import {
  DeleteDocumentationPartCommandInput,
  DeleteDocumentationPartCommandOutput
} from "../commands/DeleteDocumentationPartCommand";
import {
  DeleteDocumentationVersionCommandInput,
  DeleteDocumentationVersionCommandOutput
} from "../commands/DeleteDocumentationVersionCommand";
import {
  DeleteDomainNameCommandInput,
  DeleteDomainNameCommandOutput
} from "../commands/DeleteDomainNameCommand";
import {
  DeleteGatewayResponseCommandInput,
  DeleteGatewayResponseCommandOutput
} from "../commands/DeleteGatewayResponseCommand";
import {
  DeleteIntegrationCommandInput,
  DeleteIntegrationCommandOutput
} from "../commands/DeleteIntegrationCommand";
import {
  DeleteIntegrationResponseCommandInput,
  DeleteIntegrationResponseCommandOutput
} from "../commands/DeleteIntegrationResponseCommand";
import {
  DeleteMethodCommandInput,
  DeleteMethodCommandOutput
} from "../commands/DeleteMethodCommand";
import {
  DeleteMethodResponseCommandInput,
  DeleteMethodResponseCommandOutput
} from "../commands/DeleteMethodResponseCommand";
import {
  DeleteModelCommandInput,
  DeleteModelCommandOutput
} from "../commands/DeleteModelCommand";
import {
  DeleteRequestValidatorCommandInput,
  DeleteRequestValidatorCommandOutput
} from "../commands/DeleteRequestValidatorCommand";
import {
  DeleteResourceCommandInput,
  DeleteResourceCommandOutput
} from "../commands/DeleteResourceCommand";
import {
  DeleteRestApiCommandInput,
  DeleteRestApiCommandOutput
} from "../commands/DeleteRestApiCommand";
import {
  DeleteStageCommandInput,
  DeleteStageCommandOutput
} from "../commands/DeleteStageCommand";
import {
  DeleteUsagePlanCommandInput,
  DeleteUsagePlanCommandOutput
} from "../commands/DeleteUsagePlanCommand";
import {
  DeleteUsagePlanKeyCommandInput,
  DeleteUsagePlanKeyCommandOutput
} from "../commands/DeleteUsagePlanKeyCommand";
import {
  DeleteVpcLinkCommandInput,
  DeleteVpcLinkCommandOutput
} from "../commands/DeleteVpcLinkCommand";
import {
  FlushStageAuthorizersCacheCommandInput,
  FlushStageAuthorizersCacheCommandOutput
} from "../commands/FlushStageAuthorizersCacheCommand";
import {
  FlushStageCacheCommandInput,
  FlushStageCacheCommandOutput
} from "../commands/FlushStageCacheCommand";
import {
  GenerateClientCertificateCommandInput,
  GenerateClientCertificateCommandOutput
} from "../commands/GenerateClientCertificateCommand";
import {
  GetAccountCommandInput,
  GetAccountCommandOutput
} from "../commands/GetAccountCommand";
import {
  GetApiKeyCommandInput,
  GetApiKeyCommandOutput
} from "../commands/GetApiKeyCommand";
import {
  GetApiKeysCommandInput,
  GetApiKeysCommandOutput
} from "../commands/GetApiKeysCommand";
import {
  GetAuthorizerCommandInput,
  GetAuthorizerCommandOutput
} from "../commands/GetAuthorizerCommand";
import {
  GetAuthorizersCommandInput,
  GetAuthorizersCommandOutput
} from "../commands/GetAuthorizersCommand";
import {
  GetBasePathMappingCommandInput,
  GetBasePathMappingCommandOutput
} from "../commands/GetBasePathMappingCommand";
import {
  GetBasePathMappingsCommandInput,
  GetBasePathMappingsCommandOutput
} from "../commands/GetBasePathMappingsCommand";
import {
  GetClientCertificateCommandInput,
  GetClientCertificateCommandOutput
} from "../commands/GetClientCertificateCommand";
import {
  GetClientCertificatesCommandInput,
  GetClientCertificatesCommandOutput
} from "../commands/GetClientCertificatesCommand";
import {
  GetDeploymentCommandInput,
  GetDeploymentCommandOutput
} from "../commands/GetDeploymentCommand";
import {
  GetDeploymentsCommandInput,
  GetDeploymentsCommandOutput
} from "../commands/GetDeploymentsCommand";
import {
  GetDocumentationPartCommandInput,
  GetDocumentationPartCommandOutput
} from "../commands/GetDocumentationPartCommand";
import {
  GetDocumentationPartsCommandInput,
  GetDocumentationPartsCommandOutput
} from "../commands/GetDocumentationPartsCommand";
import {
  GetDocumentationVersionCommandInput,
  GetDocumentationVersionCommandOutput
} from "../commands/GetDocumentationVersionCommand";
import {
  GetDocumentationVersionsCommandInput,
  GetDocumentationVersionsCommandOutput
} from "../commands/GetDocumentationVersionsCommand";
import {
  GetDomainNameCommandInput,
  GetDomainNameCommandOutput
} from "../commands/GetDomainNameCommand";
import {
  GetDomainNamesCommandInput,
  GetDomainNamesCommandOutput
} from "../commands/GetDomainNamesCommand";
import {
  GetExportCommandInput,
  GetExportCommandOutput
} from "../commands/GetExportCommand";
import {
  GetGatewayResponseCommandInput,
  GetGatewayResponseCommandOutput
} from "../commands/GetGatewayResponseCommand";
import {
  GetGatewayResponsesCommandInput,
  GetGatewayResponsesCommandOutput
} from "../commands/GetGatewayResponsesCommand";
import {
  GetIntegrationCommandInput,
  GetIntegrationCommandOutput
} from "../commands/GetIntegrationCommand";
import {
  GetIntegrationResponseCommandInput,
  GetIntegrationResponseCommandOutput
} from "../commands/GetIntegrationResponseCommand";
import {
  GetMethodCommandInput,
  GetMethodCommandOutput
} from "../commands/GetMethodCommand";
import {
  GetMethodResponseCommandInput,
  GetMethodResponseCommandOutput
} from "../commands/GetMethodResponseCommand";
import {
  GetModelCommandInput,
  GetModelCommandOutput
} from "../commands/GetModelCommand";
import {
  GetModelTemplateCommandInput,
  GetModelTemplateCommandOutput
} from "../commands/GetModelTemplateCommand";
import {
  GetModelsCommandInput,
  GetModelsCommandOutput
} from "../commands/GetModelsCommand";
import {
  GetRequestValidatorCommandInput,
  GetRequestValidatorCommandOutput
} from "../commands/GetRequestValidatorCommand";
import {
  GetRequestValidatorsCommandInput,
  GetRequestValidatorsCommandOutput
} from "../commands/GetRequestValidatorsCommand";
import {
  GetResourceCommandInput,
  GetResourceCommandOutput
} from "../commands/GetResourceCommand";
import {
  GetResourcesCommandInput,
  GetResourcesCommandOutput
} from "../commands/GetResourcesCommand";
import {
  GetRestApiCommandInput,
  GetRestApiCommandOutput
} from "../commands/GetRestApiCommand";
import {
  GetRestApisCommandInput,
  GetRestApisCommandOutput
} from "../commands/GetRestApisCommand";
import {
  GetSdkCommandInput,
  GetSdkCommandOutput
} from "../commands/GetSdkCommand";
import {
  GetSdkTypeCommandInput,
  GetSdkTypeCommandOutput
} from "../commands/GetSdkTypeCommand";
import {
  GetSdkTypesCommandInput,
  GetSdkTypesCommandOutput
} from "../commands/GetSdkTypesCommand";
import {
  GetStageCommandInput,
  GetStageCommandOutput
} from "../commands/GetStageCommand";
import {
  GetStagesCommandInput,
  GetStagesCommandOutput
} from "../commands/GetStagesCommand";
import {
  GetTagsCommandInput,
  GetTagsCommandOutput
} from "../commands/GetTagsCommand";
import {
  GetUsageCommandInput,
  GetUsageCommandOutput
} from "../commands/GetUsageCommand";
import {
  GetUsagePlanCommandInput,
  GetUsagePlanCommandOutput
} from "../commands/GetUsagePlanCommand";
import {
  GetUsagePlanKeyCommandInput,
  GetUsagePlanKeyCommandOutput
} from "../commands/GetUsagePlanKeyCommand";
import {
  GetUsagePlanKeysCommandInput,
  GetUsagePlanKeysCommandOutput
} from "../commands/GetUsagePlanKeysCommand";
import {
  GetUsagePlansCommandInput,
  GetUsagePlansCommandOutput
} from "../commands/GetUsagePlansCommand";
import {
  GetVpcLinkCommandInput,
  GetVpcLinkCommandOutput
} from "../commands/GetVpcLinkCommand";
import {
  GetVpcLinksCommandInput,
  GetVpcLinksCommandOutput
} from "../commands/GetVpcLinksCommand";
import {
  ImportApiKeysCommandInput,
  ImportApiKeysCommandOutput
} from "../commands/ImportApiKeysCommand";
import {
  ImportDocumentationPartsCommandInput,
  ImportDocumentationPartsCommandOutput
} from "../commands/ImportDocumentationPartsCommand";
import {
  ImportRestApiCommandInput,
  ImportRestApiCommandOutput
} from "../commands/ImportRestApiCommand";
import {
  PutGatewayResponseCommandInput,
  PutGatewayResponseCommandOutput
} from "../commands/PutGatewayResponseCommand";
import {
  PutIntegrationCommandInput,
  PutIntegrationCommandOutput
} from "../commands/PutIntegrationCommand";
import {
  PutIntegrationResponseCommandInput,
  PutIntegrationResponseCommandOutput
} from "../commands/PutIntegrationResponseCommand";
import {
  PutMethodCommandInput,
  PutMethodCommandOutput
} from "../commands/PutMethodCommand";
import {
  PutMethodResponseCommandInput,
  PutMethodResponseCommandOutput
} from "../commands/PutMethodResponseCommand";
import {
  PutRestApiCommandInput,
  PutRestApiCommandOutput
} from "../commands/PutRestApiCommand";
import {
  TagResourceCommandInput,
  TagResourceCommandOutput
} from "../commands/TagResourceCommand";
import {
  TestInvokeAuthorizerCommandInput,
  TestInvokeAuthorizerCommandOutput
} from "../commands/TestInvokeAuthorizerCommand";
import {
  TestInvokeMethodCommandInput,
  TestInvokeMethodCommandOutput
} from "../commands/TestInvokeMethodCommand";
import {
  UntagResourceCommandInput,
  UntagResourceCommandOutput
} from "../commands/UntagResourceCommand";
import {
  UpdateAccountCommandInput,
  UpdateAccountCommandOutput
} from "../commands/UpdateAccountCommand";
import {
  UpdateApiKeyCommandInput,
  UpdateApiKeyCommandOutput
} from "../commands/UpdateApiKeyCommand";
import {
  UpdateAuthorizerCommandInput,
  UpdateAuthorizerCommandOutput
} from "../commands/UpdateAuthorizerCommand";
import {
  UpdateBasePathMappingCommandInput,
  UpdateBasePathMappingCommandOutput
} from "../commands/UpdateBasePathMappingCommand";
import {
  UpdateClientCertificateCommandInput,
  UpdateClientCertificateCommandOutput
} from "../commands/UpdateClientCertificateCommand";
import {
  UpdateDeploymentCommandInput,
  UpdateDeploymentCommandOutput
} from "../commands/UpdateDeploymentCommand";
import {
  UpdateDocumentationPartCommandInput,
  UpdateDocumentationPartCommandOutput
} from "../commands/UpdateDocumentationPartCommand";
import {
  UpdateDocumentationVersionCommandInput,
  UpdateDocumentationVersionCommandOutput
} from "../commands/UpdateDocumentationVersionCommand";
import {
  UpdateDomainNameCommandInput,
  UpdateDomainNameCommandOutput
} from "../commands/UpdateDomainNameCommand";
import {
  UpdateGatewayResponseCommandInput,
  UpdateGatewayResponseCommandOutput
} from "../commands/UpdateGatewayResponseCommand";
import {
  UpdateIntegrationCommandInput,
  UpdateIntegrationCommandOutput
} from "../commands/UpdateIntegrationCommand";
import {
  UpdateIntegrationResponseCommandInput,
  UpdateIntegrationResponseCommandOutput
} from "../commands/UpdateIntegrationResponseCommand";
import {
  UpdateMethodCommandInput,
  UpdateMethodCommandOutput
} from "../commands/UpdateMethodCommand";
import {
  UpdateMethodResponseCommandInput,
  UpdateMethodResponseCommandOutput
} from "../commands/UpdateMethodResponseCommand";
import {
  UpdateModelCommandInput,
  UpdateModelCommandOutput
} from "../commands/UpdateModelCommand";
import {
  UpdateRequestValidatorCommandInput,
  UpdateRequestValidatorCommandOutput
} from "../commands/UpdateRequestValidatorCommand";
import {
  UpdateResourceCommandInput,
  UpdateResourceCommandOutput
} from "../commands/UpdateResourceCommand";
import {
  UpdateRestApiCommandInput,
  UpdateRestApiCommandOutput
} from "../commands/UpdateRestApiCommand";
import {
  UpdateStageCommandInput,
  UpdateStageCommandOutput
} from "../commands/UpdateStageCommand";
import {
  UpdateUsageCommandInput,
  UpdateUsageCommandOutput
} from "../commands/UpdateUsageCommand";
import {
  UpdateUsagePlanCommandInput,
  UpdateUsagePlanCommandOutput
} from "../commands/UpdateUsagePlanCommand";
import {
  UpdateVpcLinkCommandInput,
  UpdateVpcLinkCommandOutput
} from "../commands/UpdateVpcLinkCommand";
import {
  AccessLogSettings,
  ApiKey,
  ApiStage,
  Authorizer,
  BadRequestException,
  BasePathMapping,
  CanarySettings,
  ClientCertificate,
  ConflictException,
  Deployment,
  DeploymentCanarySettings,
  DocumentationPart,
  DocumentationPartLocation,
  DocumentationVersion,
  DomainName,
  EndpointConfiguration,
  EndpointType,
  GatewayResponse,
  Integration,
  IntegrationResponse,
  LimitExceededException,
  Method,
  MethodResponse,
  MethodSetting,
  MethodSnapshot,
  Model,
  NotFoundException,
  PatchOperation,
  QuotaSettings,
  RequestValidator,
  Resource,
  RestApi,
  SdkConfigurationProperty,
  SdkType,
  ServiceUnavailableException,
  Stage,
  StageKey,
  ThrottleSettings,
  TooManyRequestsException,
  UnauthorizedException,
  UsagePlan,
  UsagePlanKey,
  VpcLink
} from "../models/index";
import {
  HttpRequest as __HttpRequest,
  HttpResponse as __HttpResponse
} from "@aws-sdk/protocol-http";
import {
  SmithyException as __SmithyException,
  extendedEncodeURIComponent as __extendedEncodeURIComponent
} from "@aws-sdk/smithy-client";
import {
  Endpoint as __Endpoint,
  MetadataBearer as __MetadataBearer,
  ResponseMetadata as __ResponseMetadata,
  SerdeContext as __SerdeContext
} from "@aws-sdk/types";

export const serializeAws_restJson1CreateApiKeyCommand = async (
  input: CreateApiKeyCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath = "/apikeys";
  let body: any;
  body = JSON.stringify({
    ...(input.customerId !== undefined && { customerId: input.customerId }),
    ...(input.description !== undefined && { description: input.description }),
    ...(input.enabled !== undefined && { enabled: input.enabled }),
    ...(input.generateDistinctId !== undefined && {
      generateDistinctId: input.generateDistinctId
    }),
    ...(input.name !== undefined && { name: input.name }),
    ...(input.stageKeys !== undefined && {
      stageKeys: serializeAws_restJson1ListOfStageKeys(input.stageKeys, context)
    }),
    ...(input.tags !== undefined && {
      tags: serializeAws_restJson1MapOfStringToString(input.tags, context)
    }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title }),
    ...(input.value !== undefined && { value: input.value })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1CreateAuthorizerCommand = async (
  input: CreateAuthorizerCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath = "/restapis/{restApiId}/authorizers";
  if (input.restApiId !== undefined) {
    const labelValue: string = input.restApiId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: restApiId.");
    }
    resolvedPath = resolvedPath.replace(
      "{restApiId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: restApiId.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.authType !== undefined && { authType: input.authType }),
    ...(input.authorizerCredentials !== undefined && {
      authorizerCredentials: input.authorizerCredentials
    }),
    ...(input.authorizerResultTtlInSeconds !== undefined && {
      authorizerResultTtlInSeconds: input.authorizerResultTtlInSeconds
    }),
    ...(input.authorizerUri !== undefined && {
      authorizerUri: input.authorizerUri
    }),
    ...(input.identitySource !== undefined && {
      identitySource: input.identitySource
    }),
    ...(input.identityValidationExpression !== undefined && {
      identityValidationExpression: input.identityValidationExpression
    }),
    ...(input.name !== undefined && { name: input.name }),
    ...(input.providerARNs !== undefined && {
      providerARNs: serializeAws_restJson1ListOfARNs(
        input.providerARNs,
        context
      )
    }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title }),
    ...(input.type !== undefined && { type: input.type })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1CreateBasePathMappingCommand = async (
  input: CreateBasePathMappingCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath = "/domainnames/{domainName}/basepathmappings";
  if (input.domainName !== undefined) {
    const labelValue: string = input.domainName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: domainName.");
    }
    resolvedPath = resolvedPath.replace(
      "{domainName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: domainName.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.basePath !== undefined && { basePath: input.basePath }),
    ...(input.name !== undefined && { name: input.name }),
    ...(input.restApiId !== undefined && { restApiId: input.restApiId }),
    ...(input.stage !== undefined && { stage: input.stage }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1CreateDeploymentCommand = async (
  input: CreateDeploymentCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath = "/restapis/{restApiId}/deployments";
  if (input.restApiId !== undefined) {
    const labelValue: string = input.restApiId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: restApiId.");
    }
    resolvedPath = resolvedPath.replace(
      "{restApiId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: restApiId.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.cacheClusterEnabled !== undefined && {
      cacheClusterEnabled: input.cacheClusterEnabled
    }),
    ...(input.cacheClusterSize !== undefined && {
      cacheClusterSize: input.cacheClusterSize
    }),
    ...(input.canarySettings !== undefined && {
      canarySettings: serializeAws_restJson1DeploymentCanarySettings(
        input.canarySettings,
        context
      )
    }),
    ...(input.description !== undefined && { description: input.description }),
    ...(input.name !== undefined && { name: input.name }),
    ...(input.stageDescription !== undefined && {
      stageDescription: input.stageDescription
    }),
    ...(input.stageName !== undefined && { stageName: input.stageName }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title }),
    ...(input.tracingEnabled !== undefined && {
      tracingEnabled: input.tracingEnabled
    }),
    ...(input.variables !== undefined && {
      variables: serializeAws_restJson1MapOfStringToString(
        input.variables,
        context
      )
    })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1CreateDocumentationPartCommand = async (
  input: CreateDocumentationPartCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath = "/restapis/{restApiId}/documentation/parts";
  if (input.restApiId !== undefined) {
    const labelValue: string = input.restApiId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: restApiId.");
    }
    resolvedPath = resolvedPath.replace(
      "{restApiId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: restApiId.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.location !== undefined && {
      location: serializeAws_restJson1DocumentationPartLocation(
        input.location,
        context
      )
    }),
    ...(input.name !== undefined && { name: input.name }),
    ...(input.properties !== undefined && { properties: input.properties }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1CreateDocumentationVersionCommand = async (
  input: CreateDocumentationVersionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath = "/restapis/{restApiId}/documentation/versions";
  if (input.restApiId !== undefined) {
    const labelValue: string = input.restApiId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: restApiId.");
    }
    resolvedPath = resolvedPath.replace(
      "{restApiId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: restApiId.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.description !== undefined && { description: input.description }),
    ...(input.documentationVersion !== undefined && {
      documentationVersion: input.documentationVersion
    }),
    ...(input.name !== undefined && { name: input.name }),
    ...(input.stageName !== undefined && { stageName: input.stageName }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1CreateDomainNameCommand = async (
  input: CreateDomainNameCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath = "/domainnames";
  let body: any;
  body = JSON.stringify({
    ...(input.certificateArn !== undefined && {
      certificateArn: input.certificateArn
    }),
    ...(input.certificateBody !== undefined && {
      certificateBody: input.certificateBody
    }),
    ...(input.certificateChain !== undefined && {
      certificateChain: input.certificateChain
    }),
    ...(input.certificateName !== undefined && {
      certificateName: input.certificateName
    }),
    ...(input.certificatePrivateKey !== undefined && {
      certificatePrivateKey: input.certificatePrivateKey
    }),
    ...(input.domainName !== undefined && { domainName: input.domainName }),
    ...(input.endpointConfiguration !== undefined && {
      endpointConfiguration: serializeAws_restJson1EndpointConfiguration(
        input.endpointConfiguration,
        context
      )
    }),
    ...(input.name !== undefined && { name: input.name }),
    ...(input.regionalCertificateArn !== undefined && {
      regionalCertificateArn: input.regionalCertificateArn
    }),
    ...(input.regionalCertificateName !== undefined && {
      regionalCertificateName: input.regionalCertificateName
    }),
    ...(input.securityPolicy !== undefined && {
      securityPolicy: input.securityPolicy
    }),
    ...(input.tags !== undefined && {
      tags: serializeAws_restJson1MapOfStringToString(input.tags, context)
    }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1CreateModelCommand = async (
  input: CreateModelCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath = "/restapis/{restApiId}/models";
  if (input.restApiId !== undefined) {
    const labelValue: string = input.restApiId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: restApiId.");
    }
    resolvedPath = resolvedPath.replace(
      "{restApiId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: restApiId.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.contentType !== undefined && { contentType: input.contentType }),
    ...(input.description !== undefined && { description: input.description }),
    ...(input.name !== undefined && { name: input.name }),
    ...(input.schema !== undefined && { schema: input.schema }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1CreateRequestValidatorCommand = async (
  input: CreateRequestValidatorCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath = "/restapis/{restApiId}/requestvalidators";
  if (input.restApiId !== undefined) {
    const labelValue: string = input.restApiId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: restApiId.");
    }
    resolvedPath = resolvedPath.replace(
      "{restApiId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: restApiId.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.name !== undefined && { name: input.name }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title }),
    ...(input.validateRequestBody !== undefined && {
      validateRequestBody: input.validateRequestBody
    }),
    ...(input.validateRequestParameters !== undefined && {
      validateRequestParameters: input.validateRequestParameters
    })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1CreateResourceCommand = async (
  input: CreateResourceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath = "/restapis/{restApiId}/resources/{parentId}";
  if (input.parentId !== undefined) {
    const labelValue: string = input.parentId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: parentId.");
    }
    resolvedPath = resolvedPath.replace(
      "{parentId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: parentId.");
  }
  if (input.restApiId !== undefined) {
    const labelValue: string = input.restApiId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: restApiId.");
    }
    resolvedPath = resolvedPath.replace(
      "{restApiId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: restApiId.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.name !== undefined && { name: input.name }),
    ...(input.pathPart !== undefined && { pathPart: input.pathPart }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1CreateRestApiCommand = async (
  input: CreateRestApiCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath = "/restapis";
  let body: any;
  body = JSON.stringify({
    ...(input.apiKeySource !== undefined && {
      apiKeySource: input.apiKeySource
    }),
    ...(input.binaryMediaTypes !== undefined && {
      binaryMediaTypes: serializeAws_restJson1ListOfString(
        input.binaryMediaTypes,
        context
      )
    }),
    ...(input.cloneFrom !== undefined && { cloneFrom: input.cloneFrom }),
    ...(input.description !== undefined && { description: input.description }),
    ...(input.endpointConfiguration !== undefined && {
      endpointConfiguration: serializeAws_restJson1EndpointConfiguration(
        input.endpointConfiguration,
        context
      )
    }),
    ...(input.minimumCompressionSize !== undefined && {
      minimumCompressionSize: input.minimumCompressionSize
    }),
    ...(input.name !== undefined && { name: input.name }),
    ...(input.policy !== undefined && { policy: input.policy }),
    ...(input.tags !== undefined && {
      tags: serializeAws_restJson1MapOfStringToString(input.tags, context)
    }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title }),
    ...(input.version !== undefined && { version: input.version })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1CreateStageCommand = async (
  input: CreateStageCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath = "/restapis/{restApiId}/stages";
  if (input.restApiId !== undefined) {
    const labelValue: string = input.restApiId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: restApiId.");
    }
    resolvedPath = resolvedPath.replace(
      "{restApiId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: restApiId.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.cacheClusterEnabled !== undefined && {
      cacheClusterEnabled: input.cacheClusterEnabled
    }),
    ...(input.cacheClusterSize !== undefined && {
      cacheClusterSize: input.cacheClusterSize
    }),
    ...(input.canarySettings !== undefined && {
      canarySettings: serializeAws_restJson1CanarySettings(
        input.canarySettings,
        context
      )
    }),
    ...(input.deploymentId !== undefined && {
      deploymentId: input.deploymentId
    }),
    ...(input.description !== undefined && { description: input.description }),
    ...(input.documentationVersion !== undefined && {
      documentationVersion: input.documentationVersion
    }),
    ...(input.name !== undefined && { name: input.name }),
    ...(input.stageName !== undefined && { stageName: input.stageName }),
    ...(input.tags !== undefined && {
      tags: serializeAws_restJson1MapOfStringToString(input.tags, context)
    }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title }),
    ...(input.tracingEnabled !== undefined && {
      tracingEnabled: input.tracingEnabled
    }),
    ...(input.variables !== undefined && {
      variables: serializeAws_restJson1MapOfStringToString(
        input.variables,
        context
      )
    })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1CreateUsagePlanCommand = async (
  input: CreateUsagePlanCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath = "/usageplans";
  let body: any;
  body = JSON.stringify({
    ...(input.apiStages !== undefined && {
      apiStages: serializeAws_restJson1ListOfApiStage(input.apiStages, context)
    }),
    ...(input.description !== undefined && { description: input.description }),
    ...(input.name !== undefined && { name: input.name }),
    ...(input.quota !== undefined && {
      quota: serializeAws_restJson1QuotaSettings(input.quota, context)
    }),
    ...(input.tags !== undefined && {
      tags: serializeAws_restJson1MapOfStringToString(input.tags, context)
    }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.throttle !== undefined && {
      throttle: serializeAws_restJson1ThrottleSettings(input.throttle, context)
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1CreateUsagePlanKeyCommand = async (
  input: CreateUsagePlanKeyCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath = "/usageplans/{usagePlanId}/keys";
  if (input.usagePlanId !== undefined) {
    const labelValue: string = input.usagePlanId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: usagePlanId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{usagePlanId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: usagePlanId.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.keyId !== undefined && { keyId: input.keyId }),
    ...(input.keyType !== undefined && { keyType: input.keyType }),
    ...(input.name !== undefined && { name: input.name }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1CreateVpcLinkCommand = async (
  input: CreateVpcLinkCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath = "/vpclinks";
  let body: any;
  body = JSON.stringify({
    ...(input.description !== undefined && { description: input.description }),
    ...(input.name !== undefined && { name: input.name }),
    ...(input.tags !== undefined && {
      tags: serializeAws_restJson1MapOfStringToString(input.tags, context)
    }),
    ...(input.targetArns !== undefined && {
      targetArns: serializeAws_restJson1ListOfString(input.targetArns, context)
    }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1DeleteApiKeyCommand = async (
  input: DeleteApiKeyCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath = "/apikeys/{apiKey}";
  if (input.apiKey !== undefined) {
    const labelValue: string = input.apiKey;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: apiKey.");
    }
    resolvedPath = resolvedPath.replace(
      "{apiKey}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: apiKey.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.name !== undefined && { name: input.name }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1DeleteAuthorizerCommand = async (
  input: DeleteAuthorizerCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath = "/restapis/{restApiId}/authorizers/{authorizerId}";
  if (input.authorizerId !== undefined) {
    const labelValue: string = input.authorizerId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: authorizerId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{authorizerId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: authorizerId.");
  }
  if (input.restApiId !== undefined) {
    const labelValue: string = input.restApiId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: restApiId.");
    }
    resolvedPath = resolvedPath.replace(
      "{restApiId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: restApiId.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.name !== undefined && { name: input.name }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1DeleteBasePathMappingCommand = async (
  input: DeleteBasePathMappingCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath = "/domainnames/{domainName}/basepathmappings/{basePath}";
  if (input.basePath !== undefined) {
    const labelValue: string = input.basePath;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: basePath.");
    }
    resolvedPath = resolvedPath.replace(
      "{basePath}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: basePath.");
  }
  if (input.domainName !== undefined) {
    const labelValue: string = input.domainName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: domainName.");
    }
    resolvedPath = resolvedPath.replace(
      "{domainName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: domainName.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.name !== undefined && { name: input.name }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1DeleteClientCertificateCommand = async (
  input: DeleteClientCertificateCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath = "/clientcertificates/{clientCertificateId}";
  if (input.clientCertificateId !== undefined) {
    const labelValue: string = input.clientCertificateId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: clientCertificateId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{clientCertificateId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: clientCertificateId."
    );
  }
  let body: any;
  body = JSON.stringify({
    ...(input.name !== undefined && { name: input.name }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1DeleteDeploymentCommand = async (
  input: DeleteDeploymentCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath = "/restapis/{restApiId}/deployments/{deploymentId}";
  if (input.deploymentId !== undefined) {
    const labelValue: string = input.deploymentId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: deploymentId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{deploymentId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: deploymentId.");
  }
  if (input.restApiId !== undefined) {
    const labelValue: string = input.restApiId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: restApiId.");
    }
    resolvedPath = resolvedPath.replace(
      "{restApiId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: restApiId.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.name !== undefined && { name: input.name }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1DeleteDocumentationPartCommand = async (
  input: DeleteDocumentationPartCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath =
    "/restapis/{restApiId}/documentation/parts/{documentationPartId}";
  if (input.documentationPartId !== undefined) {
    const labelValue: string = input.documentationPartId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: documentationPartId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{documentationPartId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: documentationPartId."
    );
  }
  if (input.restApiId !== undefined) {
    const labelValue: string = input.restApiId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: restApiId.");
    }
    resolvedPath = resolvedPath.replace(
      "{restApiId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: restApiId.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.name !== undefined && { name: input.name }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1DeleteDocumentationVersionCommand = async (
  input: DeleteDocumentationVersionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath =
    "/restapis/{restApiId}/documentation/versions/{documentationVersion}";
  if (input.documentationVersion !== undefined) {
    const labelValue: string = input.documentationVersion;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: documentationVersion."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{documentationVersion}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: documentationVersion."
    );
  }
  if (input.restApiId !== undefined) {
    const labelValue: string = input.restApiId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: restApiId.");
    }
    resolvedPath = resolvedPath.replace(
      "{restApiId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: restApiId.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.name !== undefined && { name: input.name }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1DeleteDomainNameCommand = async (
  input: DeleteDomainNameCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath = "/domainnames/{domainName}";
  if (input.domainName !== undefined) {
    const labelValue: string = input.domainName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: domainName.");
    }
    resolvedPath = resolvedPath.replace(
      "{domainName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: domainName.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.name !== undefined && { name: input.name }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1DeleteGatewayResponseCommand = async (
  input: DeleteGatewayResponseCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath = "/restapis/{restApiId}/gatewayresponses/{responseType}";
  if (input.responseType !== undefined) {
    const labelValue: string = input.responseType;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: responseType."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{responseType}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: responseType.");
  }
  if (input.restApiId !== undefined) {
    const labelValue: string = input.restApiId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: restApiId.");
    }
    resolvedPath = resolvedPath.replace(
      "{restApiId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: restApiId.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.name !== undefined && { name: input.name }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1DeleteIntegrationCommand = async (
  input: DeleteIntegrationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath =
    "/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}/integration";
  if (input.httpMethod !== undefined) {
    const labelValue: string = input.httpMethod;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: httpMethod.");
    }
    resolvedPath = resolvedPath.replace(
      "{httpMethod}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: httpMethod.");
  }
  if (input.resourceId !== undefined) {
    const labelValue: string = input.resourceId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: resourceId.");
    }
    resolvedPath = resolvedPath.replace(
      "{resourceId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: resourceId.");
  }
  if (input.restApiId !== undefined) {
    const labelValue: string = input.restApiId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: restApiId.");
    }
    resolvedPath = resolvedPath.replace(
      "{restApiId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: restApiId.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.name !== undefined && { name: input.name }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1DeleteIntegrationResponseCommand = async (
  input: DeleteIntegrationResponseCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath =
    "/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}/integration/responses/{statusCode}";
  if (input.httpMethod !== undefined) {
    const labelValue: string = input.httpMethod;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: httpMethod.");
    }
    resolvedPath = resolvedPath.replace(
      "{httpMethod}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: httpMethod.");
  }
  if (input.resourceId !== undefined) {
    const labelValue: string = input.resourceId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: resourceId.");
    }
    resolvedPath = resolvedPath.replace(
      "{resourceId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: resourceId.");
  }
  if (input.restApiId !== undefined) {
    const labelValue: string = input.restApiId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: restApiId.");
    }
    resolvedPath = resolvedPath.replace(
      "{restApiId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: restApiId.");
  }
  if (input.statusCode !== undefined) {
    const labelValue: string = input.statusCode;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: statusCode.");
    }
    resolvedPath = resolvedPath.replace(
      "{statusCode}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: statusCode.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.name !== undefined && { name: input.name }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1DeleteMethodCommand = async (
  input: DeleteMethodCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath =
    "/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}";
  if (input.httpMethod !== undefined) {
    const labelValue: string = input.httpMethod;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: httpMethod.");
    }
    resolvedPath = resolvedPath.replace(
      "{httpMethod}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: httpMethod.");
  }
  if (input.resourceId !== undefined) {
    const labelValue: string = input.resourceId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: resourceId.");
    }
    resolvedPath = resolvedPath.replace(
      "{resourceId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: resourceId.");
  }
  if (input.restApiId !== undefined) {
    const labelValue: string = input.restApiId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: restApiId.");
    }
    resolvedPath = resolvedPath.replace(
      "{restApiId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: restApiId.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.name !== undefined && { name: input.name }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1DeleteMethodResponseCommand = async (
  input: DeleteMethodResponseCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath =
    "/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}/responses/{statusCode}";
  if (input.httpMethod !== undefined) {
    const labelValue: string = input.httpMethod;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: httpMethod.");
    }
    resolvedPath = resolvedPath.replace(
      "{httpMethod}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: httpMethod.");
  }
  if (input.resourceId !== undefined) {
    const labelValue: string = input.resourceId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: resourceId.");
    }
    resolvedPath = resolvedPath.replace(
      "{resourceId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: resourceId.");
  }
  if (input.restApiId !== undefined) {
    const labelValue: string = input.restApiId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: restApiId.");
    }
    resolvedPath = resolvedPath.replace(
      "{restApiId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: restApiId.");
  }
  if (input.statusCode !== undefined) {
    const labelValue: string = input.statusCode;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: statusCode.");
    }
    resolvedPath = resolvedPath.replace(
      "{statusCode}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: statusCode.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.name !== undefined && { name: input.name }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1DeleteModelCommand = async (
  input: DeleteModelCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath = "/restapis/{restApiId}/models/{modelName}";
  if (input.modelName !== undefined) {
    const labelValue: string = input.modelName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: modelName.");
    }
    resolvedPath = resolvedPath.replace(
      "{modelName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: modelName.");
  }
  if (input.restApiId !== undefined) {
    const labelValue: string = input.restApiId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: restApiId.");
    }
    resolvedPath = resolvedPath.replace(
      "{restApiId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: restApiId.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.name !== undefined && { name: input.name }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1DeleteRequestValidatorCommand = async (
  input: DeleteRequestValidatorCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath =
    "/restapis/{restApiId}/requestvalidators/{requestValidatorId}";
  if (input.requestValidatorId !== undefined) {
    const labelValue: string = input.requestValidatorId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: requestValidatorId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{requestValidatorId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: requestValidatorId."
    );
  }
  if (input.restApiId !== undefined) {
    const labelValue: string = input.restApiId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: restApiId.");
    }
    resolvedPath = resolvedPath.replace(
      "{restApiId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: restApiId.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.name !== undefined && { name: input.name }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1DeleteResourceCommand = async (
  input: DeleteResourceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath = "/restapis/{restApiId}/resources/{resourceId}";
  if (input.resourceId !== undefined) {
    const labelValue: string = input.resourceId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: resourceId.");
    }
    resolvedPath = resolvedPath.replace(
      "{resourceId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: resourceId.");
  }
  if (input.restApiId !== undefined) {
    const labelValue: string = input.restApiId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: restApiId.");
    }
    resolvedPath = resolvedPath.replace(
      "{restApiId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: restApiId.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.name !== undefined && { name: input.name }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1DeleteRestApiCommand = async (
  input: DeleteRestApiCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath = "/restapis/{restApiId}";
  if (input.restApiId !== undefined) {
    const labelValue: string = input.restApiId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: restApiId.");
    }
    resolvedPath = resolvedPath.replace(
      "{restApiId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: restApiId.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.name !== undefined && { name: input.name }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1DeleteStageCommand = async (
  input: DeleteStageCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath = "/restapis/{restApiId}/stages/{stageName}";
  if (input.restApiId !== undefined) {
    const labelValue: string = input.restApiId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: restApiId.");
    }
    resolvedPath = resolvedPath.replace(
      "{restApiId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: restApiId.");
  }
  if (input.stageName !== undefined) {
    const labelValue: string = input.stageName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: stageName.");
    }
    resolvedPath = resolvedPath.replace(
      "{stageName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: stageName.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.name !== undefined && { name: input.name }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1DeleteUsagePlanCommand = async (
  input: DeleteUsagePlanCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath = "/usageplans/{usagePlanId}";
  if (input.usagePlanId !== undefined) {
    const labelValue: string = input.usagePlanId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: usagePlanId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{usagePlanId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: usagePlanId.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.name !== undefined && { name: input.name }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1DeleteUsagePlanKeyCommand = async (
  input: DeleteUsagePlanKeyCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath = "/usageplans/{usagePlanId}/keys/{keyId}";
  if (input.keyId !== undefined) {
    const labelValue: string = input.keyId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: keyId.");
    }
    resolvedPath = resolvedPath.replace(
      "{keyId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: keyId.");
  }
  if (input.usagePlanId !== undefined) {
    const labelValue: string = input.usagePlanId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: usagePlanId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{usagePlanId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: usagePlanId.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.name !== undefined && { name: input.name }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1DeleteVpcLinkCommand = async (
  input: DeleteVpcLinkCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath = "/vpclinks/{vpcLinkId}";
  if (input.vpcLinkId !== undefined) {
    const labelValue: string = input.vpcLinkId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: vpcLinkId.");
    }
    resolvedPath = resolvedPath.replace(
      "{vpcLinkId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: vpcLinkId.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.name !== undefined && { name: input.name }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1FlushStageAuthorizersCacheCommand = async (
  input: FlushStageAuthorizersCacheCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath =
    "/restapis/{restApiId}/stages/{stageName}/cache/authorizers";
  if (input.restApiId !== undefined) {
    const labelValue: string = input.restApiId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: restApiId.");
    }
    resolvedPath = resolvedPath.replace(
      "{restApiId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: restApiId.");
  }
  if (input.stageName !== undefined) {
    const labelValue: string = input.stageName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: stageName.");
    }
    resolvedPath = resolvedPath.replace(
      "{stageName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: stageName.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.name !== undefined && { name: input.name }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1FlushStageCacheCommand = async (
  input: FlushStageCacheCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath = "/restapis/{restApiId}/stages/{stageName}/cache/data";
  if (input.restApiId !== undefined) {
    const labelValue: string = input.restApiId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: restApiId.");
    }
    resolvedPath = resolvedPath.replace(
      "{restApiId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: restApiId.");
  }
  if (input.stageName !== undefined) {
    const labelValue: string = input.stageName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: stageName.");
    }
    resolvedPath = resolvedPath.replace(
      "{stageName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: stageName.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.name !== undefined && { name: input.name }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1GenerateClientCertificateCommand = async (
  input: GenerateClientCertificateCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath = "/clientcertificates";
  let body: any;
  body = JSON.stringify({
    ...(input.description !== undefined && { description: input.description }),
    ...(input.name !== undefined && { name: input.name }),
    ...(input.tags !== undefined && {
      tags: serializeAws_restJson1MapOfStringToString(input.tags, context)
    }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1GetAccountCommand = async (
  input: GetAccountCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath = "/account";
  let body: any;
  body = JSON.stringify({
    ...(input.name !== undefined && { name: input.name }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1GetApiKeyCommand = async (
  input: GetApiKeyCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath = "/apikeys/{apiKey}";
  if (input.apiKey !== undefined) {
    const labelValue: string = input.apiKey;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: apiKey.");
    }
    resolvedPath = resolvedPath.replace(
      "{apiKey}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: apiKey.");
  }
  const query: any = {
    ...(input.includeValue !== undefined && {
      includeValue: input.includeValue.toString()
    })
  };
  let body: any;
  body = JSON.stringify({
    ...(input.name !== undefined && { name: input.name }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body
  });
};

export const serializeAws_restJson1GetApiKeysCommand = async (
  input: GetApiKeysCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath = "/apikeys";
  const query: any = {
    ...(input.customerId !== undefined && { customerId: input.customerId }),
    ...(input.includeValues !== undefined && {
      includeValues: input.includeValues.toString()
    }),
    ...(input.limit !== undefined && { limit: input.limit.toString() }),
    ...(input.nameQuery !== undefined && { name: input.nameQuery }),
    ...(input.position !== undefined && { position: input.position })
  };
  let body: any;
  body = JSON.stringify({
    ...(input.name !== undefined && { name: input.name }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body
  });
};

export const serializeAws_restJson1GetAuthorizerCommand = async (
  input: GetAuthorizerCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath = "/restapis/{restApiId}/authorizers/{authorizerId}";
  if (input.authorizerId !== undefined) {
    const labelValue: string = input.authorizerId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: authorizerId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{authorizerId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: authorizerId.");
  }
  if (input.restApiId !== undefined) {
    const labelValue: string = input.restApiId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: restApiId.");
    }
    resolvedPath = resolvedPath.replace(
      "{restApiId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: restApiId.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.name !== undefined && { name: input.name }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1GetAuthorizersCommand = async (
  input: GetAuthorizersCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath = "/restapis/{restApiId}/authorizers";
  if (input.restApiId !== undefined) {
    const labelValue: string = input.restApiId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: restApiId.");
    }
    resolvedPath = resolvedPath.replace(
      "{restApiId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: restApiId.");
  }
  const query: any = {
    ...(input.limit !== undefined && { limit: input.limit.toString() }),
    ...(input.position !== undefined && { position: input.position })
  };
  let body: any;
  body = JSON.stringify({
    ...(input.name !== undefined && { name: input.name }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body
  });
};

export const serializeAws_restJson1GetBasePathMappingCommand = async (
  input: GetBasePathMappingCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath = "/domainnames/{domainName}/basepathmappings/{basePath}";
  if (input.basePath !== undefined) {
    const labelValue: string = input.basePath;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: basePath.");
    }
    resolvedPath = resolvedPath.replace(
      "{basePath}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: basePath.");
  }
  if (input.domainName !== undefined) {
    const labelValue: string = input.domainName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: domainName.");
    }
    resolvedPath = resolvedPath.replace(
      "{domainName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: domainName.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.name !== undefined && { name: input.name }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1GetBasePathMappingsCommand = async (
  input: GetBasePathMappingsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath = "/domainnames/{domainName}/basepathmappings";
  if (input.domainName !== undefined) {
    const labelValue: string = input.domainName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: domainName.");
    }
    resolvedPath = resolvedPath.replace(
      "{domainName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: domainName.");
  }
  const query: any = {
    ...(input.limit !== undefined && { limit: input.limit.toString() }),
    ...(input.position !== undefined && { position: input.position })
  };
  let body: any;
  body = JSON.stringify({
    ...(input.name !== undefined && { name: input.name }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body
  });
};

export const serializeAws_restJson1GetClientCertificateCommand = async (
  input: GetClientCertificateCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath = "/clientcertificates/{clientCertificateId}";
  if (input.clientCertificateId !== undefined) {
    const labelValue: string = input.clientCertificateId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: clientCertificateId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{clientCertificateId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: clientCertificateId."
    );
  }
  let body: any;
  body = JSON.stringify({
    ...(input.name !== undefined && { name: input.name }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1GetClientCertificatesCommand = async (
  input: GetClientCertificatesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath = "/clientcertificates";
  const query: any = {
    ...(input.limit !== undefined && { limit: input.limit.toString() }),
    ...(input.position !== undefined && { position: input.position })
  };
  let body: any;
  body = JSON.stringify({
    ...(input.name !== undefined && { name: input.name }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body
  });
};

export const serializeAws_restJson1GetDeploymentCommand = async (
  input: GetDeploymentCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath = "/restapis/{restApiId}/deployments/{deploymentId}";
  if (input.deploymentId !== undefined) {
    const labelValue: string = input.deploymentId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: deploymentId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{deploymentId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: deploymentId.");
  }
  if (input.restApiId !== undefined) {
    const labelValue: string = input.restApiId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: restApiId.");
    }
    resolvedPath = resolvedPath.replace(
      "{restApiId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: restApiId.");
  }
  const query: any = {
    ...(input.embed !== undefined && {
      embed: (input.embed || []).map(_entry => _entry)
    })
  };
  let body: any;
  body = JSON.stringify({
    ...(input.name !== undefined && { name: input.name }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body
  });
};

export const serializeAws_restJson1GetDeploymentsCommand = async (
  input: GetDeploymentsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath = "/restapis/{restApiId}/deployments";
  if (input.restApiId !== undefined) {
    const labelValue: string = input.restApiId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: restApiId.");
    }
    resolvedPath = resolvedPath.replace(
      "{restApiId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: restApiId.");
  }
  const query: any = {
    ...(input.limit !== undefined && { limit: input.limit.toString() }),
    ...(input.position !== undefined && { position: input.position })
  };
  let body: any;
  body = JSON.stringify({
    ...(input.name !== undefined && { name: input.name }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body
  });
};

export const serializeAws_restJson1GetDocumentationPartCommand = async (
  input: GetDocumentationPartCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath =
    "/restapis/{restApiId}/documentation/parts/{documentationPartId}";
  if (input.documentationPartId !== undefined) {
    const labelValue: string = input.documentationPartId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: documentationPartId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{documentationPartId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: documentationPartId."
    );
  }
  if (input.restApiId !== undefined) {
    const labelValue: string = input.restApiId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: restApiId.");
    }
    resolvedPath = resolvedPath.replace(
      "{restApiId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: restApiId.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.name !== undefined && { name: input.name }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1GetDocumentationPartsCommand = async (
  input: GetDocumentationPartsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath = "/restapis/{restApiId}/documentation/parts";
  if (input.restApiId !== undefined) {
    const labelValue: string = input.restApiId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: restApiId.");
    }
    resolvedPath = resolvedPath.replace(
      "{restApiId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: restApiId.");
  }
  const query: any = {
    ...(input.limit !== undefined && { limit: input.limit.toString() }),
    ...(input.locationStatus !== undefined && {
      locationStatus: input.locationStatus
    }),
    ...(input.nameQuery !== undefined && { name: input.nameQuery }),
    ...(input.path !== undefined && { path: input.path }),
    ...(input.position !== undefined && { position: input.position }),
    ...(input.type !== undefined && { type: input.type })
  };
  let body: any;
  body = JSON.stringify({
    ...(input.name !== undefined && { name: input.name }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body
  });
};

export const serializeAws_restJson1GetDocumentationVersionCommand = async (
  input: GetDocumentationVersionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath =
    "/restapis/{restApiId}/documentation/versions/{documentationVersion}";
  if (input.documentationVersion !== undefined) {
    const labelValue: string = input.documentationVersion;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: documentationVersion."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{documentationVersion}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: documentationVersion."
    );
  }
  if (input.restApiId !== undefined) {
    const labelValue: string = input.restApiId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: restApiId.");
    }
    resolvedPath = resolvedPath.replace(
      "{restApiId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: restApiId.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.name !== undefined && { name: input.name }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1GetDocumentationVersionsCommand = async (
  input: GetDocumentationVersionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath = "/restapis/{restApiId}/documentation/versions";
  if (input.restApiId !== undefined) {
    const labelValue: string = input.restApiId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: restApiId.");
    }
    resolvedPath = resolvedPath.replace(
      "{restApiId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: restApiId.");
  }
  const query: any = {
    ...(input.limit !== undefined && { limit: input.limit.toString() }),
    ...(input.position !== undefined && { position: input.position })
  };
  let body: any;
  body = JSON.stringify({
    ...(input.name !== undefined && { name: input.name }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body
  });
};

export const serializeAws_restJson1GetDomainNameCommand = async (
  input: GetDomainNameCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath = "/domainnames/{domainName}";
  if (input.domainName !== undefined) {
    const labelValue: string = input.domainName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: domainName.");
    }
    resolvedPath = resolvedPath.replace(
      "{domainName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: domainName.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.name !== undefined && { name: input.name }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1GetDomainNamesCommand = async (
  input: GetDomainNamesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath = "/domainnames";
  const query: any = {
    ...(input.limit !== undefined && { limit: input.limit.toString() }),
    ...(input.position !== undefined && { position: input.position })
  };
  let body: any;
  body = JSON.stringify({
    ...(input.name !== undefined && { name: input.name }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body
  });
};

export const serializeAws_restJson1GetExportCommand = async (
  input: GetExportCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json",
    ...(isSerializableHeaderValue(input.accepts) && { Accept: input.accepts! })
  };
  let resolvedPath =
    "/restapis/{restApiId}/stages/{stageName}/exports/{exportType}";
  if (input.exportType !== undefined) {
    const labelValue: string = input.exportType;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: exportType.");
    }
    resolvedPath = resolvedPath.replace(
      "{exportType}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: exportType.");
  }
  if (input.restApiId !== undefined) {
    const labelValue: string = input.restApiId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: restApiId.");
    }
    resolvedPath = resolvedPath.replace(
      "{restApiId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: restApiId.");
  }
  if (input.stageName !== undefined) {
    const labelValue: string = input.stageName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: stageName.");
    }
    resolvedPath = resolvedPath.replace(
      "{stageName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: stageName.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.parameters !== undefined && {
      parameters: serializeAws_restJson1MapOfStringToString(
        input.parameters,
        context
      )
    })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1GetGatewayResponseCommand = async (
  input: GetGatewayResponseCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath = "/restapis/{restApiId}/gatewayresponses/{responseType}";
  if (input.responseType !== undefined) {
    const labelValue: string = input.responseType;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: responseType."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{responseType}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: responseType.");
  }
  if (input.restApiId !== undefined) {
    const labelValue: string = input.restApiId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: restApiId.");
    }
    resolvedPath = resolvedPath.replace(
      "{restApiId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: restApiId.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.name !== undefined && { name: input.name }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1GetGatewayResponsesCommand = async (
  input: GetGatewayResponsesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath = "/restapis/{restApiId}/gatewayresponses";
  if (input.restApiId !== undefined) {
    const labelValue: string = input.restApiId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: restApiId.");
    }
    resolvedPath = resolvedPath.replace(
      "{restApiId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: restApiId.");
  }
  const query: any = {
    ...(input.limit !== undefined && { limit: input.limit.toString() }),
    ...(input.position !== undefined && { position: input.position })
  };
  let body: any;
  body = JSON.stringify({
    ...(input.name !== undefined && { name: input.name }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body
  });
};

export const serializeAws_restJson1GetIntegrationCommand = async (
  input: GetIntegrationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath =
    "/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}/integration";
  if (input.httpMethod !== undefined) {
    const labelValue: string = input.httpMethod;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: httpMethod.");
    }
    resolvedPath = resolvedPath.replace(
      "{httpMethod}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: httpMethod.");
  }
  if (input.resourceId !== undefined) {
    const labelValue: string = input.resourceId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: resourceId.");
    }
    resolvedPath = resolvedPath.replace(
      "{resourceId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: resourceId.");
  }
  if (input.restApiId !== undefined) {
    const labelValue: string = input.restApiId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: restApiId.");
    }
    resolvedPath = resolvedPath.replace(
      "{restApiId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: restApiId.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.name !== undefined && { name: input.name }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1GetIntegrationResponseCommand = async (
  input: GetIntegrationResponseCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath =
    "/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}/integration/responses/{statusCode}";
  if (input.httpMethod !== undefined) {
    const labelValue: string = input.httpMethod;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: httpMethod.");
    }
    resolvedPath = resolvedPath.replace(
      "{httpMethod}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: httpMethod.");
  }
  if (input.resourceId !== undefined) {
    const labelValue: string = input.resourceId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: resourceId.");
    }
    resolvedPath = resolvedPath.replace(
      "{resourceId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: resourceId.");
  }
  if (input.restApiId !== undefined) {
    const labelValue: string = input.restApiId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: restApiId.");
    }
    resolvedPath = resolvedPath.replace(
      "{restApiId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: restApiId.");
  }
  if (input.statusCode !== undefined) {
    const labelValue: string = input.statusCode;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: statusCode.");
    }
    resolvedPath = resolvedPath.replace(
      "{statusCode}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: statusCode.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.name !== undefined && { name: input.name }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1GetMethodCommand = async (
  input: GetMethodCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath =
    "/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}";
  if (input.httpMethod !== undefined) {
    const labelValue: string = input.httpMethod;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: httpMethod.");
    }
    resolvedPath = resolvedPath.replace(
      "{httpMethod}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: httpMethod.");
  }
  if (input.resourceId !== undefined) {
    const labelValue: string = input.resourceId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: resourceId.");
    }
    resolvedPath = resolvedPath.replace(
      "{resourceId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: resourceId.");
  }
  if (input.restApiId !== undefined) {
    const labelValue: string = input.restApiId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: restApiId.");
    }
    resolvedPath = resolvedPath.replace(
      "{restApiId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: restApiId.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.name !== undefined && { name: input.name }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1GetMethodResponseCommand = async (
  input: GetMethodResponseCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath =
    "/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}/responses/{statusCode}";
  if (input.httpMethod !== undefined) {
    const labelValue: string = input.httpMethod;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: httpMethod.");
    }
    resolvedPath = resolvedPath.replace(
      "{httpMethod}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: httpMethod.");
  }
  if (input.resourceId !== undefined) {
    const labelValue: string = input.resourceId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: resourceId.");
    }
    resolvedPath = resolvedPath.replace(
      "{resourceId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: resourceId.");
  }
  if (input.restApiId !== undefined) {
    const labelValue: string = input.restApiId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: restApiId.");
    }
    resolvedPath = resolvedPath.replace(
      "{restApiId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: restApiId.");
  }
  if (input.statusCode !== undefined) {
    const labelValue: string = input.statusCode;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: statusCode.");
    }
    resolvedPath = resolvedPath.replace(
      "{statusCode}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: statusCode.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.name !== undefined && { name: input.name }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1GetModelCommand = async (
  input: GetModelCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath = "/restapis/{restApiId}/models/{modelName}";
  if (input.modelName !== undefined) {
    const labelValue: string = input.modelName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: modelName.");
    }
    resolvedPath = resolvedPath.replace(
      "{modelName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: modelName.");
  }
  if (input.restApiId !== undefined) {
    const labelValue: string = input.restApiId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: restApiId.");
    }
    resolvedPath = resolvedPath.replace(
      "{restApiId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: restApiId.");
  }
  const query: any = {
    ...(input.flatten !== undefined && { flatten: input.flatten.toString() })
  };
  let body: any;
  body = JSON.stringify({
    ...(input.name !== undefined && { name: input.name }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body
  });
};

export const serializeAws_restJson1GetModelsCommand = async (
  input: GetModelsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath = "/restapis/{restApiId}/models";
  if (input.restApiId !== undefined) {
    const labelValue: string = input.restApiId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: restApiId.");
    }
    resolvedPath = resolvedPath.replace(
      "{restApiId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: restApiId.");
  }
  const query: any = {
    ...(input.limit !== undefined && { limit: input.limit.toString() }),
    ...(input.position !== undefined && { position: input.position })
  };
  let body: any;
  body = JSON.stringify({
    ...(input.name !== undefined && { name: input.name }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body
  });
};

export const serializeAws_restJson1GetModelTemplateCommand = async (
  input: GetModelTemplateCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath =
    "/restapis/{restApiId}/models/{modelName}/default_template";
  if (input.modelName !== undefined) {
    const labelValue: string = input.modelName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: modelName.");
    }
    resolvedPath = resolvedPath.replace(
      "{modelName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: modelName.");
  }
  if (input.restApiId !== undefined) {
    const labelValue: string = input.restApiId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: restApiId.");
    }
    resolvedPath = resolvedPath.replace(
      "{restApiId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: restApiId.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.name !== undefined && { name: input.name }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1GetRequestValidatorCommand = async (
  input: GetRequestValidatorCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath =
    "/restapis/{restApiId}/requestvalidators/{requestValidatorId}";
  if (input.requestValidatorId !== undefined) {
    const labelValue: string = input.requestValidatorId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: requestValidatorId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{requestValidatorId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: requestValidatorId."
    );
  }
  if (input.restApiId !== undefined) {
    const labelValue: string = input.restApiId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: restApiId.");
    }
    resolvedPath = resolvedPath.replace(
      "{restApiId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: restApiId.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.name !== undefined && { name: input.name }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1GetRequestValidatorsCommand = async (
  input: GetRequestValidatorsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath = "/restapis/{restApiId}/requestvalidators";
  if (input.restApiId !== undefined) {
    const labelValue: string = input.restApiId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: restApiId.");
    }
    resolvedPath = resolvedPath.replace(
      "{restApiId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: restApiId.");
  }
  const query: any = {
    ...(input.limit !== undefined && { limit: input.limit.toString() }),
    ...(input.position !== undefined && { position: input.position })
  };
  let body: any;
  body = JSON.stringify({
    ...(input.name !== undefined && { name: input.name }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body
  });
};

export const serializeAws_restJson1GetResourceCommand = async (
  input: GetResourceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath = "/restapis/{restApiId}/resources/{resourceId}";
  if (input.resourceId !== undefined) {
    const labelValue: string = input.resourceId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: resourceId.");
    }
    resolvedPath = resolvedPath.replace(
      "{resourceId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: resourceId.");
  }
  if (input.restApiId !== undefined) {
    const labelValue: string = input.restApiId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: restApiId.");
    }
    resolvedPath = resolvedPath.replace(
      "{restApiId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: restApiId.");
  }
  const query: any = {
    ...(input.embed !== undefined && {
      embed: (input.embed || []).map(_entry => _entry)
    })
  };
  let body: any;
  body = JSON.stringify({
    ...(input.name !== undefined && { name: input.name }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body
  });
};

export const serializeAws_restJson1GetResourcesCommand = async (
  input: GetResourcesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath = "/restapis/{restApiId}/resources";
  if (input.restApiId !== undefined) {
    const labelValue: string = input.restApiId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: restApiId.");
    }
    resolvedPath = resolvedPath.replace(
      "{restApiId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: restApiId.");
  }
  const query: any = {
    ...(input.embed !== undefined && {
      embed: (input.embed || []).map(_entry => _entry)
    }),
    ...(input.limit !== undefined && { limit: input.limit.toString() }),
    ...(input.position !== undefined && { position: input.position })
  };
  let body: any;
  body = JSON.stringify({
    ...(input.name !== undefined && { name: input.name }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body
  });
};

export const serializeAws_restJson1GetRestApiCommand = async (
  input: GetRestApiCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath = "/restapis/{restApiId}";
  if (input.restApiId !== undefined) {
    const labelValue: string = input.restApiId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: restApiId.");
    }
    resolvedPath = resolvedPath.replace(
      "{restApiId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: restApiId.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.name !== undefined && { name: input.name }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1GetRestApisCommand = async (
  input: GetRestApisCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath = "/restapis";
  const query: any = {
    ...(input.limit !== undefined && { limit: input.limit.toString() }),
    ...(input.position !== undefined && { position: input.position })
  };
  let body: any;
  body = JSON.stringify({
    ...(input.name !== undefined && { name: input.name }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body
  });
};

export const serializeAws_restJson1GetSdkCommand = async (
  input: GetSdkCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath = "/restapis/{restApiId}/stages/{stageName}/sdks/{sdkType}";
  if (input.restApiId !== undefined) {
    const labelValue: string = input.restApiId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: restApiId.");
    }
    resolvedPath = resolvedPath.replace(
      "{restApiId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: restApiId.");
  }
  if (input.sdkType !== undefined) {
    const labelValue: string = input.sdkType;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: sdkType.");
    }
    resolvedPath = resolvedPath.replace(
      "{sdkType}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: sdkType.");
  }
  if (input.stageName !== undefined) {
    const labelValue: string = input.stageName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: stageName.");
    }
    resolvedPath = resolvedPath.replace(
      "{stageName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: stageName.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.parameters !== undefined && {
      parameters: serializeAws_restJson1MapOfStringToString(
        input.parameters,
        context
      )
    })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1GetSdkTypeCommand = async (
  input: GetSdkTypeCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath = "/sdktypes/{id}";
  if (input.id !== undefined) {
    const labelValue: string = input.id;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: id.");
    }
    resolvedPath = resolvedPath.replace(
      "{id}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: id.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.name !== undefined && { name: input.name }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1GetSdkTypesCommand = async (
  input: GetSdkTypesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath = "/sdktypes";
  const query: any = {
    ...(input.limit !== undefined && { limit: input.limit.toString() }),
    ...(input.position !== undefined && { position: input.position })
  };
  let body: any;
  body = JSON.stringify({
    ...(input.name !== undefined && { name: input.name }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body
  });
};

export const serializeAws_restJson1GetStageCommand = async (
  input: GetStageCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath = "/restapis/{restApiId}/stages/{stageName}";
  if (input.restApiId !== undefined) {
    const labelValue: string = input.restApiId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: restApiId.");
    }
    resolvedPath = resolvedPath.replace(
      "{restApiId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: restApiId.");
  }
  if (input.stageName !== undefined) {
    const labelValue: string = input.stageName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: stageName.");
    }
    resolvedPath = resolvedPath.replace(
      "{stageName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: stageName.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.name !== undefined && { name: input.name }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1GetStagesCommand = async (
  input: GetStagesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath = "/restapis/{restApiId}/stages";
  if (input.restApiId !== undefined) {
    const labelValue: string = input.restApiId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: restApiId.");
    }
    resolvedPath = resolvedPath.replace(
      "{restApiId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: restApiId.");
  }
  const query: any = {
    ...(input.deploymentId !== undefined && {
      deploymentId: input.deploymentId
    })
  };
  let body: any;
  body = JSON.stringify({
    ...(input.name !== undefined && { name: input.name }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body
  });
};

export const serializeAws_restJson1GetTagsCommand = async (
  input: GetTagsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath = "/tags/{resourceArn}";
  if (input.resourceArn !== undefined) {
    const labelValue: string = input.resourceArn;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: resourceArn."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{resourceArn}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: resourceArn.");
  }
  const query: any = {
    ...(input.limit !== undefined && { limit: input.limit.toString() }),
    ...(input.position !== undefined && { position: input.position })
  };
  let body: any;
  body = JSON.stringify({
    ...(input.name !== undefined && { name: input.name }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body
  });
};

export const serializeAws_restJson1GetUsageCommand = async (
  input: GetUsageCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath = "/usageplans/{usagePlanId}/usage";
  if (input.usagePlanId !== undefined) {
    const labelValue: string = input.usagePlanId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: usagePlanId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{usagePlanId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: usagePlanId.");
  }
  const query: any = {
    ...(input.endDate !== undefined && { endDate: input.endDate }),
    ...(input.keyId !== undefined && { keyId: input.keyId }),
    ...(input.limit !== undefined && { limit: input.limit.toString() }),
    ...(input.position !== undefined && { position: input.position }),
    ...(input.startDate !== undefined && { startDate: input.startDate })
  };
  let body: any;
  body = JSON.stringify({
    ...(input.name !== undefined && { name: input.name }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body
  });
};

export const serializeAws_restJson1GetUsagePlanCommand = async (
  input: GetUsagePlanCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath = "/usageplans/{usagePlanId}";
  if (input.usagePlanId !== undefined) {
    const labelValue: string = input.usagePlanId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: usagePlanId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{usagePlanId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: usagePlanId.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.name !== undefined && { name: input.name }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1GetUsagePlanKeyCommand = async (
  input: GetUsagePlanKeyCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath = "/usageplans/{usagePlanId}/keys/{keyId}";
  if (input.keyId !== undefined) {
    const labelValue: string = input.keyId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: keyId.");
    }
    resolvedPath = resolvedPath.replace(
      "{keyId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: keyId.");
  }
  if (input.usagePlanId !== undefined) {
    const labelValue: string = input.usagePlanId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: usagePlanId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{usagePlanId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: usagePlanId.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.name !== undefined && { name: input.name }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1GetUsagePlanKeysCommand = async (
  input: GetUsagePlanKeysCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath = "/usageplans/{usagePlanId}/keys";
  if (input.usagePlanId !== undefined) {
    const labelValue: string = input.usagePlanId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: usagePlanId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{usagePlanId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: usagePlanId.");
  }
  const query: any = {
    ...(input.limit !== undefined && { limit: input.limit.toString() }),
    ...(input.nameQuery !== undefined && { name: input.nameQuery }),
    ...(input.position !== undefined && { position: input.position })
  };
  let body: any;
  body = JSON.stringify({
    ...(input.name !== undefined && { name: input.name }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body
  });
};

export const serializeAws_restJson1GetUsagePlansCommand = async (
  input: GetUsagePlansCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath = "/usageplans";
  const query: any = {
    ...(input.keyId !== undefined && { keyId: input.keyId }),
    ...(input.limit !== undefined && { limit: input.limit.toString() }),
    ...(input.position !== undefined && { position: input.position })
  };
  let body: any;
  body = JSON.stringify({
    ...(input.name !== undefined && { name: input.name }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body
  });
};

export const serializeAws_restJson1GetVpcLinkCommand = async (
  input: GetVpcLinkCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath = "/vpclinks/{vpcLinkId}";
  if (input.vpcLinkId !== undefined) {
    const labelValue: string = input.vpcLinkId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: vpcLinkId.");
    }
    resolvedPath = resolvedPath.replace(
      "{vpcLinkId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: vpcLinkId.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.name !== undefined && { name: input.name }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1GetVpcLinksCommand = async (
  input: GetVpcLinksCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath = "/vpclinks";
  const query: any = {
    ...(input.limit !== undefined && { limit: input.limit.toString() }),
    ...(input.position !== undefined && { position: input.position })
  };
  let body: any;
  body = JSON.stringify({
    ...(input.name !== undefined && { name: input.name }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body
  });
};

export const serializeAws_restJson1ImportApiKeysCommand = async (
  input: ImportApiKeysCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath = "/apikeys";
  const query: any = {
    mode: "import",
    ...(input.failOnWarnings !== undefined && {
      failonwarnings: input.failOnWarnings.toString()
    }),
    ...(input.format !== undefined && { format: input.format })
  };
  let body: any;
  body = JSON.stringify({
    ...(input.name !== undefined && { name: input.name }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    query,
    body
  });
};

export const serializeAws_restJson1ImportDocumentationPartsCommand = async (
  input: ImportDocumentationPartsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath = "/restapis/{restApiId}/documentation/parts";
  if (input.restApiId !== undefined) {
    const labelValue: string = input.restApiId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: restApiId.");
    }
    resolvedPath = resolvedPath.replace(
      "{restApiId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: restApiId.");
  }
  const query: any = {
    ...(input.failOnWarnings !== undefined && {
      failonwarnings: input.failOnWarnings.toString()
    }),
    ...(input.mode !== undefined && { mode: input.mode })
  };
  let body: any;
  body = JSON.stringify({
    ...(input.name !== undefined && { name: input.name }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "PUT",
    headers,
    path: resolvedPath,
    query,
    body
  });
};

export const serializeAws_restJson1ImportRestApiCommand = async (
  input: ImportRestApiCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath = "/restapis";
  const query: any = {
    mode: "import",
    ...(input.failOnWarnings !== undefined && {
      failonwarnings: input.failOnWarnings.toString()
    })
  };
  let body: any;
  body = JSON.stringify({
    ...(input.name !== undefined && { name: input.name }),
    ...(input.parameters !== undefined && {
      parameters: serializeAws_restJson1MapOfStringToString(
        input.parameters,
        context
      )
    }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    query,
    body
  });
};

export const serializeAws_restJson1PutGatewayResponseCommand = async (
  input: PutGatewayResponseCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath = "/restapis/{restApiId}/gatewayresponses/{responseType}";
  if (input.responseType !== undefined) {
    const labelValue: string = input.responseType;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: responseType."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{responseType}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: responseType.");
  }
  if (input.restApiId !== undefined) {
    const labelValue: string = input.restApiId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: restApiId.");
    }
    resolvedPath = resolvedPath.replace(
      "{restApiId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: restApiId.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.name !== undefined && { name: input.name }),
    ...(input.responseParameters !== undefined && {
      responseParameters: serializeAws_restJson1MapOfStringToString(
        input.responseParameters,
        context
      )
    }),
    ...(input.responseTemplates !== undefined && {
      responseTemplates: serializeAws_restJson1MapOfStringToString(
        input.responseTemplates,
        context
      )
    }),
    ...(input.statusCode !== undefined && { statusCode: input.statusCode }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "PUT",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1PutIntegrationCommand = async (
  input: PutIntegrationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath =
    "/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}/integration";
  if (input.httpMethod !== undefined) {
    const labelValue: string = input.httpMethod;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: httpMethod.");
    }
    resolvedPath = resolvedPath.replace(
      "{httpMethod}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: httpMethod.");
  }
  if (input.resourceId !== undefined) {
    const labelValue: string = input.resourceId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: resourceId.");
    }
    resolvedPath = resolvedPath.replace(
      "{resourceId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: resourceId.");
  }
  if (input.restApiId !== undefined) {
    const labelValue: string = input.restApiId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: restApiId.");
    }
    resolvedPath = resolvedPath.replace(
      "{restApiId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: restApiId.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.cacheKeyParameters !== undefined && {
      cacheKeyParameters: serializeAws_restJson1ListOfString(
        input.cacheKeyParameters,
        context
      )
    }),
    ...(input.cacheNamespace !== undefined && {
      cacheNamespace: input.cacheNamespace
    }),
    ...(input.connectionId !== undefined && {
      connectionId: input.connectionId
    }),
    ...(input.connectionType !== undefined && {
      connectionType: input.connectionType
    }),
    ...(input.contentHandling !== undefined && {
      contentHandling: input.contentHandling
    }),
    ...(input.credentials !== undefined && { credentials: input.credentials }),
    ...(input.integrationHttpMethod !== undefined && {
      httpMethod: input.integrationHttpMethod
    }),
    ...(input.name !== undefined && { name: input.name }),
    ...(input.passthroughBehavior !== undefined && {
      passthroughBehavior: input.passthroughBehavior
    }),
    ...(input.requestParameters !== undefined && {
      requestParameters: serializeAws_restJson1MapOfStringToString(
        input.requestParameters,
        context
      )
    }),
    ...(input.requestTemplates !== undefined && {
      requestTemplates: serializeAws_restJson1MapOfStringToString(
        input.requestTemplates,
        context
      )
    }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.timeoutInMillis !== undefined && {
      timeoutInMillis: input.timeoutInMillis
    }),
    ...(input.title !== undefined && { title: input.title }),
    ...(input.type !== undefined && { type: input.type }),
    ...(input.uri !== undefined && { uri: input.uri })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "PUT",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1PutIntegrationResponseCommand = async (
  input: PutIntegrationResponseCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath =
    "/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}/integration/responses/{statusCode}";
  if (input.httpMethod !== undefined) {
    const labelValue: string = input.httpMethod;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: httpMethod.");
    }
    resolvedPath = resolvedPath.replace(
      "{httpMethod}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: httpMethod.");
  }
  if (input.resourceId !== undefined) {
    const labelValue: string = input.resourceId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: resourceId.");
    }
    resolvedPath = resolvedPath.replace(
      "{resourceId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: resourceId.");
  }
  if (input.restApiId !== undefined) {
    const labelValue: string = input.restApiId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: restApiId.");
    }
    resolvedPath = resolvedPath.replace(
      "{restApiId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: restApiId.");
  }
  if (input.statusCode !== undefined) {
    const labelValue: string = input.statusCode;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: statusCode.");
    }
    resolvedPath = resolvedPath.replace(
      "{statusCode}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: statusCode.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.contentHandling !== undefined && {
      contentHandling: input.contentHandling
    }),
    ...(input.name !== undefined && { name: input.name }),
    ...(input.responseParameters !== undefined && {
      responseParameters: serializeAws_restJson1MapOfStringToString(
        input.responseParameters,
        context
      )
    }),
    ...(input.responseTemplates !== undefined && {
      responseTemplates: serializeAws_restJson1MapOfStringToString(
        input.responseTemplates,
        context
      )
    }),
    ...(input.selectionPattern !== undefined && {
      selectionPattern: input.selectionPattern
    }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "PUT",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1PutMethodCommand = async (
  input: PutMethodCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath =
    "/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}";
  if (input.httpMethod !== undefined) {
    const labelValue: string = input.httpMethod;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: httpMethod.");
    }
    resolvedPath = resolvedPath.replace(
      "{httpMethod}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: httpMethod.");
  }
  if (input.resourceId !== undefined) {
    const labelValue: string = input.resourceId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: resourceId.");
    }
    resolvedPath = resolvedPath.replace(
      "{resourceId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: resourceId.");
  }
  if (input.restApiId !== undefined) {
    const labelValue: string = input.restApiId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: restApiId.");
    }
    resolvedPath = resolvedPath.replace(
      "{restApiId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: restApiId.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.apiKeyRequired !== undefined && {
      apiKeyRequired: input.apiKeyRequired
    }),
    ...(input.authorizationScopes !== undefined && {
      authorizationScopes: serializeAws_restJson1ListOfString(
        input.authorizationScopes,
        context
      )
    }),
    ...(input.authorizationType !== undefined && {
      authorizationType: input.authorizationType
    }),
    ...(input.authorizerId !== undefined && {
      authorizerId: input.authorizerId
    }),
    ...(input.name !== undefined && { name: input.name }),
    ...(input.operationName !== undefined && {
      operationName: input.operationName
    }),
    ...(input.requestModels !== undefined && {
      requestModels: serializeAws_restJson1MapOfStringToString(
        input.requestModels,
        context
      )
    }),
    ...(input.requestParameters !== undefined && {
      requestParameters: serializeAws_restJson1MapOfStringToBoolean(
        input.requestParameters,
        context
      )
    }),
    ...(input.requestValidatorId !== undefined && {
      requestValidatorId: input.requestValidatorId
    }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "PUT",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1PutMethodResponseCommand = async (
  input: PutMethodResponseCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath =
    "/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}/responses/{statusCode}";
  if (input.httpMethod !== undefined) {
    const labelValue: string = input.httpMethod;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: httpMethod.");
    }
    resolvedPath = resolvedPath.replace(
      "{httpMethod}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: httpMethod.");
  }
  if (input.resourceId !== undefined) {
    const labelValue: string = input.resourceId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: resourceId.");
    }
    resolvedPath = resolvedPath.replace(
      "{resourceId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: resourceId.");
  }
  if (input.restApiId !== undefined) {
    const labelValue: string = input.restApiId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: restApiId.");
    }
    resolvedPath = resolvedPath.replace(
      "{restApiId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: restApiId.");
  }
  if (input.statusCode !== undefined) {
    const labelValue: string = input.statusCode;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: statusCode.");
    }
    resolvedPath = resolvedPath.replace(
      "{statusCode}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: statusCode.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.name !== undefined && { name: input.name }),
    ...(input.responseModels !== undefined && {
      responseModels: serializeAws_restJson1MapOfStringToString(
        input.responseModels,
        context
      )
    }),
    ...(input.responseParameters !== undefined && {
      responseParameters: serializeAws_restJson1MapOfStringToBoolean(
        input.responseParameters,
        context
      )
    }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "PUT",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1PutRestApiCommand = async (
  input: PutRestApiCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath = "/restapis/{restApiId}";
  if (input.restApiId !== undefined) {
    const labelValue: string = input.restApiId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: restApiId.");
    }
    resolvedPath = resolvedPath.replace(
      "{restApiId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: restApiId.");
  }
  const query: any = {
    ...(input.failOnWarnings !== undefined && {
      failonwarnings: input.failOnWarnings.toString()
    }),
    ...(input.mode !== undefined && { mode: input.mode })
  };
  let body: any;
  body = JSON.stringify({
    ...(input.name !== undefined && { name: input.name }),
    ...(input.parameters !== undefined && {
      parameters: serializeAws_restJson1MapOfStringToString(
        input.parameters,
        context
      )
    }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "PUT",
    headers,
    path: resolvedPath,
    query,
    body
  });
};

export const serializeAws_restJson1TagResourceCommand = async (
  input: TagResourceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath = "/tags/{resourceArn}";
  if (input.resourceArn !== undefined) {
    const labelValue: string = input.resourceArn;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: resourceArn."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{resourceArn}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: resourceArn.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.name !== undefined && { name: input.name }),
    ...(input.tags !== undefined && {
      tags: serializeAws_restJson1MapOfStringToString(input.tags, context)
    }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "PUT",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1TestInvokeAuthorizerCommand = async (
  input: TestInvokeAuthorizerCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath = "/restapis/{restApiId}/authorizers/{authorizerId}";
  if (input.authorizerId !== undefined) {
    const labelValue: string = input.authorizerId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: authorizerId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{authorizerId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: authorizerId.");
  }
  if (input.restApiId !== undefined) {
    const labelValue: string = input.restApiId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: restApiId.");
    }
    resolvedPath = resolvedPath.replace(
      "{restApiId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: restApiId.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.additionalContext !== undefined && {
      additionalContext: serializeAws_restJson1MapOfStringToString(
        input.additionalContext,
        context
      )
    }),
    ...(input.body !== undefined && { body: input.body }),
    ...(input.headers !== undefined && {
      headers: serializeAws_restJson1MapOfStringToString(input.headers, context)
    }),
    ...(input.multiValueHeaders !== undefined && {
      multiValueHeaders: serializeAws_restJson1MapOfStringToList(
        input.multiValueHeaders,
        context
      )
    }),
    ...(input.pathWithQueryString !== undefined && {
      pathWithQueryString: input.pathWithQueryString
    }),
    ...(input.stageVariables !== undefined && {
      stageVariables: serializeAws_restJson1MapOfStringToString(
        input.stageVariables,
        context
      )
    })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1TestInvokeMethodCommand = async (
  input: TestInvokeMethodCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath =
    "/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}";
  if (input.httpMethod !== undefined) {
    const labelValue: string = input.httpMethod;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: httpMethod.");
    }
    resolvedPath = resolvedPath.replace(
      "{httpMethod}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: httpMethod.");
  }
  if (input.resourceId !== undefined) {
    const labelValue: string = input.resourceId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: resourceId.");
    }
    resolvedPath = resolvedPath.replace(
      "{resourceId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: resourceId.");
  }
  if (input.restApiId !== undefined) {
    const labelValue: string = input.restApiId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: restApiId.");
    }
    resolvedPath = resolvedPath.replace(
      "{restApiId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: restApiId.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.body !== undefined && { body: input.body }),
    ...(input.clientCertificateId !== undefined && {
      clientCertificateId: input.clientCertificateId
    }),
    ...(input.headers !== undefined && {
      headers: serializeAws_restJson1MapOfStringToString(input.headers, context)
    }),
    ...(input.multiValueHeaders !== undefined && {
      multiValueHeaders: serializeAws_restJson1MapOfStringToList(
        input.multiValueHeaders,
        context
      )
    }),
    ...(input.pathWithQueryString !== undefined && {
      pathWithQueryString: input.pathWithQueryString
    }),
    ...(input.stageVariables !== undefined && {
      stageVariables: serializeAws_restJson1MapOfStringToString(
        input.stageVariables,
        context
      )
    })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1UntagResourceCommand = async (
  input: UntagResourceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath = "/tags/{resourceArn}";
  if (input.resourceArn !== undefined) {
    const labelValue: string = input.resourceArn;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: resourceArn."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{resourceArn}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: resourceArn.");
  }
  const query: any = {
    ...(input.tagKeys !== undefined && {
      tagKeys: (input.tagKeys || []).map(_entry => _entry)
    })
  };
  let body: any;
  body = JSON.stringify({
    ...(input.name !== undefined && { name: input.name }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    query,
    body
  });
};

export const serializeAws_restJson1UpdateAccountCommand = async (
  input: UpdateAccountCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath = "/account";
  let body: any;
  body = JSON.stringify({
    ...(input.name !== undefined && { name: input.name }),
    ...(input.patchOperations !== undefined && {
      patchOperations: serializeAws_restJson1ListOfPatchOperation(
        input.patchOperations,
        context
      )
    }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "PATCH",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1UpdateApiKeyCommand = async (
  input: UpdateApiKeyCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath = "/apikeys/{apiKey}";
  if (input.apiKey !== undefined) {
    const labelValue: string = input.apiKey;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: apiKey.");
    }
    resolvedPath = resolvedPath.replace(
      "{apiKey}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: apiKey.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.name !== undefined && { name: input.name }),
    ...(input.patchOperations !== undefined && {
      patchOperations: serializeAws_restJson1ListOfPatchOperation(
        input.patchOperations,
        context
      )
    }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "PATCH",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1UpdateAuthorizerCommand = async (
  input: UpdateAuthorizerCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath = "/restapis/{restApiId}/authorizers/{authorizerId}";
  if (input.authorizerId !== undefined) {
    const labelValue: string = input.authorizerId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: authorizerId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{authorizerId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: authorizerId.");
  }
  if (input.restApiId !== undefined) {
    const labelValue: string = input.restApiId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: restApiId.");
    }
    resolvedPath = resolvedPath.replace(
      "{restApiId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: restApiId.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.name !== undefined && { name: input.name }),
    ...(input.patchOperations !== undefined && {
      patchOperations: serializeAws_restJson1ListOfPatchOperation(
        input.patchOperations,
        context
      )
    }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "PATCH",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1UpdateBasePathMappingCommand = async (
  input: UpdateBasePathMappingCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath = "/domainnames/{domainName}/basepathmappings/{basePath}";
  if (input.basePath !== undefined) {
    const labelValue: string = input.basePath;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: basePath.");
    }
    resolvedPath = resolvedPath.replace(
      "{basePath}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: basePath.");
  }
  if (input.domainName !== undefined) {
    const labelValue: string = input.domainName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: domainName.");
    }
    resolvedPath = resolvedPath.replace(
      "{domainName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: domainName.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.name !== undefined && { name: input.name }),
    ...(input.patchOperations !== undefined && {
      patchOperations: serializeAws_restJson1ListOfPatchOperation(
        input.patchOperations,
        context
      )
    }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "PATCH",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1UpdateClientCertificateCommand = async (
  input: UpdateClientCertificateCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath = "/clientcertificates/{clientCertificateId}";
  if (input.clientCertificateId !== undefined) {
    const labelValue: string = input.clientCertificateId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: clientCertificateId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{clientCertificateId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: clientCertificateId."
    );
  }
  let body: any;
  body = JSON.stringify({
    ...(input.name !== undefined && { name: input.name }),
    ...(input.patchOperations !== undefined && {
      patchOperations: serializeAws_restJson1ListOfPatchOperation(
        input.patchOperations,
        context
      )
    }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "PATCH",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1UpdateDeploymentCommand = async (
  input: UpdateDeploymentCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath = "/restapis/{restApiId}/deployments/{deploymentId}";
  if (input.deploymentId !== undefined) {
    const labelValue: string = input.deploymentId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: deploymentId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{deploymentId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: deploymentId.");
  }
  if (input.restApiId !== undefined) {
    const labelValue: string = input.restApiId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: restApiId.");
    }
    resolvedPath = resolvedPath.replace(
      "{restApiId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: restApiId.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.name !== undefined && { name: input.name }),
    ...(input.patchOperations !== undefined && {
      patchOperations: serializeAws_restJson1ListOfPatchOperation(
        input.patchOperations,
        context
      )
    }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "PATCH",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1UpdateDocumentationPartCommand = async (
  input: UpdateDocumentationPartCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath =
    "/restapis/{restApiId}/documentation/parts/{documentationPartId}";
  if (input.documentationPartId !== undefined) {
    const labelValue: string = input.documentationPartId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: documentationPartId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{documentationPartId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: documentationPartId."
    );
  }
  if (input.restApiId !== undefined) {
    const labelValue: string = input.restApiId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: restApiId.");
    }
    resolvedPath = resolvedPath.replace(
      "{restApiId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: restApiId.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.name !== undefined && { name: input.name }),
    ...(input.patchOperations !== undefined && {
      patchOperations: serializeAws_restJson1ListOfPatchOperation(
        input.patchOperations,
        context
      )
    }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "PATCH",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1UpdateDocumentationVersionCommand = async (
  input: UpdateDocumentationVersionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath =
    "/restapis/{restApiId}/documentation/versions/{documentationVersion}";
  if (input.documentationVersion !== undefined) {
    const labelValue: string = input.documentationVersion;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: documentationVersion."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{documentationVersion}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: documentationVersion."
    );
  }
  if (input.restApiId !== undefined) {
    const labelValue: string = input.restApiId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: restApiId.");
    }
    resolvedPath = resolvedPath.replace(
      "{restApiId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: restApiId.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.name !== undefined && { name: input.name }),
    ...(input.patchOperations !== undefined && {
      patchOperations: serializeAws_restJson1ListOfPatchOperation(
        input.patchOperations,
        context
      )
    }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "PATCH",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1UpdateDomainNameCommand = async (
  input: UpdateDomainNameCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath = "/domainnames/{domainName}";
  if (input.domainName !== undefined) {
    const labelValue: string = input.domainName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: domainName.");
    }
    resolvedPath = resolvedPath.replace(
      "{domainName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: domainName.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.name !== undefined && { name: input.name }),
    ...(input.patchOperations !== undefined && {
      patchOperations: serializeAws_restJson1ListOfPatchOperation(
        input.patchOperations,
        context
      )
    }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "PATCH",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1UpdateGatewayResponseCommand = async (
  input: UpdateGatewayResponseCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath = "/restapis/{restApiId}/gatewayresponses/{responseType}";
  if (input.responseType !== undefined) {
    const labelValue: string = input.responseType;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: responseType."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{responseType}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: responseType.");
  }
  if (input.restApiId !== undefined) {
    const labelValue: string = input.restApiId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: restApiId.");
    }
    resolvedPath = resolvedPath.replace(
      "{restApiId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: restApiId.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.name !== undefined && { name: input.name }),
    ...(input.patchOperations !== undefined && {
      patchOperations: serializeAws_restJson1ListOfPatchOperation(
        input.patchOperations,
        context
      )
    }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "PATCH",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1UpdateIntegrationCommand = async (
  input: UpdateIntegrationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath =
    "/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}/integration";
  if (input.httpMethod !== undefined) {
    const labelValue: string = input.httpMethod;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: httpMethod.");
    }
    resolvedPath = resolvedPath.replace(
      "{httpMethod}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: httpMethod.");
  }
  if (input.resourceId !== undefined) {
    const labelValue: string = input.resourceId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: resourceId.");
    }
    resolvedPath = resolvedPath.replace(
      "{resourceId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: resourceId.");
  }
  if (input.restApiId !== undefined) {
    const labelValue: string = input.restApiId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: restApiId.");
    }
    resolvedPath = resolvedPath.replace(
      "{restApiId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: restApiId.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.name !== undefined && { name: input.name }),
    ...(input.patchOperations !== undefined && {
      patchOperations: serializeAws_restJson1ListOfPatchOperation(
        input.patchOperations,
        context
      )
    }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "PATCH",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1UpdateIntegrationResponseCommand = async (
  input: UpdateIntegrationResponseCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath =
    "/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}/integration/responses/{statusCode}";
  if (input.httpMethod !== undefined) {
    const labelValue: string = input.httpMethod;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: httpMethod.");
    }
    resolvedPath = resolvedPath.replace(
      "{httpMethod}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: httpMethod.");
  }
  if (input.resourceId !== undefined) {
    const labelValue: string = input.resourceId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: resourceId.");
    }
    resolvedPath = resolvedPath.replace(
      "{resourceId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: resourceId.");
  }
  if (input.restApiId !== undefined) {
    const labelValue: string = input.restApiId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: restApiId.");
    }
    resolvedPath = resolvedPath.replace(
      "{restApiId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: restApiId.");
  }
  if (input.statusCode !== undefined) {
    const labelValue: string = input.statusCode;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: statusCode.");
    }
    resolvedPath = resolvedPath.replace(
      "{statusCode}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: statusCode.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.name !== undefined && { name: input.name }),
    ...(input.patchOperations !== undefined && {
      patchOperations: serializeAws_restJson1ListOfPatchOperation(
        input.patchOperations,
        context
      )
    }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "PATCH",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1UpdateMethodCommand = async (
  input: UpdateMethodCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath =
    "/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}";
  if (input.httpMethod !== undefined) {
    const labelValue: string = input.httpMethod;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: httpMethod.");
    }
    resolvedPath = resolvedPath.replace(
      "{httpMethod}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: httpMethod.");
  }
  if (input.resourceId !== undefined) {
    const labelValue: string = input.resourceId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: resourceId.");
    }
    resolvedPath = resolvedPath.replace(
      "{resourceId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: resourceId.");
  }
  if (input.restApiId !== undefined) {
    const labelValue: string = input.restApiId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: restApiId.");
    }
    resolvedPath = resolvedPath.replace(
      "{restApiId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: restApiId.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.name !== undefined && { name: input.name }),
    ...(input.patchOperations !== undefined && {
      patchOperations: serializeAws_restJson1ListOfPatchOperation(
        input.patchOperations,
        context
      )
    }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "PATCH",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1UpdateMethodResponseCommand = async (
  input: UpdateMethodResponseCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath =
    "/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}/responses/{statusCode}";
  if (input.httpMethod !== undefined) {
    const labelValue: string = input.httpMethod;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: httpMethod.");
    }
    resolvedPath = resolvedPath.replace(
      "{httpMethod}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: httpMethod.");
  }
  if (input.resourceId !== undefined) {
    const labelValue: string = input.resourceId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: resourceId.");
    }
    resolvedPath = resolvedPath.replace(
      "{resourceId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: resourceId.");
  }
  if (input.restApiId !== undefined) {
    const labelValue: string = input.restApiId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: restApiId.");
    }
    resolvedPath = resolvedPath.replace(
      "{restApiId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: restApiId.");
  }
  if (input.statusCode !== undefined) {
    const labelValue: string = input.statusCode;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: statusCode.");
    }
    resolvedPath = resolvedPath.replace(
      "{statusCode}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: statusCode.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.name !== undefined && { name: input.name }),
    ...(input.patchOperations !== undefined && {
      patchOperations: serializeAws_restJson1ListOfPatchOperation(
        input.patchOperations,
        context
      )
    }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "PATCH",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1UpdateModelCommand = async (
  input: UpdateModelCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath = "/restapis/{restApiId}/models/{modelName}";
  if (input.modelName !== undefined) {
    const labelValue: string = input.modelName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: modelName.");
    }
    resolvedPath = resolvedPath.replace(
      "{modelName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: modelName.");
  }
  if (input.restApiId !== undefined) {
    const labelValue: string = input.restApiId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: restApiId.");
    }
    resolvedPath = resolvedPath.replace(
      "{restApiId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: restApiId.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.name !== undefined && { name: input.name }),
    ...(input.patchOperations !== undefined && {
      patchOperations: serializeAws_restJson1ListOfPatchOperation(
        input.patchOperations,
        context
      )
    }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "PATCH",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1UpdateRequestValidatorCommand = async (
  input: UpdateRequestValidatorCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath =
    "/restapis/{restApiId}/requestvalidators/{requestValidatorId}";
  if (input.requestValidatorId !== undefined) {
    const labelValue: string = input.requestValidatorId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: requestValidatorId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{requestValidatorId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: requestValidatorId."
    );
  }
  if (input.restApiId !== undefined) {
    const labelValue: string = input.restApiId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: restApiId.");
    }
    resolvedPath = resolvedPath.replace(
      "{restApiId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: restApiId.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.name !== undefined && { name: input.name }),
    ...(input.patchOperations !== undefined && {
      patchOperations: serializeAws_restJson1ListOfPatchOperation(
        input.patchOperations,
        context
      )
    }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "PATCH",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1UpdateResourceCommand = async (
  input: UpdateResourceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath = "/restapis/{restApiId}/resources/{resourceId}";
  if (input.resourceId !== undefined) {
    const labelValue: string = input.resourceId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: resourceId.");
    }
    resolvedPath = resolvedPath.replace(
      "{resourceId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: resourceId.");
  }
  if (input.restApiId !== undefined) {
    const labelValue: string = input.restApiId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: restApiId.");
    }
    resolvedPath = resolvedPath.replace(
      "{restApiId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: restApiId.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.name !== undefined && { name: input.name }),
    ...(input.patchOperations !== undefined && {
      patchOperations: serializeAws_restJson1ListOfPatchOperation(
        input.patchOperations,
        context
      )
    }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "PATCH",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1UpdateRestApiCommand = async (
  input: UpdateRestApiCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath = "/restapis/{restApiId}";
  if (input.restApiId !== undefined) {
    const labelValue: string = input.restApiId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: restApiId.");
    }
    resolvedPath = resolvedPath.replace(
      "{restApiId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: restApiId.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.name !== undefined && { name: input.name }),
    ...(input.patchOperations !== undefined && {
      patchOperations: serializeAws_restJson1ListOfPatchOperation(
        input.patchOperations,
        context
      )
    }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "PATCH",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1UpdateStageCommand = async (
  input: UpdateStageCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath = "/restapis/{restApiId}/stages/{stageName}";
  if (input.restApiId !== undefined) {
    const labelValue: string = input.restApiId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: restApiId.");
    }
    resolvedPath = resolvedPath.replace(
      "{restApiId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: restApiId.");
  }
  if (input.stageName !== undefined) {
    const labelValue: string = input.stageName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: stageName.");
    }
    resolvedPath = resolvedPath.replace(
      "{stageName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: stageName.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.name !== undefined && { name: input.name }),
    ...(input.patchOperations !== undefined && {
      patchOperations: serializeAws_restJson1ListOfPatchOperation(
        input.patchOperations,
        context
      )
    }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "PATCH",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1UpdateUsageCommand = async (
  input: UpdateUsageCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath = "/usageplans/{usagePlanId}/keys/{keyId}/usage";
  if (input.keyId !== undefined) {
    const labelValue: string = input.keyId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: keyId.");
    }
    resolvedPath = resolvedPath.replace(
      "{keyId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: keyId.");
  }
  if (input.usagePlanId !== undefined) {
    const labelValue: string = input.usagePlanId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: usagePlanId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{usagePlanId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: usagePlanId.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.name !== undefined && { name: input.name }),
    ...(input.patchOperations !== undefined && {
      patchOperations: serializeAws_restJson1ListOfPatchOperation(
        input.patchOperations,
        context
      )
    }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "PATCH",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1UpdateUsagePlanCommand = async (
  input: UpdateUsagePlanCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath = "/usageplans/{usagePlanId}";
  if (input.usagePlanId !== undefined) {
    const labelValue: string = input.usagePlanId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: usagePlanId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{usagePlanId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: usagePlanId.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.name !== undefined && { name: input.name }),
    ...(input.patchOperations !== undefined && {
      patchOperations: serializeAws_restJson1ListOfPatchOperation(
        input.patchOperations,
        context
      )
    }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "PATCH",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1UpdateVpcLinkCommand = async (
  input: UpdateVpcLinkCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/json"
  };
  let resolvedPath = "/vpclinks/{vpcLinkId}";
  if (input.vpcLinkId !== undefined) {
    const labelValue: string = input.vpcLinkId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: vpcLinkId.");
    }
    resolvedPath = resolvedPath.replace(
      "{vpcLinkId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: vpcLinkId.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.name !== undefined && { name: input.name }),
    ...(input.patchOperations !== undefined && {
      patchOperations: serializeAws_restJson1ListOfPatchOperation(
        input.patchOperations,
        context
      )
    }),
    ...(input.template !== undefined && { template: input.template }),
    ...(input.templateSkipList !== undefined && {
      templateSkipList: serializeAws_restJson1ListOfString(
        input.templateSkipList,
        context
      )
    }),
    ...(input.title !== undefined && { title: input.title })
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "PATCH",
    headers,
    path: resolvedPath,
    body
  });
};

export const deserializeAws_restJson1CreateApiKeyCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateApiKeyCommandOutput> => {
  if (output.statusCode !== 201 && output.statusCode >= 400) {
    return deserializeAws_restJson1CreateApiKeyCommandError(output, context);
  }
  const contents: CreateApiKeyCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ApiKey",
    createdDate: undefined,
    customerId: undefined,
    description: undefined,
    enabled: undefined,
    id: undefined,
    lastUpdatedDate: undefined,
    name: undefined,
    stageKeys: undefined,
    tags: undefined,
    value: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.createdDate !== undefined && data.createdDate !== null) {
    contents.createdDate = new Date(Math.round(data.createdDate * 1000));
  }
  if (data.customerId !== undefined && data.customerId !== null) {
    contents.customerId = data.customerId;
  }
  if (data.description !== undefined && data.description !== null) {
    contents.description = data.description;
  }
  if (data.enabled !== undefined && data.enabled !== null) {
    contents.enabled = data.enabled;
  }
  if (data.id !== undefined && data.id !== null) {
    contents.id = data.id;
  }
  if (data.lastUpdatedDate !== undefined && data.lastUpdatedDate !== null) {
    contents.lastUpdatedDate = new Date(
      Math.round(data.lastUpdatedDate * 1000)
    );
  }
  if (data.name !== undefined && data.name !== null) {
    contents.name = data.name;
  }
  if (data.stageKeys !== undefined && data.stageKeys !== null) {
    contents.stageKeys = deserializeAws_restJson1ListOfString(
      data.stageKeys,
      context
    );
  }
  if (data.tags !== undefined && data.tags !== null) {
    contents.tags = deserializeAws_restJson1MapOfStringToString(
      data.tags,
      context
    );
  }
  if (data.value !== undefined && data.value !== null) {
    contents.value = data.value;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1CreateApiKeyCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateApiKeyCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.apigateway#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ConflictException":
    case "com.amazonaws.apigateway#ConflictException":
      response = {
        ...(await deserializeAws_restJson1ConflictExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.apigateway#LimitExceededException":
      response = {
        ...(await deserializeAws_restJson1LimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1CreateAuthorizerCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateAuthorizerCommandOutput> => {
  if (output.statusCode !== 201 && output.statusCode >= 400) {
    return deserializeAws_restJson1CreateAuthorizerCommandError(
      output,
      context
    );
  }
  const contents: CreateAuthorizerCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "Authorizer",
    authType: undefined,
    authorizerCredentials: undefined,
    authorizerResultTtlInSeconds: undefined,
    authorizerUri: undefined,
    id: undefined,
    identitySource: undefined,
    identityValidationExpression: undefined,
    name: undefined,
    providerARNs: undefined,
    type: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.authType !== undefined && data.authType !== null) {
    contents.authType = data.authType;
  }
  if (
    data.authorizerCredentials !== undefined &&
    data.authorizerCredentials !== null
  ) {
    contents.authorizerCredentials = data.authorizerCredentials;
  }
  if (
    data.authorizerResultTtlInSeconds !== undefined &&
    data.authorizerResultTtlInSeconds !== null
  ) {
    contents.authorizerResultTtlInSeconds = data.authorizerResultTtlInSeconds;
  }
  if (data.authorizerUri !== undefined && data.authorizerUri !== null) {
    contents.authorizerUri = data.authorizerUri;
  }
  if (data.id !== undefined && data.id !== null) {
    contents.id = data.id;
  }
  if (data.identitySource !== undefined && data.identitySource !== null) {
    contents.identitySource = data.identitySource;
  }
  if (
    data.identityValidationExpression !== undefined &&
    data.identityValidationExpression !== null
  ) {
    contents.identityValidationExpression = data.identityValidationExpression;
  }
  if (data.name !== undefined && data.name !== null) {
    contents.name = data.name;
  }
  if (data.providerARNs !== undefined && data.providerARNs !== null) {
    contents.providerARNs = deserializeAws_restJson1ListOfARNs(
      data.providerARNs,
      context
    );
  }
  if (data.type !== undefined && data.type !== null) {
    contents.type = data.type;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1CreateAuthorizerCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateAuthorizerCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.apigateway#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.apigateway#LimitExceededException":
      response = {
        ...(await deserializeAws_restJson1LimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1CreateBasePathMappingCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateBasePathMappingCommandOutput> => {
  if (output.statusCode !== 201 && output.statusCode >= 400) {
    return deserializeAws_restJson1CreateBasePathMappingCommandError(
      output,
      context
    );
  }
  const contents: CreateBasePathMappingCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "BasePathMapping",
    basePath: undefined,
    restApiId: undefined,
    stage: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.basePath !== undefined && data.basePath !== null) {
    contents.basePath = data.basePath;
  }
  if (data.restApiId !== undefined && data.restApiId !== null) {
    contents.restApiId = data.restApiId;
  }
  if (data.stage !== undefined && data.stage !== null) {
    contents.stage = data.stage;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1CreateBasePathMappingCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateBasePathMappingCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.apigateway#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ConflictException":
    case "com.amazonaws.apigateway#ConflictException":
      response = {
        ...(await deserializeAws_restJson1ConflictExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1CreateDeploymentCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDeploymentCommandOutput> => {
  if (output.statusCode !== 201 && output.statusCode >= 400) {
    return deserializeAws_restJson1CreateDeploymentCommandError(
      output,
      context
    );
  }
  const contents: CreateDeploymentCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "Deployment",
    apiSummary: undefined,
    createdDate: undefined,
    description: undefined,
    id: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.apiSummary !== undefined && data.apiSummary !== null) {
    contents.apiSummary = deserializeAws_restJson1PathToMapOfMethodSnapshot(
      data.apiSummary,
      context
    );
  }
  if (data.createdDate !== undefined && data.createdDate !== null) {
    contents.createdDate = new Date(Math.round(data.createdDate * 1000));
  }
  if (data.description !== undefined && data.description !== null) {
    contents.description = data.description;
  }
  if (data.id !== undefined && data.id !== null) {
    contents.id = data.id;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1CreateDeploymentCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDeploymentCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.apigateway#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ConflictException":
    case "com.amazonaws.apigateway#ConflictException":
      response = {
        ...(await deserializeAws_restJson1ConflictExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.apigateway#LimitExceededException":
      response = {
        ...(await deserializeAws_restJson1LimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.apigateway#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1CreateDocumentationPartCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDocumentationPartCommandOutput> => {
  if (output.statusCode !== 201 && output.statusCode >= 400) {
    return deserializeAws_restJson1CreateDocumentationPartCommandError(
      output,
      context
    );
  }
  const contents: CreateDocumentationPartCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DocumentationPart",
    id: undefined,
    location: undefined,
    properties: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.id !== undefined && data.id !== null) {
    contents.id = data.id;
  }
  if (data.location !== undefined && data.location !== null) {
    contents.location = deserializeAws_restJson1DocumentationPartLocation(
      data.location,
      context
    );
  }
  if (data.properties !== undefined && data.properties !== null) {
    contents.properties = data.properties;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1CreateDocumentationPartCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDocumentationPartCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.apigateway#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ConflictException":
    case "com.amazonaws.apigateway#ConflictException":
      response = {
        ...(await deserializeAws_restJson1ConflictExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.apigateway#LimitExceededException":
      response = {
        ...(await deserializeAws_restJson1LimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1CreateDocumentationVersionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDocumentationVersionCommandOutput> => {
  if (output.statusCode !== 201 && output.statusCode >= 400) {
    return deserializeAws_restJson1CreateDocumentationVersionCommandError(
      output,
      context
    );
  }
  const contents: CreateDocumentationVersionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DocumentationVersion",
    createdDate: undefined,
    description: undefined,
    version: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.createdDate !== undefined && data.createdDate !== null) {
    contents.createdDate = new Date(Math.round(data.createdDate * 1000));
  }
  if (data.description !== undefined && data.description !== null) {
    contents.description = data.description;
  }
  if (data.version !== undefined && data.version !== null) {
    contents.version = data.version;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1CreateDocumentationVersionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDocumentationVersionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.apigateway#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ConflictException":
    case "com.amazonaws.apigateway#ConflictException":
      response = {
        ...(await deserializeAws_restJson1ConflictExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.apigateway#LimitExceededException":
      response = {
        ...(await deserializeAws_restJson1LimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1CreateDomainNameCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDomainNameCommandOutput> => {
  if (output.statusCode !== 201 && output.statusCode >= 400) {
    return deserializeAws_restJson1CreateDomainNameCommandError(
      output,
      context
    );
  }
  const contents: CreateDomainNameCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DomainName",
    certificateArn: undefined,
    certificateName: undefined,
    certificateUploadDate: undefined,
    distributionDomainName: undefined,
    distributionHostedZoneId: undefined,
    domainName: undefined,
    domainNameStatus: undefined,
    domainNameStatusMessage: undefined,
    endpointConfiguration: undefined,
    regionalCertificateArn: undefined,
    regionalCertificateName: undefined,
    regionalDomainName: undefined,
    regionalHostedZoneId: undefined,
    securityPolicy: undefined,
    tags: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.certificateArn !== undefined && data.certificateArn !== null) {
    contents.certificateArn = data.certificateArn;
  }
  if (data.certificateName !== undefined && data.certificateName !== null) {
    contents.certificateName = data.certificateName;
  }
  if (
    data.certificateUploadDate !== undefined &&
    data.certificateUploadDate !== null
  ) {
    contents.certificateUploadDate = new Date(
      Math.round(data.certificateUploadDate * 1000)
    );
  }
  if (
    data.distributionDomainName !== undefined &&
    data.distributionDomainName !== null
  ) {
    contents.distributionDomainName = data.distributionDomainName;
  }
  if (
    data.distributionHostedZoneId !== undefined &&
    data.distributionHostedZoneId !== null
  ) {
    contents.distributionHostedZoneId = data.distributionHostedZoneId;
  }
  if (data.domainName !== undefined && data.domainName !== null) {
    contents.domainName = data.domainName;
  }
  if (data.domainNameStatus !== undefined && data.domainNameStatus !== null) {
    contents.domainNameStatus = data.domainNameStatus;
  }
  if (
    data.domainNameStatusMessage !== undefined &&
    data.domainNameStatusMessage !== null
  ) {
    contents.domainNameStatusMessage = data.domainNameStatusMessage;
  }
  if (
    data.endpointConfiguration !== undefined &&
    data.endpointConfiguration !== null
  ) {
    contents.endpointConfiguration = deserializeAws_restJson1EndpointConfiguration(
      data.endpointConfiguration,
      context
    );
  }
  if (
    data.regionalCertificateArn !== undefined &&
    data.regionalCertificateArn !== null
  ) {
    contents.regionalCertificateArn = data.regionalCertificateArn;
  }
  if (
    data.regionalCertificateName !== undefined &&
    data.regionalCertificateName !== null
  ) {
    contents.regionalCertificateName = data.regionalCertificateName;
  }
  if (
    data.regionalDomainName !== undefined &&
    data.regionalDomainName !== null
  ) {
    contents.regionalDomainName = data.regionalDomainName;
  }
  if (
    data.regionalHostedZoneId !== undefined &&
    data.regionalHostedZoneId !== null
  ) {
    contents.regionalHostedZoneId = data.regionalHostedZoneId;
  }
  if (data.securityPolicy !== undefined && data.securityPolicy !== null) {
    contents.securityPolicy = data.securityPolicy;
  }
  if (data.tags !== undefined && data.tags !== null) {
    contents.tags = deserializeAws_restJson1MapOfStringToString(
      data.tags,
      context
    );
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1CreateDomainNameCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDomainNameCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.apigateway#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ConflictException":
    case "com.amazonaws.apigateway#ConflictException":
      response = {
        ...(await deserializeAws_restJson1ConflictExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1CreateModelCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateModelCommandOutput> => {
  if (output.statusCode !== 201 && output.statusCode >= 400) {
    return deserializeAws_restJson1CreateModelCommandError(output, context);
  }
  const contents: CreateModelCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "Model",
    contentType: undefined,
    description: undefined,
    id: undefined,
    name: undefined,
    schema: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.contentType !== undefined && data.contentType !== null) {
    contents.contentType = data.contentType;
  }
  if (data.description !== undefined && data.description !== null) {
    contents.description = data.description;
  }
  if (data.id !== undefined && data.id !== null) {
    contents.id = data.id;
  }
  if (data.name !== undefined && data.name !== null) {
    contents.name = data.name;
  }
  if (data.schema !== undefined && data.schema !== null) {
    contents.schema = data.schema;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1CreateModelCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateModelCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.apigateway#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ConflictException":
    case "com.amazonaws.apigateway#ConflictException":
      response = {
        ...(await deserializeAws_restJson1ConflictExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.apigateway#LimitExceededException":
      response = {
        ...(await deserializeAws_restJson1LimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1CreateRequestValidatorCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateRequestValidatorCommandOutput> => {
  if (output.statusCode !== 201 && output.statusCode >= 400) {
    return deserializeAws_restJson1CreateRequestValidatorCommandError(
      output,
      context
    );
  }
  const contents: CreateRequestValidatorCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "RequestValidator",
    id: undefined,
    name: undefined,
    validateRequestBody: undefined,
    validateRequestParameters: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.id !== undefined && data.id !== null) {
    contents.id = data.id;
  }
  if (data.name !== undefined && data.name !== null) {
    contents.name = data.name;
  }
  if (
    data.validateRequestBody !== undefined &&
    data.validateRequestBody !== null
  ) {
    contents.validateRequestBody = data.validateRequestBody;
  }
  if (
    data.validateRequestParameters !== undefined &&
    data.validateRequestParameters !== null
  ) {
    contents.validateRequestParameters = data.validateRequestParameters;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1CreateRequestValidatorCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateRequestValidatorCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.apigateway#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.apigateway#LimitExceededException":
      response = {
        ...(await deserializeAws_restJson1LimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1CreateResourceCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateResourceCommandOutput> => {
  if (output.statusCode !== 201 && output.statusCode >= 400) {
    return deserializeAws_restJson1CreateResourceCommandError(output, context);
  }
  const contents: CreateResourceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "Resource",
    id: undefined,
    parentId: undefined,
    path: undefined,
    pathPart: undefined,
    resourceMethods: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.id !== undefined && data.id !== null) {
    contents.id = data.id;
  }
  if (data.parentId !== undefined && data.parentId !== null) {
    contents.parentId = data.parentId;
  }
  if (data.path !== undefined && data.path !== null) {
    contents.path = data.path;
  }
  if (data.pathPart !== undefined && data.pathPart !== null) {
    contents.pathPart = data.pathPart;
  }
  if (data.resourceMethods !== undefined && data.resourceMethods !== null) {
    contents.resourceMethods = deserializeAws_restJson1MapOfMethod(
      data.resourceMethods,
      context
    );
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1CreateResourceCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateResourceCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.apigateway#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ConflictException":
    case "com.amazonaws.apigateway#ConflictException":
      response = {
        ...(await deserializeAws_restJson1ConflictExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.apigateway#LimitExceededException":
      response = {
        ...(await deserializeAws_restJson1LimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1CreateRestApiCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateRestApiCommandOutput> => {
  if (output.statusCode !== 201 && output.statusCode >= 400) {
    return deserializeAws_restJson1CreateRestApiCommandError(output, context);
  }
  const contents: CreateRestApiCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "RestApi",
    apiKeySource: undefined,
    binaryMediaTypes: undefined,
    createdDate: undefined,
    description: undefined,
    endpointConfiguration: undefined,
    id: undefined,
    minimumCompressionSize: undefined,
    name: undefined,
    policy: undefined,
    tags: undefined,
    version: undefined,
    warnings: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.apiKeySource !== undefined && data.apiKeySource !== null) {
    contents.apiKeySource = data.apiKeySource;
  }
  if (data.binaryMediaTypes !== undefined && data.binaryMediaTypes !== null) {
    contents.binaryMediaTypes = deserializeAws_restJson1ListOfString(
      data.binaryMediaTypes,
      context
    );
  }
  if (data.createdDate !== undefined && data.createdDate !== null) {
    contents.createdDate = new Date(Math.round(data.createdDate * 1000));
  }
  if (data.description !== undefined && data.description !== null) {
    contents.description = data.description;
  }
  if (
    data.endpointConfiguration !== undefined &&
    data.endpointConfiguration !== null
  ) {
    contents.endpointConfiguration = deserializeAws_restJson1EndpointConfiguration(
      data.endpointConfiguration,
      context
    );
  }
  if (data.id !== undefined && data.id !== null) {
    contents.id = data.id;
  }
  if (
    data.minimumCompressionSize !== undefined &&
    data.minimumCompressionSize !== null
  ) {
    contents.minimumCompressionSize = data.minimumCompressionSize;
  }
  if (data.name !== undefined && data.name !== null) {
    contents.name = data.name;
  }
  if (data.policy !== undefined && data.policy !== null) {
    contents.policy = data.policy;
  }
  if (data.tags !== undefined && data.tags !== null) {
    contents.tags = deserializeAws_restJson1MapOfStringToString(
      data.tags,
      context
    );
  }
  if (data.version !== undefined && data.version !== null) {
    contents.version = data.version;
  }
  if (data.warnings !== undefined && data.warnings !== null) {
    contents.warnings = deserializeAws_restJson1ListOfString(
      data.warnings,
      context
    );
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1CreateRestApiCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateRestApiCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.apigateway#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.apigateway#LimitExceededException":
      response = {
        ...(await deserializeAws_restJson1LimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1CreateStageCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateStageCommandOutput> => {
  if (output.statusCode !== 201 && output.statusCode >= 400) {
    return deserializeAws_restJson1CreateStageCommandError(output, context);
  }
  const contents: CreateStageCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "Stage",
    accessLogSettings: undefined,
    cacheClusterEnabled: undefined,
    cacheClusterSize: undefined,
    cacheClusterStatus: undefined,
    canarySettings: undefined,
    clientCertificateId: undefined,
    createdDate: undefined,
    deploymentId: undefined,
    description: undefined,
    documentationVersion: undefined,
    lastUpdatedDate: undefined,
    methodSettings: undefined,
    stageName: undefined,
    tags: undefined,
    tracingEnabled: undefined,
    variables: undefined,
    webAclArn: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.accessLogSettings !== undefined && data.accessLogSettings !== null) {
    contents.accessLogSettings = deserializeAws_restJson1AccessLogSettings(
      data.accessLogSettings,
      context
    );
  }
  if (
    data.cacheClusterEnabled !== undefined &&
    data.cacheClusterEnabled !== null
  ) {
    contents.cacheClusterEnabled = data.cacheClusterEnabled;
  }
  if (data.cacheClusterSize !== undefined && data.cacheClusterSize !== null) {
    contents.cacheClusterSize = data.cacheClusterSize;
  }
  if (
    data.cacheClusterStatus !== undefined &&
    data.cacheClusterStatus !== null
  ) {
    contents.cacheClusterStatus = data.cacheClusterStatus;
  }
  if (data.canarySettings !== undefined && data.canarySettings !== null) {
    contents.canarySettings = deserializeAws_restJson1CanarySettings(
      data.canarySettings,
      context
    );
  }
  if (
    data.clientCertificateId !== undefined &&
    data.clientCertificateId !== null
  ) {
    contents.clientCertificateId = data.clientCertificateId;
  }
  if (data.createdDate !== undefined && data.createdDate !== null) {
    contents.createdDate = new Date(Math.round(data.createdDate * 1000));
  }
  if (data.deploymentId !== undefined && data.deploymentId !== null) {
    contents.deploymentId = data.deploymentId;
  }
  if (data.description !== undefined && data.description !== null) {
    contents.description = data.description;
  }
  if (
    data.documentationVersion !== undefined &&
    data.documentationVersion !== null
  ) {
    contents.documentationVersion = data.documentationVersion;
  }
  if (data.lastUpdatedDate !== undefined && data.lastUpdatedDate !== null) {
    contents.lastUpdatedDate = new Date(
      Math.round(data.lastUpdatedDate * 1000)
    );
  }
  if (data.methodSettings !== undefined && data.methodSettings !== null) {
    contents.methodSettings = deserializeAws_restJson1MapOfMethodSettings(
      data.methodSettings,
      context
    );
  }
  if (data.stageName !== undefined && data.stageName !== null) {
    contents.stageName = data.stageName;
  }
  if (data.tags !== undefined && data.tags !== null) {
    contents.tags = deserializeAws_restJson1MapOfStringToString(
      data.tags,
      context
    );
  }
  if (data.tracingEnabled !== undefined && data.tracingEnabled !== null) {
    contents.tracingEnabled = data.tracingEnabled;
  }
  if (data.variables !== undefined && data.variables !== null) {
    contents.variables = deserializeAws_restJson1MapOfStringToString(
      data.variables,
      context
    );
  }
  if (data.webAclArn !== undefined && data.webAclArn !== null) {
    contents.webAclArn = data.webAclArn;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1CreateStageCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateStageCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.apigateway#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ConflictException":
    case "com.amazonaws.apigateway#ConflictException":
      response = {
        ...(await deserializeAws_restJson1ConflictExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.apigateway#LimitExceededException":
      response = {
        ...(await deserializeAws_restJson1LimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1CreateUsagePlanCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateUsagePlanCommandOutput> => {
  if (output.statusCode !== 201 && output.statusCode >= 400) {
    return deserializeAws_restJson1CreateUsagePlanCommandError(output, context);
  }
  const contents: CreateUsagePlanCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UsagePlan",
    apiStages: undefined,
    description: undefined,
    id: undefined,
    name: undefined,
    productCode: undefined,
    quota: undefined,
    tags: undefined,
    throttle: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.apiStages !== undefined && data.apiStages !== null) {
    contents.apiStages = deserializeAws_restJson1ListOfApiStage(
      data.apiStages,
      context
    );
  }
  if (data.description !== undefined && data.description !== null) {
    contents.description = data.description;
  }
  if (data.id !== undefined && data.id !== null) {
    contents.id = data.id;
  }
  if (data.name !== undefined && data.name !== null) {
    contents.name = data.name;
  }
  if (data.productCode !== undefined && data.productCode !== null) {
    contents.productCode = data.productCode;
  }
  if (data.quota !== undefined && data.quota !== null) {
    contents.quota = deserializeAws_restJson1QuotaSettings(data.quota, context);
  }
  if (data.tags !== undefined && data.tags !== null) {
    contents.tags = deserializeAws_restJson1MapOfStringToString(
      data.tags,
      context
    );
  }
  if (data.throttle !== undefined && data.throttle !== null) {
    contents.throttle = deserializeAws_restJson1ThrottleSettings(
      data.throttle,
      context
    );
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1CreateUsagePlanCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateUsagePlanCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.apigateway#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ConflictException":
    case "com.amazonaws.apigateway#ConflictException":
      response = {
        ...(await deserializeAws_restJson1ConflictExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.apigateway#LimitExceededException":
      response = {
        ...(await deserializeAws_restJson1LimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1CreateUsagePlanKeyCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateUsagePlanKeyCommandOutput> => {
  if (output.statusCode !== 201 && output.statusCode >= 400) {
    return deserializeAws_restJson1CreateUsagePlanKeyCommandError(
      output,
      context
    );
  }
  const contents: CreateUsagePlanKeyCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UsagePlanKey",
    id: undefined,
    name: undefined,
    type: undefined,
    value: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.id !== undefined && data.id !== null) {
    contents.id = data.id;
  }
  if (data.name !== undefined && data.name !== null) {
    contents.name = data.name;
  }
  if (data.type !== undefined && data.type !== null) {
    contents.type = data.type;
  }
  if (data.value !== undefined && data.value !== null) {
    contents.value = data.value;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1CreateUsagePlanKeyCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateUsagePlanKeyCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.apigateway#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ConflictException":
    case "com.amazonaws.apigateway#ConflictException":
      response = {
        ...(await deserializeAws_restJson1ConflictExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1CreateVpcLinkCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateVpcLinkCommandOutput> => {
  if (output.statusCode !== 202 && output.statusCode >= 400) {
    return deserializeAws_restJson1CreateVpcLinkCommandError(output, context);
  }
  const contents: CreateVpcLinkCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "VpcLink",
    description: undefined,
    id: undefined,
    name: undefined,
    status: undefined,
    statusMessage: undefined,
    tags: undefined,
    targetArns: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.description !== undefined && data.description !== null) {
    contents.description = data.description;
  }
  if (data.id !== undefined && data.id !== null) {
    contents.id = data.id;
  }
  if (data.name !== undefined && data.name !== null) {
    contents.name = data.name;
  }
  if (data.status !== undefined && data.status !== null) {
    contents.status = data.status;
  }
  if (data.statusMessage !== undefined && data.statusMessage !== null) {
    contents.statusMessage = data.statusMessage;
  }
  if (data.tags !== undefined && data.tags !== null) {
    contents.tags = deserializeAws_restJson1MapOfStringToString(
      data.tags,
      context
    );
  }
  if (data.targetArns !== undefined && data.targetArns !== null) {
    contents.targetArns = deserializeAws_restJson1ListOfString(
      data.targetArns,
      context
    );
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1CreateVpcLinkCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateVpcLinkCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.apigateway#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1DeleteApiKeyCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteApiKeyCommandOutput> => {
  if (output.statusCode !== 202 && output.statusCode >= 400) {
    return deserializeAws_restJson1DeleteApiKeyCommandError(output, context);
  }
  const contents: DeleteApiKeyCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restJson1DeleteApiKeyCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteApiKeyCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1DeleteAuthorizerCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteAuthorizerCommandOutput> => {
  if (output.statusCode !== 202 && output.statusCode >= 400) {
    return deserializeAws_restJson1DeleteAuthorizerCommandError(
      output,
      context
    );
  }
  const contents: DeleteAuthorizerCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restJson1DeleteAuthorizerCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteAuthorizerCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.apigateway#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ConflictException":
    case "com.amazonaws.apigateway#ConflictException":
      response = {
        ...(await deserializeAws_restJson1ConflictExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1DeleteBasePathMappingCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteBasePathMappingCommandOutput> => {
  if (output.statusCode !== 202 && output.statusCode >= 400) {
    return deserializeAws_restJson1DeleteBasePathMappingCommandError(
      output,
      context
    );
  }
  const contents: DeleteBasePathMappingCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restJson1DeleteBasePathMappingCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteBasePathMappingCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.apigateway#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ConflictException":
    case "com.amazonaws.apigateway#ConflictException":
      response = {
        ...(await deserializeAws_restJson1ConflictExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1DeleteClientCertificateCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteClientCertificateCommandOutput> => {
  if (output.statusCode !== 202 && output.statusCode >= 400) {
    return deserializeAws_restJson1DeleteClientCertificateCommandError(
      output,
      context
    );
  }
  const contents: DeleteClientCertificateCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restJson1DeleteClientCertificateCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteClientCertificateCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.apigateway#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1DeleteDeploymentCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteDeploymentCommandOutput> => {
  if (output.statusCode !== 202 && output.statusCode >= 400) {
    return deserializeAws_restJson1DeleteDeploymentCommandError(
      output,
      context
    );
  }
  const contents: DeleteDeploymentCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restJson1DeleteDeploymentCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteDeploymentCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.apigateway#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1DeleteDocumentationPartCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteDocumentationPartCommandOutput> => {
  if (output.statusCode !== 202 && output.statusCode >= 400) {
    return deserializeAws_restJson1DeleteDocumentationPartCommandError(
      output,
      context
    );
  }
  const contents: DeleteDocumentationPartCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restJson1DeleteDocumentationPartCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteDocumentationPartCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.apigateway#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ConflictException":
    case "com.amazonaws.apigateway#ConflictException":
      response = {
        ...(await deserializeAws_restJson1ConflictExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1DeleteDocumentationVersionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteDocumentationVersionCommandOutput> => {
  if (output.statusCode !== 202 && output.statusCode >= 400) {
    return deserializeAws_restJson1DeleteDocumentationVersionCommandError(
      output,
      context
    );
  }
  const contents: DeleteDocumentationVersionCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restJson1DeleteDocumentationVersionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteDocumentationVersionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.apigateway#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ConflictException":
    case "com.amazonaws.apigateway#ConflictException":
      response = {
        ...(await deserializeAws_restJson1ConflictExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1DeleteDomainNameCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteDomainNameCommandOutput> => {
  if (output.statusCode !== 202 && output.statusCode >= 400) {
    return deserializeAws_restJson1DeleteDomainNameCommandError(
      output,
      context
    );
  }
  const contents: DeleteDomainNameCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restJson1DeleteDomainNameCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteDomainNameCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.apigateway#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1DeleteGatewayResponseCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteGatewayResponseCommandOutput> => {
  if (output.statusCode !== 202 && output.statusCode >= 400) {
    return deserializeAws_restJson1DeleteGatewayResponseCommandError(
      output,
      context
    );
  }
  const contents: DeleteGatewayResponseCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restJson1DeleteGatewayResponseCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteGatewayResponseCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.apigateway#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ConflictException":
    case "com.amazonaws.apigateway#ConflictException":
      response = {
        ...(await deserializeAws_restJson1ConflictExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1DeleteIntegrationCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteIntegrationCommandOutput> => {
  if (output.statusCode !== 204 && output.statusCode >= 400) {
    return deserializeAws_restJson1DeleteIntegrationCommandError(
      output,
      context
    );
  }
  const contents: DeleteIntegrationCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restJson1DeleteIntegrationCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteIntegrationCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ConflictException":
    case "com.amazonaws.apigateway#ConflictException":
      response = {
        ...(await deserializeAws_restJson1ConflictExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1DeleteIntegrationResponseCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteIntegrationResponseCommandOutput> => {
  if (output.statusCode !== 204 && output.statusCode >= 400) {
    return deserializeAws_restJson1DeleteIntegrationResponseCommandError(
      output,
      context
    );
  }
  const contents: DeleteIntegrationResponseCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restJson1DeleteIntegrationResponseCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteIntegrationResponseCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.apigateway#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ConflictException":
    case "com.amazonaws.apigateway#ConflictException":
      response = {
        ...(await deserializeAws_restJson1ConflictExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1DeleteMethodCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteMethodCommandOutput> => {
  if (output.statusCode !== 204 && output.statusCode >= 400) {
    return deserializeAws_restJson1DeleteMethodCommandError(output, context);
  }
  const contents: DeleteMethodCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restJson1DeleteMethodCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteMethodCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ConflictException":
    case "com.amazonaws.apigateway#ConflictException":
      response = {
        ...(await deserializeAws_restJson1ConflictExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1DeleteMethodResponseCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteMethodResponseCommandOutput> => {
  if (output.statusCode !== 204 && output.statusCode >= 400) {
    return deserializeAws_restJson1DeleteMethodResponseCommandError(
      output,
      context
    );
  }
  const contents: DeleteMethodResponseCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restJson1DeleteMethodResponseCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteMethodResponseCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.apigateway#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ConflictException":
    case "com.amazonaws.apigateway#ConflictException":
      response = {
        ...(await deserializeAws_restJson1ConflictExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1DeleteModelCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteModelCommandOutput> => {
  if (output.statusCode !== 202 && output.statusCode >= 400) {
    return deserializeAws_restJson1DeleteModelCommandError(output, context);
  }
  const contents: DeleteModelCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restJson1DeleteModelCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteModelCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.apigateway#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ConflictException":
    case "com.amazonaws.apigateway#ConflictException":
      response = {
        ...(await deserializeAws_restJson1ConflictExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1DeleteRequestValidatorCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteRequestValidatorCommandOutput> => {
  if (output.statusCode !== 202 && output.statusCode >= 400) {
    return deserializeAws_restJson1DeleteRequestValidatorCommandError(
      output,
      context
    );
  }
  const contents: DeleteRequestValidatorCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restJson1DeleteRequestValidatorCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteRequestValidatorCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.apigateway#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ConflictException":
    case "com.amazonaws.apigateway#ConflictException":
      response = {
        ...(await deserializeAws_restJson1ConflictExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1DeleteResourceCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteResourceCommandOutput> => {
  if (output.statusCode !== 202 && output.statusCode >= 400) {
    return deserializeAws_restJson1DeleteResourceCommandError(output, context);
  }
  const contents: DeleteResourceCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restJson1DeleteResourceCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteResourceCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.apigateway#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ConflictException":
    case "com.amazonaws.apigateway#ConflictException":
      response = {
        ...(await deserializeAws_restJson1ConflictExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1DeleteRestApiCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteRestApiCommandOutput> => {
  if (output.statusCode !== 202 && output.statusCode >= 400) {
    return deserializeAws_restJson1DeleteRestApiCommandError(output, context);
  }
  const contents: DeleteRestApiCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restJson1DeleteRestApiCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteRestApiCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.apigateway#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1DeleteStageCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteStageCommandOutput> => {
  if (output.statusCode !== 202 && output.statusCode >= 400) {
    return deserializeAws_restJson1DeleteStageCommandError(output, context);
  }
  const contents: DeleteStageCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restJson1DeleteStageCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteStageCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.apigateway#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1DeleteUsagePlanCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteUsagePlanCommandOutput> => {
  if (output.statusCode !== 202 && output.statusCode >= 400) {
    return deserializeAws_restJson1DeleteUsagePlanCommandError(output, context);
  }
  const contents: DeleteUsagePlanCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restJson1DeleteUsagePlanCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteUsagePlanCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.apigateway#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1DeleteUsagePlanKeyCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteUsagePlanKeyCommandOutput> => {
  if (output.statusCode !== 202 && output.statusCode >= 400) {
    return deserializeAws_restJson1DeleteUsagePlanKeyCommandError(
      output,
      context
    );
  }
  const contents: DeleteUsagePlanKeyCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restJson1DeleteUsagePlanKeyCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteUsagePlanKeyCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.apigateway#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ConflictException":
    case "com.amazonaws.apigateway#ConflictException":
      response = {
        ...(await deserializeAws_restJson1ConflictExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1DeleteVpcLinkCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteVpcLinkCommandOutput> => {
  if (output.statusCode !== 202 && output.statusCode >= 400) {
    return deserializeAws_restJson1DeleteVpcLinkCommandError(output, context);
  }
  const contents: DeleteVpcLinkCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restJson1DeleteVpcLinkCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteVpcLinkCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.apigateway#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1FlushStageAuthorizersCacheCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<FlushStageAuthorizersCacheCommandOutput> => {
  if (output.statusCode !== 202 && output.statusCode >= 400) {
    return deserializeAws_restJson1FlushStageAuthorizersCacheCommandError(
      output,
      context
    );
  }
  const contents: FlushStageAuthorizersCacheCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restJson1FlushStageAuthorizersCacheCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<FlushStageAuthorizersCacheCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.apigateway#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1FlushStageCacheCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<FlushStageCacheCommandOutput> => {
  if (output.statusCode !== 202 && output.statusCode >= 400) {
    return deserializeAws_restJson1FlushStageCacheCommandError(output, context);
  }
  const contents: FlushStageCacheCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restJson1FlushStageCacheCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<FlushStageCacheCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.apigateway#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1GenerateClientCertificateCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GenerateClientCertificateCommandOutput> => {
  if (output.statusCode !== 201 && output.statusCode >= 400) {
    return deserializeAws_restJson1GenerateClientCertificateCommandError(
      output,
      context
    );
  }
  const contents: GenerateClientCertificateCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ClientCertificate",
    clientCertificateId: undefined,
    createdDate: undefined,
    description: undefined,
    expirationDate: undefined,
    pemEncodedCertificate: undefined,
    tags: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (
    data.clientCertificateId !== undefined &&
    data.clientCertificateId !== null
  ) {
    contents.clientCertificateId = data.clientCertificateId;
  }
  if (data.createdDate !== undefined && data.createdDate !== null) {
    contents.createdDate = new Date(Math.round(data.createdDate * 1000));
  }
  if (data.description !== undefined && data.description !== null) {
    contents.description = data.description;
  }
  if (data.expirationDate !== undefined && data.expirationDate !== null) {
    contents.expirationDate = new Date(Math.round(data.expirationDate * 1000));
  }
  if (
    data.pemEncodedCertificate !== undefined &&
    data.pemEncodedCertificate !== null
  ) {
    contents.pemEncodedCertificate = data.pemEncodedCertificate;
  }
  if (data.tags !== undefined && data.tags !== null) {
    contents.tags = deserializeAws_restJson1MapOfStringToString(
      data.tags,
      context
    );
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1GenerateClientCertificateCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GenerateClientCertificateCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "LimitExceededException":
    case "com.amazonaws.apigateway#LimitExceededException":
      response = {
        ...(await deserializeAws_restJson1LimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1GetAccountCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetAccountCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1GetAccountCommandError(output, context);
  }
  const contents: GetAccountCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "Account",
    apiKeyVersion: undefined,
    cloudwatchRoleArn: undefined,
    features: undefined,
    throttleSettings: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.apiKeyVersion !== undefined && data.apiKeyVersion !== null) {
    contents.apiKeyVersion = data.apiKeyVersion;
  }
  if (data.cloudwatchRoleArn !== undefined && data.cloudwatchRoleArn !== null) {
    contents.cloudwatchRoleArn = data.cloudwatchRoleArn;
  }
  if (data.features !== undefined && data.features !== null) {
    contents.features = deserializeAws_restJson1ListOfString(
      data.features,
      context
    );
  }
  if (data.throttleSettings !== undefined && data.throttleSettings !== null) {
    contents.throttleSettings = deserializeAws_restJson1ThrottleSettings(
      data.throttleSettings,
      context
    );
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1GetAccountCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetAccountCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1GetApiKeyCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetApiKeyCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1GetApiKeyCommandError(output, context);
  }
  const contents: GetApiKeyCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ApiKey",
    createdDate: undefined,
    customerId: undefined,
    description: undefined,
    enabled: undefined,
    id: undefined,
    lastUpdatedDate: undefined,
    name: undefined,
    stageKeys: undefined,
    tags: undefined,
    value: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.createdDate !== undefined && data.createdDate !== null) {
    contents.createdDate = new Date(Math.round(data.createdDate * 1000));
  }
  if (data.customerId !== undefined && data.customerId !== null) {
    contents.customerId = data.customerId;
  }
  if (data.description !== undefined && data.description !== null) {
    contents.description = data.description;
  }
  if (data.enabled !== undefined && data.enabled !== null) {
    contents.enabled = data.enabled;
  }
  if (data.id !== undefined && data.id !== null) {
    contents.id = data.id;
  }
  if (data.lastUpdatedDate !== undefined && data.lastUpdatedDate !== null) {
    contents.lastUpdatedDate = new Date(
      Math.round(data.lastUpdatedDate * 1000)
    );
  }
  if (data.name !== undefined && data.name !== null) {
    contents.name = data.name;
  }
  if (data.stageKeys !== undefined && data.stageKeys !== null) {
    contents.stageKeys = deserializeAws_restJson1ListOfString(
      data.stageKeys,
      context
    );
  }
  if (data.tags !== undefined && data.tags !== null) {
    contents.tags = deserializeAws_restJson1MapOfStringToString(
      data.tags,
      context
    );
  }
  if (data.value !== undefined && data.value !== null) {
    contents.value = data.value;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1GetApiKeyCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetApiKeyCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1GetApiKeysCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetApiKeysCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1GetApiKeysCommandError(output, context);
  }
  const contents: GetApiKeysCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ApiKeys",
    items: undefined,
    position: undefined,
    warnings: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.item !== undefined && data.item !== null) {
    contents.items = deserializeAws_restJson1ListOfApiKey(data.item, context);
  }
  if (data.position !== undefined && data.position !== null) {
    contents.position = data.position;
  }
  if (data.warnings !== undefined && data.warnings !== null) {
    contents.warnings = deserializeAws_restJson1ListOfString(
      data.warnings,
      context
    );
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1GetApiKeysCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetApiKeysCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.apigateway#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1GetAuthorizerCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetAuthorizerCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1GetAuthorizerCommandError(output, context);
  }
  const contents: GetAuthorizerCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "Authorizer",
    authType: undefined,
    authorizerCredentials: undefined,
    authorizerResultTtlInSeconds: undefined,
    authorizerUri: undefined,
    id: undefined,
    identitySource: undefined,
    identityValidationExpression: undefined,
    name: undefined,
    providerARNs: undefined,
    type: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.authType !== undefined && data.authType !== null) {
    contents.authType = data.authType;
  }
  if (
    data.authorizerCredentials !== undefined &&
    data.authorizerCredentials !== null
  ) {
    contents.authorizerCredentials = data.authorizerCredentials;
  }
  if (
    data.authorizerResultTtlInSeconds !== undefined &&
    data.authorizerResultTtlInSeconds !== null
  ) {
    contents.authorizerResultTtlInSeconds = data.authorizerResultTtlInSeconds;
  }
  if (data.authorizerUri !== undefined && data.authorizerUri !== null) {
    contents.authorizerUri = data.authorizerUri;
  }
  if (data.id !== undefined && data.id !== null) {
    contents.id = data.id;
  }
  if (data.identitySource !== undefined && data.identitySource !== null) {
    contents.identitySource = data.identitySource;
  }
  if (
    data.identityValidationExpression !== undefined &&
    data.identityValidationExpression !== null
  ) {
    contents.identityValidationExpression = data.identityValidationExpression;
  }
  if (data.name !== undefined && data.name !== null) {
    contents.name = data.name;
  }
  if (data.providerARNs !== undefined && data.providerARNs !== null) {
    contents.providerARNs = deserializeAws_restJson1ListOfARNs(
      data.providerARNs,
      context
    );
  }
  if (data.type !== undefined && data.type !== null) {
    contents.type = data.type;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1GetAuthorizerCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetAuthorizerCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1GetAuthorizersCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetAuthorizersCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1GetAuthorizersCommandError(output, context);
  }
  const contents: GetAuthorizersCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "Authorizers",
    items: undefined,
    position: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.item !== undefined && data.item !== null) {
    contents.items = deserializeAws_restJson1ListOfAuthorizer(
      data.item,
      context
    );
  }
  if (data.position !== undefined && data.position !== null) {
    contents.position = data.position;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1GetAuthorizersCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetAuthorizersCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.apigateway#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1GetBasePathMappingCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetBasePathMappingCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1GetBasePathMappingCommandError(
      output,
      context
    );
  }
  const contents: GetBasePathMappingCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "BasePathMapping",
    basePath: undefined,
    restApiId: undefined,
    stage: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.basePath !== undefined && data.basePath !== null) {
    contents.basePath = data.basePath;
  }
  if (data.restApiId !== undefined && data.restApiId !== null) {
    contents.restApiId = data.restApiId;
  }
  if (data.stage !== undefined && data.stage !== null) {
    contents.stage = data.stage;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1GetBasePathMappingCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetBasePathMappingCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1GetBasePathMappingsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetBasePathMappingsCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1GetBasePathMappingsCommandError(
      output,
      context
    );
  }
  const contents: GetBasePathMappingsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "BasePathMappings",
    items: undefined,
    position: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.item !== undefined && data.item !== null) {
    contents.items = deserializeAws_restJson1ListOfBasePathMapping(
      data.item,
      context
    );
  }
  if (data.position !== undefined && data.position !== null) {
    contents.position = data.position;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1GetBasePathMappingsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetBasePathMappingsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1GetClientCertificateCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetClientCertificateCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1GetClientCertificateCommandError(
      output,
      context
    );
  }
  const contents: GetClientCertificateCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ClientCertificate",
    clientCertificateId: undefined,
    createdDate: undefined,
    description: undefined,
    expirationDate: undefined,
    pemEncodedCertificate: undefined,
    tags: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (
    data.clientCertificateId !== undefined &&
    data.clientCertificateId !== null
  ) {
    contents.clientCertificateId = data.clientCertificateId;
  }
  if (data.createdDate !== undefined && data.createdDate !== null) {
    contents.createdDate = new Date(Math.round(data.createdDate * 1000));
  }
  if (data.description !== undefined && data.description !== null) {
    contents.description = data.description;
  }
  if (data.expirationDate !== undefined && data.expirationDate !== null) {
    contents.expirationDate = new Date(Math.round(data.expirationDate * 1000));
  }
  if (
    data.pemEncodedCertificate !== undefined &&
    data.pemEncodedCertificate !== null
  ) {
    contents.pemEncodedCertificate = data.pemEncodedCertificate;
  }
  if (data.tags !== undefined && data.tags !== null) {
    contents.tags = deserializeAws_restJson1MapOfStringToString(
      data.tags,
      context
    );
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1GetClientCertificateCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetClientCertificateCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1GetClientCertificatesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetClientCertificatesCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1GetClientCertificatesCommandError(
      output,
      context
    );
  }
  const contents: GetClientCertificatesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ClientCertificates",
    items: undefined,
    position: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.item !== undefined && data.item !== null) {
    contents.items = deserializeAws_restJson1ListOfClientCertificate(
      data.item,
      context
    );
  }
  if (data.position !== undefined && data.position !== null) {
    contents.position = data.position;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1GetClientCertificatesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetClientCertificatesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.apigateway#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1GetDeploymentCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetDeploymentCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1GetDeploymentCommandError(output, context);
  }
  const contents: GetDeploymentCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "Deployment",
    apiSummary: undefined,
    createdDate: undefined,
    description: undefined,
    id: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.apiSummary !== undefined && data.apiSummary !== null) {
    contents.apiSummary = deserializeAws_restJson1PathToMapOfMethodSnapshot(
      data.apiSummary,
      context
    );
  }
  if (data.createdDate !== undefined && data.createdDate !== null) {
    contents.createdDate = new Date(Math.round(data.createdDate * 1000));
  }
  if (data.description !== undefined && data.description !== null) {
    contents.description = data.description;
  }
  if (data.id !== undefined && data.id !== null) {
    contents.id = data.id;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1GetDeploymentCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetDeploymentCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.apigateway#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1GetDeploymentsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetDeploymentsCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1GetDeploymentsCommandError(output, context);
  }
  const contents: GetDeploymentsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "Deployments",
    items: undefined,
    position: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.item !== undefined && data.item !== null) {
    contents.items = deserializeAws_restJson1ListOfDeployment(
      data.item,
      context
    );
  }
  if (data.position !== undefined && data.position !== null) {
    contents.position = data.position;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1GetDeploymentsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetDeploymentsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.apigateway#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.apigateway#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1GetDocumentationPartCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetDocumentationPartCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1GetDocumentationPartCommandError(
      output,
      context
    );
  }
  const contents: GetDocumentationPartCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DocumentationPart",
    id: undefined,
    location: undefined,
    properties: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.id !== undefined && data.id !== null) {
    contents.id = data.id;
  }
  if (data.location !== undefined && data.location !== null) {
    contents.location = deserializeAws_restJson1DocumentationPartLocation(
      data.location,
      context
    );
  }
  if (data.properties !== undefined && data.properties !== null) {
    contents.properties = data.properties;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1GetDocumentationPartCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetDocumentationPartCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1GetDocumentationPartsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetDocumentationPartsCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1GetDocumentationPartsCommandError(
      output,
      context
    );
  }
  const contents: GetDocumentationPartsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DocumentationParts",
    items: undefined,
    position: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.item !== undefined && data.item !== null) {
    contents.items = deserializeAws_restJson1ListOfDocumentationPart(
      data.item,
      context
    );
  }
  if (data.position !== undefined && data.position !== null) {
    contents.position = data.position;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1GetDocumentationPartsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetDocumentationPartsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.apigateway#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1GetDocumentationVersionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetDocumentationVersionCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1GetDocumentationVersionCommandError(
      output,
      context
    );
  }
  const contents: GetDocumentationVersionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DocumentationVersion",
    createdDate: undefined,
    description: undefined,
    version: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.createdDate !== undefined && data.createdDate !== null) {
    contents.createdDate = new Date(Math.round(data.createdDate * 1000));
  }
  if (data.description !== undefined && data.description !== null) {
    contents.description = data.description;
  }
  if (data.version !== undefined && data.version !== null) {
    contents.version = data.version;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1GetDocumentationVersionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetDocumentationVersionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1GetDocumentationVersionsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetDocumentationVersionsCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1GetDocumentationVersionsCommandError(
      output,
      context
    );
  }
  const contents: GetDocumentationVersionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DocumentationVersions",
    items: undefined,
    position: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.item !== undefined && data.item !== null) {
    contents.items = deserializeAws_restJson1ListOfDocumentationVersion(
      data.item,
      context
    );
  }
  if (data.position !== undefined && data.position !== null) {
    contents.position = data.position;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1GetDocumentationVersionsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetDocumentationVersionsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.apigateway#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1GetDomainNameCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetDomainNameCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1GetDomainNameCommandError(output, context);
  }
  const contents: GetDomainNameCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DomainName",
    certificateArn: undefined,
    certificateName: undefined,
    certificateUploadDate: undefined,
    distributionDomainName: undefined,
    distributionHostedZoneId: undefined,
    domainName: undefined,
    domainNameStatus: undefined,
    domainNameStatusMessage: undefined,
    endpointConfiguration: undefined,
    regionalCertificateArn: undefined,
    regionalCertificateName: undefined,
    regionalDomainName: undefined,
    regionalHostedZoneId: undefined,
    securityPolicy: undefined,
    tags: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.certificateArn !== undefined && data.certificateArn !== null) {
    contents.certificateArn = data.certificateArn;
  }
  if (data.certificateName !== undefined && data.certificateName !== null) {
    contents.certificateName = data.certificateName;
  }
  if (
    data.certificateUploadDate !== undefined &&
    data.certificateUploadDate !== null
  ) {
    contents.certificateUploadDate = new Date(
      Math.round(data.certificateUploadDate * 1000)
    );
  }
  if (
    data.distributionDomainName !== undefined &&
    data.distributionDomainName !== null
  ) {
    contents.distributionDomainName = data.distributionDomainName;
  }
  if (
    data.distributionHostedZoneId !== undefined &&
    data.distributionHostedZoneId !== null
  ) {
    contents.distributionHostedZoneId = data.distributionHostedZoneId;
  }
  if (data.domainName !== undefined && data.domainName !== null) {
    contents.domainName = data.domainName;
  }
  if (data.domainNameStatus !== undefined && data.domainNameStatus !== null) {
    contents.domainNameStatus = data.domainNameStatus;
  }
  if (
    data.domainNameStatusMessage !== undefined &&
    data.domainNameStatusMessage !== null
  ) {
    contents.domainNameStatusMessage = data.domainNameStatusMessage;
  }
  if (
    data.endpointConfiguration !== undefined &&
    data.endpointConfiguration !== null
  ) {
    contents.endpointConfiguration = deserializeAws_restJson1EndpointConfiguration(
      data.endpointConfiguration,
      context
    );
  }
  if (
    data.regionalCertificateArn !== undefined &&
    data.regionalCertificateArn !== null
  ) {
    contents.regionalCertificateArn = data.regionalCertificateArn;
  }
  if (
    data.regionalCertificateName !== undefined &&
    data.regionalCertificateName !== null
  ) {
    contents.regionalCertificateName = data.regionalCertificateName;
  }
  if (
    data.regionalDomainName !== undefined &&
    data.regionalDomainName !== null
  ) {
    contents.regionalDomainName = data.regionalDomainName;
  }
  if (
    data.regionalHostedZoneId !== undefined &&
    data.regionalHostedZoneId !== null
  ) {
    contents.regionalHostedZoneId = data.regionalHostedZoneId;
  }
  if (data.securityPolicy !== undefined && data.securityPolicy !== null) {
    contents.securityPolicy = data.securityPolicy;
  }
  if (data.tags !== undefined && data.tags !== null) {
    contents.tags = deserializeAws_restJson1MapOfStringToString(
      data.tags,
      context
    );
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1GetDomainNameCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetDomainNameCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.apigateway#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1GetDomainNamesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetDomainNamesCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1GetDomainNamesCommandError(output, context);
  }
  const contents: GetDomainNamesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DomainNames",
    items: undefined,
    position: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.item !== undefined && data.item !== null) {
    contents.items = deserializeAws_restJson1ListOfDomainName(
      data.item,
      context
    );
  }
  if (data.position !== undefined && data.position !== null) {
    contents.position = data.position;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1GetDomainNamesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetDomainNamesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.apigateway#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1GetExportCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetExportCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1GetExportCommandError(output, context);
  }
  const contents: GetExportCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ExportResponse",
    body: undefined,
    contentDisposition: undefined,
    contentType: undefined
  };
  if (output.headers["content-disposition"] !== undefined) {
    contents.contentDisposition = output.headers["content-disposition"];
  }
  if (output.headers["content-type"] !== undefined) {
    contents.contentType = output.headers["content-type"];
  }
  const data: any = await collectBody(output.body, context);
  contents.body = data;
  return Promise.resolve(contents);
};

const deserializeAws_restJson1GetExportCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetExportCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.apigateway#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ConflictException":
    case "com.amazonaws.apigateway#ConflictException":
      response = {
        ...(await deserializeAws_restJson1ConflictExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1GetGatewayResponseCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetGatewayResponseCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1GetGatewayResponseCommandError(
      output,
      context
    );
  }
  const contents: GetGatewayResponseCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GatewayResponse",
    defaultResponse: undefined,
    responseParameters: undefined,
    responseTemplates: undefined,
    responseType: undefined,
    statusCode: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.defaultResponse !== undefined && data.defaultResponse !== null) {
    contents.defaultResponse = data.defaultResponse;
  }
  if (
    data.responseParameters !== undefined &&
    data.responseParameters !== null
  ) {
    contents.responseParameters = deserializeAws_restJson1MapOfStringToString(
      data.responseParameters,
      context
    );
  }
  if (data.responseTemplates !== undefined && data.responseTemplates !== null) {
    contents.responseTemplates = deserializeAws_restJson1MapOfStringToString(
      data.responseTemplates,
      context
    );
  }
  if (data.responseType !== undefined && data.responseType !== null) {
    contents.responseType = data.responseType;
  }
  if (data.statusCode !== undefined && data.statusCode !== null) {
    contents.statusCode = data.statusCode;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1GetGatewayResponseCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetGatewayResponseCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1GetGatewayResponsesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetGatewayResponsesCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1GetGatewayResponsesCommandError(
      output,
      context
    );
  }
  const contents: GetGatewayResponsesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GatewayResponses",
    items: undefined,
    position: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.item !== undefined && data.item !== null) {
    contents.items = deserializeAws_restJson1ListOfGatewayResponse(
      data.item,
      context
    );
  }
  if (data.position !== undefined && data.position !== null) {
    contents.position = data.position;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1GetGatewayResponsesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetGatewayResponsesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.apigateway#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1GetIntegrationCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetIntegrationCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1GetIntegrationCommandError(output, context);
  }
  const contents: GetIntegrationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "Integration",
    cacheKeyParameters: undefined,
    cacheNamespace: undefined,
    connectionId: undefined,
    connectionType: undefined,
    contentHandling: undefined,
    credentials: undefined,
    httpMethod: undefined,
    integrationResponses: undefined,
    passthroughBehavior: undefined,
    requestParameters: undefined,
    requestTemplates: undefined,
    timeoutInMillis: undefined,
    type: undefined,
    uri: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (
    data.cacheKeyParameters !== undefined &&
    data.cacheKeyParameters !== null
  ) {
    contents.cacheKeyParameters = deserializeAws_restJson1ListOfString(
      data.cacheKeyParameters,
      context
    );
  }
  if (data.cacheNamespace !== undefined && data.cacheNamespace !== null) {
    contents.cacheNamespace = data.cacheNamespace;
  }
  if (data.connectionId !== undefined && data.connectionId !== null) {
    contents.connectionId = data.connectionId;
  }
  if (data.connectionType !== undefined && data.connectionType !== null) {
    contents.connectionType = data.connectionType;
  }
  if (data.contentHandling !== undefined && data.contentHandling !== null) {
    contents.contentHandling = data.contentHandling;
  }
  if (data.credentials !== undefined && data.credentials !== null) {
    contents.credentials = data.credentials;
  }
  if (data.httpMethod !== undefined && data.httpMethod !== null) {
    contents.httpMethod = data.httpMethod;
  }
  if (
    data.integrationResponses !== undefined &&
    data.integrationResponses !== null
  ) {
    contents.integrationResponses = deserializeAws_restJson1MapOfIntegrationResponse(
      data.integrationResponses,
      context
    );
  }
  if (
    data.passthroughBehavior !== undefined &&
    data.passthroughBehavior !== null
  ) {
    contents.passthroughBehavior = data.passthroughBehavior;
  }
  if (data.requestParameters !== undefined && data.requestParameters !== null) {
    contents.requestParameters = deserializeAws_restJson1MapOfStringToString(
      data.requestParameters,
      context
    );
  }
  if (data.requestTemplates !== undefined && data.requestTemplates !== null) {
    contents.requestTemplates = deserializeAws_restJson1MapOfStringToString(
      data.requestTemplates,
      context
    );
  }
  if (data.timeoutInMillis !== undefined && data.timeoutInMillis !== null) {
    contents.timeoutInMillis = data.timeoutInMillis;
  }
  if (data.type !== undefined && data.type !== null) {
    contents.type = data.type;
  }
  if (data.uri !== undefined && data.uri !== null) {
    contents.uri = data.uri;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1GetIntegrationCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetIntegrationCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1GetIntegrationResponseCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetIntegrationResponseCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1GetIntegrationResponseCommandError(
      output,
      context
    );
  }
  const contents: GetIntegrationResponseCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "IntegrationResponse",
    contentHandling: undefined,
    responseParameters: undefined,
    responseTemplates: undefined,
    selectionPattern: undefined,
    statusCode: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.contentHandling !== undefined && data.contentHandling !== null) {
    contents.contentHandling = data.contentHandling;
  }
  if (
    data.responseParameters !== undefined &&
    data.responseParameters !== null
  ) {
    contents.responseParameters = deserializeAws_restJson1MapOfStringToString(
      data.responseParameters,
      context
    );
  }
  if (data.responseTemplates !== undefined && data.responseTemplates !== null) {
    contents.responseTemplates = deserializeAws_restJson1MapOfStringToString(
      data.responseTemplates,
      context
    );
  }
  if (data.selectionPattern !== undefined && data.selectionPattern !== null) {
    contents.selectionPattern = data.selectionPattern;
  }
  if (data.statusCode !== undefined && data.statusCode !== null) {
    contents.statusCode = data.statusCode;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1GetIntegrationResponseCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetIntegrationResponseCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1GetMethodCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetMethodCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1GetMethodCommandError(output, context);
  }
  const contents: GetMethodCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "Method",
    apiKeyRequired: undefined,
    authorizationScopes: undefined,
    authorizationType: undefined,
    authorizerId: undefined,
    httpMethod: undefined,
    methodIntegration: undefined,
    methodResponses: undefined,
    operationName: undefined,
    requestModels: undefined,
    requestParameters: undefined,
    requestValidatorId: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.apiKeyRequired !== undefined && data.apiKeyRequired !== null) {
    contents.apiKeyRequired = data.apiKeyRequired;
  }
  if (
    data.authorizationScopes !== undefined &&
    data.authorizationScopes !== null
  ) {
    contents.authorizationScopes = deserializeAws_restJson1ListOfString(
      data.authorizationScopes,
      context
    );
  }
  if (data.authorizationType !== undefined && data.authorizationType !== null) {
    contents.authorizationType = data.authorizationType;
  }
  if (data.authorizerId !== undefined && data.authorizerId !== null) {
    contents.authorizerId = data.authorizerId;
  }
  if (data.httpMethod !== undefined && data.httpMethod !== null) {
    contents.httpMethod = data.httpMethod;
  }
  if (data.methodIntegration !== undefined && data.methodIntegration !== null) {
    contents.methodIntegration = deserializeAws_restJson1Integration(
      data.methodIntegration,
      context
    );
  }
  if (data.methodResponses !== undefined && data.methodResponses !== null) {
    contents.methodResponses = deserializeAws_restJson1MapOfMethodResponse(
      data.methodResponses,
      context
    );
  }
  if (data.operationName !== undefined && data.operationName !== null) {
    contents.operationName = data.operationName;
  }
  if (data.requestModels !== undefined && data.requestModels !== null) {
    contents.requestModels = deserializeAws_restJson1MapOfStringToString(
      data.requestModels,
      context
    );
  }
  if (data.requestParameters !== undefined && data.requestParameters !== null) {
    contents.requestParameters = deserializeAws_restJson1MapOfStringToBoolean(
      data.requestParameters,
      context
    );
  }
  if (
    data.requestValidatorId !== undefined &&
    data.requestValidatorId !== null
  ) {
    contents.requestValidatorId = data.requestValidatorId;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1GetMethodCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetMethodCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1GetMethodResponseCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetMethodResponseCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1GetMethodResponseCommandError(
      output,
      context
    );
  }
  const contents: GetMethodResponseCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "MethodResponse",
    responseModels: undefined,
    responseParameters: undefined,
    statusCode: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.responseModels !== undefined && data.responseModels !== null) {
    contents.responseModels = deserializeAws_restJson1MapOfStringToString(
      data.responseModels,
      context
    );
  }
  if (
    data.responseParameters !== undefined &&
    data.responseParameters !== null
  ) {
    contents.responseParameters = deserializeAws_restJson1MapOfStringToBoolean(
      data.responseParameters,
      context
    );
  }
  if (data.statusCode !== undefined && data.statusCode !== null) {
    contents.statusCode = data.statusCode;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1GetMethodResponseCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetMethodResponseCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1GetModelCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetModelCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1GetModelCommandError(output, context);
  }
  const contents: GetModelCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "Model",
    contentType: undefined,
    description: undefined,
    id: undefined,
    name: undefined,
    schema: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.contentType !== undefined && data.contentType !== null) {
    contents.contentType = data.contentType;
  }
  if (data.description !== undefined && data.description !== null) {
    contents.description = data.description;
  }
  if (data.id !== undefined && data.id !== null) {
    contents.id = data.id;
  }
  if (data.name !== undefined && data.name !== null) {
    contents.name = data.name;
  }
  if (data.schema !== undefined && data.schema !== null) {
    contents.schema = data.schema;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1GetModelCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetModelCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1GetModelsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetModelsCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1GetModelsCommandError(output, context);
  }
  const contents: GetModelsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "Models",
    items: undefined,
    position: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.item !== undefined && data.item !== null) {
    contents.items = deserializeAws_restJson1ListOfModel(data.item, context);
  }
  if (data.position !== undefined && data.position !== null) {
    contents.position = data.position;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1GetModelsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetModelsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.apigateway#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1GetModelTemplateCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetModelTemplateCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1GetModelTemplateCommandError(
      output,
      context
    );
  }
  const contents: GetModelTemplateCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "Template",
    value: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.value !== undefined && data.value !== null) {
    contents.value = data.value;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1GetModelTemplateCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetModelTemplateCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.apigateway#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1GetRequestValidatorCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetRequestValidatorCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1GetRequestValidatorCommandError(
      output,
      context
    );
  }
  const contents: GetRequestValidatorCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "RequestValidator",
    id: undefined,
    name: undefined,
    validateRequestBody: undefined,
    validateRequestParameters: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.id !== undefined && data.id !== null) {
    contents.id = data.id;
  }
  if (data.name !== undefined && data.name !== null) {
    contents.name = data.name;
  }
  if (
    data.validateRequestBody !== undefined &&
    data.validateRequestBody !== null
  ) {
    contents.validateRequestBody = data.validateRequestBody;
  }
  if (
    data.validateRequestParameters !== undefined &&
    data.validateRequestParameters !== null
  ) {
    contents.validateRequestParameters = data.validateRequestParameters;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1GetRequestValidatorCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetRequestValidatorCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1GetRequestValidatorsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetRequestValidatorsCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1GetRequestValidatorsCommandError(
      output,
      context
    );
  }
  const contents: GetRequestValidatorsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "RequestValidators",
    items: undefined,
    position: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.item !== undefined && data.item !== null) {
    contents.items = deserializeAws_restJson1ListOfRequestValidator(
      data.item,
      context
    );
  }
  if (data.position !== undefined && data.position !== null) {
    contents.position = data.position;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1GetRequestValidatorsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetRequestValidatorsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.apigateway#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1GetResourceCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetResourceCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1GetResourceCommandError(output, context);
  }
  const contents: GetResourceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "Resource",
    id: undefined,
    parentId: undefined,
    path: undefined,
    pathPart: undefined,
    resourceMethods: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.id !== undefined && data.id !== null) {
    contents.id = data.id;
  }
  if (data.parentId !== undefined && data.parentId !== null) {
    contents.parentId = data.parentId;
  }
  if (data.path !== undefined && data.path !== null) {
    contents.path = data.path;
  }
  if (data.pathPart !== undefined && data.pathPart !== null) {
    contents.pathPart = data.pathPart;
  }
  if (data.resourceMethods !== undefined && data.resourceMethods !== null) {
    contents.resourceMethods = deserializeAws_restJson1MapOfMethod(
      data.resourceMethods,
      context
    );
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1GetResourceCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetResourceCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1GetResourcesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetResourcesCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1GetResourcesCommandError(output, context);
  }
  const contents: GetResourcesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "Resources",
    items: undefined,
    position: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.item !== undefined && data.item !== null) {
    contents.items = deserializeAws_restJson1ListOfResource(data.item, context);
  }
  if (data.position !== undefined && data.position !== null) {
    contents.position = data.position;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1GetResourcesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetResourcesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.apigateway#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1GetRestApiCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetRestApiCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1GetRestApiCommandError(output, context);
  }
  const contents: GetRestApiCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "RestApi",
    apiKeySource: undefined,
    binaryMediaTypes: undefined,
    createdDate: undefined,
    description: undefined,
    endpointConfiguration: undefined,
    id: undefined,
    minimumCompressionSize: undefined,
    name: undefined,
    policy: undefined,
    tags: undefined,
    version: undefined,
    warnings: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.apiKeySource !== undefined && data.apiKeySource !== null) {
    contents.apiKeySource = data.apiKeySource;
  }
  if (data.binaryMediaTypes !== undefined && data.binaryMediaTypes !== null) {
    contents.binaryMediaTypes = deserializeAws_restJson1ListOfString(
      data.binaryMediaTypes,
      context
    );
  }
  if (data.createdDate !== undefined && data.createdDate !== null) {
    contents.createdDate = new Date(Math.round(data.createdDate * 1000));
  }
  if (data.description !== undefined && data.description !== null) {
    contents.description = data.description;
  }
  if (
    data.endpointConfiguration !== undefined &&
    data.endpointConfiguration !== null
  ) {
    contents.endpointConfiguration = deserializeAws_restJson1EndpointConfiguration(
      data.endpointConfiguration,
      context
    );
  }
  if (data.id !== undefined && data.id !== null) {
    contents.id = data.id;
  }
  if (
    data.minimumCompressionSize !== undefined &&
    data.minimumCompressionSize !== null
  ) {
    contents.minimumCompressionSize = data.minimumCompressionSize;
  }
  if (data.name !== undefined && data.name !== null) {
    contents.name = data.name;
  }
  if (data.policy !== undefined && data.policy !== null) {
    contents.policy = data.policy;
  }
  if (data.tags !== undefined && data.tags !== null) {
    contents.tags = deserializeAws_restJson1MapOfStringToString(
      data.tags,
      context
    );
  }
  if (data.version !== undefined && data.version !== null) {
    contents.version = data.version;
  }
  if (data.warnings !== undefined && data.warnings !== null) {
    contents.warnings = deserializeAws_restJson1ListOfString(
      data.warnings,
      context
    );
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1GetRestApiCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetRestApiCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1GetRestApisCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetRestApisCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1GetRestApisCommandError(output, context);
  }
  const contents: GetRestApisCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "RestApis",
    items: undefined,
    position: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.item !== undefined && data.item !== null) {
    contents.items = deserializeAws_restJson1ListOfRestApi(data.item, context);
  }
  if (data.position !== undefined && data.position !== null) {
    contents.position = data.position;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1GetRestApisCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetRestApisCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.apigateway#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1GetSdkCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetSdkCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1GetSdkCommandError(output, context);
  }
  const contents: GetSdkCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "SdkResponse",
    body: undefined,
    contentDisposition: undefined,
    contentType: undefined
  };
  if (output.headers["content-disposition"] !== undefined) {
    contents.contentDisposition = output.headers["content-disposition"];
  }
  if (output.headers["content-type"] !== undefined) {
    contents.contentType = output.headers["content-type"];
  }
  const data: any = await collectBody(output.body, context);
  contents.body = data;
  return Promise.resolve(contents);
};

const deserializeAws_restJson1GetSdkCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetSdkCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.apigateway#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ConflictException":
    case "com.amazonaws.apigateway#ConflictException":
      response = {
        ...(await deserializeAws_restJson1ConflictExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1GetSdkTypeCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetSdkTypeCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1GetSdkTypeCommandError(output, context);
  }
  const contents: GetSdkTypeCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "SdkType",
    configurationProperties: undefined,
    description: undefined,
    friendlyName: undefined,
    id: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (
    data.configurationProperties !== undefined &&
    data.configurationProperties !== null
  ) {
    contents.configurationProperties = deserializeAws_restJson1ListOfSdkConfigurationProperty(
      data.configurationProperties,
      context
    );
  }
  if (data.description !== undefined && data.description !== null) {
    contents.description = data.description;
  }
  if (data.friendlyName !== undefined && data.friendlyName !== null) {
    contents.friendlyName = data.friendlyName;
  }
  if (data.id !== undefined && data.id !== null) {
    contents.id = data.id;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1GetSdkTypeCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetSdkTypeCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1GetSdkTypesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetSdkTypesCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1GetSdkTypesCommandError(output, context);
  }
  const contents: GetSdkTypesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "SdkTypes",
    items: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.item !== undefined && data.item !== null) {
    contents.items = deserializeAws_restJson1ListOfSdkType(data.item, context);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1GetSdkTypesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetSdkTypesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1GetStageCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetStageCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1GetStageCommandError(output, context);
  }
  const contents: GetStageCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "Stage",
    accessLogSettings: undefined,
    cacheClusterEnabled: undefined,
    cacheClusterSize: undefined,
    cacheClusterStatus: undefined,
    canarySettings: undefined,
    clientCertificateId: undefined,
    createdDate: undefined,
    deploymentId: undefined,
    description: undefined,
    documentationVersion: undefined,
    lastUpdatedDate: undefined,
    methodSettings: undefined,
    stageName: undefined,
    tags: undefined,
    tracingEnabled: undefined,
    variables: undefined,
    webAclArn: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.accessLogSettings !== undefined && data.accessLogSettings !== null) {
    contents.accessLogSettings = deserializeAws_restJson1AccessLogSettings(
      data.accessLogSettings,
      context
    );
  }
  if (
    data.cacheClusterEnabled !== undefined &&
    data.cacheClusterEnabled !== null
  ) {
    contents.cacheClusterEnabled = data.cacheClusterEnabled;
  }
  if (data.cacheClusterSize !== undefined && data.cacheClusterSize !== null) {
    contents.cacheClusterSize = data.cacheClusterSize;
  }
  if (
    data.cacheClusterStatus !== undefined &&
    data.cacheClusterStatus !== null
  ) {
    contents.cacheClusterStatus = data.cacheClusterStatus;
  }
  if (data.canarySettings !== undefined && data.canarySettings !== null) {
    contents.canarySettings = deserializeAws_restJson1CanarySettings(
      data.canarySettings,
      context
    );
  }
  if (
    data.clientCertificateId !== undefined &&
    data.clientCertificateId !== null
  ) {
    contents.clientCertificateId = data.clientCertificateId;
  }
  if (data.createdDate !== undefined && data.createdDate !== null) {
    contents.createdDate = new Date(Math.round(data.createdDate * 1000));
  }
  if (data.deploymentId !== undefined && data.deploymentId !== null) {
    contents.deploymentId = data.deploymentId;
  }
  if (data.description !== undefined && data.description !== null) {
    contents.description = data.description;
  }
  if (
    data.documentationVersion !== undefined &&
    data.documentationVersion !== null
  ) {
    contents.documentationVersion = data.documentationVersion;
  }
  if (data.lastUpdatedDate !== undefined && data.lastUpdatedDate !== null) {
    contents.lastUpdatedDate = new Date(
      Math.round(data.lastUpdatedDate * 1000)
    );
  }
  if (data.methodSettings !== undefined && data.methodSettings !== null) {
    contents.methodSettings = deserializeAws_restJson1MapOfMethodSettings(
      data.methodSettings,
      context
    );
  }
  if (data.stageName !== undefined && data.stageName !== null) {
    contents.stageName = data.stageName;
  }
  if (data.tags !== undefined && data.tags !== null) {
    contents.tags = deserializeAws_restJson1MapOfStringToString(
      data.tags,
      context
    );
  }
  if (data.tracingEnabled !== undefined && data.tracingEnabled !== null) {
    contents.tracingEnabled = data.tracingEnabled;
  }
  if (data.variables !== undefined && data.variables !== null) {
    contents.variables = deserializeAws_restJson1MapOfStringToString(
      data.variables,
      context
    );
  }
  if (data.webAclArn !== undefined && data.webAclArn !== null) {
    contents.webAclArn = data.webAclArn;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1GetStageCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetStageCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1GetStagesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetStagesCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1GetStagesCommandError(output, context);
  }
  const contents: GetStagesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "Stages",
    item: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.item !== undefined && data.item !== null) {
    contents.item = deserializeAws_restJson1ListOfStage(data.item, context);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1GetStagesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetStagesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1GetTagsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetTagsCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1GetTagsCommandError(output, context);
  }
  const contents: GetTagsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "Tags",
    tags: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.tags !== undefined && data.tags !== null) {
    contents.tags = deserializeAws_restJson1MapOfStringToString(
      data.tags,
      context
    );
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1GetTagsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetTagsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.apigateway#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.apigateway#LimitExceededException":
      response = {
        ...(await deserializeAws_restJson1LimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1GetUsageCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetUsageCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1GetUsageCommandError(output, context);
  }
  const contents: GetUsageCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "Usage",
    endDate: undefined,
    items: undefined,
    position: undefined,
    startDate: undefined,
    usagePlanId: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.endDate !== undefined && data.endDate !== null) {
    contents.endDate = data.endDate;
  }
  if (data.values !== undefined && data.values !== null) {
    contents.items = deserializeAws_restJson1MapOfKeyUsages(
      data.values,
      context
    );
  }
  if (data.position !== undefined && data.position !== null) {
    contents.position = data.position;
  }
  if (data.startDate !== undefined && data.startDate !== null) {
    contents.startDate = data.startDate;
  }
  if (data.usagePlanId !== undefined && data.usagePlanId !== null) {
    contents.usagePlanId = data.usagePlanId;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1GetUsageCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetUsageCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.apigateway#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1GetUsagePlanCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetUsagePlanCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1GetUsagePlanCommandError(output, context);
  }
  const contents: GetUsagePlanCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UsagePlan",
    apiStages: undefined,
    description: undefined,
    id: undefined,
    name: undefined,
    productCode: undefined,
    quota: undefined,
    tags: undefined,
    throttle: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.apiStages !== undefined && data.apiStages !== null) {
    contents.apiStages = deserializeAws_restJson1ListOfApiStage(
      data.apiStages,
      context
    );
  }
  if (data.description !== undefined && data.description !== null) {
    contents.description = data.description;
  }
  if (data.id !== undefined && data.id !== null) {
    contents.id = data.id;
  }
  if (data.name !== undefined && data.name !== null) {
    contents.name = data.name;
  }
  if (data.productCode !== undefined && data.productCode !== null) {
    contents.productCode = data.productCode;
  }
  if (data.quota !== undefined && data.quota !== null) {
    contents.quota = deserializeAws_restJson1QuotaSettings(data.quota, context);
  }
  if (data.tags !== undefined && data.tags !== null) {
    contents.tags = deserializeAws_restJson1MapOfStringToString(
      data.tags,
      context
    );
  }
  if (data.throttle !== undefined && data.throttle !== null) {
    contents.throttle = deserializeAws_restJson1ThrottleSettings(
      data.throttle,
      context
    );
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1GetUsagePlanCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetUsagePlanCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.apigateway#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1GetUsagePlanKeyCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetUsagePlanKeyCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1GetUsagePlanKeyCommandError(output, context);
  }
  const contents: GetUsagePlanKeyCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UsagePlanKey",
    id: undefined,
    name: undefined,
    type: undefined,
    value: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.id !== undefined && data.id !== null) {
    contents.id = data.id;
  }
  if (data.name !== undefined && data.name !== null) {
    contents.name = data.name;
  }
  if (data.type !== undefined && data.type !== null) {
    contents.type = data.type;
  }
  if (data.value !== undefined && data.value !== null) {
    contents.value = data.value;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1GetUsagePlanKeyCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetUsagePlanKeyCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.apigateway#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1GetUsagePlanKeysCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetUsagePlanKeysCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1GetUsagePlanKeysCommandError(
      output,
      context
    );
  }
  const contents: GetUsagePlanKeysCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UsagePlanKeys",
    items: undefined,
    position: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.item !== undefined && data.item !== null) {
    contents.items = deserializeAws_restJson1ListOfUsagePlanKey(
      data.item,
      context
    );
  }
  if (data.position !== undefined && data.position !== null) {
    contents.position = data.position;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1GetUsagePlanKeysCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetUsagePlanKeysCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.apigateway#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1GetUsagePlansCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetUsagePlansCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1GetUsagePlansCommandError(output, context);
  }
  const contents: GetUsagePlansCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UsagePlans",
    items: undefined,
    position: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.item !== undefined && data.item !== null) {
    contents.items = deserializeAws_restJson1ListOfUsagePlan(
      data.item,
      context
    );
  }
  if (data.position !== undefined && data.position !== null) {
    contents.position = data.position;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1GetUsagePlansCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetUsagePlansCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.apigateway#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ConflictException":
    case "com.amazonaws.apigateway#ConflictException":
      response = {
        ...(await deserializeAws_restJson1ConflictExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1GetVpcLinkCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetVpcLinkCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1GetVpcLinkCommandError(output, context);
  }
  const contents: GetVpcLinkCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "VpcLink",
    description: undefined,
    id: undefined,
    name: undefined,
    status: undefined,
    statusMessage: undefined,
    tags: undefined,
    targetArns: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.description !== undefined && data.description !== null) {
    contents.description = data.description;
  }
  if (data.id !== undefined && data.id !== null) {
    contents.id = data.id;
  }
  if (data.name !== undefined && data.name !== null) {
    contents.name = data.name;
  }
  if (data.status !== undefined && data.status !== null) {
    contents.status = data.status;
  }
  if (data.statusMessage !== undefined && data.statusMessage !== null) {
    contents.statusMessage = data.statusMessage;
  }
  if (data.tags !== undefined && data.tags !== null) {
    contents.tags = deserializeAws_restJson1MapOfStringToString(
      data.tags,
      context
    );
  }
  if (data.targetArns !== undefined && data.targetArns !== null) {
    contents.targetArns = deserializeAws_restJson1ListOfString(
      data.targetArns,
      context
    );
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1GetVpcLinkCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetVpcLinkCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1GetVpcLinksCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetVpcLinksCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1GetVpcLinksCommandError(output, context);
  }
  const contents: GetVpcLinksCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "VpcLinks",
    items: undefined,
    position: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.item !== undefined && data.item !== null) {
    contents.items = deserializeAws_restJson1ListOfVpcLink(data.item, context);
  }
  if (data.position !== undefined && data.position !== null) {
    contents.position = data.position;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1GetVpcLinksCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetVpcLinksCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.apigateway#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1ImportApiKeysCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ImportApiKeysCommandOutput> => {
  if (output.statusCode !== 201 && output.statusCode >= 400) {
    return deserializeAws_restJson1ImportApiKeysCommandError(output, context);
  }
  const contents: ImportApiKeysCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ApiKeyIds",
    ids: undefined,
    warnings: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.ids !== undefined && data.ids !== null) {
    contents.ids = deserializeAws_restJson1ListOfString(data.ids, context);
  }
  if (data.warnings !== undefined && data.warnings !== null) {
    contents.warnings = deserializeAws_restJson1ListOfString(
      data.warnings,
      context
    );
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1ImportApiKeysCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ImportApiKeysCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.apigateway#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ConflictException":
    case "com.amazonaws.apigateway#ConflictException":
      response = {
        ...(await deserializeAws_restJson1ConflictExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.apigateway#LimitExceededException":
      response = {
        ...(await deserializeAws_restJson1LimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1ImportDocumentationPartsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ImportDocumentationPartsCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1ImportDocumentationPartsCommandError(
      output,
      context
    );
  }
  const contents: ImportDocumentationPartsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DocumentationPartIds",
    ids: undefined,
    warnings: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.ids !== undefined && data.ids !== null) {
    contents.ids = deserializeAws_restJson1ListOfString(data.ids, context);
  }
  if (data.warnings !== undefined && data.warnings !== null) {
    contents.warnings = deserializeAws_restJson1ListOfString(
      data.warnings,
      context
    );
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1ImportDocumentationPartsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ImportDocumentationPartsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.apigateway#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.apigateway#LimitExceededException":
      response = {
        ...(await deserializeAws_restJson1LimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1ImportRestApiCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ImportRestApiCommandOutput> => {
  if (output.statusCode !== 201 && output.statusCode >= 400) {
    return deserializeAws_restJson1ImportRestApiCommandError(output, context);
  }
  const contents: ImportRestApiCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "RestApi",
    apiKeySource: undefined,
    binaryMediaTypes: undefined,
    createdDate: undefined,
    description: undefined,
    endpointConfiguration: undefined,
    id: undefined,
    minimumCompressionSize: undefined,
    name: undefined,
    policy: undefined,
    tags: undefined,
    version: undefined,
    warnings: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.apiKeySource !== undefined && data.apiKeySource !== null) {
    contents.apiKeySource = data.apiKeySource;
  }
  if (data.binaryMediaTypes !== undefined && data.binaryMediaTypes !== null) {
    contents.binaryMediaTypes = deserializeAws_restJson1ListOfString(
      data.binaryMediaTypes,
      context
    );
  }
  if (data.createdDate !== undefined && data.createdDate !== null) {
    contents.createdDate = new Date(Math.round(data.createdDate * 1000));
  }
  if (data.description !== undefined && data.description !== null) {
    contents.description = data.description;
  }
  if (
    data.endpointConfiguration !== undefined &&
    data.endpointConfiguration !== null
  ) {
    contents.endpointConfiguration = deserializeAws_restJson1EndpointConfiguration(
      data.endpointConfiguration,
      context
    );
  }
  if (data.id !== undefined && data.id !== null) {
    contents.id = data.id;
  }
  if (
    data.minimumCompressionSize !== undefined &&
    data.minimumCompressionSize !== null
  ) {
    contents.minimumCompressionSize = data.minimumCompressionSize;
  }
  if (data.name !== undefined && data.name !== null) {
    contents.name = data.name;
  }
  if (data.policy !== undefined && data.policy !== null) {
    contents.policy = data.policy;
  }
  if (data.tags !== undefined && data.tags !== null) {
    contents.tags = deserializeAws_restJson1MapOfStringToString(
      data.tags,
      context
    );
  }
  if (data.version !== undefined && data.version !== null) {
    contents.version = data.version;
  }
  if (data.warnings !== undefined && data.warnings !== null) {
    contents.warnings = deserializeAws_restJson1ListOfString(
      data.warnings,
      context
    );
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1ImportRestApiCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ImportRestApiCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.apigateway#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ConflictException":
    case "com.amazonaws.apigateway#ConflictException":
      response = {
        ...(await deserializeAws_restJson1ConflictExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.apigateway#LimitExceededException":
      response = {
        ...(await deserializeAws_restJson1LimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1PutGatewayResponseCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutGatewayResponseCommandOutput> => {
  if (output.statusCode !== 201 && output.statusCode >= 400) {
    return deserializeAws_restJson1PutGatewayResponseCommandError(
      output,
      context
    );
  }
  const contents: PutGatewayResponseCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GatewayResponse",
    defaultResponse: undefined,
    responseParameters: undefined,
    responseTemplates: undefined,
    responseType: undefined,
    statusCode: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.defaultResponse !== undefined && data.defaultResponse !== null) {
    contents.defaultResponse = data.defaultResponse;
  }
  if (
    data.responseParameters !== undefined &&
    data.responseParameters !== null
  ) {
    contents.responseParameters = deserializeAws_restJson1MapOfStringToString(
      data.responseParameters,
      context
    );
  }
  if (data.responseTemplates !== undefined && data.responseTemplates !== null) {
    contents.responseTemplates = deserializeAws_restJson1MapOfStringToString(
      data.responseTemplates,
      context
    );
  }
  if (data.responseType !== undefined && data.responseType !== null) {
    contents.responseType = data.responseType;
  }
  if (data.statusCode !== undefined && data.statusCode !== null) {
    contents.statusCode = data.statusCode;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1PutGatewayResponseCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutGatewayResponseCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.apigateway#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.apigateway#LimitExceededException":
      response = {
        ...(await deserializeAws_restJson1LimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1PutIntegrationCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutIntegrationCommandOutput> => {
  if (output.statusCode !== 201 && output.statusCode >= 400) {
    return deserializeAws_restJson1PutIntegrationCommandError(output, context);
  }
  const contents: PutIntegrationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "Integration",
    cacheKeyParameters: undefined,
    cacheNamespace: undefined,
    connectionId: undefined,
    connectionType: undefined,
    contentHandling: undefined,
    credentials: undefined,
    httpMethod: undefined,
    integrationResponses: undefined,
    passthroughBehavior: undefined,
    requestParameters: undefined,
    requestTemplates: undefined,
    timeoutInMillis: undefined,
    type: undefined,
    uri: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (
    data.cacheKeyParameters !== undefined &&
    data.cacheKeyParameters !== null
  ) {
    contents.cacheKeyParameters = deserializeAws_restJson1ListOfString(
      data.cacheKeyParameters,
      context
    );
  }
  if (data.cacheNamespace !== undefined && data.cacheNamespace !== null) {
    contents.cacheNamespace = data.cacheNamespace;
  }
  if (data.connectionId !== undefined && data.connectionId !== null) {
    contents.connectionId = data.connectionId;
  }
  if (data.connectionType !== undefined && data.connectionType !== null) {
    contents.connectionType = data.connectionType;
  }
  if (data.contentHandling !== undefined && data.contentHandling !== null) {
    contents.contentHandling = data.contentHandling;
  }
  if (data.credentials !== undefined && data.credentials !== null) {
    contents.credentials = data.credentials;
  }
  if (data.httpMethod !== undefined && data.httpMethod !== null) {
    contents.httpMethod = data.httpMethod;
  }
  if (
    data.integrationResponses !== undefined &&
    data.integrationResponses !== null
  ) {
    contents.integrationResponses = deserializeAws_restJson1MapOfIntegrationResponse(
      data.integrationResponses,
      context
    );
  }
  if (
    data.passthroughBehavior !== undefined &&
    data.passthroughBehavior !== null
  ) {
    contents.passthroughBehavior = data.passthroughBehavior;
  }
  if (data.requestParameters !== undefined && data.requestParameters !== null) {
    contents.requestParameters = deserializeAws_restJson1MapOfStringToString(
      data.requestParameters,
      context
    );
  }
  if (data.requestTemplates !== undefined && data.requestTemplates !== null) {
    contents.requestTemplates = deserializeAws_restJson1MapOfStringToString(
      data.requestTemplates,
      context
    );
  }
  if (data.timeoutInMillis !== undefined && data.timeoutInMillis !== null) {
    contents.timeoutInMillis = data.timeoutInMillis;
  }
  if (data.type !== undefined && data.type !== null) {
    contents.type = data.type;
  }
  if (data.uri !== undefined && data.uri !== null) {
    contents.uri = data.uri;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1PutIntegrationCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutIntegrationCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.apigateway#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ConflictException":
    case "com.amazonaws.apigateway#ConflictException":
      response = {
        ...(await deserializeAws_restJson1ConflictExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1PutIntegrationResponseCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutIntegrationResponseCommandOutput> => {
  if (output.statusCode !== 201 && output.statusCode >= 400) {
    return deserializeAws_restJson1PutIntegrationResponseCommandError(
      output,
      context
    );
  }
  const contents: PutIntegrationResponseCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "IntegrationResponse",
    contentHandling: undefined,
    responseParameters: undefined,
    responseTemplates: undefined,
    selectionPattern: undefined,
    statusCode: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.contentHandling !== undefined && data.contentHandling !== null) {
    contents.contentHandling = data.contentHandling;
  }
  if (
    data.responseParameters !== undefined &&
    data.responseParameters !== null
  ) {
    contents.responseParameters = deserializeAws_restJson1MapOfStringToString(
      data.responseParameters,
      context
    );
  }
  if (data.responseTemplates !== undefined && data.responseTemplates !== null) {
    contents.responseTemplates = deserializeAws_restJson1MapOfStringToString(
      data.responseTemplates,
      context
    );
  }
  if (data.selectionPattern !== undefined && data.selectionPattern !== null) {
    contents.selectionPattern = data.selectionPattern;
  }
  if (data.statusCode !== undefined && data.statusCode !== null) {
    contents.statusCode = data.statusCode;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1PutIntegrationResponseCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutIntegrationResponseCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.apigateway#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ConflictException":
    case "com.amazonaws.apigateway#ConflictException":
      response = {
        ...(await deserializeAws_restJson1ConflictExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.apigateway#LimitExceededException":
      response = {
        ...(await deserializeAws_restJson1LimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1PutMethodCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutMethodCommandOutput> => {
  if (output.statusCode !== 201 && output.statusCode >= 400) {
    return deserializeAws_restJson1PutMethodCommandError(output, context);
  }
  const contents: PutMethodCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "Method",
    apiKeyRequired: undefined,
    authorizationScopes: undefined,
    authorizationType: undefined,
    authorizerId: undefined,
    httpMethod: undefined,
    methodIntegration: undefined,
    methodResponses: undefined,
    operationName: undefined,
    requestModels: undefined,
    requestParameters: undefined,
    requestValidatorId: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.apiKeyRequired !== undefined && data.apiKeyRequired !== null) {
    contents.apiKeyRequired = data.apiKeyRequired;
  }
  if (
    data.authorizationScopes !== undefined &&
    data.authorizationScopes !== null
  ) {
    contents.authorizationScopes = deserializeAws_restJson1ListOfString(
      data.authorizationScopes,
      context
    );
  }
  if (data.authorizationType !== undefined && data.authorizationType !== null) {
    contents.authorizationType = data.authorizationType;
  }
  if (data.authorizerId !== undefined && data.authorizerId !== null) {
    contents.authorizerId = data.authorizerId;
  }
  if (data.httpMethod !== undefined && data.httpMethod !== null) {
    contents.httpMethod = data.httpMethod;
  }
  if (data.methodIntegration !== undefined && data.methodIntegration !== null) {
    contents.methodIntegration = deserializeAws_restJson1Integration(
      data.methodIntegration,
      context
    );
  }
  if (data.methodResponses !== undefined && data.methodResponses !== null) {
    contents.methodResponses = deserializeAws_restJson1MapOfMethodResponse(
      data.methodResponses,
      context
    );
  }
  if (data.operationName !== undefined && data.operationName !== null) {
    contents.operationName = data.operationName;
  }
  if (data.requestModels !== undefined && data.requestModels !== null) {
    contents.requestModels = deserializeAws_restJson1MapOfStringToString(
      data.requestModels,
      context
    );
  }
  if (data.requestParameters !== undefined && data.requestParameters !== null) {
    contents.requestParameters = deserializeAws_restJson1MapOfStringToBoolean(
      data.requestParameters,
      context
    );
  }
  if (
    data.requestValidatorId !== undefined &&
    data.requestValidatorId !== null
  ) {
    contents.requestValidatorId = data.requestValidatorId;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1PutMethodCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutMethodCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.apigateway#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ConflictException":
    case "com.amazonaws.apigateway#ConflictException":
      response = {
        ...(await deserializeAws_restJson1ConflictExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.apigateway#LimitExceededException":
      response = {
        ...(await deserializeAws_restJson1LimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1PutMethodResponseCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutMethodResponseCommandOutput> => {
  if (output.statusCode !== 201 && output.statusCode >= 400) {
    return deserializeAws_restJson1PutMethodResponseCommandError(
      output,
      context
    );
  }
  const contents: PutMethodResponseCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "MethodResponse",
    responseModels: undefined,
    responseParameters: undefined,
    statusCode: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.responseModels !== undefined && data.responseModels !== null) {
    contents.responseModels = deserializeAws_restJson1MapOfStringToString(
      data.responseModels,
      context
    );
  }
  if (
    data.responseParameters !== undefined &&
    data.responseParameters !== null
  ) {
    contents.responseParameters = deserializeAws_restJson1MapOfStringToBoolean(
      data.responseParameters,
      context
    );
  }
  if (data.statusCode !== undefined && data.statusCode !== null) {
    contents.statusCode = data.statusCode;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1PutMethodResponseCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutMethodResponseCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.apigateway#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ConflictException":
    case "com.amazonaws.apigateway#ConflictException":
      response = {
        ...(await deserializeAws_restJson1ConflictExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.apigateway#LimitExceededException":
      response = {
        ...(await deserializeAws_restJson1LimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1PutRestApiCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutRestApiCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1PutRestApiCommandError(output, context);
  }
  const contents: PutRestApiCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "RestApi",
    apiKeySource: undefined,
    binaryMediaTypes: undefined,
    createdDate: undefined,
    description: undefined,
    endpointConfiguration: undefined,
    id: undefined,
    minimumCompressionSize: undefined,
    name: undefined,
    policy: undefined,
    tags: undefined,
    version: undefined,
    warnings: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.apiKeySource !== undefined && data.apiKeySource !== null) {
    contents.apiKeySource = data.apiKeySource;
  }
  if (data.binaryMediaTypes !== undefined && data.binaryMediaTypes !== null) {
    contents.binaryMediaTypes = deserializeAws_restJson1ListOfString(
      data.binaryMediaTypes,
      context
    );
  }
  if (data.createdDate !== undefined && data.createdDate !== null) {
    contents.createdDate = new Date(Math.round(data.createdDate * 1000));
  }
  if (data.description !== undefined && data.description !== null) {
    contents.description = data.description;
  }
  if (
    data.endpointConfiguration !== undefined &&
    data.endpointConfiguration !== null
  ) {
    contents.endpointConfiguration = deserializeAws_restJson1EndpointConfiguration(
      data.endpointConfiguration,
      context
    );
  }
  if (data.id !== undefined && data.id !== null) {
    contents.id = data.id;
  }
  if (
    data.minimumCompressionSize !== undefined &&
    data.minimumCompressionSize !== null
  ) {
    contents.minimumCompressionSize = data.minimumCompressionSize;
  }
  if (data.name !== undefined && data.name !== null) {
    contents.name = data.name;
  }
  if (data.policy !== undefined && data.policy !== null) {
    contents.policy = data.policy;
  }
  if (data.tags !== undefined && data.tags !== null) {
    contents.tags = deserializeAws_restJson1MapOfStringToString(
      data.tags,
      context
    );
  }
  if (data.version !== undefined && data.version !== null) {
    contents.version = data.version;
  }
  if (data.warnings !== undefined && data.warnings !== null) {
    contents.warnings = deserializeAws_restJson1ListOfString(
      data.warnings,
      context
    );
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1PutRestApiCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutRestApiCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.apigateway#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ConflictException":
    case "com.amazonaws.apigateway#ConflictException":
      response = {
        ...(await deserializeAws_restJson1ConflictExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.apigateway#LimitExceededException":
      response = {
        ...(await deserializeAws_restJson1LimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1TagResourceCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<TagResourceCommandOutput> => {
  if (output.statusCode !== 204 && output.statusCode >= 400) {
    return deserializeAws_restJson1TagResourceCommandError(output, context);
  }
  const contents: TagResourceCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restJson1TagResourceCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<TagResourceCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.apigateway#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ConflictException":
    case "com.amazonaws.apigateway#ConflictException":
      response = {
        ...(await deserializeAws_restJson1ConflictExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.apigateway#LimitExceededException":
      response = {
        ...(await deserializeAws_restJson1LimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1TestInvokeAuthorizerCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<TestInvokeAuthorizerCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1TestInvokeAuthorizerCommandError(
      output,
      context
    );
  }
  const contents: TestInvokeAuthorizerCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "TestInvokeAuthorizerResponse",
    authorization: undefined,
    claims: undefined,
    clientStatus: undefined,
    latency: undefined,
    log: undefined,
    policy: undefined,
    principalId: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.authorization !== undefined && data.authorization !== null) {
    contents.authorization = deserializeAws_restJson1MapOfStringToList(
      data.authorization,
      context
    );
  }
  if (data.claims !== undefined && data.claims !== null) {
    contents.claims = deserializeAws_restJson1MapOfStringToString(
      data.claims,
      context
    );
  }
  if (data.clientStatus !== undefined && data.clientStatus !== null) {
    contents.clientStatus = data.clientStatus;
  }
  if (data.latency !== undefined && data.latency !== null) {
    contents.latency = data.latency;
  }
  if (data.log !== undefined && data.log !== null) {
    contents.log = data.log;
  }
  if (data.policy !== undefined && data.policy !== null) {
    contents.policy = data.policy;
  }
  if (data.principalId !== undefined && data.principalId !== null) {
    contents.principalId = data.principalId;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1TestInvokeAuthorizerCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<TestInvokeAuthorizerCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.apigateway#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1TestInvokeMethodCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<TestInvokeMethodCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1TestInvokeMethodCommandError(
      output,
      context
    );
  }
  const contents: TestInvokeMethodCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "TestInvokeMethodResponse",
    body: undefined,
    headers: undefined,
    latency: undefined,
    log: undefined,
    multiValueHeaders: undefined,
    status: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.body !== undefined && data.body !== null) {
    contents.body = data.body;
  }
  if (data.headers !== undefined && data.headers !== null) {
    contents.headers = deserializeAws_restJson1MapOfStringToString(
      data.headers,
      context
    );
  }
  if (data.latency !== undefined && data.latency !== null) {
    contents.latency = data.latency;
  }
  if (data.log !== undefined && data.log !== null) {
    contents.log = data.log;
  }
  if (data.multiValueHeaders !== undefined && data.multiValueHeaders !== null) {
    contents.multiValueHeaders = deserializeAws_restJson1MapOfStringToList(
      data.multiValueHeaders,
      context
    );
  }
  if (data.status !== undefined && data.status !== null) {
    contents.status = data.status;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1TestInvokeMethodCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<TestInvokeMethodCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.apigateway#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1UntagResourceCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UntagResourceCommandOutput> => {
  if (output.statusCode !== 204 && output.statusCode >= 400) {
    return deserializeAws_restJson1UntagResourceCommandError(output, context);
  }
  const contents: UntagResourceCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restJson1UntagResourceCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UntagResourceCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.apigateway#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ConflictException":
    case "com.amazonaws.apigateway#ConflictException":
      response = {
        ...(await deserializeAws_restJson1ConflictExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1UpdateAccountCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateAccountCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1UpdateAccountCommandError(output, context);
  }
  const contents: UpdateAccountCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "Account",
    apiKeyVersion: undefined,
    cloudwatchRoleArn: undefined,
    features: undefined,
    throttleSettings: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.apiKeyVersion !== undefined && data.apiKeyVersion !== null) {
    contents.apiKeyVersion = data.apiKeyVersion;
  }
  if (data.cloudwatchRoleArn !== undefined && data.cloudwatchRoleArn !== null) {
    contents.cloudwatchRoleArn = data.cloudwatchRoleArn;
  }
  if (data.features !== undefined && data.features !== null) {
    contents.features = deserializeAws_restJson1ListOfString(
      data.features,
      context
    );
  }
  if (data.throttleSettings !== undefined && data.throttleSettings !== null) {
    contents.throttleSettings = deserializeAws_restJson1ThrottleSettings(
      data.throttleSettings,
      context
    );
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1UpdateAccountCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateAccountCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.apigateway#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1UpdateApiKeyCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateApiKeyCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1UpdateApiKeyCommandError(output, context);
  }
  const contents: UpdateApiKeyCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ApiKey",
    createdDate: undefined,
    customerId: undefined,
    description: undefined,
    enabled: undefined,
    id: undefined,
    lastUpdatedDate: undefined,
    name: undefined,
    stageKeys: undefined,
    tags: undefined,
    value: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.createdDate !== undefined && data.createdDate !== null) {
    contents.createdDate = new Date(Math.round(data.createdDate * 1000));
  }
  if (data.customerId !== undefined && data.customerId !== null) {
    contents.customerId = data.customerId;
  }
  if (data.description !== undefined && data.description !== null) {
    contents.description = data.description;
  }
  if (data.enabled !== undefined && data.enabled !== null) {
    contents.enabled = data.enabled;
  }
  if (data.id !== undefined && data.id !== null) {
    contents.id = data.id;
  }
  if (data.lastUpdatedDate !== undefined && data.lastUpdatedDate !== null) {
    contents.lastUpdatedDate = new Date(
      Math.round(data.lastUpdatedDate * 1000)
    );
  }
  if (data.name !== undefined && data.name !== null) {
    contents.name = data.name;
  }
  if (data.stageKeys !== undefined && data.stageKeys !== null) {
    contents.stageKeys = deserializeAws_restJson1ListOfString(
      data.stageKeys,
      context
    );
  }
  if (data.tags !== undefined && data.tags !== null) {
    contents.tags = deserializeAws_restJson1MapOfStringToString(
      data.tags,
      context
    );
  }
  if (data.value !== undefined && data.value !== null) {
    contents.value = data.value;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1UpdateApiKeyCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateApiKeyCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.apigateway#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ConflictException":
    case "com.amazonaws.apigateway#ConflictException":
      response = {
        ...(await deserializeAws_restJson1ConflictExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1UpdateAuthorizerCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateAuthorizerCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1UpdateAuthorizerCommandError(
      output,
      context
    );
  }
  const contents: UpdateAuthorizerCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "Authorizer",
    authType: undefined,
    authorizerCredentials: undefined,
    authorizerResultTtlInSeconds: undefined,
    authorizerUri: undefined,
    id: undefined,
    identitySource: undefined,
    identityValidationExpression: undefined,
    name: undefined,
    providerARNs: undefined,
    type: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.authType !== undefined && data.authType !== null) {
    contents.authType = data.authType;
  }
  if (
    data.authorizerCredentials !== undefined &&
    data.authorizerCredentials !== null
  ) {
    contents.authorizerCredentials = data.authorizerCredentials;
  }
  if (
    data.authorizerResultTtlInSeconds !== undefined &&
    data.authorizerResultTtlInSeconds !== null
  ) {
    contents.authorizerResultTtlInSeconds = data.authorizerResultTtlInSeconds;
  }
  if (data.authorizerUri !== undefined && data.authorizerUri !== null) {
    contents.authorizerUri = data.authorizerUri;
  }
  if (data.id !== undefined && data.id !== null) {
    contents.id = data.id;
  }
  if (data.identitySource !== undefined && data.identitySource !== null) {
    contents.identitySource = data.identitySource;
  }
  if (
    data.identityValidationExpression !== undefined &&
    data.identityValidationExpression !== null
  ) {
    contents.identityValidationExpression = data.identityValidationExpression;
  }
  if (data.name !== undefined && data.name !== null) {
    contents.name = data.name;
  }
  if (data.providerARNs !== undefined && data.providerARNs !== null) {
    contents.providerARNs = deserializeAws_restJson1ListOfARNs(
      data.providerARNs,
      context
    );
  }
  if (data.type !== undefined && data.type !== null) {
    contents.type = data.type;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1UpdateAuthorizerCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateAuthorizerCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.apigateway#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1UpdateBasePathMappingCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateBasePathMappingCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1UpdateBasePathMappingCommandError(
      output,
      context
    );
  }
  const contents: UpdateBasePathMappingCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "BasePathMapping",
    basePath: undefined,
    restApiId: undefined,
    stage: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.basePath !== undefined && data.basePath !== null) {
    contents.basePath = data.basePath;
  }
  if (data.restApiId !== undefined && data.restApiId !== null) {
    contents.restApiId = data.restApiId;
  }
  if (data.stage !== undefined && data.stage !== null) {
    contents.stage = data.stage;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1UpdateBasePathMappingCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateBasePathMappingCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.apigateway#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ConflictException":
    case "com.amazonaws.apigateway#ConflictException":
      response = {
        ...(await deserializeAws_restJson1ConflictExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1UpdateClientCertificateCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateClientCertificateCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1UpdateClientCertificateCommandError(
      output,
      context
    );
  }
  const contents: UpdateClientCertificateCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ClientCertificate",
    clientCertificateId: undefined,
    createdDate: undefined,
    description: undefined,
    expirationDate: undefined,
    pemEncodedCertificate: undefined,
    tags: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (
    data.clientCertificateId !== undefined &&
    data.clientCertificateId !== null
  ) {
    contents.clientCertificateId = data.clientCertificateId;
  }
  if (data.createdDate !== undefined && data.createdDate !== null) {
    contents.createdDate = new Date(Math.round(data.createdDate * 1000));
  }
  if (data.description !== undefined && data.description !== null) {
    contents.description = data.description;
  }
  if (data.expirationDate !== undefined && data.expirationDate !== null) {
    contents.expirationDate = new Date(Math.round(data.expirationDate * 1000));
  }
  if (
    data.pemEncodedCertificate !== undefined &&
    data.pemEncodedCertificate !== null
  ) {
    contents.pemEncodedCertificate = data.pemEncodedCertificate;
  }
  if (data.tags !== undefined && data.tags !== null) {
    contents.tags = deserializeAws_restJson1MapOfStringToString(
      data.tags,
      context
    );
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1UpdateClientCertificateCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateClientCertificateCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.apigateway#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1UpdateDeploymentCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateDeploymentCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1UpdateDeploymentCommandError(
      output,
      context
    );
  }
  const contents: UpdateDeploymentCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "Deployment",
    apiSummary: undefined,
    createdDate: undefined,
    description: undefined,
    id: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.apiSummary !== undefined && data.apiSummary !== null) {
    contents.apiSummary = deserializeAws_restJson1PathToMapOfMethodSnapshot(
      data.apiSummary,
      context
    );
  }
  if (data.createdDate !== undefined && data.createdDate !== null) {
    contents.createdDate = new Date(Math.round(data.createdDate * 1000));
  }
  if (data.description !== undefined && data.description !== null) {
    contents.description = data.description;
  }
  if (data.id !== undefined && data.id !== null) {
    contents.id = data.id;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1UpdateDeploymentCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateDeploymentCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.apigateway#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.apigateway#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1UpdateDocumentationPartCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateDocumentationPartCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1UpdateDocumentationPartCommandError(
      output,
      context
    );
  }
  const contents: UpdateDocumentationPartCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DocumentationPart",
    id: undefined,
    location: undefined,
    properties: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.id !== undefined && data.id !== null) {
    contents.id = data.id;
  }
  if (data.location !== undefined && data.location !== null) {
    contents.location = deserializeAws_restJson1DocumentationPartLocation(
      data.location,
      context
    );
  }
  if (data.properties !== undefined && data.properties !== null) {
    contents.properties = data.properties;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1UpdateDocumentationPartCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateDocumentationPartCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.apigateway#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ConflictException":
    case "com.amazonaws.apigateway#ConflictException":
      response = {
        ...(await deserializeAws_restJson1ConflictExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.apigateway#LimitExceededException":
      response = {
        ...(await deserializeAws_restJson1LimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1UpdateDocumentationVersionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateDocumentationVersionCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1UpdateDocumentationVersionCommandError(
      output,
      context
    );
  }
  const contents: UpdateDocumentationVersionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DocumentationVersion",
    createdDate: undefined,
    description: undefined,
    version: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.createdDate !== undefined && data.createdDate !== null) {
    contents.createdDate = new Date(Math.round(data.createdDate * 1000));
  }
  if (data.description !== undefined && data.description !== null) {
    contents.description = data.description;
  }
  if (data.version !== undefined && data.version !== null) {
    contents.version = data.version;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1UpdateDocumentationVersionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateDocumentationVersionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.apigateway#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ConflictException":
    case "com.amazonaws.apigateway#ConflictException":
      response = {
        ...(await deserializeAws_restJson1ConflictExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1UpdateDomainNameCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateDomainNameCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1UpdateDomainNameCommandError(
      output,
      context
    );
  }
  const contents: UpdateDomainNameCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DomainName",
    certificateArn: undefined,
    certificateName: undefined,
    certificateUploadDate: undefined,
    distributionDomainName: undefined,
    distributionHostedZoneId: undefined,
    domainName: undefined,
    domainNameStatus: undefined,
    domainNameStatusMessage: undefined,
    endpointConfiguration: undefined,
    regionalCertificateArn: undefined,
    regionalCertificateName: undefined,
    regionalDomainName: undefined,
    regionalHostedZoneId: undefined,
    securityPolicy: undefined,
    tags: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.certificateArn !== undefined && data.certificateArn !== null) {
    contents.certificateArn = data.certificateArn;
  }
  if (data.certificateName !== undefined && data.certificateName !== null) {
    contents.certificateName = data.certificateName;
  }
  if (
    data.certificateUploadDate !== undefined &&
    data.certificateUploadDate !== null
  ) {
    contents.certificateUploadDate = new Date(
      Math.round(data.certificateUploadDate * 1000)
    );
  }
  if (
    data.distributionDomainName !== undefined &&
    data.distributionDomainName !== null
  ) {
    contents.distributionDomainName = data.distributionDomainName;
  }
  if (
    data.distributionHostedZoneId !== undefined &&
    data.distributionHostedZoneId !== null
  ) {
    contents.distributionHostedZoneId = data.distributionHostedZoneId;
  }
  if (data.domainName !== undefined && data.domainName !== null) {
    contents.domainName = data.domainName;
  }
  if (data.domainNameStatus !== undefined && data.domainNameStatus !== null) {
    contents.domainNameStatus = data.domainNameStatus;
  }
  if (
    data.domainNameStatusMessage !== undefined &&
    data.domainNameStatusMessage !== null
  ) {
    contents.domainNameStatusMessage = data.domainNameStatusMessage;
  }
  if (
    data.endpointConfiguration !== undefined &&
    data.endpointConfiguration !== null
  ) {
    contents.endpointConfiguration = deserializeAws_restJson1EndpointConfiguration(
      data.endpointConfiguration,
      context
    );
  }
  if (
    data.regionalCertificateArn !== undefined &&
    data.regionalCertificateArn !== null
  ) {
    contents.regionalCertificateArn = data.regionalCertificateArn;
  }
  if (
    data.regionalCertificateName !== undefined &&
    data.regionalCertificateName !== null
  ) {
    contents.regionalCertificateName = data.regionalCertificateName;
  }
  if (
    data.regionalDomainName !== undefined &&
    data.regionalDomainName !== null
  ) {
    contents.regionalDomainName = data.regionalDomainName;
  }
  if (
    data.regionalHostedZoneId !== undefined &&
    data.regionalHostedZoneId !== null
  ) {
    contents.regionalHostedZoneId = data.regionalHostedZoneId;
  }
  if (data.securityPolicy !== undefined && data.securityPolicy !== null) {
    contents.securityPolicy = data.securityPolicy;
  }
  if (data.tags !== undefined && data.tags !== null) {
    contents.tags = deserializeAws_restJson1MapOfStringToString(
      data.tags,
      context
    );
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1UpdateDomainNameCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateDomainNameCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.apigateway#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ConflictException":
    case "com.amazonaws.apigateway#ConflictException":
      response = {
        ...(await deserializeAws_restJson1ConflictExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1UpdateGatewayResponseCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateGatewayResponseCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1UpdateGatewayResponseCommandError(
      output,
      context
    );
  }
  const contents: UpdateGatewayResponseCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GatewayResponse",
    defaultResponse: undefined,
    responseParameters: undefined,
    responseTemplates: undefined,
    responseType: undefined,
    statusCode: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.defaultResponse !== undefined && data.defaultResponse !== null) {
    contents.defaultResponse = data.defaultResponse;
  }
  if (
    data.responseParameters !== undefined &&
    data.responseParameters !== null
  ) {
    contents.responseParameters = deserializeAws_restJson1MapOfStringToString(
      data.responseParameters,
      context
    );
  }
  if (data.responseTemplates !== undefined && data.responseTemplates !== null) {
    contents.responseTemplates = deserializeAws_restJson1MapOfStringToString(
      data.responseTemplates,
      context
    );
  }
  if (data.responseType !== undefined && data.responseType !== null) {
    contents.responseType = data.responseType;
  }
  if (data.statusCode !== undefined && data.statusCode !== null) {
    contents.statusCode = data.statusCode;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1UpdateGatewayResponseCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateGatewayResponseCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.apigateway#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1UpdateIntegrationCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateIntegrationCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1UpdateIntegrationCommandError(
      output,
      context
    );
  }
  const contents: UpdateIntegrationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "Integration",
    cacheKeyParameters: undefined,
    cacheNamespace: undefined,
    connectionId: undefined,
    connectionType: undefined,
    contentHandling: undefined,
    credentials: undefined,
    httpMethod: undefined,
    integrationResponses: undefined,
    passthroughBehavior: undefined,
    requestParameters: undefined,
    requestTemplates: undefined,
    timeoutInMillis: undefined,
    type: undefined,
    uri: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (
    data.cacheKeyParameters !== undefined &&
    data.cacheKeyParameters !== null
  ) {
    contents.cacheKeyParameters = deserializeAws_restJson1ListOfString(
      data.cacheKeyParameters,
      context
    );
  }
  if (data.cacheNamespace !== undefined && data.cacheNamespace !== null) {
    contents.cacheNamespace = data.cacheNamespace;
  }
  if (data.connectionId !== undefined && data.connectionId !== null) {
    contents.connectionId = data.connectionId;
  }
  if (data.connectionType !== undefined && data.connectionType !== null) {
    contents.connectionType = data.connectionType;
  }
  if (data.contentHandling !== undefined && data.contentHandling !== null) {
    contents.contentHandling = data.contentHandling;
  }
  if (data.credentials !== undefined && data.credentials !== null) {
    contents.credentials = data.credentials;
  }
  if (data.httpMethod !== undefined && data.httpMethod !== null) {
    contents.httpMethod = data.httpMethod;
  }
  if (
    data.integrationResponses !== undefined &&
    data.integrationResponses !== null
  ) {
    contents.integrationResponses = deserializeAws_restJson1MapOfIntegrationResponse(
      data.integrationResponses,
      context
    );
  }
  if (
    data.passthroughBehavior !== undefined &&
    data.passthroughBehavior !== null
  ) {
    contents.passthroughBehavior = data.passthroughBehavior;
  }
  if (data.requestParameters !== undefined && data.requestParameters !== null) {
    contents.requestParameters = deserializeAws_restJson1MapOfStringToString(
      data.requestParameters,
      context
    );
  }
  if (data.requestTemplates !== undefined && data.requestTemplates !== null) {
    contents.requestTemplates = deserializeAws_restJson1MapOfStringToString(
      data.requestTemplates,
      context
    );
  }
  if (data.timeoutInMillis !== undefined && data.timeoutInMillis !== null) {
    contents.timeoutInMillis = data.timeoutInMillis;
  }
  if (data.type !== undefined && data.type !== null) {
    contents.type = data.type;
  }
  if (data.uri !== undefined && data.uri !== null) {
    contents.uri = data.uri;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1UpdateIntegrationCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateIntegrationCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.apigateway#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ConflictException":
    case "com.amazonaws.apigateway#ConflictException":
      response = {
        ...(await deserializeAws_restJson1ConflictExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1UpdateIntegrationResponseCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateIntegrationResponseCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1UpdateIntegrationResponseCommandError(
      output,
      context
    );
  }
  const contents: UpdateIntegrationResponseCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "IntegrationResponse",
    contentHandling: undefined,
    responseParameters: undefined,
    responseTemplates: undefined,
    selectionPattern: undefined,
    statusCode: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.contentHandling !== undefined && data.contentHandling !== null) {
    contents.contentHandling = data.contentHandling;
  }
  if (
    data.responseParameters !== undefined &&
    data.responseParameters !== null
  ) {
    contents.responseParameters = deserializeAws_restJson1MapOfStringToString(
      data.responseParameters,
      context
    );
  }
  if (data.responseTemplates !== undefined && data.responseTemplates !== null) {
    contents.responseTemplates = deserializeAws_restJson1MapOfStringToString(
      data.responseTemplates,
      context
    );
  }
  if (data.selectionPattern !== undefined && data.selectionPattern !== null) {
    contents.selectionPattern = data.selectionPattern;
  }
  if (data.statusCode !== undefined && data.statusCode !== null) {
    contents.statusCode = data.statusCode;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1UpdateIntegrationResponseCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateIntegrationResponseCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.apigateway#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ConflictException":
    case "com.amazonaws.apigateway#ConflictException":
      response = {
        ...(await deserializeAws_restJson1ConflictExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1UpdateMethodCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateMethodCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1UpdateMethodCommandError(output, context);
  }
  const contents: UpdateMethodCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "Method",
    apiKeyRequired: undefined,
    authorizationScopes: undefined,
    authorizationType: undefined,
    authorizerId: undefined,
    httpMethod: undefined,
    methodIntegration: undefined,
    methodResponses: undefined,
    operationName: undefined,
    requestModels: undefined,
    requestParameters: undefined,
    requestValidatorId: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.apiKeyRequired !== undefined && data.apiKeyRequired !== null) {
    contents.apiKeyRequired = data.apiKeyRequired;
  }
  if (
    data.authorizationScopes !== undefined &&
    data.authorizationScopes !== null
  ) {
    contents.authorizationScopes = deserializeAws_restJson1ListOfString(
      data.authorizationScopes,
      context
    );
  }
  if (data.authorizationType !== undefined && data.authorizationType !== null) {
    contents.authorizationType = data.authorizationType;
  }
  if (data.authorizerId !== undefined && data.authorizerId !== null) {
    contents.authorizerId = data.authorizerId;
  }
  if (data.httpMethod !== undefined && data.httpMethod !== null) {
    contents.httpMethod = data.httpMethod;
  }
  if (data.methodIntegration !== undefined && data.methodIntegration !== null) {
    contents.methodIntegration = deserializeAws_restJson1Integration(
      data.methodIntegration,
      context
    );
  }
  if (data.methodResponses !== undefined && data.methodResponses !== null) {
    contents.methodResponses = deserializeAws_restJson1MapOfMethodResponse(
      data.methodResponses,
      context
    );
  }
  if (data.operationName !== undefined && data.operationName !== null) {
    contents.operationName = data.operationName;
  }
  if (data.requestModels !== undefined && data.requestModels !== null) {
    contents.requestModels = deserializeAws_restJson1MapOfStringToString(
      data.requestModels,
      context
    );
  }
  if (data.requestParameters !== undefined && data.requestParameters !== null) {
    contents.requestParameters = deserializeAws_restJson1MapOfStringToBoolean(
      data.requestParameters,
      context
    );
  }
  if (
    data.requestValidatorId !== undefined &&
    data.requestValidatorId !== null
  ) {
    contents.requestValidatorId = data.requestValidatorId;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1UpdateMethodCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateMethodCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.apigateway#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ConflictException":
    case "com.amazonaws.apigateway#ConflictException":
      response = {
        ...(await deserializeAws_restJson1ConflictExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1UpdateMethodResponseCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateMethodResponseCommandOutput> => {
  if (output.statusCode !== 201 && output.statusCode >= 400) {
    return deserializeAws_restJson1UpdateMethodResponseCommandError(
      output,
      context
    );
  }
  const contents: UpdateMethodResponseCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "MethodResponse",
    responseModels: undefined,
    responseParameters: undefined,
    statusCode: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.responseModels !== undefined && data.responseModels !== null) {
    contents.responseModels = deserializeAws_restJson1MapOfStringToString(
      data.responseModels,
      context
    );
  }
  if (
    data.responseParameters !== undefined &&
    data.responseParameters !== null
  ) {
    contents.responseParameters = deserializeAws_restJson1MapOfStringToBoolean(
      data.responseParameters,
      context
    );
  }
  if (data.statusCode !== undefined && data.statusCode !== null) {
    contents.statusCode = data.statusCode;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1UpdateMethodResponseCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateMethodResponseCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.apigateway#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ConflictException":
    case "com.amazonaws.apigateway#ConflictException":
      response = {
        ...(await deserializeAws_restJson1ConflictExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.apigateway#LimitExceededException":
      response = {
        ...(await deserializeAws_restJson1LimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1UpdateModelCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateModelCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1UpdateModelCommandError(output, context);
  }
  const contents: UpdateModelCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "Model",
    contentType: undefined,
    description: undefined,
    id: undefined,
    name: undefined,
    schema: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.contentType !== undefined && data.contentType !== null) {
    contents.contentType = data.contentType;
  }
  if (data.description !== undefined && data.description !== null) {
    contents.description = data.description;
  }
  if (data.id !== undefined && data.id !== null) {
    contents.id = data.id;
  }
  if (data.name !== undefined && data.name !== null) {
    contents.name = data.name;
  }
  if (data.schema !== undefined && data.schema !== null) {
    contents.schema = data.schema;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1UpdateModelCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateModelCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.apigateway#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ConflictException":
    case "com.amazonaws.apigateway#ConflictException":
      response = {
        ...(await deserializeAws_restJson1ConflictExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1UpdateRequestValidatorCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateRequestValidatorCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1UpdateRequestValidatorCommandError(
      output,
      context
    );
  }
  const contents: UpdateRequestValidatorCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "RequestValidator",
    id: undefined,
    name: undefined,
    validateRequestBody: undefined,
    validateRequestParameters: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.id !== undefined && data.id !== null) {
    contents.id = data.id;
  }
  if (data.name !== undefined && data.name !== null) {
    contents.name = data.name;
  }
  if (
    data.validateRequestBody !== undefined &&
    data.validateRequestBody !== null
  ) {
    contents.validateRequestBody = data.validateRequestBody;
  }
  if (
    data.validateRequestParameters !== undefined &&
    data.validateRequestParameters !== null
  ) {
    contents.validateRequestParameters = data.validateRequestParameters;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1UpdateRequestValidatorCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateRequestValidatorCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.apigateway#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1UpdateResourceCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateResourceCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1UpdateResourceCommandError(output, context);
  }
  const contents: UpdateResourceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "Resource",
    id: undefined,
    parentId: undefined,
    path: undefined,
    pathPart: undefined,
    resourceMethods: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.id !== undefined && data.id !== null) {
    contents.id = data.id;
  }
  if (data.parentId !== undefined && data.parentId !== null) {
    contents.parentId = data.parentId;
  }
  if (data.path !== undefined && data.path !== null) {
    contents.path = data.path;
  }
  if (data.pathPart !== undefined && data.pathPart !== null) {
    contents.pathPart = data.pathPart;
  }
  if (data.resourceMethods !== undefined && data.resourceMethods !== null) {
    contents.resourceMethods = deserializeAws_restJson1MapOfMethod(
      data.resourceMethods,
      context
    );
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1UpdateResourceCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateResourceCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.apigateway#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ConflictException":
    case "com.amazonaws.apigateway#ConflictException":
      response = {
        ...(await deserializeAws_restJson1ConflictExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1UpdateRestApiCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateRestApiCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1UpdateRestApiCommandError(output, context);
  }
  const contents: UpdateRestApiCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "RestApi",
    apiKeySource: undefined,
    binaryMediaTypes: undefined,
    createdDate: undefined,
    description: undefined,
    endpointConfiguration: undefined,
    id: undefined,
    minimumCompressionSize: undefined,
    name: undefined,
    policy: undefined,
    tags: undefined,
    version: undefined,
    warnings: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.apiKeySource !== undefined && data.apiKeySource !== null) {
    contents.apiKeySource = data.apiKeySource;
  }
  if (data.binaryMediaTypes !== undefined && data.binaryMediaTypes !== null) {
    contents.binaryMediaTypes = deserializeAws_restJson1ListOfString(
      data.binaryMediaTypes,
      context
    );
  }
  if (data.createdDate !== undefined && data.createdDate !== null) {
    contents.createdDate = new Date(Math.round(data.createdDate * 1000));
  }
  if (data.description !== undefined && data.description !== null) {
    contents.description = data.description;
  }
  if (
    data.endpointConfiguration !== undefined &&
    data.endpointConfiguration !== null
  ) {
    contents.endpointConfiguration = deserializeAws_restJson1EndpointConfiguration(
      data.endpointConfiguration,
      context
    );
  }
  if (data.id !== undefined && data.id !== null) {
    contents.id = data.id;
  }
  if (
    data.minimumCompressionSize !== undefined &&
    data.minimumCompressionSize !== null
  ) {
    contents.minimumCompressionSize = data.minimumCompressionSize;
  }
  if (data.name !== undefined && data.name !== null) {
    contents.name = data.name;
  }
  if (data.policy !== undefined && data.policy !== null) {
    contents.policy = data.policy;
  }
  if (data.tags !== undefined && data.tags !== null) {
    contents.tags = deserializeAws_restJson1MapOfStringToString(
      data.tags,
      context
    );
  }
  if (data.version !== undefined && data.version !== null) {
    contents.version = data.version;
  }
  if (data.warnings !== undefined && data.warnings !== null) {
    contents.warnings = deserializeAws_restJson1ListOfString(
      data.warnings,
      context
    );
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1UpdateRestApiCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateRestApiCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.apigateway#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ConflictException":
    case "com.amazonaws.apigateway#ConflictException":
      response = {
        ...(await deserializeAws_restJson1ConflictExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1UpdateStageCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateStageCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1UpdateStageCommandError(output, context);
  }
  const contents: UpdateStageCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "Stage",
    accessLogSettings: undefined,
    cacheClusterEnabled: undefined,
    cacheClusterSize: undefined,
    cacheClusterStatus: undefined,
    canarySettings: undefined,
    clientCertificateId: undefined,
    createdDate: undefined,
    deploymentId: undefined,
    description: undefined,
    documentationVersion: undefined,
    lastUpdatedDate: undefined,
    methodSettings: undefined,
    stageName: undefined,
    tags: undefined,
    tracingEnabled: undefined,
    variables: undefined,
    webAclArn: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.accessLogSettings !== undefined && data.accessLogSettings !== null) {
    contents.accessLogSettings = deserializeAws_restJson1AccessLogSettings(
      data.accessLogSettings,
      context
    );
  }
  if (
    data.cacheClusterEnabled !== undefined &&
    data.cacheClusterEnabled !== null
  ) {
    contents.cacheClusterEnabled = data.cacheClusterEnabled;
  }
  if (data.cacheClusterSize !== undefined && data.cacheClusterSize !== null) {
    contents.cacheClusterSize = data.cacheClusterSize;
  }
  if (
    data.cacheClusterStatus !== undefined &&
    data.cacheClusterStatus !== null
  ) {
    contents.cacheClusterStatus = data.cacheClusterStatus;
  }
  if (data.canarySettings !== undefined && data.canarySettings !== null) {
    contents.canarySettings = deserializeAws_restJson1CanarySettings(
      data.canarySettings,
      context
    );
  }
  if (
    data.clientCertificateId !== undefined &&
    data.clientCertificateId !== null
  ) {
    contents.clientCertificateId = data.clientCertificateId;
  }
  if (data.createdDate !== undefined && data.createdDate !== null) {
    contents.createdDate = new Date(Math.round(data.createdDate * 1000));
  }
  if (data.deploymentId !== undefined && data.deploymentId !== null) {
    contents.deploymentId = data.deploymentId;
  }
  if (data.description !== undefined && data.description !== null) {
    contents.description = data.description;
  }
  if (
    data.documentationVersion !== undefined &&
    data.documentationVersion !== null
  ) {
    contents.documentationVersion = data.documentationVersion;
  }
  if (data.lastUpdatedDate !== undefined && data.lastUpdatedDate !== null) {
    contents.lastUpdatedDate = new Date(
      Math.round(data.lastUpdatedDate * 1000)
    );
  }
  if (data.methodSettings !== undefined && data.methodSettings !== null) {
    contents.methodSettings = deserializeAws_restJson1MapOfMethodSettings(
      data.methodSettings,
      context
    );
  }
  if (data.stageName !== undefined && data.stageName !== null) {
    contents.stageName = data.stageName;
  }
  if (data.tags !== undefined && data.tags !== null) {
    contents.tags = deserializeAws_restJson1MapOfStringToString(
      data.tags,
      context
    );
  }
  if (data.tracingEnabled !== undefined && data.tracingEnabled !== null) {
    contents.tracingEnabled = data.tracingEnabled;
  }
  if (data.variables !== undefined && data.variables !== null) {
    contents.variables = deserializeAws_restJson1MapOfStringToString(
      data.variables,
      context
    );
  }
  if (data.webAclArn !== undefined && data.webAclArn !== null) {
    contents.webAclArn = data.webAclArn;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1UpdateStageCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateStageCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.apigateway#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ConflictException":
    case "com.amazonaws.apigateway#ConflictException":
      response = {
        ...(await deserializeAws_restJson1ConflictExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1UpdateUsageCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateUsageCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1UpdateUsageCommandError(output, context);
  }
  const contents: UpdateUsageCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "Usage",
    endDate: undefined,
    items: undefined,
    position: undefined,
    startDate: undefined,
    usagePlanId: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.endDate !== undefined && data.endDate !== null) {
    contents.endDate = data.endDate;
  }
  if (data.values !== undefined && data.values !== null) {
    contents.items = deserializeAws_restJson1MapOfKeyUsages(
      data.values,
      context
    );
  }
  if (data.position !== undefined && data.position !== null) {
    contents.position = data.position;
  }
  if (data.startDate !== undefined && data.startDate !== null) {
    contents.startDate = data.startDate;
  }
  if (data.usagePlanId !== undefined && data.usagePlanId !== null) {
    contents.usagePlanId = data.usagePlanId;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1UpdateUsageCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateUsageCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.apigateway#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1UpdateUsagePlanCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateUsagePlanCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1UpdateUsagePlanCommandError(output, context);
  }
  const contents: UpdateUsagePlanCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UsagePlan",
    apiStages: undefined,
    description: undefined,
    id: undefined,
    name: undefined,
    productCode: undefined,
    quota: undefined,
    tags: undefined,
    throttle: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.apiStages !== undefined && data.apiStages !== null) {
    contents.apiStages = deserializeAws_restJson1ListOfApiStage(
      data.apiStages,
      context
    );
  }
  if (data.description !== undefined && data.description !== null) {
    contents.description = data.description;
  }
  if (data.id !== undefined && data.id !== null) {
    contents.id = data.id;
  }
  if (data.name !== undefined && data.name !== null) {
    contents.name = data.name;
  }
  if (data.productCode !== undefined && data.productCode !== null) {
    contents.productCode = data.productCode;
  }
  if (data.quota !== undefined && data.quota !== null) {
    contents.quota = deserializeAws_restJson1QuotaSettings(data.quota, context);
  }
  if (data.tags !== undefined && data.tags !== null) {
    contents.tags = deserializeAws_restJson1MapOfStringToString(
      data.tags,
      context
    );
  }
  if (data.throttle !== undefined && data.throttle !== null) {
    contents.throttle = deserializeAws_restJson1ThrottleSettings(
      data.throttle,
      context
    );
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1UpdateUsagePlanCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateUsagePlanCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.apigateway#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ConflictException":
    case "com.amazonaws.apigateway#ConflictException":
      response = {
        ...(await deserializeAws_restJson1ConflictExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1UpdateVpcLinkCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateVpcLinkCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1UpdateVpcLinkCommandError(output, context);
  }
  const contents: UpdateVpcLinkCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "VpcLink",
    description: undefined,
    id: undefined,
    name: undefined,
    status: undefined,
    statusMessage: undefined,
    tags: undefined,
    targetArns: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.description !== undefined && data.description !== null) {
    contents.description = data.description;
  }
  if (data.id !== undefined && data.id !== null) {
    contents.id = data.id;
  }
  if (data.name !== undefined && data.name !== null) {
    contents.name = data.name;
  }
  if (data.status !== undefined && data.status !== null) {
    contents.status = data.status;
  }
  if (data.statusMessage !== undefined && data.statusMessage !== null) {
    contents.statusMessage = data.statusMessage;
  }
  if (data.tags !== undefined && data.tags !== null) {
    contents.tags = deserializeAws_restJson1MapOfStringToString(
      data.tags,
      context
    );
  }
  if (data.targetArns !== undefined && data.targetArns !== null) {
    contents.targetArns = deserializeAws_restJson1ListOfString(
      data.targetArns,
      context
    );
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1UpdateVpcLinkCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateVpcLinkCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.apigateway#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ConflictException":
    case "com.amazonaws.apigateway#ConflictException":
      response = {
        ...(await deserializeAws_restJson1ConflictExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.apigateway#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.apigateway#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.apigateway#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

const deserializeAws_restJson1BadRequestExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<BadRequestException> => {
  const contents: BadRequestException = {
    name: "BadRequestException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined
  };
  const data: any = parsedOutput.body;
  if (data.message !== undefined && data.message !== null) {
    contents.message = data.message;
  }
  return contents;
};

const deserializeAws_restJson1ConflictExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ConflictException> => {
  const contents: ConflictException = {
    name: "ConflictException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined
  };
  const data: any = parsedOutput.body;
  if (data.message !== undefined && data.message !== null) {
    contents.message = data.message;
  }
  return contents;
};

const deserializeAws_restJson1LimitExceededExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<LimitExceededException> => {
  const contents: LimitExceededException = {
    name: "LimitExceededException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined,
    retryAfterSeconds: undefined
  };
  if (parsedOutput.headers["retry-after"] !== undefined) {
    contents.retryAfterSeconds = parsedOutput.headers["retry-after"];
  }
  const data: any = parsedOutput.body;
  if (data.message !== undefined && data.message !== null) {
    contents.message = data.message;
  }
  return contents;
};

const deserializeAws_restJson1NotFoundExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<NotFoundException> => {
  const contents: NotFoundException = {
    name: "NotFoundException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined
  };
  const data: any = parsedOutput.body;
  if (data.message !== undefined && data.message !== null) {
    contents.message = data.message;
  }
  return contents;
};

const deserializeAws_restJson1ServiceUnavailableExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ServiceUnavailableException> => {
  const contents: ServiceUnavailableException = {
    name: "ServiceUnavailableException",
    $fault: "server",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined,
    retryAfterSeconds: undefined
  };
  if (parsedOutput.headers["retry-after"] !== undefined) {
    contents.retryAfterSeconds = parsedOutput.headers["retry-after"];
  }
  const data: any = parsedOutput.body;
  if (data.message !== undefined && data.message !== null) {
    contents.message = data.message;
  }
  return contents;
};

const deserializeAws_restJson1TooManyRequestsExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<TooManyRequestsException> => {
  const contents: TooManyRequestsException = {
    name: "TooManyRequestsException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined,
    retryAfterSeconds: undefined
  };
  if (parsedOutput.headers["retry-after"] !== undefined) {
    contents.retryAfterSeconds = parsedOutput.headers["retry-after"];
  }
  const data: any = parsedOutput.body;
  if (data.message !== undefined && data.message !== null) {
    contents.message = data.message;
  }
  return contents;
};

const deserializeAws_restJson1UnauthorizedExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<UnauthorizedException> => {
  const contents: UnauthorizedException = {
    name: "UnauthorizedException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined
  };
  const data: any = parsedOutput.body;
  if (data.message !== undefined && data.message !== null) {
    contents.message = data.message;
  }
  return contents;
};

const serializeAws_restJson1ApiStage = (
  input: ApiStage,
  context: __SerdeContext
): any => {
  return {
    ...(input.apiId !== undefined && { apiId: input.apiId }),
    ...(input.stage !== undefined && { stage: input.stage }),
    ...(input.throttle !== undefined && {
      throttle: serializeAws_restJson1MapOfApiStageThrottleSettings(
        input.throttle,
        context
      )
    })
  };
};

const serializeAws_restJson1CanarySettings = (
  input: CanarySettings,
  context: __SerdeContext
): any => {
  return {
    ...(input.deploymentId !== undefined && {
      deploymentId: input.deploymentId
    }),
    ...(input.percentTraffic !== undefined && {
      percentTraffic: input.percentTraffic
    }),
    ...(input.stageVariableOverrides !== undefined && {
      stageVariableOverrides: serializeAws_restJson1MapOfStringToString(
        input.stageVariableOverrides,
        context
      )
    }),
    ...(input.useStageCache !== undefined && {
      useStageCache: input.useStageCache
    })
  };
};

const serializeAws_restJson1DeploymentCanarySettings = (
  input: DeploymentCanarySettings,
  context: __SerdeContext
): any => {
  return {
    ...(input.percentTraffic !== undefined && {
      percentTraffic: input.percentTraffic
    }),
    ...(input.stageVariableOverrides !== undefined && {
      stageVariableOverrides: serializeAws_restJson1MapOfStringToString(
        input.stageVariableOverrides,
        context
      )
    }),
    ...(input.useStageCache !== undefined && {
      useStageCache: input.useStageCache
    })
  };
};

const serializeAws_restJson1DocumentationPartLocation = (
  input: DocumentationPartLocation,
  context: __SerdeContext
): any => {
  return {
    ...(input.method !== undefined && { method: input.method }),
    ...(input.name !== undefined && { name: input.name }),
    ...(input.path !== undefined && { path: input.path }),
    ...(input.statusCode !== undefined && { statusCode: input.statusCode }),
    ...(input.type !== undefined && { type: input.type })
  };
};

const serializeAws_restJson1EndpointConfiguration = (
  input: EndpointConfiguration,
  context: __SerdeContext
): any => {
  return {
    ...(input.types !== undefined && {
      types: serializeAws_restJson1ListOfEndpointType(input.types, context)
    }),
    ...(input.vpcEndpointIds !== undefined && {
      vpcEndpointIds: serializeAws_restJson1ListOfString(
        input.vpcEndpointIds,
        context
      )
    })
  };
};

const serializeAws_restJson1ListOfApiStage = (
  input: ApiStage[],
  context: __SerdeContext
): any => {
  return input.map(entry => serializeAws_restJson1ApiStage(entry, context));
};

const serializeAws_restJson1ListOfARNs = (
  input: string[],
  context: __SerdeContext
): any => {
  return input.map(entry => entry);
};

const serializeAws_restJson1ListOfEndpointType = (
  input: (EndpointType | string)[],
  context: __SerdeContext
): any => {
  return input.map(entry => entry);
};

const serializeAws_restJson1ListOfPatchOperation = (
  input: PatchOperation[],
  context: __SerdeContext
): any => {
  return input.map(entry =>
    serializeAws_restJson1PatchOperation(entry, context)
  );
};

const serializeAws_restJson1ListOfStageKeys = (
  input: StageKey[],
  context: __SerdeContext
): any => {
  return input.map(entry => serializeAws_restJson1StageKey(entry, context));
};

const serializeAws_restJson1ListOfString = (
  input: string[],
  context: __SerdeContext
): any => {
  return input.map(entry => entry);
};

const serializeAws_restJson1MapOfApiStageThrottleSettings = (
  input: { [key: string]: ThrottleSettings },
  context: __SerdeContext
): any => {
  return Object.entries(input).reduce(
    (
      acc: { [key: string]: ThrottleSettings },
      [key, value]: [string, any]
    ) => ({
      ...acc,
      [key]: serializeAws_restJson1ThrottleSettings(value, context)
    }),
    {}
  );
};

const serializeAws_restJson1MapOfStringToBoolean = (
  input: { [key: string]: boolean },
  context: __SerdeContext
): any => {
  return Object.entries(input).reduce(
    (acc: { [key: string]: boolean }, [key, value]: [string, any]) => ({
      ...acc,
      [key]: value
    }),
    {}
  );
};

const serializeAws_restJson1MapOfStringToList = (
  input: { [key: string]: string[] },
  context: __SerdeContext
): any => {
  return Object.entries(input).reduce(
    (acc: { [key: string]: string[] }, [key, value]: [string, any]) => ({
      ...acc,
      [key]: serializeAws_restJson1ListOfString(value, context)
    }),
    {}
  );
};

const serializeAws_restJson1MapOfStringToString = (
  input: { [key: string]: string },
  context: __SerdeContext
): any => {
  return Object.entries(input).reduce(
    (acc: { [key: string]: string }, [key, value]: [string, any]) => ({
      ...acc,
      [key]: value
    }),
    {}
  );
};

const serializeAws_restJson1PatchOperation = (
  input: PatchOperation,
  context: __SerdeContext
): any => {
  return {
    ...(input.from !== undefined && { from: input.from }),
    ...(input.op !== undefined && { op: input.op }),
    ...(input.path !== undefined && { path: input.path }),
    ...(input.value !== undefined && { value: input.value })
  };
};

const serializeAws_restJson1QuotaSettings = (
  input: QuotaSettings,
  context: __SerdeContext
): any => {
  return {
    ...(input.limit !== undefined && { limit: input.limit }),
    ...(input.offset !== undefined && { offset: input.offset }),
    ...(input.period !== undefined && { period: input.period })
  };
};

const serializeAws_restJson1StageKey = (
  input: StageKey,
  context: __SerdeContext
): any => {
  return {
    ...(input.restApiId !== undefined && { restApiId: input.restApiId }),
    ...(input.stageName !== undefined && { stageName: input.stageName })
  };
};

const serializeAws_restJson1ThrottleSettings = (
  input: ThrottleSettings,
  context: __SerdeContext
): any => {
  return {
    ...(input.burstLimit !== undefined && { burstLimit: input.burstLimit }),
    ...(input.rateLimit !== undefined && { rateLimit: input.rateLimit })
  };
};

const deserializeAws_restJson1AccessLogSettings = (
  output: any,
  context: __SerdeContext
): AccessLogSettings => {
  return {
    __type: "AccessLogSettings",
    destinationArn:
      output.destinationArn !== undefined && output.destinationArn !== null
        ? output.destinationArn
        : undefined,
    format:
      output.format !== undefined && output.format !== null
        ? output.format
        : undefined
  } as any;
};

const deserializeAws_restJson1ApiKey = (
  output: any,
  context: __SerdeContext
): ApiKey => {
  return {
    __type: "ApiKey",
    createdDate:
      output.createdDate !== undefined && output.createdDate !== null
        ? new Date(Math.round(output.createdDate * 1000))
        : undefined,
    customerId:
      output.customerId !== undefined && output.customerId !== null
        ? output.customerId
        : undefined,
    description:
      output.description !== undefined && output.description !== null
        ? output.description
        : undefined,
    enabled:
      output.enabled !== undefined && output.enabled !== null
        ? output.enabled
        : undefined,
    id: output.id !== undefined && output.id !== null ? output.id : undefined,
    lastUpdatedDate:
      output.lastUpdatedDate !== undefined && output.lastUpdatedDate !== null
        ? new Date(Math.round(output.lastUpdatedDate * 1000))
        : undefined,
    name:
      output.name !== undefined && output.name !== null
        ? output.name
        : undefined,
    stageKeys:
      output.stageKeys !== undefined && output.stageKeys !== null
        ? deserializeAws_restJson1ListOfString(output.stageKeys, context)
        : undefined,
    tags:
      output.tags !== undefined && output.tags !== null
        ? deserializeAws_restJson1MapOfStringToString(output.tags, context)
        : undefined,
    value:
      output.value !== undefined && output.value !== null
        ? output.value
        : undefined
  } as any;
};

const deserializeAws_restJson1ApiStage = (
  output: any,
  context: __SerdeContext
): ApiStage => {
  return {
    __type: "ApiStage",
    apiId:
      output.apiId !== undefined && output.apiId !== null
        ? output.apiId
        : undefined,
    stage:
      output.stage !== undefined && output.stage !== null
        ? output.stage
        : undefined,
    throttle:
      output.throttle !== undefined && output.throttle !== null
        ? deserializeAws_restJson1MapOfApiStageThrottleSettings(
            output.throttle,
            context
          )
        : undefined
  } as any;
};

const deserializeAws_restJson1Authorizer = (
  output: any,
  context: __SerdeContext
): Authorizer => {
  return {
    __type: "Authorizer",
    authType:
      output.authType !== undefined && output.authType !== null
        ? output.authType
        : undefined,
    authorizerCredentials:
      output.authorizerCredentials !== undefined &&
      output.authorizerCredentials !== null
        ? output.authorizerCredentials
        : undefined,
    authorizerResultTtlInSeconds:
      output.authorizerResultTtlInSeconds !== undefined &&
      output.authorizerResultTtlInSeconds !== null
        ? output.authorizerResultTtlInSeconds
        : undefined,
    authorizerUri:
      output.authorizerUri !== undefined && output.authorizerUri !== null
        ? output.authorizerUri
        : undefined,
    id: output.id !== undefined && output.id !== null ? output.id : undefined,
    identitySource:
      output.identitySource !== undefined && output.identitySource !== null
        ? output.identitySource
        : undefined,
    identityValidationExpression:
      output.identityValidationExpression !== undefined &&
      output.identityValidationExpression !== null
        ? output.identityValidationExpression
        : undefined,
    name:
      output.name !== undefined && output.name !== null
        ? output.name
        : undefined,
    providerARNs:
      output.providerARNs !== undefined && output.providerARNs !== null
        ? deserializeAws_restJson1ListOfARNs(output.providerARNs, context)
        : undefined,
    type:
      output.type !== undefined && output.type !== null
        ? output.type
        : undefined
  } as any;
};

const deserializeAws_restJson1BasePathMapping = (
  output: any,
  context: __SerdeContext
): BasePathMapping => {
  return {
    __type: "BasePathMapping",
    basePath:
      output.basePath !== undefined && output.basePath !== null
        ? output.basePath
        : undefined,
    restApiId:
      output.restApiId !== undefined && output.restApiId !== null
        ? output.restApiId
        : undefined,
    stage:
      output.stage !== undefined && output.stage !== null
        ? output.stage
        : undefined
  } as any;
};

const deserializeAws_restJson1CanarySettings = (
  output: any,
  context: __SerdeContext
): CanarySettings => {
  return {
    __type: "CanarySettings",
    deploymentId:
      output.deploymentId !== undefined && output.deploymentId !== null
        ? output.deploymentId
        : undefined,
    percentTraffic:
      output.percentTraffic !== undefined && output.percentTraffic !== null
        ? output.percentTraffic
        : undefined,
    stageVariableOverrides:
      output.stageVariableOverrides !== undefined &&
      output.stageVariableOverrides !== null
        ? deserializeAws_restJson1MapOfStringToString(
            output.stageVariableOverrides,
            context
          )
        : undefined,
    useStageCache:
      output.useStageCache !== undefined && output.useStageCache !== null
        ? output.useStageCache
        : undefined
  } as any;
};

const deserializeAws_restJson1ClientCertificate = (
  output: any,
  context: __SerdeContext
): ClientCertificate => {
  return {
    __type: "ClientCertificate",
    clientCertificateId:
      output.clientCertificateId !== undefined &&
      output.clientCertificateId !== null
        ? output.clientCertificateId
        : undefined,
    createdDate:
      output.createdDate !== undefined && output.createdDate !== null
        ? new Date(Math.round(output.createdDate * 1000))
        : undefined,
    description:
      output.description !== undefined && output.description !== null
        ? output.description
        : undefined,
    expirationDate:
      output.expirationDate !== undefined && output.expirationDate !== null
        ? new Date(Math.round(output.expirationDate * 1000))
        : undefined,
    pemEncodedCertificate:
      output.pemEncodedCertificate !== undefined &&
      output.pemEncodedCertificate !== null
        ? output.pemEncodedCertificate
        : undefined,
    tags:
      output.tags !== undefined && output.tags !== null
        ? deserializeAws_restJson1MapOfStringToString(output.tags, context)
        : undefined
  } as any;
};

const deserializeAws_restJson1Deployment = (
  output: any,
  context: __SerdeContext
): Deployment => {
  return {
    __type: "Deployment",
    apiSummary:
      output.apiSummary !== undefined && output.apiSummary !== null
        ? deserializeAws_restJson1PathToMapOfMethodSnapshot(
            output.apiSummary,
            context
          )
        : undefined,
    createdDate:
      output.createdDate !== undefined && output.createdDate !== null
        ? new Date(Math.round(output.createdDate * 1000))
        : undefined,
    description:
      output.description !== undefined && output.description !== null
        ? output.description
        : undefined,
    id: output.id !== undefined && output.id !== null ? output.id : undefined
  } as any;
};

const deserializeAws_restJson1DocumentationPart = (
  output: any,
  context: __SerdeContext
): DocumentationPart => {
  return {
    __type: "DocumentationPart",
    id: output.id !== undefined && output.id !== null ? output.id : undefined,
    location:
      output.location !== undefined && output.location !== null
        ? deserializeAws_restJson1DocumentationPartLocation(
            output.location,
            context
          )
        : undefined,
    properties:
      output.properties !== undefined && output.properties !== null
        ? output.properties
        : undefined
  } as any;
};

const deserializeAws_restJson1DocumentationPartLocation = (
  output: any,
  context: __SerdeContext
): DocumentationPartLocation => {
  return {
    __type: "DocumentationPartLocation",
    method:
      output.method !== undefined && output.method !== null
        ? output.method
        : undefined,
    name:
      output.name !== undefined && output.name !== null
        ? output.name
        : undefined,
    path:
      output.path !== undefined && output.path !== null
        ? output.path
        : undefined,
    statusCode:
      output.statusCode !== undefined && output.statusCode !== null
        ? output.statusCode
        : undefined,
    type:
      output.type !== undefined && output.type !== null
        ? output.type
        : undefined
  } as any;
};

const deserializeAws_restJson1DocumentationVersion = (
  output: any,
  context: __SerdeContext
): DocumentationVersion => {
  return {
    __type: "DocumentationVersion",
    createdDate:
      output.createdDate !== undefined && output.createdDate !== null
        ? new Date(Math.round(output.createdDate * 1000))
        : undefined,
    description:
      output.description !== undefined && output.description !== null
        ? output.description
        : undefined,
    version:
      output.version !== undefined && output.version !== null
        ? output.version
        : undefined
  } as any;
};

const deserializeAws_restJson1DomainName = (
  output: any,
  context: __SerdeContext
): DomainName => {
  return {
    __type: "DomainName",
    certificateArn:
      output.certificateArn !== undefined && output.certificateArn !== null
        ? output.certificateArn
        : undefined,
    certificateName:
      output.certificateName !== undefined && output.certificateName !== null
        ? output.certificateName
        : undefined,
    certificateUploadDate:
      output.certificateUploadDate !== undefined &&
      output.certificateUploadDate !== null
        ? new Date(Math.round(output.certificateUploadDate * 1000))
        : undefined,
    distributionDomainName:
      output.distributionDomainName !== undefined &&
      output.distributionDomainName !== null
        ? output.distributionDomainName
        : undefined,
    distributionHostedZoneId:
      output.distributionHostedZoneId !== undefined &&
      output.distributionHostedZoneId !== null
        ? output.distributionHostedZoneId
        : undefined,
    domainName:
      output.domainName !== undefined && output.domainName !== null
        ? output.domainName
        : undefined,
    domainNameStatus:
      output.domainNameStatus !== undefined && output.domainNameStatus !== null
        ? output.domainNameStatus
        : undefined,
    domainNameStatusMessage:
      output.domainNameStatusMessage !== undefined &&
      output.domainNameStatusMessage !== null
        ? output.domainNameStatusMessage
        : undefined,
    endpointConfiguration:
      output.endpointConfiguration !== undefined &&
      output.endpointConfiguration !== null
        ? deserializeAws_restJson1EndpointConfiguration(
            output.endpointConfiguration,
            context
          )
        : undefined,
    regionalCertificateArn:
      output.regionalCertificateArn !== undefined &&
      output.regionalCertificateArn !== null
        ? output.regionalCertificateArn
        : undefined,
    regionalCertificateName:
      output.regionalCertificateName !== undefined &&
      output.regionalCertificateName !== null
        ? output.regionalCertificateName
        : undefined,
    regionalDomainName:
      output.regionalDomainName !== undefined &&
      output.regionalDomainName !== null
        ? output.regionalDomainName
        : undefined,
    regionalHostedZoneId:
      output.regionalHostedZoneId !== undefined &&
      output.regionalHostedZoneId !== null
        ? output.regionalHostedZoneId
        : undefined,
    securityPolicy:
      output.securityPolicy !== undefined && output.securityPolicy !== null
        ? output.securityPolicy
        : undefined,
    tags:
      output.tags !== undefined && output.tags !== null
        ? deserializeAws_restJson1MapOfStringToString(output.tags, context)
        : undefined
  } as any;
};

const deserializeAws_restJson1EndpointConfiguration = (
  output: any,
  context: __SerdeContext
): EndpointConfiguration => {
  return {
    __type: "EndpointConfiguration",
    types:
      output.types !== undefined && output.types !== null
        ? deserializeAws_restJson1ListOfEndpointType(output.types, context)
        : undefined,
    vpcEndpointIds:
      output.vpcEndpointIds !== undefined && output.vpcEndpointIds !== null
        ? deserializeAws_restJson1ListOfString(output.vpcEndpointIds, context)
        : undefined
  } as any;
};

const deserializeAws_restJson1GatewayResponse = (
  output: any,
  context: __SerdeContext
): GatewayResponse => {
  return {
    __type: "GatewayResponse",
    defaultResponse:
      output.defaultResponse !== undefined && output.defaultResponse !== null
        ? output.defaultResponse
        : undefined,
    responseParameters:
      output.responseParameters !== undefined &&
      output.responseParameters !== null
        ? deserializeAws_restJson1MapOfStringToString(
            output.responseParameters,
            context
          )
        : undefined,
    responseTemplates:
      output.responseTemplates !== undefined &&
      output.responseTemplates !== null
        ? deserializeAws_restJson1MapOfStringToString(
            output.responseTemplates,
            context
          )
        : undefined,
    responseType:
      output.responseType !== undefined && output.responseType !== null
        ? output.responseType
        : undefined,
    statusCode:
      output.statusCode !== undefined && output.statusCode !== null
        ? output.statusCode
        : undefined
  } as any;
};

const deserializeAws_restJson1Integration = (
  output: any,
  context: __SerdeContext
): Integration => {
  return {
    __type: "Integration",
    cacheKeyParameters:
      output.cacheKeyParameters !== undefined &&
      output.cacheKeyParameters !== null
        ? deserializeAws_restJson1ListOfString(
            output.cacheKeyParameters,
            context
          )
        : undefined,
    cacheNamespace:
      output.cacheNamespace !== undefined && output.cacheNamespace !== null
        ? output.cacheNamespace
        : undefined,
    connectionId:
      output.connectionId !== undefined && output.connectionId !== null
        ? output.connectionId
        : undefined,
    connectionType:
      output.connectionType !== undefined && output.connectionType !== null
        ? output.connectionType
        : undefined,
    contentHandling:
      output.contentHandling !== undefined && output.contentHandling !== null
        ? output.contentHandling
        : undefined,
    credentials:
      output.credentials !== undefined && output.credentials !== null
        ? output.credentials
        : undefined,
    httpMethod:
      output.httpMethod !== undefined && output.httpMethod !== null
        ? output.httpMethod
        : undefined,
    integrationResponses:
      output.integrationResponses !== undefined &&
      output.integrationResponses !== null
        ? deserializeAws_restJson1MapOfIntegrationResponse(
            output.integrationResponses,
            context
          )
        : undefined,
    passthroughBehavior:
      output.passthroughBehavior !== undefined &&
      output.passthroughBehavior !== null
        ? output.passthroughBehavior
        : undefined,
    requestParameters:
      output.requestParameters !== undefined &&
      output.requestParameters !== null
        ? deserializeAws_restJson1MapOfStringToString(
            output.requestParameters,
            context
          )
        : undefined,
    requestTemplates:
      output.requestTemplates !== undefined && output.requestTemplates !== null
        ? deserializeAws_restJson1MapOfStringToString(
            output.requestTemplates,
            context
          )
        : undefined,
    timeoutInMillis:
      output.timeoutInMillis !== undefined && output.timeoutInMillis !== null
        ? output.timeoutInMillis
        : undefined,
    type:
      output.type !== undefined && output.type !== null
        ? output.type
        : undefined,
    uri:
      output.uri !== undefined && output.uri !== null ? output.uri : undefined
  } as any;
};

const deserializeAws_restJson1IntegrationResponse = (
  output: any,
  context: __SerdeContext
): IntegrationResponse => {
  return {
    __type: "IntegrationResponse",
    contentHandling:
      output.contentHandling !== undefined && output.contentHandling !== null
        ? output.contentHandling
        : undefined,
    responseParameters:
      output.responseParameters !== undefined &&
      output.responseParameters !== null
        ? deserializeAws_restJson1MapOfStringToString(
            output.responseParameters,
            context
          )
        : undefined,
    responseTemplates:
      output.responseTemplates !== undefined &&
      output.responseTemplates !== null
        ? deserializeAws_restJson1MapOfStringToString(
            output.responseTemplates,
            context
          )
        : undefined,
    selectionPattern:
      output.selectionPattern !== undefined && output.selectionPattern !== null
        ? output.selectionPattern
        : undefined,
    statusCode:
      output.statusCode !== undefined && output.statusCode !== null
        ? output.statusCode
        : undefined
  } as any;
};

const deserializeAws_restJson1ListOfApiKey = (
  output: any,
  context: __SerdeContext
): ApiKey[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1ApiKey(entry, context)
  );
};

const deserializeAws_restJson1ListOfApiStage = (
  output: any,
  context: __SerdeContext
): ApiStage[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1ApiStage(entry, context)
  );
};

const deserializeAws_restJson1ListOfARNs = (
  output: any,
  context: __SerdeContext
): string[] => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_restJson1ListOfAuthorizer = (
  output: any,
  context: __SerdeContext
): Authorizer[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1Authorizer(entry, context)
  );
};

const deserializeAws_restJson1ListOfBasePathMapping = (
  output: any,
  context: __SerdeContext
): BasePathMapping[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1BasePathMapping(entry, context)
  );
};

const deserializeAws_restJson1ListOfClientCertificate = (
  output: any,
  context: __SerdeContext
): ClientCertificate[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1ClientCertificate(entry, context)
  );
};

const deserializeAws_restJson1ListOfDeployment = (
  output: any,
  context: __SerdeContext
): Deployment[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1Deployment(entry, context)
  );
};

const deserializeAws_restJson1ListOfDocumentationPart = (
  output: any,
  context: __SerdeContext
): DocumentationPart[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1DocumentationPart(entry, context)
  );
};

const deserializeAws_restJson1ListOfDocumentationVersion = (
  output: any,
  context: __SerdeContext
): DocumentationVersion[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1DocumentationVersion(entry, context)
  );
};

const deserializeAws_restJson1ListOfDomainName = (
  output: any,
  context: __SerdeContext
): DomainName[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1DomainName(entry, context)
  );
};

const deserializeAws_restJson1ListOfEndpointType = (
  output: any,
  context: __SerdeContext
): (EndpointType | string)[] => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_restJson1ListOfGatewayResponse = (
  output: any,
  context: __SerdeContext
): GatewayResponse[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1GatewayResponse(entry, context)
  );
};

const deserializeAws_restJson1ListOfLong = (
  output: any,
  context: __SerdeContext
): number[] => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_restJson1ListOfModel = (
  output: any,
  context: __SerdeContext
): Model[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1Model(entry, context)
  );
};

const deserializeAws_restJson1ListOfRequestValidator = (
  output: any,
  context: __SerdeContext
): RequestValidator[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1RequestValidator(entry, context)
  );
};

const deserializeAws_restJson1ListOfResource = (
  output: any,
  context: __SerdeContext
): Resource[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1Resource(entry, context)
  );
};

const deserializeAws_restJson1ListOfRestApi = (
  output: any,
  context: __SerdeContext
): RestApi[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1RestApi(entry, context)
  );
};

const deserializeAws_restJson1ListOfSdkConfigurationProperty = (
  output: any,
  context: __SerdeContext
): SdkConfigurationProperty[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1SdkConfigurationProperty(entry, context)
  );
};

const deserializeAws_restJson1ListOfSdkType = (
  output: any,
  context: __SerdeContext
): SdkType[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1SdkType(entry, context)
  );
};

const deserializeAws_restJson1ListOfStage = (
  output: any,
  context: __SerdeContext
): Stage[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1Stage(entry, context)
  );
};

const deserializeAws_restJson1ListOfString = (
  output: any,
  context: __SerdeContext
): string[] => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_restJson1ListOfUsage = (
  output: any,
  context: __SerdeContext
): number[][] => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1ListOfLong(entry, context)
  );
};

const deserializeAws_restJson1ListOfUsagePlan = (
  output: any,
  context: __SerdeContext
): UsagePlan[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1UsagePlan(entry, context)
  );
};

const deserializeAws_restJson1ListOfUsagePlanKey = (
  output: any,
  context: __SerdeContext
): UsagePlanKey[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1UsagePlanKey(entry, context)
  );
};

const deserializeAws_restJson1ListOfVpcLink = (
  output: any,
  context: __SerdeContext
): VpcLink[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1VpcLink(entry, context)
  );
};

const deserializeAws_restJson1MapOfApiStageThrottleSettings = (
  output: any,
  context: __SerdeContext
): { [key: string]: ThrottleSettings } => {
  return Object.entries(output).reduce(
    (
      acc: { [key: string]: ThrottleSettings },
      [key, value]: [string, any]
    ) => ({
      ...acc,
      [key]: deserializeAws_restJson1ThrottleSettings(value, context)
    }),
    {}
  );
};

const deserializeAws_restJson1MapOfIntegrationResponse = (
  output: any,
  context: __SerdeContext
): { [key: string]: IntegrationResponse } => {
  return Object.entries(output).reduce(
    (
      acc: { [key: string]: IntegrationResponse },
      [key, value]: [string, any]
    ) => ({
      ...acc,
      [key]: deserializeAws_restJson1IntegrationResponse(value, context)
    }),
    {}
  );
};

const deserializeAws_restJson1MapOfKeyUsages = (
  output: any,
  context: __SerdeContext
): { [key: string]: number[][] } => {
  return Object.entries(output).reduce(
    (acc: { [key: string]: number[][] }, [key, value]: [string, any]) => ({
      ...acc,
      [key]: deserializeAws_restJson1ListOfUsage(value, context)
    }),
    {}
  );
};

const deserializeAws_restJson1MapOfMethod = (
  output: any,
  context: __SerdeContext
): { [key: string]: Method } => {
  return Object.entries(output).reduce(
    (acc: { [key: string]: Method }, [key, value]: [string, any]) => ({
      ...acc,
      [key]: deserializeAws_restJson1Method(value, context)
    }),
    {}
  );
};

const deserializeAws_restJson1MapOfMethodResponse = (
  output: any,
  context: __SerdeContext
): { [key: string]: MethodResponse } => {
  return Object.entries(output).reduce(
    (acc: { [key: string]: MethodResponse }, [key, value]: [string, any]) => ({
      ...acc,
      [key]: deserializeAws_restJson1MethodResponse(value, context)
    }),
    {}
  );
};

const deserializeAws_restJson1MapOfMethodSettings = (
  output: any,
  context: __SerdeContext
): { [key: string]: MethodSetting } => {
  return Object.entries(output).reduce(
    (acc: { [key: string]: MethodSetting }, [key, value]: [string, any]) => ({
      ...acc,
      [key]: deserializeAws_restJson1MethodSetting(value, context)
    }),
    {}
  );
};

const deserializeAws_restJson1MapOfMethodSnapshot = (
  output: any,
  context: __SerdeContext
): { [key: string]: MethodSnapshot } => {
  return Object.entries(output).reduce(
    (acc: { [key: string]: MethodSnapshot }, [key, value]: [string, any]) => ({
      ...acc,
      [key]: deserializeAws_restJson1MethodSnapshot(value, context)
    }),
    {}
  );
};

const deserializeAws_restJson1MapOfStringToBoolean = (
  output: any,
  context: __SerdeContext
): { [key: string]: boolean } => {
  return Object.entries(output).reduce(
    (acc: { [key: string]: boolean }, [key, value]: [string, any]) => ({
      ...acc,
      [key]: value
    }),
    {}
  );
};

const deserializeAws_restJson1MapOfStringToList = (
  output: any,
  context: __SerdeContext
): { [key: string]: string[] } => {
  return Object.entries(output).reduce(
    (acc: { [key: string]: string[] }, [key, value]: [string, any]) => ({
      ...acc,
      [key]: deserializeAws_restJson1ListOfString(value, context)
    }),
    {}
  );
};

const deserializeAws_restJson1MapOfStringToString = (
  output: any,
  context: __SerdeContext
): { [key: string]: string } => {
  return Object.entries(output).reduce(
    (acc: { [key: string]: string }, [key, value]: [string, any]) => ({
      ...acc,
      [key]: value
    }),
    {}
  );
};

const deserializeAws_restJson1Method = (
  output: any,
  context: __SerdeContext
): Method => {
  return {
    __type: "Method",
    apiKeyRequired:
      output.apiKeyRequired !== undefined && output.apiKeyRequired !== null
        ? output.apiKeyRequired
        : undefined,
    authorizationScopes:
      output.authorizationScopes !== undefined &&
      output.authorizationScopes !== null
        ? deserializeAws_restJson1ListOfString(
            output.authorizationScopes,
            context
          )
        : undefined,
    authorizationType:
      output.authorizationType !== undefined &&
      output.authorizationType !== null
        ? output.authorizationType
        : undefined,
    authorizerId:
      output.authorizerId !== undefined && output.authorizerId !== null
        ? output.authorizerId
        : undefined,
    httpMethod:
      output.httpMethod !== undefined && output.httpMethod !== null
        ? output.httpMethod
        : undefined,
    methodIntegration:
      output.methodIntegration !== undefined &&
      output.methodIntegration !== null
        ? deserializeAws_restJson1Integration(output.methodIntegration, context)
        : undefined,
    methodResponses:
      output.methodResponses !== undefined && output.methodResponses !== null
        ? deserializeAws_restJson1MapOfMethodResponse(
            output.methodResponses,
            context
          )
        : undefined,
    operationName:
      output.operationName !== undefined && output.operationName !== null
        ? output.operationName
        : undefined,
    requestModels:
      output.requestModels !== undefined && output.requestModels !== null
        ? deserializeAws_restJson1MapOfStringToString(
            output.requestModels,
            context
          )
        : undefined,
    requestParameters:
      output.requestParameters !== undefined &&
      output.requestParameters !== null
        ? deserializeAws_restJson1MapOfStringToBoolean(
            output.requestParameters,
            context
          )
        : undefined,
    requestValidatorId:
      output.requestValidatorId !== undefined &&
      output.requestValidatorId !== null
        ? output.requestValidatorId
        : undefined
  } as any;
};

const deserializeAws_restJson1MethodResponse = (
  output: any,
  context: __SerdeContext
): MethodResponse => {
  return {
    __type: "MethodResponse",
    responseModels:
      output.responseModels !== undefined && output.responseModels !== null
        ? deserializeAws_restJson1MapOfStringToString(
            output.responseModels,
            context
          )
        : undefined,
    responseParameters:
      output.responseParameters !== undefined &&
      output.responseParameters !== null
        ? deserializeAws_restJson1MapOfStringToBoolean(
            output.responseParameters,
            context
          )
        : undefined,
    statusCode:
      output.statusCode !== undefined && output.statusCode !== null
        ? output.statusCode
        : undefined
  } as any;
};

const deserializeAws_restJson1MethodSetting = (
  output: any,
  context: __SerdeContext
): MethodSetting => {
  return {
    __type: "MethodSetting",
    cacheDataEncrypted:
      output.cacheDataEncrypted !== undefined &&
      output.cacheDataEncrypted !== null
        ? output.cacheDataEncrypted
        : undefined,
    cacheTtlInSeconds:
      output.cacheTtlInSeconds !== undefined &&
      output.cacheTtlInSeconds !== null
        ? output.cacheTtlInSeconds
        : undefined,
    cachingEnabled:
      output.cachingEnabled !== undefined && output.cachingEnabled !== null
        ? output.cachingEnabled
        : undefined,
    dataTraceEnabled:
      output.dataTraceEnabled !== undefined && output.dataTraceEnabled !== null
        ? output.dataTraceEnabled
        : undefined,
    loggingLevel:
      output.loggingLevel !== undefined && output.loggingLevel !== null
        ? output.loggingLevel
        : undefined,
    metricsEnabled:
      output.metricsEnabled !== undefined && output.metricsEnabled !== null
        ? output.metricsEnabled
        : undefined,
    requireAuthorizationForCacheControl:
      output.requireAuthorizationForCacheControl !== undefined &&
      output.requireAuthorizationForCacheControl !== null
        ? output.requireAuthorizationForCacheControl
        : undefined,
    throttlingBurstLimit:
      output.throttlingBurstLimit !== undefined &&
      output.throttlingBurstLimit !== null
        ? output.throttlingBurstLimit
        : undefined,
    throttlingRateLimit:
      output.throttlingRateLimit !== undefined &&
      output.throttlingRateLimit !== null
        ? output.throttlingRateLimit
        : undefined,
    unauthorizedCacheControlHeaderStrategy:
      output.unauthorizedCacheControlHeaderStrategy !== undefined &&
      output.unauthorizedCacheControlHeaderStrategy !== null
        ? output.unauthorizedCacheControlHeaderStrategy
        : undefined
  } as any;
};

const deserializeAws_restJson1MethodSnapshot = (
  output: any,
  context: __SerdeContext
): MethodSnapshot => {
  return {
    __type: "MethodSnapshot",
    apiKeyRequired:
      output.apiKeyRequired !== undefined && output.apiKeyRequired !== null
        ? output.apiKeyRequired
        : undefined,
    authorizationType:
      output.authorizationType !== undefined &&
      output.authorizationType !== null
        ? output.authorizationType
        : undefined
  } as any;
};

const deserializeAws_restJson1Model = (
  output: any,
  context: __SerdeContext
): Model => {
  return {
    __type: "Model",
    contentType:
      output.contentType !== undefined && output.contentType !== null
        ? output.contentType
        : undefined,
    description:
      output.description !== undefined && output.description !== null
        ? output.description
        : undefined,
    id: output.id !== undefined && output.id !== null ? output.id : undefined,
    name:
      output.name !== undefined && output.name !== null
        ? output.name
        : undefined,
    schema:
      output.schema !== undefined && output.schema !== null
        ? output.schema
        : undefined
  } as any;
};

const deserializeAws_restJson1PathToMapOfMethodSnapshot = (
  output: any,
  context: __SerdeContext
): { [key: string]: { [key: string]: MethodSnapshot } } => {
  return Object.entries(output).reduce(
    (
      acc: { [key: string]: { [key: string]: MethodSnapshot } },
      [key, value]: [string, any]
    ) => ({
      ...acc,
      [key]: deserializeAws_restJson1MapOfMethodSnapshot(value, context)
    }),
    {}
  );
};

const deserializeAws_restJson1QuotaSettings = (
  output: any,
  context: __SerdeContext
): QuotaSettings => {
  return {
    __type: "QuotaSettings",
    limit:
      output.limit !== undefined && output.limit !== null
        ? output.limit
        : undefined,
    offset:
      output.offset !== undefined && output.offset !== null
        ? output.offset
        : undefined,
    period:
      output.period !== undefined && output.period !== null
        ? output.period
        : undefined
  } as any;
};

const deserializeAws_restJson1RequestValidator = (
  output: any,
  context: __SerdeContext
): RequestValidator => {
  return {
    __type: "RequestValidator",
    id: output.id !== undefined && output.id !== null ? output.id : undefined,
    name:
      output.name !== undefined && output.name !== null
        ? output.name
        : undefined,
    validateRequestBody:
      output.validateRequestBody !== undefined &&
      output.validateRequestBody !== null
        ? output.validateRequestBody
        : undefined,
    validateRequestParameters:
      output.validateRequestParameters !== undefined &&
      output.validateRequestParameters !== null
        ? output.validateRequestParameters
        : undefined
  } as any;
};

const deserializeAws_restJson1Resource = (
  output: any,
  context: __SerdeContext
): Resource => {
  return {
    __type: "Resource",
    id: output.id !== undefined && output.id !== null ? output.id : undefined,
    parentId:
      output.parentId !== undefined && output.parentId !== null
        ? output.parentId
        : undefined,
    path:
      output.path !== undefined && output.path !== null
        ? output.path
        : undefined,
    pathPart:
      output.pathPart !== undefined && output.pathPart !== null
        ? output.pathPart
        : undefined,
    resourceMethods:
      output.resourceMethods !== undefined && output.resourceMethods !== null
        ? deserializeAws_restJson1MapOfMethod(output.resourceMethods, context)
        : undefined
  } as any;
};

const deserializeAws_restJson1RestApi = (
  output: any,
  context: __SerdeContext
): RestApi => {
  return {
    __type: "RestApi",
    apiKeySource:
      output.apiKeySource !== undefined && output.apiKeySource !== null
        ? output.apiKeySource
        : undefined,
    binaryMediaTypes:
      output.binaryMediaTypes !== undefined && output.binaryMediaTypes !== null
        ? deserializeAws_restJson1ListOfString(output.binaryMediaTypes, context)
        : undefined,
    createdDate:
      output.createdDate !== undefined && output.createdDate !== null
        ? new Date(Math.round(output.createdDate * 1000))
        : undefined,
    description:
      output.description !== undefined && output.description !== null
        ? output.description
        : undefined,
    endpointConfiguration:
      output.endpointConfiguration !== undefined &&
      output.endpointConfiguration !== null
        ? deserializeAws_restJson1EndpointConfiguration(
            output.endpointConfiguration,
            context
          )
        : undefined,
    id: output.id !== undefined && output.id !== null ? output.id : undefined,
    minimumCompressionSize:
      output.minimumCompressionSize !== undefined &&
      output.minimumCompressionSize !== null
        ? output.minimumCompressionSize
        : undefined,
    name:
      output.name !== undefined && output.name !== null
        ? output.name
        : undefined,
    policy:
      output.policy !== undefined && output.policy !== null
        ? output.policy
        : undefined,
    tags:
      output.tags !== undefined && output.tags !== null
        ? deserializeAws_restJson1MapOfStringToString(output.tags, context)
        : undefined,
    version:
      output.version !== undefined && output.version !== null
        ? output.version
        : undefined,
    warnings:
      output.warnings !== undefined && output.warnings !== null
        ? deserializeAws_restJson1ListOfString(output.warnings, context)
        : undefined
  } as any;
};

const deserializeAws_restJson1SdkConfigurationProperty = (
  output: any,
  context: __SerdeContext
): SdkConfigurationProperty => {
  return {
    __type: "SdkConfigurationProperty",
    defaultValue:
      output.defaultValue !== undefined && output.defaultValue !== null
        ? output.defaultValue
        : undefined,
    description:
      output.description !== undefined && output.description !== null
        ? output.description
        : undefined,
    friendlyName:
      output.friendlyName !== undefined && output.friendlyName !== null
        ? output.friendlyName
        : undefined,
    name:
      output.name !== undefined && output.name !== null
        ? output.name
        : undefined,
    required:
      output.required !== undefined && output.required !== null
        ? output.required
        : undefined
  } as any;
};

const deserializeAws_restJson1SdkType = (
  output: any,
  context: __SerdeContext
): SdkType => {
  return {
    __type: "SdkType",
    configurationProperties:
      output.configurationProperties !== undefined &&
      output.configurationProperties !== null
        ? deserializeAws_restJson1ListOfSdkConfigurationProperty(
            output.configurationProperties,
            context
          )
        : undefined,
    description:
      output.description !== undefined && output.description !== null
        ? output.description
        : undefined,
    friendlyName:
      output.friendlyName !== undefined && output.friendlyName !== null
        ? output.friendlyName
        : undefined,
    id: output.id !== undefined && output.id !== null ? output.id : undefined
  } as any;
};

const deserializeAws_restJson1Stage = (
  output: any,
  context: __SerdeContext
): Stage => {
  return {
    __type: "Stage",
    accessLogSettings:
      output.accessLogSettings !== undefined &&
      output.accessLogSettings !== null
        ? deserializeAws_restJson1AccessLogSettings(
            output.accessLogSettings,
            context
          )
        : undefined,
    cacheClusterEnabled:
      output.cacheClusterEnabled !== undefined &&
      output.cacheClusterEnabled !== null
        ? output.cacheClusterEnabled
        : undefined,
    cacheClusterSize:
      output.cacheClusterSize !== undefined && output.cacheClusterSize !== null
        ? output.cacheClusterSize
        : undefined,
    cacheClusterStatus:
      output.cacheClusterStatus !== undefined &&
      output.cacheClusterStatus !== null
        ? output.cacheClusterStatus
        : undefined,
    canarySettings:
      output.canarySettings !== undefined && output.canarySettings !== null
        ? deserializeAws_restJson1CanarySettings(output.canarySettings, context)
        : undefined,
    clientCertificateId:
      output.clientCertificateId !== undefined &&
      output.clientCertificateId !== null
        ? output.clientCertificateId
        : undefined,
    createdDate:
      output.createdDate !== undefined && output.createdDate !== null
        ? new Date(Math.round(output.createdDate * 1000))
        : undefined,
    deploymentId:
      output.deploymentId !== undefined && output.deploymentId !== null
        ? output.deploymentId
        : undefined,
    description:
      output.description !== undefined && output.description !== null
        ? output.description
        : undefined,
    documentationVersion:
      output.documentationVersion !== undefined &&
      output.documentationVersion !== null
        ? output.documentationVersion
        : undefined,
    lastUpdatedDate:
      output.lastUpdatedDate !== undefined && output.lastUpdatedDate !== null
        ? new Date(Math.round(output.lastUpdatedDate * 1000))
        : undefined,
    methodSettings:
      output.methodSettings !== undefined && output.methodSettings !== null
        ? deserializeAws_restJson1MapOfMethodSettings(
            output.methodSettings,
            context
          )
        : undefined,
    stageName:
      output.stageName !== undefined && output.stageName !== null
        ? output.stageName
        : undefined,
    tags:
      output.tags !== undefined && output.tags !== null
        ? deserializeAws_restJson1MapOfStringToString(output.tags, context)
        : undefined,
    tracingEnabled:
      output.tracingEnabled !== undefined && output.tracingEnabled !== null
        ? output.tracingEnabled
        : undefined,
    variables:
      output.variables !== undefined && output.variables !== null
        ? deserializeAws_restJson1MapOfStringToString(output.variables, context)
        : undefined,
    webAclArn:
      output.webAclArn !== undefined && output.webAclArn !== null
        ? output.webAclArn
        : undefined
  } as any;
};

const deserializeAws_restJson1ThrottleSettings = (
  output: any,
  context: __SerdeContext
): ThrottleSettings => {
  return {
    __type: "ThrottleSettings",
    burstLimit:
      output.burstLimit !== undefined && output.burstLimit !== null
        ? output.burstLimit
        : undefined,
    rateLimit:
      output.rateLimit !== undefined && output.rateLimit !== null
        ? output.rateLimit
        : undefined
  } as any;
};

const deserializeAws_restJson1UsagePlan = (
  output: any,
  context: __SerdeContext
): UsagePlan => {
  return {
    __type: "UsagePlan",
    apiStages:
      output.apiStages !== undefined && output.apiStages !== null
        ? deserializeAws_restJson1ListOfApiStage(output.apiStages, context)
        : undefined,
    description:
      output.description !== undefined && output.description !== null
        ? output.description
        : undefined,
    id: output.id !== undefined && output.id !== null ? output.id : undefined,
    name:
      output.name !== undefined && output.name !== null
        ? output.name
        : undefined,
    productCode:
      output.productCode !== undefined && output.productCode !== null
        ? output.productCode
        : undefined,
    quota:
      output.quota !== undefined && output.quota !== null
        ? deserializeAws_restJson1QuotaSettings(output.quota, context)
        : undefined,
    tags:
      output.tags !== undefined && output.tags !== null
        ? deserializeAws_restJson1MapOfStringToString(output.tags, context)
        : undefined,
    throttle:
      output.throttle !== undefined && output.throttle !== null
        ? deserializeAws_restJson1ThrottleSettings(output.throttle, context)
        : undefined
  } as any;
};

const deserializeAws_restJson1UsagePlanKey = (
  output: any,
  context: __SerdeContext
): UsagePlanKey => {
  return {
    __type: "UsagePlanKey",
    id: output.id !== undefined && output.id !== null ? output.id : undefined,
    name:
      output.name !== undefined && output.name !== null
        ? output.name
        : undefined,
    type:
      output.type !== undefined && output.type !== null
        ? output.type
        : undefined,
    value:
      output.value !== undefined && output.value !== null
        ? output.value
        : undefined
  } as any;
};

const deserializeAws_restJson1VpcLink = (
  output: any,
  context: __SerdeContext
): VpcLink => {
  return {
    __type: "VpcLink",
    description:
      output.description !== undefined && output.description !== null
        ? output.description
        : undefined,
    id: output.id !== undefined && output.id !== null ? output.id : undefined,
    name:
      output.name !== undefined && output.name !== null
        ? output.name
        : undefined,
    status:
      output.status !== undefined && output.status !== null
        ? output.status
        : undefined,
    statusMessage:
      output.statusMessage !== undefined && output.statusMessage !== null
        ? output.statusMessage
        : undefined,
    tags:
      output.tags !== undefined && output.tags !== null
        ? deserializeAws_restJson1MapOfStringToString(output.tags, context)
        : undefined,
    targetArns:
      output.targetArns !== undefined && output.targetArns !== null
        ? deserializeAws_restJson1ListOfString(output.targetArns, context)
        : undefined
  } as any;
};

const deserializeMetadata = (output: __HttpResponse): __ResponseMetadata => ({
  httpStatusCode: output.statusCode,
  httpHeaders: output.headers,
  requestId: output.headers["x-amzn-requestid"]
});

// Collect low-level response body stream to Uint8Array.
const collectBody = (
  streamBody: any = new Uint8Array(),
  context: __SerdeContext
): Promise<Uint8Array> => {
  if (streamBody instanceof Uint8Array) {
    return Promise.resolve(streamBody);
  }
  return (
    context.streamCollector(streamBody) || Promise.resolve(new Uint8Array())
  );
};

// Encode Uint8Array data into string with utf-8.
const collectBodyString = (
  streamBody: any,
  context: __SerdeContext
): Promise<string> =>
  collectBody(streamBody, context).then(body => context.utf8Encoder(body));

const isSerializableHeaderValue = (value: any): boolean =>
  value !== undefined &&
  value !== "" &&
  (!Object.getOwnPropertyNames(value).includes("length") ||
    value.length != 0) &&
  (!Object.getOwnPropertyNames(value).includes("size") || value.size != 0);

const parseBody = (streamBody: any, context: __SerdeContext): any =>
  collectBodyString(streamBody, context).then(encoded => {
    if (encoded.length) {
      return JSON.parse(encoded);
    }
    return {};
  });

/**
 * Load an error code for the aws.rest-json-1.1 protocol.
 */
const loadRestJsonErrorCode = (output: __HttpResponse, data: any): string => {
  const findKey = (object: any, key: string) =>
    Object.keys(object).find(k => k.toLowerCase() === key.toLowerCase());

  const sanitizeErrorCode = (rawValue: string): string => {
    let cleanValue = rawValue;
    if (cleanValue.indexOf(":") >= 0) {
      cleanValue = cleanValue.split(":")[0];
    }
    if (cleanValue.indexOf("#") >= 0) {
      cleanValue = cleanValue.split("#")[1];
    }
    return cleanValue;
  };

  const headerKey = findKey(output.headers, "x-amzn-errortype");
  if (headerKey !== undefined) {
    return sanitizeErrorCode(output.headers[headerKey]);
  }

  if (data.code !== undefined) {
    return sanitizeErrorCode(data.code);
  }

  if (data["__type"] !== undefined) {
    return sanitizeErrorCode(data["__type"]);
  }

  return "";
};
