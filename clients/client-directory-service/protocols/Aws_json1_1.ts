import {
  AcceptSharedDirectoryCommandInput,
  AcceptSharedDirectoryCommandOutput
} from "../commands/AcceptSharedDirectoryCommand";
import {
  AddIpRoutesCommandInput,
  AddIpRoutesCommandOutput
} from "../commands/AddIpRoutesCommand";
import {
  AddTagsToResourceCommandInput,
  AddTagsToResourceCommandOutput
} from "../commands/AddTagsToResourceCommand";
import {
  CancelSchemaExtensionCommandInput,
  CancelSchemaExtensionCommandOutput
} from "../commands/CancelSchemaExtensionCommand";
import {
  ConnectDirectoryCommandInput,
  ConnectDirectoryCommandOutput
} from "../commands/ConnectDirectoryCommand";
import {
  CreateAliasCommandInput,
  CreateAliasCommandOutput
} from "../commands/CreateAliasCommand";
import {
  CreateComputerCommandInput,
  CreateComputerCommandOutput
} from "../commands/CreateComputerCommand";
import {
  CreateConditionalForwarderCommandInput,
  CreateConditionalForwarderCommandOutput
} from "../commands/CreateConditionalForwarderCommand";
import {
  CreateDirectoryCommandInput,
  CreateDirectoryCommandOutput
} from "../commands/CreateDirectoryCommand";
import {
  CreateLogSubscriptionCommandInput,
  CreateLogSubscriptionCommandOutput
} from "../commands/CreateLogSubscriptionCommand";
import {
  CreateMicrosoftADCommandInput,
  CreateMicrosoftADCommandOutput
} from "../commands/CreateMicrosoftADCommand";
import {
  CreateSnapshotCommandInput,
  CreateSnapshotCommandOutput
} from "../commands/CreateSnapshotCommand";
import {
  CreateTrustCommandInput,
  CreateTrustCommandOutput
} from "../commands/CreateTrustCommand";
import {
  DeleteConditionalForwarderCommandInput,
  DeleteConditionalForwarderCommandOutput
} from "../commands/DeleteConditionalForwarderCommand";
import {
  DeleteDirectoryCommandInput,
  DeleteDirectoryCommandOutput
} from "../commands/DeleteDirectoryCommand";
import {
  DeleteLogSubscriptionCommandInput,
  DeleteLogSubscriptionCommandOutput
} from "../commands/DeleteLogSubscriptionCommand";
import {
  DeleteSnapshotCommandInput,
  DeleteSnapshotCommandOutput
} from "../commands/DeleteSnapshotCommand";
import {
  DeleteTrustCommandInput,
  DeleteTrustCommandOutput
} from "../commands/DeleteTrustCommand";
import {
  DeregisterCertificateCommandInput,
  DeregisterCertificateCommandOutput
} from "../commands/DeregisterCertificateCommand";
import {
  DeregisterEventTopicCommandInput,
  DeregisterEventTopicCommandOutput
} from "../commands/DeregisterEventTopicCommand";
import {
  DescribeCertificateCommandInput,
  DescribeCertificateCommandOutput
} from "../commands/DescribeCertificateCommand";
import {
  DescribeConditionalForwardersCommandInput,
  DescribeConditionalForwardersCommandOutput
} from "../commands/DescribeConditionalForwardersCommand";
import {
  DescribeDirectoriesCommandInput,
  DescribeDirectoriesCommandOutput
} from "../commands/DescribeDirectoriesCommand";
import {
  DescribeDomainControllersCommandInput,
  DescribeDomainControllersCommandOutput
} from "../commands/DescribeDomainControllersCommand";
import {
  DescribeEventTopicsCommandInput,
  DescribeEventTopicsCommandOutput
} from "../commands/DescribeEventTopicsCommand";
import {
  DescribeLDAPSSettingsCommandInput,
  DescribeLDAPSSettingsCommandOutput
} from "../commands/DescribeLDAPSSettingsCommand";
import {
  DescribeSharedDirectoriesCommandInput,
  DescribeSharedDirectoriesCommandOutput
} from "../commands/DescribeSharedDirectoriesCommand";
import {
  DescribeSnapshotsCommandInput,
  DescribeSnapshotsCommandOutput
} from "../commands/DescribeSnapshotsCommand";
import {
  DescribeTrustsCommandInput,
  DescribeTrustsCommandOutput
} from "../commands/DescribeTrustsCommand";
import {
  DisableLDAPSCommandInput,
  DisableLDAPSCommandOutput
} from "../commands/DisableLDAPSCommand";
import {
  DisableRadiusCommandInput,
  DisableRadiusCommandOutput
} from "../commands/DisableRadiusCommand";
import {
  DisableSsoCommandInput,
  DisableSsoCommandOutput
} from "../commands/DisableSsoCommand";
import {
  EnableLDAPSCommandInput,
  EnableLDAPSCommandOutput
} from "../commands/EnableLDAPSCommand";
import {
  EnableRadiusCommandInput,
  EnableRadiusCommandOutput
} from "../commands/EnableRadiusCommand";
import {
  EnableSsoCommandInput,
  EnableSsoCommandOutput
} from "../commands/EnableSsoCommand";
import {
  GetDirectoryLimitsCommandInput,
  GetDirectoryLimitsCommandOutput
} from "../commands/GetDirectoryLimitsCommand";
import {
  GetSnapshotLimitsCommandInput,
  GetSnapshotLimitsCommandOutput
} from "../commands/GetSnapshotLimitsCommand";
import {
  ListCertificatesCommandInput,
  ListCertificatesCommandOutput
} from "../commands/ListCertificatesCommand";
import {
  ListIpRoutesCommandInput,
  ListIpRoutesCommandOutput
} from "../commands/ListIpRoutesCommand";
import {
  ListLogSubscriptionsCommandInput,
  ListLogSubscriptionsCommandOutput
} from "../commands/ListLogSubscriptionsCommand";
import {
  ListSchemaExtensionsCommandInput,
  ListSchemaExtensionsCommandOutput
} from "../commands/ListSchemaExtensionsCommand";
import {
  ListTagsForResourceCommandInput,
  ListTagsForResourceCommandOutput
} from "../commands/ListTagsForResourceCommand";
import {
  RegisterCertificateCommandInput,
  RegisterCertificateCommandOutput
} from "../commands/RegisterCertificateCommand";
import {
  RegisterEventTopicCommandInput,
  RegisterEventTopicCommandOutput
} from "../commands/RegisterEventTopicCommand";
import {
  RejectSharedDirectoryCommandInput,
  RejectSharedDirectoryCommandOutput
} from "../commands/RejectSharedDirectoryCommand";
import {
  RemoveIpRoutesCommandInput,
  RemoveIpRoutesCommandOutput
} from "../commands/RemoveIpRoutesCommand";
import {
  RemoveTagsFromResourceCommandInput,
  RemoveTagsFromResourceCommandOutput
} from "../commands/RemoveTagsFromResourceCommand";
import {
  ResetUserPasswordCommandInput,
  ResetUserPasswordCommandOutput
} from "../commands/ResetUserPasswordCommand";
import {
  RestoreFromSnapshotCommandInput,
  RestoreFromSnapshotCommandOutput
} from "../commands/RestoreFromSnapshotCommand";
import {
  ShareDirectoryCommandInput,
  ShareDirectoryCommandOutput
} from "../commands/ShareDirectoryCommand";
import {
  StartSchemaExtensionCommandInput,
  StartSchemaExtensionCommandOutput
} from "../commands/StartSchemaExtensionCommand";
import {
  UnshareDirectoryCommandInput,
  UnshareDirectoryCommandOutput
} from "../commands/UnshareDirectoryCommand";
import {
  UpdateConditionalForwarderCommandInput,
  UpdateConditionalForwarderCommandOutput
} from "../commands/UpdateConditionalForwarderCommand";
import {
  UpdateNumberOfDomainControllersCommandInput,
  UpdateNumberOfDomainControllersCommandOutput
} from "../commands/UpdateNumberOfDomainControllersCommand";
import {
  UpdateRadiusCommandInput,
  UpdateRadiusCommandOutput
} from "../commands/UpdateRadiusCommand";
import {
  UpdateTrustCommandInput,
  UpdateTrustCommandOutput
} from "../commands/UpdateTrustCommand";
import {
  VerifyTrustCommandInput,
  VerifyTrustCommandOutput
} from "../commands/VerifyTrustCommand";
import {
  AcceptSharedDirectoryRequest,
  AcceptSharedDirectoryResult,
  AccessDeniedException,
  AddIpRoutesRequest,
  AddIpRoutesResult,
  AddTagsToResourceRequest,
  AddTagsToResourceResult,
  Attribute,
  AuthenticationFailedException,
  CancelSchemaExtensionRequest,
  CancelSchemaExtensionResult,
  Certificate,
  CertificateAlreadyExistsException,
  CertificateDoesNotExistException,
  CertificateInUseException,
  CertificateInfo,
  CertificateLimitExceededException,
  ClientException,
  Computer,
  ConditionalForwarder,
  ConnectDirectoryRequest,
  ConnectDirectoryResult,
  CreateAliasRequest,
  CreateAliasResult,
  CreateComputerRequest,
  CreateComputerResult,
  CreateConditionalForwarderRequest,
  CreateConditionalForwarderResult,
  CreateDirectoryRequest,
  CreateDirectoryResult,
  CreateLogSubscriptionRequest,
  CreateLogSubscriptionResult,
  CreateMicrosoftADRequest,
  CreateMicrosoftADResult,
  CreateSnapshotRequest,
  CreateSnapshotResult,
  CreateTrustRequest,
  CreateTrustResult,
  DeleteConditionalForwarderRequest,
  DeleteConditionalForwarderResult,
  DeleteDirectoryRequest,
  DeleteDirectoryResult,
  DeleteLogSubscriptionRequest,
  DeleteLogSubscriptionResult,
  DeleteSnapshotRequest,
  DeleteSnapshotResult,
  DeleteTrustRequest,
  DeleteTrustResult,
  DeregisterCertificateRequest,
  DeregisterCertificateResult,
  DeregisterEventTopicRequest,
  DeregisterEventTopicResult,
  DescribeCertificateRequest,
  DescribeCertificateResult,
  DescribeConditionalForwardersRequest,
  DescribeConditionalForwardersResult,
  DescribeDirectoriesRequest,
  DescribeDirectoriesResult,
  DescribeDomainControllersRequest,
  DescribeDomainControllersResult,
  DescribeEventTopicsRequest,
  DescribeEventTopicsResult,
  DescribeLDAPSSettingsRequest,
  DescribeLDAPSSettingsResult,
  DescribeSharedDirectoriesRequest,
  DescribeSharedDirectoriesResult,
  DescribeSnapshotsRequest,
  DescribeSnapshotsResult,
  DescribeTrustsRequest,
  DescribeTrustsResult,
  DirectoryAlreadySharedException,
  DirectoryConnectSettings,
  DirectoryConnectSettingsDescription,
  DirectoryDescription,
  DirectoryDoesNotExistException,
  DirectoryLimitExceededException,
  DirectoryLimits,
  DirectoryNotSharedException,
  DirectoryUnavailableException,
  DirectoryVpcSettings,
  DirectoryVpcSettingsDescription,
  DisableLDAPSRequest,
  DisableLDAPSResult,
  DisableRadiusRequest,
  DisableRadiusResult,
  DisableSsoRequest,
  DisableSsoResult,
  DomainController,
  DomainControllerLimitExceededException,
  EnableLDAPSRequest,
  EnableLDAPSResult,
  EnableRadiusRequest,
  EnableRadiusResult,
  EnableSsoRequest,
  EnableSsoResult,
  EntityAlreadyExistsException,
  EntityDoesNotExistException,
  EventTopic,
  GetDirectoryLimitsRequest,
  GetDirectoryLimitsResult,
  GetSnapshotLimitsRequest,
  GetSnapshotLimitsResult,
  InsufficientPermissionsException,
  InvalidCertificateException,
  InvalidLDAPSStatusException,
  InvalidNextTokenException,
  InvalidParameterException,
  InvalidPasswordException,
  InvalidTargetException,
  IpRoute,
  IpRouteInfo,
  IpRouteLimitExceededException,
  LDAPSSettingInfo,
  ListCertificatesRequest,
  ListCertificatesResult,
  ListIpRoutesRequest,
  ListIpRoutesResult,
  ListLogSubscriptionsRequest,
  ListLogSubscriptionsResult,
  ListSchemaExtensionsRequest,
  ListSchemaExtensionsResult,
  ListTagsForResourceRequest,
  ListTagsForResourceResult,
  LogSubscription,
  NoAvailableCertificateException,
  OrganizationsException,
  OwnerDirectoryDescription,
  RadiusSettings,
  RegisterCertificateRequest,
  RegisterCertificateResult,
  RegisterEventTopicRequest,
  RegisterEventTopicResult,
  RejectSharedDirectoryRequest,
  RejectSharedDirectoryResult,
  RemoveIpRoutesRequest,
  RemoveIpRoutesResult,
  RemoveTagsFromResourceRequest,
  RemoveTagsFromResourceResult,
  ResetUserPasswordRequest,
  ResetUserPasswordResult,
  RestoreFromSnapshotRequest,
  RestoreFromSnapshotResult,
  SchemaExtensionInfo,
  ServiceException,
  ShareDirectoryRequest,
  ShareDirectoryResult,
  ShareLimitExceededException,
  ShareTarget,
  SharedDirectory,
  Snapshot,
  SnapshotLimitExceededException,
  SnapshotLimits,
  StartSchemaExtensionRequest,
  StartSchemaExtensionResult,
  Tag,
  TagLimitExceededException,
  Trust,
  UnshareDirectoryRequest,
  UnshareDirectoryResult,
  UnshareTarget,
  UnsupportedOperationException,
  UpdateConditionalForwarderRequest,
  UpdateConditionalForwarderResult,
  UpdateNumberOfDomainControllersRequest,
  UpdateNumberOfDomainControllersResult,
  UpdateRadiusRequest,
  UpdateRadiusResult,
  UpdateTrustRequest,
  UpdateTrustResult,
  UserDoesNotExistException,
  VerifyTrustRequest,
  VerifyTrustResult
} from "../models/index";
import {
  HttpRequest as __HttpRequest,
  HttpResponse as __HttpResponse
} from "@aws-sdk/protocol-http";
import { SmithyException as __SmithyException } from "@aws-sdk/smithy-client";
import {
  Endpoint as __Endpoint,
  HeaderBag as __HeaderBag,
  MetadataBearer as __MetadataBearer,
  ResponseMetadata as __ResponseMetadata,
  SerdeContext as __SerdeContext
} from "@aws-sdk/types";

export async function serializeAws_json1_1AcceptSharedDirectoryCommand(
  input: AcceptSharedDirectoryCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "DirectoryService_20150416.AcceptSharedDirectory";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1AcceptSharedDirectoryRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1AddIpRoutesCommand(
  input: AddIpRoutesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "DirectoryService_20150416.AddIpRoutes";
  let body: any;
  body = JSON.stringify(serializeAws_json1_1AddIpRoutesRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1AddTagsToResourceCommand(
  input: AddTagsToResourceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "DirectoryService_20150416.AddTagsToResource";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1AddTagsToResourceRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1CancelSchemaExtensionCommand(
  input: CancelSchemaExtensionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "DirectoryService_20150416.CancelSchemaExtension";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1CancelSchemaExtensionRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1ConnectDirectoryCommand(
  input: ConnectDirectoryCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "DirectoryService_20150416.ConnectDirectory";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1ConnectDirectoryRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1CreateAliasCommand(
  input: CreateAliasCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "DirectoryService_20150416.CreateAlias";
  let body: any;
  body = JSON.stringify(serializeAws_json1_1CreateAliasRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1CreateComputerCommand(
  input: CreateComputerCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "DirectoryService_20150416.CreateComputer";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1CreateComputerRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1CreateConditionalForwarderCommand(
  input: CreateConditionalForwarderCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] =
    "DirectoryService_20150416.CreateConditionalForwarder";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1CreateConditionalForwarderRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1CreateDirectoryCommand(
  input: CreateDirectoryCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "DirectoryService_20150416.CreateDirectory";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1CreateDirectoryRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1CreateLogSubscriptionCommand(
  input: CreateLogSubscriptionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "DirectoryService_20150416.CreateLogSubscription";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1CreateLogSubscriptionRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1CreateMicrosoftADCommand(
  input: CreateMicrosoftADCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "DirectoryService_20150416.CreateMicrosoftAD";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1CreateMicrosoftADRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1CreateSnapshotCommand(
  input: CreateSnapshotCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "DirectoryService_20150416.CreateSnapshot";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1CreateSnapshotRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1CreateTrustCommand(
  input: CreateTrustCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "DirectoryService_20150416.CreateTrust";
  let body: any;
  body = JSON.stringify(serializeAws_json1_1CreateTrustRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DeleteConditionalForwarderCommand(
  input: DeleteConditionalForwarderCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] =
    "DirectoryService_20150416.DeleteConditionalForwarder";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DeleteConditionalForwarderRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DeleteDirectoryCommand(
  input: DeleteDirectoryCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "DirectoryService_20150416.DeleteDirectory";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DeleteDirectoryRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DeleteLogSubscriptionCommand(
  input: DeleteLogSubscriptionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "DirectoryService_20150416.DeleteLogSubscription";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DeleteLogSubscriptionRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DeleteSnapshotCommand(
  input: DeleteSnapshotCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "DirectoryService_20150416.DeleteSnapshot";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DeleteSnapshotRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DeleteTrustCommand(
  input: DeleteTrustCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "DirectoryService_20150416.DeleteTrust";
  let body: any;
  body = JSON.stringify(serializeAws_json1_1DeleteTrustRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DeregisterCertificateCommand(
  input: DeregisterCertificateCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "DirectoryService_20150416.DeregisterCertificate";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DeregisterCertificateRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DeregisterEventTopicCommand(
  input: DeregisterEventTopicCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "DirectoryService_20150416.DeregisterEventTopic";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DeregisterEventTopicRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DescribeCertificateCommand(
  input: DescribeCertificateCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "DirectoryService_20150416.DescribeCertificate";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeCertificateRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DescribeConditionalForwardersCommand(
  input: DescribeConditionalForwardersCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] =
    "DirectoryService_20150416.DescribeConditionalForwarders";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeConditionalForwardersRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DescribeDirectoriesCommand(
  input: DescribeDirectoriesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "DirectoryService_20150416.DescribeDirectories";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeDirectoriesRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DescribeDomainControllersCommand(
  input: DescribeDomainControllersCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] =
    "DirectoryService_20150416.DescribeDomainControllers";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeDomainControllersRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DescribeEventTopicsCommand(
  input: DescribeEventTopicsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "DirectoryService_20150416.DescribeEventTopics";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeEventTopicsRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DescribeLDAPSSettingsCommand(
  input: DescribeLDAPSSettingsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "DirectoryService_20150416.DescribeLDAPSSettings";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeLDAPSSettingsRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DescribeSharedDirectoriesCommand(
  input: DescribeSharedDirectoriesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] =
    "DirectoryService_20150416.DescribeSharedDirectories";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeSharedDirectoriesRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DescribeSnapshotsCommand(
  input: DescribeSnapshotsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "DirectoryService_20150416.DescribeSnapshots";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeSnapshotsRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DescribeTrustsCommand(
  input: DescribeTrustsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "DirectoryService_20150416.DescribeTrusts";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeTrustsRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DisableLDAPSCommand(
  input: DisableLDAPSCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "DirectoryService_20150416.DisableLDAPS";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DisableLDAPSRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DisableRadiusCommand(
  input: DisableRadiusCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "DirectoryService_20150416.DisableRadius";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DisableRadiusRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DisableSsoCommand(
  input: DisableSsoCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "DirectoryService_20150416.DisableSso";
  let body: any;
  body = JSON.stringify(serializeAws_json1_1DisableSsoRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1EnableLDAPSCommand(
  input: EnableLDAPSCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "DirectoryService_20150416.EnableLDAPS";
  let body: any;
  body = JSON.stringify(serializeAws_json1_1EnableLDAPSRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1EnableRadiusCommand(
  input: EnableRadiusCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "DirectoryService_20150416.EnableRadius";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1EnableRadiusRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1EnableSsoCommand(
  input: EnableSsoCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "DirectoryService_20150416.EnableSso";
  let body: any;
  body = JSON.stringify(serializeAws_json1_1EnableSsoRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1GetDirectoryLimitsCommand(
  input: GetDirectoryLimitsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "DirectoryService_20150416.GetDirectoryLimits";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1GetDirectoryLimitsRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1GetSnapshotLimitsCommand(
  input: GetSnapshotLimitsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "DirectoryService_20150416.GetSnapshotLimits";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1GetSnapshotLimitsRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1ListCertificatesCommand(
  input: ListCertificatesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "DirectoryService_20150416.ListCertificates";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1ListCertificatesRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1ListIpRoutesCommand(
  input: ListIpRoutesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "DirectoryService_20150416.ListIpRoutes";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1ListIpRoutesRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1ListLogSubscriptionsCommand(
  input: ListLogSubscriptionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "DirectoryService_20150416.ListLogSubscriptions";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1ListLogSubscriptionsRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1ListSchemaExtensionsCommand(
  input: ListSchemaExtensionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "DirectoryService_20150416.ListSchemaExtensions";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1ListSchemaExtensionsRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1ListTagsForResourceCommand(
  input: ListTagsForResourceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "DirectoryService_20150416.ListTagsForResource";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1ListTagsForResourceRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1RegisterCertificateCommand(
  input: RegisterCertificateCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "DirectoryService_20150416.RegisterCertificate";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1RegisterCertificateRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1RegisterEventTopicCommand(
  input: RegisterEventTopicCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "DirectoryService_20150416.RegisterEventTopic";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1RegisterEventTopicRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1RejectSharedDirectoryCommand(
  input: RejectSharedDirectoryCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "DirectoryService_20150416.RejectSharedDirectory";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1RejectSharedDirectoryRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1RemoveIpRoutesCommand(
  input: RemoveIpRoutesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "DirectoryService_20150416.RemoveIpRoutes";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1RemoveIpRoutesRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1RemoveTagsFromResourceCommand(
  input: RemoveTagsFromResourceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "DirectoryService_20150416.RemoveTagsFromResource";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1RemoveTagsFromResourceRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1ResetUserPasswordCommand(
  input: ResetUserPasswordCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "DirectoryService_20150416.ResetUserPassword";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1ResetUserPasswordRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1RestoreFromSnapshotCommand(
  input: RestoreFromSnapshotCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "DirectoryService_20150416.RestoreFromSnapshot";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1RestoreFromSnapshotRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1ShareDirectoryCommand(
  input: ShareDirectoryCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "DirectoryService_20150416.ShareDirectory";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1ShareDirectoryRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1StartSchemaExtensionCommand(
  input: StartSchemaExtensionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "DirectoryService_20150416.StartSchemaExtension";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1StartSchemaExtensionRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1UnshareDirectoryCommand(
  input: UnshareDirectoryCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "DirectoryService_20150416.UnshareDirectory";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1UnshareDirectoryRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1UpdateConditionalForwarderCommand(
  input: UpdateConditionalForwarderCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] =
    "DirectoryService_20150416.UpdateConditionalForwarder";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1UpdateConditionalForwarderRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1UpdateNumberOfDomainControllersCommand(
  input: UpdateNumberOfDomainControllersCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] =
    "DirectoryService_20150416.UpdateNumberOfDomainControllers";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1UpdateNumberOfDomainControllersRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1UpdateRadiusCommand(
  input: UpdateRadiusCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "DirectoryService_20150416.UpdateRadius";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1UpdateRadiusRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1UpdateTrustCommand(
  input: UpdateTrustCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "DirectoryService_20150416.UpdateTrust";
  let body: any;
  body = JSON.stringify(serializeAws_json1_1UpdateTrustRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1VerifyTrustCommand(
  input: VerifyTrustCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "DirectoryService_20150416.VerifyTrust";
  let body: any;
  body = JSON.stringify(serializeAws_json1_1VerifyTrustRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function deserializeAws_json1_1AcceptSharedDirectoryCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AcceptSharedDirectoryCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1AcceptSharedDirectoryCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1AcceptSharedDirectoryResult(data, context);
  const response: AcceptSharedDirectoryCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "AcceptSharedDirectoryResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1AcceptSharedDirectoryCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AcceptSharedDirectoryCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ClientException":
    case "com.amazonaws.directoryservice.v20150416#ClientException":
      response = await deserializeAws_json1_1ClientExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "DirectoryAlreadySharedException":
    case "com.amazonaws.directoryservice.v20150416#DirectoryAlreadySharedException":
      response = await deserializeAws_json1_1DirectoryAlreadySharedExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "EntityDoesNotExistException":
    case "com.amazonaws.directoryservice.v20150416#EntityDoesNotExistException":
      response = await deserializeAws_json1_1EntityDoesNotExistExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidParameterException":
    case "com.amazonaws.directoryservice.v20150416#InvalidParameterException":
      response = await deserializeAws_json1_1InvalidParameterExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "ServiceException":
    case "com.amazonaws.directoryservice.v20150416#ServiceException":
      response = await deserializeAws_json1_1ServiceExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1AddIpRoutesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AddIpRoutesCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1AddIpRoutesCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1AddIpRoutesResult(data, context);
  const response: AddIpRoutesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "AddIpRoutesResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1AddIpRoutesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AddIpRoutesCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ClientException":
    case "com.amazonaws.directoryservice.v20150416#ClientException":
      response = await deserializeAws_json1_1ClientExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "DirectoryUnavailableException":
    case "com.amazonaws.directoryservice.v20150416#DirectoryUnavailableException":
      response = await deserializeAws_json1_1DirectoryUnavailableExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "EntityAlreadyExistsException":
    case "com.amazonaws.directoryservice.v20150416#EntityAlreadyExistsException":
      response = await deserializeAws_json1_1EntityAlreadyExistsExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "EntityDoesNotExistException":
    case "com.amazonaws.directoryservice.v20150416#EntityDoesNotExistException":
      response = await deserializeAws_json1_1EntityDoesNotExistExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidParameterException":
    case "com.amazonaws.directoryservice.v20150416#InvalidParameterException":
      response = await deserializeAws_json1_1InvalidParameterExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "IpRouteLimitExceededException":
    case "com.amazonaws.directoryservice.v20150416#IpRouteLimitExceededException":
      response = await deserializeAws_json1_1IpRouteLimitExceededExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "ServiceException":
    case "com.amazonaws.directoryservice.v20150416#ServiceException":
      response = await deserializeAws_json1_1ServiceExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1AddTagsToResourceCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AddTagsToResourceCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1AddTagsToResourceCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1AddTagsToResourceResult(data, context);
  const response: AddTagsToResourceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "AddTagsToResourceResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1AddTagsToResourceCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AddTagsToResourceCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ClientException":
    case "com.amazonaws.directoryservice.v20150416#ClientException":
      response = await deserializeAws_json1_1ClientExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "EntityDoesNotExistException":
    case "com.amazonaws.directoryservice.v20150416#EntityDoesNotExistException":
      response = await deserializeAws_json1_1EntityDoesNotExistExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidParameterException":
    case "com.amazonaws.directoryservice.v20150416#InvalidParameterException":
      response = await deserializeAws_json1_1InvalidParameterExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "ServiceException":
    case "com.amazonaws.directoryservice.v20150416#ServiceException":
      response = await deserializeAws_json1_1ServiceExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "TagLimitExceededException":
    case "com.amazonaws.directoryservice.v20150416#TagLimitExceededException":
      response = await deserializeAws_json1_1TagLimitExceededExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CancelSchemaExtensionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CancelSchemaExtensionCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CancelSchemaExtensionCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CancelSchemaExtensionResult(data, context);
  const response: CancelSchemaExtensionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CancelSchemaExtensionResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CancelSchemaExtensionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CancelSchemaExtensionCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ClientException":
    case "com.amazonaws.directoryservice.v20150416#ClientException":
      response = await deserializeAws_json1_1ClientExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "EntityDoesNotExistException":
    case "com.amazonaws.directoryservice.v20150416#EntityDoesNotExistException":
      response = await deserializeAws_json1_1EntityDoesNotExistExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "ServiceException":
    case "com.amazonaws.directoryservice.v20150416#ServiceException":
      response = await deserializeAws_json1_1ServiceExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ConnectDirectoryCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ConnectDirectoryCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ConnectDirectoryCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ConnectDirectoryResult(data, context);
  const response: ConnectDirectoryCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ConnectDirectoryResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ConnectDirectoryCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ConnectDirectoryCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ClientException":
    case "com.amazonaws.directoryservice.v20150416#ClientException":
      response = await deserializeAws_json1_1ClientExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "DirectoryLimitExceededException":
    case "com.amazonaws.directoryservice.v20150416#DirectoryLimitExceededException":
      response = await deserializeAws_json1_1DirectoryLimitExceededExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidParameterException":
    case "com.amazonaws.directoryservice.v20150416#InvalidParameterException":
      response = await deserializeAws_json1_1InvalidParameterExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "ServiceException":
    case "com.amazonaws.directoryservice.v20150416#ServiceException":
      response = await deserializeAws_json1_1ServiceExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreateAliasCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateAliasCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateAliasCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateAliasResult(data, context);
  const response: CreateAliasCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateAliasResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateAliasCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateAliasCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ClientException":
    case "com.amazonaws.directoryservice.v20150416#ClientException":
      response = await deserializeAws_json1_1ClientExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "EntityAlreadyExistsException":
    case "com.amazonaws.directoryservice.v20150416#EntityAlreadyExistsException":
      response = await deserializeAws_json1_1EntityAlreadyExistsExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "EntityDoesNotExistException":
    case "com.amazonaws.directoryservice.v20150416#EntityDoesNotExistException":
      response = await deserializeAws_json1_1EntityDoesNotExistExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidParameterException":
    case "com.amazonaws.directoryservice.v20150416#InvalidParameterException":
      response = await deserializeAws_json1_1InvalidParameterExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "ServiceException":
    case "com.amazonaws.directoryservice.v20150416#ServiceException":
      response = await deserializeAws_json1_1ServiceExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreateComputerCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateComputerCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateComputerCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateComputerResult(data, context);
  const response: CreateComputerCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateComputerResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateComputerCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateComputerCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "AuthenticationFailedException":
    case "com.amazonaws.directoryservice.v20150416#AuthenticationFailedException":
      response = await deserializeAws_json1_1AuthenticationFailedExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "ClientException":
    case "com.amazonaws.directoryservice.v20150416#ClientException":
      response = await deserializeAws_json1_1ClientExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "DirectoryUnavailableException":
    case "com.amazonaws.directoryservice.v20150416#DirectoryUnavailableException":
      response = await deserializeAws_json1_1DirectoryUnavailableExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "EntityAlreadyExistsException":
    case "com.amazonaws.directoryservice.v20150416#EntityAlreadyExistsException":
      response = await deserializeAws_json1_1EntityAlreadyExistsExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "EntityDoesNotExistException":
    case "com.amazonaws.directoryservice.v20150416#EntityDoesNotExistException":
      response = await deserializeAws_json1_1EntityDoesNotExistExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidParameterException":
    case "com.amazonaws.directoryservice.v20150416#InvalidParameterException":
      response = await deserializeAws_json1_1InvalidParameterExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "ServiceException":
    case "com.amazonaws.directoryservice.v20150416#ServiceException":
      response = await deserializeAws_json1_1ServiceExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "UnsupportedOperationException":
    case "com.amazonaws.directoryservice.v20150416#UnsupportedOperationException":
      response = await deserializeAws_json1_1UnsupportedOperationExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreateConditionalForwarderCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateConditionalForwarderCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateConditionalForwarderCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateConditionalForwarderResult(
    data,
    context
  );
  const response: CreateConditionalForwarderCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateConditionalForwarderResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateConditionalForwarderCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateConditionalForwarderCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ClientException":
    case "com.amazonaws.directoryservice.v20150416#ClientException":
      response = await deserializeAws_json1_1ClientExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "DirectoryUnavailableException":
    case "com.amazonaws.directoryservice.v20150416#DirectoryUnavailableException":
      response = await deserializeAws_json1_1DirectoryUnavailableExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "EntityAlreadyExistsException":
    case "com.amazonaws.directoryservice.v20150416#EntityAlreadyExistsException":
      response = await deserializeAws_json1_1EntityAlreadyExistsExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "EntityDoesNotExistException":
    case "com.amazonaws.directoryservice.v20150416#EntityDoesNotExistException":
      response = await deserializeAws_json1_1EntityDoesNotExistExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidParameterException":
    case "com.amazonaws.directoryservice.v20150416#InvalidParameterException":
      response = await deserializeAws_json1_1InvalidParameterExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "ServiceException":
    case "com.amazonaws.directoryservice.v20150416#ServiceException":
      response = await deserializeAws_json1_1ServiceExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "UnsupportedOperationException":
    case "com.amazonaws.directoryservice.v20150416#UnsupportedOperationException":
      response = await deserializeAws_json1_1UnsupportedOperationExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreateDirectoryCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDirectoryCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateDirectoryCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateDirectoryResult(data, context);
  const response: CreateDirectoryCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateDirectoryResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateDirectoryCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDirectoryCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ClientException":
    case "com.amazonaws.directoryservice.v20150416#ClientException":
      response = await deserializeAws_json1_1ClientExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "DirectoryLimitExceededException":
    case "com.amazonaws.directoryservice.v20150416#DirectoryLimitExceededException":
      response = await deserializeAws_json1_1DirectoryLimitExceededExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidParameterException":
    case "com.amazonaws.directoryservice.v20150416#InvalidParameterException":
      response = await deserializeAws_json1_1InvalidParameterExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "ServiceException":
    case "com.amazonaws.directoryservice.v20150416#ServiceException":
      response = await deserializeAws_json1_1ServiceExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreateLogSubscriptionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateLogSubscriptionCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateLogSubscriptionCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateLogSubscriptionResult(data, context);
  const response: CreateLogSubscriptionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateLogSubscriptionResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateLogSubscriptionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateLogSubscriptionCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ClientException":
    case "com.amazonaws.directoryservice.v20150416#ClientException":
      response = await deserializeAws_json1_1ClientExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "EntityAlreadyExistsException":
    case "com.amazonaws.directoryservice.v20150416#EntityAlreadyExistsException":
      response = await deserializeAws_json1_1EntityAlreadyExistsExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "EntityDoesNotExistException":
    case "com.amazonaws.directoryservice.v20150416#EntityDoesNotExistException":
      response = await deserializeAws_json1_1EntityDoesNotExistExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InsufficientPermissionsException":
    case "com.amazonaws.directoryservice.v20150416#InsufficientPermissionsException":
      response = await deserializeAws_json1_1InsufficientPermissionsExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "ServiceException":
    case "com.amazonaws.directoryservice.v20150416#ServiceException":
      response = await deserializeAws_json1_1ServiceExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "UnsupportedOperationException":
    case "com.amazonaws.directoryservice.v20150416#UnsupportedOperationException":
      response = await deserializeAws_json1_1UnsupportedOperationExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreateMicrosoftADCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateMicrosoftADCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateMicrosoftADCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateMicrosoftADResult(data, context);
  const response: CreateMicrosoftADCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateMicrosoftADResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateMicrosoftADCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateMicrosoftADCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ClientException":
    case "com.amazonaws.directoryservice.v20150416#ClientException":
      response = await deserializeAws_json1_1ClientExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "DirectoryLimitExceededException":
    case "com.amazonaws.directoryservice.v20150416#DirectoryLimitExceededException":
      response = await deserializeAws_json1_1DirectoryLimitExceededExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidParameterException":
    case "com.amazonaws.directoryservice.v20150416#InvalidParameterException":
      response = await deserializeAws_json1_1InvalidParameterExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "ServiceException":
    case "com.amazonaws.directoryservice.v20150416#ServiceException":
      response = await deserializeAws_json1_1ServiceExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "UnsupportedOperationException":
    case "com.amazonaws.directoryservice.v20150416#UnsupportedOperationException":
      response = await deserializeAws_json1_1UnsupportedOperationExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreateSnapshotCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateSnapshotCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateSnapshotCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateSnapshotResult(data, context);
  const response: CreateSnapshotCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateSnapshotResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateSnapshotCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateSnapshotCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ClientException":
    case "com.amazonaws.directoryservice.v20150416#ClientException":
      response = await deserializeAws_json1_1ClientExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "EntityDoesNotExistException":
    case "com.amazonaws.directoryservice.v20150416#EntityDoesNotExistException":
      response = await deserializeAws_json1_1EntityDoesNotExistExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidParameterException":
    case "com.amazonaws.directoryservice.v20150416#InvalidParameterException":
      response = await deserializeAws_json1_1InvalidParameterExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "ServiceException":
    case "com.amazonaws.directoryservice.v20150416#ServiceException":
      response = await deserializeAws_json1_1ServiceExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "SnapshotLimitExceededException":
    case "com.amazonaws.directoryservice.v20150416#SnapshotLimitExceededException":
      response = await deserializeAws_json1_1SnapshotLimitExceededExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreateTrustCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateTrustCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateTrustCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateTrustResult(data, context);
  const response: CreateTrustCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateTrustResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateTrustCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateTrustCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ClientException":
    case "com.amazonaws.directoryservice.v20150416#ClientException":
      response = await deserializeAws_json1_1ClientExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "EntityAlreadyExistsException":
    case "com.amazonaws.directoryservice.v20150416#EntityAlreadyExistsException":
      response = await deserializeAws_json1_1EntityAlreadyExistsExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "EntityDoesNotExistException":
    case "com.amazonaws.directoryservice.v20150416#EntityDoesNotExistException":
      response = await deserializeAws_json1_1EntityDoesNotExistExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidParameterException":
    case "com.amazonaws.directoryservice.v20150416#InvalidParameterException":
      response = await deserializeAws_json1_1InvalidParameterExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "ServiceException":
    case "com.amazonaws.directoryservice.v20150416#ServiceException":
      response = await deserializeAws_json1_1ServiceExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "UnsupportedOperationException":
    case "com.amazonaws.directoryservice.v20150416#UnsupportedOperationException":
      response = await deserializeAws_json1_1UnsupportedOperationExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeleteConditionalForwarderCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteConditionalForwarderCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteConditionalForwarderCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteConditionalForwarderResult(
    data,
    context
  );
  const response: DeleteConditionalForwarderCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteConditionalForwarderResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteConditionalForwarderCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteConditionalForwarderCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ClientException":
    case "com.amazonaws.directoryservice.v20150416#ClientException":
      response = await deserializeAws_json1_1ClientExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "DirectoryUnavailableException":
    case "com.amazonaws.directoryservice.v20150416#DirectoryUnavailableException":
      response = await deserializeAws_json1_1DirectoryUnavailableExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "EntityDoesNotExistException":
    case "com.amazonaws.directoryservice.v20150416#EntityDoesNotExistException":
      response = await deserializeAws_json1_1EntityDoesNotExistExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidParameterException":
    case "com.amazonaws.directoryservice.v20150416#InvalidParameterException":
      response = await deserializeAws_json1_1InvalidParameterExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "ServiceException":
    case "com.amazonaws.directoryservice.v20150416#ServiceException":
      response = await deserializeAws_json1_1ServiceExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "UnsupportedOperationException":
    case "com.amazonaws.directoryservice.v20150416#UnsupportedOperationException":
      response = await deserializeAws_json1_1UnsupportedOperationExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeleteDirectoryCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteDirectoryCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteDirectoryCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteDirectoryResult(data, context);
  const response: DeleteDirectoryCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteDirectoryResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteDirectoryCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteDirectoryCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ClientException":
    case "com.amazonaws.directoryservice.v20150416#ClientException":
      response = await deserializeAws_json1_1ClientExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "EntityDoesNotExistException":
    case "com.amazonaws.directoryservice.v20150416#EntityDoesNotExistException":
      response = await deserializeAws_json1_1EntityDoesNotExistExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "ServiceException":
    case "com.amazonaws.directoryservice.v20150416#ServiceException":
      response = await deserializeAws_json1_1ServiceExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeleteLogSubscriptionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteLogSubscriptionCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteLogSubscriptionCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteLogSubscriptionResult(data, context);
  const response: DeleteLogSubscriptionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteLogSubscriptionResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteLogSubscriptionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteLogSubscriptionCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ClientException":
    case "com.amazonaws.directoryservice.v20150416#ClientException":
      response = await deserializeAws_json1_1ClientExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "EntityDoesNotExistException":
    case "com.amazonaws.directoryservice.v20150416#EntityDoesNotExistException":
      response = await deserializeAws_json1_1EntityDoesNotExistExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "ServiceException":
    case "com.amazonaws.directoryservice.v20150416#ServiceException":
      response = await deserializeAws_json1_1ServiceExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "UnsupportedOperationException":
    case "com.amazonaws.directoryservice.v20150416#UnsupportedOperationException":
      response = await deserializeAws_json1_1UnsupportedOperationExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeleteSnapshotCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteSnapshotCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteSnapshotCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteSnapshotResult(data, context);
  const response: DeleteSnapshotCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteSnapshotResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteSnapshotCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteSnapshotCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ClientException":
    case "com.amazonaws.directoryservice.v20150416#ClientException":
      response = await deserializeAws_json1_1ClientExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "EntityDoesNotExistException":
    case "com.amazonaws.directoryservice.v20150416#EntityDoesNotExistException":
      response = await deserializeAws_json1_1EntityDoesNotExistExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidParameterException":
    case "com.amazonaws.directoryservice.v20150416#InvalidParameterException":
      response = await deserializeAws_json1_1InvalidParameterExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "ServiceException":
    case "com.amazonaws.directoryservice.v20150416#ServiceException":
      response = await deserializeAws_json1_1ServiceExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeleteTrustCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteTrustCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteTrustCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteTrustResult(data, context);
  const response: DeleteTrustCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteTrustResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteTrustCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteTrustCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ClientException":
    case "com.amazonaws.directoryservice.v20150416#ClientException":
      response = await deserializeAws_json1_1ClientExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "EntityDoesNotExistException":
    case "com.amazonaws.directoryservice.v20150416#EntityDoesNotExistException":
      response = await deserializeAws_json1_1EntityDoesNotExistExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidParameterException":
    case "com.amazonaws.directoryservice.v20150416#InvalidParameterException":
      response = await deserializeAws_json1_1InvalidParameterExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "ServiceException":
    case "com.amazonaws.directoryservice.v20150416#ServiceException":
      response = await deserializeAws_json1_1ServiceExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "UnsupportedOperationException":
    case "com.amazonaws.directoryservice.v20150416#UnsupportedOperationException":
      response = await deserializeAws_json1_1UnsupportedOperationExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeregisterCertificateCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeregisterCertificateCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeregisterCertificateCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeregisterCertificateResult(data, context);
  const response: DeregisterCertificateCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeregisterCertificateResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeregisterCertificateCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeregisterCertificateCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "CertificateDoesNotExistException":
    case "com.amazonaws.directoryservice.v20150416#CertificateDoesNotExistException":
      response = await deserializeAws_json1_1CertificateDoesNotExistExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "CertificateInUseException":
    case "com.amazonaws.directoryservice.v20150416#CertificateInUseException":
      response = await deserializeAws_json1_1CertificateInUseExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "ClientException":
    case "com.amazonaws.directoryservice.v20150416#ClientException":
      response = await deserializeAws_json1_1ClientExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "DirectoryDoesNotExistException":
    case "com.amazonaws.directoryservice.v20150416#DirectoryDoesNotExistException":
      response = await deserializeAws_json1_1DirectoryDoesNotExistExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "DirectoryUnavailableException":
    case "com.amazonaws.directoryservice.v20150416#DirectoryUnavailableException":
      response = await deserializeAws_json1_1DirectoryUnavailableExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidParameterException":
    case "com.amazonaws.directoryservice.v20150416#InvalidParameterException":
      response = await deserializeAws_json1_1InvalidParameterExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "ServiceException":
    case "com.amazonaws.directoryservice.v20150416#ServiceException":
      response = await deserializeAws_json1_1ServiceExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "UnsupportedOperationException":
    case "com.amazonaws.directoryservice.v20150416#UnsupportedOperationException":
      response = await deserializeAws_json1_1UnsupportedOperationExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeregisterEventTopicCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeregisterEventTopicCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeregisterEventTopicCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeregisterEventTopicResult(data, context);
  const response: DeregisterEventTopicCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeregisterEventTopicResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeregisterEventTopicCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeregisterEventTopicCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ClientException":
    case "com.amazonaws.directoryservice.v20150416#ClientException":
      response = await deserializeAws_json1_1ClientExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "EntityDoesNotExistException":
    case "com.amazonaws.directoryservice.v20150416#EntityDoesNotExistException":
      response = await deserializeAws_json1_1EntityDoesNotExistExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidParameterException":
    case "com.amazonaws.directoryservice.v20150416#InvalidParameterException":
      response = await deserializeAws_json1_1InvalidParameterExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "ServiceException":
    case "com.amazonaws.directoryservice.v20150416#ServiceException":
      response = await deserializeAws_json1_1ServiceExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeCertificateCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeCertificateCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeCertificateCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeCertificateResult(data, context);
  const response: DescribeCertificateCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeCertificateResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeCertificateCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeCertificateCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "CertificateDoesNotExistException":
    case "com.amazonaws.directoryservice.v20150416#CertificateDoesNotExistException":
      response = await deserializeAws_json1_1CertificateDoesNotExistExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "ClientException":
    case "com.amazonaws.directoryservice.v20150416#ClientException":
      response = await deserializeAws_json1_1ClientExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "DirectoryDoesNotExistException":
    case "com.amazonaws.directoryservice.v20150416#DirectoryDoesNotExistException":
      response = await deserializeAws_json1_1DirectoryDoesNotExistExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidParameterException":
    case "com.amazonaws.directoryservice.v20150416#InvalidParameterException":
      response = await deserializeAws_json1_1InvalidParameterExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "ServiceException":
    case "com.amazonaws.directoryservice.v20150416#ServiceException":
      response = await deserializeAws_json1_1ServiceExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "UnsupportedOperationException":
    case "com.amazonaws.directoryservice.v20150416#UnsupportedOperationException":
      response = await deserializeAws_json1_1UnsupportedOperationExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeConditionalForwardersCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeConditionalForwardersCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeConditionalForwardersCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeConditionalForwardersResult(
    data,
    context
  );
  const response: DescribeConditionalForwardersCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeConditionalForwardersResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeConditionalForwardersCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeConditionalForwardersCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ClientException":
    case "com.amazonaws.directoryservice.v20150416#ClientException":
      response = await deserializeAws_json1_1ClientExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "DirectoryUnavailableException":
    case "com.amazonaws.directoryservice.v20150416#DirectoryUnavailableException":
      response = await deserializeAws_json1_1DirectoryUnavailableExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "EntityDoesNotExistException":
    case "com.amazonaws.directoryservice.v20150416#EntityDoesNotExistException":
      response = await deserializeAws_json1_1EntityDoesNotExistExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidParameterException":
    case "com.amazonaws.directoryservice.v20150416#InvalidParameterException":
      response = await deserializeAws_json1_1InvalidParameterExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "ServiceException":
    case "com.amazonaws.directoryservice.v20150416#ServiceException":
      response = await deserializeAws_json1_1ServiceExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "UnsupportedOperationException":
    case "com.amazonaws.directoryservice.v20150416#UnsupportedOperationException":
      response = await deserializeAws_json1_1UnsupportedOperationExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeDirectoriesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDirectoriesCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeDirectoriesCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeDirectoriesResult(data, context);
  const response: DescribeDirectoriesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeDirectoriesResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeDirectoriesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDirectoriesCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ClientException":
    case "com.amazonaws.directoryservice.v20150416#ClientException":
      response = await deserializeAws_json1_1ClientExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "EntityDoesNotExistException":
    case "com.amazonaws.directoryservice.v20150416#EntityDoesNotExistException":
      response = await deserializeAws_json1_1EntityDoesNotExistExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidNextTokenException":
    case "com.amazonaws.directoryservice.v20150416#InvalidNextTokenException":
      response = await deserializeAws_json1_1InvalidNextTokenExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidParameterException":
    case "com.amazonaws.directoryservice.v20150416#InvalidParameterException":
      response = await deserializeAws_json1_1InvalidParameterExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "ServiceException":
    case "com.amazonaws.directoryservice.v20150416#ServiceException":
      response = await deserializeAws_json1_1ServiceExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeDomainControllersCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDomainControllersCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeDomainControllersCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeDomainControllersResult(
    data,
    context
  );
  const response: DescribeDomainControllersCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeDomainControllersResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeDomainControllersCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDomainControllersCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ClientException":
    case "com.amazonaws.directoryservice.v20150416#ClientException":
      response = await deserializeAws_json1_1ClientExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "EntityDoesNotExistException":
    case "com.amazonaws.directoryservice.v20150416#EntityDoesNotExistException":
      response = await deserializeAws_json1_1EntityDoesNotExistExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidNextTokenException":
    case "com.amazonaws.directoryservice.v20150416#InvalidNextTokenException":
      response = await deserializeAws_json1_1InvalidNextTokenExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidParameterException":
    case "com.amazonaws.directoryservice.v20150416#InvalidParameterException":
      response = await deserializeAws_json1_1InvalidParameterExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "ServiceException":
    case "com.amazonaws.directoryservice.v20150416#ServiceException":
      response = await deserializeAws_json1_1ServiceExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "UnsupportedOperationException":
    case "com.amazonaws.directoryservice.v20150416#UnsupportedOperationException":
      response = await deserializeAws_json1_1UnsupportedOperationExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeEventTopicsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeEventTopicsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeEventTopicsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeEventTopicsResult(data, context);
  const response: DescribeEventTopicsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeEventTopicsResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeEventTopicsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeEventTopicsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ClientException":
    case "com.amazonaws.directoryservice.v20150416#ClientException":
      response = await deserializeAws_json1_1ClientExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "EntityDoesNotExistException":
    case "com.amazonaws.directoryservice.v20150416#EntityDoesNotExistException":
      response = await deserializeAws_json1_1EntityDoesNotExistExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidParameterException":
    case "com.amazonaws.directoryservice.v20150416#InvalidParameterException":
      response = await deserializeAws_json1_1InvalidParameterExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "ServiceException":
    case "com.amazonaws.directoryservice.v20150416#ServiceException":
      response = await deserializeAws_json1_1ServiceExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeLDAPSSettingsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeLDAPSSettingsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeLDAPSSettingsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeLDAPSSettingsResult(data, context);
  const response: DescribeLDAPSSettingsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeLDAPSSettingsResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeLDAPSSettingsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeLDAPSSettingsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ClientException":
    case "com.amazonaws.directoryservice.v20150416#ClientException":
      response = await deserializeAws_json1_1ClientExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "DirectoryDoesNotExistException":
    case "com.amazonaws.directoryservice.v20150416#DirectoryDoesNotExistException":
      response = await deserializeAws_json1_1DirectoryDoesNotExistExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidNextTokenException":
    case "com.amazonaws.directoryservice.v20150416#InvalidNextTokenException":
      response = await deserializeAws_json1_1InvalidNextTokenExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidParameterException":
    case "com.amazonaws.directoryservice.v20150416#InvalidParameterException":
      response = await deserializeAws_json1_1InvalidParameterExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "ServiceException":
    case "com.amazonaws.directoryservice.v20150416#ServiceException":
      response = await deserializeAws_json1_1ServiceExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "UnsupportedOperationException":
    case "com.amazonaws.directoryservice.v20150416#UnsupportedOperationException":
      response = await deserializeAws_json1_1UnsupportedOperationExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeSharedDirectoriesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeSharedDirectoriesCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeSharedDirectoriesCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeSharedDirectoriesResult(
    data,
    context
  );
  const response: DescribeSharedDirectoriesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeSharedDirectoriesResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeSharedDirectoriesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeSharedDirectoriesCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ClientException":
    case "com.amazonaws.directoryservice.v20150416#ClientException":
      response = await deserializeAws_json1_1ClientExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "EntityDoesNotExistException":
    case "com.amazonaws.directoryservice.v20150416#EntityDoesNotExistException":
      response = await deserializeAws_json1_1EntityDoesNotExistExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidNextTokenException":
    case "com.amazonaws.directoryservice.v20150416#InvalidNextTokenException":
      response = await deserializeAws_json1_1InvalidNextTokenExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidParameterException":
    case "com.amazonaws.directoryservice.v20150416#InvalidParameterException":
      response = await deserializeAws_json1_1InvalidParameterExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "ServiceException":
    case "com.amazonaws.directoryservice.v20150416#ServiceException":
      response = await deserializeAws_json1_1ServiceExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "UnsupportedOperationException":
    case "com.amazonaws.directoryservice.v20150416#UnsupportedOperationException":
      response = await deserializeAws_json1_1UnsupportedOperationExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeSnapshotsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeSnapshotsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeSnapshotsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeSnapshotsResult(data, context);
  const response: DescribeSnapshotsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeSnapshotsResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeSnapshotsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeSnapshotsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ClientException":
    case "com.amazonaws.directoryservice.v20150416#ClientException":
      response = await deserializeAws_json1_1ClientExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "EntityDoesNotExistException":
    case "com.amazonaws.directoryservice.v20150416#EntityDoesNotExistException":
      response = await deserializeAws_json1_1EntityDoesNotExistExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidNextTokenException":
    case "com.amazonaws.directoryservice.v20150416#InvalidNextTokenException":
      response = await deserializeAws_json1_1InvalidNextTokenExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidParameterException":
    case "com.amazonaws.directoryservice.v20150416#InvalidParameterException":
      response = await deserializeAws_json1_1InvalidParameterExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "ServiceException":
    case "com.amazonaws.directoryservice.v20150416#ServiceException":
      response = await deserializeAws_json1_1ServiceExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeTrustsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeTrustsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeTrustsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeTrustsResult(data, context);
  const response: DescribeTrustsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeTrustsResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeTrustsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeTrustsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ClientException":
    case "com.amazonaws.directoryservice.v20150416#ClientException":
      response = await deserializeAws_json1_1ClientExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "EntityDoesNotExistException":
    case "com.amazonaws.directoryservice.v20150416#EntityDoesNotExistException":
      response = await deserializeAws_json1_1EntityDoesNotExistExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidNextTokenException":
    case "com.amazonaws.directoryservice.v20150416#InvalidNextTokenException":
      response = await deserializeAws_json1_1InvalidNextTokenExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidParameterException":
    case "com.amazonaws.directoryservice.v20150416#InvalidParameterException":
      response = await deserializeAws_json1_1InvalidParameterExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "ServiceException":
    case "com.amazonaws.directoryservice.v20150416#ServiceException":
      response = await deserializeAws_json1_1ServiceExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "UnsupportedOperationException":
    case "com.amazonaws.directoryservice.v20150416#UnsupportedOperationException":
      response = await deserializeAws_json1_1UnsupportedOperationExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DisableLDAPSCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DisableLDAPSCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DisableLDAPSCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DisableLDAPSResult(data, context);
  const response: DisableLDAPSCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DisableLDAPSResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DisableLDAPSCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DisableLDAPSCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ClientException":
    case "com.amazonaws.directoryservice.v20150416#ClientException":
      response = await deserializeAws_json1_1ClientExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "DirectoryDoesNotExistException":
    case "com.amazonaws.directoryservice.v20150416#DirectoryDoesNotExistException":
      response = await deserializeAws_json1_1DirectoryDoesNotExistExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "DirectoryUnavailableException":
    case "com.amazonaws.directoryservice.v20150416#DirectoryUnavailableException":
      response = await deserializeAws_json1_1DirectoryUnavailableExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidLDAPSStatusException":
    case "com.amazonaws.directoryservice.v20150416#InvalidLDAPSStatusException":
      response = await deserializeAws_json1_1InvalidLDAPSStatusExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidParameterException":
    case "com.amazonaws.directoryservice.v20150416#InvalidParameterException":
      response = await deserializeAws_json1_1InvalidParameterExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "ServiceException":
    case "com.amazonaws.directoryservice.v20150416#ServiceException":
      response = await deserializeAws_json1_1ServiceExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "UnsupportedOperationException":
    case "com.amazonaws.directoryservice.v20150416#UnsupportedOperationException":
      response = await deserializeAws_json1_1UnsupportedOperationExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DisableRadiusCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DisableRadiusCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DisableRadiusCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DisableRadiusResult(data, context);
  const response: DisableRadiusCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DisableRadiusResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DisableRadiusCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DisableRadiusCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ClientException":
    case "com.amazonaws.directoryservice.v20150416#ClientException":
      response = await deserializeAws_json1_1ClientExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "EntityDoesNotExistException":
    case "com.amazonaws.directoryservice.v20150416#EntityDoesNotExistException":
      response = await deserializeAws_json1_1EntityDoesNotExistExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "ServiceException":
    case "com.amazonaws.directoryservice.v20150416#ServiceException":
      response = await deserializeAws_json1_1ServiceExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DisableSsoCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DisableSsoCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DisableSsoCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DisableSsoResult(data, context);
  const response: DisableSsoCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DisableSsoResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DisableSsoCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DisableSsoCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "AuthenticationFailedException":
    case "com.amazonaws.directoryservice.v20150416#AuthenticationFailedException":
      response = await deserializeAws_json1_1AuthenticationFailedExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "ClientException":
    case "com.amazonaws.directoryservice.v20150416#ClientException":
      response = await deserializeAws_json1_1ClientExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "EntityDoesNotExistException":
    case "com.amazonaws.directoryservice.v20150416#EntityDoesNotExistException":
      response = await deserializeAws_json1_1EntityDoesNotExistExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InsufficientPermissionsException":
    case "com.amazonaws.directoryservice.v20150416#InsufficientPermissionsException":
      response = await deserializeAws_json1_1InsufficientPermissionsExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "ServiceException":
    case "com.amazonaws.directoryservice.v20150416#ServiceException":
      response = await deserializeAws_json1_1ServiceExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1EnableLDAPSCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<EnableLDAPSCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1EnableLDAPSCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1EnableLDAPSResult(data, context);
  const response: EnableLDAPSCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "EnableLDAPSResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1EnableLDAPSCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<EnableLDAPSCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ClientException":
    case "com.amazonaws.directoryservice.v20150416#ClientException":
      response = await deserializeAws_json1_1ClientExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "DirectoryDoesNotExistException":
    case "com.amazonaws.directoryservice.v20150416#DirectoryDoesNotExistException":
      response = await deserializeAws_json1_1DirectoryDoesNotExistExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "DirectoryUnavailableException":
    case "com.amazonaws.directoryservice.v20150416#DirectoryUnavailableException":
      response = await deserializeAws_json1_1DirectoryUnavailableExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidLDAPSStatusException":
    case "com.amazonaws.directoryservice.v20150416#InvalidLDAPSStatusException":
      response = await deserializeAws_json1_1InvalidLDAPSStatusExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidParameterException":
    case "com.amazonaws.directoryservice.v20150416#InvalidParameterException":
      response = await deserializeAws_json1_1InvalidParameterExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "NoAvailableCertificateException":
    case "com.amazonaws.directoryservice.v20150416#NoAvailableCertificateException":
      response = await deserializeAws_json1_1NoAvailableCertificateExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "ServiceException":
    case "com.amazonaws.directoryservice.v20150416#ServiceException":
      response = await deserializeAws_json1_1ServiceExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "UnsupportedOperationException":
    case "com.amazonaws.directoryservice.v20150416#UnsupportedOperationException":
      response = await deserializeAws_json1_1UnsupportedOperationExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1EnableRadiusCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<EnableRadiusCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1EnableRadiusCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1EnableRadiusResult(data, context);
  const response: EnableRadiusCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "EnableRadiusResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1EnableRadiusCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<EnableRadiusCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ClientException":
    case "com.amazonaws.directoryservice.v20150416#ClientException":
      response = await deserializeAws_json1_1ClientExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "EntityAlreadyExistsException":
    case "com.amazonaws.directoryservice.v20150416#EntityAlreadyExistsException":
      response = await deserializeAws_json1_1EntityAlreadyExistsExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "EntityDoesNotExistException":
    case "com.amazonaws.directoryservice.v20150416#EntityDoesNotExistException":
      response = await deserializeAws_json1_1EntityDoesNotExistExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidParameterException":
    case "com.amazonaws.directoryservice.v20150416#InvalidParameterException":
      response = await deserializeAws_json1_1InvalidParameterExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "ServiceException":
    case "com.amazonaws.directoryservice.v20150416#ServiceException":
      response = await deserializeAws_json1_1ServiceExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1EnableSsoCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<EnableSsoCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1EnableSsoCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1EnableSsoResult(data, context);
  const response: EnableSsoCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "EnableSsoResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1EnableSsoCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<EnableSsoCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "AuthenticationFailedException":
    case "com.amazonaws.directoryservice.v20150416#AuthenticationFailedException":
      response = await deserializeAws_json1_1AuthenticationFailedExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "ClientException":
    case "com.amazonaws.directoryservice.v20150416#ClientException":
      response = await deserializeAws_json1_1ClientExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "EntityDoesNotExistException":
    case "com.amazonaws.directoryservice.v20150416#EntityDoesNotExistException":
      response = await deserializeAws_json1_1EntityDoesNotExistExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InsufficientPermissionsException":
    case "com.amazonaws.directoryservice.v20150416#InsufficientPermissionsException":
      response = await deserializeAws_json1_1InsufficientPermissionsExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "ServiceException":
    case "com.amazonaws.directoryservice.v20150416#ServiceException":
      response = await deserializeAws_json1_1ServiceExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetDirectoryLimitsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetDirectoryLimitsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetDirectoryLimitsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetDirectoryLimitsResult(data, context);
  const response: GetDirectoryLimitsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetDirectoryLimitsResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetDirectoryLimitsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetDirectoryLimitsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ClientException":
    case "com.amazonaws.directoryservice.v20150416#ClientException":
      response = await deserializeAws_json1_1ClientExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "EntityDoesNotExistException":
    case "com.amazonaws.directoryservice.v20150416#EntityDoesNotExistException":
      response = await deserializeAws_json1_1EntityDoesNotExistExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "ServiceException":
    case "com.amazonaws.directoryservice.v20150416#ServiceException":
      response = await deserializeAws_json1_1ServiceExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetSnapshotLimitsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetSnapshotLimitsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetSnapshotLimitsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetSnapshotLimitsResult(data, context);
  const response: GetSnapshotLimitsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetSnapshotLimitsResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetSnapshotLimitsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetSnapshotLimitsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ClientException":
    case "com.amazonaws.directoryservice.v20150416#ClientException":
      response = await deserializeAws_json1_1ClientExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "EntityDoesNotExistException":
    case "com.amazonaws.directoryservice.v20150416#EntityDoesNotExistException":
      response = await deserializeAws_json1_1EntityDoesNotExistExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "ServiceException":
    case "com.amazonaws.directoryservice.v20150416#ServiceException":
      response = await deserializeAws_json1_1ServiceExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ListCertificatesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListCertificatesCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListCertificatesCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListCertificatesResult(data, context);
  const response: ListCertificatesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListCertificatesResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListCertificatesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListCertificatesCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ClientException":
    case "com.amazonaws.directoryservice.v20150416#ClientException":
      response = await deserializeAws_json1_1ClientExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "DirectoryDoesNotExistException":
    case "com.amazonaws.directoryservice.v20150416#DirectoryDoesNotExistException":
      response = await deserializeAws_json1_1DirectoryDoesNotExistExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidNextTokenException":
    case "com.amazonaws.directoryservice.v20150416#InvalidNextTokenException":
      response = await deserializeAws_json1_1InvalidNextTokenExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidParameterException":
    case "com.amazonaws.directoryservice.v20150416#InvalidParameterException":
      response = await deserializeAws_json1_1InvalidParameterExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "ServiceException":
    case "com.amazonaws.directoryservice.v20150416#ServiceException":
      response = await deserializeAws_json1_1ServiceExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "UnsupportedOperationException":
    case "com.amazonaws.directoryservice.v20150416#UnsupportedOperationException":
      response = await deserializeAws_json1_1UnsupportedOperationExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ListIpRoutesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListIpRoutesCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListIpRoutesCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListIpRoutesResult(data, context);
  const response: ListIpRoutesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListIpRoutesResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListIpRoutesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListIpRoutesCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ClientException":
    case "com.amazonaws.directoryservice.v20150416#ClientException":
      response = await deserializeAws_json1_1ClientExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "EntityDoesNotExistException":
    case "com.amazonaws.directoryservice.v20150416#EntityDoesNotExistException":
      response = await deserializeAws_json1_1EntityDoesNotExistExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidNextTokenException":
    case "com.amazonaws.directoryservice.v20150416#InvalidNextTokenException":
      response = await deserializeAws_json1_1InvalidNextTokenExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidParameterException":
    case "com.amazonaws.directoryservice.v20150416#InvalidParameterException":
      response = await deserializeAws_json1_1InvalidParameterExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "ServiceException":
    case "com.amazonaws.directoryservice.v20150416#ServiceException":
      response = await deserializeAws_json1_1ServiceExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ListLogSubscriptionsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListLogSubscriptionsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListLogSubscriptionsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListLogSubscriptionsResult(data, context);
  const response: ListLogSubscriptionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListLogSubscriptionsResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListLogSubscriptionsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListLogSubscriptionsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ClientException":
    case "com.amazonaws.directoryservice.v20150416#ClientException":
      response = await deserializeAws_json1_1ClientExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "EntityDoesNotExistException":
    case "com.amazonaws.directoryservice.v20150416#EntityDoesNotExistException":
      response = await deserializeAws_json1_1EntityDoesNotExistExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidNextTokenException":
    case "com.amazonaws.directoryservice.v20150416#InvalidNextTokenException":
      response = await deserializeAws_json1_1InvalidNextTokenExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "ServiceException":
    case "com.amazonaws.directoryservice.v20150416#ServiceException":
      response = await deserializeAws_json1_1ServiceExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ListSchemaExtensionsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListSchemaExtensionsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListSchemaExtensionsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListSchemaExtensionsResult(data, context);
  const response: ListSchemaExtensionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListSchemaExtensionsResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListSchemaExtensionsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListSchemaExtensionsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ClientException":
    case "com.amazonaws.directoryservice.v20150416#ClientException":
      response = await deserializeAws_json1_1ClientExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "EntityDoesNotExistException":
    case "com.amazonaws.directoryservice.v20150416#EntityDoesNotExistException":
      response = await deserializeAws_json1_1EntityDoesNotExistExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidNextTokenException":
    case "com.amazonaws.directoryservice.v20150416#InvalidNextTokenException":
      response = await deserializeAws_json1_1InvalidNextTokenExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "ServiceException":
    case "com.amazonaws.directoryservice.v20150416#ServiceException":
      response = await deserializeAws_json1_1ServiceExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ListTagsForResourceCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTagsForResourceCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListTagsForResourceCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListTagsForResourceResult(data, context);
  const response: ListTagsForResourceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListTagsForResourceResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListTagsForResourceCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTagsForResourceCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ClientException":
    case "com.amazonaws.directoryservice.v20150416#ClientException":
      response = await deserializeAws_json1_1ClientExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "EntityDoesNotExistException":
    case "com.amazonaws.directoryservice.v20150416#EntityDoesNotExistException":
      response = await deserializeAws_json1_1EntityDoesNotExistExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidNextTokenException":
    case "com.amazonaws.directoryservice.v20150416#InvalidNextTokenException":
      response = await deserializeAws_json1_1InvalidNextTokenExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidParameterException":
    case "com.amazonaws.directoryservice.v20150416#InvalidParameterException":
      response = await deserializeAws_json1_1InvalidParameterExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "ServiceException":
    case "com.amazonaws.directoryservice.v20150416#ServiceException":
      response = await deserializeAws_json1_1ServiceExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1RegisterCertificateCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RegisterCertificateCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1RegisterCertificateCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1RegisterCertificateResult(data, context);
  const response: RegisterCertificateCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "RegisterCertificateResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1RegisterCertificateCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RegisterCertificateCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "CertificateAlreadyExistsException":
    case "com.amazonaws.directoryservice.v20150416#CertificateAlreadyExistsException":
      response = await deserializeAws_json1_1CertificateAlreadyExistsExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "CertificateLimitExceededException":
    case "com.amazonaws.directoryservice.v20150416#CertificateLimitExceededException":
      response = await deserializeAws_json1_1CertificateLimitExceededExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "ClientException":
    case "com.amazonaws.directoryservice.v20150416#ClientException":
      response = await deserializeAws_json1_1ClientExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "DirectoryDoesNotExistException":
    case "com.amazonaws.directoryservice.v20150416#DirectoryDoesNotExistException":
      response = await deserializeAws_json1_1DirectoryDoesNotExistExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "DirectoryUnavailableException":
    case "com.amazonaws.directoryservice.v20150416#DirectoryUnavailableException":
      response = await deserializeAws_json1_1DirectoryUnavailableExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidCertificateException":
    case "com.amazonaws.directoryservice.v20150416#InvalidCertificateException":
      response = await deserializeAws_json1_1InvalidCertificateExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidParameterException":
    case "com.amazonaws.directoryservice.v20150416#InvalidParameterException":
      response = await deserializeAws_json1_1InvalidParameterExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "ServiceException":
    case "com.amazonaws.directoryservice.v20150416#ServiceException":
      response = await deserializeAws_json1_1ServiceExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "UnsupportedOperationException":
    case "com.amazonaws.directoryservice.v20150416#UnsupportedOperationException":
      response = await deserializeAws_json1_1UnsupportedOperationExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1RegisterEventTopicCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RegisterEventTopicCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1RegisterEventTopicCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1RegisterEventTopicResult(data, context);
  const response: RegisterEventTopicCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "RegisterEventTopicResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1RegisterEventTopicCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RegisterEventTopicCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ClientException":
    case "com.amazonaws.directoryservice.v20150416#ClientException":
      response = await deserializeAws_json1_1ClientExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "EntityDoesNotExistException":
    case "com.amazonaws.directoryservice.v20150416#EntityDoesNotExistException":
      response = await deserializeAws_json1_1EntityDoesNotExistExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidParameterException":
    case "com.amazonaws.directoryservice.v20150416#InvalidParameterException":
      response = await deserializeAws_json1_1InvalidParameterExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "ServiceException":
    case "com.amazonaws.directoryservice.v20150416#ServiceException":
      response = await deserializeAws_json1_1ServiceExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1RejectSharedDirectoryCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RejectSharedDirectoryCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1RejectSharedDirectoryCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1RejectSharedDirectoryResult(data, context);
  const response: RejectSharedDirectoryCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "RejectSharedDirectoryResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1RejectSharedDirectoryCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RejectSharedDirectoryCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ClientException":
    case "com.amazonaws.directoryservice.v20150416#ClientException":
      response = await deserializeAws_json1_1ClientExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "DirectoryAlreadySharedException":
    case "com.amazonaws.directoryservice.v20150416#DirectoryAlreadySharedException":
      response = await deserializeAws_json1_1DirectoryAlreadySharedExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "EntityDoesNotExistException":
    case "com.amazonaws.directoryservice.v20150416#EntityDoesNotExistException":
      response = await deserializeAws_json1_1EntityDoesNotExistExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidParameterException":
    case "com.amazonaws.directoryservice.v20150416#InvalidParameterException":
      response = await deserializeAws_json1_1InvalidParameterExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "ServiceException":
    case "com.amazonaws.directoryservice.v20150416#ServiceException":
      response = await deserializeAws_json1_1ServiceExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1RemoveIpRoutesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RemoveIpRoutesCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1RemoveIpRoutesCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1RemoveIpRoutesResult(data, context);
  const response: RemoveIpRoutesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "RemoveIpRoutesResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1RemoveIpRoutesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RemoveIpRoutesCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ClientException":
    case "com.amazonaws.directoryservice.v20150416#ClientException":
      response = await deserializeAws_json1_1ClientExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "DirectoryUnavailableException":
    case "com.amazonaws.directoryservice.v20150416#DirectoryUnavailableException":
      response = await deserializeAws_json1_1DirectoryUnavailableExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "EntityDoesNotExistException":
    case "com.amazonaws.directoryservice.v20150416#EntityDoesNotExistException":
      response = await deserializeAws_json1_1EntityDoesNotExistExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidParameterException":
    case "com.amazonaws.directoryservice.v20150416#InvalidParameterException":
      response = await deserializeAws_json1_1InvalidParameterExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "ServiceException":
    case "com.amazonaws.directoryservice.v20150416#ServiceException":
      response = await deserializeAws_json1_1ServiceExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1RemoveTagsFromResourceCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RemoveTagsFromResourceCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1RemoveTagsFromResourceCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1RemoveTagsFromResourceResult(data, context);
  const response: RemoveTagsFromResourceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "RemoveTagsFromResourceResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1RemoveTagsFromResourceCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RemoveTagsFromResourceCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ClientException":
    case "com.amazonaws.directoryservice.v20150416#ClientException":
      response = await deserializeAws_json1_1ClientExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "EntityDoesNotExistException":
    case "com.amazonaws.directoryservice.v20150416#EntityDoesNotExistException":
      response = await deserializeAws_json1_1EntityDoesNotExistExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidParameterException":
    case "com.amazonaws.directoryservice.v20150416#InvalidParameterException":
      response = await deserializeAws_json1_1InvalidParameterExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "ServiceException":
    case "com.amazonaws.directoryservice.v20150416#ServiceException":
      response = await deserializeAws_json1_1ServiceExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ResetUserPasswordCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ResetUserPasswordCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ResetUserPasswordCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ResetUserPasswordResult(data, context);
  const response: ResetUserPasswordCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ResetUserPasswordResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ResetUserPasswordCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ResetUserPasswordCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ClientException":
    case "com.amazonaws.directoryservice.v20150416#ClientException":
      response = await deserializeAws_json1_1ClientExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "DirectoryUnavailableException":
    case "com.amazonaws.directoryservice.v20150416#DirectoryUnavailableException":
      response = await deserializeAws_json1_1DirectoryUnavailableExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "EntityDoesNotExistException":
    case "com.amazonaws.directoryservice.v20150416#EntityDoesNotExistException":
      response = await deserializeAws_json1_1EntityDoesNotExistExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidPasswordException":
    case "com.amazonaws.directoryservice.v20150416#InvalidPasswordException":
      response = await deserializeAws_json1_1InvalidPasswordExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "ServiceException":
    case "com.amazonaws.directoryservice.v20150416#ServiceException":
      response = await deserializeAws_json1_1ServiceExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "UnsupportedOperationException":
    case "com.amazonaws.directoryservice.v20150416#UnsupportedOperationException":
      response = await deserializeAws_json1_1UnsupportedOperationExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "UserDoesNotExistException":
    case "com.amazonaws.directoryservice.v20150416#UserDoesNotExistException":
      response = await deserializeAws_json1_1UserDoesNotExistExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1RestoreFromSnapshotCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RestoreFromSnapshotCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1RestoreFromSnapshotCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1RestoreFromSnapshotResult(data, context);
  const response: RestoreFromSnapshotCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "RestoreFromSnapshotResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1RestoreFromSnapshotCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RestoreFromSnapshotCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ClientException":
    case "com.amazonaws.directoryservice.v20150416#ClientException":
      response = await deserializeAws_json1_1ClientExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "EntityDoesNotExistException":
    case "com.amazonaws.directoryservice.v20150416#EntityDoesNotExistException":
      response = await deserializeAws_json1_1EntityDoesNotExistExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidParameterException":
    case "com.amazonaws.directoryservice.v20150416#InvalidParameterException":
      response = await deserializeAws_json1_1InvalidParameterExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "ServiceException":
    case "com.amazonaws.directoryservice.v20150416#ServiceException":
      response = await deserializeAws_json1_1ServiceExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ShareDirectoryCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ShareDirectoryCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ShareDirectoryCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ShareDirectoryResult(data, context);
  const response: ShareDirectoryCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ShareDirectoryResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ShareDirectoryCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ShareDirectoryCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.directoryservice.v20150416#AccessDeniedException":
      response = await deserializeAws_json1_1AccessDeniedExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "ClientException":
    case "com.amazonaws.directoryservice.v20150416#ClientException":
      response = await deserializeAws_json1_1ClientExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "DirectoryAlreadySharedException":
    case "com.amazonaws.directoryservice.v20150416#DirectoryAlreadySharedException":
      response = await deserializeAws_json1_1DirectoryAlreadySharedExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "EntityDoesNotExistException":
    case "com.amazonaws.directoryservice.v20150416#EntityDoesNotExistException":
      response = await deserializeAws_json1_1EntityDoesNotExistExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidParameterException":
    case "com.amazonaws.directoryservice.v20150416#InvalidParameterException":
      response = await deserializeAws_json1_1InvalidParameterExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidTargetException":
    case "com.amazonaws.directoryservice.v20150416#InvalidTargetException":
      response = await deserializeAws_json1_1InvalidTargetExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "OrganizationsException":
    case "com.amazonaws.directoryservice.v20150416#OrganizationsException":
      response = await deserializeAws_json1_1OrganizationsExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "ServiceException":
    case "com.amazonaws.directoryservice.v20150416#ServiceException":
      response = await deserializeAws_json1_1ServiceExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "ShareLimitExceededException":
    case "com.amazonaws.directoryservice.v20150416#ShareLimitExceededException":
      response = await deserializeAws_json1_1ShareLimitExceededExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "UnsupportedOperationException":
    case "com.amazonaws.directoryservice.v20150416#UnsupportedOperationException":
      response = await deserializeAws_json1_1UnsupportedOperationExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1StartSchemaExtensionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartSchemaExtensionCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1StartSchemaExtensionCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1StartSchemaExtensionResult(data, context);
  const response: StartSchemaExtensionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "StartSchemaExtensionResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1StartSchemaExtensionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartSchemaExtensionCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ClientException":
    case "com.amazonaws.directoryservice.v20150416#ClientException":
      response = await deserializeAws_json1_1ClientExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "DirectoryUnavailableException":
    case "com.amazonaws.directoryservice.v20150416#DirectoryUnavailableException":
      response = await deserializeAws_json1_1DirectoryUnavailableExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "EntityDoesNotExistException":
    case "com.amazonaws.directoryservice.v20150416#EntityDoesNotExistException":
      response = await deserializeAws_json1_1EntityDoesNotExistExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidParameterException":
    case "com.amazonaws.directoryservice.v20150416#InvalidParameterException":
      response = await deserializeAws_json1_1InvalidParameterExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "ServiceException":
    case "com.amazonaws.directoryservice.v20150416#ServiceException":
      response = await deserializeAws_json1_1ServiceExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "SnapshotLimitExceededException":
    case "com.amazonaws.directoryservice.v20150416#SnapshotLimitExceededException":
      response = await deserializeAws_json1_1SnapshotLimitExceededExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1UnshareDirectoryCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UnshareDirectoryCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UnshareDirectoryCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UnshareDirectoryResult(data, context);
  const response: UnshareDirectoryCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UnshareDirectoryResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1UnshareDirectoryCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UnshareDirectoryCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ClientException":
    case "com.amazonaws.directoryservice.v20150416#ClientException":
      response = await deserializeAws_json1_1ClientExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "DirectoryNotSharedException":
    case "com.amazonaws.directoryservice.v20150416#DirectoryNotSharedException":
      response = await deserializeAws_json1_1DirectoryNotSharedExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "EntityDoesNotExistException":
    case "com.amazonaws.directoryservice.v20150416#EntityDoesNotExistException":
      response = await deserializeAws_json1_1EntityDoesNotExistExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidTargetException":
    case "com.amazonaws.directoryservice.v20150416#InvalidTargetException":
      response = await deserializeAws_json1_1InvalidTargetExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "ServiceException":
    case "com.amazonaws.directoryservice.v20150416#ServiceException":
      response = await deserializeAws_json1_1ServiceExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1UpdateConditionalForwarderCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateConditionalForwarderCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateConditionalForwarderCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdateConditionalForwarderResult(
    data,
    context
  );
  const response: UpdateConditionalForwarderCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateConditionalForwarderResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1UpdateConditionalForwarderCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateConditionalForwarderCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ClientException":
    case "com.amazonaws.directoryservice.v20150416#ClientException":
      response = await deserializeAws_json1_1ClientExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "DirectoryUnavailableException":
    case "com.amazonaws.directoryservice.v20150416#DirectoryUnavailableException":
      response = await deserializeAws_json1_1DirectoryUnavailableExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "EntityDoesNotExistException":
    case "com.amazonaws.directoryservice.v20150416#EntityDoesNotExistException":
      response = await deserializeAws_json1_1EntityDoesNotExistExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidParameterException":
    case "com.amazonaws.directoryservice.v20150416#InvalidParameterException":
      response = await deserializeAws_json1_1InvalidParameterExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "ServiceException":
    case "com.amazonaws.directoryservice.v20150416#ServiceException":
      response = await deserializeAws_json1_1ServiceExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "UnsupportedOperationException":
    case "com.amazonaws.directoryservice.v20150416#UnsupportedOperationException":
      response = await deserializeAws_json1_1UnsupportedOperationExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1UpdateNumberOfDomainControllersCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateNumberOfDomainControllersCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateNumberOfDomainControllersCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdateNumberOfDomainControllersResult(
    data,
    context
  );
  const response: UpdateNumberOfDomainControllersCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateNumberOfDomainControllersResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1UpdateNumberOfDomainControllersCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateNumberOfDomainControllersCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ClientException":
    case "com.amazonaws.directoryservice.v20150416#ClientException":
      response = await deserializeAws_json1_1ClientExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "DirectoryUnavailableException":
    case "com.amazonaws.directoryservice.v20150416#DirectoryUnavailableException":
      response = await deserializeAws_json1_1DirectoryUnavailableExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "DomainControllerLimitExceededException":
    case "com.amazonaws.directoryservice.v20150416#DomainControllerLimitExceededException":
      response = await deserializeAws_json1_1DomainControllerLimitExceededExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "EntityDoesNotExistException":
    case "com.amazonaws.directoryservice.v20150416#EntityDoesNotExistException":
      response = await deserializeAws_json1_1EntityDoesNotExistExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidParameterException":
    case "com.amazonaws.directoryservice.v20150416#InvalidParameterException":
      response = await deserializeAws_json1_1InvalidParameterExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "ServiceException":
    case "com.amazonaws.directoryservice.v20150416#ServiceException":
      response = await deserializeAws_json1_1ServiceExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "UnsupportedOperationException":
    case "com.amazonaws.directoryservice.v20150416#UnsupportedOperationException":
      response = await deserializeAws_json1_1UnsupportedOperationExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1UpdateRadiusCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateRadiusCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateRadiusCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdateRadiusResult(data, context);
  const response: UpdateRadiusCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateRadiusResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1UpdateRadiusCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateRadiusCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ClientException":
    case "com.amazonaws.directoryservice.v20150416#ClientException":
      response = await deserializeAws_json1_1ClientExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "EntityDoesNotExistException":
    case "com.amazonaws.directoryservice.v20150416#EntityDoesNotExistException":
      response = await deserializeAws_json1_1EntityDoesNotExistExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidParameterException":
    case "com.amazonaws.directoryservice.v20150416#InvalidParameterException":
      response = await deserializeAws_json1_1InvalidParameterExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "ServiceException":
    case "com.amazonaws.directoryservice.v20150416#ServiceException":
      response = await deserializeAws_json1_1ServiceExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1UpdateTrustCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateTrustCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateTrustCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdateTrustResult(data, context);
  const response: UpdateTrustCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateTrustResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1UpdateTrustCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateTrustCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ClientException":
    case "com.amazonaws.directoryservice.v20150416#ClientException":
      response = await deserializeAws_json1_1ClientExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "EntityDoesNotExistException":
    case "com.amazonaws.directoryservice.v20150416#EntityDoesNotExistException":
      response = await deserializeAws_json1_1EntityDoesNotExistExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidParameterException":
    case "com.amazonaws.directoryservice.v20150416#InvalidParameterException":
      response = await deserializeAws_json1_1InvalidParameterExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "ServiceException":
    case "com.amazonaws.directoryservice.v20150416#ServiceException":
      response = await deserializeAws_json1_1ServiceExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1VerifyTrustCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<VerifyTrustCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1VerifyTrustCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1VerifyTrustResult(data, context);
  const response: VerifyTrustCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "VerifyTrustResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1VerifyTrustCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<VerifyTrustCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ClientException":
    case "com.amazonaws.directoryservice.v20150416#ClientException":
      response = await deserializeAws_json1_1ClientExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "EntityDoesNotExistException":
    case "com.amazonaws.directoryservice.v20150416#EntityDoesNotExistException":
      response = await deserializeAws_json1_1EntityDoesNotExistExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidParameterException":
    case "com.amazonaws.directoryservice.v20150416#InvalidParameterException":
      response = await deserializeAws_json1_1InvalidParameterExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "ServiceException":
    case "com.amazonaws.directoryservice.v20150416#ServiceException":
      response = await deserializeAws_json1_1ServiceExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "UnsupportedOperationException":
    case "com.amazonaws.directoryservice.v20150416#UnsupportedOperationException":
      response = await deserializeAws_json1_1UnsupportedOperationExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

const deserializeAws_json1_1AccessDeniedExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<AccessDeniedException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1AccessDeniedException(
    body,
    context
  );
  const contents: AccessDeniedException = {
    name: "AccessDeniedException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1AuthenticationFailedExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<AuthenticationFailedException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1AuthenticationFailedException(
    body,
    context
  );
  const contents: AuthenticationFailedException = {
    name: "AuthenticationFailedException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1CertificateAlreadyExistsExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<CertificateAlreadyExistsException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1CertificateAlreadyExistsException(
    body,
    context
  );
  const contents: CertificateAlreadyExistsException = {
    name: "CertificateAlreadyExistsException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1CertificateDoesNotExistExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<CertificateDoesNotExistException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1CertificateDoesNotExistException(
    body,
    context
  );
  const contents: CertificateDoesNotExistException = {
    name: "CertificateDoesNotExistException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1CertificateInUseExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<CertificateInUseException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1CertificateInUseException(
    body,
    context
  );
  const contents: CertificateInUseException = {
    name: "CertificateInUseException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1CertificateLimitExceededExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<CertificateLimitExceededException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1CertificateLimitExceededException(
    body,
    context
  );
  const contents: CertificateLimitExceededException = {
    name: "CertificateLimitExceededException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1ClientExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ClientException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1ClientException(
    body,
    context
  );
  const contents: ClientException = {
    name: "ClientException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1DirectoryAlreadySharedExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<DirectoryAlreadySharedException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1DirectoryAlreadySharedException(
    body,
    context
  );
  const contents: DirectoryAlreadySharedException = {
    name: "DirectoryAlreadySharedException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1DirectoryDoesNotExistExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<DirectoryDoesNotExistException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1DirectoryDoesNotExistException(
    body,
    context
  );
  const contents: DirectoryDoesNotExistException = {
    name: "DirectoryDoesNotExistException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1DirectoryLimitExceededExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<DirectoryLimitExceededException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1DirectoryLimitExceededException(
    body,
    context
  );
  const contents: DirectoryLimitExceededException = {
    name: "DirectoryLimitExceededException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1DirectoryNotSharedExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<DirectoryNotSharedException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1DirectoryNotSharedException(
    body,
    context
  );
  const contents: DirectoryNotSharedException = {
    name: "DirectoryNotSharedException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1DirectoryUnavailableExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<DirectoryUnavailableException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1DirectoryUnavailableException(
    body,
    context
  );
  const contents: DirectoryUnavailableException = {
    name: "DirectoryUnavailableException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1DomainControllerLimitExceededExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<DomainControllerLimitExceededException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1DomainControllerLimitExceededException(
    body,
    context
  );
  const contents: DomainControllerLimitExceededException = {
    name: "DomainControllerLimitExceededException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1EntityAlreadyExistsExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<EntityAlreadyExistsException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1EntityAlreadyExistsException(
    body,
    context
  );
  const contents: EntityAlreadyExistsException = {
    name: "EntityAlreadyExistsException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1EntityDoesNotExistExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<EntityDoesNotExistException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1EntityDoesNotExistException(
    body,
    context
  );
  const contents: EntityDoesNotExistException = {
    name: "EntityDoesNotExistException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InsufficientPermissionsExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InsufficientPermissionsException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InsufficientPermissionsException(
    body,
    context
  );
  const contents: InsufficientPermissionsException = {
    name: "InsufficientPermissionsException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidCertificateExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidCertificateException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidCertificateException(
    body,
    context
  );
  const contents: InvalidCertificateException = {
    name: "InvalidCertificateException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidLDAPSStatusExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidLDAPSStatusException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidLDAPSStatusException(
    body,
    context
  );
  const contents: InvalidLDAPSStatusException = {
    name: "InvalidLDAPSStatusException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidNextTokenExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidNextTokenException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidNextTokenException(
    body,
    context
  );
  const contents: InvalidNextTokenException = {
    name: "InvalidNextTokenException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidParameterExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidParameterException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidParameterException(
    body,
    context
  );
  const contents: InvalidParameterException = {
    name: "InvalidParameterException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidPasswordExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidPasswordException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidPasswordException(
    body,
    context
  );
  const contents: InvalidPasswordException = {
    name: "InvalidPasswordException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidTargetExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidTargetException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidTargetException(
    body,
    context
  );
  const contents: InvalidTargetException = {
    name: "InvalidTargetException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1IpRouteLimitExceededExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<IpRouteLimitExceededException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1IpRouteLimitExceededException(
    body,
    context
  );
  const contents: IpRouteLimitExceededException = {
    name: "IpRouteLimitExceededException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1NoAvailableCertificateExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<NoAvailableCertificateException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1NoAvailableCertificateException(
    body,
    context
  );
  const contents: NoAvailableCertificateException = {
    name: "NoAvailableCertificateException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1OrganizationsExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<OrganizationsException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1OrganizationsException(
    body,
    context
  );
  const contents: OrganizationsException = {
    name: "OrganizationsException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1ServiceExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ServiceException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1ServiceException(
    body,
    context
  );
  const contents: ServiceException = {
    name: "ServiceException",
    $fault: "server",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1ShareLimitExceededExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ShareLimitExceededException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1ShareLimitExceededException(
    body,
    context
  );
  const contents: ShareLimitExceededException = {
    name: "ShareLimitExceededException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1SnapshotLimitExceededExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<SnapshotLimitExceededException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1SnapshotLimitExceededException(
    body,
    context
  );
  const contents: SnapshotLimitExceededException = {
    name: "SnapshotLimitExceededException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1TagLimitExceededExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<TagLimitExceededException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1TagLimitExceededException(
    body,
    context
  );
  const contents: TagLimitExceededException = {
    name: "TagLimitExceededException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1UnsupportedOperationExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<UnsupportedOperationException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1UnsupportedOperationException(
    body,
    context
  );
  const contents: UnsupportedOperationException = {
    name: "UnsupportedOperationException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1UserDoesNotExistExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<UserDoesNotExistException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1UserDoesNotExistException(
    body,
    context
  );
  const contents: UserDoesNotExistException = {
    name: "UserDoesNotExistException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const serializeAws_json1_1AcceptSharedDirectoryRequest = (
  input: AcceptSharedDirectoryRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.SharedDirectoryId !== undefined) {
    bodyParams["SharedDirectoryId"] = input.SharedDirectoryId;
  }
  return bodyParams;
};

const serializeAws_json1_1AddIpRoutesRequest = (
  input: AddIpRoutesRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.DirectoryId !== undefined) {
    bodyParams["DirectoryId"] = input.DirectoryId;
  }
  if (input.IpRoutes !== undefined) {
    bodyParams["IpRoutes"] = serializeAws_json1_1IpRoutes(
      input.IpRoutes,
      context
    );
  }
  if (input.UpdateSecurityGroupForDirectoryControllers !== undefined) {
    bodyParams["UpdateSecurityGroupForDirectoryControllers"] =
      input.UpdateSecurityGroupForDirectoryControllers;
  }
  return bodyParams;
};

const serializeAws_json1_1AddTagsToResourceRequest = (
  input: AddTagsToResourceRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ResourceId !== undefined) {
    bodyParams["ResourceId"] = input.ResourceId;
  }
  if (input.Tags !== undefined) {
    bodyParams["Tags"] = serializeAws_json1_1Tags(input.Tags, context);
  }
  return bodyParams;
};

const serializeAws_json1_1Attribute = (
  input: Attribute,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.Value !== undefined) {
    bodyParams["Value"] = input.Value;
  }
  return bodyParams;
};

const serializeAws_json1_1Attributes = (
  input: Array<Attribute>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry =>
    serializeAws_json1_1Attribute(entry, context)
  );
};

const serializeAws_json1_1CancelSchemaExtensionRequest = (
  input: CancelSchemaExtensionRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.DirectoryId !== undefined) {
    bodyParams["DirectoryId"] = input.DirectoryId;
  }
  if (input.SchemaExtensionId !== undefined) {
    bodyParams["SchemaExtensionId"] = input.SchemaExtensionId;
  }
  return bodyParams;
};

const serializeAws_json1_1CidrIps = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry => entry);
};

const serializeAws_json1_1ConnectDirectoryRequest = (
  input: ConnectDirectoryRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ConnectSettings !== undefined) {
    bodyParams[
      "ConnectSettings"
    ] = serializeAws_json1_1DirectoryConnectSettings(
      input.ConnectSettings,
      context
    );
  }
  if (input.Description !== undefined) {
    bodyParams["Description"] = input.Description;
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.Password !== undefined) {
    bodyParams["Password"] = input.Password;
  }
  if (input.ShortName !== undefined) {
    bodyParams["ShortName"] = input.ShortName;
  }
  if (input.Size !== undefined) {
    bodyParams["Size"] = input.Size;
  }
  if (input.Tags !== undefined) {
    bodyParams["Tags"] = serializeAws_json1_1Tags(input.Tags, context);
  }
  return bodyParams;
};

const serializeAws_json1_1CreateAliasRequest = (
  input: CreateAliasRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Alias !== undefined) {
    bodyParams["Alias"] = input.Alias;
  }
  if (input.DirectoryId !== undefined) {
    bodyParams["DirectoryId"] = input.DirectoryId;
  }
  return bodyParams;
};

const serializeAws_json1_1CreateComputerRequest = (
  input: CreateComputerRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ComputerAttributes !== undefined) {
    bodyParams["ComputerAttributes"] = serializeAws_json1_1Attributes(
      input.ComputerAttributes,
      context
    );
  }
  if (input.ComputerName !== undefined) {
    bodyParams["ComputerName"] = input.ComputerName;
  }
  if (input.DirectoryId !== undefined) {
    bodyParams["DirectoryId"] = input.DirectoryId;
  }
  if (input.OrganizationalUnitDistinguishedName !== undefined) {
    bodyParams["OrganizationalUnitDistinguishedName"] =
      input.OrganizationalUnitDistinguishedName;
  }
  if (input.Password !== undefined) {
    bodyParams["Password"] = input.Password;
  }
  return bodyParams;
};

const serializeAws_json1_1CreateConditionalForwarderRequest = (
  input: CreateConditionalForwarderRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.DirectoryId !== undefined) {
    bodyParams["DirectoryId"] = input.DirectoryId;
  }
  if (input.DnsIpAddrs !== undefined) {
    bodyParams["DnsIpAddrs"] = serializeAws_json1_1DnsIpAddrs(
      input.DnsIpAddrs,
      context
    );
  }
  if (input.RemoteDomainName !== undefined) {
    bodyParams["RemoteDomainName"] = input.RemoteDomainName;
  }
  return bodyParams;
};

const serializeAws_json1_1CreateDirectoryRequest = (
  input: CreateDirectoryRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Description !== undefined) {
    bodyParams["Description"] = input.Description;
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.Password !== undefined) {
    bodyParams["Password"] = input.Password;
  }
  if (input.ShortName !== undefined) {
    bodyParams["ShortName"] = input.ShortName;
  }
  if (input.Size !== undefined) {
    bodyParams["Size"] = input.Size;
  }
  if (input.Tags !== undefined) {
    bodyParams["Tags"] = serializeAws_json1_1Tags(input.Tags, context);
  }
  if (input.VpcSettings !== undefined) {
    bodyParams["VpcSettings"] = serializeAws_json1_1DirectoryVpcSettings(
      input.VpcSettings,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1CreateLogSubscriptionRequest = (
  input: CreateLogSubscriptionRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.DirectoryId !== undefined) {
    bodyParams["DirectoryId"] = input.DirectoryId;
  }
  if (input.LogGroupName !== undefined) {
    bodyParams["LogGroupName"] = input.LogGroupName;
  }
  return bodyParams;
};

const serializeAws_json1_1CreateMicrosoftADRequest = (
  input: CreateMicrosoftADRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Description !== undefined) {
    bodyParams["Description"] = input.Description;
  }
  if (input.Edition !== undefined) {
    bodyParams["Edition"] = input.Edition;
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.Password !== undefined) {
    bodyParams["Password"] = input.Password;
  }
  if (input.ShortName !== undefined) {
    bodyParams["ShortName"] = input.ShortName;
  }
  if (input.Tags !== undefined) {
    bodyParams["Tags"] = serializeAws_json1_1Tags(input.Tags, context);
  }
  if (input.VpcSettings !== undefined) {
    bodyParams["VpcSettings"] = serializeAws_json1_1DirectoryVpcSettings(
      input.VpcSettings,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1CreateSnapshotRequest = (
  input: CreateSnapshotRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.DirectoryId !== undefined) {
    bodyParams["DirectoryId"] = input.DirectoryId;
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  return bodyParams;
};

const serializeAws_json1_1CreateTrustRequest = (
  input: CreateTrustRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ConditionalForwarderIpAddrs !== undefined) {
    bodyParams["ConditionalForwarderIpAddrs"] = serializeAws_json1_1DnsIpAddrs(
      input.ConditionalForwarderIpAddrs,
      context
    );
  }
  if (input.DirectoryId !== undefined) {
    bodyParams["DirectoryId"] = input.DirectoryId;
  }
  if (input.RemoteDomainName !== undefined) {
    bodyParams["RemoteDomainName"] = input.RemoteDomainName;
  }
  if (input.SelectiveAuth !== undefined) {
    bodyParams["SelectiveAuth"] = input.SelectiveAuth;
  }
  if (input.TrustDirection !== undefined) {
    bodyParams["TrustDirection"] = input.TrustDirection;
  }
  if (input.TrustPassword !== undefined) {
    bodyParams["TrustPassword"] = input.TrustPassword;
  }
  if (input.TrustType !== undefined) {
    bodyParams["TrustType"] = input.TrustType;
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteConditionalForwarderRequest = (
  input: DeleteConditionalForwarderRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.DirectoryId !== undefined) {
    bodyParams["DirectoryId"] = input.DirectoryId;
  }
  if (input.RemoteDomainName !== undefined) {
    bodyParams["RemoteDomainName"] = input.RemoteDomainName;
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteDirectoryRequest = (
  input: DeleteDirectoryRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.DirectoryId !== undefined) {
    bodyParams["DirectoryId"] = input.DirectoryId;
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteLogSubscriptionRequest = (
  input: DeleteLogSubscriptionRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.DirectoryId !== undefined) {
    bodyParams["DirectoryId"] = input.DirectoryId;
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteSnapshotRequest = (
  input: DeleteSnapshotRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.SnapshotId !== undefined) {
    bodyParams["SnapshotId"] = input.SnapshotId;
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteTrustRequest = (
  input: DeleteTrustRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.DeleteAssociatedConditionalForwarder !== undefined) {
    bodyParams["DeleteAssociatedConditionalForwarder"] =
      input.DeleteAssociatedConditionalForwarder;
  }
  if (input.TrustId !== undefined) {
    bodyParams["TrustId"] = input.TrustId;
  }
  return bodyParams;
};

const serializeAws_json1_1DeregisterCertificateRequest = (
  input: DeregisterCertificateRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.CertificateId !== undefined) {
    bodyParams["CertificateId"] = input.CertificateId;
  }
  if (input.DirectoryId !== undefined) {
    bodyParams["DirectoryId"] = input.DirectoryId;
  }
  return bodyParams;
};

const serializeAws_json1_1DeregisterEventTopicRequest = (
  input: DeregisterEventTopicRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.DirectoryId !== undefined) {
    bodyParams["DirectoryId"] = input.DirectoryId;
  }
  if (input.TopicName !== undefined) {
    bodyParams["TopicName"] = input.TopicName;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeCertificateRequest = (
  input: DescribeCertificateRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.CertificateId !== undefined) {
    bodyParams["CertificateId"] = input.CertificateId;
  }
  if (input.DirectoryId !== undefined) {
    bodyParams["DirectoryId"] = input.DirectoryId;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeConditionalForwardersRequest = (
  input: DescribeConditionalForwardersRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.DirectoryId !== undefined) {
    bodyParams["DirectoryId"] = input.DirectoryId;
  }
  if (input.RemoteDomainNames !== undefined) {
    bodyParams["RemoteDomainNames"] = serializeAws_json1_1RemoteDomainNames(
      input.RemoteDomainNames,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeDirectoriesRequest = (
  input: DescribeDirectoriesRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.DirectoryIds !== undefined) {
    bodyParams["DirectoryIds"] = serializeAws_json1_1DirectoryIds(
      input.DirectoryIds,
      context
    );
  }
  if (input.Limit !== undefined) {
    bodyParams["Limit"] = input.Limit;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeDomainControllersRequest = (
  input: DescribeDomainControllersRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.DirectoryId !== undefined) {
    bodyParams["DirectoryId"] = input.DirectoryId;
  }
  if (input.DomainControllerIds !== undefined) {
    bodyParams["DomainControllerIds"] = serializeAws_json1_1DomainControllerIds(
      input.DomainControllerIds,
      context
    );
  }
  if (input.Limit !== undefined) {
    bodyParams["Limit"] = input.Limit;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeEventTopicsRequest = (
  input: DescribeEventTopicsRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.DirectoryId !== undefined) {
    bodyParams["DirectoryId"] = input.DirectoryId;
  }
  if (input.TopicNames !== undefined) {
    bodyParams["TopicNames"] = serializeAws_json1_1TopicNames(
      input.TopicNames,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeLDAPSSettingsRequest = (
  input: DescribeLDAPSSettingsRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.DirectoryId !== undefined) {
    bodyParams["DirectoryId"] = input.DirectoryId;
  }
  if (input.Limit !== undefined) {
    bodyParams["Limit"] = input.Limit;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  if (input.Type !== undefined) {
    bodyParams["Type"] = input.Type;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeSharedDirectoriesRequest = (
  input: DescribeSharedDirectoriesRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Limit !== undefined) {
    bodyParams["Limit"] = input.Limit;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  if (input.OwnerDirectoryId !== undefined) {
    bodyParams["OwnerDirectoryId"] = input.OwnerDirectoryId;
  }
  if (input.SharedDirectoryIds !== undefined) {
    bodyParams["SharedDirectoryIds"] = serializeAws_json1_1DirectoryIds(
      input.SharedDirectoryIds,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeSnapshotsRequest = (
  input: DescribeSnapshotsRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.DirectoryId !== undefined) {
    bodyParams["DirectoryId"] = input.DirectoryId;
  }
  if (input.Limit !== undefined) {
    bodyParams["Limit"] = input.Limit;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  if (input.SnapshotIds !== undefined) {
    bodyParams["SnapshotIds"] = serializeAws_json1_1SnapshotIds(
      input.SnapshotIds,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeTrustsRequest = (
  input: DescribeTrustsRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.DirectoryId !== undefined) {
    bodyParams["DirectoryId"] = input.DirectoryId;
  }
  if (input.Limit !== undefined) {
    bodyParams["Limit"] = input.Limit;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  if (input.TrustIds !== undefined) {
    bodyParams["TrustIds"] = serializeAws_json1_1TrustIds(
      input.TrustIds,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1DirectoryConnectSettings = (
  input: DirectoryConnectSettings,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.CustomerDnsIps !== undefined) {
    bodyParams["CustomerDnsIps"] = serializeAws_json1_1DnsIpAddrs(
      input.CustomerDnsIps,
      context
    );
  }
  if (input.CustomerUserName !== undefined) {
    bodyParams["CustomerUserName"] = input.CustomerUserName;
  }
  if (input.SubnetIds !== undefined) {
    bodyParams["SubnetIds"] = serializeAws_json1_1SubnetIds(
      input.SubnetIds,
      context
    );
  }
  if (input.VpcId !== undefined) {
    bodyParams["VpcId"] = input.VpcId;
  }
  return bodyParams;
};

const serializeAws_json1_1DirectoryIds = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry => entry);
};

const serializeAws_json1_1DirectoryVpcSettings = (
  input: DirectoryVpcSettings,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.SubnetIds !== undefined) {
    bodyParams["SubnetIds"] = serializeAws_json1_1SubnetIds(
      input.SubnetIds,
      context
    );
  }
  if (input.VpcId !== undefined) {
    bodyParams["VpcId"] = input.VpcId;
  }
  return bodyParams;
};

const serializeAws_json1_1DisableLDAPSRequest = (
  input: DisableLDAPSRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.DirectoryId !== undefined) {
    bodyParams["DirectoryId"] = input.DirectoryId;
  }
  if (input.Type !== undefined) {
    bodyParams["Type"] = input.Type;
  }
  return bodyParams;
};

const serializeAws_json1_1DisableRadiusRequest = (
  input: DisableRadiusRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.DirectoryId !== undefined) {
    bodyParams["DirectoryId"] = input.DirectoryId;
  }
  return bodyParams;
};

const serializeAws_json1_1DisableSsoRequest = (
  input: DisableSsoRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.DirectoryId !== undefined) {
    bodyParams["DirectoryId"] = input.DirectoryId;
  }
  if (input.Password !== undefined) {
    bodyParams["Password"] = input.Password;
  }
  if (input.UserName !== undefined) {
    bodyParams["UserName"] = input.UserName;
  }
  return bodyParams;
};

const serializeAws_json1_1DnsIpAddrs = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry => entry);
};

const serializeAws_json1_1DomainControllerIds = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry => entry);
};

const serializeAws_json1_1EnableLDAPSRequest = (
  input: EnableLDAPSRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.DirectoryId !== undefined) {
    bodyParams["DirectoryId"] = input.DirectoryId;
  }
  if (input.Type !== undefined) {
    bodyParams["Type"] = input.Type;
  }
  return bodyParams;
};

const serializeAws_json1_1EnableRadiusRequest = (
  input: EnableRadiusRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.DirectoryId !== undefined) {
    bodyParams["DirectoryId"] = input.DirectoryId;
  }
  if (input.RadiusSettings !== undefined) {
    bodyParams["RadiusSettings"] = serializeAws_json1_1RadiusSettings(
      input.RadiusSettings,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1EnableSsoRequest = (
  input: EnableSsoRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.DirectoryId !== undefined) {
    bodyParams["DirectoryId"] = input.DirectoryId;
  }
  if (input.Password !== undefined) {
    bodyParams["Password"] = input.Password;
  }
  if (input.UserName !== undefined) {
    bodyParams["UserName"] = input.UserName;
  }
  return bodyParams;
};

const serializeAws_json1_1GetDirectoryLimitsRequest = (
  input: GetDirectoryLimitsRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  return bodyParams;
};

const serializeAws_json1_1GetSnapshotLimitsRequest = (
  input: GetSnapshotLimitsRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.DirectoryId !== undefined) {
    bodyParams["DirectoryId"] = input.DirectoryId;
  }
  return bodyParams;
};

const serializeAws_json1_1IpRoute = (
  input: IpRoute,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.CidrIp !== undefined) {
    bodyParams["CidrIp"] = input.CidrIp;
  }
  if (input.Description !== undefined) {
    bodyParams["Description"] = input.Description;
  }
  return bodyParams;
};

const serializeAws_json1_1IpRoutes = (
  input: Array<IpRoute>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry =>
    serializeAws_json1_1IpRoute(entry, context)
  );
};

const serializeAws_json1_1ListCertificatesRequest = (
  input: ListCertificatesRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.DirectoryId !== undefined) {
    bodyParams["DirectoryId"] = input.DirectoryId;
  }
  if (input.Limit !== undefined) {
    bodyParams["Limit"] = input.Limit;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  return bodyParams;
};

const serializeAws_json1_1ListIpRoutesRequest = (
  input: ListIpRoutesRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.DirectoryId !== undefined) {
    bodyParams["DirectoryId"] = input.DirectoryId;
  }
  if (input.Limit !== undefined) {
    bodyParams["Limit"] = input.Limit;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  return bodyParams;
};

const serializeAws_json1_1ListLogSubscriptionsRequest = (
  input: ListLogSubscriptionsRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.DirectoryId !== undefined) {
    bodyParams["DirectoryId"] = input.DirectoryId;
  }
  if (input.Limit !== undefined) {
    bodyParams["Limit"] = input.Limit;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  return bodyParams;
};

const serializeAws_json1_1ListSchemaExtensionsRequest = (
  input: ListSchemaExtensionsRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.DirectoryId !== undefined) {
    bodyParams["DirectoryId"] = input.DirectoryId;
  }
  if (input.Limit !== undefined) {
    bodyParams["Limit"] = input.Limit;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  return bodyParams;
};

const serializeAws_json1_1ListTagsForResourceRequest = (
  input: ListTagsForResourceRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Limit !== undefined) {
    bodyParams["Limit"] = input.Limit;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  if (input.ResourceId !== undefined) {
    bodyParams["ResourceId"] = input.ResourceId;
  }
  return bodyParams;
};

const serializeAws_json1_1RadiusSettings = (
  input: RadiusSettings,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.AuthenticationProtocol !== undefined) {
    bodyParams["AuthenticationProtocol"] = input.AuthenticationProtocol;
  }
  if (input.DisplayLabel !== undefined) {
    bodyParams["DisplayLabel"] = input.DisplayLabel;
  }
  if (input.RadiusPort !== undefined) {
    bodyParams["RadiusPort"] = input.RadiusPort;
  }
  if (input.RadiusRetries !== undefined) {
    bodyParams["RadiusRetries"] = input.RadiusRetries;
  }
  if (input.RadiusServers !== undefined) {
    bodyParams["RadiusServers"] = serializeAws_json1_1Servers(
      input.RadiusServers,
      context
    );
  }
  if (input.RadiusTimeout !== undefined) {
    bodyParams["RadiusTimeout"] = input.RadiusTimeout;
  }
  if (input.SharedSecret !== undefined) {
    bodyParams["SharedSecret"] = input.SharedSecret;
  }
  if (input.UseSameUsername !== undefined) {
    bodyParams["UseSameUsername"] = input.UseSameUsername;
  }
  return bodyParams;
};

const serializeAws_json1_1RegisterCertificateRequest = (
  input: RegisterCertificateRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.CertificateData !== undefined) {
    bodyParams["CertificateData"] = input.CertificateData;
  }
  if (input.DirectoryId !== undefined) {
    bodyParams["DirectoryId"] = input.DirectoryId;
  }
  return bodyParams;
};

const serializeAws_json1_1RegisterEventTopicRequest = (
  input: RegisterEventTopicRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.DirectoryId !== undefined) {
    bodyParams["DirectoryId"] = input.DirectoryId;
  }
  if (input.TopicName !== undefined) {
    bodyParams["TopicName"] = input.TopicName;
  }
  return bodyParams;
};

const serializeAws_json1_1RejectSharedDirectoryRequest = (
  input: RejectSharedDirectoryRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.SharedDirectoryId !== undefined) {
    bodyParams["SharedDirectoryId"] = input.SharedDirectoryId;
  }
  return bodyParams;
};

const serializeAws_json1_1RemoteDomainNames = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry => entry);
};

const serializeAws_json1_1RemoveIpRoutesRequest = (
  input: RemoveIpRoutesRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.CidrIps !== undefined) {
    bodyParams["CidrIps"] = serializeAws_json1_1CidrIps(input.CidrIps, context);
  }
  if (input.DirectoryId !== undefined) {
    bodyParams["DirectoryId"] = input.DirectoryId;
  }
  return bodyParams;
};

const serializeAws_json1_1RemoveTagsFromResourceRequest = (
  input: RemoveTagsFromResourceRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ResourceId !== undefined) {
    bodyParams["ResourceId"] = input.ResourceId;
  }
  if (input.TagKeys !== undefined) {
    bodyParams["TagKeys"] = serializeAws_json1_1TagKeys(input.TagKeys, context);
  }
  return bodyParams;
};

const serializeAws_json1_1ResetUserPasswordRequest = (
  input: ResetUserPasswordRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.DirectoryId !== undefined) {
    bodyParams["DirectoryId"] = input.DirectoryId;
  }
  if (input.NewPassword !== undefined) {
    bodyParams["NewPassword"] = input.NewPassword;
  }
  if (input.UserName !== undefined) {
    bodyParams["UserName"] = input.UserName;
  }
  return bodyParams;
};

const serializeAws_json1_1RestoreFromSnapshotRequest = (
  input: RestoreFromSnapshotRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.SnapshotId !== undefined) {
    bodyParams["SnapshotId"] = input.SnapshotId;
  }
  return bodyParams;
};

const serializeAws_json1_1Servers = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry => entry);
};

const serializeAws_json1_1ShareDirectoryRequest = (
  input: ShareDirectoryRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.DirectoryId !== undefined) {
    bodyParams["DirectoryId"] = input.DirectoryId;
  }
  if (input.ShareMethod !== undefined) {
    bodyParams["ShareMethod"] = input.ShareMethod;
  }
  if (input.ShareNotes !== undefined) {
    bodyParams["ShareNotes"] = input.ShareNotes;
  }
  if (input.ShareTarget !== undefined) {
    bodyParams["ShareTarget"] = serializeAws_json1_1ShareTarget(
      input.ShareTarget,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1ShareTarget = (
  input: ShareTarget,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Id !== undefined) {
    bodyParams["Id"] = input.Id;
  }
  if (input.Type !== undefined) {
    bodyParams["Type"] = input.Type;
  }
  return bodyParams;
};

const serializeAws_json1_1SnapshotIds = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry => entry);
};

const serializeAws_json1_1StartSchemaExtensionRequest = (
  input: StartSchemaExtensionRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.CreateSnapshotBeforeSchemaExtension !== undefined) {
    bodyParams["CreateSnapshotBeforeSchemaExtension"] =
      input.CreateSnapshotBeforeSchemaExtension;
  }
  if (input.Description !== undefined) {
    bodyParams["Description"] = input.Description;
  }
  if (input.DirectoryId !== undefined) {
    bodyParams["DirectoryId"] = input.DirectoryId;
  }
  if (input.LdifContent !== undefined) {
    bodyParams["LdifContent"] = input.LdifContent;
  }
  return bodyParams;
};

const serializeAws_json1_1SubnetIds = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry => entry);
};

const serializeAws_json1_1Tag = (input: Tag, context: __SerdeContext): any => {
  const bodyParams: any = {};
  if (input.Key !== undefined) {
    bodyParams["Key"] = input.Key;
  }
  if (input.Value !== undefined) {
    bodyParams["Value"] = input.Value;
  }
  return bodyParams;
};

const serializeAws_json1_1TagKeys = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry => entry);
};

const serializeAws_json1_1Tags = (
  input: Array<Tag>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry => serializeAws_json1_1Tag(entry, context));
};

const serializeAws_json1_1TopicNames = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry => entry);
};

const serializeAws_json1_1TrustIds = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry => entry);
};

const serializeAws_json1_1UnshareDirectoryRequest = (
  input: UnshareDirectoryRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.DirectoryId !== undefined) {
    bodyParams["DirectoryId"] = input.DirectoryId;
  }
  if (input.UnshareTarget !== undefined) {
    bodyParams["UnshareTarget"] = serializeAws_json1_1UnshareTarget(
      input.UnshareTarget,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1UnshareTarget = (
  input: UnshareTarget,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Id !== undefined) {
    bodyParams["Id"] = input.Id;
  }
  if (input.Type !== undefined) {
    bodyParams["Type"] = input.Type;
  }
  return bodyParams;
};

const serializeAws_json1_1UpdateConditionalForwarderRequest = (
  input: UpdateConditionalForwarderRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.DirectoryId !== undefined) {
    bodyParams["DirectoryId"] = input.DirectoryId;
  }
  if (input.DnsIpAddrs !== undefined) {
    bodyParams["DnsIpAddrs"] = serializeAws_json1_1DnsIpAddrs(
      input.DnsIpAddrs,
      context
    );
  }
  if (input.RemoteDomainName !== undefined) {
    bodyParams["RemoteDomainName"] = input.RemoteDomainName;
  }
  return bodyParams;
};

const serializeAws_json1_1UpdateNumberOfDomainControllersRequest = (
  input: UpdateNumberOfDomainControllersRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.DesiredNumber !== undefined) {
    bodyParams["DesiredNumber"] = input.DesiredNumber;
  }
  if (input.DirectoryId !== undefined) {
    bodyParams["DirectoryId"] = input.DirectoryId;
  }
  return bodyParams;
};

const serializeAws_json1_1UpdateRadiusRequest = (
  input: UpdateRadiusRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.DirectoryId !== undefined) {
    bodyParams["DirectoryId"] = input.DirectoryId;
  }
  if (input.RadiusSettings !== undefined) {
    bodyParams["RadiusSettings"] = serializeAws_json1_1RadiusSettings(
      input.RadiusSettings,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1UpdateTrustRequest = (
  input: UpdateTrustRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.SelectiveAuth !== undefined) {
    bodyParams["SelectiveAuth"] = input.SelectiveAuth;
  }
  if (input.TrustId !== undefined) {
    bodyParams["TrustId"] = input.TrustId;
  }
  return bodyParams;
};

const serializeAws_json1_1VerifyTrustRequest = (
  input: VerifyTrustRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.TrustId !== undefined) {
    bodyParams["TrustId"] = input.TrustId;
  }
  return bodyParams;
};

const deserializeAws_json1_1AcceptSharedDirectoryResult = (
  output: any,
  context: __SerdeContext
): AcceptSharedDirectoryResult => {
  let contents: any = {
    __type: "AcceptSharedDirectoryResult",
    SharedDirectory: undefined
  };
  if (output.SharedDirectory !== undefined && output.SharedDirectory !== null) {
    contents.SharedDirectory = deserializeAws_json1_1SharedDirectory(
      output.SharedDirectory,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1AccessDeniedException = (
  output: any,
  context: __SerdeContext
): AccessDeniedException => {
  let contents: any = {
    __type: "AccessDeniedException",
    Message: undefined,
    RequestId: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  if (output.RequestId !== undefined && output.RequestId !== null) {
    contents.RequestId = output.RequestId;
  }
  return contents;
};

const deserializeAws_json1_1AddIpRoutesResult = (
  output: any,
  context: __SerdeContext
): AddIpRoutesResult => {
  let contents: any = {
    __type: "AddIpRoutesResult"
  };
  return contents;
};

const deserializeAws_json1_1AddTagsToResourceResult = (
  output: any,
  context: __SerdeContext
): AddTagsToResourceResult => {
  let contents: any = {
    __type: "AddTagsToResourceResult"
  };
  return contents;
};

const deserializeAws_json1_1Attribute = (
  output: any,
  context: __SerdeContext
): Attribute => {
  let contents: any = {
    __type: "Attribute",
    Name: undefined,
    Value: undefined
  };
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  if (output.Value !== undefined && output.Value !== null) {
    contents.Value = output.Value;
  }
  return contents;
};

const deserializeAws_json1_1Attributes = (
  output: any,
  context: __SerdeContext
): Array<Attribute> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1Attribute(entry, context)
  );
};

const deserializeAws_json1_1AuthenticationFailedException = (
  output: any,
  context: __SerdeContext
): AuthenticationFailedException => {
  let contents: any = {
    __type: "AuthenticationFailedException",
    Message: undefined,
    RequestId: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  if (output.RequestId !== undefined && output.RequestId !== null) {
    contents.RequestId = output.RequestId;
  }
  return contents;
};

const deserializeAws_json1_1AvailabilityZones = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1CancelSchemaExtensionResult = (
  output: any,
  context: __SerdeContext
): CancelSchemaExtensionResult => {
  let contents: any = {
    __type: "CancelSchemaExtensionResult"
  };
  return contents;
};

const deserializeAws_json1_1Certificate = (
  output: any,
  context: __SerdeContext
): Certificate => {
  let contents: any = {
    __type: "Certificate",
    CertificateId: undefined,
    CommonName: undefined,
    ExpiryDateTime: undefined,
    RegisteredDateTime: undefined,
    State: undefined,
    StateReason: undefined
  };
  if (output.CertificateId !== undefined && output.CertificateId !== null) {
    contents.CertificateId = output.CertificateId;
  }
  if (output.CommonName !== undefined && output.CommonName !== null) {
    contents.CommonName = output.CommonName;
  }
  if (output.ExpiryDateTime !== undefined && output.ExpiryDateTime !== null) {
    contents.ExpiryDateTime = new Date(
      Math.round(output.ExpiryDateTime * 1000)
    );
  }
  if (
    output.RegisteredDateTime !== undefined &&
    output.RegisteredDateTime !== null
  ) {
    contents.RegisteredDateTime = new Date(
      Math.round(output.RegisteredDateTime * 1000)
    );
  }
  if (output.State !== undefined && output.State !== null) {
    contents.State = output.State;
  }
  if (output.StateReason !== undefined && output.StateReason !== null) {
    contents.StateReason = output.StateReason;
  }
  return contents;
};

const deserializeAws_json1_1CertificateAlreadyExistsException = (
  output: any,
  context: __SerdeContext
): CertificateAlreadyExistsException => {
  let contents: any = {
    __type: "CertificateAlreadyExistsException",
    Message: undefined,
    RequestId: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  if (output.RequestId !== undefined && output.RequestId !== null) {
    contents.RequestId = output.RequestId;
  }
  return contents;
};

const deserializeAws_json1_1CertificateDoesNotExistException = (
  output: any,
  context: __SerdeContext
): CertificateDoesNotExistException => {
  let contents: any = {
    __type: "CertificateDoesNotExistException",
    Message: undefined,
    RequestId: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  if (output.RequestId !== undefined && output.RequestId !== null) {
    contents.RequestId = output.RequestId;
  }
  return contents;
};

const deserializeAws_json1_1CertificateInUseException = (
  output: any,
  context: __SerdeContext
): CertificateInUseException => {
  let contents: any = {
    __type: "CertificateInUseException",
    Message: undefined,
    RequestId: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  if (output.RequestId !== undefined && output.RequestId !== null) {
    contents.RequestId = output.RequestId;
  }
  return contents;
};

const deserializeAws_json1_1CertificateInfo = (
  output: any,
  context: __SerdeContext
): CertificateInfo => {
  let contents: any = {
    __type: "CertificateInfo",
    CertificateId: undefined,
    CommonName: undefined,
    State: undefined
  };
  if (output.CertificateId !== undefined && output.CertificateId !== null) {
    contents.CertificateId = output.CertificateId;
  }
  if (output.CommonName !== undefined && output.CommonName !== null) {
    contents.CommonName = output.CommonName;
  }
  if (output.State !== undefined && output.State !== null) {
    contents.State = output.State;
  }
  return contents;
};

const deserializeAws_json1_1CertificateLimitExceededException = (
  output: any,
  context: __SerdeContext
): CertificateLimitExceededException => {
  let contents: any = {
    __type: "CertificateLimitExceededException",
    Message: undefined,
    RequestId: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  if (output.RequestId !== undefined && output.RequestId !== null) {
    contents.RequestId = output.RequestId;
  }
  return contents;
};

const deserializeAws_json1_1CertificatesInfo = (
  output: any,
  context: __SerdeContext
): Array<CertificateInfo> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1CertificateInfo(entry, context)
  );
};

const deserializeAws_json1_1ClientException = (
  output: any,
  context: __SerdeContext
): ClientException => {
  let contents: any = {
    __type: "ClientException",
    Message: undefined,
    RequestId: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  if (output.RequestId !== undefined && output.RequestId !== null) {
    contents.RequestId = output.RequestId;
  }
  return contents;
};

const deserializeAws_json1_1Computer = (
  output: any,
  context: __SerdeContext
): Computer => {
  let contents: any = {
    __type: "Computer",
    ComputerAttributes: undefined,
    ComputerId: undefined,
    ComputerName: undefined
  };
  if (
    output.ComputerAttributes !== undefined &&
    output.ComputerAttributes !== null
  ) {
    contents.ComputerAttributes = deserializeAws_json1_1Attributes(
      output.ComputerAttributes,
      context
    );
  }
  if (output.ComputerId !== undefined && output.ComputerId !== null) {
    contents.ComputerId = output.ComputerId;
  }
  if (output.ComputerName !== undefined && output.ComputerName !== null) {
    contents.ComputerName = output.ComputerName;
  }
  return contents;
};

const deserializeAws_json1_1ConditionalForwarder = (
  output: any,
  context: __SerdeContext
): ConditionalForwarder => {
  let contents: any = {
    __type: "ConditionalForwarder",
    DnsIpAddrs: undefined,
    RemoteDomainName: undefined,
    ReplicationScope: undefined
  };
  if (output.DnsIpAddrs !== undefined && output.DnsIpAddrs !== null) {
    contents.DnsIpAddrs = deserializeAws_json1_1DnsIpAddrs(
      output.DnsIpAddrs,
      context
    );
  }
  if (
    output.RemoteDomainName !== undefined &&
    output.RemoteDomainName !== null
  ) {
    contents.RemoteDomainName = output.RemoteDomainName;
  }
  if (
    output.ReplicationScope !== undefined &&
    output.ReplicationScope !== null
  ) {
    contents.ReplicationScope = output.ReplicationScope;
  }
  return contents;
};

const deserializeAws_json1_1ConditionalForwarders = (
  output: any,
  context: __SerdeContext
): Array<ConditionalForwarder> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1ConditionalForwarder(entry, context)
  );
};

const deserializeAws_json1_1ConnectDirectoryResult = (
  output: any,
  context: __SerdeContext
): ConnectDirectoryResult => {
  let contents: any = {
    __type: "ConnectDirectoryResult",
    DirectoryId: undefined
  };
  if (output.DirectoryId !== undefined && output.DirectoryId !== null) {
    contents.DirectoryId = output.DirectoryId;
  }
  return contents;
};

const deserializeAws_json1_1CreateAliasResult = (
  output: any,
  context: __SerdeContext
): CreateAliasResult => {
  let contents: any = {
    __type: "CreateAliasResult",
    Alias: undefined,
    DirectoryId: undefined
  };
  if (output.Alias !== undefined && output.Alias !== null) {
    contents.Alias = output.Alias;
  }
  if (output.DirectoryId !== undefined && output.DirectoryId !== null) {
    contents.DirectoryId = output.DirectoryId;
  }
  return contents;
};

const deserializeAws_json1_1CreateComputerResult = (
  output: any,
  context: __SerdeContext
): CreateComputerResult => {
  let contents: any = {
    __type: "CreateComputerResult",
    Computer: undefined
  };
  if (output.Computer !== undefined && output.Computer !== null) {
    contents.Computer = deserializeAws_json1_1Computer(
      output.Computer,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1CreateConditionalForwarderResult = (
  output: any,
  context: __SerdeContext
): CreateConditionalForwarderResult => {
  let contents: any = {
    __type: "CreateConditionalForwarderResult"
  };
  return contents;
};

const deserializeAws_json1_1CreateDirectoryResult = (
  output: any,
  context: __SerdeContext
): CreateDirectoryResult => {
  let contents: any = {
    __type: "CreateDirectoryResult",
    DirectoryId: undefined
  };
  if (output.DirectoryId !== undefined && output.DirectoryId !== null) {
    contents.DirectoryId = output.DirectoryId;
  }
  return contents;
};

const deserializeAws_json1_1CreateLogSubscriptionResult = (
  output: any,
  context: __SerdeContext
): CreateLogSubscriptionResult => {
  let contents: any = {
    __type: "CreateLogSubscriptionResult"
  };
  return contents;
};

const deserializeAws_json1_1CreateMicrosoftADResult = (
  output: any,
  context: __SerdeContext
): CreateMicrosoftADResult => {
  let contents: any = {
    __type: "CreateMicrosoftADResult",
    DirectoryId: undefined
  };
  if (output.DirectoryId !== undefined && output.DirectoryId !== null) {
    contents.DirectoryId = output.DirectoryId;
  }
  return contents;
};

const deserializeAws_json1_1CreateSnapshotResult = (
  output: any,
  context: __SerdeContext
): CreateSnapshotResult => {
  let contents: any = {
    __type: "CreateSnapshotResult",
    SnapshotId: undefined
  };
  if (output.SnapshotId !== undefined && output.SnapshotId !== null) {
    contents.SnapshotId = output.SnapshotId;
  }
  return contents;
};

const deserializeAws_json1_1CreateTrustResult = (
  output: any,
  context: __SerdeContext
): CreateTrustResult => {
  let contents: any = {
    __type: "CreateTrustResult",
    TrustId: undefined
  };
  if (output.TrustId !== undefined && output.TrustId !== null) {
    contents.TrustId = output.TrustId;
  }
  return contents;
};

const deserializeAws_json1_1DeleteConditionalForwarderResult = (
  output: any,
  context: __SerdeContext
): DeleteConditionalForwarderResult => {
  let contents: any = {
    __type: "DeleteConditionalForwarderResult"
  };
  return contents;
};

const deserializeAws_json1_1DeleteDirectoryResult = (
  output: any,
  context: __SerdeContext
): DeleteDirectoryResult => {
  let contents: any = {
    __type: "DeleteDirectoryResult",
    DirectoryId: undefined
  };
  if (output.DirectoryId !== undefined && output.DirectoryId !== null) {
    contents.DirectoryId = output.DirectoryId;
  }
  return contents;
};

const deserializeAws_json1_1DeleteLogSubscriptionResult = (
  output: any,
  context: __SerdeContext
): DeleteLogSubscriptionResult => {
  let contents: any = {
    __type: "DeleteLogSubscriptionResult"
  };
  return contents;
};

const deserializeAws_json1_1DeleteSnapshotResult = (
  output: any,
  context: __SerdeContext
): DeleteSnapshotResult => {
  let contents: any = {
    __type: "DeleteSnapshotResult",
    SnapshotId: undefined
  };
  if (output.SnapshotId !== undefined && output.SnapshotId !== null) {
    contents.SnapshotId = output.SnapshotId;
  }
  return contents;
};

const deserializeAws_json1_1DeleteTrustResult = (
  output: any,
  context: __SerdeContext
): DeleteTrustResult => {
  let contents: any = {
    __type: "DeleteTrustResult",
    TrustId: undefined
  };
  if (output.TrustId !== undefined && output.TrustId !== null) {
    contents.TrustId = output.TrustId;
  }
  return contents;
};

const deserializeAws_json1_1DeregisterCertificateResult = (
  output: any,
  context: __SerdeContext
): DeregisterCertificateResult => {
  let contents: any = {
    __type: "DeregisterCertificateResult"
  };
  return contents;
};

const deserializeAws_json1_1DeregisterEventTopicResult = (
  output: any,
  context: __SerdeContext
): DeregisterEventTopicResult => {
  let contents: any = {
    __type: "DeregisterEventTopicResult"
  };
  return contents;
};

const deserializeAws_json1_1DescribeCertificateResult = (
  output: any,
  context: __SerdeContext
): DescribeCertificateResult => {
  let contents: any = {
    __type: "DescribeCertificateResult",
    Certificate: undefined
  };
  if (output.Certificate !== undefined && output.Certificate !== null) {
    contents.Certificate = deserializeAws_json1_1Certificate(
      output.Certificate,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DescribeConditionalForwardersResult = (
  output: any,
  context: __SerdeContext
): DescribeConditionalForwardersResult => {
  let contents: any = {
    __type: "DescribeConditionalForwardersResult",
    ConditionalForwarders: undefined
  };
  if (
    output.ConditionalForwarders !== undefined &&
    output.ConditionalForwarders !== null
  ) {
    contents.ConditionalForwarders = deserializeAws_json1_1ConditionalForwarders(
      output.ConditionalForwarders,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DescribeDirectoriesResult = (
  output: any,
  context: __SerdeContext
): DescribeDirectoriesResult => {
  let contents: any = {
    __type: "DescribeDirectoriesResult",
    DirectoryDescriptions: undefined,
    NextToken: undefined
  };
  if (
    output.DirectoryDescriptions !== undefined &&
    output.DirectoryDescriptions !== null
  ) {
    contents.DirectoryDescriptions = deserializeAws_json1_1DirectoryDescriptions(
      output.DirectoryDescriptions,
      context
    );
  }
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  return contents;
};

const deserializeAws_json1_1DescribeDomainControllersResult = (
  output: any,
  context: __SerdeContext
): DescribeDomainControllersResult => {
  let contents: any = {
    __type: "DescribeDomainControllersResult",
    DomainControllers: undefined,
    NextToken: undefined
  };
  if (
    output.DomainControllers !== undefined &&
    output.DomainControllers !== null
  ) {
    contents.DomainControllers = deserializeAws_json1_1DomainControllers(
      output.DomainControllers,
      context
    );
  }
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  return contents;
};

const deserializeAws_json1_1DescribeEventTopicsResult = (
  output: any,
  context: __SerdeContext
): DescribeEventTopicsResult => {
  let contents: any = {
    __type: "DescribeEventTopicsResult",
    EventTopics: undefined
  };
  if (output.EventTopics !== undefined && output.EventTopics !== null) {
    contents.EventTopics = deserializeAws_json1_1EventTopics(
      output.EventTopics,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DescribeLDAPSSettingsResult = (
  output: any,
  context: __SerdeContext
): DescribeLDAPSSettingsResult => {
  let contents: any = {
    __type: "DescribeLDAPSSettingsResult",
    LDAPSSettingsInfo: undefined,
    NextToken: undefined
  };
  if (
    output.LDAPSSettingsInfo !== undefined &&
    output.LDAPSSettingsInfo !== null
  ) {
    contents.LDAPSSettingsInfo = deserializeAws_json1_1LDAPSSettingsInfo(
      output.LDAPSSettingsInfo,
      context
    );
  }
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  return contents;
};

const deserializeAws_json1_1DescribeSharedDirectoriesResult = (
  output: any,
  context: __SerdeContext
): DescribeSharedDirectoriesResult => {
  let contents: any = {
    __type: "DescribeSharedDirectoriesResult",
    NextToken: undefined,
    SharedDirectories: undefined
  };
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  if (
    output.SharedDirectories !== undefined &&
    output.SharedDirectories !== null
  ) {
    contents.SharedDirectories = deserializeAws_json1_1SharedDirectories(
      output.SharedDirectories,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DescribeSnapshotsResult = (
  output: any,
  context: __SerdeContext
): DescribeSnapshotsResult => {
  let contents: any = {
    __type: "DescribeSnapshotsResult",
    NextToken: undefined,
    Snapshots: undefined
  };
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  if (output.Snapshots !== undefined && output.Snapshots !== null) {
    contents.Snapshots = deserializeAws_json1_1Snapshots(
      output.Snapshots,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DescribeTrustsResult = (
  output: any,
  context: __SerdeContext
): DescribeTrustsResult => {
  let contents: any = {
    __type: "DescribeTrustsResult",
    NextToken: undefined,
    Trusts: undefined
  };
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  if (output.Trusts !== undefined && output.Trusts !== null) {
    contents.Trusts = deserializeAws_json1_1Trusts(output.Trusts, context);
  }
  return contents;
};

const deserializeAws_json1_1DirectoryAlreadySharedException = (
  output: any,
  context: __SerdeContext
): DirectoryAlreadySharedException => {
  let contents: any = {
    __type: "DirectoryAlreadySharedException",
    Message: undefined,
    RequestId: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  if (output.RequestId !== undefined && output.RequestId !== null) {
    contents.RequestId = output.RequestId;
  }
  return contents;
};

const deserializeAws_json1_1DirectoryConnectSettingsDescription = (
  output: any,
  context: __SerdeContext
): DirectoryConnectSettingsDescription => {
  let contents: any = {
    __type: "DirectoryConnectSettingsDescription",
    AvailabilityZones: undefined,
    ConnectIps: undefined,
    CustomerUserName: undefined,
    SecurityGroupId: undefined,
    SubnetIds: undefined,
    VpcId: undefined
  };
  if (
    output.AvailabilityZones !== undefined &&
    output.AvailabilityZones !== null
  ) {
    contents.AvailabilityZones = deserializeAws_json1_1AvailabilityZones(
      output.AvailabilityZones,
      context
    );
  }
  if (output.ConnectIps !== undefined && output.ConnectIps !== null) {
    contents.ConnectIps = deserializeAws_json1_1IpAddrs(
      output.ConnectIps,
      context
    );
  }
  if (
    output.CustomerUserName !== undefined &&
    output.CustomerUserName !== null
  ) {
    contents.CustomerUserName = output.CustomerUserName;
  }
  if (output.SecurityGroupId !== undefined && output.SecurityGroupId !== null) {
    contents.SecurityGroupId = output.SecurityGroupId;
  }
  if (output.SubnetIds !== undefined && output.SubnetIds !== null) {
    contents.SubnetIds = deserializeAws_json1_1SubnetIds(
      output.SubnetIds,
      context
    );
  }
  if (output.VpcId !== undefined && output.VpcId !== null) {
    contents.VpcId = output.VpcId;
  }
  return contents;
};

const deserializeAws_json1_1DirectoryDescription = (
  output: any,
  context: __SerdeContext
): DirectoryDescription => {
  let contents: any = {
    __type: "DirectoryDescription",
    AccessUrl: undefined,
    Alias: undefined,
    ConnectSettings: undefined,
    Description: undefined,
    DesiredNumberOfDomainControllers: undefined,
    DirectoryId: undefined,
    DnsIpAddrs: undefined,
    Edition: undefined,
    LaunchTime: undefined,
    Name: undefined,
    OwnerDirectoryDescription: undefined,
    RadiusSettings: undefined,
    RadiusStatus: undefined,
    ShareMethod: undefined,
    ShareNotes: undefined,
    ShareStatus: undefined,
    ShortName: undefined,
    Size: undefined,
    SsoEnabled: undefined,
    Stage: undefined,
    StageLastUpdatedDateTime: undefined,
    StageReason: undefined,
    Type: undefined,
    VpcSettings: undefined
  };
  if (output.AccessUrl !== undefined && output.AccessUrl !== null) {
    contents.AccessUrl = output.AccessUrl;
  }
  if (output.Alias !== undefined && output.Alias !== null) {
    contents.Alias = output.Alias;
  }
  if (output.ConnectSettings !== undefined && output.ConnectSettings !== null) {
    contents.ConnectSettings = deserializeAws_json1_1DirectoryConnectSettingsDescription(
      output.ConnectSettings,
      context
    );
  }
  if (output.Description !== undefined && output.Description !== null) {
    contents.Description = output.Description;
  }
  if (
    output.DesiredNumberOfDomainControllers !== undefined &&
    output.DesiredNumberOfDomainControllers !== null
  ) {
    contents.DesiredNumberOfDomainControllers =
      output.DesiredNumberOfDomainControllers;
  }
  if (output.DirectoryId !== undefined && output.DirectoryId !== null) {
    contents.DirectoryId = output.DirectoryId;
  }
  if (output.DnsIpAddrs !== undefined && output.DnsIpAddrs !== null) {
    contents.DnsIpAddrs = deserializeAws_json1_1DnsIpAddrs(
      output.DnsIpAddrs,
      context
    );
  }
  if (output.Edition !== undefined && output.Edition !== null) {
    contents.Edition = output.Edition;
  }
  if (output.LaunchTime !== undefined && output.LaunchTime !== null) {
    contents.LaunchTime = new Date(Math.round(output.LaunchTime * 1000));
  }
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  if (
    output.OwnerDirectoryDescription !== undefined &&
    output.OwnerDirectoryDescription !== null
  ) {
    contents.OwnerDirectoryDescription = deserializeAws_json1_1OwnerDirectoryDescription(
      output.OwnerDirectoryDescription,
      context
    );
  }
  if (output.RadiusSettings !== undefined && output.RadiusSettings !== null) {
    contents.RadiusSettings = deserializeAws_json1_1RadiusSettings(
      output.RadiusSettings,
      context
    );
  }
  if (output.RadiusStatus !== undefined && output.RadiusStatus !== null) {
    contents.RadiusStatus = output.RadiusStatus;
  }
  if (output.ShareMethod !== undefined && output.ShareMethod !== null) {
    contents.ShareMethod = output.ShareMethod;
  }
  if (output.ShareNotes !== undefined && output.ShareNotes !== null) {
    contents.ShareNotes = output.ShareNotes;
  }
  if (output.ShareStatus !== undefined && output.ShareStatus !== null) {
    contents.ShareStatus = output.ShareStatus;
  }
  if (output.ShortName !== undefined && output.ShortName !== null) {
    contents.ShortName = output.ShortName;
  }
  if (output.Size !== undefined && output.Size !== null) {
    contents.Size = output.Size;
  }
  if (output.SsoEnabled !== undefined && output.SsoEnabled !== null) {
    contents.SsoEnabled = output.SsoEnabled;
  }
  if (output.Stage !== undefined && output.Stage !== null) {
    contents.Stage = output.Stage;
  }
  if (
    output.StageLastUpdatedDateTime !== undefined &&
    output.StageLastUpdatedDateTime !== null
  ) {
    contents.StageLastUpdatedDateTime = new Date(
      Math.round(output.StageLastUpdatedDateTime * 1000)
    );
  }
  if (output.StageReason !== undefined && output.StageReason !== null) {
    contents.StageReason = output.StageReason;
  }
  if (output.Type !== undefined && output.Type !== null) {
    contents.Type = output.Type;
  }
  if (output.VpcSettings !== undefined && output.VpcSettings !== null) {
    contents.VpcSettings = deserializeAws_json1_1DirectoryVpcSettingsDescription(
      output.VpcSettings,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DirectoryDescriptions = (
  output: any,
  context: __SerdeContext
): Array<DirectoryDescription> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1DirectoryDescription(entry, context)
  );
};

const deserializeAws_json1_1DirectoryDoesNotExistException = (
  output: any,
  context: __SerdeContext
): DirectoryDoesNotExistException => {
  let contents: any = {
    __type: "DirectoryDoesNotExistException",
    Message: undefined,
    RequestId: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  if (output.RequestId !== undefined && output.RequestId !== null) {
    contents.RequestId = output.RequestId;
  }
  return contents;
};

const deserializeAws_json1_1DirectoryLimitExceededException = (
  output: any,
  context: __SerdeContext
): DirectoryLimitExceededException => {
  let contents: any = {
    __type: "DirectoryLimitExceededException",
    Message: undefined,
    RequestId: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  if (output.RequestId !== undefined && output.RequestId !== null) {
    contents.RequestId = output.RequestId;
  }
  return contents;
};

const deserializeAws_json1_1DirectoryLimits = (
  output: any,
  context: __SerdeContext
): DirectoryLimits => {
  let contents: any = {
    __type: "DirectoryLimits",
    CloudOnlyDirectoriesCurrentCount: undefined,
    CloudOnlyDirectoriesLimit: undefined,
    CloudOnlyDirectoriesLimitReached: undefined,
    CloudOnlyMicrosoftADCurrentCount: undefined,
    CloudOnlyMicrosoftADLimit: undefined,
    CloudOnlyMicrosoftADLimitReached: undefined,
    ConnectedDirectoriesCurrentCount: undefined,
    ConnectedDirectoriesLimit: undefined,
    ConnectedDirectoriesLimitReached: undefined
  };
  if (
    output.CloudOnlyDirectoriesCurrentCount !== undefined &&
    output.CloudOnlyDirectoriesCurrentCount !== null
  ) {
    contents.CloudOnlyDirectoriesCurrentCount =
      output.CloudOnlyDirectoriesCurrentCount;
  }
  if (
    output.CloudOnlyDirectoriesLimit !== undefined &&
    output.CloudOnlyDirectoriesLimit !== null
  ) {
    contents.CloudOnlyDirectoriesLimit = output.CloudOnlyDirectoriesLimit;
  }
  if (
    output.CloudOnlyDirectoriesLimitReached !== undefined &&
    output.CloudOnlyDirectoriesLimitReached !== null
  ) {
    contents.CloudOnlyDirectoriesLimitReached =
      output.CloudOnlyDirectoriesLimitReached;
  }
  if (
    output.CloudOnlyMicrosoftADCurrentCount !== undefined &&
    output.CloudOnlyMicrosoftADCurrentCount !== null
  ) {
    contents.CloudOnlyMicrosoftADCurrentCount =
      output.CloudOnlyMicrosoftADCurrentCount;
  }
  if (
    output.CloudOnlyMicrosoftADLimit !== undefined &&
    output.CloudOnlyMicrosoftADLimit !== null
  ) {
    contents.CloudOnlyMicrosoftADLimit = output.CloudOnlyMicrosoftADLimit;
  }
  if (
    output.CloudOnlyMicrosoftADLimitReached !== undefined &&
    output.CloudOnlyMicrosoftADLimitReached !== null
  ) {
    contents.CloudOnlyMicrosoftADLimitReached =
      output.CloudOnlyMicrosoftADLimitReached;
  }
  if (
    output.ConnectedDirectoriesCurrentCount !== undefined &&
    output.ConnectedDirectoriesCurrentCount !== null
  ) {
    contents.ConnectedDirectoriesCurrentCount =
      output.ConnectedDirectoriesCurrentCount;
  }
  if (
    output.ConnectedDirectoriesLimit !== undefined &&
    output.ConnectedDirectoriesLimit !== null
  ) {
    contents.ConnectedDirectoriesLimit = output.ConnectedDirectoriesLimit;
  }
  if (
    output.ConnectedDirectoriesLimitReached !== undefined &&
    output.ConnectedDirectoriesLimitReached !== null
  ) {
    contents.ConnectedDirectoriesLimitReached =
      output.ConnectedDirectoriesLimitReached;
  }
  return contents;
};

const deserializeAws_json1_1DirectoryNotSharedException = (
  output: any,
  context: __SerdeContext
): DirectoryNotSharedException => {
  let contents: any = {
    __type: "DirectoryNotSharedException",
    Message: undefined,
    RequestId: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  if (output.RequestId !== undefined && output.RequestId !== null) {
    contents.RequestId = output.RequestId;
  }
  return contents;
};

const deserializeAws_json1_1DirectoryUnavailableException = (
  output: any,
  context: __SerdeContext
): DirectoryUnavailableException => {
  let contents: any = {
    __type: "DirectoryUnavailableException",
    Message: undefined,
    RequestId: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  if (output.RequestId !== undefined && output.RequestId !== null) {
    contents.RequestId = output.RequestId;
  }
  return contents;
};

const deserializeAws_json1_1DirectoryVpcSettingsDescription = (
  output: any,
  context: __SerdeContext
): DirectoryVpcSettingsDescription => {
  let contents: any = {
    __type: "DirectoryVpcSettingsDescription",
    AvailabilityZones: undefined,
    SecurityGroupId: undefined,
    SubnetIds: undefined,
    VpcId: undefined
  };
  if (
    output.AvailabilityZones !== undefined &&
    output.AvailabilityZones !== null
  ) {
    contents.AvailabilityZones = deserializeAws_json1_1AvailabilityZones(
      output.AvailabilityZones,
      context
    );
  }
  if (output.SecurityGroupId !== undefined && output.SecurityGroupId !== null) {
    contents.SecurityGroupId = output.SecurityGroupId;
  }
  if (output.SubnetIds !== undefined && output.SubnetIds !== null) {
    contents.SubnetIds = deserializeAws_json1_1SubnetIds(
      output.SubnetIds,
      context
    );
  }
  if (output.VpcId !== undefined && output.VpcId !== null) {
    contents.VpcId = output.VpcId;
  }
  return contents;
};

const deserializeAws_json1_1DisableLDAPSResult = (
  output: any,
  context: __SerdeContext
): DisableLDAPSResult => {
  let contents: any = {
    __type: "DisableLDAPSResult"
  };
  return contents;
};

const deserializeAws_json1_1DisableRadiusResult = (
  output: any,
  context: __SerdeContext
): DisableRadiusResult => {
  let contents: any = {
    __type: "DisableRadiusResult"
  };
  return contents;
};

const deserializeAws_json1_1DisableSsoResult = (
  output: any,
  context: __SerdeContext
): DisableSsoResult => {
  let contents: any = {
    __type: "DisableSsoResult"
  };
  return contents;
};

const deserializeAws_json1_1DnsIpAddrs = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1DomainController = (
  output: any,
  context: __SerdeContext
): DomainController => {
  let contents: any = {
    __type: "DomainController",
    AvailabilityZone: undefined,
    DirectoryId: undefined,
    DnsIpAddr: undefined,
    DomainControllerId: undefined,
    LaunchTime: undefined,
    Status: undefined,
    StatusLastUpdatedDateTime: undefined,
    StatusReason: undefined,
    SubnetId: undefined,
    VpcId: undefined
  };
  if (
    output.AvailabilityZone !== undefined &&
    output.AvailabilityZone !== null
  ) {
    contents.AvailabilityZone = output.AvailabilityZone;
  }
  if (output.DirectoryId !== undefined && output.DirectoryId !== null) {
    contents.DirectoryId = output.DirectoryId;
  }
  if (output.DnsIpAddr !== undefined && output.DnsIpAddr !== null) {
    contents.DnsIpAddr = output.DnsIpAddr;
  }
  if (
    output.DomainControllerId !== undefined &&
    output.DomainControllerId !== null
  ) {
    contents.DomainControllerId = output.DomainControllerId;
  }
  if (output.LaunchTime !== undefined && output.LaunchTime !== null) {
    contents.LaunchTime = new Date(Math.round(output.LaunchTime * 1000));
  }
  if (output.Status !== undefined && output.Status !== null) {
    contents.Status = output.Status;
  }
  if (
    output.StatusLastUpdatedDateTime !== undefined &&
    output.StatusLastUpdatedDateTime !== null
  ) {
    contents.StatusLastUpdatedDateTime = new Date(
      Math.round(output.StatusLastUpdatedDateTime * 1000)
    );
  }
  if (output.StatusReason !== undefined && output.StatusReason !== null) {
    contents.StatusReason = output.StatusReason;
  }
  if (output.SubnetId !== undefined && output.SubnetId !== null) {
    contents.SubnetId = output.SubnetId;
  }
  if (output.VpcId !== undefined && output.VpcId !== null) {
    contents.VpcId = output.VpcId;
  }
  return contents;
};

const deserializeAws_json1_1DomainControllerLimitExceededException = (
  output: any,
  context: __SerdeContext
): DomainControllerLimitExceededException => {
  let contents: any = {
    __type: "DomainControllerLimitExceededException",
    Message: undefined,
    RequestId: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  if (output.RequestId !== undefined && output.RequestId !== null) {
    contents.RequestId = output.RequestId;
  }
  return contents;
};

const deserializeAws_json1_1DomainControllers = (
  output: any,
  context: __SerdeContext
): Array<DomainController> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1DomainController(entry, context)
  );
};

const deserializeAws_json1_1EnableLDAPSResult = (
  output: any,
  context: __SerdeContext
): EnableLDAPSResult => {
  let contents: any = {
    __type: "EnableLDAPSResult"
  };
  return contents;
};

const deserializeAws_json1_1EnableRadiusResult = (
  output: any,
  context: __SerdeContext
): EnableRadiusResult => {
  let contents: any = {
    __type: "EnableRadiusResult"
  };
  return contents;
};

const deserializeAws_json1_1EnableSsoResult = (
  output: any,
  context: __SerdeContext
): EnableSsoResult => {
  let contents: any = {
    __type: "EnableSsoResult"
  };
  return contents;
};

const deserializeAws_json1_1EntityAlreadyExistsException = (
  output: any,
  context: __SerdeContext
): EntityAlreadyExistsException => {
  let contents: any = {
    __type: "EntityAlreadyExistsException",
    Message: undefined,
    RequestId: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  if (output.RequestId !== undefined && output.RequestId !== null) {
    contents.RequestId = output.RequestId;
  }
  return contents;
};

const deserializeAws_json1_1EntityDoesNotExistException = (
  output: any,
  context: __SerdeContext
): EntityDoesNotExistException => {
  let contents: any = {
    __type: "EntityDoesNotExistException",
    Message: undefined,
    RequestId: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  if (output.RequestId !== undefined && output.RequestId !== null) {
    contents.RequestId = output.RequestId;
  }
  return contents;
};

const deserializeAws_json1_1EventTopic = (
  output: any,
  context: __SerdeContext
): EventTopic => {
  let contents: any = {
    __type: "EventTopic",
    CreatedDateTime: undefined,
    DirectoryId: undefined,
    Status: undefined,
    TopicArn: undefined,
    TopicName: undefined
  };
  if (output.CreatedDateTime !== undefined && output.CreatedDateTime !== null) {
    contents.CreatedDateTime = new Date(
      Math.round(output.CreatedDateTime * 1000)
    );
  }
  if (output.DirectoryId !== undefined && output.DirectoryId !== null) {
    contents.DirectoryId = output.DirectoryId;
  }
  if (output.Status !== undefined && output.Status !== null) {
    contents.Status = output.Status;
  }
  if (output.TopicArn !== undefined && output.TopicArn !== null) {
    contents.TopicArn = output.TopicArn;
  }
  if (output.TopicName !== undefined && output.TopicName !== null) {
    contents.TopicName = output.TopicName;
  }
  return contents;
};

const deserializeAws_json1_1EventTopics = (
  output: any,
  context: __SerdeContext
): Array<EventTopic> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1EventTopic(entry, context)
  );
};

const deserializeAws_json1_1GetDirectoryLimitsResult = (
  output: any,
  context: __SerdeContext
): GetDirectoryLimitsResult => {
  let contents: any = {
    __type: "GetDirectoryLimitsResult",
    DirectoryLimits: undefined
  };
  if (output.DirectoryLimits !== undefined && output.DirectoryLimits !== null) {
    contents.DirectoryLimits = deserializeAws_json1_1DirectoryLimits(
      output.DirectoryLimits,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1GetSnapshotLimitsResult = (
  output: any,
  context: __SerdeContext
): GetSnapshotLimitsResult => {
  let contents: any = {
    __type: "GetSnapshotLimitsResult",
    SnapshotLimits: undefined
  };
  if (output.SnapshotLimits !== undefined && output.SnapshotLimits !== null) {
    contents.SnapshotLimits = deserializeAws_json1_1SnapshotLimits(
      output.SnapshotLimits,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1InsufficientPermissionsException = (
  output: any,
  context: __SerdeContext
): InsufficientPermissionsException => {
  let contents: any = {
    __type: "InsufficientPermissionsException",
    Message: undefined,
    RequestId: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  if (output.RequestId !== undefined && output.RequestId !== null) {
    contents.RequestId = output.RequestId;
  }
  return contents;
};

const deserializeAws_json1_1InvalidCertificateException = (
  output: any,
  context: __SerdeContext
): InvalidCertificateException => {
  let contents: any = {
    __type: "InvalidCertificateException",
    Message: undefined,
    RequestId: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  if (output.RequestId !== undefined && output.RequestId !== null) {
    contents.RequestId = output.RequestId;
  }
  return contents;
};

const deserializeAws_json1_1InvalidLDAPSStatusException = (
  output: any,
  context: __SerdeContext
): InvalidLDAPSStatusException => {
  let contents: any = {
    __type: "InvalidLDAPSStatusException",
    Message: undefined,
    RequestId: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  if (output.RequestId !== undefined && output.RequestId !== null) {
    contents.RequestId = output.RequestId;
  }
  return contents;
};

const deserializeAws_json1_1InvalidNextTokenException = (
  output: any,
  context: __SerdeContext
): InvalidNextTokenException => {
  let contents: any = {
    __type: "InvalidNextTokenException",
    Message: undefined,
    RequestId: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  if (output.RequestId !== undefined && output.RequestId !== null) {
    contents.RequestId = output.RequestId;
  }
  return contents;
};

const deserializeAws_json1_1InvalidParameterException = (
  output: any,
  context: __SerdeContext
): InvalidParameterException => {
  let contents: any = {
    __type: "InvalidParameterException",
    Message: undefined,
    RequestId: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  if (output.RequestId !== undefined && output.RequestId !== null) {
    contents.RequestId = output.RequestId;
  }
  return contents;
};

const deserializeAws_json1_1InvalidPasswordException = (
  output: any,
  context: __SerdeContext
): InvalidPasswordException => {
  let contents: any = {
    __type: "InvalidPasswordException",
    Message: undefined,
    RequestId: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  if (output.RequestId !== undefined && output.RequestId !== null) {
    contents.RequestId = output.RequestId;
  }
  return contents;
};

const deserializeAws_json1_1InvalidTargetException = (
  output: any,
  context: __SerdeContext
): InvalidTargetException => {
  let contents: any = {
    __type: "InvalidTargetException",
    Message: undefined,
    RequestId: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  if (output.RequestId !== undefined && output.RequestId !== null) {
    contents.RequestId = output.RequestId;
  }
  return contents;
};

const deserializeAws_json1_1IpAddrs = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1IpRouteInfo = (
  output: any,
  context: __SerdeContext
): IpRouteInfo => {
  let contents: any = {
    __type: "IpRouteInfo",
    AddedDateTime: undefined,
    CidrIp: undefined,
    Description: undefined,
    DirectoryId: undefined,
    IpRouteStatusMsg: undefined,
    IpRouteStatusReason: undefined
  };
  if (output.AddedDateTime !== undefined && output.AddedDateTime !== null) {
    contents.AddedDateTime = new Date(Math.round(output.AddedDateTime * 1000));
  }
  if (output.CidrIp !== undefined && output.CidrIp !== null) {
    contents.CidrIp = output.CidrIp;
  }
  if (output.Description !== undefined && output.Description !== null) {
    contents.Description = output.Description;
  }
  if (output.DirectoryId !== undefined && output.DirectoryId !== null) {
    contents.DirectoryId = output.DirectoryId;
  }
  if (
    output.IpRouteStatusMsg !== undefined &&
    output.IpRouteStatusMsg !== null
  ) {
    contents.IpRouteStatusMsg = output.IpRouteStatusMsg;
  }
  if (
    output.IpRouteStatusReason !== undefined &&
    output.IpRouteStatusReason !== null
  ) {
    contents.IpRouteStatusReason = output.IpRouteStatusReason;
  }
  return contents;
};

const deserializeAws_json1_1IpRouteLimitExceededException = (
  output: any,
  context: __SerdeContext
): IpRouteLimitExceededException => {
  let contents: any = {
    __type: "IpRouteLimitExceededException",
    Message: undefined,
    RequestId: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  if (output.RequestId !== undefined && output.RequestId !== null) {
    contents.RequestId = output.RequestId;
  }
  return contents;
};

const deserializeAws_json1_1IpRoutesInfo = (
  output: any,
  context: __SerdeContext
): Array<IpRouteInfo> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1IpRouteInfo(entry, context)
  );
};

const deserializeAws_json1_1LDAPSSettingInfo = (
  output: any,
  context: __SerdeContext
): LDAPSSettingInfo => {
  let contents: any = {
    __type: "LDAPSSettingInfo",
    LDAPSStatus: undefined,
    LDAPSStatusReason: undefined,
    LastUpdatedDateTime: undefined
  };
  if (output.LDAPSStatus !== undefined && output.LDAPSStatus !== null) {
    contents.LDAPSStatus = output.LDAPSStatus;
  }
  if (
    output.LDAPSStatusReason !== undefined &&
    output.LDAPSStatusReason !== null
  ) {
    contents.LDAPSStatusReason = output.LDAPSStatusReason;
  }
  if (
    output.LastUpdatedDateTime !== undefined &&
    output.LastUpdatedDateTime !== null
  ) {
    contents.LastUpdatedDateTime = new Date(
      Math.round(output.LastUpdatedDateTime * 1000)
    );
  }
  return contents;
};

const deserializeAws_json1_1LDAPSSettingsInfo = (
  output: any,
  context: __SerdeContext
): Array<LDAPSSettingInfo> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1LDAPSSettingInfo(entry, context)
  );
};

const deserializeAws_json1_1ListCertificatesResult = (
  output: any,
  context: __SerdeContext
): ListCertificatesResult => {
  let contents: any = {
    __type: "ListCertificatesResult",
    CertificatesInfo: undefined,
    NextToken: undefined
  };
  if (
    output.CertificatesInfo !== undefined &&
    output.CertificatesInfo !== null
  ) {
    contents.CertificatesInfo = deserializeAws_json1_1CertificatesInfo(
      output.CertificatesInfo,
      context
    );
  }
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  return contents;
};

const deserializeAws_json1_1ListIpRoutesResult = (
  output: any,
  context: __SerdeContext
): ListIpRoutesResult => {
  let contents: any = {
    __type: "ListIpRoutesResult",
    IpRoutesInfo: undefined,
    NextToken: undefined
  };
  if (output.IpRoutesInfo !== undefined && output.IpRoutesInfo !== null) {
    contents.IpRoutesInfo = deserializeAws_json1_1IpRoutesInfo(
      output.IpRoutesInfo,
      context
    );
  }
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  return contents;
};

const deserializeAws_json1_1ListLogSubscriptionsResult = (
  output: any,
  context: __SerdeContext
): ListLogSubscriptionsResult => {
  let contents: any = {
    __type: "ListLogSubscriptionsResult",
    LogSubscriptions: undefined,
    NextToken: undefined
  };
  if (
    output.LogSubscriptions !== undefined &&
    output.LogSubscriptions !== null
  ) {
    contents.LogSubscriptions = deserializeAws_json1_1LogSubscriptions(
      output.LogSubscriptions,
      context
    );
  }
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  return contents;
};

const deserializeAws_json1_1ListSchemaExtensionsResult = (
  output: any,
  context: __SerdeContext
): ListSchemaExtensionsResult => {
  let contents: any = {
    __type: "ListSchemaExtensionsResult",
    NextToken: undefined,
    SchemaExtensionsInfo: undefined
  };
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  if (
    output.SchemaExtensionsInfo !== undefined &&
    output.SchemaExtensionsInfo !== null
  ) {
    contents.SchemaExtensionsInfo = deserializeAws_json1_1SchemaExtensionsInfo(
      output.SchemaExtensionsInfo,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1ListTagsForResourceResult = (
  output: any,
  context: __SerdeContext
): ListTagsForResourceResult => {
  let contents: any = {
    __type: "ListTagsForResourceResult",
    NextToken: undefined,
    Tags: undefined
  };
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  if (output.Tags !== undefined && output.Tags !== null) {
    contents.Tags = deserializeAws_json1_1Tags(output.Tags, context);
  }
  return contents;
};

const deserializeAws_json1_1LogSubscription = (
  output: any,
  context: __SerdeContext
): LogSubscription => {
  let contents: any = {
    __type: "LogSubscription",
    DirectoryId: undefined,
    LogGroupName: undefined,
    SubscriptionCreatedDateTime: undefined
  };
  if (output.DirectoryId !== undefined && output.DirectoryId !== null) {
    contents.DirectoryId = output.DirectoryId;
  }
  if (output.LogGroupName !== undefined && output.LogGroupName !== null) {
    contents.LogGroupName = output.LogGroupName;
  }
  if (
    output.SubscriptionCreatedDateTime !== undefined &&
    output.SubscriptionCreatedDateTime !== null
  ) {
    contents.SubscriptionCreatedDateTime = new Date(
      Math.round(output.SubscriptionCreatedDateTime * 1000)
    );
  }
  return contents;
};

const deserializeAws_json1_1LogSubscriptions = (
  output: any,
  context: __SerdeContext
): Array<LogSubscription> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1LogSubscription(entry, context)
  );
};

const deserializeAws_json1_1NoAvailableCertificateException = (
  output: any,
  context: __SerdeContext
): NoAvailableCertificateException => {
  let contents: any = {
    __type: "NoAvailableCertificateException",
    Message: undefined,
    RequestId: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  if (output.RequestId !== undefined && output.RequestId !== null) {
    contents.RequestId = output.RequestId;
  }
  return contents;
};

const deserializeAws_json1_1OrganizationsException = (
  output: any,
  context: __SerdeContext
): OrganizationsException => {
  let contents: any = {
    __type: "OrganizationsException",
    Message: undefined,
    RequestId: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  if (output.RequestId !== undefined && output.RequestId !== null) {
    contents.RequestId = output.RequestId;
  }
  return contents;
};

const deserializeAws_json1_1OwnerDirectoryDescription = (
  output: any,
  context: __SerdeContext
): OwnerDirectoryDescription => {
  let contents: any = {
    __type: "OwnerDirectoryDescription",
    AccountId: undefined,
    DirectoryId: undefined,
    DnsIpAddrs: undefined,
    RadiusSettings: undefined,
    RadiusStatus: undefined,
    VpcSettings: undefined
  };
  if (output.AccountId !== undefined && output.AccountId !== null) {
    contents.AccountId = output.AccountId;
  }
  if (output.DirectoryId !== undefined && output.DirectoryId !== null) {
    contents.DirectoryId = output.DirectoryId;
  }
  if (output.DnsIpAddrs !== undefined && output.DnsIpAddrs !== null) {
    contents.DnsIpAddrs = deserializeAws_json1_1DnsIpAddrs(
      output.DnsIpAddrs,
      context
    );
  }
  if (output.RadiusSettings !== undefined && output.RadiusSettings !== null) {
    contents.RadiusSettings = deserializeAws_json1_1RadiusSettings(
      output.RadiusSettings,
      context
    );
  }
  if (output.RadiusStatus !== undefined && output.RadiusStatus !== null) {
    contents.RadiusStatus = output.RadiusStatus;
  }
  if (output.VpcSettings !== undefined && output.VpcSettings !== null) {
    contents.VpcSettings = deserializeAws_json1_1DirectoryVpcSettingsDescription(
      output.VpcSettings,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1RadiusSettings = (
  output: any,
  context: __SerdeContext
): RadiusSettings => {
  let contents: any = {
    __type: "RadiusSettings",
    AuthenticationProtocol: undefined,
    DisplayLabel: undefined,
    RadiusPort: undefined,
    RadiusRetries: undefined,
    RadiusServers: undefined,
    RadiusTimeout: undefined,
    SharedSecret: undefined,
    UseSameUsername: undefined
  };
  if (
    output.AuthenticationProtocol !== undefined &&
    output.AuthenticationProtocol !== null
  ) {
    contents.AuthenticationProtocol = output.AuthenticationProtocol;
  }
  if (output.DisplayLabel !== undefined && output.DisplayLabel !== null) {
    contents.DisplayLabel = output.DisplayLabel;
  }
  if (output.RadiusPort !== undefined && output.RadiusPort !== null) {
    contents.RadiusPort = output.RadiusPort;
  }
  if (output.RadiusRetries !== undefined && output.RadiusRetries !== null) {
    contents.RadiusRetries = output.RadiusRetries;
  }
  if (output.RadiusServers !== undefined && output.RadiusServers !== null) {
    contents.RadiusServers = deserializeAws_json1_1Servers(
      output.RadiusServers,
      context
    );
  }
  if (output.RadiusTimeout !== undefined && output.RadiusTimeout !== null) {
    contents.RadiusTimeout = output.RadiusTimeout;
  }
  if (output.SharedSecret !== undefined && output.SharedSecret !== null) {
    contents.SharedSecret = output.SharedSecret;
  }
  if (output.UseSameUsername !== undefined && output.UseSameUsername !== null) {
    contents.UseSameUsername = output.UseSameUsername;
  }
  return contents;
};

const deserializeAws_json1_1RegisterCertificateResult = (
  output: any,
  context: __SerdeContext
): RegisterCertificateResult => {
  let contents: any = {
    __type: "RegisterCertificateResult",
    CertificateId: undefined
  };
  if (output.CertificateId !== undefined && output.CertificateId !== null) {
    contents.CertificateId = output.CertificateId;
  }
  return contents;
};

const deserializeAws_json1_1RegisterEventTopicResult = (
  output: any,
  context: __SerdeContext
): RegisterEventTopicResult => {
  let contents: any = {
    __type: "RegisterEventTopicResult"
  };
  return contents;
};

const deserializeAws_json1_1RejectSharedDirectoryResult = (
  output: any,
  context: __SerdeContext
): RejectSharedDirectoryResult => {
  let contents: any = {
    __type: "RejectSharedDirectoryResult",
    SharedDirectoryId: undefined
  };
  if (
    output.SharedDirectoryId !== undefined &&
    output.SharedDirectoryId !== null
  ) {
    contents.SharedDirectoryId = output.SharedDirectoryId;
  }
  return contents;
};

const deserializeAws_json1_1RemoveIpRoutesResult = (
  output: any,
  context: __SerdeContext
): RemoveIpRoutesResult => {
  let contents: any = {
    __type: "RemoveIpRoutesResult"
  };
  return contents;
};

const deserializeAws_json1_1RemoveTagsFromResourceResult = (
  output: any,
  context: __SerdeContext
): RemoveTagsFromResourceResult => {
  let contents: any = {
    __type: "RemoveTagsFromResourceResult"
  };
  return contents;
};

const deserializeAws_json1_1ResetUserPasswordResult = (
  output: any,
  context: __SerdeContext
): ResetUserPasswordResult => {
  let contents: any = {
    __type: "ResetUserPasswordResult"
  };
  return contents;
};

const deserializeAws_json1_1RestoreFromSnapshotResult = (
  output: any,
  context: __SerdeContext
): RestoreFromSnapshotResult => {
  let contents: any = {
    __type: "RestoreFromSnapshotResult"
  };
  return contents;
};

const deserializeAws_json1_1SchemaExtensionInfo = (
  output: any,
  context: __SerdeContext
): SchemaExtensionInfo => {
  let contents: any = {
    __type: "SchemaExtensionInfo",
    Description: undefined,
    DirectoryId: undefined,
    EndDateTime: undefined,
    SchemaExtensionId: undefined,
    SchemaExtensionStatus: undefined,
    SchemaExtensionStatusReason: undefined,
    StartDateTime: undefined
  };
  if (output.Description !== undefined && output.Description !== null) {
    contents.Description = output.Description;
  }
  if (output.DirectoryId !== undefined && output.DirectoryId !== null) {
    contents.DirectoryId = output.DirectoryId;
  }
  if (output.EndDateTime !== undefined && output.EndDateTime !== null) {
    contents.EndDateTime = new Date(Math.round(output.EndDateTime * 1000));
  }
  if (
    output.SchemaExtensionId !== undefined &&
    output.SchemaExtensionId !== null
  ) {
    contents.SchemaExtensionId = output.SchemaExtensionId;
  }
  if (
    output.SchemaExtensionStatus !== undefined &&
    output.SchemaExtensionStatus !== null
  ) {
    contents.SchemaExtensionStatus = output.SchemaExtensionStatus;
  }
  if (
    output.SchemaExtensionStatusReason !== undefined &&
    output.SchemaExtensionStatusReason !== null
  ) {
    contents.SchemaExtensionStatusReason = output.SchemaExtensionStatusReason;
  }
  if (output.StartDateTime !== undefined && output.StartDateTime !== null) {
    contents.StartDateTime = new Date(Math.round(output.StartDateTime * 1000));
  }
  return contents;
};

const deserializeAws_json1_1SchemaExtensionsInfo = (
  output: any,
  context: __SerdeContext
): Array<SchemaExtensionInfo> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1SchemaExtensionInfo(entry, context)
  );
};

const deserializeAws_json1_1Servers = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1ServiceException = (
  output: any,
  context: __SerdeContext
): ServiceException => {
  let contents: any = {
    __type: "ServiceException",
    Message: undefined,
    RequestId: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  if (output.RequestId !== undefined && output.RequestId !== null) {
    contents.RequestId = output.RequestId;
  }
  return contents;
};

const deserializeAws_json1_1ShareDirectoryResult = (
  output: any,
  context: __SerdeContext
): ShareDirectoryResult => {
  let contents: any = {
    __type: "ShareDirectoryResult",
    SharedDirectoryId: undefined
  };
  if (
    output.SharedDirectoryId !== undefined &&
    output.SharedDirectoryId !== null
  ) {
    contents.SharedDirectoryId = output.SharedDirectoryId;
  }
  return contents;
};

const deserializeAws_json1_1ShareLimitExceededException = (
  output: any,
  context: __SerdeContext
): ShareLimitExceededException => {
  let contents: any = {
    __type: "ShareLimitExceededException",
    Message: undefined,
    RequestId: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  if (output.RequestId !== undefined && output.RequestId !== null) {
    contents.RequestId = output.RequestId;
  }
  return contents;
};

const deserializeAws_json1_1SharedDirectories = (
  output: any,
  context: __SerdeContext
): Array<SharedDirectory> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1SharedDirectory(entry, context)
  );
};

const deserializeAws_json1_1SharedDirectory = (
  output: any,
  context: __SerdeContext
): SharedDirectory => {
  let contents: any = {
    __type: "SharedDirectory",
    CreatedDateTime: undefined,
    LastUpdatedDateTime: undefined,
    OwnerAccountId: undefined,
    OwnerDirectoryId: undefined,
    ShareMethod: undefined,
    ShareNotes: undefined,
    ShareStatus: undefined,
    SharedAccountId: undefined,
    SharedDirectoryId: undefined
  };
  if (output.CreatedDateTime !== undefined && output.CreatedDateTime !== null) {
    contents.CreatedDateTime = new Date(
      Math.round(output.CreatedDateTime * 1000)
    );
  }
  if (
    output.LastUpdatedDateTime !== undefined &&
    output.LastUpdatedDateTime !== null
  ) {
    contents.LastUpdatedDateTime = new Date(
      Math.round(output.LastUpdatedDateTime * 1000)
    );
  }
  if (output.OwnerAccountId !== undefined && output.OwnerAccountId !== null) {
    contents.OwnerAccountId = output.OwnerAccountId;
  }
  if (
    output.OwnerDirectoryId !== undefined &&
    output.OwnerDirectoryId !== null
  ) {
    contents.OwnerDirectoryId = output.OwnerDirectoryId;
  }
  if (output.ShareMethod !== undefined && output.ShareMethod !== null) {
    contents.ShareMethod = output.ShareMethod;
  }
  if (output.ShareNotes !== undefined && output.ShareNotes !== null) {
    contents.ShareNotes = output.ShareNotes;
  }
  if (output.ShareStatus !== undefined && output.ShareStatus !== null) {
    contents.ShareStatus = output.ShareStatus;
  }
  if (output.SharedAccountId !== undefined && output.SharedAccountId !== null) {
    contents.SharedAccountId = output.SharedAccountId;
  }
  if (
    output.SharedDirectoryId !== undefined &&
    output.SharedDirectoryId !== null
  ) {
    contents.SharedDirectoryId = output.SharedDirectoryId;
  }
  return contents;
};

const deserializeAws_json1_1Snapshot = (
  output: any,
  context: __SerdeContext
): Snapshot => {
  let contents: any = {
    __type: "Snapshot",
    DirectoryId: undefined,
    Name: undefined,
    SnapshotId: undefined,
    StartTime: undefined,
    Status: undefined,
    Type: undefined
  };
  if (output.DirectoryId !== undefined && output.DirectoryId !== null) {
    contents.DirectoryId = output.DirectoryId;
  }
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  if (output.SnapshotId !== undefined && output.SnapshotId !== null) {
    contents.SnapshotId = output.SnapshotId;
  }
  if (output.StartTime !== undefined && output.StartTime !== null) {
    contents.StartTime = new Date(Math.round(output.StartTime * 1000));
  }
  if (output.Status !== undefined && output.Status !== null) {
    contents.Status = output.Status;
  }
  if (output.Type !== undefined && output.Type !== null) {
    contents.Type = output.Type;
  }
  return contents;
};

const deserializeAws_json1_1SnapshotLimitExceededException = (
  output: any,
  context: __SerdeContext
): SnapshotLimitExceededException => {
  let contents: any = {
    __type: "SnapshotLimitExceededException",
    Message: undefined,
    RequestId: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  if (output.RequestId !== undefined && output.RequestId !== null) {
    contents.RequestId = output.RequestId;
  }
  return contents;
};

const deserializeAws_json1_1SnapshotLimits = (
  output: any,
  context: __SerdeContext
): SnapshotLimits => {
  let contents: any = {
    __type: "SnapshotLimits",
    ManualSnapshotsCurrentCount: undefined,
    ManualSnapshotsLimit: undefined,
    ManualSnapshotsLimitReached: undefined
  };
  if (
    output.ManualSnapshotsCurrentCount !== undefined &&
    output.ManualSnapshotsCurrentCount !== null
  ) {
    contents.ManualSnapshotsCurrentCount = output.ManualSnapshotsCurrentCount;
  }
  if (
    output.ManualSnapshotsLimit !== undefined &&
    output.ManualSnapshotsLimit !== null
  ) {
    contents.ManualSnapshotsLimit = output.ManualSnapshotsLimit;
  }
  if (
    output.ManualSnapshotsLimitReached !== undefined &&
    output.ManualSnapshotsLimitReached !== null
  ) {
    contents.ManualSnapshotsLimitReached = output.ManualSnapshotsLimitReached;
  }
  return contents;
};

const deserializeAws_json1_1Snapshots = (
  output: any,
  context: __SerdeContext
): Array<Snapshot> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1Snapshot(entry, context)
  );
};

const deserializeAws_json1_1StartSchemaExtensionResult = (
  output: any,
  context: __SerdeContext
): StartSchemaExtensionResult => {
  let contents: any = {
    __type: "StartSchemaExtensionResult",
    SchemaExtensionId: undefined
  };
  if (
    output.SchemaExtensionId !== undefined &&
    output.SchemaExtensionId !== null
  ) {
    contents.SchemaExtensionId = output.SchemaExtensionId;
  }
  return contents;
};

const deserializeAws_json1_1SubnetIds = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1Tag = (
  output: any,
  context: __SerdeContext
): Tag => {
  let contents: any = {
    __type: "Tag",
    Key: undefined,
    Value: undefined
  };
  if (output.Key !== undefined && output.Key !== null) {
    contents.Key = output.Key;
  }
  if (output.Value !== undefined && output.Value !== null) {
    contents.Value = output.Value;
  }
  return contents;
};

const deserializeAws_json1_1TagLimitExceededException = (
  output: any,
  context: __SerdeContext
): TagLimitExceededException => {
  let contents: any = {
    __type: "TagLimitExceededException",
    Message: undefined,
    RequestId: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  if (output.RequestId !== undefined && output.RequestId !== null) {
    contents.RequestId = output.RequestId;
  }
  return contents;
};

const deserializeAws_json1_1Tags = (
  output: any,
  context: __SerdeContext
): Array<Tag> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1Tag(entry, context)
  );
};

const deserializeAws_json1_1Trust = (
  output: any,
  context: __SerdeContext
): Trust => {
  let contents: any = {
    __type: "Trust",
    CreatedDateTime: undefined,
    DirectoryId: undefined,
    LastUpdatedDateTime: undefined,
    RemoteDomainName: undefined,
    SelectiveAuth: undefined,
    StateLastUpdatedDateTime: undefined,
    TrustDirection: undefined,
    TrustId: undefined,
    TrustState: undefined,
    TrustStateReason: undefined,
    TrustType: undefined
  };
  if (output.CreatedDateTime !== undefined && output.CreatedDateTime !== null) {
    contents.CreatedDateTime = new Date(
      Math.round(output.CreatedDateTime * 1000)
    );
  }
  if (output.DirectoryId !== undefined && output.DirectoryId !== null) {
    contents.DirectoryId = output.DirectoryId;
  }
  if (
    output.LastUpdatedDateTime !== undefined &&
    output.LastUpdatedDateTime !== null
  ) {
    contents.LastUpdatedDateTime = new Date(
      Math.round(output.LastUpdatedDateTime * 1000)
    );
  }
  if (
    output.RemoteDomainName !== undefined &&
    output.RemoteDomainName !== null
  ) {
    contents.RemoteDomainName = output.RemoteDomainName;
  }
  if (output.SelectiveAuth !== undefined && output.SelectiveAuth !== null) {
    contents.SelectiveAuth = output.SelectiveAuth;
  }
  if (
    output.StateLastUpdatedDateTime !== undefined &&
    output.StateLastUpdatedDateTime !== null
  ) {
    contents.StateLastUpdatedDateTime = new Date(
      Math.round(output.StateLastUpdatedDateTime * 1000)
    );
  }
  if (output.TrustDirection !== undefined && output.TrustDirection !== null) {
    contents.TrustDirection = output.TrustDirection;
  }
  if (output.TrustId !== undefined && output.TrustId !== null) {
    contents.TrustId = output.TrustId;
  }
  if (output.TrustState !== undefined && output.TrustState !== null) {
    contents.TrustState = output.TrustState;
  }
  if (
    output.TrustStateReason !== undefined &&
    output.TrustStateReason !== null
  ) {
    contents.TrustStateReason = output.TrustStateReason;
  }
  if (output.TrustType !== undefined && output.TrustType !== null) {
    contents.TrustType = output.TrustType;
  }
  return contents;
};

const deserializeAws_json1_1Trusts = (
  output: any,
  context: __SerdeContext
): Array<Trust> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1Trust(entry, context)
  );
};

const deserializeAws_json1_1UnshareDirectoryResult = (
  output: any,
  context: __SerdeContext
): UnshareDirectoryResult => {
  let contents: any = {
    __type: "UnshareDirectoryResult",
    SharedDirectoryId: undefined
  };
  if (
    output.SharedDirectoryId !== undefined &&
    output.SharedDirectoryId !== null
  ) {
    contents.SharedDirectoryId = output.SharedDirectoryId;
  }
  return contents;
};

const deserializeAws_json1_1UnsupportedOperationException = (
  output: any,
  context: __SerdeContext
): UnsupportedOperationException => {
  let contents: any = {
    __type: "UnsupportedOperationException",
    Message: undefined,
    RequestId: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  if (output.RequestId !== undefined && output.RequestId !== null) {
    contents.RequestId = output.RequestId;
  }
  return contents;
};

const deserializeAws_json1_1UpdateConditionalForwarderResult = (
  output: any,
  context: __SerdeContext
): UpdateConditionalForwarderResult => {
  let contents: any = {
    __type: "UpdateConditionalForwarderResult"
  };
  return contents;
};

const deserializeAws_json1_1UpdateNumberOfDomainControllersResult = (
  output: any,
  context: __SerdeContext
): UpdateNumberOfDomainControllersResult => {
  let contents: any = {
    __type: "UpdateNumberOfDomainControllersResult"
  };
  return contents;
};

const deserializeAws_json1_1UpdateRadiusResult = (
  output: any,
  context: __SerdeContext
): UpdateRadiusResult => {
  let contents: any = {
    __type: "UpdateRadiusResult"
  };
  return contents;
};

const deserializeAws_json1_1UpdateTrustResult = (
  output: any,
  context: __SerdeContext
): UpdateTrustResult => {
  let contents: any = {
    __type: "UpdateTrustResult",
    RequestId: undefined,
    TrustId: undefined
  };
  if (output.RequestId !== undefined && output.RequestId !== null) {
    contents.RequestId = output.RequestId;
  }
  if (output.TrustId !== undefined && output.TrustId !== null) {
    contents.TrustId = output.TrustId;
  }
  return contents;
};

const deserializeAws_json1_1UserDoesNotExistException = (
  output: any,
  context: __SerdeContext
): UserDoesNotExistException => {
  let contents: any = {
    __type: "UserDoesNotExistException",
    Message: undefined,
    RequestId: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  if (output.RequestId !== undefined && output.RequestId !== null) {
    contents.RequestId = output.RequestId;
  }
  return contents;
};

const deserializeAws_json1_1VerifyTrustResult = (
  output: any,
  context: __SerdeContext
): VerifyTrustResult => {
  let contents: any = {
    __type: "VerifyTrustResult",
    TrustId: undefined
  };
  if (output.TrustId !== undefined && output.TrustId !== null) {
    contents.TrustId = output.TrustId;
  }
  return contents;
};

const deserializeMetadata = (output: __HttpResponse): __ResponseMetadata => ({
  httpStatusCode: output.statusCode,
  httpHeaders: output.headers,
  requestId: output.headers["x-amzn-requestid"]
});

// Collect low-level response body stream to Uint8Array.
const collectBody = (
  streamBody: any,
  context: __SerdeContext
): Promise<Uint8Array> => {
  return (
    context.streamCollector(streamBody) || Promise.resolve(new Uint8Array())
  );
};

// Encode Uint8Array data into string with utf-8.
const collectBodyString = (
  streamBody: any,
  context: __SerdeContext
): Promise<string> => {
  return collectBody(streamBody, context).then(body =>
    context.utf8Encoder(body)
  );
};

const buildHttpRpcRequest = (
  context: __SerdeContext,
  headers: __HeaderBag,
  path: string,
  resolvedHostname: string | undefined,
  body: any
): __HttpRequest => {
  const contents: any = {
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: path,
    headers: headers
  };
  if (resolvedHostname !== undefined) {
    contents.hostname = resolvedHostname;
  }
  if (body !== undefined) {
    contents.body = body;
  }
  return new __HttpRequest(contents);
};

const parseBody = (streamBody: any, context: __SerdeContext): any => {
  return collectBodyString(streamBody, context).then(encoded => {
    if (encoded.length) {
      return JSON.parse(encoded);
    }
    return {};
  });
};
