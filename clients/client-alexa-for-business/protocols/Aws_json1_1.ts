import {
  ApproveSkillCommandInput,
  ApproveSkillCommandOutput
} from "../commands/ApproveSkillCommand";
import {
  AssociateContactWithAddressBookCommandInput,
  AssociateContactWithAddressBookCommandOutput
} from "../commands/AssociateContactWithAddressBookCommand";
import {
  AssociateDeviceWithNetworkProfileCommandInput,
  AssociateDeviceWithNetworkProfileCommandOutput
} from "../commands/AssociateDeviceWithNetworkProfileCommand";
import {
  AssociateDeviceWithRoomCommandInput,
  AssociateDeviceWithRoomCommandOutput
} from "../commands/AssociateDeviceWithRoomCommand";
import {
  AssociateSkillGroupWithRoomCommandInput,
  AssociateSkillGroupWithRoomCommandOutput
} from "../commands/AssociateSkillGroupWithRoomCommand";
import {
  AssociateSkillWithSkillGroupCommandInput,
  AssociateSkillWithSkillGroupCommandOutput
} from "../commands/AssociateSkillWithSkillGroupCommand";
import {
  AssociateSkillWithUsersCommandInput,
  AssociateSkillWithUsersCommandOutput
} from "../commands/AssociateSkillWithUsersCommand";
import {
  CreateAddressBookCommandInput,
  CreateAddressBookCommandOutput
} from "../commands/CreateAddressBookCommand";
import {
  CreateBusinessReportScheduleCommandInput,
  CreateBusinessReportScheduleCommandOutput
} from "../commands/CreateBusinessReportScheduleCommand";
import {
  CreateConferenceProviderCommandInput,
  CreateConferenceProviderCommandOutput
} from "../commands/CreateConferenceProviderCommand";
import {
  CreateContactCommandInput,
  CreateContactCommandOutput
} from "../commands/CreateContactCommand";
import {
  CreateGatewayGroupCommandInput,
  CreateGatewayGroupCommandOutput
} from "../commands/CreateGatewayGroupCommand";
import {
  CreateNetworkProfileCommandInput,
  CreateNetworkProfileCommandOutput
} from "../commands/CreateNetworkProfileCommand";
import {
  CreateProfileCommandInput,
  CreateProfileCommandOutput
} from "../commands/CreateProfileCommand";
import {
  CreateRoomCommandInput,
  CreateRoomCommandOutput
} from "../commands/CreateRoomCommand";
import {
  CreateSkillGroupCommandInput,
  CreateSkillGroupCommandOutput
} from "../commands/CreateSkillGroupCommand";
import {
  CreateUserCommandInput,
  CreateUserCommandOutput
} from "../commands/CreateUserCommand";
import {
  DeleteAddressBookCommandInput,
  DeleteAddressBookCommandOutput
} from "../commands/DeleteAddressBookCommand";
import {
  DeleteBusinessReportScheduleCommandInput,
  DeleteBusinessReportScheduleCommandOutput
} from "../commands/DeleteBusinessReportScheduleCommand";
import {
  DeleteConferenceProviderCommandInput,
  DeleteConferenceProviderCommandOutput
} from "../commands/DeleteConferenceProviderCommand";
import {
  DeleteContactCommandInput,
  DeleteContactCommandOutput
} from "../commands/DeleteContactCommand";
import {
  DeleteDeviceCommandInput,
  DeleteDeviceCommandOutput
} from "../commands/DeleteDeviceCommand";
import {
  DeleteDeviceUsageDataCommandInput,
  DeleteDeviceUsageDataCommandOutput
} from "../commands/DeleteDeviceUsageDataCommand";
import {
  DeleteGatewayGroupCommandInput,
  DeleteGatewayGroupCommandOutput
} from "../commands/DeleteGatewayGroupCommand";
import {
  DeleteNetworkProfileCommandInput,
  DeleteNetworkProfileCommandOutput
} from "../commands/DeleteNetworkProfileCommand";
import {
  DeleteProfileCommandInput,
  DeleteProfileCommandOutput
} from "../commands/DeleteProfileCommand";
import {
  DeleteRoomCommandInput,
  DeleteRoomCommandOutput
} from "../commands/DeleteRoomCommand";
import {
  DeleteRoomSkillParameterCommandInput,
  DeleteRoomSkillParameterCommandOutput
} from "../commands/DeleteRoomSkillParameterCommand";
import {
  DeleteSkillAuthorizationCommandInput,
  DeleteSkillAuthorizationCommandOutput
} from "../commands/DeleteSkillAuthorizationCommand";
import {
  DeleteSkillGroupCommandInput,
  DeleteSkillGroupCommandOutput
} from "../commands/DeleteSkillGroupCommand";
import {
  DeleteUserCommandInput,
  DeleteUserCommandOutput
} from "../commands/DeleteUserCommand";
import {
  DisassociateContactFromAddressBookCommandInput,
  DisassociateContactFromAddressBookCommandOutput
} from "../commands/DisassociateContactFromAddressBookCommand";
import {
  DisassociateDeviceFromRoomCommandInput,
  DisassociateDeviceFromRoomCommandOutput
} from "../commands/DisassociateDeviceFromRoomCommand";
import {
  DisassociateSkillFromSkillGroupCommandInput,
  DisassociateSkillFromSkillGroupCommandOutput
} from "../commands/DisassociateSkillFromSkillGroupCommand";
import {
  DisassociateSkillFromUsersCommandInput,
  DisassociateSkillFromUsersCommandOutput
} from "../commands/DisassociateSkillFromUsersCommand";
import {
  DisassociateSkillGroupFromRoomCommandInput,
  DisassociateSkillGroupFromRoomCommandOutput
} from "../commands/DisassociateSkillGroupFromRoomCommand";
import {
  ForgetSmartHomeAppliancesCommandInput,
  ForgetSmartHomeAppliancesCommandOutput
} from "../commands/ForgetSmartHomeAppliancesCommand";
import {
  GetAddressBookCommandInput,
  GetAddressBookCommandOutput
} from "../commands/GetAddressBookCommand";
import {
  GetConferencePreferenceCommandInput,
  GetConferencePreferenceCommandOutput
} from "../commands/GetConferencePreferenceCommand";
import {
  GetConferenceProviderCommandInput,
  GetConferenceProviderCommandOutput
} from "../commands/GetConferenceProviderCommand";
import {
  GetContactCommandInput,
  GetContactCommandOutput
} from "../commands/GetContactCommand";
import {
  GetDeviceCommandInput,
  GetDeviceCommandOutput
} from "../commands/GetDeviceCommand";
import {
  GetGatewayCommandInput,
  GetGatewayCommandOutput
} from "../commands/GetGatewayCommand";
import {
  GetGatewayGroupCommandInput,
  GetGatewayGroupCommandOutput
} from "../commands/GetGatewayGroupCommand";
import {
  GetInvitationConfigurationCommandInput,
  GetInvitationConfigurationCommandOutput
} from "../commands/GetInvitationConfigurationCommand";
import {
  GetNetworkProfileCommandInput,
  GetNetworkProfileCommandOutput
} from "../commands/GetNetworkProfileCommand";
import {
  GetProfileCommandInput,
  GetProfileCommandOutput
} from "../commands/GetProfileCommand";
import {
  GetRoomCommandInput,
  GetRoomCommandOutput
} from "../commands/GetRoomCommand";
import {
  GetRoomSkillParameterCommandInput,
  GetRoomSkillParameterCommandOutput
} from "../commands/GetRoomSkillParameterCommand";
import {
  GetSkillGroupCommandInput,
  GetSkillGroupCommandOutput
} from "../commands/GetSkillGroupCommand";
import {
  ListBusinessReportSchedulesCommandInput,
  ListBusinessReportSchedulesCommandOutput
} from "../commands/ListBusinessReportSchedulesCommand";
import {
  ListConferenceProvidersCommandInput,
  ListConferenceProvidersCommandOutput
} from "../commands/ListConferenceProvidersCommand";
import {
  ListDeviceEventsCommandInput,
  ListDeviceEventsCommandOutput
} from "../commands/ListDeviceEventsCommand";
import {
  ListGatewayGroupsCommandInput,
  ListGatewayGroupsCommandOutput
} from "../commands/ListGatewayGroupsCommand";
import {
  ListGatewaysCommandInput,
  ListGatewaysCommandOutput
} from "../commands/ListGatewaysCommand";
import {
  ListSkillsCommandInput,
  ListSkillsCommandOutput
} from "../commands/ListSkillsCommand";
import {
  ListSkillsStoreCategoriesCommandInput,
  ListSkillsStoreCategoriesCommandOutput
} from "../commands/ListSkillsStoreCategoriesCommand";
import {
  ListSkillsStoreSkillsByCategoryCommandInput,
  ListSkillsStoreSkillsByCategoryCommandOutput
} from "../commands/ListSkillsStoreSkillsByCategoryCommand";
import {
  ListSmartHomeAppliancesCommandInput,
  ListSmartHomeAppliancesCommandOutput
} from "../commands/ListSmartHomeAppliancesCommand";
import {
  ListTagsCommandInput,
  ListTagsCommandOutput
} from "../commands/ListTagsCommand";
import {
  PutConferencePreferenceCommandInput,
  PutConferencePreferenceCommandOutput
} from "../commands/PutConferencePreferenceCommand";
import {
  PutInvitationConfigurationCommandInput,
  PutInvitationConfigurationCommandOutput
} from "../commands/PutInvitationConfigurationCommand";
import {
  PutRoomSkillParameterCommandInput,
  PutRoomSkillParameterCommandOutput
} from "../commands/PutRoomSkillParameterCommand";
import {
  PutSkillAuthorizationCommandInput,
  PutSkillAuthorizationCommandOutput
} from "../commands/PutSkillAuthorizationCommand";
import {
  RegisterAVSDeviceCommandInput,
  RegisterAVSDeviceCommandOutput
} from "../commands/RegisterAVSDeviceCommand";
import {
  RejectSkillCommandInput,
  RejectSkillCommandOutput
} from "../commands/RejectSkillCommand";
import {
  ResolveRoomCommandInput,
  ResolveRoomCommandOutput
} from "../commands/ResolveRoomCommand";
import {
  RevokeInvitationCommandInput,
  RevokeInvitationCommandOutput
} from "../commands/RevokeInvitationCommand";
import {
  SearchAddressBooksCommandInput,
  SearchAddressBooksCommandOutput
} from "../commands/SearchAddressBooksCommand";
import {
  SearchContactsCommandInput,
  SearchContactsCommandOutput
} from "../commands/SearchContactsCommand";
import {
  SearchDevicesCommandInput,
  SearchDevicesCommandOutput
} from "../commands/SearchDevicesCommand";
import {
  SearchNetworkProfilesCommandInput,
  SearchNetworkProfilesCommandOutput
} from "../commands/SearchNetworkProfilesCommand";
import {
  SearchProfilesCommandInput,
  SearchProfilesCommandOutput
} from "../commands/SearchProfilesCommand";
import {
  SearchRoomsCommandInput,
  SearchRoomsCommandOutput
} from "../commands/SearchRoomsCommand";
import {
  SearchSkillGroupsCommandInput,
  SearchSkillGroupsCommandOutput
} from "../commands/SearchSkillGroupsCommand";
import {
  SearchUsersCommandInput,
  SearchUsersCommandOutput
} from "../commands/SearchUsersCommand";
import {
  SendAnnouncementCommandInput,
  SendAnnouncementCommandOutput
} from "../commands/SendAnnouncementCommand";
import {
  SendInvitationCommandInput,
  SendInvitationCommandOutput
} from "../commands/SendInvitationCommand";
import {
  StartDeviceSyncCommandInput,
  StartDeviceSyncCommandOutput
} from "../commands/StartDeviceSyncCommand";
import {
  StartSmartHomeApplianceDiscoveryCommandInput,
  StartSmartHomeApplianceDiscoveryCommandOutput
} from "../commands/StartSmartHomeApplianceDiscoveryCommand";
import {
  TagResourceCommandInput,
  TagResourceCommandOutput
} from "../commands/TagResourceCommand";
import {
  UntagResourceCommandInput,
  UntagResourceCommandOutput
} from "../commands/UntagResourceCommand";
import {
  UpdateAddressBookCommandInput,
  UpdateAddressBookCommandOutput
} from "../commands/UpdateAddressBookCommand";
import {
  UpdateBusinessReportScheduleCommandInput,
  UpdateBusinessReportScheduleCommandOutput
} from "../commands/UpdateBusinessReportScheduleCommand";
import {
  UpdateConferenceProviderCommandInput,
  UpdateConferenceProviderCommandOutput
} from "../commands/UpdateConferenceProviderCommand";
import {
  UpdateContactCommandInput,
  UpdateContactCommandOutput
} from "../commands/UpdateContactCommand";
import {
  UpdateDeviceCommandInput,
  UpdateDeviceCommandOutput
} from "../commands/UpdateDeviceCommand";
import {
  UpdateGatewayCommandInput,
  UpdateGatewayCommandOutput
} from "../commands/UpdateGatewayCommand";
import {
  UpdateGatewayGroupCommandInput,
  UpdateGatewayGroupCommandOutput
} from "../commands/UpdateGatewayGroupCommand";
import {
  UpdateNetworkProfileCommandInput,
  UpdateNetworkProfileCommandOutput
} from "../commands/UpdateNetworkProfileCommand";
import {
  UpdateProfileCommandInput,
  UpdateProfileCommandOutput
} from "../commands/UpdateProfileCommand";
import {
  UpdateRoomCommandInput,
  UpdateRoomCommandOutput
} from "../commands/UpdateRoomCommand";
import {
  UpdateSkillGroupCommandInput,
  UpdateSkillGroupCommandOutput
} from "../commands/UpdateSkillGroupCommand";
import {
  AddressBook,
  AddressBookData,
  AlreadyExistsException,
  ApproveSkillRequest,
  ApproveSkillResponse,
  AssociateContactWithAddressBookRequest,
  AssociateContactWithAddressBookResponse,
  AssociateDeviceWithNetworkProfileRequest,
  AssociateDeviceWithNetworkProfileResponse,
  AssociateDeviceWithRoomRequest,
  AssociateDeviceWithRoomResponse,
  AssociateSkillGroupWithRoomRequest,
  AssociateSkillGroupWithRoomResponse,
  AssociateSkillWithSkillGroupRequest,
  AssociateSkillWithSkillGroupResponse,
  AssociateSkillWithUsersRequest,
  AssociateSkillWithUsersResponse,
  Audio,
  BusinessReport,
  BusinessReportContentRange,
  BusinessReportRecurrence,
  BusinessReportS3Location,
  BusinessReportSchedule,
  Category,
  ConcurrentModificationException,
  ConferencePreference,
  ConferenceProvider,
  Contact,
  ContactData,
  Content,
  CreateAddressBookRequest,
  CreateAddressBookResponse,
  CreateBusinessReportScheduleRequest,
  CreateBusinessReportScheduleResponse,
  CreateConferenceProviderRequest,
  CreateConferenceProviderResponse,
  CreateContactRequest,
  CreateContactResponse,
  CreateEndOfMeetingReminder,
  CreateGatewayGroupRequest,
  CreateGatewayGroupResponse,
  CreateInstantBooking,
  CreateMeetingRoomConfiguration,
  CreateNetworkProfileRequest,
  CreateNetworkProfileResponse,
  CreateProfileRequest,
  CreateProfileResponse,
  CreateRequireCheckIn,
  CreateRoomRequest,
  CreateRoomResponse,
  CreateSkillGroupRequest,
  CreateSkillGroupResponse,
  CreateUserRequest,
  CreateUserResponse,
  DeleteAddressBookRequest,
  DeleteAddressBookResponse,
  DeleteBusinessReportScheduleRequest,
  DeleteBusinessReportScheduleResponse,
  DeleteConferenceProviderRequest,
  DeleteConferenceProviderResponse,
  DeleteContactRequest,
  DeleteContactResponse,
  DeleteDeviceRequest,
  DeleteDeviceResponse,
  DeleteDeviceUsageDataRequest,
  DeleteDeviceUsageDataResponse,
  DeleteGatewayGroupRequest,
  DeleteGatewayGroupResponse,
  DeleteNetworkProfileRequest,
  DeleteNetworkProfileResponse,
  DeleteProfileRequest,
  DeleteProfileResponse,
  DeleteRoomRequest,
  DeleteRoomResponse,
  DeleteRoomSkillParameterRequest,
  DeleteRoomSkillParameterResponse,
  DeleteSkillAuthorizationRequest,
  DeleteSkillAuthorizationResponse,
  DeleteSkillGroupRequest,
  DeleteSkillGroupResponse,
  DeleteUserRequest,
  DeleteUserResponse,
  DeveloperInfo,
  Device,
  DeviceData,
  DeviceEvent,
  DeviceNetworkProfileInfo,
  DeviceNotRegisteredException,
  DeviceStatusDetail,
  DeviceStatusInfo,
  DisassociateContactFromAddressBookRequest,
  DisassociateContactFromAddressBookResponse,
  DisassociateDeviceFromRoomRequest,
  DisassociateDeviceFromRoomResponse,
  DisassociateSkillFromSkillGroupRequest,
  DisassociateSkillFromSkillGroupResponse,
  DisassociateSkillFromUsersRequest,
  DisassociateSkillFromUsersResponse,
  DisassociateSkillGroupFromRoomRequest,
  DisassociateSkillGroupFromRoomResponse,
  EndOfMeetingReminder,
  Feature,
  Filter,
  ForgetSmartHomeAppliancesRequest,
  ForgetSmartHomeAppliancesResponse,
  Gateway,
  GatewayGroup,
  GatewayGroupSummary,
  GatewaySummary,
  GetAddressBookRequest,
  GetAddressBookResponse,
  GetConferencePreferenceRequest,
  GetConferencePreferenceResponse,
  GetConferenceProviderRequest,
  GetConferenceProviderResponse,
  GetContactRequest,
  GetContactResponse,
  GetDeviceRequest,
  GetDeviceResponse,
  GetGatewayGroupRequest,
  GetGatewayGroupResponse,
  GetGatewayRequest,
  GetGatewayResponse,
  GetInvitationConfigurationRequest,
  GetInvitationConfigurationResponse,
  GetNetworkProfileRequest,
  GetNetworkProfileResponse,
  GetProfileRequest,
  GetProfileResponse,
  GetRoomRequest,
  GetRoomResponse,
  GetRoomSkillParameterRequest,
  GetRoomSkillParameterResponse,
  GetSkillGroupRequest,
  GetSkillGroupResponse,
  IPDialIn,
  InstantBooking,
  InvalidCertificateAuthorityException,
  InvalidDeviceException,
  InvalidSecretsManagerResourceException,
  InvalidServiceLinkedRoleStateException,
  InvalidUserStatusException,
  LimitExceededException,
  ListBusinessReportSchedulesRequest,
  ListBusinessReportSchedulesResponse,
  ListConferenceProvidersRequest,
  ListConferenceProvidersResponse,
  ListDeviceEventsRequest,
  ListDeviceEventsResponse,
  ListGatewayGroupsRequest,
  ListGatewayGroupsResponse,
  ListGatewaysRequest,
  ListGatewaysResponse,
  ListSkillsRequest,
  ListSkillsResponse,
  ListSkillsStoreCategoriesRequest,
  ListSkillsStoreCategoriesResponse,
  ListSkillsStoreSkillsByCategoryRequest,
  ListSkillsStoreSkillsByCategoryResponse,
  ListSmartHomeAppliancesRequest,
  ListSmartHomeAppliancesResponse,
  ListTagsRequest,
  ListTagsResponse,
  MeetingRoomConfiguration,
  MeetingSetting,
  NameInUseException,
  NetworkProfile,
  NetworkProfileData,
  NotFoundException,
  PSTNDialIn,
  PhoneNumber,
  Profile,
  ProfileData,
  PutConferencePreferenceRequest,
  PutConferencePreferenceResponse,
  PutInvitationConfigurationRequest,
  PutInvitationConfigurationResponse,
  PutRoomSkillParameterRequest,
  PutRoomSkillParameterResponse,
  PutSkillAuthorizationRequest,
  PutSkillAuthorizationResponse,
  RegisterAVSDeviceRequest,
  RegisterAVSDeviceResponse,
  RejectSkillRequest,
  RejectSkillResponse,
  RequireCheckIn,
  ResolveRoomRequest,
  ResolveRoomResponse,
  ResourceAssociatedException,
  ResourceInUseException,
  RevokeInvitationRequest,
  RevokeInvitationResponse,
  Room,
  RoomData,
  RoomSkillParameter,
  SearchAddressBooksRequest,
  SearchAddressBooksResponse,
  SearchContactsRequest,
  SearchContactsResponse,
  SearchDevicesRequest,
  SearchDevicesResponse,
  SearchNetworkProfilesRequest,
  SearchNetworkProfilesResponse,
  SearchProfilesRequest,
  SearchProfilesResponse,
  SearchRoomsRequest,
  SearchRoomsResponse,
  SearchSkillGroupsRequest,
  SearchSkillGroupsResponse,
  SearchUsersRequest,
  SearchUsersResponse,
  SendAnnouncementRequest,
  SendAnnouncementResponse,
  SendInvitationRequest,
  SendInvitationResponse,
  SipAddress,
  SkillDetails,
  SkillGroup,
  SkillGroupData,
  SkillNotLinkedException,
  SkillSummary,
  SkillsStoreSkill,
  SmartHomeAppliance,
  Sort,
  Ssml,
  StartDeviceSyncRequest,
  StartDeviceSyncResponse,
  StartSmartHomeApplianceDiscoveryRequest,
  StartSmartHomeApplianceDiscoveryResponse,
  Tag,
  TagResourceRequest,
  TagResourceResponse,
  Text,
  UnauthorizedException,
  UntagResourceRequest,
  UntagResourceResponse,
  UpdateAddressBookRequest,
  UpdateAddressBookResponse,
  UpdateBusinessReportScheduleRequest,
  UpdateBusinessReportScheduleResponse,
  UpdateConferenceProviderRequest,
  UpdateConferenceProviderResponse,
  UpdateContactRequest,
  UpdateContactResponse,
  UpdateDeviceRequest,
  UpdateDeviceResponse,
  UpdateEndOfMeetingReminder,
  UpdateGatewayGroupRequest,
  UpdateGatewayGroupResponse,
  UpdateGatewayRequest,
  UpdateGatewayResponse,
  UpdateInstantBooking,
  UpdateMeetingRoomConfiguration,
  UpdateNetworkProfileRequest,
  UpdateNetworkProfileResponse,
  UpdateProfileRequest,
  UpdateProfileResponse,
  UpdateRequireCheckIn,
  UpdateRoomRequest,
  UpdateRoomResponse,
  UpdateSkillGroupRequest,
  UpdateSkillGroupResponse,
  UserData
} from "../models/index";
import {
  HttpRequest as __HttpRequest,
  HttpResponse as __HttpResponse
} from "@aws-sdk/protocol-http";
import { SmithyException as __SmithyException } from "@aws-sdk/smithy-client";
import {
  Endpoint as __Endpoint,
  HeaderBag as __HeaderBag,
  MetadataBearer as __MetadataBearer,
  ResponseMetadata as __ResponseMetadata,
  SerdeContext as __SerdeContext
} from "@aws-sdk/types";
import { v4 as generateIdempotencyToken } from "uuid";

export async function serializeAws_json1_1SendAnnouncementCommand(
  input: SendAnnouncementCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AlexaForBusiness.SendAnnouncement";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1SendAnnouncementRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DeleteDeviceUsageDataCommand(
  input: DeleteDeviceUsageDataCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AlexaForBusiness.DeleteDeviceUsageData";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DeleteDeviceUsageDataRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1ApproveSkillCommand(
  input: ApproveSkillCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AlexaForBusiness.ApproveSkill";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1ApproveSkillRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1AssociateContactWithAddressBookCommand(
  input: AssociateContactWithAddressBookCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AlexaForBusiness.AssociateContactWithAddressBook";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1AssociateContactWithAddressBookRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1AssociateDeviceWithNetworkProfileCommand(
  input: AssociateDeviceWithNetworkProfileCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] =
    "AlexaForBusiness.AssociateDeviceWithNetworkProfile";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1AssociateDeviceWithNetworkProfileRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1AssociateDeviceWithRoomCommand(
  input: AssociateDeviceWithRoomCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AlexaForBusiness.AssociateDeviceWithRoom";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1AssociateDeviceWithRoomRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1AssociateSkillGroupWithRoomCommand(
  input: AssociateSkillGroupWithRoomCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AlexaForBusiness.AssociateSkillGroupWithRoom";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1AssociateSkillGroupWithRoomRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1AssociateSkillWithSkillGroupCommand(
  input: AssociateSkillWithSkillGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AlexaForBusiness.AssociateSkillWithSkillGroup";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1AssociateSkillWithSkillGroupRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1AssociateSkillWithUsersCommand(
  input: AssociateSkillWithUsersCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AlexaForBusiness.AssociateSkillWithUsers";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1AssociateSkillWithUsersRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1CreateAddressBookCommand(
  input: CreateAddressBookCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AlexaForBusiness.CreateAddressBook";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1CreateAddressBookRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1CreateBusinessReportScheduleCommand(
  input: CreateBusinessReportScheduleCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AlexaForBusiness.CreateBusinessReportSchedule";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1CreateBusinessReportScheduleRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1CreateConferenceProviderCommand(
  input: CreateConferenceProviderCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AlexaForBusiness.CreateConferenceProvider";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1CreateConferenceProviderRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1CreateContactCommand(
  input: CreateContactCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AlexaForBusiness.CreateContact";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1CreateContactRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1CreateGatewayGroupCommand(
  input: CreateGatewayGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AlexaForBusiness.CreateGatewayGroup";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1CreateGatewayGroupRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1CreateNetworkProfileCommand(
  input: CreateNetworkProfileCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AlexaForBusiness.CreateNetworkProfile";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1CreateNetworkProfileRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1CreateProfileCommand(
  input: CreateProfileCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AlexaForBusiness.CreateProfile";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1CreateProfileRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1CreateRoomCommand(
  input: CreateRoomCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AlexaForBusiness.CreateRoom";
  let body: any;
  body = JSON.stringify(serializeAws_json1_1CreateRoomRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1CreateSkillGroupCommand(
  input: CreateSkillGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AlexaForBusiness.CreateSkillGroup";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1CreateSkillGroupRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1CreateUserCommand(
  input: CreateUserCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AlexaForBusiness.CreateUser";
  let body: any;
  body = JSON.stringify(serializeAws_json1_1CreateUserRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DeleteAddressBookCommand(
  input: DeleteAddressBookCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AlexaForBusiness.DeleteAddressBook";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DeleteAddressBookRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DeleteBusinessReportScheduleCommand(
  input: DeleteBusinessReportScheduleCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AlexaForBusiness.DeleteBusinessReportSchedule";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DeleteBusinessReportScheduleRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DeleteConferenceProviderCommand(
  input: DeleteConferenceProviderCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AlexaForBusiness.DeleteConferenceProvider";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DeleteConferenceProviderRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DeleteContactCommand(
  input: DeleteContactCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AlexaForBusiness.DeleteContact";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DeleteContactRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DeleteDeviceCommand(
  input: DeleteDeviceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AlexaForBusiness.DeleteDevice";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DeleteDeviceRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DeleteGatewayGroupCommand(
  input: DeleteGatewayGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AlexaForBusiness.DeleteGatewayGroup";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DeleteGatewayGroupRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DeleteNetworkProfileCommand(
  input: DeleteNetworkProfileCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AlexaForBusiness.DeleteNetworkProfile";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DeleteNetworkProfileRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DeleteProfileCommand(
  input: DeleteProfileCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AlexaForBusiness.DeleteProfile";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DeleteProfileRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DeleteRoomCommand(
  input: DeleteRoomCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AlexaForBusiness.DeleteRoom";
  let body: any;
  body = JSON.stringify(serializeAws_json1_1DeleteRoomRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DeleteRoomSkillParameterCommand(
  input: DeleteRoomSkillParameterCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AlexaForBusiness.DeleteRoomSkillParameter";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DeleteRoomSkillParameterRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DeleteSkillAuthorizationCommand(
  input: DeleteSkillAuthorizationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AlexaForBusiness.DeleteSkillAuthorization";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DeleteSkillAuthorizationRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DeleteSkillGroupCommand(
  input: DeleteSkillGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AlexaForBusiness.DeleteSkillGroup";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DeleteSkillGroupRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DeleteUserCommand(
  input: DeleteUserCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AlexaForBusiness.DeleteUser";
  let body: any;
  body = JSON.stringify(serializeAws_json1_1DeleteUserRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DisassociateContactFromAddressBookCommand(
  input: DisassociateContactFromAddressBookCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] =
    "AlexaForBusiness.DisassociateContactFromAddressBook";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DisassociateContactFromAddressBookRequest(
      input,
      context
    )
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DisassociateDeviceFromRoomCommand(
  input: DisassociateDeviceFromRoomCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AlexaForBusiness.DisassociateDeviceFromRoom";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DisassociateDeviceFromRoomRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DisassociateSkillFromSkillGroupCommand(
  input: DisassociateSkillFromSkillGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AlexaForBusiness.DisassociateSkillFromSkillGroup";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DisassociateSkillFromSkillGroupRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DisassociateSkillFromUsersCommand(
  input: DisassociateSkillFromUsersCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AlexaForBusiness.DisassociateSkillFromUsers";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DisassociateSkillFromUsersRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DisassociateSkillGroupFromRoomCommand(
  input: DisassociateSkillGroupFromRoomCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AlexaForBusiness.DisassociateSkillGroupFromRoom";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DisassociateSkillGroupFromRoomRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1ForgetSmartHomeAppliancesCommand(
  input: ForgetSmartHomeAppliancesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AlexaForBusiness.ForgetSmartHomeAppliances";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1ForgetSmartHomeAppliancesRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1GetAddressBookCommand(
  input: GetAddressBookCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AlexaForBusiness.GetAddressBook";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1GetAddressBookRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1GetConferencePreferenceCommand(
  input: GetConferencePreferenceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AlexaForBusiness.GetConferencePreference";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1GetConferencePreferenceRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1GetConferenceProviderCommand(
  input: GetConferenceProviderCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AlexaForBusiness.GetConferenceProvider";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1GetConferenceProviderRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1GetContactCommand(
  input: GetContactCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AlexaForBusiness.GetContact";
  let body: any;
  body = JSON.stringify(serializeAws_json1_1GetContactRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1GetDeviceCommand(
  input: GetDeviceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AlexaForBusiness.GetDevice";
  let body: any;
  body = JSON.stringify(serializeAws_json1_1GetDeviceRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1GetGatewayCommand(
  input: GetGatewayCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AlexaForBusiness.GetGateway";
  let body: any;
  body = JSON.stringify(serializeAws_json1_1GetGatewayRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1GetGatewayGroupCommand(
  input: GetGatewayGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AlexaForBusiness.GetGatewayGroup";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1GetGatewayGroupRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1GetInvitationConfigurationCommand(
  input: GetInvitationConfigurationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AlexaForBusiness.GetInvitationConfiguration";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1GetInvitationConfigurationRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1GetNetworkProfileCommand(
  input: GetNetworkProfileCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AlexaForBusiness.GetNetworkProfile";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1GetNetworkProfileRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1GetProfileCommand(
  input: GetProfileCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AlexaForBusiness.GetProfile";
  let body: any;
  body = JSON.stringify(serializeAws_json1_1GetProfileRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1GetRoomCommand(
  input: GetRoomCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AlexaForBusiness.GetRoom";
  let body: any;
  body = JSON.stringify(serializeAws_json1_1GetRoomRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1GetRoomSkillParameterCommand(
  input: GetRoomSkillParameterCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AlexaForBusiness.GetRoomSkillParameter";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1GetRoomSkillParameterRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1GetSkillGroupCommand(
  input: GetSkillGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AlexaForBusiness.GetSkillGroup";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1GetSkillGroupRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1ListBusinessReportSchedulesCommand(
  input: ListBusinessReportSchedulesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AlexaForBusiness.ListBusinessReportSchedules";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1ListBusinessReportSchedulesRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1ListConferenceProvidersCommand(
  input: ListConferenceProvidersCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AlexaForBusiness.ListConferenceProviders";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1ListConferenceProvidersRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1ListDeviceEventsCommand(
  input: ListDeviceEventsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AlexaForBusiness.ListDeviceEvents";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1ListDeviceEventsRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1ListGatewayGroupsCommand(
  input: ListGatewayGroupsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AlexaForBusiness.ListGatewayGroups";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1ListGatewayGroupsRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1ListGatewaysCommand(
  input: ListGatewaysCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AlexaForBusiness.ListGateways";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1ListGatewaysRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1ListSkillsCommand(
  input: ListSkillsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AlexaForBusiness.ListSkills";
  let body: any;
  body = JSON.stringify(serializeAws_json1_1ListSkillsRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1ListSkillsStoreCategoriesCommand(
  input: ListSkillsStoreCategoriesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AlexaForBusiness.ListSkillsStoreCategories";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1ListSkillsStoreCategoriesRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1ListSkillsStoreSkillsByCategoryCommand(
  input: ListSkillsStoreSkillsByCategoryCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AlexaForBusiness.ListSkillsStoreSkillsByCategory";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1ListSkillsStoreSkillsByCategoryRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1ListSmartHomeAppliancesCommand(
  input: ListSmartHomeAppliancesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AlexaForBusiness.ListSmartHomeAppliances";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1ListSmartHomeAppliancesRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1ListTagsCommand(
  input: ListTagsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AlexaForBusiness.ListTags";
  let body: any;
  body = JSON.stringify(serializeAws_json1_1ListTagsRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1PutConferencePreferenceCommand(
  input: PutConferencePreferenceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AlexaForBusiness.PutConferencePreference";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1PutConferencePreferenceRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1PutInvitationConfigurationCommand(
  input: PutInvitationConfigurationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AlexaForBusiness.PutInvitationConfiguration";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1PutInvitationConfigurationRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1PutRoomSkillParameterCommand(
  input: PutRoomSkillParameterCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AlexaForBusiness.PutRoomSkillParameter";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1PutRoomSkillParameterRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1PutSkillAuthorizationCommand(
  input: PutSkillAuthorizationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AlexaForBusiness.PutSkillAuthorization";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1PutSkillAuthorizationRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1RegisterAVSDeviceCommand(
  input: RegisterAVSDeviceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AlexaForBusiness.RegisterAVSDevice";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1RegisterAVSDeviceRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1RejectSkillCommand(
  input: RejectSkillCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AlexaForBusiness.RejectSkill";
  let body: any;
  body = JSON.stringify(serializeAws_json1_1RejectSkillRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1ResolveRoomCommand(
  input: ResolveRoomCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AlexaForBusiness.ResolveRoom";
  let body: any;
  body = JSON.stringify(serializeAws_json1_1ResolveRoomRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1RevokeInvitationCommand(
  input: RevokeInvitationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AlexaForBusiness.RevokeInvitation";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1RevokeInvitationRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1SearchAddressBooksCommand(
  input: SearchAddressBooksCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AlexaForBusiness.SearchAddressBooks";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1SearchAddressBooksRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1SearchContactsCommand(
  input: SearchContactsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AlexaForBusiness.SearchContacts";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1SearchContactsRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1SearchDevicesCommand(
  input: SearchDevicesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AlexaForBusiness.SearchDevices";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1SearchDevicesRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1SearchNetworkProfilesCommand(
  input: SearchNetworkProfilesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AlexaForBusiness.SearchNetworkProfiles";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1SearchNetworkProfilesRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1SearchProfilesCommand(
  input: SearchProfilesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AlexaForBusiness.SearchProfiles";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1SearchProfilesRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1SearchRoomsCommand(
  input: SearchRoomsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AlexaForBusiness.SearchRooms";
  let body: any;
  body = JSON.stringify(serializeAws_json1_1SearchRoomsRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1SearchSkillGroupsCommand(
  input: SearchSkillGroupsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AlexaForBusiness.SearchSkillGroups";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1SearchSkillGroupsRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1SearchUsersCommand(
  input: SearchUsersCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AlexaForBusiness.SearchUsers";
  let body: any;
  body = JSON.stringify(serializeAws_json1_1SearchUsersRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1SendInvitationCommand(
  input: SendInvitationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AlexaForBusiness.SendInvitation";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1SendInvitationRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1StartDeviceSyncCommand(
  input: StartDeviceSyncCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AlexaForBusiness.StartDeviceSync";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1StartDeviceSyncRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1StartSmartHomeApplianceDiscoveryCommand(
  input: StartSmartHomeApplianceDiscoveryCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AlexaForBusiness.StartSmartHomeApplianceDiscovery";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1StartSmartHomeApplianceDiscoveryRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1TagResourceCommand(
  input: TagResourceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AlexaForBusiness.TagResource";
  let body: any;
  body = JSON.stringify(serializeAws_json1_1TagResourceRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1UntagResourceCommand(
  input: UntagResourceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AlexaForBusiness.UntagResource";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1UntagResourceRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1UpdateAddressBookCommand(
  input: UpdateAddressBookCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AlexaForBusiness.UpdateAddressBook";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1UpdateAddressBookRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1UpdateBusinessReportScheduleCommand(
  input: UpdateBusinessReportScheduleCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AlexaForBusiness.UpdateBusinessReportSchedule";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1UpdateBusinessReportScheduleRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1UpdateConferenceProviderCommand(
  input: UpdateConferenceProviderCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AlexaForBusiness.UpdateConferenceProvider";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1UpdateConferenceProviderRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1UpdateContactCommand(
  input: UpdateContactCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AlexaForBusiness.UpdateContact";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1UpdateContactRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1UpdateDeviceCommand(
  input: UpdateDeviceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AlexaForBusiness.UpdateDevice";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1UpdateDeviceRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1UpdateGatewayCommand(
  input: UpdateGatewayCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AlexaForBusiness.UpdateGateway";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1UpdateGatewayRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1UpdateGatewayGroupCommand(
  input: UpdateGatewayGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AlexaForBusiness.UpdateGatewayGroup";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1UpdateGatewayGroupRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1UpdateNetworkProfileCommand(
  input: UpdateNetworkProfileCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AlexaForBusiness.UpdateNetworkProfile";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1UpdateNetworkProfileRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1UpdateProfileCommand(
  input: UpdateProfileCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AlexaForBusiness.UpdateProfile";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1UpdateProfileRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1UpdateRoomCommand(
  input: UpdateRoomCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AlexaForBusiness.UpdateRoom";
  let body: any;
  body = JSON.stringify(serializeAws_json1_1UpdateRoomRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1UpdateSkillGroupCommand(
  input: UpdateSkillGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AlexaForBusiness.UpdateSkillGroup";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1UpdateSkillGroupRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function deserializeAws_json1_1SendAnnouncementCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<SendAnnouncementCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1SendAnnouncementCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1SendAnnouncementResponse(data, context);
  const response: SendAnnouncementCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "SendAnnouncementResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1SendAnnouncementCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<SendAnnouncementCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "AlreadyExistsException":
    case "com.amazonaws.a4b.api#AlreadyExistsException":
      response = {
        ...(await deserializeAws_json1_1AlreadyExistsExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.a4b.api#LimitExceededException":
      response = {
        ...(await deserializeAws_json1_1LimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeleteDeviceUsageDataCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteDeviceUsageDataCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteDeviceUsageDataCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteDeviceUsageDataResponse(data, context);
  const response: DeleteDeviceUsageDataCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteDeviceUsageDataResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteDeviceUsageDataCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteDeviceUsageDataCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "DeviceNotRegisteredException":
    case "com.amazonaws.a4b.api#DeviceNotRegisteredException":
      response = {
        ...(await deserializeAws_json1_1DeviceNotRegisteredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.a4b.api#LimitExceededException":
      response = {
        ...(await deserializeAws_json1_1LimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.a4b.api#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ApproveSkillCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ApproveSkillCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ApproveSkillCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ApproveSkillResponse(data, context);
  const response: ApproveSkillCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ApproveSkillResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ApproveSkillCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ApproveSkillCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ConcurrentModificationException":
    case "com.amazonaws.a4b.api#ConcurrentModificationException":
      response = {
        ...(await deserializeAws_json1_1ConcurrentModificationExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.a4b.api#LimitExceededException":
      response = {
        ...(await deserializeAws_json1_1LimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.a4b.api#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1AssociateContactWithAddressBookCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AssociateContactWithAddressBookCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1AssociateContactWithAddressBookCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1AssociateContactWithAddressBookResponse(
    data,
    context
  );
  const response: AssociateContactWithAddressBookCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "AssociateContactWithAddressBookResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1AssociateContactWithAddressBookCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AssociateContactWithAddressBookCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "LimitExceededException":
    case "com.amazonaws.a4b.api#LimitExceededException":
      response = {
        ...(await deserializeAws_json1_1LimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1AssociateDeviceWithNetworkProfileCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AssociateDeviceWithNetworkProfileCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1AssociateDeviceWithNetworkProfileCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1AssociateDeviceWithNetworkProfileResponse(
    data,
    context
  );
  const response: AssociateDeviceWithNetworkProfileCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "AssociateDeviceWithNetworkProfileResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1AssociateDeviceWithNetworkProfileCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AssociateDeviceWithNetworkProfileCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ConcurrentModificationException":
    case "com.amazonaws.a4b.api#ConcurrentModificationException":
      response = {
        ...(await deserializeAws_json1_1ConcurrentModificationExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DeviceNotRegisteredException":
    case "com.amazonaws.a4b.api#DeviceNotRegisteredException":
      response = {
        ...(await deserializeAws_json1_1DeviceNotRegisteredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.a4b.api#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1AssociateDeviceWithRoomCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AssociateDeviceWithRoomCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1AssociateDeviceWithRoomCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1AssociateDeviceWithRoomResponse(
    data,
    context
  );
  const response: AssociateDeviceWithRoomCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "AssociateDeviceWithRoomResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1AssociateDeviceWithRoomCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AssociateDeviceWithRoomCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ConcurrentModificationException":
    case "com.amazonaws.a4b.api#ConcurrentModificationException":
      response = {
        ...(await deserializeAws_json1_1ConcurrentModificationExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DeviceNotRegisteredException":
    case "com.amazonaws.a4b.api#DeviceNotRegisteredException":
      response = {
        ...(await deserializeAws_json1_1DeviceNotRegisteredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.a4b.api#LimitExceededException":
      response = {
        ...(await deserializeAws_json1_1LimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1AssociateSkillGroupWithRoomCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AssociateSkillGroupWithRoomCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1AssociateSkillGroupWithRoomCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1AssociateSkillGroupWithRoomResponse(
    data,
    context
  );
  const response: AssociateSkillGroupWithRoomCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "AssociateSkillGroupWithRoomResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1AssociateSkillGroupWithRoomCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AssociateSkillGroupWithRoomCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ConcurrentModificationException":
    case "com.amazonaws.a4b.api#ConcurrentModificationException":
      response = {
        ...(await deserializeAws_json1_1ConcurrentModificationExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1AssociateSkillWithSkillGroupCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AssociateSkillWithSkillGroupCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1AssociateSkillWithSkillGroupCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1AssociateSkillWithSkillGroupResponse(
    data,
    context
  );
  const response: AssociateSkillWithSkillGroupCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "AssociateSkillWithSkillGroupResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1AssociateSkillWithSkillGroupCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AssociateSkillWithSkillGroupCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ConcurrentModificationException":
    case "com.amazonaws.a4b.api#ConcurrentModificationException":
      response = {
        ...(await deserializeAws_json1_1ConcurrentModificationExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.a4b.api#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "SkillNotLinkedException":
    case "com.amazonaws.awsmoneypennyresourcemanagement#SkillNotLinkedException":
      response = {
        ...(await deserializeAws_json1_1SkillNotLinkedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1AssociateSkillWithUsersCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AssociateSkillWithUsersCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1AssociateSkillWithUsersCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1AssociateSkillWithUsersResponse(
    data,
    context
  );
  const response: AssociateSkillWithUsersCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "AssociateSkillWithUsersResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1AssociateSkillWithUsersCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AssociateSkillWithUsersCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ConcurrentModificationException":
    case "com.amazonaws.a4b.api#ConcurrentModificationException":
      response = {
        ...(await deserializeAws_json1_1ConcurrentModificationExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.a4b.api#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreateAddressBookCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateAddressBookCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateAddressBookCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateAddressBookResponse(data, context);
  const response: CreateAddressBookCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateAddressBookResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateAddressBookCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateAddressBookCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "AlreadyExistsException":
    case "com.amazonaws.a4b.api#AlreadyExistsException":
      response = {
        ...(await deserializeAws_json1_1AlreadyExistsExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.a4b.api#LimitExceededException":
      response = {
        ...(await deserializeAws_json1_1LimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreateBusinessReportScheduleCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateBusinessReportScheduleCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateBusinessReportScheduleCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateBusinessReportScheduleResponse(
    data,
    context
  );
  const response: CreateBusinessReportScheduleCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateBusinessReportScheduleResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateBusinessReportScheduleCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateBusinessReportScheduleCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "AlreadyExistsException":
    case "com.amazonaws.a4b.api#AlreadyExistsException":
      response = {
        ...(await deserializeAws_json1_1AlreadyExistsExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreateConferenceProviderCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateConferenceProviderCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateConferenceProviderCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateConferenceProviderResponse(
    data,
    context
  );
  const response: CreateConferenceProviderCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateConferenceProviderResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateConferenceProviderCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateConferenceProviderCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "AlreadyExistsException":
    case "com.amazonaws.a4b.api#AlreadyExistsException":
      response = {
        ...(await deserializeAws_json1_1AlreadyExistsExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreateContactCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateContactCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateContactCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateContactResponse(data, context);
  const response: CreateContactCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateContactResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateContactCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateContactCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "AlreadyExistsException":
    case "com.amazonaws.a4b.api#AlreadyExistsException":
      response = {
        ...(await deserializeAws_json1_1AlreadyExistsExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.a4b.api#LimitExceededException":
      response = {
        ...(await deserializeAws_json1_1LimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreateGatewayGroupCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateGatewayGroupCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateGatewayGroupCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateGatewayGroupResponse(data, context);
  const response: CreateGatewayGroupCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateGatewayGroupResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateGatewayGroupCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateGatewayGroupCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "AlreadyExistsException":
    case "com.amazonaws.a4b.api#AlreadyExistsException":
      response = {
        ...(await deserializeAws_json1_1AlreadyExistsExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.a4b.api#LimitExceededException":
      response = {
        ...(await deserializeAws_json1_1LimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreateNetworkProfileCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateNetworkProfileCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateNetworkProfileCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateNetworkProfileResponse(data, context);
  const response: CreateNetworkProfileCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateNetworkProfileResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateNetworkProfileCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateNetworkProfileCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "AlreadyExistsException":
    case "com.amazonaws.a4b.api#AlreadyExistsException":
      response = {
        ...(await deserializeAws_json1_1AlreadyExistsExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ConcurrentModificationException":
    case "com.amazonaws.a4b.api#ConcurrentModificationException":
      response = {
        ...(await deserializeAws_json1_1ConcurrentModificationExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.a4b.api#LimitExceededException":
      response = {
        ...(await deserializeAws_json1_1LimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidCertificateAuthorityException":
    case "com.amazonaws.awsmoneypennyresourcemanagement#InvalidCertificateAuthorityException":
      response = {
        ...(await deserializeAws_json1_1InvalidCertificateAuthorityExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidServiceLinkedRoleStateException":
    case "com.amazonaws.awsmoneypennyresourcemanagement#InvalidServiceLinkedRoleStateException":
      response = {
        ...(await deserializeAws_json1_1InvalidServiceLinkedRoleStateExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreateProfileCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateProfileCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateProfileCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateProfileResponse(data, context);
  const response: CreateProfileCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateProfileResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateProfileCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateProfileCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "AlreadyExistsException":
    case "com.amazonaws.a4b.api#AlreadyExistsException":
      response = {
        ...(await deserializeAws_json1_1AlreadyExistsExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ConcurrentModificationException":
    case "com.amazonaws.a4b.api#ConcurrentModificationException":
      response = {
        ...(await deserializeAws_json1_1ConcurrentModificationExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.a4b.api#LimitExceededException":
      response = {
        ...(await deserializeAws_json1_1LimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreateRoomCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateRoomCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateRoomCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateRoomResponse(data, context);
  const response: CreateRoomCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateRoomResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateRoomCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateRoomCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "AlreadyExistsException":
    case "com.amazonaws.a4b.api#AlreadyExistsException":
      response = {
        ...(await deserializeAws_json1_1AlreadyExistsExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.a4b.api#LimitExceededException":
      response = {
        ...(await deserializeAws_json1_1LimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreateSkillGroupCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateSkillGroupCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateSkillGroupCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateSkillGroupResponse(data, context);
  const response: CreateSkillGroupCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateSkillGroupResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateSkillGroupCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateSkillGroupCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "AlreadyExistsException":
    case "com.amazonaws.a4b.api#AlreadyExistsException":
      response = {
        ...(await deserializeAws_json1_1AlreadyExistsExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ConcurrentModificationException":
    case "com.amazonaws.a4b.api#ConcurrentModificationException":
      response = {
        ...(await deserializeAws_json1_1ConcurrentModificationExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.a4b.api#LimitExceededException":
      response = {
        ...(await deserializeAws_json1_1LimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreateUserCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateUserCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateUserCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateUserResponse(data, context);
  const response: CreateUserCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateUserResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateUserCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateUserCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ConcurrentModificationException":
    case "com.amazonaws.a4b.api#ConcurrentModificationException":
      response = {
        ...(await deserializeAws_json1_1ConcurrentModificationExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.a4b.api#LimitExceededException":
      response = {
        ...(await deserializeAws_json1_1LimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceInUseException":
    case "com.amazonaws.a4b.api#ResourceInUseException":
      response = {
        ...(await deserializeAws_json1_1ResourceInUseExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeleteAddressBookCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteAddressBookCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteAddressBookCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteAddressBookResponse(data, context);
  const response: DeleteAddressBookCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteAddressBookResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteAddressBookCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteAddressBookCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ConcurrentModificationException":
    case "com.amazonaws.a4b.api#ConcurrentModificationException":
      response = {
        ...(await deserializeAws_json1_1ConcurrentModificationExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.a4b.api#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeleteBusinessReportScheduleCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteBusinessReportScheduleCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteBusinessReportScheduleCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteBusinessReportScheduleResponse(
    data,
    context
  );
  const response: DeleteBusinessReportScheduleCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteBusinessReportScheduleResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteBusinessReportScheduleCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteBusinessReportScheduleCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ConcurrentModificationException":
    case "com.amazonaws.a4b.api#ConcurrentModificationException":
      response = {
        ...(await deserializeAws_json1_1ConcurrentModificationExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.a4b.api#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeleteConferenceProviderCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteConferenceProviderCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteConferenceProviderCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteConferenceProviderResponse(
    data,
    context
  );
  const response: DeleteConferenceProviderCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteConferenceProviderResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteConferenceProviderCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteConferenceProviderCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "NotFoundException":
    case "com.amazonaws.a4b.api#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeleteContactCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteContactCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteContactCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteContactResponse(data, context);
  const response: DeleteContactCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteContactResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteContactCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteContactCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ConcurrentModificationException":
    case "com.amazonaws.a4b.api#ConcurrentModificationException":
      response = {
        ...(await deserializeAws_json1_1ConcurrentModificationExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.a4b.api#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeleteDeviceCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteDeviceCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteDeviceCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteDeviceResponse(data, context);
  const response: DeleteDeviceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteDeviceResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteDeviceCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteDeviceCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ConcurrentModificationException":
    case "com.amazonaws.a4b.api#ConcurrentModificationException":
      response = {
        ...(await deserializeAws_json1_1ConcurrentModificationExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.a4b.api#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidCertificateAuthorityException":
    case "com.amazonaws.awsmoneypennyresourcemanagement#InvalidCertificateAuthorityException":
      response = {
        ...(await deserializeAws_json1_1InvalidCertificateAuthorityExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeleteGatewayGroupCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteGatewayGroupCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteGatewayGroupCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteGatewayGroupResponse(data, context);
  const response: DeleteGatewayGroupCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteGatewayGroupResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteGatewayGroupCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteGatewayGroupCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceAssociatedException":
    case "com.amazonaws.awsmoneypennyresourcemanagement#ResourceAssociatedException":
      response = {
        ...(await deserializeAws_json1_1ResourceAssociatedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeleteNetworkProfileCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteNetworkProfileCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteNetworkProfileCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteNetworkProfileResponse(data, context);
  const response: DeleteNetworkProfileCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteNetworkProfileResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteNetworkProfileCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteNetworkProfileCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ConcurrentModificationException":
    case "com.amazonaws.a4b.api#ConcurrentModificationException":
      response = {
        ...(await deserializeAws_json1_1ConcurrentModificationExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.a4b.api#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceInUseException":
    case "com.amazonaws.a4b.api#ResourceInUseException":
      response = {
        ...(await deserializeAws_json1_1ResourceInUseExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeleteProfileCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteProfileCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteProfileCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteProfileResponse(data, context);
  const response: DeleteProfileCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteProfileResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteProfileCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteProfileCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ConcurrentModificationException":
    case "com.amazonaws.a4b.api#ConcurrentModificationException":
      response = {
        ...(await deserializeAws_json1_1ConcurrentModificationExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.a4b.api#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeleteRoomCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteRoomCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteRoomCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteRoomResponse(data, context);
  const response: DeleteRoomCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteRoomResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteRoomCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteRoomCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ConcurrentModificationException":
    case "com.amazonaws.a4b.api#ConcurrentModificationException":
      response = {
        ...(await deserializeAws_json1_1ConcurrentModificationExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.a4b.api#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeleteRoomSkillParameterCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteRoomSkillParameterCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteRoomSkillParameterCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteRoomSkillParameterResponse(
    data,
    context
  );
  const response: DeleteRoomSkillParameterCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteRoomSkillParameterResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteRoomSkillParameterCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteRoomSkillParameterCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ConcurrentModificationException":
    case "com.amazonaws.a4b.api#ConcurrentModificationException":
      response = {
        ...(await deserializeAws_json1_1ConcurrentModificationExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeleteSkillAuthorizationCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteSkillAuthorizationCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteSkillAuthorizationCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteSkillAuthorizationResponse(
    data,
    context
  );
  const response: DeleteSkillAuthorizationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteSkillAuthorizationResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteSkillAuthorizationCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteSkillAuthorizationCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ConcurrentModificationException":
    case "com.amazonaws.a4b.api#ConcurrentModificationException":
      response = {
        ...(await deserializeAws_json1_1ConcurrentModificationExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.a4b.api#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeleteSkillGroupCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteSkillGroupCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteSkillGroupCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteSkillGroupResponse(data, context);
  const response: DeleteSkillGroupCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteSkillGroupResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteSkillGroupCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteSkillGroupCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ConcurrentModificationException":
    case "com.amazonaws.a4b.api#ConcurrentModificationException":
      response = {
        ...(await deserializeAws_json1_1ConcurrentModificationExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.a4b.api#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeleteUserCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteUserCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteUserCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteUserResponse(data, context);
  const response: DeleteUserCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteUserResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteUserCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteUserCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ConcurrentModificationException":
    case "com.amazonaws.a4b.api#ConcurrentModificationException":
      response = {
        ...(await deserializeAws_json1_1ConcurrentModificationExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.a4b.api#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DisassociateContactFromAddressBookCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DisassociateContactFromAddressBookCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DisassociateContactFromAddressBookCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DisassociateContactFromAddressBookResponse(
    data,
    context
  );
  const response: DisassociateContactFromAddressBookCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DisassociateContactFromAddressBookResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DisassociateContactFromAddressBookCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DisassociateContactFromAddressBookCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DisassociateDeviceFromRoomCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DisassociateDeviceFromRoomCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DisassociateDeviceFromRoomCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DisassociateDeviceFromRoomResponse(
    data,
    context
  );
  const response: DisassociateDeviceFromRoomCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DisassociateDeviceFromRoomResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DisassociateDeviceFromRoomCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DisassociateDeviceFromRoomCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ConcurrentModificationException":
    case "com.amazonaws.a4b.api#ConcurrentModificationException":
      response = {
        ...(await deserializeAws_json1_1ConcurrentModificationExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DeviceNotRegisteredException":
    case "com.amazonaws.a4b.api#DeviceNotRegisteredException":
      response = {
        ...(await deserializeAws_json1_1DeviceNotRegisteredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DisassociateSkillFromSkillGroupCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DisassociateSkillFromSkillGroupCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DisassociateSkillFromSkillGroupCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DisassociateSkillFromSkillGroupResponse(
    data,
    context
  );
  const response: DisassociateSkillFromSkillGroupCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DisassociateSkillFromSkillGroupResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DisassociateSkillFromSkillGroupCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DisassociateSkillFromSkillGroupCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ConcurrentModificationException":
    case "com.amazonaws.a4b.api#ConcurrentModificationException":
      response = {
        ...(await deserializeAws_json1_1ConcurrentModificationExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.a4b.api#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DisassociateSkillFromUsersCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DisassociateSkillFromUsersCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DisassociateSkillFromUsersCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DisassociateSkillFromUsersResponse(
    data,
    context
  );
  const response: DisassociateSkillFromUsersCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DisassociateSkillFromUsersResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DisassociateSkillFromUsersCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DisassociateSkillFromUsersCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ConcurrentModificationException":
    case "com.amazonaws.a4b.api#ConcurrentModificationException":
      response = {
        ...(await deserializeAws_json1_1ConcurrentModificationExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.a4b.api#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DisassociateSkillGroupFromRoomCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DisassociateSkillGroupFromRoomCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DisassociateSkillGroupFromRoomCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DisassociateSkillGroupFromRoomResponse(
    data,
    context
  );
  const response: DisassociateSkillGroupFromRoomCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DisassociateSkillGroupFromRoomResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DisassociateSkillGroupFromRoomCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DisassociateSkillGroupFromRoomCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ConcurrentModificationException":
    case "com.amazonaws.a4b.api#ConcurrentModificationException":
      response = {
        ...(await deserializeAws_json1_1ConcurrentModificationExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ForgetSmartHomeAppliancesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ForgetSmartHomeAppliancesCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ForgetSmartHomeAppliancesCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ForgetSmartHomeAppliancesResponse(
    data,
    context
  );
  const response: ForgetSmartHomeAppliancesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ForgetSmartHomeAppliancesResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ForgetSmartHomeAppliancesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ForgetSmartHomeAppliancesCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "NotFoundException":
    case "com.amazonaws.a4b.api#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetAddressBookCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetAddressBookCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetAddressBookCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetAddressBookResponse(data, context);
  const response: GetAddressBookCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetAddressBookResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetAddressBookCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetAddressBookCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "NotFoundException":
    case "com.amazonaws.a4b.api#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetConferencePreferenceCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetConferencePreferenceCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetConferencePreferenceCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetConferencePreferenceResponse(
    data,
    context
  );
  const response: GetConferencePreferenceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetConferencePreferenceResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetConferencePreferenceCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetConferencePreferenceCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "NotFoundException":
    case "com.amazonaws.a4b.api#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetConferenceProviderCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetConferenceProviderCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetConferenceProviderCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetConferenceProviderResponse(data, context);
  const response: GetConferenceProviderCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetConferenceProviderResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetConferenceProviderCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetConferenceProviderCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "NotFoundException":
    case "com.amazonaws.a4b.api#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetContactCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetContactCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetContactCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetContactResponse(data, context);
  const response: GetContactCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetContactResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetContactCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetContactCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "NotFoundException":
    case "com.amazonaws.a4b.api#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetDeviceCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetDeviceCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetDeviceCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetDeviceResponse(data, context);
  const response: GetDeviceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetDeviceResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetDeviceCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetDeviceCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "NotFoundException":
    case "com.amazonaws.a4b.api#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetGatewayCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetGatewayCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetGatewayCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetGatewayResponse(data, context);
  const response: GetGatewayCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetGatewayResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetGatewayCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetGatewayCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "NotFoundException":
    case "com.amazonaws.a4b.api#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetGatewayGroupCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetGatewayGroupCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetGatewayGroupCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetGatewayGroupResponse(data, context);
  const response: GetGatewayGroupCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetGatewayGroupResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetGatewayGroupCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetGatewayGroupCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "NotFoundException":
    case "com.amazonaws.a4b.api#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetInvitationConfigurationCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetInvitationConfigurationCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetInvitationConfigurationCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetInvitationConfigurationResponse(
    data,
    context
  );
  const response: GetInvitationConfigurationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetInvitationConfigurationResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetInvitationConfigurationCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetInvitationConfigurationCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "NotFoundException":
    case "com.amazonaws.a4b.api#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetNetworkProfileCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetNetworkProfileCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetNetworkProfileCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetNetworkProfileResponse(data, context);
  const response: GetNetworkProfileCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetNetworkProfileResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetNetworkProfileCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetNetworkProfileCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "NotFoundException":
    case "com.amazonaws.a4b.api#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidSecretsManagerResourceException":
    case "com.amazonaws.awsmoneypennyresourcemanagement#InvalidSecretsManagerResourceException":
      response = {
        ...(await deserializeAws_json1_1InvalidSecretsManagerResourceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetProfileCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetProfileCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetProfileCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetProfileResponse(data, context);
  const response: GetProfileCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetProfileResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetProfileCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetProfileCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "NotFoundException":
    case "com.amazonaws.a4b.api#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetRoomCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetRoomCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetRoomCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetRoomResponse(data, context);
  const response: GetRoomCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetRoomResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetRoomCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetRoomCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "NotFoundException":
    case "com.amazonaws.a4b.api#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetRoomSkillParameterCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetRoomSkillParameterCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetRoomSkillParameterCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetRoomSkillParameterResponse(data, context);
  const response: GetRoomSkillParameterCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetRoomSkillParameterResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetRoomSkillParameterCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetRoomSkillParameterCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "NotFoundException":
    case "com.amazonaws.a4b.api#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetSkillGroupCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetSkillGroupCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetSkillGroupCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetSkillGroupResponse(data, context);
  const response: GetSkillGroupCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetSkillGroupResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetSkillGroupCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetSkillGroupCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "NotFoundException":
    case "com.amazonaws.a4b.api#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ListBusinessReportSchedulesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListBusinessReportSchedulesCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListBusinessReportSchedulesCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListBusinessReportSchedulesResponse(
    data,
    context
  );
  const response: ListBusinessReportSchedulesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListBusinessReportSchedulesResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListBusinessReportSchedulesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListBusinessReportSchedulesCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ListConferenceProvidersCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListConferenceProvidersCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListConferenceProvidersCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListConferenceProvidersResponse(
    data,
    context
  );
  const response: ListConferenceProvidersCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListConferenceProvidersResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListConferenceProvidersCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListConferenceProvidersCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ListDeviceEventsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListDeviceEventsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListDeviceEventsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListDeviceEventsResponse(data, context);
  const response: ListDeviceEventsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListDeviceEventsResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListDeviceEventsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListDeviceEventsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "NotFoundException":
    case "com.amazonaws.a4b.api#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ListGatewayGroupsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListGatewayGroupsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListGatewayGroupsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListGatewayGroupsResponse(data, context);
  const response: ListGatewayGroupsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListGatewayGroupsResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListGatewayGroupsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListGatewayGroupsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ListGatewaysCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListGatewaysCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListGatewaysCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListGatewaysResponse(data, context);
  const response: ListGatewaysCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListGatewaysResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListGatewaysCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListGatewaysCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ListSkillsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListSkillsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListSkillsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListSkillsResponse(data, context);
  const response: ListSkillsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListSkillsResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListSkillsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListSkillsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ListSkillsStoreCategoriesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListSkillsStoreCategoriesCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListSkillsStoreCategoriesCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListSkillsStoreCategoriesResponse(
    data,
    context
  );
  const response: ListSkillsStoreCategoriesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListSkillsStoreCategoriesResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListSkillsStoreCategoriesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListSkillsStoreCategoriesCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ListSkillsStoreSkillsByCategoryCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListSkillsStoreSkillsByCategoryCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListSkillsStoreSkillsByCategoryCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListSkillsStoreSkillsByCategoryResponse(
    data,
    context
  );
  const response: ListSkillsStoreSkillsByCategoryCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListSkillsStoreSkillsByCategoryResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListSkillsStoreSkillsByCategoryCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListSkillsStoreSkillsByCategoryCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ListSmartHomeAppliancesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListSmartHomeAppliancesCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListSmartHomeAppliancesCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListSmartHomeAppliancesResponse(
    data,
    context
  );
  const response: ListSmartHomeAppliancesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListSmartHomeAppliancesResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListSmartHomeAppliancesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListSmartHomeAppliancesCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "NotFoundException":
    case "com.amazonaws.a4b.api#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ListTagsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTagsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListTagsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListTagsResponse(data, context);
  const response: ListTagsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListTagsResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListTagsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTagsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "NotFoundException":
    case "com.amazonaws.a4b.api#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1PutConferencePreferenceCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutConferencePreferenceCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1PutConferencePreferenceCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1PutConferencePreferenceResponse(
    data,
    context
  );
  const response: PutConferencePreferenceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "PutConferencePreferenceResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1PutConferencePreferenceCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutConferencePreferenceCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "NotFoundException":
    case "com.amazonaws.a4b.api#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1PutInvitationConfigurationCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutInvitationConfigurationCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1PutInvitationConfigurationCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1PutInvitationConfigurationResponse(
    data,
    context
  );
  const response: PutInvitationConfigurationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "PutInvitationConfigurationResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1PutInvitationConfigurationCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutInvitationConfigurationCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ConcurrentModificationException":
    case "com.amazonaws.a4b.api#ConcurrentModificationException":
      response = {
        ...(await deserializeAws_json1_1ConcurrentModificationExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.a4b.api#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1PutRoomSkillParameterCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutRoomSkillParameterCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1PutRoomSkillParameterCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1PutRoomSkillParameterResponse(data, context);
  const response: PutRoomSkillParameterCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "PutRoomSkillParameterResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1PutRoomSkillParameterCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutRoomSkillParameterCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ConcurrentModificationException":
    case "com.amazonaws.a4b.api#ConcurrentModificationException":
      response = {
        ...(await deserializeAws_json1_1ConcurrentModificationExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1PutSkillAuthorizationCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutSkillAuthorizationCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1PutSkillAuthorizationCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1PutSkillAuthorizationResponse(data, context);
  const response: PutSkillAuthorizationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "PutSkillAuthorizationResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1PutSkillAuthorizationCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutSkillAuthorizationCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ConcurrentModificationException":
    case "com.amazonaws.a4b.api#ConcurrentModificationException":
      response = {
        ...(await deserializeAws_json1_1ConcurrentModificationExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.a4b.api#UnauthorizedException":
      response = {
        ...(await deserializeAws_json1_1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1RegisterAVSDeviceCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RegisterAVSDeviceCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1RegisterAVSDeviceCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1RegisterAVSDeviceResponse(data, context);
  const response: RegisterAVSDeviceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "RegisterAVSDeviceResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1RegisterAVSDeviceCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RegisterAVSDeviceCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ConcurrentModificationException":
    case "com.amazonaws.a4b.api#ConcurrentModificationException":
      response = {
        ...(await deserializeAws_json1_1ConcurrentModificationExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.a4b.api#LimitExceededException":
      response = {
        ...(await deserializeAws_json1_1LimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDeviceException":
    case "com.amazonaws.awsmoneypennyresourcemanagement#InvalidDeviceException":
      response = {
        ...(await deserializeAws_json1_1InvalidDeviceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1RejectSkillCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RejectSkillCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1RejectSkillCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1RejectSkillResponse(data, context);
  const response: RejectSkillCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "RejectSkillResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1RejectSkillCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RejectSkillCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ConcurrentModificationException":
    case "com.amazonaws.a4b.api#ConcurrentModificationException":
      response = {
        ...(await deserializeAws_json1_1ConcurrentModificationExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.a4b.api#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ResolveRoomCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ResolveRoomCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ResolveRoomCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ResolveRoomResponse(data, context);
  const response: ResolveRoomCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ResolveRoomResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ResolveRoomCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ResolveRoomCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "NotFoundException":
    case "com.amazonaws.a4b.api#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1RevokeInvitationCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RevokeInvitationCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1RevokeInvitationCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1RevokeInvitationResponse(data, context);
  const response: RevokeInvitationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "RevokeInvitationResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1RevokeInvitationCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RevokeInvitationCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ConcurrentModificationException":
    case "com.amazonaws.a4b.api#ConcurrentModificationException":
      response = {
        ...(await deserializeAws_json1_1ConcurrentModificationExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.a4b.api#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1SearchAddressBooksCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<SearchAddressBooksCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1SearchAddressBooksCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1SearchAddressBooksResponse(data, context);
  const response: SearchAddressBooksCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "SearchAddressBooksResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1SearchAddressBooksCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<SearchAddressBooksCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1SearchContactsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<SearchContactsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1SearchContactsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1SearchContactsResponse(data, context);
  const response: SearchContactsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "SearchContactsResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1SearchContactsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<SearchContactsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1SearchDevicesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<SearchDevicesCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1SearchDevicesCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1SearchDevicesResponse(data, context);
  const response: SearchDevicesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "SearchDevicesResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1SearchDevicesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<SearchDevicesCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1SearchNetworkProfilesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<SearchNetworkProfilesCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1SearchNetworkProfilesCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1SearchNetworkProfilesResponse(data, context);
  const response: SearchNetworkProfilesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "SearchNetworkProfilesResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1SearchNetworkProfilesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<SearchNetworkProfilesCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1SearchProfilesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<SearchProfilesCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1SearchProfilesCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1SearchProfilesResponse(data, context);
  const response: SearchProfilesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "SearchProfilesResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1SearchProfilesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<SearchProfilesCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1SearchRoomsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<SearchRoomsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1SearchRoomsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1SearchRoomsResponse(data, context);
  const response: SearchRoomsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "SearchRoomsResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1SearchRoomsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<SearchRoomsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1SearchSkillGroupsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<SearchSkillGroupsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1SearchSkillGroupsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1SearchSkillGroupsResponse(data, context);
  const response: SearchSkillGroupsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "SearchSkillGroupsResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1SearchSkillGroupsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<SearchSkillGroupsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1SearchUsersCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<SearchUsersCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1SearchUsersCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1SearchUsersResponse(data, context);
  const response: SearchUsersCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "SearchUsersResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1SearchUsersCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<SearchUsersCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1SendInvitationCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<SendInvitationCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1SendInvitationCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1SendInvitationResponse(data, context);
  const response: SendInvitationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "SendInvitationResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1SendInvitationCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<SendInvitationCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ConcurrentModificationException":
    case "com.amazonaws.a4b.api#ConcurrentModificationException":
      response = {
        ...(await deserializeAws_json1_1ConcurrentModificationExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.a4b.api#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidUserStatusException":
    case "com.amazonaws.awsmoneypennyresourcemanagement#InvalidUserStatusException":
      response = {
        ...(await deserializeAws_json1_1InvalidUserStatusExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1StartDeviceSyncCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartDeviceSyncCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1StartDeviceSyncCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1StartDeviceSyncResponse(data, context);
  const response: StartDeviceSyncCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "StartDeviceSyncResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1StartDeviceSyncCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartDeviceSyncCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "DeviceNotRegisteredException":
    case "com.amazonaws.a4b.api#DeviceNotRegisteredException":
      response = {
        ...(await deserializeAws_json1_1DeviceNotRegisteredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1StartSmartHomeApplianceDiscoveryCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartSmartHomeApplianceDiscoveryCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1StartSmartHomeApplianceDiscoveryCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1StartSmartHomeApplianceDiscoveryResponse(
    data,
    context
  );
  const response: StartSmartHomeApplianceDiscoveryCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "StartSmartHomeApplianceDiscoveryResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1StartSmartHomeApplianceDiscoveryCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartSmartHomeApplianceDiscoveryCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "NotFoundException":
    case "com.amazonaws.a4b.api#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1TagResourceCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<TagResourceCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1TagResourceCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1TagResourceResponse(data, context);
  const response: TagResourceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "TagResourceResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1TagResourceCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<TagResourceCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "NotFoundException":
    case "com.amazonaws.a4b.api#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1UntagResourceCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UntagResourceCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UntagResourceCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UntagResourceResponse(data, context);
  const response: UntagResourceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UntagResourceResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1UntagResourceCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UntagResourceCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "NotFoundException":
    case "com.amazonaws.a4b.api#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1UpdateAddressBookCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateAddressBookCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateAddressBookCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdateAddressBookResponse(data, context);
  const response: UpdateAddressBookCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateAddressBookResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1UpdateAddressBookCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateAddressBookCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ConcurrentModificationException":
    case "com.amazonaws.a4b.api#ConcurrentModificationException":
      response = {
        ...(await deserializeAws_json1_1ConcurrentModificationExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NameInUseException":
    case "com.amazonaws.a4b.api#NameInUseException":
      response = {
        ...(await deserializeAws_json1_1NameInUseExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.a4b.api#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1UpdateBusinessReportScheduleCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateBusinessReportScheduleCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateBusinessReportScheduleCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdateBusinessReportScheduleResponse(
    data,
    context
  );
  const response: UpdateBusinessReportScheduleCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateBusinessReportScheduleResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1UpdateBusinessReportScheduleCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateBusinessReportScheduleCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ConcurrentModificationException":
    case "com.amazonaws.a4b.api#ConcurrentModificationException":
      response = {
        ...(await deserializeAws_json1_1ConcurrentModificationExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.a4b.api#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1UpdateConferenceProviderCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateConferenceProviderCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateConferenceProviderCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdateConferenceProviderResponse(
    data,
    context
  );
  const response: UpdateConferenceProviderCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateConferenceProviderResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1UpdateConferenceProviderCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateConferenceProviderCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "NotFoundException":
    case "com.amazonaws.a4b.api#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1UpdateContactCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateContactCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateContactCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdateContactResponse(data, context);
  const response: UpdateContactCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateContactResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1UpdateContactCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateContactCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ConcurrentModificationException":
    case "com.amazonaws.a4b.api#ConcurrentModificationException":
      response = {
        ...(await deserializeAws_json1_1ConcurrentModificationExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.a4b.api#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1UpdateDeviceCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateDeviceCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateDeviceCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdateDeviceResponse(data, context);
  const response: UpdateDeviceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateDeviceResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1UpdateDeviceCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateDeviceCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ConcurrentModificationException":
    case "com.amazonaws.a4b.api#ConcurrentModificationException":
      response = {
        ...(await deserializeAws_json1_1ConcurrentModificationExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DeviceNotRegisteredException":
    case "com.amazonaws.a4b.api#DeviceNotRegisteredException":
      response = {
        ...(await deserializeAws_json1_1DeviceNotRegisteredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.a4b.api#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1UpdateGatewayCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateGatewayCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateGatewayCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdateGatewayResponse(data, context);
  const response: UpdateGatewayCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateGatewayResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1UpdateGatewayCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateGatewayCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "NameInUseException":
    case "com.amazonaws.a4b.api#NameInUseException":
      response = {
        ...(await deserializeAws_json1_1NameInUseExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.a4b.api#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1UpdateGatewayGroupCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateGatewayGroupCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateGatewayGroupCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdateGatewayGroupResponse(data, context);
  const response: UpdateGatewayGroupCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateGatewayGroupResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1UpdateGatewayGroupCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateGatewayGroupCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "NameInUseException":
    case "com.amazonaws.a4b.api#NameInUseException":
      response = {
        ...(await deserializeAws_json1_1NameInUseExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.a4b.api#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1UpdateNetworkProfileCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateNetworkProfileCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateNetworkProfileCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdateNetworkProfileResponse(data, context);
  const response: UpdateNetworkProfileCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateNetworkProfileResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1UpdateNetworkProfileCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateNetworkProfileCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ConcurrentModificationException":
    case "com.amazonaws.a4b.api#ConcurrentModificationException":
      response = {
        ...(await deserializeAws_json1_1ConcurrentModificationExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NameInUseException":
    case "com.amazonaws.a4b.api#NameInUseException":
      response = {
        ...(await deserializeAws_json1_1NameInUseExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.a4b.api#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidCertificateAuthorityException":
    case "com.amazonaws.awsmoneypennyresourcemanagement#InvalidCertificateAuthorityException":
      response = {
        ...(await deserializeAws_json1_1InvalidCertificateAuthorityExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidSecretsManagerResourceException":
    case "com.amazonaws.awsmoneypennyresourcemanagement#InvalidSecretsManagerResourceException":
      response = {
        ...(await deserializeAws_json1_1InvalidSecretsManagerResourceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1UpdateProfileCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateProfileCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateProfileCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdateProfileResponse(data, context);
  const response: UpdateProfileCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateProfileResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1UpdateProfileCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateProfileCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ConcurrentModificationException":
    case "com.amazonaws.a4b.api#ConcurrentModificationException":
      response = {
        ...(await deserializeAws_json1_1ConcurrentModificationExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NameInUseException":
    case "com.amazonaws.a4b.api#NameInUseException":
      response = {
        ...(await deserializeAws_json1_1NameInUseExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.a4b.api#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1UpdateRoomCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateRoomCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateRoomCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdateRoomResponse(data, context);
  const response: UpdateRoomCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateRoomResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1UpdateRoomCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateRoomCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "NameInUseException":
    case "com.amazonaws.a4b.api#NameInUseException":
      response = {
        ...(await deserializeAws_json1_1NameInUseExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.a4b.api#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1UpdateSkillGroupCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateSkillGroupCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateSkillGroupCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdateSkillGroupResponse(data, context);
  const response: UpdateSkillGroupCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateSkillGroupResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1UpdateSkillGroupCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateSkillGroupCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ConcurrentModificationException":
    case "com.amazonaws.a4b.api#ConcurrentModificationException":
      response = {
        ...(await deserializeAws_json1_1ConcurrentModificationExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NameInUseException":
    case "com.amazonaws.a4b.api#NameInUseException":
      response = {
        ...(await deserializeAws_json1_1NameInUseExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.a4b.api#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

const deserializeAws_json1_1AlreadyExistsExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<AlreadyExistsException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1AlreadyExistsException(
    body,
    context
  );
  const contents: AlreadyExistsException = {
    name: "AlreadyExistsException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1ConcurrentModificationExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ConcurrentModificationException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1ConcurrentModificationException(
    body,
    context
  );
  const contents: ConcurrentModificationException = {
    name: "ConcurrentModificationException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1DeviceNotRegisteredExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<DeviceNotRegisteredException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1DeviceNotRegisteredException(
    body,
    context
  );
  const contents: DeviceNotRegisteredException = {
    name: "DeviceNotRegisteredException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1LimitExceededExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<LimitExceededException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1LimitExceededException(
    body,
    context
  );
  const contents: LimitExceededException = {
    name: "LimitExceededException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1NameInUseExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<NameInUseException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1NameInUseException(
    body,
    context
  );
  const contents: NameInUseException = {
    name: "NameInUseException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1NotFoundExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<NotFoundException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1NotFoundException(
    body,
    context
  );
  const contents: NotFoundException = {
    name: "NotFoundException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1ResourceInUseExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ResourceInUseException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1ResourceInUseException(
    body,
    context
  );
  const contents: ResourceInUseException = {
    name: "ResourceInUseException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1UnauthorizedExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<UnauthorizedException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1UnauthorizedException(
    body,
    context
  );
  const contents: UnauthorizedException = {
    name: "UnauthorizedException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidCertificateAuthorityExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidCertificateAuthorityException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidCertificateAuthorityException(
    body,
    context
  );
  const contents: InvalidCertificateAuthorityException = {
    name: "InvalidCertificateAuthorityException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidDeviceExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidDeviceException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidDeviceException(
    body,
    context
  );
  const contents: InvalidDeviceException = {
    name: "InvalidDeviceException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidSecretsManagerResourceExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidSecretsManagerResourceException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidSecretsManagerResourceException(
    body,
    context
  );
  const contents: InvalidSecretsManagerResourceException = {
    name: "InvalidSecretsManagerResourceException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidServiceLinkedRoleStateExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidServiceLinkedRoleStateException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidServiceLinkedRoleStateException(
    body,
    context
  );
  const contents: InvalidServiceLinkedRoleStateException = {
    name: "InvalidServiceLinkedRoleStateException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidUserStatusExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidUserStatusException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidUserStatusException(
    body,
    context
  );
  const contents: InvalidUserStatusException = {
    name: "InvalidUserStatusException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1ResourceAssociatedExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ResourceAssociatedException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1ResourceAssociatedException(
    body,
    context
  );
  const contents: ResourceAssociatedException = {
    name: "ResourceAssociatedException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1SkillNotLinkedExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<SkillNotLinkedException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1SkillNotLinkedException(
    body,
    context
  );
  const contents: SkillNotLinkedException = {
    name: "SkillNotLinkedException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const serializeAws_json1_1Filter = (
  input: Filter,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Key !== undefined) {
    bodyParams["Key"] = input.Key;
  }
  if (input.Values !== undefined) {
    bodyParams["Values"] = serializeAws_json1_1FilterValueList(
      input.Values,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1FilterList = (
  input: Array<Filter>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_json1_1Filter(entry, context));
  }
  return contents;
};

const serializeAws_json1_1FilterValueList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_json1_1IPDialIn = (
  input: IPDialIn,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.CommsProtocol !== undefined) {
    bodyParams["CommsProtocol"] = input.CommsProtocol;
  }
  if (input.Endpoint !== undefined) {
    bodyParams["Endpoint"] = input.Endpoint;
  }
  return bodyParams;
};

const serializeAws_json1_1MeetingSetting = (
  input: MeetingSetting,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.RequirePin !== undefined) {
    bodyParams["RequirePin"] = input.RequirePin;
  }
  return bodyParams;
};

const serializeAws_json1_1PSTNDialIn = (
  input: PSTNDialIn,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.CountryCode !== undefined) {
    bodyParams["CountryCode"] = input.CountryCode;
  }
  if (input.OneClickIdDelay !== undefined) {
    bodyParams["OneClickIdDelay"] = input.OneClickIdDelay;
  }
  if (input.OneClickPinDelay !== undefined) {
    bodyParams["OneClickPinDelay"] = input.OneClickPinDelay;
  }
  if (input.PhoneNumber !== undefined) {
    bodyParams["PhoneNumber"] = input.PhoneNumber;
  }
  return bodyParams;
};

const serializeAws_json1_1Audio = (
  input: Audio,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Locale !== undefined) {
    bodyParams["Locale"] = input.Locale;
  }
  if (input.Location !== undefined) {
    bodyParams["Location"] = input.Location;
  }
  return bodyParams;
};

const serializeAws_json1_1AudioList = (
  input: Array<Audio>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_json1_1Audio(entry, context));
  }
  return contents;
};

const serializeAws_json1_1Content = (
  input: Content,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.AudioList !== undefined) {
    bodyParams["AudioList"] = serializeAws_json1_1AudioList(
      input.AudioList,
      context
    );
  }
  if (input.SsmlList !== undefined) {
    bodyParams["SsmlList"] = serializeAws_json1_1SsmlList(
      input.SsmlList,
      context
    );
  }
  if (input.TextList !== undefined) {
    bodyParams["TextList"] = serializeAws_json1_1TextList(
      input.TextList,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1SendAnnouncementRequest = (
  input: SendAnnouncementRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ClientRequestToken === undefined) {
    input.ClientRequestToken = generateIdempotencyToken();
  }
  if (input.ClientRequestToken !== undefined) {
    bodyParams["ClientRequestToken"] = input.ClientRequestToken;
  }
  if (input.Content !== undefined) {
    bodyParams["Content"] = serializeAws_json1_1Content(input.Content, context);
  }
  if (input.RoomFilters !== undefined) {
    bodyParams["RoomFilters"] = serializeAws_json1_1FilterList(
      input.RoomFilters,
      context
    );
  }
  if (input.TimeToLiveInSeconds !== undefined) {
    bodyParams["TimeToLiveInSeconds"] = input.TimeToLiveInSeconds;
  }
  return bodyParams;
};

const serializeAws_json1_1Ssml = (
  input: Ssml,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Locale !== undefined) {
    bodyParams["Locale"] = input.Locale;
  }
  if (input.Value !== undefined) {
    bodyParams["Value"] = input.Value;
  }
  return bodyParams;
};

const serializeAws_json1_1SsmlList = (
  input: Array<Ssml>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_json1_1Ssml(entry, context));
  }
  return contents;
};

const serializeAws_json1_1Text = (
  input: Text,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Locale !== undefined) {
    bodyParams["Locale"] = input.Locale;
  }
  if (input.Value !== undefined) {
    bodyParams["Value"] = input.Value;
  }
  return bodyParams;
};

const serializeAws_json1_1TextList = (
  input: Array<Text>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_json1_1Text(entry, context));
  }
  return contents;
};

const serializeAws_json1_1DeleteDeviceUsageDataRequest = (
  input: DeleteDeviceUsageDataRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.DeviceArn !== undefined) {
    bodyParams["DeviceArn"] = input.DeviceArn;
  }
  if (input.DeviceUsageType !== undefined) {
    bodyParams["DeviceUsageType"] = input.DeviceUsageType;
  }
  return bodyParams;
};

const serializeAws_json1_1ApproveSkillRequest = (
  input: ApproveSkillRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.SkillId !== undefined) {
    bodyParams["SkillId"] = input.SkillId;
  }
  return bodyParams;
};

const serializeAws_json1_1AssociateContactWithAddressBookRequest = (
  input: AssociateContactWithAddressBookRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.AddressBookArn !== undefined) {
    bodyParams["AddressBookArn"] = input.AddressBookArn;
  }
  if (input.ContactArn !== undefined) {
    bodyParams["ContactArn"] = input.ContactArn;
  }
  return bodyParams;
};

const serializeAws_json1_1AssociateDeviceWithNetworkProfileRequest = (
  input: AssociateDeviceWithNetworkProfileRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.DeviceArn !== undefined) {
    bodyParams["DeviceArn"] = input.DeviceArn;
  }
  if (input.NetworkProfileArn !== undefined) {
    bodyParams["NetworkProfileArn"] = input.NetworkProfileArn;
  }
  return bodyParams;
};

const serializeAws_json1_1AssociateDeviceWithRoomRequest = (
  input: AssociateDeviceWithRoomRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.DeviceArn !== undefined) {
    bodyParams["DeviceArn"] = input.DeviceArn;
  }
  if (input.RoomArn !== undefined) {
    bodyParams["RoomArn"] = input.RoomArn;
  }
  return bodyParams;
};

const serializeAws_json1_1AssociateSkillGroupWithRoomRequest = (
  input: AssociateSkillGroupWithRoomRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.RoomArn !== undefined) {
    bodyParams["RoomArn"] = input.RoomArn;
  }
  if (input.SkillGroupArn !== undefined) {
    bodyParams["SkillGroupArn"] = input.SkillGroupArn;
  }
  return bodyParams;
};

const serializeAws_json1_1AssociateSkillWithSkillGroupRequest = (
  input: AssociateSkillWithSkillGroupRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.SkillGroupArn !== undefined) {
    bodyParams["SkillGroupArn"] = input.SkillGroupArn;
  }
  if (input.SkillId !== undefined) {
    bodyParams["SkillId"] = input.SkillId;
  }
  return bodyParams;
};

const serializeAws_json1_1AssociateSkillWithUsersRequest = (
  input: AssociateSkillWithUsersRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.SkillId !== undefined) {
    bodyParams["SkillId"] = input.SkillId;
  }
  return bodyParams;
};

const serializeAws_json1_1AuthorizationResult = (
  input: { [key: string]: string },
  context: __SerdeContext
): any => {
  const mapParams: any = {};
  Object.keys(input).forEach(key => {
    mapParams[key] = input[key];
  });
  return mapParams;
};

const serializeAws_json1_1BusinessReportContentRange = (
  input: BusinessReportContentRange,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Interval !== undefined) {
    bodyParams["Interval"] = input.Interval;
  }
  return bodyParams;
};

const serializeAws_json1_1BusinessReportRecurrence = (
  input: BusinessReportRecurrence,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.StartDate !== undefined) {
    bodyParams["StartDate"] = input.StartDate;
  }
  return bodyParams;
};

const serializeAws_json1_1ConferencePreference = (
  input: ConferencePreference,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.DefaultConferenceProviderArn !== undefined) {
    bodyParams["DefaultConferenceProviderArn"] =
      input.DefaultConferenceProviderArn;
  }
  return bodyParams;
};

const serializeAws_json1_1CreateAddressBookRequest = (
  input: CreateAddressBookRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ClientRequestToken === undefined) {
    input.ClientRequestToken = generateIdempotencyToken();
  }
  if (input.ClientRequestToken !== undefined) {
    bodyParams["ClientRequestToken"] = input.ClientRequestToken;
  }
  if (input.Description !== undefined) {
    bodyParams["Description"] = input.Description;
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  return bodyParams;
};

const serializeAws_json1_1CreateBusinessReportScheduleRequest = (
  input: CreateBusinessReportScheduleRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ClientRequestToken === undefined) {
    input.ClientRequestToken = generateIdempotencyToken();
  }
  if (input.ClientRequestToken !== undefined) {
    bodyParams["ClientRequestToken"] = input.ClientRequestToken;
  }
  if (input.ContentRange !== undefined) {
    bodyParams["ContentRange"] = serializeAws_json1_1BusinessReportContentRange(
      input.ContentRange,
      context
    );
  }
  if (input.Format !== undefined) {
    bodyParams["Format"] = input.Format;
  }
  if (input.Recurrence !== undefined) {
    bodyParams["Recurrence"] = serializeAws_json1_1BusinessReportRecurrence(
      input.Recurrence,
      context
    );
  }
  if (input.S3BucketName !== undefined) {
    bodyParams["S3BucketName"] = input.S3BucketName;
  }
  if (input.S3KeyPrefix !== undefined) {
    bodyParams["S3KeyPrefix"] = input.S3KeyPrefix;
  }
  if (input.ScheduleName !== undefined) {
    bodyParams["ScheduleName"] = input.ScheduleName;
  }
  return bodyParams;
};

const serializeAws_json1_1CreateConferenceProviderRequest = (
  input: CreateConferenceProviderRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ClientRequestToken === undefined) {
    input.ClientRequestToken = generateIdempotencyToken();
  }
  if (input.ClientRequestToken !== undefined) {
    bodyParams["ClientRequestToken"] = input.ClientRequestToken;
  }
  if (input.ConferenceProviderName !== undefined) {
    bodyParams["ConferenceProviderName"] = input.ConferenceProviderName;
  }
  if (input.ConferenceProviderType !== undefined) {
    bodyParams["ConferenceProviderType"] = input.ConferenceProviderType;
  }
  if (input.IPDialIn !== undefined) {
    bodyParams["IPDialIn"] = serializeAws_json1_1IPDialIn(
      input.IPDialIn,
      context
    );
  }
  if (input.MeetingSetting !== undefined) {
    bodyParams["MeetingSetting"] = serializeAws_json1_1MeetingSetting(
      input.MeetingSetting,
      context
    );
  }
  if (input.PSTNDialIn !== undefined) {
    bodyParams["PSTNDialIn"] = serializeAws_json1_1PSTNDialIn(
      input.PSTNDialIn,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1CreateContactRequest = (
  input: CreateContactRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ClientRequestToken === undefined) {
    input.ClientRequestToken = generateIdempotencyToken();
  }
  if (input.ClientRequestToken !== undefined) {
    bodyParams["ClientRequestToken"] = input.ClientRequestToken;
  }
  if (input.DisplayName !== undefined) {
    bodyParams["DisplayName"] = input.DisplayName;
  }
  if (input.FirstName !== undefined) {
    bodyParams["FirstName"] = input.FirstName;
  }
  if (input.LastName !== undefined) {
    bodyParams["LastName"] = input.LastName;
  }
  if (input.PhoneNumber !== undefined) {
    bodyParams["PhoneNumber"] = input.PhoneNumber;
  }
  if (input.PhoneNumbers !== undefined) {
    bodyParams["PhoneNumbers"] = serializeAws_json1_1PhoneNumberList(
      input.PhoneNumbers,
      context
    );
  }
  if (input.SipAddresses !== undefined) {
    bodyParams["SipAddresses"] = serializeAws_json1_1SipAddressList(
      input.SipAddresses,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1CreateEndOfMeetingReminder = (
  input: CreateEndOfMeetingReminder,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Enabled !== undefined) {
    bodyParams["Enabled"] = input.Enabled;
  }
  if (input.ReminderAtMinutes !== undefined) {
    bodyParams[
      "ReminderAtMinutes"
    ] = serializeAws_json1_1EndOfMeetingReminderMinutesList(
      input.ReminderAtMinutes,
      context
    );
  }
  if (input.ReminderType !== undefined) {
    bodyParams["ReminderType"] = input.ReminderType;
  }
  return bodyParams;
};

const serializeAws_json1_1CreateGatewayGroupRequest = (
  input: CreateGatewayGroupRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ClientRequestToken === undefined) {
    input.ClientRequestToken = generateIdempotencyToken();
  }
  if (input.ClientRequestToken !== undefined) {
    bodyParams["ClientRequestToken"] = input.ClientRequestToken;
  }
  if (input.Description !== undefined) {
    bodyParams["Description"] = input.Description;
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  return bodyParams;
};

const serializeAws_json1_1CreateInstantBooking = (
  input: CreateInstantBooking,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.DurationInMinutes !== undefined) {
    bodyParams["DurationInMinutes"] = input.DurationInMinutes;
  }
  if (input.Enabled !== undefined) {
    bodyParams["Enabled"] = input.Enabled;
  }
  return bodyParams;
};

const serializeAws_json1_1CreateMeetingRoomConfiguration = (
  input: CreateMeetingRoomConfiguration,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.EndOfMeetingReminder !== undefined) {
    bodyParams[
      "EndOfMeetingReminder"
    ] = serializeAws_json1_1CreateEndOfMeetingReminder(
      input.EndOfMeetingReminder,
      context
    );
  }
  if (input.InstantBooking !== undefined) {
    bodyParams["InstantBooking"] = serializeAws_json1_1CreateInstantBooking(
      input.InstantBooking,
      context
    );
  }
  if (input.RequireCheckIn !== undefined) {
    bodyParams["RequireCheckIn"] = serializeAws_json1_1CreateRequireCheckIn(
      input.RequireCheckIn,
      context
    );
  }
  if (input.RoomUtilizationMetricsEnabled !== undefined) {
    bodyParams["RoomUtilizationMetricsEnabled"] =
      input.RoomUtilizationMetricsEnabled;
  }
  return bodyParams;
};

const serializeAws_json1_1CreateNetworkProfileRequest = (
  input: CreateNetworkProfileRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.CertificateAuthorityArn !== undefined) {
    bodyParams["CertificateAuthorityArn"] = input.CertificateAuthorityArn;
  }
  if (input.ClientRequestToken === undefined) {
    input.ClientRequestToken = generateIdempotencyToken();
  }
  if (input.ClientRequestToken !== undefined) {
    bodyParams["ClientRequestToken"] = input.ClientRequestToken;
  }
  if (input.CurrentPassword !== undefined) {
    bodyParams["CurrentPassword"] = input.CurrentPassword;
  }
  if (input.Description !== undefined) {
    bodyParams["Description"] = input.Description;
  }
  if (input.EapMethod !== undefined) {
    bodyParams["EapMethod"] = input.EapMethod;
  }
  if (input.NetworkProfileName !== undefined) {
    bodyParams["NetworkProfileName"] = input.NetworkProfileName;
  }
  if (input.NextPassword !== undefined) {
    bodyParams["NextPassword"] = input.NextPassword;
  }
  if (input.SecurityType !== undefined) {
    bodyParams["SecurityType"] = input.SecurityType;
  }
  if (input.Ssid !== undefined) {
    bodyParams["Ssid"] = input.Ssid;
  }
  if (input.TrustAnchors !== undefined) {
    bodyParams["TrustAnchors"] = serializeAws_json1_1TrustAnchorList(
      input.TrustAnchors,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1CreateProfileRequest = (
  input: CreateProfileRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Address !== undefined) {
    bodyParams["Address"] = input.Address;
  }
  if (input.ClientRequestToken === undefined) {
    input.ClientRequestToken = generateIdempotencyToken();
  }
  if (input.ClientRequestToken !== undefined) {
    bodyParams["ClientRequestToken"] = input.ClientRequestToken;
  }
  if (input.DistanceUnit !== undefined) {
    bodyParams["DistanceUnit"] = input.DistanceUnit;
  }
  if (input.Locale !== undefined) {
    bodyParams["Locale"] = input.Locale;
  }
  if (input.MaxVolumeLimit !== undefined) {
    bodyParams["MaxVolumeLimit"] = input.MaxVolumeLimit;
  }
  if (input.MeetingRoomConfiguration !== undefined) {
    bodyParams[
      "MeetingRoomConfiguration"
    ] = serializeAws_json1_1CreateMeetingRoomConfiguration(
      input.MeetingRoomConfiguration,
      context
    );
  }
  if (input.PSTNEnabled !== undefined) {
    bodyParams["PSTNEnabled"] = input.PSTNEnabled;
  }
  if (input.ProfileName !== undefined) {
    bodyParams["ProfileName"] = input.ProfileName;
  }
  if (input.SetupModeDisabled !== undefined) {
    bodyParams["SetupModeDisabled"] = input.SetupModeDisabled;
  }
  if (input.TemperatureUnit !== undefined) {
    bodyParams["TemperatureUnit"] = input.TemperatureUnit;
  }
  if (input.Timezone !== undefined) {
    bodyParams["Timezone"] = input.Timezone;
  }
  if (input.WakeWord !== undefined) {
    bodyParams["WakeWord"] = input.WakeWord;
  }
  return bodyParams;
};

const serializeAws_json1_1CreateRequireCheckIn = (
  input: CreateRequireCheckIn,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Enabled !== undefined) {
    bodyParams["Enabled"] = input.Enabled;
  }
  if (input.ReleaseAfterMinutes !== undefined) {
    bodyParams["ReleaseAfterMinutes"] = input.ReleaseAfterMinutes;
  }
  return bodyParams;
};

const serializeAws_json1_1CreateRoomRequest = (
  input: CreateRoomRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ClientRequestToken === undefined) {
    input.ClientRequestToken = generateIdempotencyToken();
  }
  if (input.ClientRequestToken !== undefined) {
    bodyParams["ClientRequestToken"] = input.ClientRequestToken;
  }
  if (input.Description !== undefined) {
    bodyParams["Description"] = input.Description;
  }
  if (input.ProfileArn !== undefined) {
    bodyParams["ProfileArn"] = input.ProfileArn;
  }
  if (input.ProviderCalendarId !== undefined) {
    bodyParams["ProviderCalendarId"] = input.ProviderCalendarId;
  }
  if (input.RoomName !== undefined) {
    bodyParams["RoomName"] = input.RoomName;
  }
  if (input.Tags !== undefined) {
    bodyParams["Tags"] = serializeAws_json1_1TagList(input.Tags, context);
  }
  return bodyParams;
};

const serializeAws_json1_1CreateSkillGroupRequest = (
  input: CreateSkillGroupRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ClientRequestToken === undefined) {
    input.ClientRequestToken = generateIdempotencyToken();
  }
  if (input.ClientRequestToken !== undefined) {
    bodyParams["ClientRequestToken"] = input.ClientRequestToken;
  }
  if (input.Description !== undefined) {
    bodyParams["Description"] = input.Description;
  }
  if (input.SkillGroupName !== undefined) {
    bodyParams["SkillGroupName"] = input.SkillGroupName;
  }
  return bodyParams;
};

const serializeAws_json1_1CreateUserRequest = (
  input: CreateUserRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ClientRequestToken === undefined) {
    input.ClientRequestToken = generateIdempotencyToken();
  }
  if (input.ClientRequestToken !== undefined) {
    bodyParams["ClientRequestToken"] = input.ClientRequestToken;
  }
  if (input.Email !== undefined) {
    bodyParams["Email"] = input.Email;
  }
  if (input.FirstName !== undefined) {
    bodyParams["FirstName"] = input.FirstName;
  }
  if (input.LastName !== undefined) {
    bodyParams["LastName"] = input.LastName;
  }
  if (input.Tags !== undefined) {
    bodyParams["Tags"] = serializeAws_json1_1TagList(input.Tags, context);
  }
  if (input.UserId !== undefined) {
    bodyParams["UserId"] = input.UserId;
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteAddressBookRequest = (
  input: DeleteAddressBookRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.AddressBookArn !== undefined) {
    bodyParams["AddressBookArn"] = input.AddressBookArn;
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteBusinessReportScheduleRequest = (
  input: DeleteBusinessReportScheduleRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ScheduleArn !== undefined) {
    bodyParams["ScheduleArn"] = input.ScheduleArn;
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteConferenceProviderRequest = (
  input: DeleteConferenceProviderRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ConferenceProviderArn !== undefined) {
    bodyParams["ConferenceProviderArn"] = input.ConferenceProviderArn;
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteContactRequest = (
  input: DeleteContactRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ContactArn !== undefined) {
    bodyParams["ContactArn"] = input.ContactArn;
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteDeviceRequest = (
  input: DeleteDeviceRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.DeviceArn !== undefined) {
    bodyParams["DeviceArn"] = input.DeviceArn;
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteGatewayGroupRequest = (
  input: DeleteGatewayGroupRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.GatewayGroupArn !== undefined) {
    bodyParams["GatewayGroupArn"] = input.GatewayGroupArn;
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteNetworkProfileRequest = (
  input: DeleteNetworkProfileRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.NetworkProfileArn !== undefined) {
    bodyParams["NetworkProfileArn"] = input.NetworkProfileArn;
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteProfileRequest = (
  input: DeleteProfileRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ProfileArn !== undefined) {
    bodyParams["ProfileArn"] = input.ProfileArn;
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteRoomRequest = (
  input: DeleteRoomRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.RoomArn !== undefined) {
    bodyParams["RoomArn"] = input.RoomArn;
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteRoomSkillParameterRequest = (
  input: DeleteRoomSkillParameterRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ParameterKey !== undefined) {
    bodyParams["ParameterKey"] = input.ParameterKey;
  }
  if (input.RoomArn !== undefined) {
    bodyParams["RoomArn"] = input.RoomArn;
  }
  if (input.SkillId !== undefined) {
    bodyParams["SkillId"] = input.SkillId;
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteSkillAuthorizationRequest = (
  input: DeleteSkillAuthorizationRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.RoomArn !== undefined) {
    bodyParams["RoomArn"] = input.RoomArn;
  }
  if (input.SkillId !== undefined) {
    bodyParams["SkillId"] = input.SkillId;
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteSkillGroupRequest = (
  input: DeleteSkillGroupRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.SkillGroupArn !== undefined) {
    bodyParams["SkillGroupArn"] = input.SkillGroupArn;
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteUserRequest = (
  input: DeleteUserRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.EnrollmentId !== undefined) {
    bodyParams["EnrollmentId"] = input.EnrollmentId;
  }
  if (input.UserArn !== undefined) {
    bodyParams["UserArn"] = input.UserArn;
  }
  return bodyParams;
};

const serializeAws_json1_1DisassociateContactFromAddressBookRequest = (
  input: DisassociateContactFromAddressBookRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.AddressBookArn !== undefined) {
    bodyParams["AddressBookArn"] = input.AddressBookArn;
  }
  if (input.ContactArn !== undefined) {
    bodyParams["ContactArn"] = input.ContactArn;
  }
  return bodyParams;
};

const serializeAws_json1_1DisassociateDeviceFromRoomRequest = (
  input: DisassociateDeviceFromRoomRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.DeviceArn !== undefined) {
    bodyParams["DeviceArn"] = input.DeviceArn;
  }
  return bodyParams;
};

const serializeAws_json1_1DisassociateSkillFromSkillGroupRequest = (
  input: DisassociateSkillFromSkillGroupRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.SkillGroupArn !== undefined) {
    bodyParams["SkillGroupArn"] = input.SkillGroupArn;
  }
  if (input.SkillId !== undefined) {
    bodyParams["SkillId"] = input.SkillId;
  }
  return bodyParams;
};

const serializeAws_json1_1DisassociateSkillFromUsersRequest = (
  input: DisassociateSkillFromUsersRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.SkillId !== undefined) {
    bodyParams["SkillId"] = input.SkillId;
  }
  return bodyParams;
};

const serializeAws_json1_1DisassociateSkillGroupFromRoomRequest = (
  input: DisassociateSkillGroupFromRoomRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.RoomArn !== undefined) {
    bodyParams["RoomArn"] = input.RoomArn;
  }
  if (input.SkillGroupArn !== undefined) {
    bodyParams["SkillGroupArn"] = input.SkillGroupArn;
  }
  return bodyParams;
};

const serializeAws_json1_1EndOfMeetingReminderMinutesList = (
  input: Array<number>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_json1_1Features = (
  input: Array<Feature | string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_json1_1ForgetSmartHomeAppliancesRequest = (
  input: ForgetSmartHomeAppliancesRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.RoomArn !== undefined) {
    bodyParams["RoomArn"] = input.RoomArn;
  }
  return bodyParams;
};

const serializeAws_json1_1GetAddressBookRequest = (
  input: GetAddressBookRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.AddressBookArn !== undefined) {
    bodyParams["AddressBookArn"] = input.AddressBookArn;
  }
  return bodyParams;
};

const serializeAws_json1_1GetConferencePreferenceRequest = (
  input: GetConferencePreferenceRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  return bodyParams;
};

const serializeAws_json1_1GetConferenceProviderRequest = (
  input: GetConferenceProviderRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ConferenceProviderArn !== undefined) {
    bodyParams["ConferenceProviderArn"] = input.ConferenceProviderArn;
  }
  return bodyParams;
};

const serializeAws_json1_1GetContactRequest = (
  input: GetContactRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ContactArn !== undefined) {
    bodyParams["ContactArn"] = input.ContactArn;
  }
  return bodyParams;
};

const serializeAws_json1_1GetDeviceRequest = (
  input: GetDeviceRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.DeviceArn !== undefined) {
    bodyParams["DeviceArn"] = input.DeviceArn;
  }
  return bodyParams;
};

const serializeAws_json1_1GetGatewayGroupRequest = (
  input: GetGatewayGroupRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.GatewayGroupArn !== undefined) {
    bodyParams["GatewayGroupArn"] = input.GatewayGroupArn;
  }
  return bodyParams;
};

const serializeAws_json1_1GetGatewayRequest = (
  input: GetGatewayRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.GatewayArn !== undefined) {
    bodyParams["GatewayArn"] = input.GatewayArn;
  }
  return bodyParams;
};

const serializeAws_json1_1GetInvitationConfigurationRequest = (
  input: GetInvitationConfigurationRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  return bodyParams;
};

const serializeAws_json1_1GetNetworkProfileRequest = (
  input: GetNetworkProfileRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.NetworkProfileArn !== undefined) {
    bodyParams["NetworkProfileArn"] = input.NetworkProfileArn;
  }
  return bodyParams;
};

const serializeAws_json1_1GetProfileRequest = (
  input: GetProfileRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ProfileArn !== undefined) {
    bodyParams["ProfileArn"] = input.ProfileArn;
  }
  return bodyParams;
};

const serializeAws_json1_1GetRoomRequest = (
  input: GetRoomRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.RoomArn !== undefined) {
    bodyParams["RoomArn"] = input.RoomArn;
  }
  return bodyParams;
};

const serializeAws_json1_1GetRoomSkillParameterRequest = (
  input: GetRoomSkillParameterRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ParameterKey !== undefined) {
    bodyParams["ParameterKey"] = input.ParameterKey;
  }
  if (input.RoomArn !== undefined) {
    bodyParams["RoomArn"] = input.RoomArn;
  }
  if (input.SkillId !== undefined) {
    bodyParams["SkillId"] = input.SkillId;
  }
  return bodyParams;
};

const serializeAws_json1_1GetSkillGroupRequest = (
  input: GetSkillGroupRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.SkillGroupArn !== undefined) {
    bodyParams["SkillGroupArn"] = input.SkillGroupArn;
  }
  return bodyParams;
};

const serializeAws_json1_1ListBusinessReportSchedulesRequest = (
  input: ListBusinessReportSchedulesRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  return bodyParams;
};

const serializeAws_json1_1ListConferenceProvidersRequest = (
  input: ListConferenceProvidersRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  return bodyParams;
};

const serializeAws_json1_1ListDeviceEventsRequest = (
  input: ListDeviceEventsRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.DeviceArn !== undefined) {
    bodyParams["DeviceArn"] = input.DeviceArn;
  }
  if (input.EventType !== undefined) {
    bodyParams["EventType"] = input.EventType;
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  return bodyParams;
};

const serializeAws_json1_1ListGatewayGroupsRequest = (
  input: ListGatewayGroupsRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  return bodyParams;
};

const serializeAws_json1_1ListGatewaysRequest = (
  input: ListGatewaysRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.GatewayGroupArn !== undefined) {
    bodyParams["GatewayGroupArn"] = input.GatewayGroupArn;
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  return bodyParams;
};

const serializeAws_json1_1ListSkillsRequest = (
  input: ListSkillsRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.EnablementType !== undefined) {
    bodyParams["EnablementType"] = input.EnablementType;
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  if (input.SkillGroupArn !== undefined) {
    bodyParams["SkillGroupArn"] = input.SkillGroupArn;
  }
  if (input.SkillType !== undefined) {
    bodyParams["SkillType"] = input.SkillType;
  }
  return bodyParams;
};

const serializeAws_json1_1ListSkillsStoreCategoriesRequest = (
  input: ListSkillsStoreCategoriesRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  return bodyParams;
};

const serializeAws_json1_1ListSkillsStoreSkillsByCategoryRequest = (
  input: ListSkillsStoreSkillsByCategoryRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.CategoryId !== undefined) {
    bodyParams["CategoryId"] = input.CategoryId;
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  return bodyParams;
};

const serializeAws_json1_1ListSmartHomeAppliancesRequest = (
  input: ListSmartHomeAppliancesRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  if (input.RoomArn !== undefined) {
    bodyParams["RoomArn"] = input.RoomArn;
  }
  return bodyParams;
};

const serializeAws_json1_1ListTagsRequest = (
  input: ListTagsRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Arn !== undefined) {
    bodyParams["Arn"] = input.Arn;
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  return bodyParams;
};

const serializeAws_json1_1PhoneNumber = (
  input: PhoneNumber,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Number !== undefined) {
    bodyParams["Number"] = input.Number;
  }
  if (input.Type !== undefined) {
    bodyParams["Type"] = input.Type;
  }
  return bodyParams;
};

const serializeAws_json1_1PhoneNumberList = (
  input: Array<PhoneNumber>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_json1_1PhoneNumber(entry, context));
  }
  return contents;
};

const serializeAws_json1_1PutConferencePreferenceRequest = (
  input: PutConferencePreferenceRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ConferencePreference !== undefined) {
    bodyParams[
      "ConferencePreference"
    ] = serializeAws_json1_1ConferencePreference(
      input.ConferencePreference,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1PutInvitationConfigurationRequest = (
  input: PutInvitationConfigurationRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ContactEmail !== undefined) {
    bodyParams["ContactEmail"] = input.ContactEmail;
  }
  if (input.OrganizationName !== undefined) {
    bodyParams["OrganizationName"] = input.OrganizationName;
  }
  if (input.PrivateSkillIds !== undefined) {
    bodyParams["PrivateSkillIds"] = serializeAws_json1_1ShortSkillIdList(
      input.PrivateSkillIds,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1PutRoomSkillParameterRequest = (
  input: PutRoomSkillParameterRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.RoomArn !== undefined) {
    bodyParams["RoomArn"] = input.RoomArn;
  }
  if (input.RoomSkillParameter !== undefined) {
    bodyParams["RoomSkillParameter"] = serializeAws_json1_1RoomSkillParameter(
      input.RoomSkillParameter,
      context
    );
  }
  if (input.SkillId !== undefined) {
    bodyParams["SkillId"] = input.SkillId;
  }
  return bodyParams;
};

const serializeAws_json1_1PutSkillAuthorizationRequest = (
  input: PutSkillAuthorizationRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.AuthorizationResult !== undefined) {
    bodyParams["AuthorizationResult"] = serializeAws_json1_1AuthorizationResult(
      input.AuthorizationResult,
      context
    );
  }
  if (input.RoomArn !== undefined) {
    bodyParams["RoomArn"] = input.RoomArn;
  }
  if (input.SkillId !== undefined) {
    bodyParams["SkillId"] = input.SkillId;
  }
  return bodyParams;
};

const serializeAws_json1_1RegisterAVSDeviceRequest = (
  input: RegisterAVSDeviceRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.AmazonId !== undefined) {
    bodyParams["AmazonId"] = input.AmazonId;
  }
  if (input.ClientId !== undefined) {
    bodyParams["ClientId"] = input.ClientId;
  }
  if (input.DeviceSerialNumber !== undefined) {
    bodyParams["DeviceSerialNumber"] = input.DeviceSerialNumber;
  }
  if (input.ProductId !== undefined) {
    bodyParams["ProductId"] = input.ProductId;
  }
  if (input.UserCode !== undefined) {
    bodyParams["UserCode"] = input.UserCode;
  }
  return bodyParams;
};

const serializeAws_json1_1RejectSkillRequest = (
  input: RejectSkillRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.SkillId !== undefined) {
    bodyParams["SkillId"] = input.SkillId;
  }
  return bodyParams;
};

const serializeAws_json1_1ResolveRoomRequest = (
  input: ResolveRoomRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.SkillId !== undefined) {
    bodyParams["SkillId"] = input.SkillId;
  }
  if (input.UserId !== undefined) {
    bodyParams["UserId"] = input.UserId;
  }
  return bodyParams;
};

const serializeAws_json1_1RevokeInvitationRequest = (
  input: RevokeInvitationRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.EnrollmentId !== undefined) {
    bodyParams["EnrollmentId"] = input.EnrollmentId;
  }
  if (input.UserArn !== undefined) {
    bodyParams["UserArn"] = input.UserArn;
  }
  return bodyParams;
};

const serializeAws_json1_1RoomSkillParameter = (
  input: RoomSkillParameter,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ParameterKey !== undefined) {
    bodyParams["ParameterKey"] = input.ParameterKey;
  }
  if (input.ParameterValue !== undefined) {
    bodyParams["ParameterValue"] = input.ParameterValue;
  }
  return bodyParams;
};

const serializeAws_json1_1SearchAddressBooksRequest = (
  input: SearchAddressBooksRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Filters !== undefined) {
    bodyParams["Filters"] = serializeAws_json1_1FilterList(
      input.Filters,
      context
    );
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  if (input.SortCriteria !== undefined) {
    bodyParams["SortCriteria"] = serializeAws_json1_1SortList(
      input.SortCriteria,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1SearchContactsRequest = (
  input: SearchContactsRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Filters !== undefined) {
    bodyParams["Filters"] = serializeAws_json1_1FilterList(
      input.Filters,
      context
    );
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  if (input.SortCriteria !== undefined) {
    bodyParams["SortCriteria"] = serializeAws_json1_1SortList(
      input.SortCriteria,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1SearchDevicesRequest = (
  input: SearchDevicesRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Filters !== undefined) {
    bodyParams["Filters"] = serializeAws_json1_1FilterList(
      input.Filters,
      context
    );
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  if (input.SortCriteria !== undefined) {
    bodyParams["SortCriteria"] = serializeAws_json1_1SortList(
      input.SortCriteria,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1SearchNetworkProfilesRequest = (
  input: SearchNetworkProfilesRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Filters !== undefined) {
    bodyParams["Filters"] = serializeAws_json1_1FilterList(
      input.Filters,
      context
    );
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  if (input.SortCriteria !== undefined) {
    bodyParams["SortCriteria"] = serializeAws_json1_1SortList(
      input.SortCriteria,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1SearchProfilesRequest = (
  input: SearchProfilesRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Filters !== undefined) {
    bodyParams["Filters"] = serializeAws_json1_1FilterList(
      input.Filters,
      context
    );
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  if (input.SortCriteria !== undefined) {
    bodyParams["SortCriteria"] = serializeAws_json1_1SortList(
      input.SortCriteria,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1SearchRoomsRequest = (
  input: SearchRoomsRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Filters !== undefined) {
    bodyParams["Filters"] = serializeAws_json1_1FilterList(
      input.Filters,
      context
    );
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  if (input.SortCriteria !== undefined) {
    bodyParams["SortCriteria"] = serializeAws_json1_1SortList(
      input.SortCriteria,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1SearchSkillGroupsRequest = (
  input: SearchSkillGroupsRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Filters !== undefined) {
    bodyParams["Filters"] = serializeAws_json1_1FilterList(
      input.Filters,
      context
    );
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  if (input.SortCriteria !== undefined) {
    bodyParams["SortCriteria"] = serializeAws_json1_1SortList(
      input.SortCriteria,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1SearchUsersRequest = (
  input: SearchUsersRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Filters !== undefined) {
    bodyParams["Filters"] = serializeAws_json1_1FilterList(
      input.Filters,
      context
    );
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  if (input.SortCriteria !== undefined) {
    bodyParams["SortCriteria"] = serializeAws_json1_1SortList(
      input.SortCriteria,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1SendInvitationRequest = (
  input: SendInvitationRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.UserArn !== undefined) {
    bodyParams["UserArn"] = input.UserArn;
  }
  return bodyParams;
};

const serializeAws_json1_1ShortSkillIdList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_json1_1SipAddress = (
  input: SipAddress,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Type !== undefined) {
    bodyParams["Type"] = input.Type;
  }
  if (input.Uri !== undefined) {
    bodyParams["Uri"] = input.Uri;
  }
  return bodyParams;
};

const serializeAws_json1_1SipAddressList = (
  input: Array<SipAddress>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_json1_1SipAddress(entry, context));
  }
  return contents;
};

const serializeAws_json1_1Sort = (
  input: Sort,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Key !== undefined) {
    bodyParams["Key"] = input.Key;
  }
  if (input.Value !== undefined) {
    bodyParams["Value"] = input.Value;
  }
  return bodyParams;
};

const serializeAws_json1_1SortList = (
  input: Array<Sort>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_json1_1Sort(entry, context));
  }
  return contents;
};

const serializeAws_json1_1StartDeviceSyncRequest = (
  input: StartDeviceSyncRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.DeviceArn !== undefined) {
    bodyParams["DeviceArn"] = input.DeviceArn;
  }
  if (input.Features !== undefined) {
    bodyParams["Features"] = serializeAws_json1_1Features(
      input.Features,
      context
    );
  }
  if (input.RoomArn !== undefined) {
    bodyParams["RoomArn"] = input.RoomArn;
  }
  return bodyParams;
};

const serializeAws_json1_1StartSmartHomeApplianceDiscoveryRequest = (
  input: StartSmartHomeApplianceDiscoveryRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.RoomArn !== undefined) {
    bodyParams["RoomArn"] = input.RoomArn;
  }
  return bodyParams;
};

const serializeAws_json1_1Tag = (input: Tag, context: __SerdeContext): any => {
  const bodyParams: any = {};
  if (input.Key !== undefined) {
    bodyParams["Key"] = input.Key;
  }
  if (input.Value !== undefined) {
    bodyParams["Value"] = input.Value;
  }
  return bodyParams;
};

const serializeAws_json1_1TagKeyList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_json1_1TagList = (
  input: Array<Tag>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_json1_1Tag(entry, context));
  }
  return contents;
};

const serializeAws_json1_1TagResourceRequest = (
  input: TagResourceRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Arn !== undefined) {
    bodyParams["Arn"] = input.Arn;
  }
  if (input.Tags !== undefined) {
    bodyParams["Tags"] = serializeAws_json1_1TagList(input.Tags, context);
  }
  return bodyParams;
};

const serializeAws_json1_1TrustAnchorList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_json1_1UntagResourceRequest = (
  input: UntagResourceRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Arn !== undefined) {
    bodyParams["Arn"] = input.Arn;
  }
  if (input.TagKeys !== undefined) {
    bodyParams["TagKeys"] = serializeAws_json1_1TagKeyList(
      input.TagKeys,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1UpdateAddressBookRequest = (
  input: UpdateAddressBookRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.AddressBookArn !== undefined) {
    bodyParams["AddressBookArn"] = input.AddressBookArn;
  }
  if (input.Description !== undefined) {
    bodyParams["Description"] = input.Description;
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  return bodyParams;
};

const serializeAws_json1_1UpdateBusinessReportScheduleRequest = (
  input: UpdateBusinessReportScheduleRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Format !== undefined) {
    bodyParams["Format"] = input.Format;
  }
  if (input.Recurrence !== undefined) {
    bodyParams["Recurrence"] = serializeAws_json1_1BusinessReportRecurrence(
      input.Recurrence,
      context
    );
  }
  if (input.S3BucketName !== undefined) {
    bodyParams["S3BucketName"] = input.S3BucketName;
  }
  if (input.S3KeyPrefix !== undefined) {
    bodyParams["S3KeyPrefix"] = input.S3KeyPrefix;
  }
  if (input.ScheduleArn !== undefined) {
    bodyParams["ScheduleArn"] = input.ScheduleArn;
  }
  if (input.ScheduleName !== undefined) {
    bodyParams["ScheduleName"] = input.ScheduleName;
  }
  return bodyParams;
};

const serializeAws_json1_1UpdateConferenceProviderRequest = (
  input: UpdateConferenceProviderRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ConferenceProviderArn !== undefined) {
    bodyParams["ConferenceProviderArn"] = input.ConferenceProviderArn;
  }
  if (input.ConferenceProviderType !== undefined) {
    bodyParams["ConferenceProviderType"] = input.ConferenceProviderType;
  }
  if (input.IPDialIn !== undefined) {
    bodyParams["IPDialIn"] = serializeAws_json1_1IPDialIn(
      input.IPDialIn,
      context
    );
  }
  if (input.MeetingSetting !== undefined) {
    bodyParams["MeetingSetting"] = serializeAws_json1_1MeetingSetting(
      input.MeetingSetting,
      context
    );
  }
  if (input.PSTNDialIn !== undefined) {
    bodyParams["PSTNDialIn"] = serializeAws_json1_1PSTNDialIn(
      input.PSTNDialIn,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1UpdateContactRequest = (
  input: UpdateContactRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ContactArn !== undefined) {
    bodyParams["ContactArn"] = input.ContactArn;
  }
  if (input.DisplayName !== undefined) {
    bodyParams["DisplayName"] = input.DisplayName;
  }
  if (input.FirstName !== undefined) {
    bodyParams["FirstName"] = input.FirstName;
  }
  if (input.LastName !== undefined) {
    bodyParams["LastName"] = input.LastName;
  }
  if (input.PhoneNumber !== undefined) {
    bodyParams["PhoneNumber"] = input.PhoneNumber;
  }
  if (input.PhoneNumbers !== undefined) {
    bodyParams["PhoneNumbers"] = serializeAws_json1_1PhoneNumberList(
      input.PhoneNumbers,
      context
    );
  }
  if (input.SipAddresses !== undefined) {
    bodyParams["SipAddresses"] = serializeAws_json1_1SipAddressList(
      input.SipAddresses,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1UpdateDeviceRequest = (
  input: UpdateDeviceRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.DeviceArn !== undefined) {
    bodyParams["DeviceArn"] = input.DeviceArn;
  }
  if (input.DeviceName !== undefined) {
    bodyParams["DeviceName"] = input.DeviceName;
  }
  return bodyParams;
};

const serializeAws_json1_1UpdateEndOfMeetingReminder = (
  input: UpdateEndOfMeetingReminder,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Enabled !== undefined) {
    bodyParams["Enabled"] = input.Enabled;
  }
  if (input.ReminderAtMinutes !== undefined) {
    bodyParams[
      "ReminderAtMinutes"
    ] = serializeAws_json1_1EndOfMeetingReminderMinutesList(
      input.ReminderAtMinutes,
      context
    );
  }
  if (input.ReminderType !== undefined) {
    bodyParams["ReminderType"] = input.ReminderType;
  }
  return bodyParams;
};

const serializeAws_json1_1UpdateGatewayGroupRequest = (
  input: UpdateGatewayGroupRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Description !== undefined) {
    bodyParams["Description"] = input.Description;
  }
  if (input.GatewayGroupArn !== undefined) {
    bodyParams["GatewayGroupArn"] = input.GatewayGroupArn;
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  return bodyParams;
};

const serializeAws_json1_1UpdateGatewayRequest = (
  input: UpdateGatewayRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Description !== undefined) {
    bodyParams["Description"] = input.Description;
  }
  if (input.GatewayArn !== undefined) {
    bodyParams["GatewayArn"] = input.GatewayArn;
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.SoftwareVersion !== undefined) {
    bodyParams["SoftwareVersion"] = input.SoftwareVersion;
  }
  return bodyParams;
};

const serializeAws_json1_1UpdateInstantBooking = (
  input: UpdateInstantBooking,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.DurationInMinutes !== undefined) {
    bodyParams["DurationInMinutes"] = input.DurationInMinutes;
  }
  if (input.Enabled !== undefined) {
    bodyParams["Enabled"] = input.Enabled;
  }
  return bodyParams;
};

const serializeAws_json1_1UpdateMeetingRoomConfiguration = (
  input: UpdateMeetingRoomConfiguration,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.EndOfMeetingReminder !== undefined) {
    bodyParams[
      "EndOfMeetingReminder"
    ] = serializeAws_json1_1UpdateEndOfMeetingReminder(
      input.EndOfMeetingReminder,
      context
    );
  }
  if (input.InstantBooking !== undefined) {
    bodyParams["InstantBooking"] = serializeAws_json1_1UpdateInstantBooking(
      input.InstantBooking,
      context
    );
  }
  if (input.RequireCheckIn !== undefined) {
    bodyParams["RequireCheckIn"] = serializeAws_json1_1UpdateRequireCheckIn(
      input.RequireCheckIn,
      context
    );
  }
  if (input.RoomUtilizationMetricsEnabled !== undefined) {
    bodyParams["RoomUtilizationMetricsEnabled"] =
      input.RoomUtilizationMetricsEnabled;
  }
  return bodyParams;
};

const serializeAws_json1_1UpdateNetworkProfileRequest = (
  input: UpdateNetworkProfileRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.CertificateAuthorityArn !== undefined) {
    bodyParams["CertificateAuthorityArn"] = input.CertificateAuthorityArn;
  }
  if (input.CurrentPassword !== undefined) {
    bodyParams["CurrentPassword"] = input.CurrentPassword;
  }
  if (input.Description !== undefined) {
    bodyParams["Description"] = input.Description;
  }
  if (input.NetworkProfileArn !== undefined) {
    bodyParams["NetworkProfileArn"] = input.NetworkProfileArn;
  }
  if (input.NetworkProfileName !== undefined) {
    bodyParams["NetworkProfileName"] = input.NetworkProfileName;
  }
  if (input.NextPassword !== undefined) {
    bodyParams["NextPassword"] = input.NextPassword;
  }
  if (input.TrustAnchors !== undefined) {
    bodyParams["TrustAnchors"] = serializeAws_json1_1TrustAnchorList(
      input.TrustAnchors,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1UpdateProfileRequest = (
  input: UpdateProfileRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Address !== undefined) {
    bodyParams["Address"] = input.Address;
  }
  if (input.DistanceUnit !== undefined) {
    bodyParams["DistanceUnit"] = input.DistanceUnit;
  }
  if (input.IsDefault !== undefined) {
    bodyParams["IsDefault"] = input.IsDefault;
  }
  if (input.Locale !== undefined) {
    bodyParams["Locale"] = input.Locale;
  }
  if (input.MaxVolumeLimit !== undefined) {
    bodyParams["MaxVolumeLimit"] = input.MaxVolumeLimit;
  }
  if (input.MeetingRoomConfiguration !== undefined) {
    bodyParams[
      "MeetingRoomConfiguration"
    ] = serializeAws_json1_1UpdateMeetingRoomConfiguration(
      input.MeetingRoomConfiguration,
      context
    );
  }
  if (input.PSTNEnabled !== undefined) {
    bodyParams["PSTNEnabled"] = input.PSTNEnabled;
  }
  if (input.ProfileArn !== undefined) {
    bodyParams["ProfileArn"] = input.ProfileArn;
  }
  if (input.ProfileName !== undefined) {
    bodyParams["ProfileName"] = input.ProfileName;
  }
  if (input.SetupModeDisabled !== undefined) {
    bodyParams["SetupModeDisabled"] = input.SetupModeDisabled;
  }
  if (input.TemperatureUnit !== undefined) {
    bodyParams["TemperatureUnit"] = input.TemperatureUnit;
  }
  if (input.Timezone !== undefined) {
    bodyParams["Timezone"] = input.Timezone;
  }
  if (input.WakeWord !== undefined) {
    bodyParams["WakeWord"] = input.WakeWord;
  }
  return bodyParams;
};

const serializeAws_json1_1UpdateRequireCheckIn = (
  input: UpdateRequireCheckIn,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Enabled !== undefined) {
    bodyParams["Enabled"] = input.Enabled;
  }
  if (input.ReleaseAfterMinutes !== undefined) {
    bodyParams["ReleaseAfterMinutes"] = input.ReleaseAfterMinutes;
  }
  return bodyParams;
};

const serializeAws_json1_1UpdateRoomRequest = (
  input: UpdateRoomRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Description !== undefined) {
    bodyParams["Description"] = input.Description;
  }
  if (input.ProfileArn !== undefined) {
    bodyParams["ProfileArn"] = input.ProfileArn;
  }
  if (input.ProviderCalendarId !== undefined) {
    bodyParams["ProviderCalendarId"] = input.ProviderCalendarId;
  }
  if (input.RoomArn !== undefined) {
    bodyParams["RoomArn"] = input.RoomArn;
  }
  if (input.RoomName !== undefined) {
    bodyParams["RoomName"] = input.RoomName;
  }
  return bodyParams;
};

const serializeAws_json1_1UpdateSkillGroupRequest = (
  input: UpdateSkillGroupRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Description !== undefined) {
    bodyParams["Description"] = input.Description;
  }
  if (input.SkillGroupArn !== undefined) {
    bodyParams["SkillGroupArn"] = input.SkillGroupArn;
  }
  if (input.SkillGroupName !== undefined) {
    bodyParams["SkillGroupName"] = input.SkillGroupName;
  }
  return bodyParams;
};

const deserializeAws_json1_1AlreadyExistsException = (
  output: any,
  context: __SerdeContext
): AlreadyExistsException => {
  let contents: any = {
    __type: "AlreadyExistsException",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1ConcurrentModificationException = (
  output: any,
  context: __SerdeContext
): ConcurrentModificationException => {
  let contents: any = {
    __type: "ConcurrentModificationException",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1DeviceNotRegisteredException = (
  output: any,
  context: __SerdeContext
): DeviceNotRegisteredException => {
  let contents: any = {
    __type: "DeviceNotRegisteredException",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1LimitExceededException = (
  output: any,
  context: __SerdeContext
): LimitExceededException => {
  let contents: any = {
    __type: "LimitExceededException",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1NameInUseException = (
  output: any,
  context: __SerdeContext
): NameInUseException => {
  let contents: any = {
    __type: "NameInUseException",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1NotFoundException = (
  output: any,
  context: __SerdeContext
): NotFoundException => {
  let contents: any = {
    __type: "NotFoundException",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1ResourceInUseException = (
  output: any,
  context: __SerdeContext
): ResourceInUseException => {
  let contents: any = {
    __type: "ResourceInUseException",
    ClientRequestToken: undefined,
    Message: undefined
  };
  if (
    output.ClientRequestToken !== undefined &&
    output.ClientRequestToken !== null
  ) {
    contents.ClientRequestToken = output.ClientRequestToken;
  }
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1UnauthorizedException = (
  output: any,
  context: __SerdeContext
): UnauthorizedException => {
  let contents: any = {
    __type: "UnauthorizedException",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1ConferenceProvider = (
  output: any,
  context: __SerdeContext
): ConferenceProvider => {
  let contents: any = {
    __type: "ConferenceProvider",
    Arn: undefined,
    IPDialIn: undefined,
    MeetingSetting: undefined,
    Name: undefined,
    PSTNDialIn: undefined,
    Type: undefined
  };
  if (output.Arn !== undefined && output.Arn !== null) {
    contents.Arn = output.Arn;
  }
  if (output.IPDialIn !== undefined && output.IPDialIn !== null) {
    contents.IPDialIn = deserializeAws_json1_1IPDialIn(
      output.IPDialIn,
      context
    );
  }
  if (output.MeetingSetting !== undefined && output.MeetingSetting !== null) {
    contents.MeetingSetting = deserializeAws_json1_1MeetingSetting(
      output.MeetingSetting,
      context
    );
  }
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  if (output.PSTNDialIn !== undefined && output.PSTNDialIn !== null) {
    contents.PSTNDialIn = deserializeAws_json1_1PSTNDialIn(
      output.PSTNDialIn,
      context
    );
  }
  if (output.Type !== undefined && output.Type !== null) {
    contents.Type = output.Type;
  }
  return contents;
};

const deserializeAws_json1_1ConferenceProvidersList = (
  output: any,
  context: __SerdeContext
): Array<ConferenceProvider> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1ConferenceProvider(entry, context)
  );
};

const deserializeAws_json1_1IPDialIn = (
  output: any,
  context: __SerdeContext
): IPDialIn => {
  let contents: any = {
    __type: "IPDialIn",
    CommsProtocol: undefined,
    Endpoint: undefined
  };
  if (output.CommsProtocol !== undefined && output.CommsProtocol !== null) {
    contents.CommsProtocol = output.CommsProtocol;
  }
  if (output.Endpoint !== undefined && output.Endpoint !== null) {
    contents.Endpoint = output.Endpoint;
  }
  return contents;
};

const deserializeAws_json1_1MeetingSetting = (
  output: any,
  context: __SerdeContext
): MeetingSetting => {
  let contents: any = {
    __type: "MeetingSetting",
    RequirePin: undefined
  };
  if (output.RequirePin !== undefined && output.RequirePin !== null) {
    contents.RequirePin = output.RequirePin;
  }
  return contents;
};

const deserializeAws_json1_1PSTNDialIn = (
  output: any,
  context: __SerdeContext
): PSTNDialIn => {
  let contents: any = {
    __type: "PSTNDialIn",
    CountryCode: undefined,
    OneClickIdDelay: undefined,
    OneClickPinDelay: undefined,
    PhoneNumber: undefined
  };
  if (output.CountryCode !== undefined && output.CountryCode !== null) {
    contents.CountryCode = output.CountryCode;
  }
  if (output.OneClickIdDelay !== undefined && output.OneClickIdDelay !== null) {
    contents.OneClickIdDelay = output.OneClickIdDelay;
  }
  if (
    output.OneClickPinDelay !== undefined &&
    output.OneClickPinDelay !== null
  ) {
    contents.OneClickPinDelay = output.OneClickPinDelay;
  }
  if (output.PhoneNumber !== undefined && output.PhoneNumber !== null) {
    contents.PhoneNumber = output.PhoneNumber;
  }
  return contents;
};

const deserializeAws_json1_1SendAnnouncementResponse = (
  output: any,
  context: __SerdeContext
): SendAnnouncementResponse => {
  let contents: any = {
    __type: "SendAnnouncementResponse",
    AnnouncementArn: undefined
  };
  if (output.AnnouncementArn !== undefined && output.AnnouncementArn !== null) {
    contents.AnnouncementArn = output.AnnouncementArn;
  }
  return contents;
};

const deserializeAws_json1_1DeleteDeviceUsageDataResponse = (
  output: any,
  context: __SerdeContext
): DeleteDeviceUsageDataResponse => {
  let contents: any = {
    __type: "DeleteDeviceUsageDataResponse"
  };
  return contents;
};

const deserializeAws_json1_1AddressBook = (
  output: any,
  context: __SerdeContext
): AddressBook => {
  let contents: any = {
    __type: "AddressBook",
    AddressBookArn: undefined,
    Description: undefined,
    Name: undefined
  };
  if (output.AddressBookArn !== undefined && output.AddressBookArn !== null) {
    contents.AddressBookArn = output.AddressBookArn;
  }
  if (output.Description !== undefined && output.Description !== null) {
    contents.Description = output.Description;
  }
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  return contents;
};

const deserializeAws_json1_1AddressBookData = (
  output: any,
  context: __SerdeContext
): AddressBookData => {
  let contents: any = {
    __type: "AddressBookData",
    AddressBookArn: undefined,
    Description: undefined,
    Name: undefined
  };
  if (output.AddressBookArn !== undefined && output.AddressBookArn !== null) {
    contents.AddressBookArn = output.AddressBookArn;
  }
  if (output.Description !== undefined && output.Description !== null) {
    contents.Description = output.Description;
  }
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  return contents;
};

const deserializeAws_json1_1AddressBookDataList = (
  output: any,
  context: __SerdeContext
): Array<AddressBookData> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1AddressBookData(entry, context)
  );
};

const deserializeAws_json1_1ApproveSkillResponse = (
  output: any,
  context: __SerdeContext
): ApproveSkillResponse => {
  let contents: any = {
    __type: "ApproveSkillResponse"
  };
  return contents;
};

const deserializeAws_json1_1AssociateContactWithAddressBookResponse = (
  output: any,
  context: __SerdeContext
): AssociateContactWithAddressBookResponse => {
  let contents: any = {
    __type: "AssociateContactWithAddressBookResponse"
  };
  return contents;
};

const deserializeAws_json1_1AssociateDeviceWithNetworkProfileResponse = (
  output: any,
  context: __SerdeContext
): AssociateDeviceWithNetworkProfileResponse => {
  let contents: any = {
    __type: "AssociateDeviceWithNetworkProfileResponse"
  };
  return contents;
};

const deserializeAws_json1_1AssociateDeviceWithRoomResponse = (
  output: any,
  context: __SerdeContext
): AssociateDeviceWithRoomResponse => {
  let contents: any = {
    __type: "AssociateDeviceWithRoomResponse"
  };
  return contents;
};

const deserializeAws_json1_1AssociateSkillGroupWithRoomResponse = (
  output: any,
  context: __SerdeContext
): AssociateSkillGroupWithRoomResponse => {
  let contents: any = {
    __type: "AssociateSkillGroupWithRoomResponse"
  };
  return contents;
};

const deserializeAws_json1_1AssociateSkillWithSkillGroupResponse = (
  output: any,
  context: __SerdeContext
): AssociateSkillWithSkillGroupResponse => {
  let contents: any = {
    __type: "AssociateSkillWithSkillGroupResponse"
  };
  return contents;
};

const deserializeAws_json1_1AssociateSkillWithUsersResponse = (
  output: any,
  context: __SerdeContext
): AssociateSkillWithUsersResponse => {
  let contents: any = {
    __type: "AssociateSkillWithUsersResponse"
  };
  return contents;
};

const deserializeAws_json1_1BulletPoints = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1BusinessReport = (
  output: any,
  context: __SerdeContext
): BusinessReport => {
  let contents: any = {
    __type: "BusinessReport",
    DeliveryTime: undefined,
    DownloadUrl: undefined,
    FailureCode: undefined,
    S3Location: undefined,
    Status: undefined
  };
  if (output.DeliveryTime !== undefined && output.DeliveryTime !== null) {
    contents.DeliveryTime = new Date(Math.round(output.DeliveryTime * 1000));
  }
  if (output.DownloadUrl !== undefined && output.DownloadUrl !== null) {
    contents.DownloadUrl = output.DownloadUrl;
  }
  if (output.FailureCode !== undefined && output.FailureCode !== null) {
    contents.FailureCode = output.FailureCode;
  }
  if (output.S3Location !== undefined && output.S3Location !== null) {
    contents.S3Location = deserializeAws_json1_1BusinessReportS3Location(
      output.S3Location,
      context
    );
  }
  if (output.Status !== undefined && output.Status !== null) {
    contents.Status = output.Status;
  }
  return contents;
};

const deserializeAws_json1_1BusinessReportContentRange = (
  output: any,
  context: __SerdeContext
): BusinessReportContentRange => {
  let contents: any = {
    __type: "BusinessReportContentRange",
    Interval: undefined
  };
  if (output.Interval !== undefined && output.Interval !== null) {
    contents.Interval = output.Interval;
  }
  return contents;
};

const deserializeAws_json1_1BusinessReportRecurrence = (
  output: any,
  context: __SerdeContext
): BusinessReportRecurrence => {
  let contents: any = {
    __type: "BusinessReportRecurrence",
    StartDate: undefined
  };
  if (output.StartDate !== undefined && output.StartDate !== null) {
    contents.StartDate = output.StartDate;
  }
  return contents;
};

const deserializeAws_json1_1BusinessReportS3Location = (
  output: any,
  context: __SerdeContext
): BusinessReportS3Location => {
  let contents: any = {
    __type: "BusinessReportS3Location",
    BucketName: undefined,
    Path: undefined
  };
  if (output.BucketName !== undefined && output.BucketName !== null) {
    contents.BucketName = output.BucketName;
  }
  if (output.Path !== undefined && output.Path !== null) {
    contents.Path = output.Path;
  }
  return contents;
};

const deserializeAws_json1_1BusinessReportSchedule = (
  output: any,
  context: __SerdeContext
): BusinessReportSchedule => {
  let contents: any = {
    __type: "BusinessReportSchedule",
    ContentRange: undefined,
    Format: undefined,
    LastBusinessReport: undefined,
    Recurrence: undefined,
    S3BucketName: undefined,
    S3KeyPrefix: undefined,
    ScheduleArn: undefined,
    ScheduleName: undefined
  };
  if (output.ContentRange !== undefined && output.ContentRange !== null) {
    contents.ContentRange = deserializeAws_json1_1BusinessReportContentRange(
      output.ContentRange,
      context
    );
  }
  if (output.Format !== undefined && output.Format !== null) {
    contents.Format = output.Format;
  }
  if (
    output.LastBusinessReport !== undefined &&
    output.LastBusinessReport !== null
  ) {
    contents.LastBusinessReport = deserializeAws_json1_1BusinessReport(
      output.LastBusinessReport,
      context
    );
  }
  if (output.Recurrence !== undefined && output.Recurrence !== null) {
    contents.Recurrence = deserializeAws_json1_1BusinessReportRecurrence(
      output.Recurrence,
      context
    );
  }
  if (output.S3BucketName !== undefined && output.S3BucketName !== null) {
    contents.S3BucketName = output.S3BucketName;
  }
  if (output.S3KeyPrefix !== undefined && output.S3KeyPrefix !== null) {
    contents.S3KeyPrefix = output.S3KeyPrefix;
  }
  if (output.ScheduleArn !== undefined && output.ScheduleArn !== null) {
    contents.ScheduleArn = output.ScheduleArn;
  }
  if (output.ScheduleName !== undefined && output.ScheduleName !== null) {
    contents.ScheduleName = output.ScheduleName;
  }
  return contents;
};

const deserializeAws_json1_1BusinessReportScheduleList = (
  output: any,
  context: __SerdeContext
): Array<BusinessReportSchedule> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1BusinessReportSchedule(entry, context)
  );
};

const deserializeAws_json1_1Category = (
  output: any,
  context: __SerdeContext
): Category => {
  let contents: any = {
    __type: "Category",
    CategoryId: undefined,
    CategoryName: undefined
  };
  if (output.CategoryId !== undefined && output.CategoryId !== null) {
    contents.CategoryId = output.CategoryId;
  }
  if (output.CategoryName !== undefined && output.CategoryName !== null) {
    contents.CategoryName = output.CategoryName;
  }
  return contents;
};

const deserializeAws_json1_1CategoryList = (
  output: any,
  context: __SerdeContext
): Array<Category> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1Category(entry, context)
  );
};

const deserializeAws_json1_1ConferencePreference = (
  output: any,
  context: __SerdeContext
): ConferencePreference => {
  let contents: any = {
    __type: "ConferencePreference",
    DefaultConferenceProviderArn: undefined
  };
  if (
    output.DefaultConferenceProviderArn !== undefined &&
    output.DefaultConferenceProviderArn !== null
  ) {
    contents.DefaultConferenceProviderArn = output.DefaultConferenceProviderArn;
  }
  return contents;
};

const deserializeAws_json1_1Contact = (
  output: any,
  context: __SerdeContext
): Contact => {
  let contents: any = {
    __type: "Contact",
    ContactArn: undefined,
    DisplayName: undefined,
    FirstName: undefined,
    LastName: undefined,
    PhoneNumber: undefined,
    PhoneNumbers: undefined,
    SipAddresses: undefined
  };
  if (output.ContactArn !== undefined && output.ContactArn !== null) {
    contents.ContactArn = output.ContactArn;
  }
  if (output.DisplayName !== undefined && output.DisplayName !== null) {
    contents.DisplayName = output.DisplayName;
  }
  if (output.FirstName !== undefined && output.FirstName !== null) {
    contents.FirstName = output.FirstName;
  }
  if (output.LastName !== undefined && output.LastName !== null) {
    contents.LastName = output.LastName;
  }
  if (output.PhoneNumber !== undefined && output.PhoneNumber !== null) {
    contents.PhoneNumber = output.PhoneNumber;
  }
  if (output.PhoneNumbers !== undefined && output.PhoneNumbers !== null) {
    contents.PhoneNumbers = deserializeAws_json1_1PhoneNumberList(
      output.PhoneNumbers,
      context
    );
  }
  if (output.SipAddresses !== undefined && output.SipAddresses !== null) {
    contents.SipAddresses = deserializeAws_json1_1SipAddressList(
      output.SipAddresses,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1ContactData = (
  output: any,
  context: __SerdeContext
): ContactData => {
  let contents: any = {
    __type: "ContactData",
    ContactArn: undefined,
    DisplayName: undefined,
    FirstName: undefined,
    LastName: undefined,
    PhoneNumber: undefined,
    PhoneNumbers: undefined,
    SipAddresses: undefined
  };
  if (output.ContactArn !== undefined && output.ContactArn !== null) {
    contents.ContactArn = output.ContactArn;
  }
  if (output.DisplayName !== undefined && output.DisplayName !== null) {
    contents.DisplayName = output.DisplayName;
  }
  if (output.FirstName !== undefined && output.FirstName !== null) {
    contents.FirstName = output.FirstName;
  }
  if (output.LastName !== undefined && output.LastName !== null) {
    contents.LastName = output.LastName;
  }
  if (output.PhoneNumber !== undefined && output.PhoneNumber !== null) {
    contents.PhoneNumber = output.PhoneNumber;
  }
  if (output.PhoneNumbers !== undefined && output.PhoneNumbers !== null) {
    contents.PhoneNumbers = deserializeAws_json1_1PhoneNumberList(
      output.PhoneNumbers,
      context
    );
  }
  if (output.SipAddresses !== undefined && output.SipAddresses !== null) {
    contents.SipAddresses = deserializeAws_json1_1SipAddressList(
      output.SipAddresses,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1ContactDataList = (
  output: any,
  context: __SerdeContext
): Array<ContactData> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1ContactData(entry, context)
  );
};

const deserializeAws_json1_1CreateAddressBookResponse = (
  output: any,
  context: __SerdeContext
): CreateAddressBookResponse => {
  let contents: any = {
    __type: "CreateAddressBookResponse",
    AddressBookArn: undefined
  };
  if (output.AddressBookArn !== undefined && output.AddressBookArn !== null) {
    contents.AddressBookArn = output.AddressBookArn;
  }
  return contents;
};

const deserializeAws_json1_1CreateBusinessReportScheduleResponse = (
  output: any,
  context: __SerdeContext
): CreateBusinessReportScheduleResponse => {
  let contents: any = {
    __type: "CreateBusinessReportScheduleResponse",
    ScheduleArn: undefined
  };
  if (output.ScheduleArn !== undefined && output.ScheduleArn !== null) {
    contents.ScheduleArn = output.ScheduleArn;
  }
  return contents;
};

const deserializeAws_json1_1CreateConferenceProviderResponse = (
  output: any,
  context: __SerdeContext
): CreateConferenceProviderResponse => {
  let contents: any = {
    __type: "CreateConferenceProviderResponse",
    ConferenceProviderArn: undefined
  };
  if (
    output.ConferenceProviderArn !== undefined &&
    output.ConferenceProviderArn !== null
  ) {
    contents.ConferenceProviderArn = output.ConferenceProviderArn;
  }
  return contents;
};

const deserializeAws_json1_1CreateContactResponse = (
  output: any,
  context: __SerdeContext
): CreateContactResponse => {
  let contents: any = {
    __type: "CreateContactResponse",
    ContactArn: undefined
  };
  if (output.ContactArn !== undefined && output.ContactArn !== null) {
    contents.ContactArn = output.ContactArn;
  }
  return contents;
};

const deserializeAws_json1_1CreateGatewayGroupResponse = (
  output: any,
  context: __SerdeContext
): CreateGatewayGroupResponse => {
  let contents: any = {
    __type: "CreateGatewayGroupResponse",
    GatewayGroupArn: undefined
  };
  if (output.GatewayGroupArn !== undefined && output.GatewayGroupArn !== null) {
    contents.GatewayGroupArn = output.GatewayGroupArn;
  }
  return contents;
};

const deserializeAws_json1_1CreateNetworkProfileResponse = (
  output: any,
  context: __SerdeContext
): CreateNetworkProfileResponse => {
  let contents: any = {
    __type: "CreateNetworkProfileResponse",
    NetworkProfileArn: undefined
  };
  if (
    output.NetworkProfileArn !== undefined &&
    output.NetworkProfileArn !== null
  ) {
    contents.NetworkProfileArn = output.NetworkProfileArn;
  }
  return contents;
};

const deserializeAws_json1_1CreateProfileResponse = (
  output: any,
  context: __SerdeContext
): CreateProfileResponse => {
  let contents: any = {
    __type: "CreateProfileResponse",
    ProfileArn: undefined
  };
  if (output.ProfileArn !== undefined && output.ProfileArn !== null) {
    contents.ProfileArn = output.ProfileArn;
  }
  return contents;
};

const deserializeAws_json1_1CreateRoomResponse = (
  output: any,
  context: __SerdeContext
): CreateRoomResponse => {
  let contents: any = {
    __type: "CreateRoomResponse",
    RoomArn: undefined
  };
  if (output.RoomArn !== undefined && output.RoomArn !== null) {
    contents.RoomArn = output.RoomArn;
  }
  return contents;
};

const deserializeAws_json1_1CreateSkillGroupResponse = (
  output: any,
  context: __SerdeContext
): CreateSkillGroupResponse => {
  let contents: any = {
    __type: "CreateSkillGroupResponse",
    SkillGroupArn: undefined
  };
  if (output.SkillGroupArn !== undefined && output.SkillGroupArn !== null) {
    contents.SkillGroupArn = output.SkillGroupArn;
  }
  return contents;
};

const deserializeAws_json1_1CreateUserResponse = (
  output: any,
  context: __SerdeContext
): CreateUserResponse => {
  let contents: any = {
    __type: "CreateUserResponse",
    UserArn: undefined
  };
  if (output.UserArn !== undefined && output.UserArn !== null) {
    contents.UserArn = output.UserArn;
  }
  return contents;
};

const deserializeAws_json1_1DeleteAddressBookResponse = (
  output: any,
  context: __SerdeContext
): DeleteAddressBookResponse => {
  let contents: any = {
    __type: "DeleteAddressBookResponse"
  };
  return contents;
};

const deserializeAws_json1_1DeleteBusinessReportScheduleResponse = (
  output: any,
  context: __SerdeContext
): DeleteBusinessReportScheduleResponse => {
  let contents: any = {
    __type: "DeleteBusinessReportScheduleResponse"
  };
  return contents;
};

const deserializeAws_json1_1DeleteConferenceProviderResponse = (
  output: any,
  context: __SerdeContext
): DeleteConferenceProviderResponse => {
  let contents: any = {
    __type: "DeleteConferenceProviderResponse"
  };
  return contents;
};

const deserializeAws_json1_1DeleteContactResponse = (
  output: any,
  context: __SerdeContext
): DeleteContactResponse => {
  let contents: any = {
    __type: "DeleteContactResponse"
  };
  return contents;
};

const deserializeAws_json1_1DeleteDeviceResponse = (
  output: any,
  context: __SerdeContext
): DeleteDeviceResponse => {
  let contents: any = {
    __type: "DeleteDeviceResponse"
  };
  return contents;
};

const deserializeAws_json1_1DeleteGatewayGroupResponse = (
  output: any,
  context: __SerdeContext
): DeleteGatewayGroupResponse => {
  let contents: any = {
    __type: "DeleteGatewayGroupResponse"
  };
  return contents;
};

const deserializeAws_json1_1DeleteNetworkProfileResponse = (
  output: any,
  context: __SerdeContext
): DeleteNetworkProfileResponse => {
  let contents: any = {
    __type: "DeleteNetworkProfileResponse"
  };
  return contents;
};

const deserializeAws_json1_1DeleteProfileResponse = (
  output: any,
  context: __SerdeContext
): DeleteProfileResponse => {
  let contents: any = {
    __type: "DeleteProfileResponse"
  };
  return contents;
};

const deserializeAws_json1_1DeleteRoomResponse = (
  output: any,
  context: __SerdeContext
): DeleteRoomResponse => {
  let contents: any = {
    __type: "DeleteRoomResponse"
  };
  return contents;
};

const deserializeAws_json1_1DeleteRoomSkillParameterResponse = (
  output: any,
  context: __SerdeContext
): DeleteRoomSkillParameterResponse => {
  let contents: any = {
    __type: "DeleteRoomSkillParameterResponse"
  };
  return contents;
};

const deserializeAws_json1_1DeleteSkillAuthorizationResponse = (
  output: any,
  context: __SerdeContext
): DeleteSkillAuthorizationResponse => {
  let contents: any = {
    __type: "DeleteSkillAuthorizationResponse"
  };
  return contents;
};

const deserializeAws_json1_1DeleteSkillGroupResponse = (
  output: any,
  context: __SerdeContext
): DeleteSkillGroupResponse => {
  let contents: any = {
    __type: "DeleteSkillGroupResponse"
  };
  return contents;
};

const deserializeAws_json1_1DeleteUserResponse = (
  output: any,
  context: __SerdeContext
): DeleteUserResponse => {
  let contents: any = {
    __type: "DeleteUserResponse"
  };
  return contents;
};

const deserializeAws_json1_1DeveloperInfo = (
  output: any,
  context: __SerdeContext
): DeveloperInfo => {
  let contents: any = {
    __type: "DeveloperInfo",
    DeveloperName: undefined,
    Email: undefined,
    PrivacyPolicy: undefined,
    Url: undefined
  };
  if (output.DeveloperName !== undefined && output.DeveloperName !== null) {
    contents.DeveloperName = output.DeveloperName;
  }
  if (output.Email !== undefined && output.Email !== null) {
    contents.Email = output.Email;
  }
  if (output.PrivacyPolicy !== undefined && output.PrivacyPolicy !== null) {
    contents.PrivacyPolicy = output.PrivacyPolicy;
  }
  if (output.Url !== undefined && output.Url !== null) {
    contents.Url = output.Url;
  }
  return contents;
};

const deserializeAws_json1_1Device = (
  output: any,
  context: __SerdeContext
): Device => {
  let contents: any = {
    __type: "Device",
    DeviceArn: undefined,
    DeviceName: undefined,
    DeviceSerialNumber: undefined,
    DeviceStatus: undefined,
    DeviceStatusInfo: undefined,
    DeviceType: undefined,
    MacAddress: undefined,
    NetworkProfileInfo: undefined,
    RoomArn: undefined,
    SoftwareVersion: undefined
  };
  if (output.DeviceArn !== undefined && output.DeviceArn !== null) {
    contents.DeviceArn = output.DeviceArn;
  }
  if (output.DeviceName !== undefined && output.DeviceName !== null) {
    contents.DeviceName = output.DeviceName;
  }
  if (
    output.DeviceSerialNumber !== undefined &&
    output.DeviceSerialNumber !== null
  ) {
    contents.DeviceSerialNumber = output.DeviceSerialNumber;
  }
  if (output.DeviceStatus !== undefined && output.DeviceStatus !== null) {
    contents.DeviceStatus = output.DeviceStatus;
  }
  if (
    output.DeviceStatusInfo !== undefined &&
    output.DeviceStatusInfo !== null
  ) {
    contents.DeviceStatusInfo = deserializeAws_json1_1DeviceStatusInfo(
      output.DeviceStatusInfo,
      context
    );
  }
  if (output.DeviceType !== undefined && output.DeviceType !== null) {
    contents.DeviceType = output.DeviceType;
  }
  if (output.MacAddress !== undefined && output.MacAddress !== null) {
    contents.MacAddress = output.MacAddress;
  }
  if (
    output.NetworkProfileInfo !== undefined &&
    output.NetworkProfileInfo !== null
  ) {
    contents.NetworkProfileInfo = deserializeAws_json1_1DeviceNetworkProfileInfo(
      output.NetworkProfileInfo,
      context
    );
  }
  if (output.RoomArn !== undefined && output.RoomArn !== null) {
    contents.RoomArn = output.RoomArn;
  }
  if (output.SoftwareVersion !== undefined && output.SoftwareVersion !== null) {
    contents.SoftwareVersion = output.SoftwareVersion;
  }
  return contents;
};

const deserializeAws_json1_1DeviceData = (
  output: any,
  context: __SerdeContext
): DeviceData => {
  let contents: any = {
    __type: "DeviceData",
    CreatedTime: undefined,
    DeviceArn: undefined,
    DeviceName: undefined,
    DeviceSerialNumber: undefined,
    DeviceStatus: undefined,
    DeviceStatusInfo: undefined,
    DeviceType: undefined,
    MacAddress: undefined,
    NetworkProfileArn: undefined,
    NetworkProfileName: undefined,
    RoomArn: undefined,
    RoomName: undefined,
    SoftwareVersion: undefined
  };
  if (output.CreatedTime !== undefined && output.CreatedTime !== null) {
    contents.CreatedTime = new Date(Math.round(output.CreatedTime * 1000));
  }
  if (output.DeviceArn !== undefined && output.DeviceArn !== null) {
    contents.DeviceArn = output.DeviceArn;
  }
  if (output.DeviceName !== undefined && output.DeviceName !== null) {
    contents.DeviceName = output.DeviceName;
  }
  if (
    output.DeviceSerialNumber !== undefined &&
    output.DeviceSerialNumber !== null
  ) {
    contents.DeviceSerialNumber = output.DeviceSerialNumber;
  }
  if (output.DeviceStatus !== undefined && output.DeviceStatus !== null) {
    contents.DeviceStatus = output.DeviceStatus;
  }
  if (
    output.DeviceStatusInfo !== undefined &&
    output.DeviceStatusInfo !== null
  ) {
    contents.DeviceStatusInfo = deserializeAws_json1_1DeviceStatusInfo(
      output.DeviceStatusInfo,
      context
    );
  }
  if (output.DeviceType !== undefined && output.DeviceType !== null) {
    contents.DeviceType = output.DeviceType;
  }
  if (output.MacAddress !== undefined && output.MacAddress !== null) {
    contents.MacAddress = output.MacAddress;
  }
  if (
    output.NetworkProfileArn !== undefined &&
    output.NetworkProfileArn !== null
  ) {
    contents.NetworkProfileArn = output.NetworkProfileArn;
  }
  if (
    output.NetworkProfileName !== undefined &&
    output.NetworkProfileName !== null
  ) {
    contents.NetworkProfileName = output.NetworkProfileName;
  }
  if (output.RoomArn !== undefined && output.RoomArn !== null) {
    contents.RoomArn = output.RoomArn;
  }
  if (output.RoomName !== undefined && output.RoomName !== null) {
    contents.RoomName = output.RoomName;
  }
  if (output.SoftwareVersion !== undefined && output.SoftwareVersion !== null) {
    contents.SoftwareVersion = output.SoftwareVersion;
  }
  return contents;
};

const deserializeAws_json1_1DeviceDataList = (
  output: any,
  context: __SerdeContext
): Array<DeviceData> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1DeviceData(entry, context)
  );
};

const deserializeAws_json1_1DeviceEvent = (
  output: any,
  context: __SerdeContext
): DeviceEvent => {
  let contents: any = {
    __type: "DeviceEvent",
    Timestamp: undefined,
    Type: undefined,
    Value: undefined
  };
  if (output.Timestamp !== undefined && output.Timestamp !== null) {
    contents.Timestamp = new Date(Math.round(output.Timestamp * 1000));
  }
  if (output.Type !== undefined && output.Type !== null) {
    contents.Type = output.Type;
  }
  if (output.Value !== undefined && output.Value !== null) {
    contents.Value = output.Value;
  }
  return contents;
};

const deserializeAws_json1_1DeviceEventList = (
  output: any,
  context: __SerdeContext
): Array<DeviceEvent> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1DeviceEvent(entry, context)
  );
};

const deserializeAws_json1_1DeviceNetworkProfileInfo = (
  output: any,
  context: __SerdeContext
): DeviceNetworkProfileInfo => {
  let contents: any = {
    __type: "DeviceNetworkProfileInfo",
    CertificateArn: undefined,
    CertificateExpirationTime: undefined,
    NetworkProfileArn: undefined
  };
  if (output.CertificateArn !== undefined && output.CertificateArn !== null) {
    contents.CertificateArn = output.CertificateArn;
  }
  if (
    output.CertificateExpirationTime !== undefined &&
    output.CertificateExpirationTime !== null
  ) {
    contents.CertificateExpirationTime = new Date(
      Math.round(output.CertificateExpirationTime * 1000)
    );
  }
  if (
    output.NetworkProfileArn !== undefined &&
    output.NetworkProfileArn !== null
  ) {
    contents.NetworkProfileArn = output.NetworkProfileArn;
  }
  return contents;
};

const deserializeAws_json1_1DeviceStatusDetail = (
  output: any,
  context: __SerdeContext
): DeviceStatusDetail => {
  let contents: any = {
    __type: "DeviceStatusDetail",
    Code: undefined,
    Feature: undefined
  };
  if (output.Code !== undefined && output.Code !== null) {
    contents.Code = output.Code;
  }
  if (output.Feature !== undefined && output.Feature !== null) {
    contents.Feature = output.Feature;
  }
  return contents;
};

const deserializeAws_json1_1DeviceStatusDetails = (
  output: any,
  context: __SerdeContext
): Array<DeviceStatusDetail> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1DeviceStatusDetail(entry, context)
  );
};

const deserializeAws_json1_1DeviceStatusInfo = (
  output: any,
  context: __SerdeContext
): DeviceStatusInfo => {
  let contents: any = {
    __type: "DeviceStatusInfo",
    ConnectionStatus: undefined,
    ConnectionStatusUpdatedTime: undefined,
    DeviceStatusDetails: undefined
  };
  if (
    output.ConnectionStatus !== undefined &&
    output.ConnectionStatus !== null
  ) {
    contents.ConnectionStatus = output.ConnectionStatus;
  }
  if (
    output.ConnectionStatusUpdatedTime !== undefined &&
    output.ConnectionStatusUpdatedTime !== null
  ) {
    contents.ConnectionStatusUpdatedTime = new Date(
      Math.round(output.ConnectionStatusUpdatedTime * 1000)
    );
  }
  if (
    output.DeviceStatusDetails !== undefined &&
    output.DeviceStatusDetails !== null
  ) {
    contents.DeviceStatusDetails = deserializeAws_json1_1DeviceStatusDetails(
      output.DeviceStatusDetails,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DisassociateContactFromAddressBookResponse = (
  output: any,
  context: __SerdeContext
): DisassociateContactFromAddressBookResponse => {
  let contents: any = {
    __type: "DisassociateContactFromAddressBookResponse"
  };
  return contents;
};

const deserializeAws_json1_1DisassociateDeviceFromRoomResponse = (
  output: any,
  context: __SerdeContext
): DisassociateDeviceFromRoomResponse => {
  let contents: any = {
    __type: "DisassociateDeviceFromRoomResponse"
  };
  return contents;
};

const deserializeAws_json1_1DisassociateSkillFromSkillGroupResponse = (
  output: any,
  context: __SerdeContext
): DisassociateSkillFromSkillGroupResponse => {
  let contents: any = {
    __type: "DisassociateSkillFromSkillGroupResponse"
  };
  return contents;
};

const deserializeAws_json1_1DisassociateSkillFromUsersResponse = (
  output: any,
  context: __SerdeContext
): DisassociateSkillFromUsersResponse => {
  let contents: any = {
    __type: "DisassociateSkillFromUsersResponse"
  };
  return contents;
};

const deserializeAws_json1_1DisassociateSkillGroupFromRoomResponse = (
  output: any,
  context: __SerdeContext
): DisassociateSkillGroupFromRoomResponse => {
  let contents: any = {
    __type: "DisassociateSkillGroupFromRoomResponse"
  };
  return contents;
};

const deserializeAws_json1_1EndOfMeetingReminder = (
  output: any,
  context: __SerdeContext
): EndOfMeetingReminder => {
  let contents: any = {
    __type: "EndOfMeetingReminder",
    Enabled: undefined,
    ReminderAtMinutes: undefined,
    ReminderType: undefined
  };
  if (output.Enabled !== undefined && output.Enabled !== null) {
    contents.Enabled = output.Enabled;
  }
  if (
    output.ReminderAtMinutes !== undefined &&
    output.ReminderAtMinutes !== null
  ) {
    contents.ReminderAtMinutes = deserializeAws_json1_1EndOfMeetingReminderMinutesList(
      output.ReminderAtMinutes,
      context
    );
  }
  if (output.ReminderType !== undefined && output.ReminderType !== null) {
    contents.ReminderType = output.ReminderType;
  }
  return contents;
};

const deserializeAws_json1_1EndOfMeetingReminderMinutesList = (
  output: any,
  context: __SerdeContext
): Array<number> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1ForgetSmartHomeAppliancesResponse = (
  output: any,
  context: __SerdeContext
): ForgetSmartHomeAppliancesResponse => {
  let contents: any = {
    __type: "ForgetSmartHomeAppliancesResponse"
  };
  return contents;
};

const deserializeAws_json1_1Gateway = (
  output: any,
  context: __SerdeContext
): Gateway => {
  let contents: any = {
    __type: "Gateway",
    Arn: undefined,
    Description: undefined,
    GatewayGroupArn: undefined,
    Name: undefined,
    SoftwareVersion: undefined
  };
  if (output.Arn !== undefined && output.Arn !== null) {
    contents.Arn = output.Arn;
  }
  if (output.Description !== undefined && output.Description !== null) {
    contents.Description = output.Description;
  }
  if (output.GatewayGroupArn !== undefined && output.GatewayGroupArn !== null) {
    contents.GatewayGroupArn = output.GatewayGroupArn;
  }
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  if (output.SoftwareVersion !== undefined && output.SoftwareVersion !== null) {
    contents.SoftwareVersion = output.SoftwareVersion;
  }
  return contents;
};

const deserializeAws_json1_1GatewayGroup = (
  output: any,
  context: __SerdeContext
): GatewayGroup => {
  let contents: any = {
    __type: "GatewayGroup",
    Arn: undefined,
    Description: undefined,
    Name: undefined
  };
  if (output.Arn !== undefined && output.Arn !== null) {
    contents.Arn = output.Arn;
  }
  if (output.Description !== undefined && output.Description !== null) {
    contents.Description = output.Description;
  }
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  return contents;
};

const deserializeAws_json1_1GatewayGroupSummaries = (
  output: any,
  context: __SerdeContext
): Array<GatewayGroupSummary> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1GatewayGroupSummary(entry, context)
  );
};

const deserializeAws_json1_1GatewayGroupSummary = (
  output: any,
  context: __SerdeContext
): GatewayGroupSummary => {
  let contents: any = {
    __type: "GatewayGroupSummary",
    Arn: undefined,
    Description: undefined,
    Name: undefined
  };
  if (output.Arn !== undefined && output.Arn !== null) {
    contents.Arn = output.Arn;
  }
  if (output.Description !== undefined && output.Description !== null) {
    contents.Description = output.Description;
  }
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  return contents;
};

const deserializeAws_json1_1GatewaySummaries = (
  output: any,
  context: __SerdeContext
): Array<GatewaySummary> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1GatewaySummary(entry, context)
  );
};

const deserializeAws_json1_1GatewaySummary = (
  output: any,
  context: __SerdeContext
): GatewaySummary => {
  let contents: any = {
    __type: "GatewaySummary",
    Arn: undefined,
    Description: undefined,
    GatewayGroupArn: undefined,
    Name: undefined,
    SoftwareVersion: undefined
  };
  if (output.Arn !== undefined && output.Arn !== null) {
    contents.Arn = output.Arn;
  }
  if (output.Description !== undefined && output.Description !== null) {
    contents.Description = output.Description;
  }
  if (output.GatewayGroupArn !== undefined && output.GatewayGroupArn !== null) {
    contents.GatewayGroupArn = output.GatewayGroupArn;
  }
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  if (output.SoftwareVersion !== undefined && output.SoftwareVersion !== null) {
    contents.SoftwareVersion = output.SoftwareVersion;
  }
  return contents;
};

const deserializeAws_json1_1GenericKeywords = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1GetAddressBookResponse = (
  output: any,
  context: __SerdeContext
): GetAddressBookResponse => {
  let contents: any = {
    __type: "GetAddressBookResponse",
    AddressBook: undefined
  };
  if (output.AddressBook !== undefined && output.AddressBook !== null) {
    contents.AddressBook = deserializeAws_json1_1AddressBook(
      output.AddressBook,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1GetConferencePreferenceResponse = (
  output: any,
  context: __SerdeContext
): GetConferencePreferenceResponse => {
  let contents: any = {
    __type: "GetConferencePreferenceResponse",
    Preference: undefined
  };
  if (output.Preference !== undefined && output.Preference !== null) {
    contents.Preference = deserializeAws_json1_1ConferencePreference(
      output.Preference,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1GetConferenceProviderResponse = (
  output: any,
  context: __SerdeContext
): GetConferenceProviderResponse => {
  let contents: any = {
    __type: "GetConferenceProviderResponse",
    ConferenceProvider: undefined
  };
  if (
    output.ConferenceProvider !== undefined &&
    output.ConferenceProvider !== null
  ) {
    contents.ConferenceProvider = deserializeAws_json1_1ConferenceProvider(
      output.ConferenceProvider,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1GetContactResponse = (
  output: any,
  context: __SerdeContext
): GetContactResponse => {
  let contents: any = {
    __type: "GetContactResponse",
    Contact: undefined
  };
  if (output.Contact !== undefined && output.Contact !== null) {
    contents.Contact = deserializeAws_json1_1Contact(output.Contact, context);
  }
  return contents;
};

const deserializeAws_json1_1GetDeviceResponse = (
  output: any,
  context: __SerdeContext
): GetDeviceResponse => {
  let contents: any = {
    __type: "GetDeviceResponse",
    Device: undefined
  };
  if (output.Device !== undefined && output.Device !== null) {
    contents.Device = deserializeAws_json1_1Device(output.Device, context);
  }
  return contents;
};

const deserializeAws_json1_1GetGatewayGroupResponse = (
  output: any,
  context: __SerdeContext
): GetGatewayGroupResponse => {
  let contents: any = {
    __type: "GetGatewayGroupResponse",
    GatewayGroup: undefined
  };
  if (output.GatewayGroup !== undefined && output.GatewayGroup !== null) {
    contents.GatewayGroup = deserializeAws_json1_1GatewayGroup(
      output.GatewayGroup,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1GetGatewayResponse = (
  output: any,
  context: __SerdeContext
): GetGatewayResponse => {
  let contents: any = {
    __type: "GetGatewayResponse",
    Gateway: undefined
  };
  if (output.Gateway !== undefined && output.Gateway !== null) {
    contents.Gateway = deserializeAws_json1_1Gateway(output.Gateway, context);
  }
  return contents;
};

const deserializeAws_json1_1GetInvitationConfigurationResponse = (
  output: any,
  context: __SerdeContext
): GetInvitationConfigurationResponse => {
  let contents: any = {
    __type: "GetInvitationConfigurationResponse",
    ContactEmail: undefined,
    OrganizationName: undefined,
    PrivateSkillIds: undefined
  };
  if (output.ContactEmail !== undefined && output.ContactEmail !== null) {
    contents.ContactEmail = output.ContactEmail;
  }
  if (
    output.OrganizationName !== undefined &&
    output.OrganizationName !== null
  ) {
    contents.OrganizationName = output.OrganizationName;
  }
  if (output.PrivateSkillIds !== undefined && output.PrivateSkillIds !== null) {
    contents.PrivateSkillIds = deserializeAws_json1_1ShortSkillIdList(
      output.PrivateSkillIds,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1GetNetworkProfileResponse = (
  output: any,
  context: __SerdeContext
): GetNetworkProfileResponse => {
  let contents: any = {
    __type: "GetNetworkProfileResponse",
    NetworkProfile: undefined
  };
  if (output.NetworkProfile !== undefined && output.NetworkProfile !== null) {
    contents.NetworkProfile = deserializeAws_json1_1NetworkProfile(
      output.NetworkProfile,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1GetProfileResponse = (
  output: any,
  context: __SerdeContext
): GetProfileResponse => {
  let contents: any = {
    __type: "GetProfileResponse",
    Profile: undefined
  };
  if (output.Profile !== undefined && output.Profile !== null) {
    contents.Profile = deserializeAws_json1_1Profile(output.Profile, context);
  }
  return contents;
};

const deserializeAws_json1_1GetRoomResponse = (
  output: any,
  context: __SerdeContext
): GetRoomResponse => {
  let contents: any = {
    __type: "GetRoomResponse",
    Room: undefined
  };
  if (output.Room !== undefined && output.Room !== null) {
    contents.Room = deserializeAws_json1_1Room(output.Room, context);
  }
  return contents;
};

const deserializeAws_json1_1GetRoomSkillParameterResponse = (
  output: any,
  context: __SerdeContext
): GetRoomSkillParameterResponse => {
  let contents: any = {
    __type: "GetRoomSkillParameterResponse",
    RoomSkillParameter: undefined
  };
  if (
    output.RoomSkillParameter !== undefined &&
    output.RoomSkillParameter !== null
  ) {
    contents.RoomSkillParameter = deserializeAws_json1_1RoomSkillParameter(
      output.RoomSkillParameter,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1GetSkillGroupResponse = (
  output: any,
  context: __SerdeContext
): GetSkillGroupResponse => {
  let contents: any = {
    __type: "GetSkillGroupResponse",
    SkillGroup: undefined
  };
  if (output.SkillGroup !== undefined && output.SkillGroup !== null) {
    contents.SkillGroup = deserializeAws_json1_1SkillGroup(
      output.SkillGroup,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1InstantBooking = (
  output: any,
  context: __SerdeContext
): InstantBooking => {
  let contents: any = {
    __type: "InstantBooking",
    DurationInMinutes: undefined,
    Enabled: undefined
  };
  if (
    output.DurationInMinutes !== undefined &&
    output.DurationInMinutes !== null
  ) {
    contents.DurationInMinutes = output.DurationInMinutes;
  }
  if (output.Enabled !== undefined && output.Enabled !== null) {
    contents.Enabled = output.Enabled;
  }
  return contents;
};

const deserializeAws_json1_1InvalidCertificateAuthorityException = (
  output: any,
  context: __SerdeContext
): InvalidCertificateAuthorityException => {
  let contents: any = {
    __type: "InvalidCertificateAuthorityException",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidDeviceException = (
  output: any,
  context: __SerdeContext
): InvalidDeviceException => {
  let contents: any = {
    __type: "InvalidDeviceException",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidSecretsManagerResourceException = (
  output: any,
  context: __SerdeContext
): InvalidSecretsManagerResourceException => {
  let contents: any = {
    __type: "InvalidSecretsManagerResourceException",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidServiceLinkedRoleStateException = (
  output: any,
  context: __SerdeContext
): InvalidServiceLinkedRoleStateException => {
  let contents: any = {
    __type: "InvalidServiceLinkedRoleStateException",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidUserStatusException = (
  output: any,
  context: __SerdeContext
): InvalidUserStatusException => {
  let contents: any = {
    __type: "InvalidUserStatusException",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1ListBusinessReportSchedulesResponse = (
  output: any,
  context: __SerdeContext
): ListBusinessReportSchedulesResponse => {
  let contents: any = {
    __type: "ListBusinessReportSchedulesResponse",
    BusinessReportSchedules: undefined,
    NextToken: undefined
  };
  if (
    output.BusinessReportSchedules !== undefined &&
    output.BusinessReportSchedules !== null
  ) {
    contents.BusinessReportSchedules = deserializeAws_json1_1BusinessReportScheduleList(
      output.BusinessReportSchedules,
      context
    );
  }
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  return contents;
};

const deserializeAws_json1_1ListConferenceProvidersResponse = (
  output: any,
  context: __SerdeContext
): ListConferenceProvidersResponse => {
  let contents: any = {
    __type: "ListConferenceProvidersResponse",
    ConferenceProviders: undefined,
    NextToken: undefined
  };
  if (
    output.ConferenceProviders !== undefined &&
    output.ConferenceProviders !== null
  ) {
    contents.ConferenceProviders = deserializeAws_json1_1ConferenceProvidersList(
      output.ConferenceProviders,
      context
    );
  }
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  return contents;
};

const deserializeAws_json1_1ListDeviceEventsResponse = (
  output: any,
  context: __SerdeContext
): ListDeviceEventsResponse => {
  let contents: any = {
    __type: "ListDeviceEventsResponse",
    DeviceEvents: undefined,
    NextToken: undefined
  };
  if (output.DeviceEvents !== undefined && output.DeviceEvents !== null) {
    contents.DeviceEvents = deserializeAws_json1_1DeviceEventList(
      output.DeviceEvents,
      context
    );
  }
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  return contents;
};

const deserializeAws_json1_1ListGatewayGroupsResponse = (
  output: any,
  context: __SerdeContext
): ListGatewayGroupsResponse => {
  let contents: any = {
    __type: "ListGatewayGroupsResponse",
    GatewayGroups: undefined,
    NextToken: undefined
  };
  if (output.GatewayGroups !== undefined && output.GatewayGroups !== null) {
    contents.GatewayGroups = deserializeAws_json1_1GatewayGroupSummaries(
      output.GatewayGroups,
      context
    );
  }
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  return contents;
};

const deserializeAws_json1_1ListGatewaysResponse = (
  output: any,
  context: __SerdeContext
): ListGatewaysResponse => {
  let contents: any = {
    __type: "ListGatewaysResponse",
    Gateways: undefined,
    NextToken: undefined
  };
  if (output.Gateways !== undefined && output.Gateways !== null) {
    contents.Gateways = deserializeAws_json1_1GatewaySummaries(
      output.Gateways,
      context
    );
  }
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  return contents;
};

const deserializeAws_json1_1ListSkillsResponse = (
  output: any,
  context: __SerdeContext
): ListSkillsResponse => {
  let contents: any = {
    __type: "ListSkillsResponse",
    NextToken: undefined,
    SkillSummaries: undefined
  };
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  if (output.SkillSummaries !== undefined && output.SkillSummaries !== null) {
    contents.SkillSummaries = deserializeAws_json1_1SkillSummaryList(
      output.SkillSummaries,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1ListSkillsStoreCategoriesResponse = (
  output: any,
  context: __SerdeContext
): ListSkillsStoreCategoriesResponse => {
  let contents: any = {
    __type: "ListSkillsStoreCategoriesResponse",
    CategoryList: undefined,
    NextToken: undefined
  };
  if (output.CategoryList !== undefined && output.CategoryList !== null) {
    contents.CategoryList = deserializeAws_json1_1CategoryList(
      output.CategoryList,
      context
    );
  }
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  return contents;
};

const deserializeAws_json1_1ListSkillsStoreSkillsByCategoryResponse = (
  output: any,
  context: __SerdeContext
): ListSkillsStoreSkillsByCategoryResponse => {
  let contents: any = {
    __type: "ListSkillsStoreSkillsByCategoryResponse",
    NextToken: undefined,
    SkillsStoreSkills: undefined
  };
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  if (
    output.SkillsStoreSkills !== undefined &&
    output.SkillsStoreSkills !== null
  ) {
    contents.SkillsStoreSkills = deserializeAws_json1_1SkillsStoreSkillList(
      output.SkillsStoreSkills,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1ListSmartHomeAppliancesResponse = (
  output: any,
  context: __SerdeContext
): ListSmartHomeAppliancesResponse => {
  let contents: any = {
    __type: "ListSmartHomeAppliancesResponse",
    NextToken: undefined,
    SmartHomeAppliances: undefined
  };
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  if (
    output.SmartHomeAppliances !== undefined &&
    output.SmartHomeAppliances !== null
  ) {
    contents.SmartHomeAppliances = deserializeAws_json1_1SmartHomeApplianceList(
      output.SmartHomeAppliances,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1ListTagsResponse = (
  output: any,
  context: __SerdeContext
): ListTagsResponse => {
  let contents: any = {
    __type: "ListTagsResponse",
    NextToken: undefined,
    Tags: undefined
  };
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  if (output.Tags !== undefined && output.Tags !== null) {
    contents.Tags = deserializeAws_json1_1TagList(output.Tags, context);
  }
  return contents;
};

const deserializeAws_json1_1MeetingRoomConfiguration = (
  output: any,
  context: __SerdeContext
): MeetingRoomConfiguration => {
  let contents: any = {
    __type: "MeetingRoomConfiguration",
    EndOfMeetingReminder: undefined,
    InstantBooking: undefined,
    RequireCheckIn: undefined,
    RoomUtilizationMetricsEnabled: undefined
  };
  if (
    output.EndOfMeetingReminder !== undefined &&
    output.EndOfMeetingReminder !== null
  ) {
    contents.EndOfMeetingReminder = deserializeAws_json1_1EndOfMeetingReminder(
      output.EndOfMeetingReminder,
      context
    );
  }
  if (output.InstantBooking !== undefined && output.InstantBooking !== null) {
    contents.InstantBooking = deserializeAws_json1_1InstantBooking(
      output.InstantBooking,
      context
    );
  }
  if (output.RequireCheckIn !== undefined && output.RequireCheckIn !== null) {
    contents.RequireCheckIn = deserializeAws_json1_1RequireCheckIn(
      output.RequireCheckIn,
      context
    );
  }
  if (
    output.RoomUtilizationMetricsEnabled !== undefined &&
    output.RoomUtilizationMetricsEnabled !== null
  ) {
    contents.RoomUtilizationMetricsEnabled =
      output.RoomUtilizationMetricsEnabled;
  }
  return contents;
};

const deserializeAws_json1_1NetworkProfile = (
  output: any,
  context: __SerdeContext
): NetworkProfile => {
  let contents: any = {
    __type: "NetworkProfile",
    CertificateAuthorityArn: undefined,
    CurrentPassword: undefined,
    Description: undefined,
    EapMethod: undefined,
    NetworkProfileArn: undefined,
    NetworkProfileName: undefined,
    NextPassword: undefined,
    SecurityType: undefined,
    Ssid: undefined,
    TrustAnchors: undefined
  };
  if (
    output.CertificateAuthorityArn !== undefined &&
    output.CertificateAuthorityArn !== null
  ) {
    contents.CertificateAuthorityArn = output.CertificateAuthorityArn;
  }
  if (output.CurrentPassword !== undefined && output.CurrentPassword !== null) {
    contents.CurrentPassword = output.CurrentPassword;
  }
  if (output.Description !== undefined && output.Description !== null) {
    contents.Description = output.Description;
  }
  if (output.EapMethod !== undefined && output.EapMethod !== null) {
    contents.EapMethod = output.EapMethod;
  }
  if (
    output.NetworkProfileArn !== undefined &&
    output.NetworkProfileArn !== null
  ) {
    contents.NetworkProfileArn = output.NetworkProfileArn;
  }
  if (
    output.NetworkProfileName !== undefined &&
    output.NetworkProfileName !== null
  ) {
    contents.NetworkProfileName = output.NetworkProfileName;
  }
  if (output.NextPassword !== undefined && output.NextPassword !== null) {
    contents.NextPassword = output.NextPassword;
  }
  if (output.SecurityType !== undefined && output.SecurityType !== null) {
    contents.SecurityType = output.SecurityType;
  }
  if (output.Ssid !== undefined && output.Ssid !== null) {
    contents.Ssid = output.Ssid;
  }
  if (output.TrustAnchors !== undefined && output.TrustAnchors !== null) {
    contents.TrustAnchors = deserializeAws_json1_1TrustAnchorList(
      output.TrustAnchors,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1NetworkProfileData = (
  output: any,
  context: __SerdeContext
): NetworkProfileData => {
  let contents: any = {
    __type: "NetworkProfileData",
    CertificateAuthorityArn: undefined,
    Description: undefined,
    EapMethod: undefined,
    NetworkProfileArn: undefined,
    NetworkProfileName: undefined,
    SecurityType: undefined,
    Ssid: undefined
  };
  if (
    output.CertificateAuthorityArn !== undefined &&
    output.CertificateAuthorityArn !== null
  ) {
    contents.CertificateAuthorityArn = output.CertificateAuthorityArn;
  }
  if (output.Description !== undefined && output.Description !== null) {
    contents.Description = output.Description;
  }
  if (output.EapMethod !== undefined && output.EapMethod !== null) {
    contents.EapMethod = output.EapMethod;
  }
  if (
    output.NetworkProfileArn !== undefined &&
    output.NetworkProfileArn !== null
  ) {
    contents.NetworkProfileArn = output.NetworkProfileArn;
  }
  if (
    output.NetworkProfileName !== undefined &&
    output.NetworkProfileName !== null
  ) {
    contents.NetworkProfileName = output.NetworkProfileName;
  }
  if (output.SecurityType !== undefined && output.SecurityType !== null) {
    contents.SecurityType = output.SecurityType;
  }
  if (output.Ssid !== undefined && output.Ssid !== null) {
    contents.Ssid = output.Ssid;
  }
  return contents;
};

const deserializeAws_json1_1NetworkProfileDataList = (
  output: any,
  context: __SerdeContext
): Array<NetworkProfileData> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1NetworkProfileData(entry, context)
  );
};

const deserializeAws_json1_1NewInThisVersionBulletPoints = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1PhoneNumber = (
  output: any,
  context: __SerdeContext
): PhoneNumber => {
  let contents: any = {
    __type: "PhoneNumber",
    Number: undefined,
    Type: undefined
  };
  if (output.Number !== undefined && output.Number !== null) {
    contents.Number = output.Number;
  }
  if (output.Type !== undefined && output.Type !== null) {
    contents.Type = output.Type;
  }
  return contents;
};

const deserializeAws_json1_1PhoneNumberList = (
  output: any,
  context: __SerdeContext
): Array<PhoneNumber> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1PhoneNumber(entry, context)
  );
};

const deserializeAws_json1_1Profile = (
  output: any,
  context: __SerdeContext
): Profile => {
  let contents: any = {
    __type: "Profile",
    Address: undefined,
    AddressBookArn: undefined,
    DistanceUnit: undefined,
    IsDefault: undefined,
    Locale: undefined,
    MaxVolumeLimit: undefined,
    MeetingRoomConfiguration: undefined,
    PSTNEnabled: undefined,
    ProfileArn: undefined,
    ProfileName: undefined,
    SetupModeDisabled: undefined,
    TemperatureUnit: undefined,
    Timezone: undefined,
    WakeWord: undefined
  };
  if (output.Address !== undefined && output.Address !== null) {
    contents.Address = output.Address;
  }
  if (output.AddressBookArn !== undefined && output.AddressBookArn !== null) {
    contents.AddressBookArn = output.AddressBookArn;
  }
  if (output.DistanceUnit !== undefined && output.DistanceUnit !== null) {
    contents.DistanceUnit = output.DistanceUnit;
  }
  if (output.IsDefault !== undefined && output.IsDefault !== null) {
    contents.IsDefault = output.IsDefault;
  }
  if (output.Locale !== undefined && output.Locale !== null) {
    contents.Locale = output.Locale;
  }
  if (output.MaxVolumeLimit !== undefined && output.MaxVolumeLimit !== null) {
    contents.MaxVolumeLimit = output.MaxVolumeLimit;
  }
  if (
    output.MeetingRoomConfiguration !== undefined &&
    output.MeetingRoomConfiguration !== null
  ) {
    contents.MeetingRoomConfiguration = deserializeAws_json1_1MeetingRoomConfiguration(
      output.MeetingRoomConfiguration,
      context
    );
  }
  if (output.PSTNEnabled !== undefined && output.PSTNEnabled !== null) {
    contents.PSTNEnabled = output.PSTNEnabled;
  }
  if (output.ProfileArn !== undefined && output.ProfileArn !== null) {
    contents.ProfileArn = output.ProfileArn;
  }
  if (output.ProfileName !== undefined && output.ProfileName !== null) {
    contents.ProfileName = output.ProfileName;
  }
  if (
    output.SetupModeDisabled !== undefined &&
    output.SetupModeDisabled !== null
  ) {
    contents.SetupModeDisabled = output.SetupModeDisabled;
  }
  if (output.TemperatureUnit !== undefined && output.TemperatureUnit !== null) {
    contents.TemperatureUnit = output.TemperatureUnit;
  }
  if (output.Timezone !== undefined && output.Timezone !== null) {
    contents.Timezone = output.Timezone;
  }
  if (output.WakeWord !== undefined && output.WakeWord !== null) {
    contents.WakeWord = output.WakeWord;
  }
  return contents;
};

const deserializeAws_json1_1ProfileData = (
  output: any,
  context: __SerdeContext
): ProfileData => {
  let contents: any = {
    __type: "ProfileData",
    Address: undefined,
    DistanceUnit: undefined,
    IsDefault: undefined,
    Locale: undefined,
    ProfileArn: undefined,
    ProfileName: undefined,
    TemperatureUnit: undefined,
    Timezone: undefined,
    WakeWord: undefined
  };
  if (output.Address !== undefined && output.Address !== null) {
    contents.Address = output.Address;
  }
  if (output.DistanceUnit !== undefined && output.DistanceUnit !== null) {
    contents.DistanceUnit = output.DistanceUnit;
  }
  if (output.IsDefault !== undefined && output.IsDefault !== null) {
    contents.IsDefault = output.IsDefault;
  }
  if (output.Locale !== undefined && output.Locale !== null) {
    contents.Locale = output.Locale;
  }
  if (output.ProfileArn !== undefined && output.ProfileArn !== null) {
    contents.ProfileArn = output.ProfileArn;
  }
  if (output.ProfileName !== undefined && output.ProfileName !== null) {
    contents.ProfileName = output.ProfileName;
  }
  if (output.TemperatureUnit !== undefined && output.TemperatureUnit !== null) {
    contents.TemperatureUnit = output.TemperatureUnit;
  }
  if (output.Timezone !== undefined && output.Timezone !== null) {
    contents.Timezone = output.Timezone;
  }
  if (output.WakeWord !== undefined && output.WakeWord !== null) {
    contents.WakeWord = output.WakeWord;
  }
  return contents;
};

const deserializeAws_json1_1ProfileDataList = (
  output: any,
  context: __SerdeContext
): Array<ProfileData> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1ProfileData(entry, context)
  );
};

const deserializeAws_json1_1PutConferencePreferenceResponse = (
  output: any,
  context: __SerdeContext
): PutConferencePreferenceResponse => {
  let contents: any = {
    __type: "PutConferencePreferenceResponse"
  };
  return contents;
};

const deserializeAws_json1_1PutInvitationConfigurationResponse = (
  output: any,
  context: __SerdeContext
): PutInvitationConfigurationResponse => {
  let contents: any = {
    __type: "PutInvitationConfigurationResponse"
  };
  return contents;
};

const deserializeAws_json1_1PutRoomSkillParameterResponse = (
  output: any,
  context: __SerdeContext
): PutRoomSkillParameterResponse => {
  let contents: any = {
    __type: "PutRoomSkillParameterResponse"
  };
  return contents;
};

const deserializeAws_json1_1PutSkillAuthorizationResponse = (
  output: any,
  context: __SerdeContext
): PutSkillAuthorizationResponse => {
  let contents: any = {
    __type: "PutSkillAuthorizationResponse"
  };
  return contents;
};

const deserializeAws_json1_1RegisterAVSDeviceResponse = (
  output: any,
  context: __SerdeContext
): RegisterAVSDeviceResponse => {
  let contents: any = {
    __type: "RegisterAVSDeviceResponse",
    DeviceArn: undefined
  };
  if (output.DeviceArn !== undefined && output.DeviceArn !== null) {
    contents.DeviceArn = output.DeviceArn;
  }
  return contents;
};

const deserializeAws_json1_1RejectSkillResponse = (
  output: any,
  context: __SerdeContext
): RejectSkillResponse => {
  let contents: any = {
    __type: "RejectSkillResponse"
  };
  return contents;
};

const deserializeAws_json1_1RequireCheckIn = (
  output: any,
  context: __SerdeContext
): RequireCheckIn => {
  let contents: any = {
    __type: "RequireCheckIn",
    Enabled: undefined,
    ReleaseAfterMinutes: undefined
  };
  if (output.Enabled !== undefined && output.Enabled !== null) {
    contents.Enabled = output.Enabled;
  }
  if (
    output.ReleaseAfterMinutes !== undefined &&
    output.ReleaseAfterMinutes !== null
  ) {
    contents.ReleaseAfterMinutes = output.ReleaseAfterMinutes;
  }
  return contents;
};

const deserializeAws_json1_1ResolveRoomResponse = (
  output: any,
  context: __SerdeContext
): ResolveRoomResponse => {
  let contents: any = {
    __type: "ResolveRoomResponse",
    RoomArn: undefined,
    RoomName: undefined,
    RoomSkillParameters: undefined
  };
  if (output.RoomArn !== undefined && output.RoomArn !== null) {
    contents.RoomArn = output.RoomArn;
  }
  if (output.RoomName !== undefined && output.RoomName !== null) {
    contents.RoomName = output.RoomName;
  }
  if (
    output.RoomSkillParameters !== undefined &&
    output.RoomSkillParameters !== null
  ) {
    contents.RoomSkillParameters = deserializeAws_json1_1RoomSkillParameters(
      output.RoomSkillParameters,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1ResourceAssociatedException = (
  output: any,
  context: __SerdeContext
): ResourceAssociatedException => {
  let contents: any = {
    __type: "ResourceAssociatedException",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1Reviews = (
  output: any,
  context: __SerdeContext
): { [key: string]: string } => {
  const mapParams: any = {};
  Object.keys(output).forEach(key => {
    mapParams[key] = output[key];
  });
  return mapParams;
};

const deserializeAws_json1_1RevokeInvitationResponse = (
  output: any,
  context: __SerdeContext
): RevokeInvitationResponse => {
  let contents: any = {
    __type: "RevokeInvitationResponse"
  };
  return contents;
};

const deserializeAws_json1_1Room = (
  output: any,
  context: __SerdeContext
): Room => {
  let contents: any = {
    __type: "Room",
    Description: undefined,
    ProfileArn: undefined,
    ProviderCalendarId: undefined,
    RoomArn: undefined,
    RoomName: undefined
  };
  if (output.Description !== undefined && output.Description !== null) {
    contents.Description = output.Description;
  }
  if (output.ProfileArn !== undefined && output.ProfileArn !== null) {
    contents.ProfileArn = output.ProfileArn;
  }
  if (
    output.ProviderCalendarId !== undefined &&
    output.ProviderCalendarId !== null
  ) {
    contents.ProviderCalendarId = output.ProviderCalendarId;
  }
  if (output.RoomArn !== undefined && output.RoomArn !== null) {
    contents.RoomArn = output.RoomArn;
  }
  if (output.RoomName !== undefined && output.RoomName !== null) {
    contents.RoomName = output.RoomName;
  }
  return contents;
};

const deserializeAws_json1_1RoomData = (
  output: any,
  context: __SerdeContext
): RoomData => {
  let contents: any = {
    __type: "RoomData",
    Description: undefined,
    ProfileArn: undefined,
    ProfileName: undefined,
    ProviderCalendarId: undefined,
    RoomArn: undefined,
    RoomName: undefined
  };
  if (output.Description !== undefined && output.Description !== null) {
    contents.Description = output.Description;
  }
  if (output.ProfileArn !== undefined && output.ProfileArn !== null) {
    contents.ProfileArn = output.ProfileArn;
  }
  if (output.ProfileName !== undefined && output.ProfileName !== null) {
    contents.ProfileName = output.ProfileName;
  }
  if (
    output.ProviderCalendarId !== undefined &&
    output.ProviderCalendarId !== null
  ) {
    contents.ProviderCalendarId = output.ProviderCalendarId;
  }
  if (output.RoomArn !== undefined && output.RoomArn !== null) {
    contents.RoomArn = output.RoomArn;
  }
  if (output.RoomName !== undefined && output.RoomName !== null) {
    contents.RoomName = output.RoomName;
  }
  return contents;
};

const deserializeAws_json1_1RoomDataList = (
  output: any,
  context: __SerdeContext
): Array<RoomData> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1RoomData(entry, context)
  );
};

const deserializeAws_json1_1RoomSkillParameter = (
  output: any,
  context: __SerdeContext
): RoomSkillParameter => {
  let contents: any = {
    __type: "RoomSkillParameter",
    ParameterKey: undefined,
    ParameterValue: undefined
  };
  if (output.ParameterKey !== undefined && output.ParameterKey !== null) {
    contents.ParameterKey = output.ParameterKey;
  }
  if (output.ParameterValue !== undefined && output.ParameterValue !== null) {
    contents.ParameterValue = output.ParameterValue;
  }
  return contents;
};

const deserializeAws_json1_1RoomSkillParameters = (
  output: any,
  context: __SerdeContext
): Array<RoomSkillParameter> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1RoomSkillParameter(entry, context)
  );
};

const deserializeAws_json1_1SampleUtterances = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1SearchAddressBooksResponse = (
  output: any,
  context: __SerdeContext
): SearchAddressBooksResponse => {
  let contents: any = {
    __type: "SearchAddressBooksResponse",
    AddressBooks: undefined,
    NextToken: undefined,
    TotalCount: undefined
  };
  if (output.AddressBooks !== undefined && output.AddressBooks !== null) {
    contents.AddressBooks = deserializeAws_json1_1AddressBookDataList(
      output.AddressBooks,
      context
    );
  }
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  if (output.TotalCount !== undefined && output.TotalCount !== null) {
    contents.TotalCount = output.TotalCount;
  }
  return contents;
};

const deserializeAws_json1_1SearchContactsResponse = (
  output: any,
  context: __SerdeContext
): SearchContactsResponse => {
  let contents: any = {
    __type: "SearchContactsResponse",
    Contacts: undefined,
    NextToken: undefined,
    TotalCount: undefined
  };
  if (output.Contacts !== undefined && output.Contacts !== null) {
    contents.Contacts = deserializeAws_json1_1ContactDataList(
      output.Contacts,
      context
    );
  }
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  if (output.TotalCount !== undefined && output.TotalCount !== null) {
    contents.TotalCount = output.TotalCount;
  }
  return contents;
};

const deserializeAws_json1_1SearchDevicesResponse = (
  output: any,
  context: __SerdeContext
): SearchDevicesResponse => {
  let contents: any = {
    __type: "SearchDevicesResponse",
    Devices: undefined,
    NextToken: undefined,
    TotalCount: undefined
  };
  if (output.Devices !== undefined && output.Devices !== null) {
    contents.Devices = deserializeAws_json1_1DeviceDataList(
      output.Devices,
      context
    );
  }
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  if (output.TotalCount !== undefined && output.TotalCount !== null) {
    contents.TotalCount = output.TotalCount;
  }
  return contents;
};

const deserializeAws_json1_1SearchNetworkProfilesResponse = (
  output: any,
  context: __SerdeContext
): SearchNetworkProfilesResponse => {
  let contents: any = {
    __type: "SearchNetworkProfilesResponse",
    NetworkProfiles: undefined,
    NextToken: undefined,
    TotalCount: undefined
  };
  if (output.NetworkProfiles !== undefined && output.NetworkProfiles !== null) {
    contents.NetworkProfiles = deserializeAws_json1_1NetworkProfileDataList(
      output.NetworkProfiles,
      context
    );
  }
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  if (output.TotalCount !== undefined && output.TotalCount !== null) {
    contents.TotalCount = output.TotalCount;
  }
  return contents;
};

const deserializeAws_json1_1SearchProfilesResponse = (
  output: any,
  context: __SerdeContext
): SearchProfilesResponse => {
  let contents: any = {
    __type: "SearchProfilesResponse",
    NextToken: undefined,
    Profiles: undefined,
    TotalCount: undefined
  };
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  if (output.Profiles !== undefined && output.Profiles !== null) {
    contents.Profiles = deserializeAws_json1_1ProfileDataList(
      output.Profiles,
      context
    );
  }
  if (output.TotalCount !== undefined && output.TotalCount !== null) {
    contents.TotalCount = output.TotalCount;
  }
  return contents;
};

const deserializeAws_json1_1SearchRoomsResponse = (
  output: any,
  context: __SerdeContext
): SearchRoomsResponse => {
  let contents: any = {
    __type: "SearchRoomsResponse",
    NextToken: undefined,
    Rooms: undefined,
    TotalCount: undefined
  };
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  if (output.Rooms !== undefined && output.Rooms !== null) {
    contents.Rooms = deserializeAws_json1_1RoomDataList(output.Rooms, context);
  }
  if (output.TotalCount !== undefined && output.TotalCount !== null) {
    contents.TotalCount = output.TotalCount;
  }
  return contents;
};

const deserializeAws_json1_1SearchSkillGroupsResponse = (
  output: any,
  context: __SerdeContext
): SearchSkillGroupsResponse => {
  let contents: any = {
    __type: "SearchSkillGroupsResponse",
    NextToken: undefined,
    SkillGroups: undefined,
    TotalCount: undefined
  };
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  if (output.SkillGroups !== undefined && output.SkillGroups !== null) {
    contents.SkillGroups = deserializeAws_json1_1SkillGroupDataList(
      output.SkillGroups,
      context
    );
  }
  if (output.TotalCount !== undefined && output.TotalCount !== null) {
    contents.TotalCount = output.TotalCount;
  }
  return contents;
};

const deserializeAws_json1_1SearchUsersResponse = (
  output: any,
  context: __SerdeContext
): SearchUsersResponse => {
  let contents: any = {
    __type: "SearchUsersResponse",
    NextToken: undefined,
    TotalCount: undefined,
    Users: undefined
  };
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  if (output.TotalCount !== undefined && output.TotalCount !== null) {
    contents.TotalCount = output.TotalCount;
  }
  if (output.Users !== undefined && output.Users !== null) {
    contents.Users = deserializeAws_json1_1UserDataList(output.Users, context);
  }
  return contents;
};

const deserializeAws_json1_1SendInvitationResponse = (
  output: any,
  context: __SerdeContext
): SendInvitationResponse => {
  let contents: any = {
    __type: "SendInvitationResponse"
  };
  return contents;
};

const deserializeAws_json1_1ShortSkillIdList = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1SipAddress = (
  output: any,
  context: __SerdeContext
): SipAddress => {
  let contents: any = {
    __type: "SipAddress",
    Type: undefined,
    Uri: undefined
  };
  if (output.Type !== undefined && output.Type !== null) {
    contents.Type = output.Type;
  }
  if (output.Uri !== undefined && output.Uri !== null) {
    contents.Uri = output.Uri;
  }
  return contents;
};

const deserializeAws_json1_1SipAddressList = (
  output: any,
  context: __SerdeContext
): Array<SipAddress> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1SipAddress(entry, context)
  );
};

const deserializeAws_json1_1SkillDetails = (
  output: any,
  context: __SerdeContext
): SkillDetails => {
  let contents: any = {
    __type: "SkillDetails",
    BulletPoints: undefined,
    DeveloperInfo: undefined,
    EndUserLicenseAgreement: undefined,
    GenericKeywords: undefined,
    InvocationPhrase: undefined,
    NewInThisVersionBulletPoints: undefined,
    ProductDescription: undefined,
    ReleaseDate: undefined,
    Reviews: undefined,
    SkillTypes: undefined
  };
  if (output.BulletPoints !== undefined && output.BulletPoints !== null) {
    contents.BulletPoints = deserializeAws_json1_1BulletPoints(
      output.BulletPoints,
      context
    );
  }
  if (output.DeveloperInfo !== undefined && output.DeveloperInfo !== null) {
    contents.DeveloperInfo = deserializeAws_json1_1DeveloperInfo(
      output.DeveloperInfo,
      context
    );
  }
  if (
    output.EndUserLicenseAgreement !== undefined &&
    output.EndUserLicenseAgreement !== null
  ) {
    contents.EndUserLicenseAgreement = output.EndUserLicenseAgreement;
  }
  if (output.GenericKeywords !== undefined && output.GenericKeywords !== null) {
    contents.GenericKeywords = deserializeAws_json1_1GenericKeywords(
      output.GenericKeywords,
      context
    );
  }
  if (
    output.InvocationPhrase !== undefined &&
    output.InvocationPhrase !== null
  ) {
    contents.InvocationPhrase = output.InvocationPhrase;
  }
  if (
    output.NewInThisVersionBulletPoints !== undefined &&
    output.NewInThisVersionBulletPoints !== null
  ) {
    contents.NewInThisVersionBulletPoints = deserializeAws_json1_1NewInThisVersionBulletPoints(
      output.NewInThisVersionBulletPoints,
      context
    );
  }
  if (
    output.ProductDescription !== undefined &&
    output.ProductDescription !== null
  ) {
    contents.ProductDescription = output.ProductDescription;
  }
  if (output.ReleaseDate !== undefined && output.ReleaseDate !== null) {
    contents.ReleaseDate = output.ReleaseDate;
  }
  if (output.Reviews !== undefined && output.Reviews !== null) {
    contents.Reviews = deserializeAws_json1_1Reviews(output.Reviews, context);
  }
  if (output.SkillTypes !== undefined && output.SkillTypes !== null) {
    contents.SkillTypes = deserializeAws_json1_1SkillTypes(
      output.SkillTypes,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1SkillGroup = (
  output: any,
  context: __SerdeContext
): SkillGroup => {
  let contents: any = {
    __type: "SkillGroup",
    Description: undefined,
    SkillGroupArn: undefined,
    SkillGroupName: undefined
  };
  if (output.Description !== undefined && output.Description !== null) {
    contents.Description = output.Description;
  }
  if (output.SkillGroupArn !== undefined && output.SkillGroupArn !== null) {
    contents.SkillGroupArn = output.SkillGroupArn;
  }
  if (output.SkillGroupName !== undefined && output.SkillGroupName !== null) {
    contents.SkillGroupName = output.SkillGroupName;
  }
  return contents;
};

const deserializeAws_json1_1SkillGroupData = (
  output: any,
  context: __SerdeContext
): SkillGroupData => {
  let contents: any = {
    __type: "SkillGroupData",
    Description: undefined,
    SkillGroupArn: undefined,
    SkillGroupName: undefined
  };
  if (output.Description !== undefined && output.Description !== null) {
    contents.Description = output.Description;
  }
  if (output.SkillGroupArn !== undefined && output.SkillGroupArn !== null) {
    contents.SkillGroupArn = output.SkillGroupArn;
  }
  if (output.SkillGroupName !== undefined && output.SkillGroupName !== null) {
    contents.SkillGroupName = output.SkillGroupName;
  }
  return contents;
};

const deserializeAws_json1_1SkillGroupDataList = (
  output: any,
  context: __SerdeContext
): Array<SkillGroupData> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1SkillGroupData(entry, context)
  );
};

const deserializeAws_json1_1SkillNotLinkedException = (
  output: any,
  context: __SerdeContext
): SkillNotLinkedException => {
  let contents: any = {
    __type: "SkillNotLinkedException",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1SkillSummary = (
  output: any,
  context: __SerdeContext
): SkillSummary => {
  let contents: any = {
    __type: "SkillSummary",
    EnablementType: undefined,
    SkillId: undefined,
    SkillName: undefined,
    SkillType: undefined,
    SupportsLinking: undefined
  };
  if (output.EnablementType !== undefined && output.EnablementType !== null) {
    contents.EnablementType = output.EnablementType;
  }
  if (output.SkillId !== undefined && output.SkillId !== null) {
    contents.SkillId = output.SkillId;
  }
  if (output.SkillName !== undefined && output.SkillName !== null) {
    contents.SkillName = output.SkillName;
  }
  if (output.SkillType !== undefined && output.SkillType !== null) {
    contents.SkillType = output.SkillType;
  }
  if (output.SupportsLinking !== undefined && output.SupportsLinking !== null) {
    contents.SupportsLinking = output.SupportsLinking;
  }
  return contents;
};

const deserializeAws_json1_1SkillSummaryList = (
  output: any,
  context: __SerdeContext
): Array<SkillSummary> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1SkillSummary(entry, context)
  );
};

const deserializeAws_json1_1SkillTypes = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1SkillsStoreSkill = (
  output: any,
  context: __SerdeContext
): SkillsStoreSkill => {
  let contents: any = {
    __type: "SkillsStoreSkill",
    IconUrl: undefined,
    SampleUtterances: undefined,
    ShortDescription: undefined,
    SkillDetails: undefined,
    SkillId: undefined,
    SkillName: undefined,
    SupportsLinking: undefined
  };
  if (output.IconUrl !== undefined && output.IconUrl !== null) {
    contents.IconUrl = output.IconUrl;
  }
  if (
    output.SampleUtterances !== undefined &&
    output.SampleUtterances !== null
  ) {
    contents.SampleUtterances = deserializeAws_json1_1SampleUtterances(
      output.SampleUtterances,
      context
    );
  }
  if (
    output.ShortDescription !== undefined &&
    output.ShortDescription !== null
  ) {
    contents.ShortDescription = output.ShortDescription;
  }
  if (output.SkillDetails !== undefined && output.SkillDetails !== null) {
    contents.SkillDetails = deserializeAws_json1_1SkillDetails(
      output.SkillDetails,
      context
    );
  }
  if (output.SkillId !== undefined && output.SkillId !== null) {
    contents.SkillId = output.SkillId;
  }
  if (output.SkillName !== undefined && output.SkillName !== null) {
    contents.SkillName = output.SkillName;
  }
  if (output.SupportsLinking !== undefined && output.SupportsLinking !== null) {
    contents.SupportsLinking = output.SupportsLinking;
  }
  return contents;
};

const deserializeAws_json1_1SkillsStoreSkillList = (
  output: any,
  context: __SerdeContext
): Array<SkillsStoreSkill> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1SkillsStoreSkill(entry, context)
  );
};

const deserializeAws_json1_1SmartHomeAppliance = (
  output: any,
  context: __SerdeContext
): SmartHomeAppliance => {
  let contents: any = {
    __type: "SmartHomeAppliance",
    Description: undefined,
    FriendlyName: undefined,
    ManufacturerName: undefined
  };
  if (output.Description !== undefined && output.Description !== null) {
    contents.Description = output.Description;
  }
  if (output.FriendlyName !== undefined && output.FriendlyName !== null) {
    contents.FriendlyName = output.FriendlyName;
  }
  if (
    output.ManufacturerName !== undefined &&
    output.ManufacturerName !== null
  ) {
    contents.ManufacturerName = output.ManufacturerName;
  }
  return contents;
};

const deserializeAws_json1_1SmartHomeApplianceList = (
  output: any,
  context: __SerdeContext
): Array<SmartHomeAppliance> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1SmartHomeAppliance(entry, context)
  );
};

const deserializeAws_json1_1StartDeviceSyncResponse = (
  output: any,
  context: __SerdeContext
): StartDeviceSyncResponse => {
  let contents: any = {
    __type: "StartDeviceSyncResponse"
  };
  return contents;
};

const deserializeAws_json1_1StartSmartHomeApplianceDiscoveryResponse = (
  output: any,
  context: __SerdeContext
): StartSmartHomeApplianceDiscoveryResponse => {
  let contents: any = {
    __type: "StartSmartHomeApplianceDiscoveryResponse"
  };
  return contents;
};

const deserializeAws_json1_1Tag = (
  output: any,
  context: __SerdeContext
): Tag => {
  let contents: any = {
    __type: "Tag",
    Key: undefined,
    Value: undefined
  };
  if (output.Key !== undefined && output.Key !== null) {
    contents.Key = output.Key;
  }
  if (output.Value !== undefined && output.Value !== null) {
    contents.Value = output.Value;
  }
  return contents;
};

const deserializeAws_json1_1TagList = (
  output: any,
  context: __SerdeContext
): Array<Tag> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1Tag(entry, context)
  );
};

const deserializeAws_json1_1TagResourceResponse = (
  output: any,
  context: __SerdeContext
): TagResourceResponse => {
  let contents: any = {
    __type: "TagResourceResponse"
  };
  return contents;
};

const deserializeAws_json1_1TrustAnchorList = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1UntagResourceResponse = (
  output: any,
  context: __SerdeContext
): UntagResourceResponse => {
  let contents: any = {
    __type: "UntagResourceResponse"
  };
  return contents;
};

const deserializeAws_json1_1UpdateAddressBookResponse = (
  output: any,
  context: __SerdeContext
): UpdateAddressBookResponse => {
  let contents: any = {
    __type: "UpdateAddressBookResponse"
  };
  return contents;
};

const deserializeAws_json1_1UpdateBusinessReportScheduleResponse = (
  output: any,
  context: __SerdeContext
): UpdateBusinessReportScheduleResponse => {
  let contents: any = {
    __type: "UpdateBusinessReportScheduleResponse"
  };
  return contents;
};

const deserializeAws_json1_1UpdateConferenceProviderResponse = (
  output: any,
  context: __SerdeContext
): UpdateConferenceProviderResponse => {
  let contents: any = {
    __type: "UpdateConferenceProviderResponse"
  };
  return contents;
};

const deserializeAws_json1_1UpdateContactResponse = (
  output: any,
  context: __SerdeContext
): UpdateContactResponse => {
  let contents: any = {
    __type: "UpdateContactResponse"
  };
  return contents;
};

const deserializeAws_json1_1UpdateDeviceResponse = (
  output: any,
  context: __SerdeContext
): UpdateDeviceResponse => {
  let contents: any = {
    __type: "UpdateDeviceResponse"
  };
  return contents;
};

const deserializeAws_json1_1UpdateGatewayGroupResponse = (
  output: any,
  context: __SerdeContext
): UpdateGatewayGroupResponse => {
  let contents: any = {
    __type: "UpdateGatewayGroupResponse"
  };
  return contents;
};

const deserializeAws_json1_1UpdateGatewayResponse = (
  output: any,
  context: __SerdeContext
): UpdateGatewayResponse => {
  let contents: any = {
    __type: "UpdateGatewayResponse"
  };
  return contents;
};

const deserializeAws_json1_1UpdateNetworkProfileResponse = (
  output: any,
  context: __SerdeContext
): UpdateNetworkProfileResponse => {
  let contents: any = {
    __type: "UpdateNetworkProfileResponse"
  };
  return contents;
};

const deserializeAws_json1_1UpdateProfileResponse = (
  output: any,
  context: __SerdeContext
): UpdateProfileResponse => {
  let contents: any = {
    __type: "UpdateProfileResponse"
  };
  return contents;
};

const deserializeAws_json1_1UpdateRoomResponse = (
  output: any,
  context: __SerdeContext
): UpdateRoomResponse => {
  let contents: any = {
    __type: "UpdateRoomResponse"
  };
  return contents;
};

const deserializeAws_json1_1UpdateSkillGroupResponse = (
  output: any,
  context: __SerdeContext
): UpdateSkillGroupResponse => {
  let contents: any = {
    __type: "UpdateSkillGroupResponse"
  };
  return contents;
};

const deserializeAws_json1_1UserData = (
  output: any,
  context: __SerdeContext
): UserData => {
  let contents: any = {
    __type: "UserData",
    Email: undefined,
    EnrollmentId: undefined,
    EnrollmentStatus: undefined,
    FirstName: undefined,
    LastName: undefined,
    UserArn: undefined
  };
  if (output.Email !== undefined && output.Email !== null) {
    contents.Email = output.Email;
  }
  if (output.EnrollmentId !== undefined && output.EnrollmentId !== null) {
    contents.EnrollmentId = output.EnrollmentId;
  }
  if (
    output.EnrollmentStatus !== undefined &&
    output.EnrollmentStatus !== null
  ) {
    contents.EnrollmentStatus = output.EnrollmentStatus;
  }
  if (output.FirstName !== undefined && output.FirstName !== null) {
    contents.FirstName = output.FirstName;
  }
  if (output.LastName !== undefined && output.LastName !== null) {
    contents.LastName = output.LastName;
  }
  if (output.UserArn !== undefined && output.UserArn !== null) {
    contents.UserArn = output.UserArn;
  }
  return contents;
};

const deserializeAws_json1_1UserDataList = (
  output: any,
  context: __SerdeContext
): Array<UserData> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1UserData(entry, context)
  );
};

const deserializeMetadata = (output: __HttpResponse): __ResponseMetadata => ({
  httpStatusCode: output.statusCode,
  httpHeaders: output.headers,
  requestId: output.headers["x-amzn-requestid"]
});

// Collect low-level response body stream to Uint8Array.
const collectBody = (
  streamBody: any,
  context: __SerdeContext
): Promise<Uint8Array> => {
  if (streamBody instanceof Uint8Array) {
    return Promise.resolve(streamBody);
  }
  return (
    context.streamCollector(streamBody) || Promise.resolve(new Uint8Array())
  );
};

// Encode Uint8Array data into string with utf-8.
const collectBodyString = (
  streamBody: any,
  context: __SerdeContext
): Promise<string> => {
  return collectBody(streamBody, context).then(body =>
    context.utf8Encoder(body)
  );
};

const buildHttpRpcRequest = (
  context: __SerdeContext,
  headers: __HeaderBag,
  path: string,
  resolvedHostname: string | undefined,
  body: any
): __HttpRequest => {
  const contents: any = {
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: path,
    headers: headers
  };
  if (resolvedHostname !== undefined) {
    contents.hostname = resolvedHostname;
  }
  if (body !== undefined) {
    contents.body = body;
  }
  return new __HttpRequest(contents);
};

const parseBody = (streamBody: any, context: __SerdeContext): any => {
  return collectBodyString(streamBody, context).then(encoded => {
    if (encoded.length) {
      return JSON.parse(encoded);
    }
    return {};
  });
};
