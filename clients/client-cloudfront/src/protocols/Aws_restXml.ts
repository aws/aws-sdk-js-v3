import {
  CreateCloudFrontOriginAccessIdentityCommandInput,
  CreateCloudFrontOriginAccessIdentityCommandOutput,
} from "../commands/CreateCloudFrontOriginAccessIdentityCommand";
import { CreateDistributionCommandInput, CreateDistributionCommandOutput } from "../commands/CreateDistributionCommand";
import {
  CreateDistributionWithTagsCommandInput,
  CreateDistributionWithTagsCommandOutput,
} from "../commands/CreateDistributionWithTagsCommand";
import {
  CreateFieldLevelEncryptionConfigCommandInput,
  CreateFieldLevelEncryptionConfigCommandOutput,
} from "../commands/CreateFieldLevelEncryptionConfigCommand";
import {
  CreateFieldLevelEncryptionProfileCommandInput,
  CreateFieldLevelEncryptionProfileCommandOutput,
} from "../commands/CreateFieldLevelEncryptionProfileCommand";
import { CreateInvalidationCommandInput, CreateInvalidationCommandOutput } from "../commands/CreateInvalidationCommand";
import { CreatePublicKeyCommandInput, CreatePublicKeyCommandOutput } from "../commands/CreatePublicKeyCommand";
import {
  CreateStreamingDistributionCommandInput,
  CreateStreamingDistributionCommandOutput,
} from "../commands/CreateStreamingDistributionCommand";
import {
  CreateStreamingDistributionWithTagsCommandInput,
  CreateStreamingDistributionWithTagsCommandOutput,
} from "../commands/CreateStreamingDistributionWithTagsCommand";
import {
  DeleteCloudFrontOriginAccessIdentityCommandInput,
  DeleteCloudFrontOriginAccessIdentityCommandOutput,
} from "../commands/DeleteCloudFrontOriginAccessIdentityCommand";
import { DeleteDistributionCommandInput, DeleteDistributionCommandOutput } from "../commands/DeleteDistributionCommand";
import {
  DeleteFieldLevelEncryptionConfigCommandInput,
  DeleteFieldLevelEncryptionConfigCommandOutput,
} from "../commands/DeleteFieldLevelEncryptionConfigCommand";
import {
  DeleteFieldLevelEncryptionProfileCommandInput,
  DeleteFieldLevelEncryptionProfileCommandOutput,
} from "../commands/DeleteFieldLevelEncryptionProfileCommand";
import { DeletePublicKeyCommandInput, DeletePublicKeyCommandOutput } from "../commands/DeletePublicKeyCommand";
import {
  DeleteStreamingDistributionCommandInput,
  DeleteStreamingDistributionCommandOutput,
} from "../commands/DeleteStreamingDistributionCommand";
import {
  GetCloudFrontOriginAccessIdentityCommandInput,
  GetCloudFrontOriginAccessIdentityCommandOutput,
} from "../commands/GetCloudFrontOriginAccessIdentityCommand";
import {
  GetCloudFrontOriginAccessIdentityConfigCommandInput,
  GetCloudFrontOriginAccessIdentityConfigCommandOutput,
} from "../commands/GetCloudFrontOriginAccessIdentityConfigCommand";
import { GetDistributionCommandInput, GetDistributionCommandOutput } from "../commands/GetDistributionCommand";
import {
  GetDistributionConfigCommandInput,
  GetDistributionConfigCommandOutput,
} from "../commands/GetDistributionConfigCommand";
import {
  GetFieldLevelEncryptionCommandInput,
  GetFieldLevelEncryptionCommandOutput,
} from "../commands/GetFieldLevelEncryptionCommand";
import {
  GetFieldLevelEncryptionConfigCommandInput,
  GetFieldLevelEncryptionConfigCommandOutput,
} from "../commands/GetFieldLevelEncryptionConfigCommand";
import {
  GetFieldLevelEncryptionProfileCommandInput,
  GetFieldLevelEncryptionProfileCommandOutput,
} from "../commands/GetFieldLevelEncryptionProfileCommand";
import {
  GetFieldLevelEncryptionProfileConfigCommandInput,
  GetFieldLevelEncryptionProfileConfigCommandOutput,
} from "../commands/GetFieldLevelEncryptionProfileConfigCommand";
import { GetInvalidationCommandInput, GetInvalidationCommandOutput } from "../commands/GetInvalidationCommand";
import { GetPublicKeyCommandInput, GetPublicKeyCommandOutput } from "../commands/GetPublicKeyCommand";
import { GetPublicKeyConfigCommandInput, GetPublicKeyConfigCommandOutput } from "../commands/GetPublicKeyConfigCommand";
import {
  GetStreamingDistributionCommandInput,
  GetStreamingDistributionCommandOutput,
} from "../commands/GetStreamingDistributionCommand";
import {
  GetStreamingDistributionConfigCommandInput,
  GetStreamingDistributionConfigCommandOutput,
} from "../commands/GetStreamingDistributionConfigCommand";
import {
  ListCloudFrontOriginAccessIdentitiesCommandInput,
  ListCloudFrontOriginAccessIdentitiesCommandOutput,
} from "../commands/ListCloudFrontOriginAccessIdentitiesCommand";
import {
  ListDistributionsByWebACLIdCommandInput,
  ListDistributionsByWebACLIdCommandOutput,
} from "../commands/ListDistributionsByWebACLIdCommand";
import { ListDistributionsCommandInput, ListDistributionsCommandOutput } from "../commands/ListDistributionsCommand";
import {
  ListFieldLevelEncryptionConfigsCommandInput,
  ListFieldLevelEncryptionConfigsCommandOutput,
} from "../commands/ListFieldLevelEncryptionConfigsCommand";
import {
  ListFieldLevelEncryptionProfilesCommandInput,
  ListFieldLevelEncryptionProfilesCommandOutput,
} from "../commands/ListFieldLevelEncryptionProfilesCommand";
import { ListInvalidationsCommandInput, ListInvalidationsCommandOutput } from "../commands/ListInvalidationsCommand";
import { ListPublicKeysCommandInput, ListPublicKeysCommandOutput } from "../commands/ListPublicKeysCommand";
import {
  ListStreamingDistributionsCommandInput,
  ListStreamingDistributionsCommandOutput,
} from "../commands/ListStreamingDistributionsCommand";
import {
  ListTagsForResourceCommandInput,
  ListTagsForResourceCommandOutput,
} from "../commands/ListTagsForResourceCommand";
import { TagResourceCommandInput, TagResourceCommandOutput } from "../commands/TagResourceCommand";
import { UntagResourceCommandInput, UntagResourceCommandOutput } from "../commands/UntagResourceCommand";
import {
  UpdateCloudFrontOriginAccessIdentityCommandInput,
  UpdateCloudFrontOriginAccessIdentityCommandOutput,
} from "../commands/UpdateCloudFrontOriginAccessIdentityCommand";
import { UpdateDistributionCommandInput, UpdateDistributionCommandOutput } from "../commands/UpdateDistributionCommand";
import {
  UpdateFieldLevelEncryptionConfigCommandInput,
  UpdateFieldLevelEncryptionConfigCommandOutput,
} from "../commands/UpdateFieldLevelEncryptionConfigCommand";
import {
  UpdateFieldLevelEncryptionProfileCommandInput,
  UpdateFieldLevelEncryptionProfileCommandOutput,
} from "../commands/UpdateFieldLevelEncryptionProfileCommand";
import { UpdatePublicKeyCommandInput, UpdatePublicKeyCommandOutput } from "../commands/UpdatePublicKeyCommand";
import {
  UpdateStreamingDistributionCommandInput,
  UpdateStreamingDistributionCommandOutput,
} from "../commands/UpdateStreamingDistributionCommand";
import {
  AccessDenied,
  ActiveTrustedSigners,
  AliasICPRecordal,
  Aliases,
  AllowedMethods,
  BatchTooLarge,
  CNAMEAlreadyExists,
  CacheBehavior,
  CacheBehaviors,
  CachedMethods,
  CannotChangeImmutablePublicKeyFields,
  CloudFrontOriginAccessIdentity,
  CloudFrontOriginAccessIdentityAlreadyExists,
  CloudFrontOriginAccessIdentityConfig,
  CloudFrontOriginAccessIdentityInUse,
  CloudFrontOriginAccessIdentityList,
  CloudFrontOriginAccessIdentitySummary,
  ContentTypeProfile,
  ContentTypeProfileConfig,
  ContentTypeProfiles,
  CookieNames,
  CookiePreference,
  CustomErrorResponse,
  CustomErrorResponses,
  CustomHeaders,
  CustomOriginConfig,
  DefaultCacheBehavior,
  Distribution,
  DistributionAlreadyExists,
  DistributionConfig,
  DistributionConfigWithTags,
  DistributionList,
  DistributionNotDisabled,
  DistributionSummary,
  EncryptionEntities,
  EncryptionEntity,
  FieldLevelEncryption,
  FieldLevelEncryptionConfig,
  FieldLevelEncryptionConfigAlreadyExists,
  FieldLevelEncryptionConfigInUse,
  FieldLevelEncryptionList,
  FieldLevelEncryptionProfile,
  FieldLevelEncryptionProfileAlreadyExists,
  FieldLevelEncryptionProfileConfig,
  FieldLevelEncryptionProfileInUse,
  FieldLevelEncryptionProfileList,
  FieldLevelEncryptionProfileSizeExceeded,
  FieldLevelEncryptionProfileSummary,
  FieldLevelEncryptionSummary,
  FieldPatterns,
  ForwardedValues,
  GeoRestriction,
  Headers,
  IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior,
  IllegalUpdate,
  InconsistentQuantities,
  InvalidArgument,
  InvalidDefaultRootObject,
  InvalidErrorCode,
  InvalidForwardCookies,
  InvalidGeoRestrictionParameter,
  InvalidHeadersForS3Origin,
  InvalidIfMatchVersion,
  InvalidLambdaFunctionAssociation,
  InvalidLocationCode,
  InvalidMinimumProtocolVersion,
  InvalidOrigin,
  InvalidOriginAccessIdentity,
  InvalidOriginKeepaliveTimeout,
  InvalidOriginReadTimeout,
  InvalidProtocolSettings,
  InvalidQueryStringParameters,
  InvalidRelativePath,
  InvalidRequiredProtocol,
  InvalidResponseCode,
  InvalidTTLOrder,
  InvalidTagging,
  InvalidViewerCertificate,
  InvalidWebACLId,
  Invalidation,
  InvalidationBatch,
  InvalidationList,
  InvalidationSummary,
  KeyPairIds,
  LambdaFunctionAssociation,
  LambdaFunctionAssociations,
  LoggingConfig,
  Method,
  MissingBody,
  NoSuchCloudFrontOriginAccessIdentity,
  NoSuchDistribution,
  NoSuchFieldLevelEncryptionConfig,
  NoSuchFieldLevelEncryptionProfile,
  NoSuchInvalidation,
  NoSuchOrigin,
  NoSuchPublicKey,
  NoSuchResource,
  NoSuchStreamingDistribution,
  Origin,
  OriginCustomHeader,
  OriginGroup,
  OriginGroupFailoverCriteria,
  OriginGroupMember,
  OriginGroupMembers,
  OriginGroups,
  OriginSslProtocols,
  Origins,
  Paths,
  PreconditionFailed,
  PublicKey,
  PublicKeyAlreadyExists,
  PublicKeyConfig,
  PublicKeyInUse,
  PublicKeyList,
  PublicKeySummary,
  QueryArgProfile,
  QueryArgProfileConfig,
  QueryArgProfileEmpty,
  QueryArgProfiles,
  QueryStringCacheKeys,
  Restrictions,
  S3Origin,
  S3OriginConfig,
  Signer,
  SslProtocol,
  StatusCodes,
  StreamingDistribution,
  StreamingDistributionAlreadyExists,
  StreamingDistributionConfig,
  StreamingDistributionConfigWithTags,
  StreamingDistributionList,
  StreamingDistributionNotDisabled,
  StreamingDistributionSummary,
  StreamingLoggingConfig,
  Tag,
  TagKeys,
  Tags,
  TooManyCacheBehaviors,
  TooManyCertificates,
  TooManyCloudFrontOriginAccessIdentities,
  TooManyCookieNamesInWhiteList,
  TooManyDistributionCNAMEs,
  TooManyDistributions,
  TooManyDistributionsAssociatedToFieldLevelEncryptionConfig,
  TooManyDistributionsWithLambdaAssociations,
  TooManyFieldLevelEncryptionConfigs,
  TooManyFieldLevelEncryptionContentTypeProfiles,
  TooManyFieldLevelEncryptionEncryptionEntities,
  TooManyFieldLevelEncryptionFieldPatterns,
  TooManyFieldLevelEncryptionProfiles,
  TooManyFieldLevelEncryptionQueryArgProfiles,
  TooManyHeadersInForwardedValues,
  TooManyInvalidationsInProgress,
  TooManyLambdaFunctionAssociations,
  TooManyOriginCustomHeaders,
  TooManyOriginGroupsPerDistribution,
  TooManyOrigins,
  TooManyPublicKeys,
  TooManyQueryStringParameters,
  TooManyStreamingDistributionCNAMEs,
  TooManyStreamingDistributions,
  TooManyTrustedSigners,
  TrustedSignerDoesNotExist,
  TrustedSigners,
  ViewerCertificate,
} from "../models/index";
import { HttpRequest as __HttpRequest, HttpResponse as __HttpResponse } from "@aws-sdk/protocol-http";
import {
  SmithyException as __SmithyException,
  extendedEncodeURIComponent as __extendedEncodeURIComponent,
  getArrayIfSingleItem as __getArrayIfSingleItem,
  getValueFromTextNode as __getValueFromTextNode,
} from "@aws-sdk/smithy-client";
import {
  Endpoint as __Endpoint,
  MetadataBearer as __MetadataBearer,
  ResponseMetadata as __ResponseMetadata,
  SerdeContext as __SerdeContext,
} from "@aws-sdk/types";
import { XmlNode as __XmlNode, XmlText as __XmlText } from "@aws-sdk/xml-builder";
import { parse as xmlParse } from "fast-xml-parser";

export const serializeAws_restXmlCreateCloudFrontOriginAccessIdentityCommand = async (
  input: CreateCloudFrontOriginAccessIdentityCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/xml",
  };
  let resolvedPath = "/2019-03-26/origin-access-identity/cloudfront";
  let body: any;
  let contents: any;
  if (input.CloudFrontOriginAccessIdentityConfig !== undefined) {
    contents = serializeAws_restXmlCloudFrontOriginAccessIdentityConfig(
      input.CloudFrontOriginAccessIdentityConfig,
      context
    );
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    contents.addAttribute("xmlns", "http://cloudfront.amazonaws.com/doc/2019-03-26/");
    body += contents.toString();
  }
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restXmlCreateDistributionCommand = async (
  input: CreateDistributionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/xml",
  };
  let resolvedPath = "/2019-03-26/distribution";
  let body: any;
  let contents: any;
  if (input.DistributionConfig !== undefined) {
    contents = serializeAws_restXmlDistributionConfig(input.DistributionConfig, context);
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    contents.addAttribute("xmlns", "http://cloudfront.amazonaws.com/doc/2019-03-26/");
    body += contents.toString();
  }
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restXmlCreateDistributionWithTagsCommand = async (
  input: CreateDistributionWithTagsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/xml",
  };
  let resolvedPath = "/2019-03-26/distribution";
  const query: any = {
    WithTags: "",
  };
  let body: any;
  let contents: any;
  if (input.DistributionConfigWithTags !== undefined) {
    contents = serializeAws_restXmlDistributionConfigWithTags(input.DistributionConfigWithTags, context);
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    contents.addAttribute("xmlns", "http://cloudfront.amazonaws.com/doc/2019-03-26/");
    body += contents.toString();
  }
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};

export const serializeAws_restXmlCreateFieldLevelEncryptionConfigCommand = async (
  input: CreateFieldLevelEncryptionConfigCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/xml",
  };
  let resolvedPath = "/2019-03-26/field-level-encryption";
  let body: any;
  let contents: any;
  if (input.FieldLevelEncryptionConfig !== undefined) {
    contents = serializeAws_restXmlFieldLevelEncryptionConfig(input.FieldLevelEncryptionConfig, context);
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    contents.addAttribute("xmlns", "http://cloudfront.amazonaws.com/doc/2019-03-26/");
    body += contents.toString();
  }
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restXmlCreateFieldLevelEncryptionProfileCommand = async (
  input: CreateFieldLevelEncryptionProfileCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/xml",
  };
  let resolvedPath = "/2019-03-26/field-level-encryption-profile";
  let body: any;
  let contents: any;
  if (input.FieldLevelEncryptionProfileConfig !== undefined) {
    contents = serializeAws_restXmlFieldLevelEncryptionProfileConfig(input.FieldLevelEncryptionProfileConfig, context);
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    contents.addAttribute("xmlns", "http://cloudfront.amazonaws.com/doc/2019-03-26/");
    body += contents.toString();
  }
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restXmlCreateInvalidationCommand = async (
  input: CreateInvalidationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/xml",
  };
  let resolvedPath = "/2019-03-26/distribution/{DistributionId}/invalidation";
  if (input.DistributionId !== undefined) {
    const labelValue: string = input.DistributionId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: DistributionId.");
    }
    resolvedPath = resolvedPath.replace("{DistributionId}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: DistributionId.");
  }
  let body: any;
  let contents: any;
  if (input.InvalidationBatch !== undefined) {
    contents = serializeAws_restXmlInvalidationBatch(input.InvalidationBatch, context);
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    contents.addAttribute("xmlns", "http://cloudfront.amazonaws.com/doc/2019-03-26/");
    body += contents.toString();
  }
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restXmlCreatePublicKeyCommand = async (
  input: CreatePublicKeyCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/xml",
  };
  let resolvedPath = "/2019-03-26/public-key";
  let body: any;
  let contents: any;
  if (input.PublicKeyConfig !== undefined) {
    contents = serializeAws_restXmlPublicKeyConfig(input.PublicKeyConfig, context);
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    contents.addAttribute("xmlns", "http://cloudfront.amazonaws.com/doc/2019-03-26/");
    body += contents.toString();
  }
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restXmlCreateStreamingDistributionCommand = async (
  input: CreateStreamingDistributionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/xml",
  };
  let resolvedPath = "/2019-03-26/streaming-distribution";
  let body: any;
  let contents: any;
  if (input.StreamingDistributionConfig !== undefined) {
    contents = serializeAws_restXmlStreamingDistributionConfig(input.StreamingDistributionConfig, context);
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    contents.addAttribute("xmlns", "http://cloudfront.amazonaws.com/doc/2019-03-26/");
    body += contents.toString();
  }
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restXmlCreateStreamingDistributionWithTagsCommand = async (
  input: CreateStreamingDistributionWithTagsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/xml",
  };
  let resolvedPath = "/2019-03-26/streaming-distribution";
  const query: any = {
    WithTags: "",
  };
  let body: any;
  let contents: any;
  if (input.StreamingDistributionConfigWithTags !== undefined) {
    contents = serializeAws_restXmlStreamingDistributionConfigWithTags(
      input.StreamingDistributionConfigWithTags,
      context
    );
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    contents.addAttribute("xmlns", "http://cloudfront.amazonaws.com/doc/2019-03-26/");
    body += contents.toString();
  }
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};

export const serializeAws_restXmlDeleteCloudFrontOriginAccessIdentityCommand = async (
  input: DeleteCloudFrontOriginAccessIdentityCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "",
    ...(isSerializableHeaderValue(input.IfMatch) && { "If-Match": input.IfMatch! }),
  };
  let resolvedPath = "/2019-03-26/origin-access-identity/cloudfront/{Id}";
  if (input.Id !== undefined) {
    const labelValue: string = input.Id;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Id.");
    }
    resolvedPath = resolvedPath.replace("{Id}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: Id.");
  }
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restXmlDeleteDistributionCommand = async (
  input: DeleteDistributionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "",
    ...(isSerializableHeaderValue(input.IfMatch) && { "If-Match": input.IfMatch! }),
  };
  let resolvedPath = "/2019-03-26/distribution/{Id}";
  if (input.Id !== undefined) {
    const labelValue: string = input.Id;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Id.");
    }
    resolvedPath = resolvedPath.replace("{Id}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: Id.");
  }
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restXmlDeleteFieldLevelEncryptionConfigCommand = async (
  input: DeleteFieldLevelEncryptionConfigCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "",
    ...(isSerializableHeaderValue(input.IfMatch) && { "If-Match": input.IfMatch! }),
  };
  let resolvedPath = "/2019-03-26/field-level-encryption/{Id}";
  if (input.Id !== undefined) {
    const labelValue: string = input.Id;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Id.");
    }
    resolvedPath = resolvedPath.replace("{Id}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: Id.");
  }
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restXmlDeleteFieldLevelEncryptionProfileCommand = async (
  input: DeleteFieldLevelEncryptionProfileCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "",
    ...(isSerializableHeaderValue(input.IfMatch) && { "If-Match": input.IfMatch! }),
  };
  let resolvedPath = "/2019-03-26/field-level-encryption-profile/{Id}";
  if (input.Id !== undefined) {
    const labelValue: string = input.Id;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Id.");
    }
    resolvedPath = resolvedPath.replace("{Id}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: Id.");
  }
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restXmlDeletePublicKeyCommand = async (
  input: DeletePublicKeyCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "",
    ...(isSerializableHeaderValue(input.IfMatch) && { "If-Match": input.IfMatch! }),
  };
  let resolvedPath = "/2019-03-26/public-key/{Id}";
  if (input.Id !== undefined) {
    const labelValue: string = input.Id;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Id.");
    }
    resolvedPath = resolvedPath.replace("{Id}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: Id.");
  }
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restXmlDeleteStreamingDistributionCommand = async (
  input: DeleteStreamingDistributionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "",
    ...(isSerializableHeaderValue(input.IfMatch) && { "If-Match": input.IfMatch! }),
  };
  let resolvedPath = "/2019-03-26/streaming-distribution/{Id}";
  if (input.Id !== undefined) {
    const labelValue: string = input.Id;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Id.");
    }
    resolvedPath = resolvedPath.replace("{Id}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: Id.");
  }
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restXmlGetCloudFrontOriginAccessIdentityCommand = async (
  input: GetCloudFrontOriginAccessIdentityCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "",
  };
  let resolvedPath = "/2019-03-26/origin-access-identity/cloudfront/{Id}";
  if (input.Id !== undefined) {
    const labelValue: string = input.Id;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Id.");
    }
    resolvedPath = resolvedPath.replace("{Id}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: Id.");
  }
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restXmlGetCloudFrontOriginAccessIdentityConfigCommand = async (
  input: GetCloudFrontOriginAccessIdentityConfigCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "",
  };
  let resolvedPath = "/2019-03-26/origin-access-identity/cloudfront/{Id}/config";
  if (input.Id !== undefined) {
    const labelValue: string = input.Id;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Id.");
    }
    resolvedPath = resolvedPath.replace("{Id}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: Id.");
  }
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restXmlGetDistributionCommand = async (
  input: GetDistributionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "",
  };
  let resolvedPath = "/2019-03-26/distribution/{Id}";
  if (input.Id !== undefined) {
    const labelValue: string = input.Id;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Id.");
    }
    resolvedPath = resolvedPath.replace("{Id}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: Id.");
  }
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restXmlGetDistributionConfigCommand = async (
  input: GetDistributionConfigCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "",
  };
  let resolvedPath = "/2019-03-26/distribution/{Id}/config";
  if (input.Id !== undefined) {
    const labelValue: string = input.Id;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Id.");
    }
    resolvedPath = resolvedPath.replace("{Id}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: Id.");
  }
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restXmlGetFieldLevelEncryptionCommand = async (
  input: GetFieldLevelEncryptionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "",
  };
  let resolvedPath = "/2019-03-26/field-level-encryption/{Id}";
  if (input.Id !== undefined) {
    const labelValue: string = input.Id;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Id.");
    }
    resolvedPath = resolvedPath.replace("{Id}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: Id.");
  }
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restXmlGetFieldLevelEncryptionConfigCommand = async (
  input: GetFieldLevelEncryptionConfigCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "",
  };
  let resolvedPath = "/2019-03-26/field-level-encryption/{Id}/config";
  if (input.Id !== undefined) {
    const labelValue: string = input.Id;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Id.");
    }
    resolvedPath = resolvedPath.replace("{Id}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: Id.");
  }
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restXmlGetFieldLevelEncryptionProfileCommand = async (
  input: GetFieldLevelEncryptionProfileCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "",
  };
  let resolvedPath = "/2019-03-26/field-level-encryption-profile/{Id}";
  if (input.Id !== undefined) {
    const labelValue: string = input.Id;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Id.");
    }
    resolvedPath = resolvedPath.replace("{Id}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: Id.");
  }
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restXmlGetFieldLevelEncryptionProfileConfigCommand = async (
  input: GetFieldLevelEncryptionProfileConfigCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "",
  };
  let resolvedPath = "/2019-03-26/field-level-encryption-profile/{Id}/config";
  if (input.Id !== undefined) {
    const labelValue: string = input.Id;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Id.");
    }
    resolvedPath = resolvedPath.replace("{Id}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: Id.");
  }
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restXmlGetInvalidationCommand = async (
  input: GetInvalidationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "",
  };
  let resolvedPath = "/2019-03-26/distribution/{DistributionId}/invalidation/{Id}";
  if (input.DistributionId !== undefined) {
    const labelValue: string = input.DistributionId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: DistributionId.");
    }
    resolvedPath = resolvedPath.replace("{DistributionId}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: DistributionId.");
  }
  if (input.Id !== undefined) {
    const labelValue: string = input.Id;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Id.");
    }
    resolvedPath = resolvedPath.replace("{Id}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: Id.");
  }
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restXmlGetPublicKeyCommand = async (
  input: GetPublicKeyCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "",
  };
  let resolvedPath = "/2019-03-26/public-key/{Id}";
  if (input.Id !== undefined) {
    const labelValue: string = input.Id;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Id.");
    }
    resolvedPath = resolvedPath.replace("{Id}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: Id.");
  }
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restXmlGetPublicKeyConfigCommand = async (
  input: GetPublicKeyConfigCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "",
  };
  let resolvedPath = "/2019-03-26/public-key/{Id}/config";
  if (input.Id !== undefined) {
    const labelValue: string = input.Id;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Id.");
    }
    resolvedPath = resolvedPath.replace("{Id}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: Id.");
  }
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restXmlGetStreamingDistributionCommand = async (
  input: GetStreamingDistributionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "",
  };
  let resolvedPath = "/2019-03-26/streaming-distribution/{Id}";
  if (input.Id !== undefined) {
    const labelValue: string = input.Id;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Id.");
    }
    resolvedPath = resolvedPath.replace("{Id}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: Id.");
  }
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restXmlGetStreamingDistributionConfigCommand = async (
  input: GetStreamingDistributionConfigCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "",
  };
  let resolvedPath = "/2019-03-26/streaming-distribution/{Id}/config";
  if (input.Id !== undefined) {
    const labelValue: string = input.Id;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Id.");
    }
    resolvedPath = resolvedPath.replace("{Id}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: Id.");
  }
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restXmlListCloudFrontOriginAccessIdentitiesCommand = async (
  input: ListCloudFrontOriginAccessIdentitiesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "",
  };
  let resolvedPath = "/2019-03-26/origin-access-identity/cloudfront";
  const query: any = {
    ...(input.Marker !== undefined && { Marker: input.Marker }),
    ...(input.MaxItems !== undefined && { MaxItems: input.MaxItems }),
  };
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};

export const serializeAws_restXmlListDistributionsCommand = async (
  input: ListDistributionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "",
  };
  let resolvedPath = "/2019-03-26/distribution";
  const query: any = {
    ...(input.Marker !== undefined && { Marker: input.Marker }),
    ...(input.MaxItems !== undefined && { MaxItems: input.MaxItems }),
  };
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};

export const serializeAws_restXmlListDistributionsByWebACLIdCommand = async (
  input: ListDistributionsByWebACLIdCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "",
  };
  let resolvedPath = "/2019-03-26/distributionsByWebACLId/{WebACLId}";
  if (input.WebACLId !== undefined) {
    const labelValue: string = input.WebACLId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: WebACLId.");
    }
    resolvedPath = resolvedPath.replace("{WebACLId}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: WebACLId.");
  }
  const query: any = {
    ...(input.Marker !== undefined && { Marker: input.Marker }),
    ...(input.MaxItems !== undefined && { MaxItems: input.MaxItems }),
  };
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};

export const serializeAws_restXmlListFieldLevelEncryptionConfigsCommand = async (
  input: ListFieldLevelEncryptionConfigsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "",
  };
  let resolvedPath = "/2019-03-26/field-level-encryption";
  const query: any = {
    ...(input.Marker !== undefined && { Marker: input.Marker }),
    ...(input.MaxItems !== undefined && { MaxItems: input.MaxItems }),
  };
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};

export const serializeAws_restXmlListFieldLevelEncryptionProfilesCommand = async (
  input: ListFieldLevelEncryptionProfilesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "",
  };
  let resolvedPath = "/2019-03-26/field-level-encryption-profile";
  const query: any = {
    ...(input.Marker !== undefined && { Marker: input.Marker }),
    ...(input.MaxItems !== undefined && { MaxItems: input.MaxItems }),
  };
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};

export const serializeAws_restXmlListInvalidationsCommand = async (
  input: ListInvalidationsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "",
  };
  let resolvedPath = "/2019-03-26/distribution/{DistributionId}/invalidation";
  if (input.DistributionId !== undefined) {
    const labelValue: string = input.DistributionId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: DistributionId.");
    }
    resolvedPath = resolvedPath.replace("{DistributionId}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: DistributionId.");
  }
  const query: any = {
    ...(input.Marker !== undefined && { Marker: input.Marker }),
    ...(input.MaxItems !== undefined && { MaxItems: input.MaxItems }),
  };
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};

export const serializeAws_restXmlListPublicKeysCommand = async (
  input: ListPublicKeysCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "",
  };
  let resolvedPath = "/2019-03-26/public-key";
  const query: any = {
    ...(input.Marker !== undefined && { Marker: input.Marker }),
    ...(input.MaxItems !== undefined && { MaxItems: input.MaxItems }),
  };
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};

export const serializeAws_restXmlListStreamingDistributionsCommand = async (
  input: ListStreamingDistributionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "",
  };
  let resolvedPath = "/2019-03-26/streaming-distribution";
  const query: any = {
    ...(input.Marker !== undefined && { Marker: input.Marker }),
    ...(input.MaxItems !== undefined && { MaxItems: input.MaxItems }),
  };
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};

export const serializeAws_restXmlListTagsForResourceCommand = async (
  input: ListTagsForResourceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "",
  };
  let resolvedPath = "/2019-03-26/tagging";
  const query: any = {
    ...(input.Resource !== undefined && { Resource: input.Resource }),
  };
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};

export const serializeAws_restXmlTagResourceCommand = async (
  input: TagResourceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/xml",
  };
  let resolvedPath = "/2019-03-26/tagging";
  const query: any = {
    Operation: "Tag",
    ...(input.Resource !== undefined && { Resource: input.Resource }),
  };
  let body: any;
  let contents: any;
  if (input.Tags !== undefined) {
    contents = serializeAws_restXmlTags(input.Tags, context);
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    contents.addAttribute("xmlns", "http://cloudfront.amazonaws.com/doc/2019-03-26/");
    body += contents.toString();
  }
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};

export const serializeAws_restXmlUntagResourceCommand = async (
  input: UntagResourceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/xml",
  };
  let resolvedPath = "/2019-03-26/tagging";
  const query: any = {
    Operation: "Untag",
    ...(input.Resource !== undefined && { Resource: input.Resource }),
  };
  let body: any;
  let contents: any;
  if (input.TagKeys !== undefined) {
    contents = serializeAws_restXmlTagKeys(input.TagKeys, context);
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    contents.addAttribute("xmlns", "http://cloudfront.amazonaws.com/doc/2019-03-26/");
    body += contents.toString();
  }
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};

export const serializeAws_restXmlUpdateCloudFrontOriginAccessIdentityCommand = async (
  input: UpdateCloudFrontOriginAccessIdentityCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/xml",
    ...(isSerializableHeaderValue(input.IfMatch) && { "If-Match": input.IfMatch! }),
  };
  let resolvedPath = "/2019-03-26/origin-access-identity/cloudfront/{Id}/config";
  if (input.Id !== undefined) {
    const labelValue: string = input.Id;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Id.");
    }
    resolvedPath = resolvedPath.replace("{Id}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: Id.");
  }
  let body: any;
  let contents: any;
  if (input.CloudFrontOriginAccessIdentityConfig !== undefined) {
    contents = serializeAws_restXmlCloudFrontOriginAccessIdentityConfig(
      input.CloudFrontOriginAccessIdentityConfig,
      context
    );
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    contents.addAttribute("xmlns", "http://cloudfront.amazonaws.com/doc/2019-03-26/");
    body += contents.toString();
  }
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "PUT",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restXmlUpdateDistributionCommand = async (
  input: UpdateDistributionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/xml",
    ...(isSerializableHeaderValue(input.IfMatch) && { "If-Match": input.IfMatch! }),
  };
  let resolvedPath = "/2019-03-26/distribution/{Id}/config";
  if (input.Id !== undefined) {
    const labelValue: string = input.Id;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Id.");
    }
    resolvedPath = resolvedPath.replace("{Id}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: Id.");
  }
  let body: any;
  let contents: any;
  if (input.DistributionConfig !== undefined) {
    contents = serializeAws_restXmlDistributionConfig(input.DistributionConfig, context);
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    contents.addAttribute("xmlns", "http://cloudfront.amazonaws.com/doc/2019-03-26/");
    body += contents.toString();
  }
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "PUT",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restXmlUpdateFieldLevelEncryptionConfigCommand = async (
  input: UpdateFieldLevelEncryptionConfigCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/xml",
    ...(isSerializableHeaderValue(input.IfMatch) && { "If-Match": input.IfMatch! }),
  };
  let resolvedPath = "/2019-03-26/field-level-encryption/{Id}/config";
  if (input.Id !== undefined) {
    const labelValue: string = input.Id;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Id.");
    }
    resolvedPath = resolvedPath.replace("{Id}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: Id.");
  }
  let body: any;
  let contents: any;
  if (input.FieldLevelEncryptionConfig !== undefined) {
    contents = serializeAws_restXmlFieldLevelEncryptionConfig(input.FieldLevelEncryptionConfig, context);
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    contents.addAttribute("xmlns", "http://cloudfront.amazonaws.com/doc/2019-03-26/");
    body += contents.toString();
  }
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "PUT",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restXmlUpdateFieldLevelEncryptionProfileCommand = async (
  input: UpdateFieldLevelEncryptionProfileCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/xml",
    ...(isSerializableHeaderValue(input.IfMatch) && { "If-Match": input.IfMatch! }),
  };
  let resolvedPath = "/2019-03-26/field-level-encryption-profile/{Id}/config";
  if (input.Id !== undefined) {
    const labelValue: string = input.Id;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Id.");
    }
    resolvedPath = resolvedPath.replace("{Id}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: Id.");
  }
  let body: any;
  let contents: any;
  if (input.FieldLevelEncryptionProfileConfig !== undefined) {
    contents = serializeAws_restXmlFieldLevelEncryptionProfileConfig(input.FieldLevelEncryptionProfileConfig, context);
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    contents.addAttribute("xmlns", "http://cloudfront.amazonaws.com/doc/2019-03-26/");
    body += contents.toString();
  }
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "PUT",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restXmlUpdatePublicKeyCommand = async (
  input: UpdatePublicKeyCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/xml",
    ...(isSerializableHeaderValue(input.IfMatch) && { "If-Match": input.IfMatch! }),
  };
  let resolvedPath = "/2019-03-26/public-key/{Id}/config";
  if (input.Id !== undefined) {
    const labelValue: string = input.Id;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Id.");
    }
    resolvedPath = resolvedPath.replace("{Id}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: Id.");
  }
  let body: any;
  let contents: any;
  if (input.PublicKeyConfig !== undefined) {
    contents = serializeAws_restXmlPublicKeyConfig(input.PublicKeyConfig, context);
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    contents.addAttribute("xmlns", "http://cloudfront.amazonaws.com/doc/2019-03-26/");
    body += contents.toString();
  }
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "PUT",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restXmlUpdateStreamingDistributionCommand = async (
  input: UpdateStreamingDistributionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/xml",
    ...(isSerializableHeaderValue(input.IfMatch) && { "If-Match": input.IfMatch! }),
  };
  let resolvedPath = "/2019-03-26/streaming-distribution/{Id}/config";
  if (input.Id !== undefined) {
    const labelValue: string = input.Id;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Id.");
    }
    resolvedPath = resolvedPath.replace("{Id}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: Id.");
  }
  let body: any;
  let contents: any;
  if (input.StreamingDistributionConfig !== undefined) {
    contents = serializeAws_restXmlStreamingDistributionConfig(input.StreamingDistributionConfig, context);
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    contents.addAttribute("xmlns", "http://cloudfront.amazonaws.com/doc/2019-03-26/");
    body += contents.toString();
  }
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "PUT",
    headers,
    path: resolvedPath,
    body,
  });
};

export const deserializeAws_restXmlCreateCloudFrontOriginAccessIdentityCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateCloudFrontOriginAccessIdentityCommandOutput> => {
  if (output.statusCode !== 201 && output.statusCode >= 400) {
    return deserializeAws_restXmlCreateCloudFrontOriginAccessIdentityCommandError(output, context);
  }
  const contents: CreateCloudFrontOriginAccessIdentityCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateCloudFrontOriginAccessIdentityResult",
    CloudFrontOriginAccessIdentity: undefined,
    ETag: undefined,
    Location: undefined,
  };
  if (output.headers["etag"] !== undefined) {
    contents.ETag = output.headers["etag"];
  }
  if (output.headers["location"] !== undefined) {
    contents.Location = output.headers["location"];
  }
  const data: any = await parseBody(output.body, context);
  contents.CloudFrontOriginAccessIdentity = deserializeAws_restXmlCloudFrontOriginAccessIdentity(data, context);
  return Promise.resolve(contents);
};

const deserializeAws_restXmlCreateCloudFrontOriginAccessIdentityCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateCloudFrontOriginAccessIdentityCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "CloudFrontOriginAccessIdentityAlreadyExists":
    case "com.amazonaws.cloudfront#CloudFrontOriginAccessIdentityAlreadyExists":
      response = {
        ...(await deserializeAws_restXmlCloudFrontOriginAccessIdentityAlreadyExistsResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InconsistentQuantities":
    case "com.amazonaws.cloudfront#InconsistentQuantities":
      response = {
        ...(await deserializeAws_restXmlInconsistentQuantitiesResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidArgument":
    case "com.amazonaws.cloudfront#InvalidArgument":
      response = {
        ...(await deserializeAws_restXmlInvalidArgumentResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "MissingBody":
    case "com.amazonaws.cloudfront#MissingBody":
      response = {
        ...(await deserializeAws_restXmlMissingBodyResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "TooManyCloudFrontOriginAccessIdentities":
    case "com.amazonaws.cloudfront#TooManyCloudFrontOriginAccessIdentities":
      response = {
        ...(await deserializeAws_restXmlTooManyCloudFrontOriginAccessIdentitiesResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message: parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlCreateDistributionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDistributionCommandOutput> => {
  if (output.statusCode !== 201 && output.statusCode >= 400) {
    return deserializeAws_restXmlCreateDistributionCommandError(output, context);
  }
  const contents: CreateDistributionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateDistributionResult",
    Distribution: undefined,
    ETag: undefined,
    Location: undefined,
  };
  if (output.headers["etag"] !== undefined) {
    contents.ETag = output.headers["etag"];
  }
  if (output.headers["location"] !== undefined) {
    contents.Location = output.headers["location"];
  }
  const data: any = await parseBody(output.body, context);
  contents.Distribution = deserializeAws_restXmlDistribution(data, context);
  return Promise.resolve(contents);
};

const deserializeAws_restXmlCreateDistributionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDistributionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDenied":
    case "com.amazonaws.cloudfront#AccessDenied":
      response = {
        ...(await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "CNAMEAlreadyExists":
    case "com.amazonaws.cloudfront#CNAMEAlreadyExists":
      response = {
        ...(await deserializeAws_restXmlCNAMEAlreadyExistsResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "DistributionAlreadyExists":
    case "com.amazonaws.cloudfront#DistributionAlreadyExists":
      response = {
        ...(await deserializeAws_restXmlDistributionAlreadyExistsResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior":
    case "com.amazonaws.cloudfront#IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior":
      response = {
        ...(await deserializeAws_restXmlIllegalFieldLevelEncryptionConfigAssociationWithCacheBehaviorResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InconsistentQuantities":
    case "com.amazonaws.cloudfront#InconsistentQuantities":
      response = {
        ...(await deserializeAws_restXmlInconsistentQuantitiesResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidArgument":
    case "com.amazonaws.cloudfront#InvalidArgument":
      response = {
        ...(await deserializeAws_restXmlInvalidArgumentResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidDefaultRootObject":
    case "com.amazonaws.cloudfront#InvalidDefaultRootObject":
      response = {
        ...(await deserializeAws_restXmlInvalidDefaultRootObjectResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidErrorCode":
    case "com.amazonaws.cloudfront#InvalidErrorCode":
      response = {
        ...(await deserializeAws_restXmlInvalidErrorCodeResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidForwardCookies":
    case "com.amazonaws.cloudfront#InvalidForwardCookies":
      response = {
        ...(await deserializeAws_restXmlInvalidForwardCookiesResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidGeoRestrictionParameter":
    case "com.amazonaws.cloudfront#InvalidGeoRestrictionParameter":
      response = {
        ...(await deserializeAws_restXmlInvalidGeoRestrictionParameterResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidHeadersForS3Origin":
    case "com.amazonaws.cloudfront#InvalidHeadersForS3Origin":
      response = {
        ...(await deserializeAws_restXmlInvalidHeadersForS3OriginResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidLambdaFunctionAssociation":
    case "com.amazonaws.cloudfront#InvalidLambdaFunctionAssociation":
      response = {
        ...(await deserializeAws_restXmlInvalidLambdaFunctionAssociationResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidLocationCode":
    case "com.amazonaws.cloudfront#InvalidLocationCode":
      response = {
        ...(await deserializeAws_restXmlInvalidLocationCodeResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidMinimumProtocolVersion":
    case "com.amazonaws.cloudfront#InvalidMinimumProtocolVersion":
      response = {
        ...(await deserializeAws_restXmlInvalidMinimumProtocolVersionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidOrigin":
    case "com.amazonaws.cloudfront#InvalidOrigin":
      response = {
        ...(await deserializeAws_restXmlInvalidOriginResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidOriginAccessIdentity":
    case "com.amazonaws.cloudfront#InvalidOriginAccessIdentity":
      response = {
        ...(await deserializeAws_restXmlInvalidOriginAccessIdentityResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidOriginKeepaliveTimeout":
    case "com.amazonaws.cloudfront#InvalidOriginKeepaliveTimeout":
      response = {
        ...(await deserializeAws_restXmlInvalidOriginKeepaliveTimeoutResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidOriginReadTimeout":
    case "com.amazonaws.cloudfront#InvalidOriginReadTimeout":
      response = {
        ...(await deserializeAws_restXmlInvalidOriginReadTimeoutResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidProtocolSettings":
    case "com.amazonaws.cloudfront#InvalidProtocolSettings":
      response = {
        ...(await deserializeAws_restXmlInvalidProtocolSettingsResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidQueryStringParameters":
    case "com.amazonaws.cloudfront#InvalidQueryStringParameters":
      response = {
        ...(await deserializeAws_restXmlInvalidQueryStringParametersResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRelativePath":
    case "com.amazonaws.cloudfront#InvalidRelativePath":
      response = {
        ...(await deserializeAws_restXmlInvalidRelativePathResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequiredProtocol":
    case "com.amazonaws.cloudfront#InvalidRequiredProtocol":
      response = {
        ...(await deserializeAws_restXmlInvalidRequiredProtocolResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidResponseCode":
    case "com.amazonaws.cloudfront#InvalidResponseCode":
      response = {
        ...(await deserializeAws_restXmlInvalidResponseCodeResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidTTLOrder":
    case "com.amazonaws.cloudfront#InvalidTTLOrder":
      response = {
        ...(await deserializeAws_restXmlInvalidTTLOrderResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidViewerCertificate":
    case "com.amazonaws.cloudfront#InvalidViewerCertificate":
      response = {
        ...(await deserializeAws_restXmlInvalidViewerCertificateResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidWebACLId":
    case "com.amazonaws.cloudfront#InvalidWebACLId":
      response = {
        ...(await deserializeAws_restXmlInvalidWebACLIdResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "MissingBody":
    case "com.amazonaws.cloudfront#MissingBody":
      response = {
        ...(await deserializeAws_restXmlMissingBodyResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NoSuchFieldLevelEncryptionConfig":
    case "com.amazonaws.cloudfront#NoSuchFieldLevelEncryptionConfig":
      response = {
        ...(await deserializeAws_restXmlNoSuchFieldLevelEncryptionConfigResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NoSuchOrigin":
    case "com.amazonaws.cloudfront#NoSuchOrigin":
      response = {
        ...(await deserializeAws_restXmlNoSuchOriginResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "TooManyCacheBehaviors":
    case "com.amazonaws.cloudfront#TooManyCacheBehaviors":
      response = {
        ...(await deserializeAws_restXmlTooManyCacheBehaviorsResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "TooManyCertificates":
    case "com.amazonaws.cloudfront#TooManyCertificates":
      response = {
        ...(await deserializeAws_restXmlTooManyCertificatesResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "TooManyCookieNamesInWhiteList":
    case "com.amazonaws.cloudfront#TooManyCookieNamesInWhiteList":
      response = {
        ...(await deserializeAws_restXmlTooManyCookieNamesInWhiteListResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "TooManyDistributionCNAMEs":
    case "com.amazonaws.cloudfront#TooManyDistributionCNAMEs":
      response = {
        ...(await deserializeAws_restXmlTooManyDistributionCNAMEsResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "TooManyDistributions":
    case "com.amazonaws.cloudfront#TooManyDistributions":
      response = {
        ...(await deserializeAws_restXmlTooManyDistributionsResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "TooManyDistributionsAssociatedToFieldLevelEncryptionConfig":
    case "com.amazonaws.cloudfront#TooManyDistributionsAssociatedToFieldLevelEncryptionConfig":
      response = {
        ...(await deserializeAws_restXmlTooManyDistributionsAssociatedToFieldLevelEncryptionConfigResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "TooManyDistributionsWithLambdaAssociations":
    case "com.amazonaws.cloudfront#TooManyDistributionsWithLambdaAssociations":
      response = {
        ...(await deserializeAws_restXmlTooManyDistributionsWithLambdaAssociationsResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "TooManyHeadersInForwardedValues":
    case "com.amazonaws.cloudfront#TooManyHeadersInForwardedValues":
      response = {
        ...(await deserializeAws_restXmlTooManyHeadersInForwardedValuesResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "TooManyLambdaFunctionAssociations":
    case "com.amazonaws.cloudfront#TooManyLambdaFunctionAssociations":
      response = {
        ...(await deserializeAws_restXmlTooManyLambdaFunctionAssociationsResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "TooManyOriginCustomHeaders":
    case "com.amazonaws.cloudfront#TooManyOriginCustomHeaders":
      response = {
        ...(await deserializeAws_restXmlTooManyOriginCustomHeadersResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "TooManyOriginGroupsPerDistribution":
    case "com.amazonaws.cloudfront#TooManyOriginGroupsPerDistribution":
      response = {
        ...(await deserializeAws_restXmlTooManyOriginGroupsPerDistributionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "TooManyOrigins":
    case "com.amazonaws.cloudfront#TooManyOrigins":
      response = {
        ...(await deserializeAws_restXmlTooManyOriginsResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "TooManyQueryStringParameters":
    case "com.amazonaws.cloudfront#TooManyQueryStringParameters":
      response = {
        ...(await deserializeAws_restXmlTooManyQueryStringParametersResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "TooManyTrustedSigners":
    case "com.amazonaws.cloudfront#TooManyTrustedSigners":
      response = {
        ...(await deserializeAws_restXmlTooManyTrustedSignersResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "TrustedSignerDoesNotExist":
    case "com.amazonaws.cloudfront#TrustedSignerDoesNotExist":
      response = {
        ...(await deserializeAws_restXmlTrustedSignerDoesNotExistResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message: parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlCreateDistributionWithTagsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDistributionWithTagsCommandOutput> => {
  if (output.statusCode !== 201 && output.statusCode >= 400) {
    return deserializeAws_restXmlCreateDistributionWithTagsCommandError(output, context);
  }
  const contents: CreateDistributionWithTagsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateDistributionWithTagsResult",
    Distribution: undefined,
    ETag: undefined,
    Location: undefined,
  };
  if (output.headers["etag"] !== undefined) {
    contents.ETag = output.headers["etag"];
  }
  if (output.headers["location"] !== undefined) {
    contents.Location = output.headers["location"];
  }
  const data: any = await parseBody(output.body, context);
  contents.Distribution = deserializeAws_restXmlDistribution(data, context);
  return Promise.resolve(contents);
};

const deserializeAws_restXmlCreateDistributionWithTagsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDistributionWithTagsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDenied":
    case "com.amazonaws.cloudfront#AccessDenied":
      response = {
        ...(await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "CNAMEAlreadyExists":
    case "com.amazonaws.cloudfront#CNAMEAlreadyExists":
      response = {
        ...(await deserializeAws_restXmlCNAMEAlreadyExistsResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "DistributionAlreadyExists":
    case "com.amazonaws.cloudfront#DistributionAlreadyExists":
      response = {
        ...(await deserializeAws_restXmlDistributionAlreadyExistsResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior":
    case "com.amazonaws.cloudfront#IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior":
      response = {
        ...(await deserializeAws_restXmlIllegalFieldLevelEncryptionConfigAssociationWithCacheBehaviorResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InconsistentQuantities":
    case "com.amazonaws.cloudfront#InconsistentQuantities":
      response = {
        ...(await deserializeAws_restXmlInconsistentQuantitiesResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidArgument":
    case "com.amazonaws.cloudfront#InvalidArgument":
      response = {
        ...(await deserializeAws_restXmlInvalidArgumentResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidDefaultRootObject":
    case "com.amazonaws.cloudfront#InvalidDefaultRootObject":
      response = {
        ...(await deserializeAws_restXmlInvalidDefaultRootObjectResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidErrorCode":
    case "com.amazonaws.cloudfront#InvalidErrorCode":
      response = {
        ...(await deserializeAws_restXmlInvalidErrorCodeResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidForwardCookies":
    case "com.amazonaws.cloudfront#InvalidForwardCookies":
      response = {
        ...(await deserializeAws_restXmlInvalidForwardCookiesResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidGeoRestrictionParameter":
    case "com.amazonaws.cloudfront#InvalidGeoRestrictionParameter":
      response = {
        ...(await deserializeAws_restXmlInvalidGeoRestrictionParameterResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidHeadersForS3Origin":
    case "com.amazonaws.cloudfront#InvalidHeadersForS3Origin":
      response = {
        ...(await deserializeAws_restXmlInvalidHeadersForS3OriginResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidLambdaFunctionAssociation":
    case "com.amazonaws.cloudfront#InvalidLambdaFunctionAssociation":
      response = {
        ...(await deserializeAws_restXmlInvalidLambdaFunctionAssociationResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidLocationCode":
    case "com.amazonaws.cloudfront#InvalidLocationCode":
      response = {
        ...(await deserializeAws_restXmlInvalidLocationCodeResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidMinimumProtocolVersion":
    case "com.amazonaws.cloudfront#InvalidMinimumProtocolVersion":
      response = {
        ...(await deserializeAws_restXmlInvalidMinimumProtocolVersionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidOrigin":
    case "com.amazonaws.cloudfront#InvalidOrigin":
      response = {
        ...(await deserializeAws_restXmlInvalidOriginResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidOriginAccessIdentity":
    case "com.amazonaws.cloudfront#InvalidOriginAccessIdentity":
      response = {
        ...(await deserializeAws_restXmlInvalidOriginAccessIdentityResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidOriginKeepaliveTimeout":
    case "com.amazonaws.cloudfront#InvalidOriginKeepaliveTimeout":
      response = {
        ...(await deserializeAws_restXmlInvalidOriginKeepaliveTimeoutResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidOriginReadTimeout":
    case "com.amazonaws.cloudfront#InvalidOriginReadTimeout":
      response = {
        ...(await deserializeAws_restXmlInvalidOriginReadTimeoutResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidProtocolSettings":
    case "com.amazonaws.cloudfront#InvalidProtocolSettings":
      response = {
        ...(await deserializeAws_restXmlInvalidProtocolSettingsResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidQueryStringParameters":
    case "com.amazonaws.cloudfront#InvalidQueryStringParameters":
      response = {
        ...(await deserializeAws_restXmlInvalidQueryStringParametersResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRelativePath":
    case "com.amazonaws.cloudfront#InvalidRelativePath":
      response = {
        ...(await deserializeAws_restXmlInvalidRelativePathResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequiredProtocol":
    case "com.amazonaws.cloudfront#InvalidRequiredProtocol":
      response = {
        ...(await deserializeAws_restXmlInvalidRequiredProtocolResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidResponseCode":
    case "com.amazonaws.cloudfront#InvalidResponseCode":
      response = {
        ...(await deserializeAws_restXmlInvalidResponseCodeResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidTagging":
    case "com.amazonaws.cloudfront#InvalidTagging":
      response = {
        ...(await deserializeAws_restXmlInvalidTaggingResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidTTLOrder":
    case "com.amazonaws.cloudfront#InvalidTTLOrder":
      response = {
        ...(await deserializeAws_restXmlInvalidTTLOrderResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidViewerCertificate":
    case "com.amazonaws.cloudfront#InvalidViewerCertificate":
      response = {
        ...(await deserializeAws_restXmlInvalidViewerCertificateResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidWebACLId":
    case "com.amazonaws.cloudfront#InvalidWebACLId":
      response = {
        ...(await deserializeAws_restXmlInvalidWebACLIdResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "MissingBody":
    case "com.amazonaws.cloudfront#MissingBody":
      response = {
        ...(await deserializeAws_restXmlMissingBodyResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NoSuchFieldLevelEncryptionConfig":
    case "com.amazonaws.cloudfront#NoSuchFieldLevelEncryptionConfig":
      response = {
        ...(await deserializeAws_restXmlNoSuchFieldLevelEncryptionConfigResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NoSuchOrigin":
    case "com.amazonaws.cloudfront#NoSuchOrigin":
      response = {
        ...(await deserializeAws_restXmlNoSuchOriginResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "TooManyCacheBehaviors":
    case "com.amazonaws.cloudfront#TooManyCacheBehaviors":
      response = {
        ...(await deserializeAws_restXmlTooManyCacheBehaviorsResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "TooManyCertificates":
    case "com.amazonaws.cloudfront#TooManyCertificates":
      response = {
        ...(await deserializeAws_restXmlTooManyCertificatesResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "TooManyCookieNamesInWhiteList":
    case "com.amazonaws.cloudfront#TooManyCookieNamesInWhiteList":
      response = {
        ...(await deserializeAws_restXmlTooManyCookieNamesInWhiteListResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "TooManyDistributionCNAMEs":
    case "com.amazonaws.cloudfront#TooManyDistributionCNAMEs":
      response = {
        ...(await deserializeAws_restXmlTooManyDistributionCNAMEsResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "TooManyDistributions":
    case "com.amazonaws.cloudfront#TooManyDistributions":
      response = {
        ...(await deserializeAws_restXmlTooManyDistributionsResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "TooManyDistributionsAssociatedToFieldLevelEncryptionConfig":
    case "com.amazonaws.cloudfront#TooManyDistributionsAssociatedToFieldLevelEncryptionConfig":
      response = {
        ...(await deserializeAws_restXmlTooManyDistributionsAssociatedToFieldLevelEncryptionConfigResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "TooManyDistributionsWithLambdaAssociations":
    case "com.amazonaws.cloudfront#TooManyDistributionsWithLambdaAssociations":
      response = {
        ...(await deserializeAws_restXmlTooManyDistributionsWithLambdaAssociationsResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "TooManyHeadersInForwardedValues":
    case "com.amazonaws.cloudfront#TooManyHeadersInForwardedValues":
      response = {
        ...(await deserializeAws_restXmlTooManyHeadersInForwardedValuesResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "TooManyLambdaFunctionAssociations":
    case "com.amazonaws.cloudfront#TooManyLambdaFunctionAssociations":
      response = {
        ...(await deserializeAws_restXmlTooManyLambdaFunctionAssociationsResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "TooManyOriginCustomHeaders":
    case "com.amazonaws.cloudfront#TooManyOriginCustomHeaders":
      response = {
        ...(await deserializeAws_restXmlTooManyOriginCustomHeadersResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "TooManyOriginGroupsPerDistribution":
    case "com.amazonaws.cloudfront#TooManyOriginGroupsPerDistribution":
      response = {
        ...(await deserializeAws_restXmlTooManyOriginGroupsPerDistributionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "TooManyOrigins":
    case "com.amazonaws.cloudfront#TooManyOrigins":
      response = {
        ...(await deserializeAws_restXmlTooManyOriginsResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "TooManyQueryStringParameters":
    case "com.amazonaws.cloudfront#TooManyQueryStringParameters":
      response = {
        ...(await deserializeAws_restXmlTooManyQueryStringParametersResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "TooManyTrustedSigners":
    case "com.amazonaws.cloudfront#TooManyTrustedSigners":
      response = {
        ...(await deserializeAws_restXmlTooManyTrustedSignersResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "TrustedSignerDoesNotExist":
    case "com.amazonaws.cloudfront#TrustedSignerDoesNotExist":
      response = {
        ...(await deserializeAws_restXmlTrustedSignerDoesNotExistResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message: parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlCreateFieldLevelEncryptionConfigCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateFieldLevelEncryptionConfigCommandOutput> => {
  if (output.statusCode !== 201 && output.statusCode >= 400) {
    return deserializeAws_restXmlCreateFieldLevelEncryptionConfigCommandError(output, context);
  }
  const contents: CreateFieldLevelEncryptionConfigCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateFieldLevelEncryptionConfigResult",
    ETag: undefined,
    FieldLevelEncryption: undefined,
    Location: undefined,
  };
  if (output.headers["etag"] !== undefined) {
    contents.ETag = output.headers["etag"];
  }
  if (output.headers["location"] !== undefined) {
    contents.Location = output.headers["location"];
  }
  const data: any = await parseBody(output.body, context);
  contents.FieldLevelEncryption = deserializeAws_restXmlFieldLevelEncryption(data, context);
  return Promise.resolve(contents);
};

const deserializeAws_restXmlCreateFieldLevelEncryptionConfigCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateFieldLevelEncryptionConfigCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "FieldLevelEncryptionConfigAlreadyExists":
    case "com.amazonaws.cloudfront#FieldLevelEncryptionConfigAlreadyExists":
      response = {
        ...(await deserializeAws_restXmlFieldLevelEncryptionConfigAlreadyExistsResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InconsistentQuantities":
    case "com.amazonaws.cloudfront#InconsistentQuantities":
      response = {
        ...(await deserializeAws_restXmlInconsistentQuantitiesResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidArgument":
    case "com.amazonaws.cloudfront#InvalidArgument":
      response = {
        ...(await deserializeAws_restXmlInvalidArgumentResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NoSuchFieldLevelEncryptionProfile":
    case "com.amazonaws.cloudfront#NoSuchFieldLevelEncryptionProfile":
      response = {
        ...(await deserializeAws_restXmlNoSuchFieldLevelEncryptionProfileResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "QueryArgProfileEmpty":
    case "com.amazonaws.cloudfront#QueryArgProfileEmpty":
      response = {
        ...(await deserializeAws_restXmlQueryArgProfileEmptyResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "TooManyFieldLevelEncryptionConfigs":
    case "com.amazonaws.cloudfront#TooManyFieldLevelEncryptionConfigs":
      response = {
        ...(await deserializeAws_restXmlTooManyFieldLevelEncryptionConfigsResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "TooManyFieldLevelEncryptionContentTypeProfiles":
    case "com.amazonaws.cloudfront#TooManyFieldLevelEncryptionContentTypeProfiles":
      response = {
        ...(await deserializeAws_restXmlTooManyFieldLevelEncryptionContentTypeProfilesResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "TooManyFieldLevelEncryptionQueryArgProfiles":
    case "com.amazonaws.cloudfront#TooManyFieldLevelEncryptionQueryArgProfiles":
      response = {
        ...(await deserializeAws_restXmlTooManyFieldLevelEncryptionQueryArgProfilesResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message: parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlCreateFieldLevelEncryptionProfileCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateFieldLevelEncryptionProfileCommandOutput> => {
  if (output.statusCode !== 201 && output.statusCode >= 400) {
    return deserializeAws_restXmlCreateFieldLevelEncryptionProfileCommandError(output, context);
  }
  const contents: CreateFieldLevelEncryptionProfileCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateFieldLevelEncryptionProfileResult",
    ETag: undefined,
    FieldLevelEncryptionProfile: undefined,
    Location: undefined,
  };
  if (output.headers["etag"] !== undefined) {
    contents.ETag = output.headers["etag"];
  }
  if (output.headers["location"] !== undefined) {
    contents.Location = output.headers["location"];
  }
  const data: any = await parseBody(output.body, context);
  contents.FieldLevelEncryptionProfile = deserializeAws_restXmlFieldLevelEncryptionProfile(data, context);
  return Promise.resolve(contents);
};

const deserializeAws_restXmlCreateFieldLevelEncryptionProfileCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateFieldLevelEncryptionProfileCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "FieldLevelEncryptionProfileAlreadyExists":
    case "com.amazonaws.cloudfront#FieldLevelEncryptionProfileAlreadyExists":
      response = {
        ...(await deserializeAws_restXmlFieldLevelEncryptionProfileAlreadyExistsResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "FieldLevelEncryptionProfileSizeExceeded":
    case "com.amazonaws.cloudfront#FieldLevelEncryptionProfileSizeExceeded":
      response = {
        ...(await deserializeAws_restXmlFieldLevelEncryptionProfileSizeExceededResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InconsistentQuantities":
    case "com.amazonaws.cloudfront#InconsistentQuantities":
      response = {
        ...(await deserializeAws_restXmlInconsistentQuantitiesResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidArgument":
    case "com.amazonaws.cloudfront#InvalidArgument":
      response = {
        ...(await deserializeAws_restXmlInvalidArgumentResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NoSuchPublicKey":
    case "com.amazonaws.cloudfront#NoSuchPublicKey":
      response = {
        ...(await deserializeAws_restXmlNoSuchPublicKeyResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "TooManyFieldLevelEncryptionEncryptionEntities":
    case "com.amazonaws.cloudfront#TooManyFieldLevelEncryptionEncryptionEntities":
      response = {
        ...(await deserializeAws_restXmlTooManyFieldLevelEncryptionEncryptionEntitiesResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "TooManyFieldLevelEncryptionFieldPatterns":
    case "com.amazonaws.cloudfront#TooManyFieldLevelEncryptionFieldPatterns":
      response = {
        ...(await deserializeAws_restXmlTooManyFieldLevelEncryptionFieldPatternsResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "TooManyFieldLevelEncryptionProfiles":
    case "com.amazonaws.cloudfront#TooManyFieldLevelEncryptionProfiles":
      response = {
        ...(await deserializeAws_restXmlTooManyFieldLevelEncryptionProfilesResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message: parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlCreateInvalidationCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateInvalidationCommandOutput> => {
  if (output.statusCode !== 201 && output.statusCode >= 400) {
    return deserializeAws_restXmlCreateInvalidationCommandError(output, context);
  }
  const contents: CreateInvalidationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateInvalidationResult",
    Invalidation: undefined,
    Location: undefined,
  };
  if (output.headers["location"] !== undefined) {
    contents.Location = output.headers["location"];
  }
  const data: any = await parseBody(output.body, context);
  contents.Invalidation = deserializeAws_restXmlInvalidation(data, context);
  return Promise.resolve(contents);
};

const deserializeAws_restXmlCreateInvalidationCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateInvalidationCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDenied":
    case "com.amazonaws.cloudfront#AccessDenied":
      response = {
        ...(await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "BatchTooLarge":
    case "com.amazonaws.cloudfront#BatchTooLarge":
      response = {
        ...(await deserializeAws_restXmlBatchTooLargeResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InconsistentQuantities":
    case "com.amazonaws.cloudfront#InconsistentQuantities":
      response = {
        ...(await deserializeAws_restXmlInconsistentQuantitiesResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidArgument":
    case "com.amazonaws.cloudfront#InvalidArgument":
      response = {
        ...(await deserializeAws_restXmlInvalidArgumentResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "MissingBody":
    case "com.amazonaws.cloudfront#MissingBody":
      response = {
        ...(await deserializeAws_restXmlMissingBodyResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NoSuchDistribution":
    case "com.amazonaws.cloudfront#NoSuchDistribution":
      response = {
        ...(await deserializeAws_restXmlNoSuchDistributionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "TooManyInvalidationsInProgress":
    case "com.amazonaws.cloudfront#TooManyInvalidationsInProgress":
      response = {
        ...(await deserializeAws_restXmlTooManyInvalidationsInProgressResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message: parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlCreatePublicKeyCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreatePublicKeyCommandOutput> => {
  if (output.statusCode !== 201 && output.statusCode >= 400) {
    return deserializeAws_restXmlCreatePublicKeyCommandError(output, context);
  }
  const contents: CreatePublicKeyCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreatePublicKeyResult",
    ETag: undefined,
    Location: undefined,
    PublicKey: undefined,
  };
  if (output.headers["etag"] !== undefined) {
    contents.ETag = output.headers["etag"];
  }
  if (output.headers["location"] !== undefined) {
    contents.Location = output.headers["location"];
  }
  const data: any = await parseBody(output.body, context);
  contents.PublicKey = deserializeAws_restXmlPublicKey(data, context);
  return Promise.resolve(contents);
};

const deserializeAws_restXmlCreatePublicKeyCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreatePublicKeyCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidArgument":
    case "com.amazonaws.cloudfront#InvalidArgument":
      response = {
        ...(await deserializeAws_restXmlInvalidArgumentResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "PublicKeyAlreadyExists":
    case "com.amazonaws.cloudfront#PublicKeyAlreadyExists":
      response = {
        ...(await deserializeAws_restXmlPublicKeyAlreadyExistsResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "TooManyPublicKeys":
    case "com.amazonaws.cloudfront#TooManyPublicKeys":
      response = {
        ...(await deserializeAws_restXmlTooManyPublicKeysResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message: parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlCreateStreamingDistributionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateStreamingDistributionCommandOutput> => {
  if (output.statusCode !== 201 && output.statusCode >= 400) {
    return deserializeAws_restXmlCreateStreamingDistributionCommandError(output, context);
  }
  const contents: CreateStreamingDistributionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateStreamingDistributionResult",
    ETag: undefined,
    Location: undefined,
    StreamingDistribution: undefined,
  };
  if (output.headers["etag"] !== undefined) {
    contents.ETag = output.headers["etag"];
  }
  if (output.headers["location"] !== undefined) {
    contents.Location = output.headers["location"];
  }
  const data: any = await parseBody(output.body, context);
  contents.StreamingDistribution = deserializeAws_restXmlStreamingDistribution(data, context);
  return Promise.resolve(contents);
};

const deserializeAws_restXmlCreateStreamingDistributionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateStreamingDistributionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDenied":
    case "com.amazonaws.cloudfront#AccessDenied":
      response = {
        ...(await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "CNAMEAlreadyExists":
    case "com.amazonaws.cloudfront#CNAMEAlreadyExists":
      response = {
        ...(await deserializeAws_restXmlCNAMEAlreadyExistsResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InconsistentQuantities":
    case "com.amazonaws.cloudfront#InconsistentQuantities":
      response = {
        ...(await deserializeAws_restXmlInconsistentQuantitiesResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidArgument":
    case "com.amazonaws.cloudfront#InvalidArgument":
      response = {
        ...(await deserializeAws_restXmlInvalidArgumentResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidOrigin":
    case "com.amazonaws.cloudfront#InvalidOrigin":
      response = {
        ...(await deserializeAws_restXmlInvalidOriginResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidOriginAccessIdentity":
    case "com.amazonaws.cloudfront#InvalidOriginAccessIdentity":
      response = {
        ...(await deserializeAws_restXmlInvalidOriginAccessIdentityResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "MissingBody":
    case "com.amazonaws.cloudfront#MissingBody":
      response = {
        ...(await deserializeAws_restXmlMissingBodyResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "StreamingDistributionAlreadyExists":
    case "com.amazonaws.cloudfront#StreamingDistributionAlreadyExists":
      response = {
        ...(await deserializeAws_restXmlStreamingDistributionAlreadyExistsResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "TooManyStreamingDistributionCNAMEs":
    case "com.amazonaws.cloudfront#TooManyStreamingDistributionCNAMEs":
      response = {
        ...(await deserializeAws_restXmlTooManyStreamingDistributionCNAMEsResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "TooManyStreamingDistributions":
    case "com.amazonaws.cloudfront#TooManyStreamingDistributions":
      response = {
        ...(await deserializeAws_restXmlTooManyStreamingDistributionsResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "TooManyTrustedSigners":
    case "com.amazonaws.cloudfront#TooManyTrustedSigners":
      response = {
        ...(await deserializeAws_restXmlTooManyTrustedSignersResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "TrustedSignerDoesNotExist":
    case "com.amazonaws.cloudfront#TrustedSignerDoesNotExist":
      response = {
        ...(await deserializeAws_restXmlTrustedSignerDoesNotExistResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message: parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlCreateStreamingDistributionWithTagsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateStreamingDistributionWithTagsCommandOutput> => {
  if (output.statusCode !== 201 && output.statusCode >= 400) {
    return deserializeAws_restXmlCreateStreamingDistributionWithTagsCommandError(output, context);
  }
  const contents: CreateStreamingDistributionWithTagsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateStreamingDistributionWithTagsResult",
    ETag: undefined,
    Location: undefined,
    StreamingDistribution: undefined,
  };
  if (output.headers["etag"] !== undefined) {
    contents.ETag = output.headers["etag"];
  }
  if (output.headers["location"] !== undefined) {
    contents.Location = output.headers["location"];
  }
  const data: any = await parseBody(output.body, context);
  contents.StreamingDistribution = deserializeAws_restXmlStreamingDistribution(data, context);
  return Promise.resolve(contents);
};

const deserializeAws_restXmlCreateStreamingDistributionWithTagsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateStreamingDistributionWithTagsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDenied":
    case "com.amazonaws.cloudfront#AccessDenied":
      response = {
        ...(await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "CNAMEAlreadyExists":
    case "com.amazonaws.cloudfront#CNAMEAlreadyExists":
      response = {
        ...(await deserializeAws_restXmlCNAMEAlreadyExistsResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InconsistentQuantities":
    case "com.amazonaws.cloudfront#InconsistentQuantities":
      response = {
        ...(await deserializeAws_restXmlInconsistentQuantitiesResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidArgument":
    case "com.amazonaws.cloudfront#InvalidArgument":
      response = {
        ...(await deserializeAws_restXmlInvalidArgumentResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidOrigin":
    case "com.amazonaws.cloudfront#InvalidOrigin":
      response = {
        ...(await deserializeAws_restXmlInvalidOriginResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidOriginAccessIdentity":
    case "com.amazonaws.cloudfront#InvalidOriginAccessIdentity":
      response = {
        ...(await deserializeAws_restXmlInvalidOriginAccessIdentityResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidTagging":
    case "com.amazonaws.cloudfront#InvalidTagging":
      response = {
        ...(await deserializeAws_restXmlInvalidTaggingResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "MissingBody":
    case "com.amazonaws.cloudfront#MissingBody":
      response = {
        ...(await deserializeAws_restXmlMissingBodyResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "StreamingDistributionAlreadyExists":
    case "com.amazonaws.cloudfront#StreamingDistributionAlreadyExists":
      response = {
        ...(await deserializeAws_restXmlStreamingDistributionAlreadyExistsResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "TooManyStreamingDistributionCNAMEs":
    case "com.amazonaws.cloudfront#TooManyStreamingDistributionCNAMEs":
      response = {
        ...(await deserializeAws_restXmlTooManyStreamingDistributionCNAMEsResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "TooManyStreamingDistributions":
    case "com.amazonaws.cloudfront#TooManyStreamingDistributions":
      response = {
        ...(await deserializeAws_restXmlTooManyStreamingDistributionsResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "TooManyTrustedSigners":
    case "com.amazonaws.cloudfront#TooManyTrustedSigners":
      response = {
        ...(await deserializeAws_restXmlTooManyTrustedSignersResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "TrustedSignerDoesNotExist":
    case "com.amazonaws.cloudfront#TrustedSignerDoesNotExist":
      response = {
        ...(await deserializeAws_restXmlTrustedSignerDoesNotExistResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message: parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlDeleteCloudFrontOriginAccessIdentityCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteCloudFrontOriginAccessIdentityCommandOutput> => {
  if (output.statusCode !== 204 && output.statusCode >= 400) {
    return deserializeAws_restXmlDeleteCloudFrontOriginAccessIdentityCommandError(output, context);
  }
  const contents: DeleteCloudFrontOriginAccessIdentityCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restXmlDeleteCloudFrontOriginAccessIdentityCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteCloudFrontOriginAccessIdentityCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDenied":
    case "com.amazonaws.cloudfront#AccessDenied":
      response = {
        ...(await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "CloudFrontOriginAccessIdentityInUse":
    case "com.amazonaws.cloudfront#CloudFrontOriginAccessIdentityInUse":
      response = {
        ...(await deserializeAws_restXmlCloudFrontOriginAccessIdentityInUseResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidIfMatchVersion":
    case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
      response = {
        ...(await deserializeAws_restXmlInvalidIfMatchVersionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NoSuchCloudFrontOriginAccessIdentity":
    case "com.amazonaws.cloudfront#NoSuchCloudFrontOriginAccessIdentity":
      response = {
        ...(await deserializeAws_restXmlNoSuchCloudFrontOriginAccessIdentityResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "PreconditionFailed":
    case "com.amazonaws.cloudfront#PreconditionFailed":
      response = {
        ...(await deserializeAws_restXmlPreconditionFailedResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message: parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlDeleteDistributionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteDistributionCommandOutput> => {
  if (output.statusCode !== 204 && output.statusCode >= 400) {
    return deserializeAws_restXmlDeleteDistributionCommandError(output, context);
  }
  const contents: DeleteDistributionCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restXmlDeleteDistributionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteDistributionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDenied":
    case "com.amazonaws.cloudfront#AccessDenied":
      response = {
        ...(await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "DistributionNotDisabled":
    case "com.amazonaws.cloudfront#DistributionNotDisabled":
      response = {
        ...(await deserializeAws_restXmlDistributionNotDisabledResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidIfMatchVersion":
    case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
      response = {
        ...(await deserializeAws_restXmlInvalidIfMatchVersionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NoSuchDistribution":
    case "com.amazonaws.cloudfront#NoSuchDistribution":
      response = {
        ...(await deserializeAws_restXmlNoSuchDistributionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "PreconditionFailed":
    case "com.amazonaws.cloudfront#PreconditionFailed":
      response = {
        ...(await deserializeAws_restXmlPreconditionFailedResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message: parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlDeleteFieldLevelEncryptionConfigCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteFieldLevelEncryptionConfigCommandOutput> => {
  if (output.statusCode !== 204 && output.statusCode >= 400) {
    return deserializeAws_restXmlDeleteFieldLevelEncryptionConfigCommandError(output, context);
  }
  const contents: DeleteFieldLevelEncryptionConfigCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restXmlDeleteFieldLevelEncryptionConfigCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteFieldLevelEncryptionConfigCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDenied":
    case "com.amazonaws.cloudfront#AccessDenied":
      response = {
        ...(await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "FieldLevelEncryptionConfigInUse":
    case "com.amazonaws.cloudfront#FieldLevelEncryptionConfigInUse":
      response = {
        ...(await deserializeAws_restXmlFieldLevelEncryptionConfigInUseResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidIfMatchVersion":
    case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
      response = {
        ...(await deserializeAws_restXmlInvalidIfMatchVersionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NoSuchFieldLevelEncryptionConfig":
    case "com.amazonaws.cloudfront#NoSuchFieldLevelEncryptionConfig":
      response = {
        ...(await deserializeAws_restXmlNoSuchFieldLevelEncryptionConfigResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "PreconditionFailed":
    case "com.amazonaws.cloudfront#PreconditionFailed":
      response = {
        ...(await deserializeAws_restXmlPreconditionFailedResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message: parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlDeleteFieldLevelEncryptionProfileCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteFieldLevelEncryptionProfileCommandOutput> => {
  if (output.statusCode !== 204 && output.statusCode >= 400) {
    return deserializeAws_restXmlDeleteFieldLevelEncryptionProfileCommandError(output, context);
  }
  const contents: DeleteFieldLevelEncryptionProfileCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restXmlDeleteFieldLevelEncryptionProfileCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteFieldLevelEncryptionProfileCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDenied":
    case "com.amazonaws.cloudfront#AccessDenied":
      response = {
        ...(await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "FieldLevelEncryptionProfileInUse":
    case "com.amazonaws.cloudfront#FieldLevelEncryptionProfileInUse":
      response = {
        ...(await deserializeAws_restXmlFieldLevelEncryptionProfileInUseResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidIfMatchVersion":
    case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
      response = {
        ...(await deserializeAws_restXmlInvalidIfMatchVersionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NoSuchFieldLevelEncryptionProfile":
    case "com.amazonaws.cloudfront#NoSuchFieldLevelEncryptionProfile":
      response = {
        ...(await deserializeAws_restXmlNoSuchFieldLevelEncryptionProfileResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "PreconditionFailed":
    case "com.amazonaws.cloudfront#PreconditionFailed":
      response = {
        ...(await deserializeAws_restXmlPreconditionFailedResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message: parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlDeletePublicKeyCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeletePublicKeyCommandOutput> => {
  if (output.statusCode !== 204 && output.statusCode >= 400) {
    return deserializeAws_restXmlDeletePublicKeyCommandError(output, context);
  }
  const contents: DeletePublicKeyCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restXmlDeletePublicKeyCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeletePublicKeyCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDenied":
    case "com.amazonaws.cloudfront#AccessDenied":
      response = {
        ...(await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidIfMatchVersion":
    case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
      response = {
        ...(await deserializeAws_restXmlInvalidIfMatchVersionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NoSuchPublicKey":
    case "com.amazonaws.cloudfront#NoSuchPublicKey":
      response = {
        ...(await deserializeAws_restXmlNoSuchPublicKeyResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "PreconditionFailed":
    case "com.amazonaws.cloudfront#PreconditionFailed":
      response = {
        ...(await deserializeAws_restXmlPreconditionFailedResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "PublicKeyInUse":
    case "com.amazonaws.cloudfront#PublicKeyInUse":
      response = {
        ...(await deserializeAws_restXmlPublicKeyInUseResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message: parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlDeleteStreamingDistributionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteStreamingDistributionCommandOutput> => {
  if (output.statusCode !== 204 && output.statusCode >= 400) {
    return deserializeAws_restXmlDeleteStreamingDistributionCommandError(output, context);
  }
  const contents: DeleteStreamingDistributionCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restXmlDeleteStreamingDistributionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteStreamingDistributionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDenied":
    case "com.amazonaws.cloudfront#AccessDenied":
      response = {
        ...(await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidIfMatchVersion":
    case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
      response = {
        ...(await deserializeAws_restXmlInvalidIfMatchVersionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NoSuchStreamingDistribution":
    case "com.amazonaws.cloudfront#NoSuchStreamingDistribution":
      response = {
        ...(await deserializeAws_restXmlNoSuchStreamingDistributionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "PreconditionFailed":
    case "com.amazonaws.cloudfront#PreconditionFailed":
      response = {
        ...(await deserializeAws_restXmlPreconditionFailedResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "StreamingDistributionNotDisabled":
    case "com.amazonaws.cloudfront#StreamingDistributionNotDisabled":
      response = {
        ...(await deserializeAws_restXmlStreamingDistributionNotDisabledResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message: parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlGetCloudFrontOriginAccessIdentityCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetCloudFrontOriginAccessIdentityCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlGetCloudFrontOriginAccessIdentityCommandError(output, context);
  }
  const contents: GetCloudFrontOriginAccessIdentityCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetCloudFrontOriginAccessIdentityResult",
    CloudFrontOriginAccessIdentity: undefined,
    ETag: undefined,
  };
  if (output.headers["etag"] !== undefined) {
    contents.ETag = output.headers["etag"];
  }
  const data: any = await parseBody(output.body, context);
  contents.CloudFrontOriginAccessIdentity = deserializeAws_restXmlCloudFrontOriginAccessIdentity(data, context);
  return Promise.resolve(contents);
};

const deserializeAws_restXmlGetCloudFrontOriginAccessIdentityCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetCloudFrontOriginAccessIdentityCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDenied":
    case "com.amazonaws.cloudfront#AccessDenied":
      response = {
        ...(await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NoSuchCloudFrontOriginAccessIdentity":
    case "com.amazonaws.cloudfront#NoSuchCloudFrontOriginAccessIdentity":
      response = {
        ...(await deserializeAws_restXmlNoSuchCloudFrontOriginAccessIdentityResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message: parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlGetCloudFrontOriginAccessIdentityConfigCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetCloudFrontOriginAccessIdentityConfigCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlGetCloudFrontOriginAccessIdentityConfigCommandError(output, context);
  }
  const contents: GetCloudFrontOriginAccessIdentityConfigCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetCloudFrontOriginAccessIdentityConfigResult",
    CloudFrontOriginAccessIdentityConfig: undefined,
    ETag: undefined,
  };
  if (output.headers["etag"] !== undefined) {
    contents.ETag = output.headers["etag"];
  }
  const data: any = await parseBody(output.body, context);
  contents.CloudFrontOriginAccessIdentityConfig = deserializeAws_restXmlCloudFrontOriginAccessIdentityConfig(
    data,
    context
  );
  return Promise.resolve(contents);
};

const deserializeAws_restXmlGetCloudFrontOriginAccessIdentityConfigCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetCloudFrontOriginAccessIdentityConfigCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDenied":
    case "com.amazonaws.cloudfront#AccessDenied":
      response = {
        ...(await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NoSuchCloudFrontOriginAccessIdentity":
    case "com.amazonaws.cloudfront#NoSuchCloudFrontOriginAccessIdentity":
      response = {
        ...(await deserializeAws_restXmlNoSuchCloudFrontOriginAccessIdentityResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message: parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlGetDistributionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetDistributionCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlGetDistributionCommandError(output, context);
  }
  const contents: GetDistributionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetDistributionResult",
    Distribution: undefined,
    ETag: undefined,
  };
  if (output.headers["etag"] !== undefined) {
    contents.ETag = output.headers["etag"];
  }
  const data: any = await parseBody(output.body, context);
  contents.Distribution = deserializeAws_restXmlDistribution(data, context);
  return Promise.resolve(contents);
};

const deserializeAws_restXmlGetDistributionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetDistributionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDenied":
    case "com.amazonaws.cloudfront#AccessDenied":
      response = {
        ...(await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NoSuchDistribution":
    case "com.amazonaws.cloudfront#NoSuchDistribution":
      response = {
        ...(await deserializeAws_restXmlNoSuchDistributionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message: parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlGetDistributionConfigCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetDistributionConfigCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlGetDistributionConfigCommandError(output, context);
  }
  const contents: GetDistributionConfigCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetDistributionConfigResult",
    DistributionConfig: undefined,
    ETag: undefined,
  };
  if (output.headers["etag"] !== undefined) {
    contents.ETag = output.headers["etag"];
  }
  const data: any = await parseBody(output.body, context);
  contents.DistributionConfig = deserializeAws_restXmlDistributionConfig(data, context);
  return Promise.resolve(contents);
};

const deserializeAws_restXmlGetDistributionConfigCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetDistributionConfigCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDenied":
    case "com.amazonaws.cloudfront#AccessDenied":
      response = {
        ...(await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NoSuchDistribution":
    case "com.amazonaws.cloudfront#NoSuchDistribution":
      response = {
        ...(await deserializeAws_restXmlNoSuchDistributionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message: parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlGetFieldLevelEncryptionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetFieldLevelEncryptionCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlGetFieldLevelEncryptionCommandError(output, context);
  }
  const contents: GetFieldLevelEncryptionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetFieldLevelEncryptionResult",
    ETag: undefined,
    FieldLevelEncryption: undefined,
  };
  if (output.headers["etag"] !== undefined) {
    contents.ETag = output.headers["etag"];
  }
  const data: any = await parseBody(output.body, context);
  contents.FieldLevelEncryption = deserializeAws_restXmlFieldLevelEncryption(data, context);
  return Promise.resolve(contents);
};

const deserializeAws_restXmlGetFieldLevelEncryptionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetFieldLevelEncryptionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDenied":
    case "com.amazonaws.cloudfront#AccessDenied":
      response = {
        ...(await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NoSuchFieldLevelEncryptionConfig":
    case "com.amazonaws.cloudfront#NoSuchFieldLevelEncryptionConfig":
      response = {
        ...(await deserializeAws_restXmlNoSuchFieldLevelEncryptionConfigResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message: parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlGetFieldLevelEncryptionConfigCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetFieldLevelEncryptionConfigCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlGetFieldLevelEncryptionConfigCommandError(output, context);
  }
  const contents: GetFieldLevelEncryptionConfigCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetFieldLevelEncryptionConfigResult",
    ETag: undefined,
    FieldLevelEncryptionConfig: undefined,
  };
  if (output.headers["etag"] !== undefined) {
    contents.ETag = output.headers["etag"];
  }
  const data: any = await parseBody(output.body, context);
  contents.FieldLevelEncryptionConfig = deserializeAws_restXmlFieldLevelEncryptionConfig(data, context);
  return Promise.resolve(contents);
};

const deserializeAws_restXmlGetFieldLevelEncryptionConfigCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetFieldLevelEncryptionConfigCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDenied":
    case "com.amazonaws.cloudfront#AccessDenied":
      response = {
        ...(await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NoSuchFieldLevelEncryptionConfig":
    case "com.amazonaws.cloudfront#NoSuchFieldLevelEncryptionConfig":
      response = {
        ...(await deserializeAws_restXmlNoSuchFieldLevelEncryptionConfigResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message: parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlGetFieldLevelEncryptionProfileCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetFieldLevelEncryptionProfileCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlGetFieldLevelEncryptionProfileCommandError(output, context);
  }
  const contents: GetFieldLevelEncryptionProfileCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetFieldLevelEncryptionProfileResult",
    ETag: undefined,
    FieldLevelEncryptionProfile: undefined,
  };
  if (output.headers["etag"] !== undefined) {
    contents.ETag = output.headers["etag"];
  }
  const data: any = await parseBody(output.body, context);
  contents.FieldLevelEncryptionProfile = deserializeAws_restXmlFieldLevelEncryptionProfile(data, context);
  return Promise.resolve(contents);
};

const deserializeAws_restXmlGetFieldLevelEncryptionProfileCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetFieldLevelEncryptionProfileCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDenied":
    case "com.amazonaws.cloudfront#AccessDenied":
      response = {
        ...(await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NoSuchFieldLevelEncryptionProfile":
    case "com.amazonaws.cloudfront#NoSuchFieldLevelEncryptionProfile":
      response = {
        ...(await deserializeAws_restXmlNoSuchFieldLevelEncryptionProfileResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message: parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlGetFieldLevelEncryptionProfileConfigCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetFieldLevelEncryptionProfileConfigCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlGetFieldLevelEncryptionProfileConfigCommandError(output, context);
  }
  const contents: GetFieldLevelEncryptionProfileConfigCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetFieldLevelEncryptionProfileConfigResult",
    ETag: undefined,
    FieldLevelEncryptionProfileConfig: undefined,
  };
  if (output.headers["etag"] !== undefined) {
    contents.ETag = output.headers["etag"];
  }
  const data: any = await parseBody(output.body, context);
  contents.FieldLevelEncryptionProfileConfig = deserializeAws_restXmlFieldLevelEncryptionProfileConfig(data, context);
  return Promise.resolve(contents);
};

const deserializeAws_restXmlGetFieldLevelEncryptionProfileConfigCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetFieldLevelEncryptionProfileConfigCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDenied":
    case "com.amazonaws.cloudfront#AccessDenied":
      response = {
        ...(await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NoSuchFieldLevelEncryptionProfile":
    case "com.amazonaws.cloudfront#NoSuchFieldLevelEncryptionProfile":
      response = {
        ...(await deserializeAws_restXmlNoSuchFieldLevelEncryptionProfileResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message: parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlGetInvalidationCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetInvalidationCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlGetInvalidationCommandError(output, context);
  }
  const contents: GetInvalidationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetInvalidationResult",
    Invalidation: undefined,
  };
  const data: any = await parseBody(output.body, context);
  contents.Invalidation = deserializeAws_restXmlInvalidation(data, context);
  return Promise.resolve(contents);
};

const deserializeAws_restXmlGetInvalidationCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetInvalidationCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDenied":
    case "com.amazonaws.cloudfront#AccessDenied":
      response = {
        ...(await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NoSuchDistribution":
    case "com.amazonaws.cloudfront#NoSuchDistribution":
      response = {
        ...(await deserializeAws_restXmlNoSuchDistributionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NoSuchInvalidation":
    case "com.amazonaws.cloudfront#NoSuchInvalidation":
      response = {
        ...(await deserializeAws_restXmlNoSuchInvalidationResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message: parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlGetPublicKeyCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetPublicKeyCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlGetPublicKeyCommandError(output, context);
  }
  const contents: GetPublicKeyCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetPublicKeyResult",
    ETag: undefined,
    PublicKey: undefined,
  };
  if (output.headers["etag"] !== undefined) {
    contents.ETag = output.headers["etag"];
  }
  const data: any = await parseBody(output.body, context);
  contents.PublicKey = deserializeAws_restXmlPublicKey(data, context);
  return Promise.resolve(contents);
};

const deserializeAws_restXmlGetPublicKeyCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetPublicKeyCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDenied":
    case "com.amazonaws.cloudfront#AccessDenied":
      response = {
        ...(await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NoSuchPublicKey":
    case "com.amazonaws.cloudfront#NoSuchPublicKey":
      response = {
        ...(await deserializeAws_restXmlNoSuchPublicKeyResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message: parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlGetPublicKeyConfigCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetPublicKeyConfigCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlGetPublicKeyConfigCommandError(output, context);
  }
  const contents: GetPublicKeyConfigCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetPublicKeyConfigResult",
    ETag: undefined,
    PublicKeyConfig: undefined,
  };
  if (output.headers["etag"] !== undefined) {
    contents.ETag = output.headers["etag"];
  }
  const data: any = await parseBody(output.body, context);
  contents.PublicKeyConfig = deserializeAws_restXmlPublicKeyConfig(data, context);
  return Promise.resolve(contents);
};

const deserializeAws_restXmlGetPublicKeyConfigCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetPublicKeyConfigCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDenied":
    case "com.amazonaws.cloudfront#AccessDenied":
      response = {
        ...(await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NoSuchPublicKey":
    case "com.amazonaws.cloudfront#NoSuchPublicKey":
      response = {
        ...(await deserializeAws_restXmlNoSuchPublicKeyResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message: parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlGetStreamingDistributionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetStreamingDistributionCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlGetStreamingDistributionCommandError(output, context);
  }
  const contents: GetStreamingDistributionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetStreamingDistributionResult",
    ETag: undefined,
    StreamingDistribution: undefined,
  };
  if (output.headers["etag"] !== undefined) {
    contents.ETag = output.headers["etag"];
  }
  const data: any = await parseBody(output.body, context);
  contents.StreamingDistribution = deserializeAws_restXmlStreamingDistribution(data, context);
  return Promise.resolve(contents);
};

const deserializeAws_restXmlGetStreamingDistributionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetStreamingDistributionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDenied":
    case "com.amazonaws.cloudfront#AccessDenied":
      response = {
        ...(await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NoSuchStreamingDistribution":
    case "com.amazonaws.cloudfront#NoSuchStreamingDistribution":
      response = {
        ...(await deserializeAws_restXmlNoSuchStreamingDistributionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message: parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlGetStreamingDistributionConfigCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetStreamingDistributionConfigCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlGetStreamingDistributionConfigCommandError(output, context);
  }
  const contents: GetStreamingDistributionConfigCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetStreamingDistributionConfigResult",
    ETag: undefined,
    StreamingDistributionConfig: undefined,
  };
  if (output.headers["etag"] !== undefined) {
    contents.ETag = output.headers["etag"];
  }
  const data: any = await parseBody(output.body, context);
  contents.StreamingDistributionConfig = deserializeAws_restXmlStreamingDistributionConfig(data, context);
  return Promise.resolve(contents);
};

const deserializeAws_restXmlGetStreamingDistributionConfigCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetStreamingDistributionConfigCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDenied":
    case "com.amazonaws.cloudfront#AccessDenied":
      response = {
        ...(await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NoSuchStreamingDistribution":
    case "com.amazonaws.cloudfront#NoSuchStreamingDistribution":
      response = {
        ...(await deserializeAws_restXmlNoSuchStreamingDistributionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message: parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlListCloudFrontOriginAccessIdentitiesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListCloudFrontOriginAccessIdentitiesCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlListCloudFrontOriginAccessIdentitiesCommandError(output, context);
  }
  const contents: ListCloudFrontOriginAccessIdentitiesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListCloudFrontOriginAccessIdentitiesResult",
    CloudFrontOriginAccessIdentityList: undefined,
  };
  const data: any = await parseBody(output.body, context);
  contents.CloudFrontOriginAccessIdentityList = deserializeAws_restXmlCloudFrontOriginAccessIdentityList(data, context);
  return Promise.resolve(contents);
};

const deserializeAws_restXmlListCloudFrontOriginAccessIdentitiesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListCloudFrontOriginAccessIdentitiesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidArgument":
    case "com.amazonaws.cloudfront#InvalidArgument":
      response = {
        ...(await deserializeAws_restXmlInvalidArgumentResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message: parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlListDistributionsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListDistributionsCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlListDistributionsCommandError(output, context);
  }
  const contents: ListDistributionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListDistributionsResult",
    DistributionList: undefined,
  };
  const data: any = await parseBody(output.body, context);
  contents.DistributionList = deserializeAws_restXmlDistributionList(data, context);
  return Promise.resolve(contents);
};

const deserializeAws_restXmlListDistributionsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListDistributionsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidArgument":
    case "com.amazonaws.cloudfront#InvalidArgument":
      response = {
        ...(await deserializeAws_restXmlInvalidArgumentResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message: parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlListDistributionsByWebACLIdCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListDistributionsByWebACLIdCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlListDistributionsByWebACLIdCommandError(output, context);
  }
  const contents: ListDistributionsByWebACLIdCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListDistributionsByWebACLIdResult",
    DistributionList: undefined,
  };
  const data: any = await parseBody(output.body, context);
  contents.DistributionList = deserializeAws_restXmlDistributionList(data, context);
  return Promise.resolve(contents);
};

const deserializeAws_restXmlListDistributionsByWebACLIdCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListDistributionsByWebACLIdCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidArgument":
    case "com.amazonaws.cloudfront#InvalidArgument":
      response = {
        ...(await deserializeAws_restXmlInvalidArgumentResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidWebACLId":
    case "com.amazonaws.cloudfront#InvalidWebACLId":
      response = {
        ...(await deserializeAws_restXmlInvalidWebACLIdResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message: parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlListFieldLevelEncryptionConfigsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListFieldLevelEncryptionConfigsCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlListFieldLevelEncryptionConfigsCommandError(output, context);
  }
  const contents: ListFieldLevelEncryptionConfigsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListFieldLevelEncryptionConfigsResult",
    FieldLevelEncryptionList: undefined,
  };
  const data: any = await parseBody(output.body, context);
  contents.FieldLevelEncryptionList = deserializeAws_restXmlFieldLevelEncryptionList(data, context);
  return Promise.resolve(contents);
};

const deserializeAws_restXmlListFieldLevelEncryptionConfigsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListFieldLevelEncryptionConfigsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidArgument":
    case "com.amazonaws.cloudfront#InvalidArgument":
      response = {
        ...(await deserializeAws_restXmlInvalidArgumentResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message: parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlListFieldLevelEncryptionProfilesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListFieldLevelEncryptionProfilesCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlListFieldLevelEncryptionProfilesCommandError(output, context);
  }
  const contents: ListFieldLevelEncryptionProfilesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListFieldLevelEncryptionProfilesResult",
    FieldLevelEncryptionProfileList: undefined,
  };
  const data: any = await parseBody(output.body, context);
  contents.FieldLevelEncryptionProfileList = deserializeAws_restXmlFieldLevelEncryptionProfileList(data, context);
  return Promise.resolve(contents);
};

const deserializeAws_restXmlListFieldLevelEncryptionProfilesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListFieldLevelEncryptionProfilesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidArgument":
    case "com.amazonaws.cloudfront#InvalidArgument":
      response = {
        ...(await deserializeAws_restXmlInvalidArgumentResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message: parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlListInvalidationsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListInvalidationsCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlListInvalidationsCommandError(output, context);
  }
  const contents: ListInvalidationsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListInvalidationsResult",
    InvalidationList: undefined,
  };
  const data: any = await parseBody(output.body, context);
  contents.InvalidationList = deserializeAws_restXmlInvalidationList(data, context);
  return Promise.resolve(contents);
};

const deserializeAws_restXmlListInvalidationsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListInvalidationsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDenied":
    case "com.amazonaws.cloudfront#AccessDenied":
      response = {
        ...(await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidArgument":
    case "com.amazonaws.cloudfront#InvalidArgument":
      response = {
        ...(await deserializeAws_restXmlInvalidArgumentResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NoSuchDistribution":
    case "com.amazonaws.cloudfront#NoSuchDistribution":
      response = {
        ...(await deserializeAws_restXmlNoSuchDistributionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message: parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlListPublicKeysCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListPublicKeysCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlListPublicKeysCommandError(output, context);
  }
  const contents: ListPublicKeysCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListPublicKeysResult",
    PublicKeyList: undefined,
  };
  const data: any = await parseBody(output.body, context);
  contents.PublicKeyList = deserializeAws_restXmlPublicKeyList(data, context);
  return Promise.resolve(contents);
};

const deserializeAws_restXmlListPublicKeysCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListPublicKeysCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidArgument":
    case "com.amazonaws.cloudfront#InvalidArgument":
      response = {
        ...(await deserializeAws_restXmlInvalidArgumentResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message: parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlListStreamingDistributionsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListStreamingDistributionsCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlListStreamingDistributionsCommandError(output, context);
  }
  const contents: ListStreamingDistributionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListStreamingDistributionsResult",
    StreamingDistributionList: undefined,
  };
  const data: any = await parseBody(output.body, context);
  contents.StreamingDistributionList = deserializeAws_restXmlStreamingDistributionList(data, context);
  return Promise.resolve(contents);
};

const deserializeAws_restXmlListStreamingDistributionsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListStreamingDistributionsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidArgument":
    case "com.amazonaws.cloudfront#InvalidArgument":
      response = {
        ...(await deserializeAws_restXmlInvalidArgumentResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message: parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlListTagsForResourceCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTagsForResourceCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlListTagsForResourceCommandError(output, context);
  }
  const contents: ListTagsForResourceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListTagsForResourceResult",
    Tags: undefined,
  };
  const data: any = await parseBody(output.body, context);
  contents.Tags = deserializeAws_restXmlTags(data, context);
  return Promise.resolve(contents);
};

const deserializeAws_restXmlListTagsForResourceCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTagsForResourceCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDenied":
    case "com.amazonaws.cloudfront#AccessDenied":
      response = {
        ...(await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidArgument":
    case "com.amazonaws.cloudfront#InvalidArgument":
      response = {
        ...(await deserializeAws_restXmlInvalidArgumentResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidTagging":
    case "com.amazonaws.cloudfront#InvalidTagging":
      response = {
        ...(await deserializeAws_restXmlInvalidTaggingResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NoSuchResource":
    case "com.amazonaws.cloudfront#NoSuchResource":
      response = {
        ...(await deserializeAws_restXmlNoSuchResourceResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message: parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlTagResourceCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<TagResourceCommandOutput> => {
  if (output.statusCode !== 204 && output.statusCode >= 400) {
    return deserializeAws_restXmlTagResourceCommandError(output, context);
  }
  const contents: TagResourceCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restXmlTagResourceCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<TagResourceCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDenied":
    case "com.amazonaws.cloudfront#AccessDenied":
      response = {
        ...(await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidArgument":
    case "com.amazonaws.cloudfront#InvalidArgument":
      response = {
        ...(await deserializeAws_restXmlInvalidArgumentResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidTagging":
    case "com.amazonaws.cloudfront#InvalidTagging":
      response = {
        ...(await deserializeAws_restXmlInvalidTaggingResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NoSuchResource":
    case "com.amazonaws.cloudfront#NoSuchResource":
      response = {
        ...(await deserializeAws_restXmlNoSuchResourceResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message: parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlUntagResourceCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UntagResourceCommandOutput> => {
  if (output.statusCode !== 204 && output.statusCode >= 400) {
    return deserializeAws_restXmlUntagResourceCommandError(output, context);
  }
  const contents: UntagResourceCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restXmlUntagResourceCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UntagResourceCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDenied":
    case "com.amazonaws.cloudfront#AccessDenied":
      response = {
        ...(await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidArgument":
    case "com.amazonaws.cloudfront#InvalidArgument":
      response = {
        ...(await deserializeAws_restXmlInvalidArgumentResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidTagging":
    case "com.amazonaws.cloudfront#InvalidTagging":
      response = {
        ...(await deserializeAws_restXmlInvalidTaggingResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NoSuchResource":
    case "com.amazonaws.cloudfront#NoSuchResource":
      response = {
        ...(await deserializeAws_restXmlNoSuchResourceResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message: parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlUpdateCloudFrontOriginAccessIdentityCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateCloudFrontOriginAccessIdentityCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlUpdateCloudFrontOriginAccessIdentityCommandError(output, context);
  }
  const contents: UpdateCloudFrontOriginAccessIdentityCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateCloudFrontOriginAccessIdentityResult",
    CloudFrontOriginAccessIdentity: undefined,
    ETag: undefined,
  };
  if (output.headers["etag"] !== undefined) {
    contents.ETag = output.headers["etag"];
  }
  const data: any = await parseBody(output.body, context);
  contents.CloudFrontOriginAccessIdentity = deserializeAws_restXmlCloudFrontOriginAccessIdentity(data, context);
  return Promise.resolve(contents);
};

const deserializeAws_restXmlUpdateCloudFrontOriginAccessIdentityCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateCloudFrontOriginAccessIdentityCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDenied":
    case "com.amazonaws.cloudfront#AccessDenied":
      response = {
        ...(await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "IllegalUpdate":
    case "com.amazonaws.cloudfront#IllegalUpdate":
      response = {
        ...(await deserializeAws_restXmlIllegalUpdateResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InconsistentQuantities":
    case "com.amazonaws.cloudfront#InconsistentQuantities":
      response = {
        ...(await deserializeAws_restXmlInconsistentQuantitiesResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidArgument":
    case "com.amazonaws.cloudfront#InvalidArgument":
      response = {
        ...(await deserializeAws_restXmlInvalidArgumentResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidIfMatchVersion":
    case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
      response = {
        ...(await deserializeAws_restXmlInvalidIfMatchVersionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "MissingBody":
    case "com.amazonaws.cloudfront#MissingBody":
      response = {
        ...(await deserializeAws_restXmlMissingBodyResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NoSuchCloudFrontOriginAccessIdentity":
    case "com.amazonaws.cloudfront#NoSuchCloudFrontOriginAccessIdentity":
      response = {
        ...(await deserializeAws_restXmlNoSuchCloudFrontOriginAccessIdentityResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "PreconditionFailed":
    case "com.amazonaws.cloudfront#PreconditionFailed":
      response = {
        ...(await deserializeAws_restXmlPreconditionFailedResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message: parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlUpdateDistributionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateDistributionCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlUpdateDistributionCommandError(output, context);
  }
  const contents: UpdateDistributionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateDistributionResult",
    Distribution: undefined,
    ETag: undefined,
  };
  if (output.headers["etag"] !== undefined) {
    contents.ETag = output.headers["etag"];
  }
  const data: any = await parseBody(output.body, context);
  contents.Distribution = deserializeAws_restXmlDistribution(data, context);
  return Promise.resolve(contents);
};

const deserializeAws_restXmlUpdateDistributionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateDistributionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDenied":
    case "com.amazonaws.cloudfront#AccessDenied":
      response = {
        ...(await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "CNAMEAlreadyExists":
    case "com.amazonaws.cloudfront#CNAMEAlreadyExists":
      response = {
        ...(await deserializeAws_restXmlCNAMEAlreadyExistsResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior":
    case "com.amazonaws.cloudfront#IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior":
      response = {
        ...(await deserializeAws_restXmlIllegalFieldLevelEncryptionConfigAssociationWithCacheBehaviorResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "IllegalUpdate":
    case "com.amazonaws.cloudfront#IllegalUpdate":
      response = {
        ...(await deserializeAws_restXmlIllegalUpdateResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InconsistentQuantities":
    case "com.amazonaws.cloudfront#InconsistentQuantities":
      response = {
        ...(await deserializeAws_restXmlInconsistentQuantitiesResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidArgument":
    case "com.amazonaws.cloudfront#InvalidArgument":
      response = {
        ...(await deserializeAws_restXmlInvalidArgumentResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidDefaultRootObject":
    case "com.amazonaws.cloudfront#InvalidDefaultRootObject":
      response = {
        ...(await deserializeAws_restXmlInvalidDefaultRootObjectResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidErrorCode":
    case "com.amazonaws.cloudfront#InvalidErrorCode":
      response = {
        ...(await deserializeAws_restXmlInvalidErrorCodeResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidForwardCookies":
    case "com.amazonaws.cloudfront#InvalidForwardCookies":
      response = {
        ...(await deserializeAws_restXmlInvalidForwardCookiesResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidGeoRestrictionParameter":
    case "com.amazonaws.cloudfront#InvalidGeoRestrictionParameter":
      response = {
        ...(await deserializeAws_restXmlInvalidGeoRestrictionParameterResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidHeadersForS3Origin":
    case "com.amazonaws.cloudfront#InvalidHeadersForS3Origin":
      response = {
        ...(await deserializeAws_restXmlInvalidHeadersForS3OriginResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidIfMatchVersion":
    case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
      response = {
        ...(await deserializeAws_restXmlInvalidIfMatchVersionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidLambdaFunctionAssociation":
    case "com.amazonaws.cloudfront#InvalidLambdaFunctionAssociation":
      response = {
        ...(await deserializeAws_restXmlInvalidLambdaFunctionAssociationResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidLocationCode":
    case "com.amazonaws.cloudfront#InvalidLocationCode":
      response = {
        ...(await deserializeAws_restXmlInvalidLocationCodeResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidMinimumProtocolVersion":
    case "com.amazonaws.cloudfront#InvalidMinimumProtocolVersion":
      response = {
        ...(await deserializeAws_restXmlInvalidMinimumProtocolVersionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidOriginAccessIdentity":
    case "com.amazonaws.cloudfront#InvalidOriginAccessIdentity":
      response = {
        ...(await deserializeAws_restXmlInvalidOriginAccessIdentityResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidOriginKeepaliveTimeout":
    case "com.amazonaws.cloudfront#InvalidOriginKeepaliveTimeout":
      response = {
        ...(await deserializeAws_restXmlInvalidOriginKeepaliveTimeoutResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidOriginReadTimeout":
    case "com.amazonaws.cloudfront#InvalidOriginReadTimeout":
      response = {
        ...(await deserializeAws_restXmlInvalidOriginReadTimeoutResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidQueryStringParameters":
    case "com.amazonaws.cloudfront#InvalidQueryStringParameters":
      response = {
        ...(await deserializeAws_restXmlInvalidQueryStringParametersResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRelativePath":
    case "com.amazonaws.cloudfront#InvalidRelativePath":
      response = {
        ...(await deserializeAws_restXmlInvalidRelativePathResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequiredProtocol":
    case "com.amazonaws.cloudfront#InvalidRequiredProtocol":
      response = {
        ...(await deserializeAws_restXmlInvalidRequiredProtocolResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidResponseCode":
    case "com.amazonaws.cloudfront#InvalidResponseCode":
      response = {
        ...(await deserializeAws_restXmlInvalidResponseCodeResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidTTLOrder":
    case "com.amazonaws.cloudfront#InvalidTTLOrder":
      response = {
        ...(await deserializeAws_restXmlInvalidTTLOrderResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidViewerCertificate":
    case "com.amazonaws.cloudfront#InvalidViewerCertificate":
      response = {
        ...(await deserializeAws_restXmlInvalidViewerCertificateResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidWebACLId":
    case "com.amazonaws.cloudfront#InvalidWebACLId":
      response = {
        ...(await deserializeAws_restXmlInvalidWebACLIdResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "MissingBody":
    case "com.amazonaws.cloudfront#MissingBody":
      response = {
        ...(await deserializeAws_restXmlMissingBodyResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NoSuchDistribution":
    case "com.amazonaws.cloudfront#NoSuchDistribution":
      response = {
        ...(await deserializeAws_restXmlNoSuchDistributionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NoSuchFieldLevelEncryptionConfig":
    case "com.amazonaws.cloudfront#NoSuchFieldLevelEncryptionConfig":
      response = {
        ...(await deserializeAws_restXmlNoSuchFieldLevelEncryptionConfigResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NoSuchOrigin":
    case "com.amazonaws.cloudfront#NoSuchOrigin":
      response = {
        ...(await deserializeAws_restXmlNoSuchOriginResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "PreconditionFailed":
    case "com.amazonaws.cloudfront#PreconditionFailed":
      response = {
        ...(await deserializeAws_restXmlPreconditionFailedResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "TooManyCacheBehaviors":
    case "com.amazonaws.cloudfront#TooManyCacheBehaviors":
      response = {
        ...(await deserializeAws_restXmlTooManyCacheBehaviorsResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "TooManyCertificates":
    case "com.amazonaws.cloudfront#TooManyCertificates":
      response = {
        ...(await deserializeAws_restXmlTooManyCertificatesResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "TooManyCookieNamesInWhiteList":
    case "com.amazonaws.cloudfront#TooManyCookieNamesInWhiteList":
      response = {
        ...(await deserializeAws_restXmlTooManyCookieNamesInWhiteListResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "TooManyDistributionCNAMEs":
    case "com.amazonaws.cloudfront#TooManyDistributionCNAMEs":
      response = {
        ...(await deserializeAws_restXmlTooManyDistributionCNAMEsResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "TooManyDistributionsAssociatedToFieldLevelEncryptionConfig":
    case "com.amazonaws.cloudfront#TooManyDistributionsAssociatedToFieldLevelEncryptionConfig":
      response = {
        ...(await deserializeAws_restXmlTooManyDistributionsAssociatedToFieldLevelEncryptionConfigResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "TooManyDistributionsWithLambdaAssociations":
    case "com.amazonaws.cloudfront#TooManyDistributionsWithLambdaAssociations":
      response = {
        ...(await deserializeAws_restXmlTooManyDistributionsWithLambdaAssociationsResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "TooManyHeadersInForwardedValues":
    case "com.amazonaws.cloudfront#TooManyHeadersInForwardedValues":
      response = {
        ...(await deserializeAws_restXmlTooManyHeadersInForwardedValuesResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "TooManyLambdaFunctionAssociations":
    case "com.amazonaws.cloudfront#TooManyLambdaFunctionAssociations":
      response = {
        ...(await deserializeAws_restXmlTooManyLambdaFunctionAssociationsResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "TooManyOriginCustomHeaders":
    case "com.amazonaws.cloudfront#TooManyOriginCustomHeaders":
      response = {
        ...(await deserializeAws_restXmlTooManyOriginCustomHeadersResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "TooManyOriginGroupsPerDistribution":
    case "com.amazonaws.cloudfront#TooManyOriginGroupsPerDistribution":
      response = {
        ...(await deserializeAws_restXmlTooManyOriginGroupsPerDistributionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "TooManyOrigins":
    case "com.amazonaws.cloudfront#TooManyOrigins":
      response = {
        ...(await deserializeAws_restXmlTooManyOriginsResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "TooManyQueryStringParameters":
    case "com.amazonaws.cloudfront#TooManyQueryStringParameters":
      response = {
        ...(await deserializeAws_restXmlTooManyQueryStringParametersResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "TooManyTrustedSigners":
    case "com.amazonaws.cloudfront#TooManyTrustedSigners":
      response = {
        ...(await deserializeAws_restXmlTooManyTrustedSignersResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "TrustedSignerDoesNotExist":
    case "com.amazonaws.cloudfront#TrustedSignerDoesNotExist":
      response = {
        ...(await deserializeAws_restXmlTrustedSignerDoesNotExistResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message: parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlUpdateFieldLevelEncryptionConfigCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateFieldLevelEncryptionConfigCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlUpdateFieldLevelEncryptionConfigCommandError(output, context);
  }
  const contents: UpdateFieldLevelEncryptionConfigCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateFieldLevelEncryptionConfigResult",
    ETag: undefined,
    FieldLevelEncryption: undefined,
  };
  if (output.headers["etag"] !== undefined) {
    contents.ETag = output.headers["etag"];
  }
  const data: any = await parseBody(output.body, context);
  contents.FieldLevelEncryption = deserializeAws_restXmlFieldLevelEncryption(data, context);
  return Promise.resolve(contents);
};

const deserializeAws_restXmlUpdateFieldLevelEncryptionConfigCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateFieldLevelEncryptionConfigCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDenied":
    case "com.amazonaws.cloudfront#AccessDenied":
      response = {
        ...(await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "IllegalUpdate":
    case "com.amazonaws.cloudfront#IllegalUpdate":
      response = {
        ...(await deserializeAws_restXmlIllegalUpdateResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InconsistentQuantities":
    case "com.amazonaws.cloudfront#InconsistentQuantities":
      response = {
        ...(await deserializeAws_restXmlInconsistentQuantitiesResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidArgument":
    case "com.amazonaws.cloudfront#InvalidArgument":
      response = {
        ...(await deserializeAws_restXmlInvalidArgumentResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidIfMatchVersion":
    case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
      response = {
        ...(await deserializeAws_restXmlInvalidIfMatchVersionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NoSuchFieldLevelEncryptionConfig":
    case "com.amazonaws.cloudfront#NoSuchFieldLevelEncryptionConfig":
      response = {
        ...(await deserializeAws_restXmlNoSuchFieldLevelEncryptionConfigResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NoSuchFieldLevelEncryptionProfile":
    case "com.amazonaws.cloudfront#NoSuchFieldLevelEncryptionProfile":
      response = {
        ...(await deserializeAws_restXmlNoSuchFieldLevelEncryptionProfileResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "PreconditionFailed":
    case "com.amazonaws.cloudfront#PreconditionFailed":
      response = {
        ...(await deserializeAws_restXmlPreconditionFailedResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "QueryArgProfileEmpty":
    case "com.amazonaws.cloudfront#QueryArgProfileEmpty":
      response = {
        ...(await deserializeAws_restXmlQueryArgProfileEmptyResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "TooManyFieldLevelEncryptionContentTypeProfiles":
    case "com.amazonaws.cloudfront#TooManyFieldLevelEncryptionContentTypeProfiles":
      response = {
        ...(await deserializeAws_restXmlTooManyFieldLevelEncryptionContentTypeProfilesResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "TooManyFieldLevelEncryptionQueryArgProfiles":
    case "com.amazonaws.cloudfront#TooManyFieldLevelEncryptionQueryArgProfiles":
      response = {
        ...(await deserializeAws_restXmlTooManyFieldLevelEncryptionQueryArgProfilesResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message: parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlUpdateFieldLevelEncryptionProfileCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateFieldLevelEncryptionProfileCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlUpdateFieldLevelEncryptionProfileCommandError(output, context);
  }
  const contents: UpdateFieldLevelEncryptionProfileCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateFieldLevelEncryptionProfileResult",
    ETag: undefined,
    FieldLevelEncryptionProfile: undefined,
  };
  if (output.headers["etag"] !== undefined) {
    contents.ETag = output.headers["etag"];
  }
  const data: any = await parseBody(output.body, context);
  contents.FieldLevelEncryptionProfile = deserializeAws_restXmlFieldLevelEncryptionProfile(data, context);
  return Promise.resolve(contents);
};

const deserializeAws_restXmlUpdateFieldLevelEncryptionProfileCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateFieldLevelEncryptionProfileCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDenied":
    case "com.amazonaws.cloudfront#AccessDenied":
      response = {
        ...(await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "FieldLevelEncryptionProfileAlreadyExists":
    case "com.amazonaws.cloudfront#FieldLevelEncryptionProfileAlreadyExists":
      response = {
        ...(await deserializeAws_restXmlFieldLevelEncryptionProfileAlreadyExistsResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "FieldLevelEncryptionProfileSizeExceeded":
    case "com.amazonaws.cloudfront#FieldLevelEncryptionProfileSizeExceeded":
      response = {
        ...(await deserializeAws_restXmlFieldLevelEncryptionProfileSizeExceededResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "IllegalUpdate":
    case "com.amazonaws.cloudfront#IllegalUpdate":
      response = {
        ...(await deserializeAws_restXmlIllegalUpdateResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InconsistentQuantities":
    case "com.amazonaws.cloudfront#InconsistentQuantities":
      response = {
        ...(await deserializeAws_restXmlInconsistentQuantitiesResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidArgument":
    case "com.amazonaws.cloudfront#InvalidArgument":
      response = {
        ...(await deserializeAws_restXmlInvalidArgumentResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidIfMatchVersion":
    case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
      response = {
        ...(await deserializeAws_restXmlInvalidIfMatchVersionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NoSuchFieldLevelEncryptionProfile":
    case "com.amazonaws.cloudfront#NoSuchFieldLevelEncryptionProfile":
      response = {
        ...(await deserializeAws_restXmlNoSuchFieldLevelEncryptionProfileResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NoSuchPublicKey":
    case "com.amazonaws.cloudfront#NoSuchPublicKey":
      response = {
        ...(await deserializeAws_restXmlNoSuchPublicKeyResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "PreconditionFailed":
    case "com.amazonaws.cloudfront#PreconditionFailed":
      response = {
        ...(await deserializeAws_restXmlPreconditionFailedResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "TooManyFieldLevelEncryptionEncryptionEntities":
    case "com.amazonaws.cloudfront#TooManyFieldLevelEncryptionEncryptionEntities":
      response = {
        ...(await deserializeAws_restXmlTooManyFieldLevelEncryptionEncryptionEntitiesResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "TooManyFieldLevelEncryptionFieldPatterns":
    case "com.amazonaws.cloudfront#TooManyFieldLevelEncryptionFieldPatterns":
      response = {
        ...(await deserializeAws_restXmlTooManyFieldLevelEncryptionFieldPatternsResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message: parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlUpdatePublicKeyCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdatePublicKeyCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlUpdatePublicKeyCommandError(output, context);
  }
  const contents: UpdatePublicKeyCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdatePublicKeyResult",
    ETag: undefined,
    PublicKey: undefined,
  };
  if (output.headers["etag"] !== undefined) {
    contents.ETag = output.headers["etag"];
  }
  const data: any = await parseBody(output.body, context);
  contents.PublicKey = deserializeAws_restXmlPublicKey(data, context);
  return Promise.resolve(contents);
};

const deserializeAws_restXmlUpdatePublicKeyCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdatePublicKeyCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDenied":
    case "com.amazonaws.cloudfront#AccessDenied":
      response = {
        ...(await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "CannotChangeImmutablePublicKeyFields":
    case "com.amazonaws.cloudfront#CannotChangeImmutablePublicKeyFields":
      response = {
        ...(await deserializeAws_restXmlCannotChangeImmutablePublicKeyFieldsResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "IllegalUpdate":
    case "com.amazonaws.cloudfront#IllegalUpdate":
      response = {
        ...(await deserializeAws_restXmlIllegalUpdateResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidArgument":
    case "com.amazonaws.cloudfront#InvalidArgument":
      response = {
        ...(await deserializeAws_restXmlInvalidArgumentResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidIfMatchVersion":
    case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
      response = {
        ...(await deserializeAws_restXmlInvalidIfMatchVersionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NoSuchPublicKey":
    case "com.amazonaws.cloudfront#NoSuchPublicKey":
      response = {
        ...(await deserializeAws_restXmlNoSuchPublicKeyResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "PreconditionFailed":
    case "com.amazonaws.cloudfront#PreconditionFailed":
      response = {
        ...(await deserializeAws_restXmlPreconditionFailedResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message: parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlUpdateStreamingDistributionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateStreamingDistributionCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlUpdateStreamingDistributionCommandError(output, context);
  }
  const contents: UpdateStreamingDistributionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateStreamingDistributionResult",
    ETag: undefined,
    StreamingDistribution: undefined,
  };
  if (output.headers["etag"] !== undefined) {
    contents.ETag = output.headers["etag"];
  }
  const data: any = await parseBody(output.body, context);
  contents.StreamingDistribution = deserializeAws_restXmlStreamingDistribution(data, context);
  return Promise.resolve(contents);
};

const deserializeAws_restXmlUpdateStreamingDistributionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateStreamingDistributionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDenied":
    case "com.amazonaws.cloudfront#AccessDenied":
      response = {
        ...(await deserializeAws_restXmlAccessDeniedResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "CNAMEAlreadyExists":
    case "com.amazonaws.cloudfront#CNAMEAlreadyExists":
      response = {
        ...(await deserializeAws_restXmlCNAMEAlreadyExistsResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "IllegalUpdate":
    case "com.amazonaws.cloudfront#IllegalUpdate":
      response = {
        ...(await deserializeAws_restXmlIllegalUpdateResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InconsistentQuantities":
    case "com.amazonaws.cloudfront#InconsistentQuantities":
      response = {
        ...(await deserializeAws_restXmlInconsistentQuantitiesResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidArgument":
    case "com.amazonaws.cloudfront#InvalidArgument":
      response = {
        ...(await deserializeAws_restXmlInvalidArgumentResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidIfMatchVersion":
    case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
      response = {
        ...(await deserializeAws_restXmlInvalidIfMatchVersionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidOriginAccessIdentity":
    case "com.amazonaws.cloudfront#InvalidOriginAccessIdentity":
      response = {
        ...(await deserializeAws_restXmlInvalidOriginAccessIdentityResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "MissingBody":
    case "com.amazonaws.cloudfront#MissingBody":
      response = {
        ...(await deserializeAws_restXmlMissingBodyResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NoSuchStreamingDistribution":
    case "com.amazonaws.cloudfront#NoSuchStreamingDistribution":
      response = {
        ...(await deserializeAws_restXmlNoSuchStreamingDistributionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "PreconditionFailed":
    case "com.amazonaws.cloudfront#PreconditionFailed":
      response = {
        ...(await deserializeAws_restXmlPreconditionFailedResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "TooManyStreamingDistributionCNAMEs":
    case "com.amazonaws.cloudfront#TooManyStreamingDistributionCNAMEs":
      response = {
        ...(await deserializeAws_restXmlTooManyStreamingDistributionCNAMEsResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "TooManyTrustedSigners":
    case "com.amazonaws.cloudfront#TooManyTrustedSigners":
      response = {
        ...(await deserializeAws_restXmlTooManyTrustedSignersResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "TrustedSignerDoesNotExist":
    case "com.amazonaws.cloudfront#TrustedSignerDoesNotExist":
      response = {
        ...(await deserializeAws_restXmlTrustedSignerDoesNotExistResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message: parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

const deserializeAws_restXmlAccessDeniedResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<AccessDenied> => {
  const contents: AccessDenied = {
    name: "AccessDenied",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined,
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlBatchTooLargeResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<BatchTooLarge> => {
  const contents: BatchTooLarge = {
    name: "BatchTooLarge",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined,
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlCannotChangeImmutablePublicKeyFieldsResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<CannotChangeImmutablePublicKeyFields> => {
  const contents: CannotChangeImmutablePublicKeyFields = {
    name: "CannotChangeImmutablePublicKeyFields",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined,
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlCloudFrontOriginAccessIdentityAlreadyExistsResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<CloudFrontOriginAccessIdentityAlreadyExists> => {
  const contents: CloudFrontOriginAccessIdentityAlreadyExists = {
    name: "CloudFrontOriginAccessIdentityAlreadyExists",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined,
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlCloudFrontOriginAccessIdentityInUseResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<CloudFrontOriginAccessIdentityInUse> => {
  const contents: CloudFrontOriginAccessIdentityInUse = {
    name: "CloudFrontOriginAccessIdentityInUse",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined,
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlCNAMEAlreadyExistsResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<CNAMEAlreadyExists> => {
  const contents: CNAMEAlreadyExists = {
    name: "CNAMEAlreadyExists",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined,
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlDistributionAlreadyExistsResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<DistributionAlreadyExists> => {
  const contents: DistributionAlreadyExists = {
    name: "DistributionAlreadyExists",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined,
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlDistributionNotDisabledResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<DistributionNotDisabled> => {
  const contents: DistributionNotDisabled = {
    name: "DistributionNotDisabled",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined,
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlFieldLevelEncryptionConfigAlreadyExistsResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<FieldLevelEncryptionConfigAlreadyExists> => {
  const contents: FieldLevelEncryptionConfigAlreadyExists = {
    name: "FieldLevelEncryptionConfigAlreadyExists",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined,
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlFieldLevelEncryptionConfigInUseResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<FieldLevelEncryptionConfigInUse> => {
  const contents: FieldLevelEncryptionConfigInUse = {
    name: "FieldLevelEncryptionConfigInUse",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined,
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlFieldLevelEncryptionProfileAlreadyExistsResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<FieldLevelEncryptionProfileAlreadyExists> => {
  const contents: FieldLevelEncryptionProfileAlreadyExists = {
    name: "FieldLevelEncryptionProfileAlreadyExists",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined,
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlFieldLevelEncryptionProfileInUseResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<FieldLevelEncryptionProfileInUse> => {
  const contents: FieldLevelEncryptionProfileInUse = {
    name: "FieldLevelEncryptionProfileInUse",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined,
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlFieldLevelEncryptionProfileSizeExceededResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<FieldLevelEncryptionProfileSizeExceeded> => {
  const contents: FieldLevelEncryptionProfileSizeExceeded = {
    name: "FieldLevelEncryptionProfileSizeExceeded",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined,
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlIllegalFieldLevelEncryptionConfigAssociationWithCacheBehaviorResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior> => {
  const contents: IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior = {
    name: "IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined,
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlIllegalUpdateResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<IllegalUpdate> => {
  const contents: IllegalUpdate = {
    name: "IllegalUpdate",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined,
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlInconsistentQuantitiesResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InconsistentQuantities> => {
  const contents: InconsistentQuantities = {
    name: "InconsistentQuantities",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined,
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlInvalidArgumentResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidArgument> => {
  const contents: InvalidArgument = {
    name: "InvalidArgument",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined,
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlInvalidDefaultRootObjectResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidDefaultRootObject> => {
  const contents: InvalidDefaultRootObject = {
    name: "InvalidDefaultRootObject",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined,
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlInvalidErrorCodeResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidErrorCode> => {
  const contents: InvalidErrorCode = {
    name: "InvalidErrorCode",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined,
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlInvalidForwardCookiesResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidForwardCookies> => {
  const contents: InvalidForwardCookies = {
    name: "InvalidForwardCookies",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined,
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlInvalidGeoRestrictionParameterResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidGeoRestrictionParameter> => {
  const contents: InvalidGeoRestrictionParameter = {
    name: "InvalidGeoRestrictionParameter",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined,
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlInvalidHeadersForS3OriginResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidHeadersForS3Origin> => {
  const contents: InvalidHeadersForS3Origin = {
    name: "InvalidHeadersForS3Origin",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined,
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlInvalidIfMatchVersionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidIfMatchVersion> => {
  const contents: InvalidIfMatchVersion = {
    name: "InvalidIfMatchVersion",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined,
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlInvalidLambdaFunctionAssociationResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidLambdaFunctionAssociation> => {
  const contents: InvalidLambdaFunctionAssociation = {
    name: "InvalidLambdaFunctionAssociation",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined,
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlInvalidLocationCodeResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidLocationCode> => {
  const contents: InvalidLocationCode = {
    name: "InvalidLocationCode",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined,
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlInvalidMinimumProtocolVersionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidMinimumProtocolVersion> => {
  const contents: InvalidMinimumProtocolVersion = {
    name: "InvalidMinimumProtocolVersion",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined,
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlInvalidOriginResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidOrigin> => {
  const contents: InvalidOrigin = {
    name: "InvalidOrigin",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined,
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlInvalidOriginAccessIdentityResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidOriginAccessIdentity> => {
  const contents: InvalidOriginAccessIdentity = {
    name: "InvalidOriginAccessIdentity",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined,
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlInvalidOriginKeepaliveTimeoutResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidOriginKeepaliveTimeout> => {
  const contents: InvalidOriginKeepaliveTimeout = {
    name: "InvalidOriginKeepaliveTimeout",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined,
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlInvalidOriginReadTimeoutResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidOriginReadTimeout> => {
  const contents: InvalidOriginReadTimeout = {
    name: "InvalidOriginReadTimeout",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined,
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlInvalidProtocolSettingsResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidProtocolSettings> => {
  const contents: InvalidProtocolSettings = {
    name: "InvalidProtocolSettings",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined,
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlInvalidQueryStringParametersResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidQueryStringParameters> => {
  const contents: InvalidQueryStringParameters = {
    name: "InvalidQueryStringParameters",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined,
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlInvalidRelativePathResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidRelativePath> => {
  const contents: InvalidRelativePath = {
    name: "InvalidRelativePath",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined,
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlInvalidRequiredProtocolResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidRequiredProtocol> => {
  const contents: InvalidRequiredProtocol = {
    name: "InvalidRequiredProtocol",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined,
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlInvalidResponseCodeResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidResponseCode> => {
  const contents: InvalidResponseCode = {
    name: "InvalidResponseCode",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined,
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlInvalidTaggingResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidTagging> => {
  const contents: InvalidTagging = {
    name: "InvalidTagging",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined,
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlInvalidTTLOrderResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidTTLOrder> => {
  const contents: InvalidTTLOrder = {
    name: "InvalidTTLOrder",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined,
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlInvalidViewerCertificateResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidViewerCertificate> => {
  const contents: InvalidViewerCertificate = {
    name: "InvalidViewerCertificate",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined,
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlInvalidWebACLIdResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidWebACLId> => {
  const contents: InvalidWebACLId = {
    name: "InvalidWebACLId",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined,
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlMissingBodyResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<MissingBody> => {
  const contents: MissingBody = {
    name: "MissingBody",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined,
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlNoSuchCloudFrontOriginAccessIdentityResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<NoSuchCloudFrontOriginAccessIdentity> => {
  const contents: NoSuchCloudFrontOriginAccessIdentity = {
    name: "NoSuchCloudFrontOriginAccessIdentity",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined,
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlNoSuchDistributionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<NoSuchDistribution> => {
  const contents: NoSuchDistribution = {
    name: "NoSuchDistribution",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined,
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlNoSuchFieldLevelEncryptionConfigResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<NoSuchFieldLevelEncryptionConfig> => {
  const contents: NoSuchFieldLevelEncryptionConfig = {
    name: "NoSuchFieldLevelEncryptionConfig",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined,
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlNoSuchFieldLevelEncryptionProfileResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<NoSuchFieldLevelEncryptionProfile> => {
  const contents: NoSuchFieldLevelEncryptionProfile = {
    name: "NoSuchFieldLevelEncryptionProfile",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined,
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlNoSuchInvalidationResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<NoSuchInvalidation> => {
  const contents: NoSuchInvalidation = {
    name: "NoSuchInvalidation",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined,
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlNoSuchOriginResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<NoSuchOrigin> => {
  const contents: NoSuchOrigin = {
    name: "NoSuchOrigin",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined,
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlNoSuchPublicKeyResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<NoSuchPublicKey> => {
  const contents: NoSuchPublicKey = {
    name: "NoSuchPublicKey",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined,
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlNoSuchResourceResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<NoSuchResource> => {
  const contents: NoSuchResource = {
    name: "NoSuchResource",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined,
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlNoSuchStreamingDistributionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<NoSuchStreamingDistribution> => {
  const contents: NoSuchStreamingDistribution = {
    name: "NoSuchStreamingDistribution",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined,
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlPreconditionFailedResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<PreconditionFailed> => {
  const contents: PreconditionFailed = {
    name: "PreconditionFailed",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined,
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlPublicKeyAlreadyExistsResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<PublicKeyAlreadyExists> => {
  const contents: PublicKeyAlreadyExists = {
    name: "PublicKeyAlreadyExists",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined,
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlPublicKeyInUseResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<PublicKeyInUse> => {
  const contents: PublicKeyInUse = {
    name: "PublicKeyInUse",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined,
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlQueryArgProfileEmptyResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<QueryArgProfileEmpty> => {
  const contents: QueryArgProfileEmpty = {
    name: "QueryArgProfileEmpty",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined,
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlStreamingDistributionAlreadyExistsResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<StreamingDistributionAlreadyExists> => {
  const contents: StreamingDistributionAlreadyExists = {
    name: "StreamingDistributionAlreadyExists",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined,
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlStreamingDistributionNotDisabledResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<StreamingDistributionNotDisabled> => {
  const contents: StreamingDistributionNotDisabled = {
    name: "StreamingDistributionNotDisabled",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined,
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlTooManyCacheBehaviorsResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<TooManyCacheBehaviors> => {
  const contents: TooManyCacheBehaviors = {
    name: "TooManyCacheBehaviors",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined,
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlTooManyCertificatesResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<TooManyCertificates> => {
  const contents: TooManyCertificates = {
    name: "TooManyCertificates",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined,
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlTooManyCloudFrontOriginAccessIdentitiesResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<TooManyCloudFrontOriginAccessIdentities> => {
  const contents: TooManyCloudFrontOriginAccessIdentities = {
    name: "TooManyCloudFrontOriginAccessIdentities",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined,
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlTooManyCookieNamesInWhiteListResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<TooManyCookieNamesInWhiteList> => {
  const contents: TooManyCookieNamesInWhiteList = {
    name: "TooManyCookieNamesInWhiteList",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined,
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlTooManyDistributionCNAMEsResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<TooManyDistributionCNAMEs> => {
  const contents: TooManyDistributionCNAMEs = {
    name: "TooManyDistributionCNAMEs",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined,
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlTooManyDistributionsResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<TooManyDistributions> => {
  const contents: TooManyDistributions = {
    name: "TooManyDistributions",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined,
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlTooManyDistributionsAssociatedToFieldLevelEncryptionConfigResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<TooManyDistributionsAssociatedToFieldLevelEncryptionConfig> => {
  const contents: TooManyDistributionsAssociatedToFieldLevelEncryptionConfig = {
    name: "TooManyDistributionsAssociatedToFieldLevelEncryptionConfig",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined,
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlTooManyDistributionsWithLambdaAssociationsResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<TooManyDistributionsWithLambdaAssociations> => {
  const contents: TooManyDistributionsWithLambdaAssociations = {
    name: "TooManyDistributionsWithLambdaAssociations",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined,
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlTooManyFieldLevelEncryptionConfigsResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<TooManyFieldLevelEncryptionConfigs> => {
  const contents: TooManyFieldLevelEncryptionConfigs = {
    name: "TooManyFieldLevelEncryptionConfigs",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined,
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlTooManyFieldLevelEncryptionContentTypeProfilesResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<TooManyFieldLevelEncryptionContentTypeProfiles> => {
  const contents: TooManyFieldLevelEncryptionContentTypeProfiles = {
    name: "TooManyFieldLevelEncryptionContentTypeProfiles",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined,
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlTooManyFieldLevelEncryptionEncryptionEntitiesResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<TooManyFieldLevelEncryptionEncryptionEntities> => {
  const contents: TooManyFieldLevelEncryptionEncryptionEntities = {
    name: "TooManyFieldLevelEncryptionEncryptionEntities",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined,
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlTooManyFieldLevelEncryptionFieldPatternsResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<TooManyFieldLevelEncryptionFieldPatterns> => {
  const contents: TooManyFieldLevelEncryptionFieldPatterns = {
    name: "TooManyFieldLevelEncryptionFieldPatterns",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined,
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlTooManyFieldLevelEncryptionProfilesResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<TooManyFieldLevelEncryptionProfiles> => {
  const contents: TooManyFieldLevelEncryptionProfiles = {
    name: "TooManyFieldLevelEncryptionProfiles",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined,
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlTooManyFieldLevelEncryptionQueryArgProfilesResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<TooManyFieldLevelEncryptionQueryArgProfiles> => {
  const contents: TooManyFieldLevelEncryptionQueryArgProfiles = {
    name: "TooManyFieldLevelEncryptionQueryArgProfiles",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined,
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlTooManyHeadersInForwardedValuesResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<TooManyHeadersInForwardedValues> => {
  const contents: TooManyHeadersInForwardedValues = {
    name: "TooManyHeadersInForwardedValues",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined,
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlTooManyInvalidationsInProgressResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<TooManyInvalidationsInProgress> => {
  const contents: TooManyInvalidationsInProgress = {
    name: "TooManyInvalidationsInProgress",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined,
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlTooManyLambdaFunctionAssociationsResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<TooManyLambdaFunctionAssociations> => {
  const contents: TooManyLambdaFunctionAssociations = {
    name: "TooManyLambdaFunctionAssociations",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined,
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlTooManyOriginCustomHeadersResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<TooManyOriginCustomHeaders> => {
  const contents: TooManyOriginCustomHeaders = {
    name: "TooManyOriginCustomHeaders",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined,
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlTooManyOriginGroupsPerDistributionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<TooManyOriginGroupsPerDistribution> => {
  const contents: TooManyOriginGroupsPerDistribution = {
    name: "TooManyOriginGroupsPerDistribution",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined,
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlTooManyOriginsResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<TooManyOrigins> => {
  const contents: TooManyOrigins = {
    name: "TooManyOrigins",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined,
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlTooManyPublicKeysResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<TooManyPublicKeys> => {
  const contents: TooManyPublicKeys = {
    name: "TooManyPublicKeys",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined,
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlTooManyQueryStringParametersResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<TooManyQueryStringParameters> => {
  const contents: TooManyQueryStringParameters = {
    name: "TooManyQueryStringParameters",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined,
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlTooManyStreamingDistributionCNAMEsResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<TooManyStreamingDistributionCNAMEs> => {
  const contents: TooManyStreamingDistributionCNAMEs = {
    name: "TooManyStreamingDistributionCNAMEs",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined,
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlTooManyStreamingDistributionsResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<TooManyStreamingDistributions> => {
  const contents: TooManyStreamingDistributions = {
    name: "TooManyStreamingDistributions",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined,
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlTooManyTrustedSignersResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<TooManyTrustedSigners> => {
  const contents: TooManyTrustedSigners = {
    name: "TooManyTrustedSigners",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined,
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlTrustedSignerDoesNotExistResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<TrustedSignerDoesNotExist> => {
  const contents: TrustedSignerDoesNotExist = {
    name: "TrustedSignerDoesNotExist",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined,
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const serializeAws_restXmlAliases = (input: Aliases, context: __SerdeContext): any => {
  const bodyNode = new __XmlNode("Aliases");
  if (input.Items !== undefined) {
    const nodes = serializeAws_restXmlAliasList(input.Items, context);
    const containerNode = new __XmlNode("Items");
    nodes.map((node: any) => {
      containerNode.addChildNode(node);
    });
    bodyNode.addChildNode(containerNode);
  }
  if (input.Quantity !== undefined) {
    const node = new __XmlNode("integer").addChildNode(new __XmlText(String(input.Quantity))).withName("Quantity");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlAliasList = (input: string[], context: __SerdeContext): any => {
  return input.map((entry) => {
    const node = new __XmlNode("string").addChildNode(new __XmlText(entry));
    return node.withName("CNAME");
  });
};

const serializeAws_restXmlAllowedMethods = (input: AllowedMethods, context: __SerdeContext): any => {
  const bodyNode = new __XmlNode("AllowedMethods");
  if (input.CachedMethods !== undefined) {
    const node = serializeAws_restXmlCachedMethods(input.CachedMethods, context).withName("CachedMethods");
    bodyNode.addChildNode(node);
  }
  if (input.Items !== undefined) {
    const nodes = serializeAws_restXmlMethodsList(input.Items, context);
    const containerNode = new __XmlNode("Items");
    nodes.map((node: any) => {
      containerNode.addChildNode(node);
    });
    bodyNode.addChildNode(containerNode);
  }
  if (input.Quantity !== undefined) {
    const node = new __XmlNode("integer").addChildNode(new __XmlText(String(input.Quantity))).withName("Quantity");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlAwsAccountNumberList = (input: string[], context: __SerdeContext): any => {
  return input.map((entry) => {
    const node = new __XmlNode("string").addChildNode(new __XmlText(entry));
    return node.withName("AwsAccountNumber");
  });
};

const serializeAws_restXmlCacheBehavior = (input: CacheBehavior, context: __SerdeContext): any => {
  const bodyNode = new __XmlNode("CacheBehavior");
  if (input.AllowedMethods !== undefined) {
    const node = serializeAws_restXmlAllowedMethods(input.AllowedMethods, context).withName("AllowedMethods");
    bodyNode.addChildNode(node);
  }
  if (input.Compress !== undefined) {
    const node = new __XmlNode("boolean").addChildNode(new __XmlText(String(input.Compress))).withName("Compress");
    bodyNode.addChildNode(node);
  }
  if (input.DefaultTTL !== undefined) {
    const node = new __XmlNode("long").addChildNode(new __XmlText(String(input.DefaultTTL))).withName("DefaultTTL");
    bodyNode.addChildNode(node);
  }
  if (input.FieldLevelEncryptionId !== undefined) {
    const node = new __XmlNode("string")
      .addChildNode(new __XmlText(input.FieldLevelEncryptionId))
      .withName("FieldLevelEncryptionId");
    bodyNode.addChildNode(node);
  }
  if (input.ForwardedValues !== undefined) {
    const node = serializeAws_restXmlForwardedValues(input.ForwardedValues, context).withName("ForwardedValues");
    bodyNode.addChildNode(node);
  }
  if (input.LambdaFunctionAssociations !== undefined) {
    const node = serializeAws_restXmlLambdaFunctionAssociations(input.LambdaFunctionAssociations, context).withName(
      "LambdaFunctionAssociations"
    );
    bodyNode.addChildNode(node);
  }
  if (input.MaxTTL !== undefined) {
    const node = new __XmlNode("long").addChildNode(new __XmlText(String(input.MaxTTL))).withName("MaxTTL");
    bodyNode.addChildNode(node);
  }
  if (input.MinTTL !== undefined) {
    const node = new __XmlNode("long").addChildNode(new __XmlText(String(input.MinTTL))).withName("MinTTL");
    bodyNode.addChildNode(node);
  }
  if (input.PathPattern !== undefined) {
    const node = new __XmlNode("string").addChildNode(new __XmlText(input.PathPattern)).withName("PathPattern");
    bodyNode.addChildNode(node);
  }
  if (input.SmoothStreaming !== undefined) {
    const node = new __XmlNode("boolean")
      .addChildNode(new __XmlText(String(input.SmoothStreaming)))
      .withName("SmoothStreaming");
    bodyNode.addChildNode(node);
  }
  if (input.TargetOriginId !== undefined) {
    const node = new __XmlNode("string").addChildNode(new __XmlText(input.TargetOriginId)).withName("TargetOriginId");
    bodyNode.addChildNode(node);
  }
  if (input.TrustedSigners !== undefined) {
    const node = serializeAws_restXmlTrustedSigners(input.TrustedSigners, context).withName("TrustedSigners");
    bodyNode.addChildNode(node);
  }
  if (input.ViewerProtocolPolicy !== undefined) {
    const node = new __XmlNode("ViewerProtocolPolicy")
      .addChildNode(new __XmlText(input.ViewerProtocolPolicy))
      .withName("ViewerProtocolPolicy");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlCacheBehaviorList = (input: CacheBehavior[], context: __SerdeContext): any => {
  return input.map((entry) => {
    const node = serializeAws_restXmlCacheBehavior(entry, context);
    return node.withName("CacheBehavior");
  });
};

const serializeAws_restXmlCacheBehaviors = (input: CacheBehaviors, context: __SerdeContext): any => {
  const bodyNode = new __XmlNode("CacheBehaviors");
  if (input.Items !== undefined) {
    const nodes = serializeAws_restXmlCacheBehaviorList(input.Items, context);
    const containerNode = new __XmlNode("Items");
    nodes.map((node: any) => {
      containerNode.addChildNode(node);
    });
    bodyNode.addChildNode(containerNode);
  }
  if (input.Quantity !== undefined) {
    const node = new __XmlNode("integer").addChildNode(new __XmlText(String(input.Quantity))).withName("Quantity");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlCachedMethods = (input: CachedMethods, context: __SerdeContext): any => {
  const bodyNode = new __XmlNode("CachedMethods");
  if (input.Items !== undefined) {
    const nodes = serializeAws_restXmlMethodsList(input.Items, context);
    const containerNode = new __XmlNode("Items");
    nodes.map((node: any) => {
      containerNode.addChildNode(node);
    });
    bodyNode.addChildNode(containerNode);
  }
  if (input.Quantity !== undefined) {
    const node = new __XmlNode("integer").addChildNode(new __XmlText(String(input.Quantity))).withName("Quantity");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlCloudFrontOriginAccessIdentityConfig = (
  input: CloudFrontOriginAccessIdentityConfig,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("CloudFrontOriginAccessIdentityConfig");
  if (input.CallerReference !== undefined) {
    const node = new __XmlNode("string").addChildNode(new __XmlText(input.CallerReference)).withName("CallerReference");
    bodyNode.addChildNode(node);
  }
  if (input.Comment !== undefined) {
    const node = new __XmlNode("string").addChildNode(new __XmlText(input.Comment)).withName("Comment");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlContentTypeProfile = (input: ContentTypeProfile, context: __SerdeContext): any => {
  const bodyNode = new __XmlNode("ContentTypeProfile");
  if (input.ContentType !== undefined) {
    const node = new __XmlNode("string").addChildNode(new __XmlText(input.ContentType)).withName("ContentType");
    bodyNode.addChildNode(node);
  }
  if (input.Format !== undefined) {
    const node = new __XmlNode("Format").addChildNode(new __XmlText(input.Format)).withName("Format");
    bodyNode.addChildNode(node);
  }
  if (input.ProfileId !== undefined) {
    const node = new __XmlNode("string").addChildNode(new __XmlText(input.ProfileId)).withName("ProfileId");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlContentTypeProfileConfig = (
  input: ContentTypeProfileConfig,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("ContentTypeProfileConfig");
  if (input.ContentTypeProfiles !== undefined) {
    const node = serializeAws_restXmlContentTypeProfiles(input.ContentTypeProfiles, context).withName(
      "ContentTypeProfiles"
    );
    bodyNode.addChildNode(node);
  }
  if (input.ForwardWhenContentTypeIsUnknown !== undefined) {
    const node = new __XmlNode("boolean")
      .addChildNode(new __XmlText(String(input.ForwardWhenContentTypeIsUnknown)))
      .withName("ForwardWhenContentTypeIsUnknown");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlContentTypeProfileList = (input: ContentTypeProfile[], context: __SerdeContext): any => {
  return input.map((entry) => {
    const node = serializeAws_restXmlContentTypeProfile(entry, context);
    return node.withName("ContentTypeProfile");
  });
};

const serializeAws_restXmlContentTypeProfiles = (input: ContentTypeProfiles, context: __SerdeContext): any => {
  const bodyNode = new __XmlNode("ContentTypeProfiles");
  if (input.Items !== undefined) {
    const nodes = serializeAws_restXmlContentTypeProfileList(input.Items, context);
    const containerNode = new __XmlNode("Items");
    nodes.map((node: any) => {
      containerNode.addChildNode(node);
    });
    bodyNode.addChildNode(containerNode);
  }
  if (input.Quantity !== undefined) {
    const node = new __XmlNode("integer").addChildNode(new __XmlText(String(input.Quantity))).withName("Quantity");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlCookieNameList = (input: string[], context: __SerdeContext): any => {
  return input.map((entry) => {
    const node = new __XmlNode("string").addChildNode(new __XmlText(entry));
    return node.withName("Name");
  });
};

const serializeAws_restXmlCookieNames = (input: CookieNames, context: __SerdeContext): any => {
  const bodyNode = new __XmlNode("CookieNames");
  if (input.Items !== undefined) {
    const nodes = serializeAws_restXmlCookieNameList(input.Items, context);
    const containerNode = new __XmlNode("Items");
    nodes.map((node: any) => {
      containerNode.addChildNode(node);
    });
    bodyNode.addChildNode(containerNode);
  }
  if (input.Quantity !== undefined) {
    const node = new __XmlNode("integer").addChildNode(new __XmlText(String(input.Quantity))).withName("Quantity");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlCookiePreference = (input: CookiePreference, context: __SerdeContext): any => {
  const bodyNode = new __XmlNode("CookiePreference");
  if (input.Forward !== undefined) {
    const node = new __XmlNode("ItemSelection").addChildNode(new __XmlText(input.Forward)).withName("Forward");
    bodyNode.addChildNode(node);
  }
  if (input.WhitelistedNames !== undefined) {
    const node = serializeAws_restXmlCookieNames(input.WhitelistedNames, context).withName("WhitelistedNames");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlCustomErrorResponse = (input: CustomErrorResponse, context: __SerdeContext): any => {
  const bodyNode = new __XmlNode("CustomErrorResponse");
  if (input.ErrorCachingMinTTL !== undefined) {
    const node = new __XmlNode("long")
      .addChildNode(new __XmlText(String(input.ErrorCachingMinTTL)))
      .withName("ErrorCachingMinTTL");
    bodyNode.addChildNode(node);
  }
  if (input.ErrorCode !== undefined) {
    const node = new __XmlNode("integer").addChildNode(new __XmlText(String(input.ErrorCode))).withName("ErrorCode");
    bodyNode.addChildNode(node);
  }
  if (input.ResponseCode !== undefined) {
    const node = new __XmlNode("string").addChildNode(new __XmlText(input.ResponseCode)).withName("ResponseCode");
    bodyNode.addChildNode(node);
  }
  if (input.ResponsePagePath !== undefined) {
    const node = new __XmlNode("string")
      .addChildNode(new __XmlText(input.ResponsePagePath))
      .withName("ResponsePagePath");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlCustomErrorResponseList = (input: CustomErrorResponse[], context: __SerdeContext): any => {
  return input.map((entry) => {
    const node = serializeAws_restXmlCustomErrorResponse(entry, context);
    return node.withName("CustomErrorResponse");
  });
};

const serializeAws_restXmlCustomErrorResponses = (input: CustomErrorResponses, context: __SerdeContext): any => {
  const bodyNode = new __XmlNode("CustomErrorResponses");
  if (input.Items !== undefined) {
    const nodes = serializeAws_restXmlCustomErrorResponseList(input.Items, context);
    const containerNode = new __XmlNode("Items");
    nodes.map((node: any) => {
      containerNode.addChildNode(node);
    });
    bodyNode.addChildNode(containerNode);
  }
  if (input.Quantity !== undefined) {
    const node = new __XmlNode("integer").addChildNode(new __XmlText(String(input.Quantity))).withName("Quantity");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlCustomHeaders = (input: CustomHeaders, context: __SerdeContext): any => {
  const bodyNode = new __XmlNode("CustomHeaders");
  if (input.Items !== undefined) {
    const nodes = serializeAws_restXmlOriginCustomHeadersList(input.Items, context);
    const containerNode = new __XmlNode("Items");
    nodes.map((node: any) => {
      containerNode.addChildNode(node);
    });
    bodyNode.addChildNode(containerNode);
  }
  if (input.Quantity !== undefined) {
    const node = new __XmlNode("integer").addChildNode(new __XmlText(String(input.Quantity))).withName("Quantity");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlCustomOriginConfig = (input: CustomOriginConfig, context: __SerdeContext): any => {
  const bodyNode = new __XmlNode("CustomOriginConfig");
  if (input.HTTPPort !== undefined) {
    const node = new __XmlNode("integer").addChildNode(new __XmlText(String(input.HTTPPort))).withName("HTTPPort");
    bodyNode.addChildNode(node);
  }
  if (input.HTTPSPort !== undefined) {
    const node = new __XmlNode("integer").addChildNode(new __XmlText(String(input.HTTPSPort))).withName("HTTPSPort");
    bodyNode.addChildNode(node);
  }
  if (input.OriginKeepaliveTimeout !== undefined) {
    const node = new __XmlNode("integer")
      .addChildNode(new __XmlText(String(input.OriginKeepaliveTimeout)))
      .withName("OriginKeepaliveTimeout");
    bodyNode.addChildNode(node);
  }
  if (input.OriginProtocolPolicy !== undefined) {
    const node = new __XmlNode("OriginProtocolPolicy")
      .addChildNode(new __XmlText(input.OriginProtocolPolicy))
      .withName("OriginProtocolPolicy");
    bodyNode.addChildNode(node);
  }
  if (input.OriginReadTimeout !== undefined) {
    const node = new __XmlNode("integer")
      .addChildNode(new __XmlText(String(input.OriginReadTimeout)))
      .withName("OriginReadTimeout");
    bodyNode.addChildNode(node);
  }
  if (input.OriginSslProtocols !== undefined) {
    const node = serializeAws_restXmlOriginSslProtocols(input.OriginSslProtocols, context).withName(
      "OriginSslProtocols"
    );
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlDefaultCacheBehavior = (input: DefaultCacheBehavior, context: __SerdeContext): any => {
  const bodyNode = new __XmlNode("DefaultCacheBehavior");
  if (input.AllowedMethods !== undefined) {
    const node = serializeAws_restXmlAllowedMethods(input.AllowedMethods, context).withName("AllowedMethods");
    bodyNode.addChildNode(node);
  }
  if (input.Compress !== undefined) {
    const node = new __XmlNode("boolean").addChildNode(new __XmlText(String(input.Compress))).withName("Compress");
    bodyNode.addChildNode(node);
  }
  if (input.DefaultTTL !== undefined) {
    const node = new __XmlNode("long").addChildNode(new __XmlText(String(input.DefaultTTL))).withName("DefaultTTL");
    bodyNode.addChildNode(node);
  }
  if (input.FieldLevelEncryptionId !== undefined) {
    const node = new __XmlNode("string")
      .addChildNode(new __XmlText(input.FieldLevelEncryptionId))
      .withName("FieldLevelEncryptionId");
    bodyNode.addChildNode(node);
  }
  if (input.ForwardedValues !== undefined) {
    const node = serializeAws_restXmlForwardedValues(input.ForwardedValues, context).withName("ForwardedValues");
    bodyNode.addChildNode(node);
  }
  if (input.LambdaFunctionAssociations !== undefined) {
    const node = serializeAws_restXmlLambdaFunctionAssociations(input.LambdaFunctionAssociations, context).withName(
      "LambdaFunctionAssociations"
    );
    bodyNode.addChildNode(node);
  }
  if (input.MaxTTL !== undefined) {
    const node = new __XmlNode("long").addChildNode(new __XmlText(String(input.MaxTTL))).withName("MaxTTL");
    bodyNode.addChildNode(node);
  }
  if (input.MinTTL !== undefined) {
    const node = new __XmlNode("long").addChildNode(new __XmlText(String(input.MinTTL))).withName("MinTTL");
    bodyNode.addChildNode(node);
  }
  if (input.SmoothStreaming !== undefined) {
    const node = new __XmlNode("boolean")
      .addChildNode(new __XmlText(String(input.SmoothStreaming)))
      .withName("SmoothStreaming");
    bodyNode.addChildNode(node);
  }
  if (input.TargetOriginId !== undefined) {
    const node = new __XmlNode("string").addChildNode(new __XmlText(input.TargetOriginId)).withName("TargetOriginId");
    bodyNode.addChildNode(node);
  }
  if (input.TrustedSigners !== undefined) {
    const node = serializeAws_restXmlTrustedSigners(input.TrustedSigners, context).withName("TrustedSigners");
    bodyNode.addChildNode(node);
  }
  if (input.ViewerProtocolPolicy !== undefined) {
    const node = new __XmlNode("ViewerProtocolPolicy")
      .addChildNode(new __XmlText(input.ViewerProtocolPolicy))
      .withName("ViewerProtocolPolicy");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlDistributionConfig = (input: DistributionConfig, context: __SerdeContext): any => {
  const bodyNode = new __XmlNode("DistributionConfig");
  if (input.Aliases !== undefined) {
    const node = serializeAws_restXmlAliases(input.Aliases, context).withName("Aliases");
    bodyNode.addChildNode(node);
  }
  if (input.CacheBehaviors !== undefined) {
    const node = serializeAws_restXmlCacheBehaviors(input.CacheBehaviors, context).withName("CacheBehaviors");
    bodyNode.addChildNode(node);
  }
  if (input.CallerReference !== undefined) {
    const node = new __XmlNode("string").addChildNode(new __XmlText(input.CallerReference)).withName("CallerReference");
    bodyNode.addChildNode(node);
  }
  if (input.Comment !== undefined) {
    const node = new __XmlNode("CommentType").addChildNode(new __XmlText(input.Comment)).withName("Comment");
    bodyNode.addChildNode(node);
  }
  if (input.CustomErrorResponses !== undefined) {
    const node = serializeAws_restXmlCustomErrorResponses(input.CustomErrorResponses, context).withName(
      "CustomErrorResponses"
    );
    bodyNode.addChildNode(node);
  }
  if (input.DefaultCacheBehavior !== undefined) {
    const node = serializeAws_restXmlDefaultCacheBehavior(input.DefaultCacheBehavior, context).withName(
      "DefaultCacheBehavior"
    );
    bodyNode.addChildNode(node);
  }
  if (input.DefaultRootObject !== undefined) {
    const node = new __XmlNode("string")
      .addChildNode(new __XmlText(input.DefaultRootObject))
      .withName("DefaultRootObject");
    bodyNode.addChildNode(node);
  }
  if (input.Enabled !== undefined) {
    const node = new __XmlNode("boolean").addChildNode(new __XmlText(String(input.Enabled))).withName("Enabled");
    bodyNode.addChildNode(node);
  }
  if (input.HttpVersion !== undefined) {
    const node = new __XmlNode("HttpVersion").addChildNode(new __XmlText(input.HttpVersion)).withName("HttpVersion");
    bodyNode.addChildNode(node);
  }
  if (input.IsIPV6Enabled !== undefined) {
    const node = new __XmlNode("boolean")
      .addChildNode(new __XmlText(String(input.IsIPV6Enabled)))
      .withName("IsIPV6Enabled");
    bodyNode.addChildNode(node);
  }
  if (input.Logging !== undefined) {
    const node = serializeAws_restXmlLoggingConfig(input.Logging, context).withName("Logging");
    bodyNode.addChildNode(node);
  }
  if (input.OriginGroups !== undefined) {
    const node = serializeAws_restXmlOriginGroups(input.OriginGroups, context).withName("OriginGroups");
    bodyNode.addChildNode(node);
  }
  if (input.Origins !== undefined) {
    const node = serializeAws_restXmlOrigins(input.Origins, context).withName("Origins");
    bodyNode.addChildNode(node);
  }
  if (input.PriceClass !== undefined) {
    const node = new __XmlNode("PriceClass").addChildNode(new __XmlText(input.PriceClass)).withName("PriceClass");
    bodyNode.addChildNode(node);
  }
  if (input.Restrictions !== undefined) {
    const node = serializeAws_restXmlRestrictions(input.Restrictions, context).withName("Restrictions");
    bodyNode.addChildNode(node);
  }
  if (input.ViewerCertificate !== undefined) {
    const node = serializeAws_restXmlViewerCertificate(input.ViewerCertificate, context).withName("ViewerCertificate");
    bodyNode.addChildNode(node);
  }
  if (input.WebACLId !== undefined) {
    const node = new __XmlNode("string").addChildNode(new __XmlText(input.WebACLId)).withName("WebACLId");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlDistributionConfigWithTags = (
  input: DistributionConfigWithTags,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("DistributionConfigWithTags");
  if (input.DistributionConfig !== undefined) {
    const node = serializeAws_restXmlDistributionConfig(input.DistributionConfig, context).withName(
      "DistributionConfig"
    );
    bodyNode.addChildNode(node);
  }
  if (input.Tags !== undefined) {
    const node = serializeAws_restXmlTags(input.Tags, context).withName("Tags");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlEncryptionEntities = (input: EncryptionEntities, context: __SerdeContext): any => {
  const bodyNode = new __XmlNode("EncryptionEntities");
  if (input.Items !== undefined) {
    const nodes = serializeAws_restXmlEncryptionEntityList(input.Items, context);
    const containerNode = new __XmlNode("Items");
    nodes.map((node: any) => {
      containerNode.addChildNode(node);
    });
    bodyNode.addChildNode(containerNode);
  }
  if (input.Quantity !== undefined) {
    const node = new __XmlNode("integer").addChildNode(new __XmlText(String(input.Quantity))).withName("Quantity");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlEncryptionEntity = (input: EncryptionEntity, context: __SerdeContext): any => {
  const bodyNode = new __XmlNode("EncryptionEntity");
  if (input.FieldPatterns !== undefined) {
    const node = serializeAws_restXmlFieldPatterns(input.FieldPatterns, context).withName("FieldPatterns");
    bodyNode.addChildNode(node);
  }
  if (input.ProviderId !== undefined) {
    const node = new __XmlNode("string").addChildNode(new __XmlText(input.ProviderId)).withName("ProviderId");
    bodyNode.addChildNode(node);
  }
  if (input.PublicKeyId !== undefined) {
    const node = new __XmlNode("string").addChildNode(new __XmlText(input.PublicKeyId)).withName("PublicKeyId");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlEncryptionEntityList = (input: EncryptionEntity[], context: __SerdeContext): any => {
  return input.map((entry) => {
    const node = serializeAws_restXmlEncryptionEntity(entry, context);
    return node.withName("EncryptionEntity");
  });
};

const serializeAws_restXmlFieldLevelEncryptionConfig = (
  input: FieldLevelEncryptionConfig,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("FieldLevelEncryptionConfig");
  if (input.CallerReference !== undefined) {
    const node = new __XmlNode("string").addChildNode(new __XmlText(input.CallerReference)).withName("CallerReference");
    bodyNode.addChildNode(node);
  }
  if (input.Comment !== undefined) {
    const node = new __XmlNode("string").addChildNode(new __XmlText(input.Comment)).withName("Comment");
    bodyNode.addChildNode(node);
  }
  if (input.ContentTypeProfileConfig !== undefined) {
    const node = serializeAws_restXmlContentTypeProfileConfig(input.ContentTypeProfileConfig, context).withName(
      "ContentTypeProfileConfig"
    );
    bodyNode.addChildNode(node);
  }
  if (input.QueryArgProfileConfig !== undefined) {
    const node = serializeAws_restXmlQueryArgProfileConfig(input.QueryArgProfileConfig, context).withName(
      "QueryArgProfileConfig"
    );
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlFieldLevelEncryptionProfileConfig = (
  input: FieldLevelEncryptionProfileConfig,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("FieldLevelEncryptionProfileConfig");
  if (input.CallerReference !== undefined) {
    const node = new __XmlNode("string").addChildNode(new __XmlText(input.CallerReference)).withName("CallerReference");
    bodyNode.addChildNode(node);
  }
  if (input.Comment !== undefined) {
    const node = new __XmlNode("string").addChildNode(new __XmlText(input.Comment)).withName("Comment");
    bodyNode.addChildNode(node);
  }
  if (input.EncryptionEntities !== undefined) {
    const node = serializeAws_restXmlEncryptionEntities(input.EncryptionEntities, context).withName(
      "EncryptionEntities"
    );
    bodyNode.addChildNode(node);
  }
  if (input.Name !== undefined) {
    const node = new __XmlNode("string").addChildNode(new __XmlText(input.Name)).withName("Name");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlFieldPatternList = (input: string[], context: __SerdeContext): any => {
  return input.map((entry) => {
    const node = new __XmlNode("string").addChildNode(new __XmlText(entry));
    return node.withName("FieldPattern");
  });
};

const serializeAws_restXmlFieldPatterns = (input: FieldPatterns, context: __SerdeContext): any => {
  const bodyNode = new __XmlNode("FieldPatterns");
  if (input.Items !== undefined) {
    const nodes = serializeAws_restXmlFieldPatternList(input.Items, context);
    const containerNode = new __XmlNode("Items");
    nodes.map((node: any) => {
      containerNode.addChildNode(node);
    });
    bodyNode.addChildNode(containerNode);
  }
  if (input.Quantity !== undefined) {
    const node = new __XmlNode("integer").addChildNode(new __XmlText(String(input.Quantity))).withName("Quantity");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlForwardedValues = (input: ForwardedValues, context: __SerdeContext): any => {
  const bodyNode = new __XmlNode("ForwardedValues");
  if (input.Cookies !== undefined) {
    const node = serializeAws_restXmlCookiePreference(input.Cookies, context).withName("Cookies");
    bodyNode.addChildNode(node);
  }
  if (input.Headers !== undefined) {
    const node = serializeAws_restXmlHeaders(input.Headers, context).withName("Headers");
    bodyNode.addChildNode(node);
  }
  if (input.QueryString !== undefined) {
    const node = new __XmlNode("boolean")
      .addChildNode(new __XmlText(String(input.QueryString)))
      .withName("QueryString");
    bodyNode.addChildNode(node);
  }
  if (input.QueryStringCacheKeys !== undefined) {
    const node = serializeAws_restXmlQueryStringCacheKeys(input.QueryStringCacheKeys, context).withName(
      "QueryStringCacheKeys"
    );
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlGeoRestriction = (input: GeoRestriction, context: __SerdeContext): any => {
  const bodyNode = new __XmlNode("GeoRestriction");
  if (input.Items !== undefined) {
    const nodes = serializeAws_restXmlLocationList(input.Items, context);
    const containerNode = new __XmlNode("Items");
    nodes.map((node: any) => {
      containerNode.addChildNode(node);
    });
    bodyNode.addChildNode(containerNode);
  }
  if (input.Quantity !== undefined) {
    const node = new __XmlNode("integer").addChildNode(new __XmlText(String(input.Quantity))).withName("Quantity");
    bodyNode.addChildNode(node);
  }
  if (input.RestrictionType !== undefined) {
    const node = new __XmlNode("GeoRestrictionType")
      .addChildNode(new __XmlText(input.RestrictionType))
      .withName("RestrictionType");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlHeaderList = (input: string[], context: __SerdeContext): any => {
  return input.map((entry) => {
    const node = new __XmlNode("string").addChildNode(new __XmlText(entry));
    return node.withName("Name");
  });
};

const serializeAws_restXmlHeaders = (input: Headers, context: __SerdeContext): any => {
  const bodyNode = new __XmlNode("Headers");
  if (input.Items !== undefined) {
    const nodes = serializeAws_restXmlHeaderList(input.Items, context);
    const containerNode = new __XmlNode("Items");
    nodes.map((node: any) => {
      containerNode.addChildNode(node);
    });
    bodyNode.addChildNode(containerNode);
  }
  if (input.Quantity !== undefined) {
    const node = new __XmlNode("integer").addChildNode(new __XmlText(String(input.Quantity))).withName("Quantity");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlInvalidationBatch = (input: InvalidationBatch, context: __SerdeContext): any => {
  const bodyNode = new __XmlNode("InvalidationBatch");
  if (input.CallerReference !== undefined) {
    const node = new __XmlNode("string").addChildNode(new __XmlText(input.CallerReference)).withName("CallerReference");
    bodyNode.addChildNode(node);
  }
  if (input.Paths !== undefined) {
    const node = serializeAws_restXmlPaths(input.Paths, context).withName("Paths");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlLambdaFunctionAssociation = (
  input: LambdaFunctionAssociation,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("LambdaFunctionAssociation");
  if (input.EventType !== undefined) {
    const node = new __XmlNode("EventType").addChildNode(new __XmlText(input.EventType)).withName("EventType");
    bodyNode.addChildNode(node);
  }
  if (input.IncludeBody !== undefined) {
    const node = new __XmlNode("boolean")
      .addChildNode(new __XmlText(String(input.IncludeBody)))
      .withName("IncludeBody");
    bodyNode.addChildNode(node);
  }
  if (input.LambdaFunctionARN !== undefined) {
    const node = new __XmlNode("LambdaFunctionARN")
      .addChildNode(new __XmlText(input.LambdaFunctionARN))
      .withName("LambdaFunctionARN");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlLambdaFunctionAssociationList = (
  input: LambdaFunctionAssociation[],
  context: __SerdeContext
): any => {
  return input.map((entry) => {
    const node = serializeAws_restXmlLambdaFunctionAssociation(entry, context);
    return node.withName("LambdaFunctionAssociation");
  });
};

const serializeAws_restXmlLambdaFunctionAssociations = (
  input: LambdaFunctionAssociations,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("LambdaFunctionAssociations");
  if (input.Items !== undefined) {
    const nodes = serializeAws_restXmlLambdaFunctionAssociationList(input.Items, context);
    const containerNode = new __XmlNode("Items");
    nodes.map((node: any) => {
      containerNode.addChildNode(node);
    });
    bodyNode.addChildNode(containerNode);
  }
  if (input.Quantity !== undefined) {
    const node = new __XmlNode("integer").addChildNode(new __XmlText(String(input.Quantity))).withName("Quantity");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlLocationList = (input: string[], context: __SerdeContext): any => {
  return input.map((entry) => {
    const node = new __XmlNode("string").addChildNode(new __XmlText(entry));
    return node.withName("Location");
  });
};

const serializeAws_restXmlLoggingConfig = (input: LoggingConfig, context: __SerdeContext): any => {
  const bodyNode = new __XmlNode("LoggingConfig");
  if (input.Bucket !== undefined) {
    const node = new __XmlNode("string").addChildNode(new __XmlText(input.Bucket)).withName("Bucket");
    bodyNode.addChildNode(node);
  }
  if (input.Enabled !== undefined) {
    const node = new __XmlNode("boolean").addChildNode(new __XmlText(String(input.Enabled))).withName("Enabled");
    bodyNode.addChildNode(node);
  }
  if (input.IncludeCookies !== undefined) {
    const node = new __XmlNode("boolean")
      .addChildNode(new __XmlText(String(input.IncludeCookies)))
      .withName("IncludeCookies");
    bodyNode.addChildNode(node);
  }
  if (input.Prefix !== undefined) {
    const node = new __XmlNode("string").addChildNode(new __XmlText(input.Prefix)).withName("Prefix");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlMethodsList = (input: (Method | string)[], context: __SerdeContext): any => {
  return input.map((entry) => {
    const node = new __XmlNode("Method").addChildNode(new __XmlText(entry));
    return node.withName("Method");
  });
};

const serializeAws_restXmlOrigin = (input: Origin, context: __SerdeContext): any => {
  const bodyNode = new __XmlNode("Origin");
  if (input.CustomHeaders !== undefined) {
    const node = serializeAws_restXmlCustomHeaders(input.CustomHeaders, context).withName("CustomHeaders");
    bodyNode.addChildNode(node);
  }
  if (input.CustomOriginConfig !== undefined) {
    const node = serializeAws_restXmlCustomOriginConfig(input.CustomOriginConfig, context).withName(
      "CustomOriginConfig"
    );
    bodyNode.addChildNode(node);
  }
  if (input.DomainName !== undefined) {
    const node = new __XmlNode("string").addChildNode(new __XmlText(input.DomainName)).withName("DomainName");
    bodyNode.addChildNode(node);
  }
  if (input.Id !== undefined) {
    const node = new __XmlNode("string").addChildNode(new __XmlText(input.Id)).withName("Id");
    bodyNode.addChildNode(node);
  }
  if (input.OriginPath !== undefined) {
    const node = new __XmlNode("string").addChildNode(new __XmlText(input.OriginPath)).withName("OriginPath");
    bodyNode.addChildNode(node);
  }
  if (input.S3OriginConfig !== undefined) {
    const node = serializeAws_restXmlS3OriginConfig(input.S3OriginConfig, context).withName("S3OriginConfig");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlOriginCustomHeader = (input: OriginCustomHeader, context: __SerdeContext): any => {
  const bodyNode = new __XmlNode("OriginCustomHeader");
  if (input.HeaderName !== undefined) {
    const node = new __XmlNode("string").addChildNode(new __XmlText(input.HeaderName)).withName("HeaderName");
    bodyNode.addChildNode(node);
  }
  if (input.HeaderValue !== undefined) {
    const node = new __XmlNode("string").addChildNode(new __XmlText(input.HeaderValue)).withName("HeaderValue");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlOriginCustomHeadersList = (input: OriginCustomHeader[], context: __SerdeContext): any => {
  return input.map((entry) => {
    const node = serializeAws_restXmlOriginCustomHeader(entry, context);
    return node.withName("OriginCustomHeader");
  });
};

const serializeAws_restXmlOriginGroup = (input: OriginGroup, context: __SerdeContext): any => {
  const bodyNode = new __XmlNode("OriginGroup");
  if (input.FailoverCriteria !== undefined) {
    const node = serializeAws_restXmlOriginGroupFailoverCriteria(input.FailoverCriteria, context).withName(
      "FailoverCriteria"
    );
    bodyNode.addChildNode(node);
  }
  if (input.Id !== undefined) {
    const node = new __XmlNode("string").addChildNode(new __XmlText(input.Id)).withName("Id");
    bodyNode.addChildNode(node);
  }
  if (input.Members !== undefined) {
    const node = serializeAws_restXmlOriginGroupMembers(input.Members, context).withName("Members");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlOriginGroupFailoverCriteria = (
  input: OriginGroupFailoverCriteria,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("OriginGroupFailoverCriteria");
  if (input.StatusCodes !== undefined) {
    const node = serializeAws_restXmlStatusCodes(input.StatusCodes, context).withName("StatusCodes");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlOriginGroupList = (input: OriginGroup[], context: __SerdeContext): any => {
  return input.map((entry) => {
    const node = serializeAws_restXmlOriginGroup(entry, context);
    return node.withName("OriginGroup");
  });
};

const serializeAws_restXmlOriginGroupMember = (input: OriginGroupMember, context: __SerdeContext): any => {
  const bodyNode = new __XmlNode("OriginGroupMember");
  if (input.OriginId !== undefined) {
    const node = new __XmlNode("string").addChildNode(new __XmlText(input.OriginId)).withName("OriginId");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlOriginGroupMemberList = (input: OriginGroupMember[], context: __SerdeContext): any => {
  return input.map((entry) => {
    const node = serializeAws_restXmlOriginGroupMember(entry, context);
    return node.withName("OriginGroupMember");
  });
};

const serializeAws_restXmlOriginGroupMembers = (input: OriginGroupMembers, context: __SerdeContext): any => {
  const bodyNode = new __XmlNode("OriginGroupMembers");
  if (input.Items !== undefined) {
    const nodes = serializeAws_restXmlOriginGroupMemberList(input.Items, context);
    const containerNode = new __XmlNode("Items");
    nodes.map((node: any) => {
      containerNode.addChildNode(node);
    });
    bodyNode.addChildNode(containerNode);
  }
  if (input.Quantity !== undefined) {
    const node = new __XmlNode("integer").addChildNode(new __XmlText(String(input.Quantity))).withName("Quantity");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlOriginGroups = (input: OriginGroups, context: __SerdeContext): any => {
  const bodyNode = new __XmlNode("OriginGroups");
  if (input.Items !== undefined) {
    const nodes = serializeAws_restXmlOriginGroupList(input.Items, context);
    const containerNode = new __XmlNode("Items");
    nodes.map((node: any) => {
      containerNode.addChildNode(node);
    });
    bodyNode.addChildNode(containerNode);
  }
  if (input.Quantity !== undefined) {
    const node = new __XmlNode("integer").addChildNode(new __XmlText(String(input.Quantity))).withName("Quantity");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlOriginList = (input: Origin[], context: __SerdeContext): any => {
  return input.map((entry) => {
    const node = serializeAws_restXmlOrigin(entry, context);
    return node.withName("Origin");
  });
};

const serializeAws_restXmlOrigins = (input: Origins, context: __SerdeContext): any => {
  const bodyNode = new __XmlNode("Origins");
  if (input.Items !== undefined) {
    const nodes = serializeAws_restXmlOriginList(input.Items, context);
    const containerNode = new __XmlNode("Items");
    nodes.map((node: any) => {
      containerNode.addChildNode(node);
    });
    bodyNode.addChildNode(containerNode);
  }
  if (input.Quantity !== undefined) {
    const node = new __XmlNode("integer").addChildNode(new __XmlText(String(input.Quantity))).withName("Quantity");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlOriginSslProtocols = (input: OriginSslProtocols, context: __SerdeContext): any => {
  const bodyNode = new __XmlNode("OriginSslProtocols");
  if (input.Items !== undefined) {
    const nodes = serializeAws_restXmlSslProtocolsList(input.Items, context);
    const containerNode = new __XmlNode("Items");
    nodes.map((node: any) => {
      containerNode.addChildNode(node);
    });
    bodyNode.addChildNode(containerNode);
  }
  if (input.Quantity !== undefined) {
    const node = new __XmlNode("integer").addChildNode(new __XmlText(String(input.Quantity))).withName("Quantity");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlPathList = (input: string[], context: __SerdeContext): any => {
  return input.map((entry) => {
    const node = new __XmlNode("string").addChildNode(new __XmlText(entry));
    return node.withName("Path");
  });
};

const serializeAws_restXmlPaths = (input: Paths, context: __SerdeContext): any => {
  const bodyNode = new __XmlNode("Paths");
  if (input.Items !== undefined) {
    const nodes = serializeAws_restXmlPathList(input.Items, context);
    const containerNode = new __XmlNode("Items");
    nodes.map((node: any) => {
      containerNode.addChildNode(node);
    });
    bodyNode.addChildNode(containerNode);
  }
  if (input.Quantity !== undefined) {
    const node = new __XmlNode("integer").addChildNode(new __XmlText(String(input.Quantity))).withName("Quantity");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlPublicKeyConfig = (input: PublicKeyConfig, context: __SerdeContext): any => {
  const bodyNode = new __XmlNode("PublicKeyConfig");
  if (input.CallerReference !== undefined) {
    const node = new __XmlNode("string").addChildNode(new __XmlText(input.CallerReference)).withName("CallerReference");
    bodyNode.addChildNode(node);
  }
  if (input.Comment !== undefined) {
    const node = new __XmlNode("string").addChildNode(new __XmlText(input.Comment)).withName("Comment");
    bodyNode.addChildNode(node);
  }
  if (input.EncodedKey !== undefined) {
    const node = new __XmlNode("string").addChildNode(new __XmlText(input.EncodedKey)).withName("EncodedKey");
    bodyNode.addChildNode(node);
  }
  if (input.Name !== undefined) {
    const node = new __XmlNode("string").addChildNode(new __XmlText(input.Name)).withName("Name");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlQueryArgProfile = (input: QueryArgProfile, context: __SerdeContext): any => {
  const bodyNode = new __XmlNode("QueryArgProfile");
  if (input.ProfileId !== undefined) {
    const node = new __XmlNode("string").addChildNode(new __XmlText(input.ProfileId)).withName("ProfileId");
    bodyNode.addChildNode(node);
  }
  if (input.QueryArg !== undefined) {
    const node = new __XmlNode("string").addChildNode(new __XmlText(input.QueryArg)).withName("QueryArg");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlQueryArgProfileConfig = (input: QueryArgProfileConfig, context: __SerdeContext): any => {
  const bodyNode = new __XmlNode("QueryArgProfileConfig");
  if (input.ForwardWhenQueryArgProfileIsUnknown !== undefined) {
    const node = new __XmlNode("boolean")
      .addChildNode(new __XmlText(String(input.ForwardWhenQueryArgProfileIsUnknown)))
      .withName("ForwardWhenQueryArgProfileIsUnknown");
    bodyNode.addChildNode(node);
  }
  if (input.QueryArgProfiles !== undefined) {
    const node = serializeAws_restXmlQueryArgProfiles(input.QueryArgProfiles, context).withName("QueryArgProfiles");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlQueryArgProfileList = (input: QueryArgProfile[], context: __SerdeContext): any => {
  return input.map((entry) => {
    const node = serializeAws_restXmlQueryArgProfile(entry, context);
    return node.withName("QueryArgProfile");
  });
};

const serializeAws_restXmlQueryArgProfiles = (input: QueryArgProfiles, context: __SerdeContext): any => {
  const bodyNode = new __XmlNode("QueryArgProfiles");
  if (input.Items !== undefined) {
    const nodes = serializeAws_restXmlQueryArgProfileList(input.Items, context);
    const containerNode = new __XmlNode("Items");
    nodes.map((node: any) => {
      containerNode.addChildNode(node);
    });
    bodyNode.addChildNode(containerNode);
  }
  if (input.Quantity !== undefined) {
    const node = new __XmlNode("integer").addChildNode(new __XmlText(String(input.Quantity))).withName("Quantity");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlQueryStringCacheKeys = (input: QueryStringCacheKeys, context: __SerdeContext): any => {
  const bodyNode = new __XmlNode("QueryStringCacheKeys");
  if (input.Items !== undefined) {
    const nodes = serializeAws_restXmlQueryStringCacheKeysList(input.Items, context);
    const containerNode = new __XmlNode("Items");
    nodes.map((node: any) => {
      containerNode.addChildNode(node);
    });
    bodyNode.addChildNode(containerNode);
  }
  if (input.Quantity !== undefined) {
    const node = new __XmlNode("integer").addChildNode(new __XmlText(String(input.Quantity))).withName("Quantity");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlQueryStringCacheKeysList = (input: string[], context: __SerdeContext): any => {
  return input.map((entry) => {
    const node = new __XmlNode("string").addChildNode(new __XmlText(entry));
    return node.withName("Name");
  });
};

const serializeAws_restXmlRestrictions = (input: Restrictions, context: __SerdeContext): any => {
  const bodyNode = new __XmlNode("Restrictions");
  if (input.GeoRestriction !== undefined) {
    const node = serializeAws_restXmlGeoRestriction(input.GeoRestriction, context).withName("GeoRestriction");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlS3Origin = (input: S3Origin, context: __SerdeContext): any => {
  const bodyNode = new __XmlNode("S3Origin");
  if (input.DomainName !== undefined) {
    const node = new __XmlNode("string").addChildNode(new __XmlText(input.DomainName)).withName("DomainName");
    bodyNode.addChildNode(node);
  }
  if (input.OriginAccessIdentity !== undefined) {
    const node = new __XmlNode("string")
      .addChildNode(new __XmlText(input.OriginAccessIdentity))
      .withName("OriginAccessIdentity");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlS3OriginConfig = (input: S3OriginConfig, context: __SerdeContext): any => {
  const bodyNode = new __XmlNode("S3OriginConfig");
  if (input.OriginAccessIdentity !== undefined) {
    const node = new __XmlNode("string")
      .addChildNode(new __XmlText(input.OriginAccessIdentity))
      .withName("OriginAccessIdentity");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlSslProtocolsList = (input: (SslProtocol | string)[], context: __SerdeContext): any => {
  return input.map((entry) => {
    const node = new __XmlNode("SslProtocol").addChildNode(new __XmlText(entry));
    return node.withName("SslProtocol");
  });
};

const serializeAws_restXmlStatusCodeList = (input: number[], context: __SerdeContext): any => {
  return input.map((entry) => {
    const node = new __XmlNode("integer").addChildNode(new __XmlText(String(entry)));
    return node.withName("StatusCode");
  });
};

const serializeAws_restXmlStatusCodes = (input: StatusCodes, context: __SerdeContext): any => {
  const bodyNode = new __XmlNode("StatusCodes");
  if (input.Items !== undefined) {
    const nodes = serializeAws_restXmlStatusCodeList(input.Items, context);
    const containerNode = new __XmlNode("Items");
    nodes.map((node: any) => {
      containerNode.addChildNode(node);
    });
    bodyNode.addChildNode(containerNode);
  }
  if (input.Quantity !== undefined) {
    const node = new __XmlNode("integer").addChildNode(new __XmlText(String(input.Quantity))).withName("Quantity");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlStreamingDistributionConfig = (
  input: StreamingDistributionConfig,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("StreamingDistributionConfig");
  if (input.Aliases !== undefined) {
    const node = serializeAws_restXmlAliases(input.Aliases, context).withName("Aliases");
    bodyNode.addChildNode(node);
  }
  if (input.CallerReference !== undefined) {
    const node = new __XmlNode("string").addChildNode(new __XmlText(input.CallerReference)).withName("CallerReference");
    bodyNode.addChildNode(node);
  }
  if (input.Comment !== undefined) {
    const node = new __XmlNode("string").addChildNode(new __XmlText(input.Comment)).withName("Comment");
    bodyNode.addChildNode(node);
  }
  if (input.Enabled !== undefined) {
    const node = new __XmlNode("boolean").addChildNode(new __XmlText(String(input.Enabled))).withName("Enabled");
    bodyNode.addChildNode(node);
  }
  if (input.Logging !== undefined) {
    const node = serializeAws_restXmlStreamingLoggingConfig(input.Logging, context).withName("Logging");
    bodyNode.addChildNode(node);
  }
  if (input.PriceClass !== undefined) {
    const node = new __XmlNode("PriceClass").addChildNode(new __XmlText(input.PriceClass)).withName("PriceClass");
    bodyNode.addChildNode(node);
  }
  if (input.S3Origin !== undefined) {
    const node = serializeAws_restXmlS3Origin(input.S3Origin, context).withName("S3Origin");
    bodyNode.addChildNode(node);
  }
  if (input.TrustedSigners !== undefined) {
    const node = serializeAws_restXmlTrustedSigners(input.TrustedSigners, context).withName("TrustedSigners");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlStreamingDistributionConfigWithTags = (
  input: StreamingDistributionConfigWithTags,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("StreamingDistributionConfigWithTags");
  if (input.StreamingDistributionConfig !== undefined) {
    const node = serializeAws_restXmlStreamingDistributionConfig(input.StreamingDistributionConfig, context).withName(
      "StreamingDistributionConfig"
    );
    bodyNode.addChildNode(node);
  }
  if (input.Tags !== undefined) {
    const node = serializeAws_restXmlTags(input.Tags, context).withName("Tags");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlStreamingLoggingConfig = (input: StreamingLoggingConfig, context: __SerdeContext): any => {
  const bodyNode = new __XmlNode("StreamingLoggingConfig");
  if (input.Bucket !== undefined) {
    const node = new __XmlNode("string").addChildNode(new __XmlText(input.Bucket)).withName("Bucket");
    bodyNode.addChildNode(node);
  }
  if (input.Enabled !== undefined) {
    const node = new __XmlNode("boolean").addChildNode(new __XmlText(String(input.Enabled))).withName("Enabled");
    bodyNode.addChildNode(node);
  }
  if (input.Prefix !== undefined) {
    const node = new __XmlNode("string").addChildNode(new __XmlText(input.Prefix)).withName("Prefix");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlTag = (input: Tag, context: __SerdeContext): any => {
  const bodyNode = new __XmlNode("Tag");
  if (input.Key !== undefined) {
    const node = new __XmlNode("TagKey").addChildNode(new __XmlText(input.Key)).withName("Key");
    bodyNode.addChildNode(node);
  }
  if (input.Value !== undefined) {
    const node = new __XmlNode("TagValue").addChildNode(new __XmlText(input.Value)).withName("Value");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlTagKeyList = (input: string[], context: __SerdeContext): any => {
  return input.map((entry) => {
    const node = new __XmlNode("TagKey").addChildNode(new __XmlText(entry));
    return node.withName("Key");
  });
};

const serializeAws_restXmlTagKeys = (input: TagKeys, context: __SerdeContext): any => {
  const bodyNode = new __XmlNode("TagKeys");
  if (input.Items !== undefined) {
    const nodes = serializeAws_restXmlTagKeyList(input.Items, context);
    const containerNode = new __XmlNode("Items");
    nodes.map((node: any) => {
      containerNode.addChildNode(node);
    });
    bodyNode.addChildNode(containerNode);
  }
  return bodyNode;
};

const serializeAws_restXmlTagList = (input: Tag[], context: __SerdeContext): any => {
  return input.map((entry) => {
    const node = serializeAws_restXmlTag(entry, context);
    return node.withName("Tag");
  });
};

const serializeAws_restXmlTags = (input: Tags, context: __SerdeContext): any => {
  const bodyNode = new __XmlNode("Tags");
  if (input.Items !== undefined) {
    const nodes = serializeAws_restXmlTagList(input.Items, context);
    const containerNode = new __XmlNode("Items");
    nodes.map((node: any) => {
      containerNode.addChildNode(node);
    });
    bodyNode.addChildNode(containerNode);
  }
  return bodyNode;
};

const serializeAws_restXmlTrustedSigners = (input: TrustedSigners, context: __SerdeContext): any => {
  const bodyNode = new __XmlNode("TrustedSigners");
  if (input.Enabled !== undefined) {
    const node = new __XmlNode("boolean").addChildNode(new __XmlText(String(input.Enabled))).withName("Enabled");
    bodyNode.addChildNode(node);
  }
  if (input.Items !== undefined) {
    const nodes = serializeAws_restXmlAwsAccountNumberList(input.Items, context);
    const containerNode = new __XmlNode("Items");
    nodes.map((node: any) => {
      containerNode.addChildNode(node);
    });
    bodyNode.addChildNode(containerNode);
  }
  if (input.Quantity !== undefined) {
    const node = new __XmlNode("integer").addChildNode(new __XmlText(String(input.Quantity))).withName("Quantity");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlViewerCertificate = (input: ViewerCertificate, context: __SerdeContext): any => {
  const bodyNode = new __XmlNode("ViewerCertificate");
  if (input.ACMCertificateArn !== undefined) {
    const node = new __XmlNode("string")
      .addChildNode(new __XmlText(input.ACMCertificateArn))
      .withName("ACMCertificateArn");
    bodyNode.addChildNode(node);
  }
  if (input.Certificate !== undefined) {
    const node = new __XmlNode("string").addChildNode(new __XmlText(input.Certificate)).withName("Certificate");
    bodyNode.addChildNode(node);
  }
  if (input.CertificateSource !== undefined) {
    const node = new __XmlNode("CertificateSource")
      .addChildNode(new __XmlText(input.CertificateSource))
      .withName("CertificateSource");
    bodyNode.addChildNode(node);
  }
  if (input.CloudFrontDefaultCertificate !== undefined) {
    const node = new __XmlNode("boolean")
      .addChildNode(new __XmlText(String(input.CloudFrontDefaultCertificate)))
      .withName("CloudFrontDefaultCertificate");
    bodyNode.addChildNode(node);
  }
  if (input.IAMCertificateId !== undefined) {
    const node = new __XmlNode("string")
      .addChildNode(new __XmlText(input.IAMCertificateId))
      .withName("IAMCertificateId");
    bodyNode.addChildNode(node);
  }
  if (input.MinimumProtocolVersion !== undefined) {
    const node = new __XmlNode("MinimumProtocolVersion")
      .addChildNode(new __XmlText(input.MinimumProtocolVersion))
      .withName("MinimumProtocolVersion");
    bodyNode.addChildNode(node);
  }
  if (input.SSLSupportMethod !== undefined) {
    const node = new __XmlNode("SSLSupportMethod")
      .addChildNode(new __XmlText(input.SSLSupportMethod))
      .withName("SSLSupportMethod");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const deserializeAws_restXmlActiveTrustedSigners = (output: any, context: __SerdeContext): ActiveTrustedSigners => {
  let contents: any = {
    __type: "ActiveTrustedSigners",
    Enabled: undefined,
    Items: undefined,
    Quantity: undefined,
  };
  if (output["Enabled"] !== undefined) {
    contents.Enabled = output["Enabled"] == "true";
  }
  if (output.Items === "") {
    contents.Items = [];
  }
  if (output["Items"] !== undefined && output["Items"]["Signer"] !== undefined) {
    contents.Items = deserializeAws_restXmlSignerList(__getArrayIfSingleItem(output["Items"]["Signer"]), context);
  }
  if (output["Quantity"] !== undefined) {
    contents.Quantity = parseInt(output["Quantity"]);
  }
  return contents;
};

const deserializeAws_restXmlAliases = (output: any, context: __SerdeContext): Aliases => {
  let contents: any = {
    __type: "Aliases",
    Items: undefined,
    Quantity: undefined,
  };
  if (output.Items === "") {
    contents.Items = [];
  }
  if (output["Items"] !== undefined && output["Items"]["CNAME"] !== undefined) {
    contents.Items = deserializeAws_restXmlAliasList(__getArrayIfSingleItem(output["Items"]["CNAME"]), context);
  }
  if (output["Quantity"] !== undefined) {
    contents.Quantity = parseInt(output["Quantity"]);
  }
  return contents;
};

const deserializeAws_restXmlAliasICPRecordal = (output: any, context: __SerdeContext): AliasICPRecordal => {
  let contents: any = {
    __type: "AliasICPRecordal",
    CNAME: undefined,
    ICPRecordalStatus: undefined,
  };
  if (output["CNAME"] !== undefined) {
    contents.CNAME = output["CNAME"];
  }
  if (output["ICPRecordalStatus"] !== undefined) {
    contents.ICPRecordalStatus = output["ICPRecordalStatus"];
  }
  return contents;
};

const deserializeAws_restXmlAliasICPRecordals = (output: any, context: __SerdeContext): AliasICPRecordal[] => {
  return (output || []).map((entry: any) => deserializeAws_restXmlAliasICPRecordal(entry, context));
};

const deserializeAws_restXmlAliasList = (output: any, context: __SerdeContext): string[] => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_restXmlAllowedMethods = (output: any, context: __SerdeContext): AllowedMethods => {
  let contents: any = {
    __type: "AllowedMethods",
    CachedMethods: undefined,
    Items: undefined,
    Quantity: undefined,
  };
  if (output["CachedMethods"] !== undefined) {
    contents.CachedMethods = deserializeAws_restXmlCachedMethods(output["CachedMethods"], context);
  }
  if (output.Items === "") {
    contents.Items = [];
  }
  if (output["Items"] !== undefined && output["Items"]["Method"] !== undefined) {
    contents.Items = deserializeAws_restXmlMethodsList(__getArrayIfSingleItem(output["Items"]["Method"]), context);
  }
  if (output["Quantity"] !== undefined) {
    contents.Quantity = parseInt(output["Quantity"]);
  }
  return contents;
};

const deserializeAws_restXmlAwsAccountNumberList = (output: any, context: __SerdeContext): string[] => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_restXmlCacheBehavior = (output: any, context: __SerdeContext): CacheBehavior => {
  let contents: any = {
    __type: "CacheBehavior",
    AllowedMethods: undefined,
    Compress: undefined,
    DefaultTTL: undefined,
    FieldLevelEncryptionId: undefined,
    ForwardedValues: undefined,
    LambdaFunctionAssociations: undefined,
    MaxTTL: undefined,
    MinTTL: undefined,
    PathPattern: undefined,
    SmoothStreaming: undefined,
    TargetOriginId: undefined,
    TrustedSigners: undefined,
    ViewerProtocolPolicy: undefined,
  };
  if (output["AllowedMethods"] !== undefined) {
    contents.AllowedMethods = deserializeAws_restXmlAllowedMethods(output["AllowedMethods"], context);
  }
  if (output["Compress"] !== undefined) {
    contents.Compress = output["Compress"] == "true";
  }
  if (output["DefaultTTL"] !== undefined) {
    contents.DefaultTTL = parseInt(output["DefaultTTL"]);
  }
  if (output["FieldLevelEncryptionId"] !== undefined) {
    contents.FieldLevelEncryptionId = output["FieldLevelEncryptionId"];
  }
  if (output["ForwardedValues"] !== undefined) {
    contents.ForwardedValues = deserializeAws_restXmlForwardedValues(output["ForwardedValues"], context);
  }
  if (output["LambdaFunctionAssociations"] !== undefined) {
    contents.LambdaFunctionAssociations = deserializeAws_restXmlLambdaFunctionAssociations(
      output["LambdaFunctionAssociations"],
      context
    );
  }
  if (output["MaxTTL"] !== undefined) {
    contents.MaxTTL = parseInt(output["MaxTTL"]);
  }
  if (output["MinTTL"] !== undefined) {
    contents.MinTTL = parseInt(output["MinTTL"]);
  }
  if (output["PathPattern"] !== undefined) {
    contents.PathPattern = output["PathPattern"];
  }
  if (output["SmoothStreaming"] !== undefined) {
    contents.SmoothStreaming = output["SmoothStreaming"] == "true";
  }
  if (output["TargetOriginId"] !== undefined) {
    contents.TargetOriginId = output["TargetOriginId"];
  }
  if (output["TrustedSigners"] !== undefined) {
    contents.TrustedSigners = deserializeAws_restXmlTrustedSigners(output["TrustedSigners"], context);
  }
  if (output["ViewerProtocolPolicy"] !== undefined) {
    contents.ViewerProtocolPolicy = output["ViewerProtocolPolicy"];
  }
  return contents;
};

const deserializeAws_restXmlCacheBehaviorList = (output: any, context: __SerdeContext): CacheBehavior[] => {
  return (output || []).map((entry: any) => deserializeAws_restXmlCacheBehavior(entry, context));
};

const deserializeAws_restXmlCacheBehaviors = (output: any, context: __SerdeContext): CacheBehaviors => {
  let contents: any = {
    __type: "CacheBehaviors",
    Items: undefined,
    Quantity: undefined,
  };
  if (output.Items === "") {
    contents.Items = [];
  }
  if (output["Items"] !== undefined && output["Items"]["CacheBehavior"] !== undefined) {
    contents.Items = deserializeAws_restXmlCacheBehaviorList(
      __getArrayIfSingleItem(output["Items"]["CacheBehavior"]),
      context
    );
  }
  if (output["Quantity"] !== undefined) {
    contents.Quantity = parseInt(output["Quantity"]);
  }
  return contents;
};

const deserializeAws_restXmlCachedMethods = (output: any, context: __SerdeContext): CachedMethods => {
  let contents: any = {
    __type: "CachedMethods",
    Items: undefined,
    Quantity: undefined,
  };
  if (output.Items === "") {
    contents.Items = [];
  }
  if (output["Items"] !== undefined && output["Items"]["Method"] !== undefined) {
    contents.Items = deserializeAws_restXmlMethodsList(__getArrayIfSingleItem(output["Items"]["Method"]), context);
  }
  if (output["Quantity"] !== undefined) {
    contents.Quantity = parseInt(output["Quantity"]);
  }
  return contents;
};

const deserializeAws_restXmlCloudFrontOriginAccessIdentity = (
  output: any,
  context: __SerdeContext
): CloudFrontOriginAccessIdentity => {
  let contents: any = {
    __type: "CloudFrontOriginAccessIdentity",
    CloudFrontOriginAccessIdentityConfig: undefined,
    Id: undefined,
    S3CanonicalUserId: undefined,
  };
  if (output["CloudFrontOriginAccessIdentityConfig"] !== undefined) {
    contents.CloudFrontOriginAccessIdentityConfig = deserializeAws_restXmlCloudFrontOriginAccessIdentityConfig(
      output["CloudFrontOriginAccessIdentityConfig"],
      context
    );
  }
  if (output["Id"] !== undefined) {
    contents.Id = output["Id"];
  }
  if (output["S3CanonicalUserId"] !== undefined) {
    contents.S3CanonicalUserId = output["S3CanonicalUserId"];
  }
  return contents;
};

const deserializeAws_restXmlCloudFrontOriginAccessIdentityConfig = (
  output: any,
  context: __SerdeContext
): CloudFrontOriginAccessIdentityConfig => {
  let contents: any = {
    __type: "CloudFrontOriginAccessIdentityConfig",
    CallerReference: undefined,
    Comment: undefined,
  };
  if (output["CallerReference"] !== undefined) {
    contents.CallerReference = output["CallerReference"];
  }
  if (output["Comment"] !== undefined) {
    contents.Comment = output["Comment"];
  }
  return contents;
};

const deserializeAws_restXmlCloudFrontOriginAccessIdentityList = (
  output: any,
  context: __SerdeContext
): CloudFrontOriginAccessIdentityList => {
  let contents: any = {
    __type: "CloudFrontOriginAccessIdentityList",
    IsTruncated: undefined,
    Items: undefined,
    Marker: undefined,
    MaxItems: undefined,
    NextMarker: undefined,
    Quantity: undefined,
  };
  if (output["IsTruncated"] !== undefined) {
    contents.IsTruncated = output["IsTruncated"] == "true";
  }
  if (output.Items === "") {
    contents.Items = [];
  }
  if (output["Items"] !== undefined && output["Items"]["CloudFrontOriginAccessIdentitySummary"] !== undefined) {
    contents.Items = deserializeAws_restXmlCloudFrontOriginAccessIdentitySummaryList(
      __getArrayIfSingleItem(output["Items"]["CloudFrontOriginAccessIdentitySummary"]),
      context
    );
  }
  if (output["Marker"] !== undefined) {
    contents.Marker = output["Marker"];
  }
  if (output["MaxItems"] !== undefined) {
    contents.MaxItems = parseInt(output["MaxItems"]);
  }
  if (output["NextMarker"] !== undefined) {
    contents.NextMarker = output["NextMarker"];
  }
  if (output["Quantity"] !== undefined) {
    contents.Quantity = parseInt(output["Quantity"]);
  }
  return contents;
};

const deserializeAws_restXmlCloudFrontOriginAccessIdentitySummary = (
  output: any,
  context: __SerdeContext
): CloudFrontOriginAccessIdentitySummary => {
  let contents: any = {
    __type: "CloudFrontOriginAccessIdentitySummary",
    Comment: undefined,
    Id: undefined,
    S3CanonicalUserId: undefined,
  };
  if (output["Comment"] !== undefined) {
    contents.Comment = output["Comment"];
  }
  if (output["Id"] !== undefined) {
    contents.Id = output["Id"];
  }
  if (output["S3CanonicalUserId"] !== undefined) {
    contents.S3CanonicalUserId = output["S3CanonicalUserId"];
  }
  return contents;
};

const deserializeAws_restXmlCloudFrontOriginAccessIdentitySummaryList = (
  output: any,
  context: __SerdeContext
): CloudFrontOriginAccessIdentitySummary[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_restXmlCloudFrontOriginAccessIdentitySummary(entry, context)
  );
};

const deserializeAws_restXmlContentTypeProfile = (output: any, context: __SerdeContext): ContentTypeProfile => {
  let contents: any = {
    __type: "ContentTypeProfile",
    ContentType: undefined,
    Format: undefined,
    ProfileId: undefined,
  };
  if (output["ContentType"] !== undefined) {
    contents.ContentType = output["ContentType"];
  }
  if (output["Format"] !== undefined) {
    contents.Format = output["Format"];
  }
  if (output["ProfileId"] !== undefined) {
    contents.ProfileId = output["ProfileId"];
  }
  return contents;
};

const deserializeAws_restXmlContentTypeProfileConfig = (
  output: any,
  context: __SerdeContext
): ContentTypeProfileConfig => {
  let contents: any = {
    __type: "ContentTypeProfileConfig",
    ContentTypeProfiles: undefined,
    ForwardWhenContentTypeIsUnknown: undefined,
  };
  if (output["ContentTypeProfiles"] !== undefined) {
    contents.ContentTypeProfiles = deserializeAws_restXmlContentTypeProfiles(output["ContentTypeProfiles"], context);
  }
  if (output["ForwardWhenContentTypeIsUnknown"] !== undefined) {
    contents.ForwardWhenContentTypeIsUnknown = output["ForwardWhenContentTypeIsUnknown"] == "true";
  }
  return contents;
};

const deserializeAws_restXmlContentTypeProfileList = (output: any, context: __SerdeContext): ContentTypeProfile[] => {
  return (output || []).map((entry: any) => deserializeAws_restXmlContentTypeProfile(entry, context));
};

const deserializeAws_restXmlContentTypeProfiles = (output: any, context: __SerdeContext): ContentTypeProfiles => {
  let contents: any = {
    __type: "ContentTypeProfiles",
    Items: undefined,
    Quantity: undefined,
  };
  if (output.Items === "") {
    contents.Items = [];
  }
  if (output["Items"] !== undefined && output["Items"]["ContentTypeProfile"] !== undefined) {
    contents.Items = deserializeAws_restXmlContentTypeProfileList(
      __getArrayIfSingleItem(output["Items"]["ContentTypeProfile"]),
      context
    );
  }
  if (output["Quantity"] !== undefined) {
    contents.Quantity = parseInt(output["Quantity"]);
  }
  return contents;
};

const deserializeAws_restXmlCookieNameList = (output: any, context: __SerdeContext): string[] => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_restXmlCookieNames = (output: any, context: __SerdeContext): CookieNames => {
  let contents: any = {
    __type: "CookieNames",
    Items: undefined,
    Quantity: undefined,
  };
  if (output.Items === "") {
    contents.Items = [];
  }
  if (output["Items"] !== undefined && output["Items"]["Name"] !== undefined) {
    contents.Items = deserializeAws_restXmlCookieNameList(__getArrayIfSingleItem(output["Items"]["Name"]), context);
  }
  if (output["Quantity"] !== undefined) {
    contents.Quantity = parseInt(output["Quantity"]);
  }
  return contents;
};

const deserializeAws_restXmlCookiePreference = (output: any, context: __SerdeContext): CookiePreference => {
  let contents: any = {
    __type: "CookiePreference",
    Forward: undefined,
    WhitelistedNames: undefined,
  };
  if (output["Forward"] !== undefined) {
    contents.Forward = output["Forward"];
  }
  if (output["WhitelistedNames"] !== undefined) {
    contents.WhitelistedNames = deserializeAws_restXmlCookieNames(output["WhitelistedNames"], context);
  }
  return contents;
};

const deserializeAws_restXmlCustomErrorResponse = (output: any, context: __SerdeContext): CustomErrorResponse => {
  let contents: any = {
    __type: "CustomErrorResponse",
    ErrorCachingMinTTL: undefined,
    ErrorCode: undefined,
    ResponseCode: undefined,
    ResponsePagePath: undefined,
  };
  if (output["ErrorCachingMinTTL"] !== undefined) {
    contents.ErrorCachingMinTTL = parseInt(output["ErrorCachingMinTTL"]);
  }
  if (output["ErrorCode"] !== undefined) {
    contents.ErrorCode = parseInt(output["ErrorCode"]);
  }
  if (output["ResponseCode"] !== undefined) {
    contents.ResponseCode = output["ResponseCode"];
  }
  if (output["ResponsePagePath"] !== undefined) {
    contents.ResponsePagePath = output["ResponsePagePath"];
  }
  return contents;
};

const deserializeAws_restXmlCustomErrorResponseList = (output: any, context: __SerdeContext): CustomErrorResponse[] => {
  return (output || []).map((entry: any) => deserializeAws_restXmlCustomErrorResponse(entry, context));
};

const deserializeAws_restXmlCustomErrorResponses = (output: any, context: __SerdeContext): CustomErrorResponses => {
  let contents: any = {
    __type: "CustomErrorResponses",
    Items: undefined,
    Quantity: undefined,
  };
  if (output.Items === "") {
    contents.Items = [];
  }
  if (output["Items"] !== undefined && output["Items"]["CustomErrorResponse"] !== undefined) {
    contents.Items = deserializeAws_restXmlCustomErrorResponseList(
      __getArrayIfSingleItem(output["Items"]["CustomErrorResponse"]),
      context
    );
  }
  if (output["Quantity"] !== undefined) {
    contents.Quantity = parseInt(output["Quantity"]);
  }
  return contents;
};

const deserializeAws_restXmlCustomHeaders = (output: any, context: __SerdeContext): CustomHeaders => {
  let contents: any = {
    __type: "CustomHeaders",
    Items: undefined,
    Quantity: undefined,
  };
  if (output.Items === "") {
    contents.Items = [];
  }
  if (output["Items"] !== undefined && output["Items"]["OriginCustomHeader"] !== undefined) {
    contents.Items = deserializeAws_restXmlOriginCustomHeadersList(
      __getArrayIfSingleItem(output["Items"]["OriginCustomHeader"]),
      context
    );
  }
  if (output["Quantity"] !== undefined) {
    contents.Quantity = parseInt(output["Quantity"]);
  }
  return contents;
};

const deserializeAws_restXmlCustomOriginConfig = (output: any, context: __SerdeContext): CustomOriginConfig => {
  let contents: any = {
    __type: "CustomOriginConfig",
    HTTPPort: undefined,
    HTTPSPort: undefined,
    OriginKeepaliveTimeout: undefined,
    OriginProtocolPolicy: undefined,
    OriginReadTimeout: undefined,
    OriginSslProtocols: undefined,
  };
  if (output["HTTPPort"] !== undefined) {
    contents.HTTPPort = parseInt(output["HTTPPort"]);
  }
  if (output["HTTPSPort"] !== undefined) {
    contents.HTTPSPort = parseInt(output["HTTPSPort"]);
  }
  if (output["OriginKeepaliveTimeout"] !== undefined) {
    contents.OriginKeepaliveTimeout = parseInt(output["OriginKeepaliveTimeout"]);
  }
  if (output["OriginProtocolPolicy"] !== undefined) {
    contents.OriginProtocolPolicy = output["OriginProtocolPolicy"];
  }
  if (output["OriginReadTimeout"] !== undefined) {
    contents.OriginReadTimeout = parseInt(output["OriginReadTimeout"]);
  }
  if (output["OriginSslProtocols"] !== undefined) {
    contents.OriginSslProtocols = deserializeAws_restXmlOriginSslProtocols(output["OriginSslProtocols"], context);
  }
  return contents;
};

const deserializeAws_restXmlDefaultCacheBehavior = (output: any, context: __SerdeContext): DefaultCacheBehavior => {
  let contents: any = {
    __type: "DefaultCacheBehavior",
    AllowedMethods: undefined,
    Compress: undefined,
    DefaultTTL: undefined,
    FieldLevelEncryptionId: undefined,
    ForwardedValues: undefined,
    LambdaFunctionAssociations: undefined,
    MaxTTL: undefined,
    MinTTL: undefined,
    SmoothStreaming: undefined,
    TargetOriginId: undefined,
    TrustedSigners: undefined,
    ViewerProtocolPolicy: undefined,
  };
  if (output["AllowedMethods"] !== undefined) {
    contents.AllowedMethods = deserializeAws_restXmlAllowedMethods(output["AllowedMethods"], context);
  }
  if (output["Compress"] !== undefined) {
    contents.Compress = output["Compress"] == "true";
  }
  if (output["DefaultTTL"] !== undefined) {
    contents.DefaultTTL = parseInt(output["DefaultTTL"]);
  }
  if (output["FieldLevelEncryptionId"] !== undefined) {
    contents.FieldLevelEncryptionId = output["FieldLevelEncryptionId"];
  }
  if (output["ForwardedValues"] !== undefined) {
    contents.ForwardedValues = deserializeAws_restXmlForwardedValues(output["ForwardedValues"], context);
  }
  if (output["LambdaFunctionAssociations"] !== undefined) {
    contents.LambdaFunctionAssociations = deserializeAws_restXmlLambdaFunctionAssociations(
      output["LambdaFunctionAssociations"],
      context
    );
  }
  if (output["MaxTTL"] !== undefined) {
    contents.MaxTTL = parseInt(output["MaxTTL"]);
  }
  if (output["MinTTL"] !== undefined) {
    contents.MinTTL = parseInt(output["MinTTL"]);
  }
  if (output["SmoothStreaming"] !== undefined) {
    contents.SmoothStreaming = output["SmoothStreaming"] == "true";
  }
  if (output["TargetOriginId"] !== undefined) {
    contents.TargetOriginId = output["TargetOriginId"];
  }
  if (output["TrustedSigners"] !== undefined) {
    contents.TrustedSigners = deserializeAws_restXmlTrustedSigners(output["TrustedSigners"], context);
  }
  if (output["ViewerProtocolPolicy"] !== undefined) {
    contents.ViewerProtocolPolicy = output["ViewerProtocolPolicy"];
  }
  return contents;
};

const deserializeAws_restXmlDistribution = (output: any, context: __SerdeContext): Distribution => {
  let contents: any = {
    __type: "Distribution",
    ARN: undefined,
    ActiveTrustedSigners: undefined,
    AliasICPRecordals: undefined,
    DistributionConfig: undefined,
    DomainName: undefined,
    Id: undefined,
    InProgressInvalidationBatches: undefined,
    LastModifiedTime: undefined,
    Status: undefined,
  };
  if (output["ARN"] !== undefined) {
    contents.ARN = output["ARN"];
  }
  if (output["ActiveTrustedSigners"] !== undefined) {
    contents.ActiveTrustedSigners = deserializeAws_restXmlActiveTrustedSigners(output["ActiveTrustedSigners"], context);
  }
  if (output.AliasICPRecordals === "") {
    contents.AliasICPRecordals = [];
  }
  if (output["AliasICPRecordals"] !== undefined && output["AliasICPRecordals"]["AliasICPRecordal"] !== undefined) {
    contents.AliasICPRecordals = deserializeAws_restXmlAliasICPRecordals(
      __getArrayIfSingleItem(output["AliasICPRecordals"]["AliasICPRecordal"]),
      context
    );
  }
  if (output["DistributionConfig"] !== undefined) {
    contents.DistributionConfig = deserializeAws_restXmlDistributionConfig(output["DistributionConfig"], context);
  }
  if (output["DomainName"] !== undefined) {
    contents.DomainName = output["DomainName"];
  }
  if (output["Id"] !== undefined) {
    contents.Id = output["Id"];
  }
  if (output["InProgressInvalidationBatches"] !== undefined) {
    contents.InProgressInvalidationBatches = parseInt(output["InProgressInvalidationBatches"]);
  }
  if (output["LastModifiedTime"] !== undefined) {
    contents.LastModifiedTime = new Date(output["LastModifiedTime"]);
  }
  if (output["Status"] !== undefined) {
    contents.Status = output["Status"];
  }
  return contents;
};

const deserializeAws_restXmlDistributionConfig = (output: any, context: __SerdeContext): DistributionConfig => {
  let contents: any = {
    __type: "DistributionConfig",
    Aliases: undefined,
    CacheBehaviors: undefined,
    CallerReference: undefined,
    Comment: undefined,
    CustomErrorResponses: undefined,
    DefaultCacheBehavior: undefined,
    DefaultRootObject: undefined,
    Enabled: undefined,
    HttpVersion: undefined,
    IsIPV6Enabled: undefined,
    Logging: undefined,
    OriginGroups: undefined,
    Origins: undefined,
    PriceClass: undefined,
    Restrictions: undefined,
    ViewerCertificate: undefined,
    WebACLId: undefined,
  };
  if (output["Aliases"] !== undefined) {
    contents.Aliases = deserializeAws_restXmlAliases(output["Aliases"], context);
  }
  if (output["CacheBehaviors"] !== undefined) {
    contents.CacheBehaviors = deserializeAws_restXmlCacheBehaviors(output["CacheBehaviors"], context);
  }
  if (output["CallerReference"] !== undefined) {
    contents.CallerReference = output["CallerReference"];
  }
  if (output["Comment"] !== undefined) {
    contents.Comment = output["Comment"];
  }
  if (output["CustomErrorResponses"] !== undefined) {
    contents.CustomErrorResponses = deserializeAws_restXmlCustomErrorResponses(output["CustomErrorResponses"], context);
  }
  if (output["DefaultCacheBehavior"] !== undefined) {
    contents.DefaultCacheBehavior = deserializeAws_restXmlDefaultCacheBehavior(output["DefaultCacheBehavior"], context);
  }
  if (output["DefaultRootObject"] !== undefined) {
    contents.DefaultRootObject = output["DefaultRootObject"];
  }
  if (output["Enabled"] !== undefined) {
    contents.Enabled = output["Enabled"] == "true";
  }
  if (output["HttpVersion"] !== undefined) {
    contents.HttpVersion = output["HttpVersion"];
  }
  if (output["IsIPV6Enabled"] !== undefined) {
    contents.IsIPV6Enabled = output["IsIPV6Enabled"] == "true";
  }
  if (output["Logging"] !== undefined) {
    contents.Logging = deserializeAws_restXmlLoggingConfig(output["Logging"], context);
  }
  if (output["OriginGroups"] !== undefined) {
    contents.OriginGroups = deserializeAws_restXmlOriginGroups(output["OriginGroups"], context);
  }
  if (output["Origins"] !== undefined) {
    contents.Origins = deserializeAws_restXmlOrigins(output["Origins"], context);
  }
  if (output["PriceClass"] !== undefined) {
    contents.PriceClass = output["PriceClass"];
  }
  if (output["Restrictions"] !== undefined) {
    contents.Restrictions = deserializeAws_restXmlRestrictions(output["Restrictions"], context);
  }
  if (output["ViewerCertificate"] !== undefined) {
    contents.ViewerCertificate = deserializeAws_restXmlViewerCertificate(output["ViewerCertificate"], context);
  }
  if (output["WebACLId"] !== undefined) {
    contents.WebACLId = output["WebACLId"];
  }
  return contents;
};

const deserializeAws_restXmlDistributionList = (output: any, context: __SerdeContext): DistributionList => {
  let contents: any = {
    __type: "DistributionList",
    IsTruncated: undefined,
    Items: undefined,
    Marker: undefined,
    MaxItems: undefined,
    NextMarker: undefined,
    Quantity: undefined,
  };
  if (output["IsTruncated"] !== undefined) {
    contents.IsTruncated = output["IsTruncated"] == "true";
  }
  if (output.Items === "") {
    contents.Items = [];
  }
  if (output["Items"] !== undefined && output["Items"]["DistributionSummary"] !== undefined) {
    contents.Items = deserializeAws_restXmlDistributionSummaryList(
      __getArrayIfSingleItem(output["Items"]["DistributionSummary"]),
      context
    );
  }
  if (output["Marker"] !== undefined) {
    contents.Marker = output["Marker"];
  }
  if (output["MaxItems"] !== undefined) {
    contents.MaxItems = parseInt(output["MaxItems"]);
  }
  if (output["NextMarker"] !== undefined) {
    contents.NextMarker = output["NextMarker"];
  }
  if (output["Quantity"] !== undefined) {
    contents.Quantity = parseInt(output["Quantity"]);
  }
  return contents;
};

const deserializeAws_restXmlDistributionSummary = (output: any, context: __SerdeContext): DistributionSummary => {
  let contents: any = {
    __type: "DistributionSummary",
    ARN: undefined,
    AliasICPRecordals: undefined,
    Aliases: undefined,
    CacheBehaviors: undefined,
    Comment: undefined,
    CustomErrorResponses: undefined,
    DefaultCacheBehavior: undefined,
    DomainName: undefined,
    Enabled: undefined,
    HttpVersion: undefined,
    Id: undefined,
    IsIPV6Enabled: undefined,
    LastModifiedTime: undefined,
    OriginGroups: undefined,
    Origins: undefined,
    PriceClass: undefined,
    Restrictions: undefined,
    Status: undefined,
    ViewerCertificate: undefined,
    WebACLId: undefined,
  };
  if (output["ARN"] !== undefined) {
    contents.ARN = output["ARN"];
  }
  if (output.AliasICPRecordals === "") {
    contents.AliasICPRecordals = [];
  }
  if (output["AliasICPRecordals"] !== undefined && output["AliasICPRecordals"]["AliasICPRecordal"] !== undefined) {
    contents.AliasICPRecordals = deserializeAws_restXmlAliasICPRecordals(
      __getArrayIfSingleItem(output["AliasICPRecordals"]["AliasICPRecordal"]),
      context
    );
  }
  if (output["Aliases"] !== undefined) {
    contents.Aliases = deserializeAws_restXmlAliases(output["Aliases"], context);
  }
  if (output["CacheBehaviors"] !== undefined) {
    contents.CacheBehaviors = deserializeAws_restXmlCacheBehaviors(output["CacheBehaviors"], context);
  }
  if (output["Comment"] !== undefined) {
    contents.Comment = output["Comment"];
  }
  if (output["CustomErrorResponses"] !== undefined) {
    contents.CustomErrorResponses = deserializeAws_restXmlCustomErrorResponses(output["CustomErrorResponses"], context);
  }
  if (output["DefaultCacheBehavior"] !== undefined) {
    contents.DefaultCacheBehavior = deserializeAws_restXmlDefaultCacheBehavior(output["DefaultCacheBehavior"], context);
  }
  if (output["DomainName"] !== undefined) {
    contents.DomainName = output["DomainName"];
  }
  if (output["Enabled"] !== undefined) {
    contents.Enabled = output["Enabled"] == "true";
  }
  if (output["HttpVersion"] !== undefined) {
    contents.HttpVersion = output["HttpVersion"];
  }
  if (output["Id"] !== undefined) {
    contents.Id = output["Id"];
  }
  if (output["IsIPV6Enabled"] !== undefined) {
    contents.IsIPV6Enabled = output["IsIPV6Enabled"] == "true";
  }
  if (output["LastModifiedTime"] !== undefined) {
    contents.LastModifiedTime = new Date(output["LastModifiedTime"]);
  }
  if (output["OriginGroups"] !== undefined) {
    contents.OriginGroups = deserializeAws_restXmlOriginGroups(output["OriginGroups"], context);
  }
  if (output["Origins"] !== undefined) {
    contents.Origins = deserializeAws_restXmlOrigins(output["Origins"], context);
  }
  if (output["PriceClass"] !== undefined) {
    contents.PriceClass = output["PriceClass"];
  }
  if (output["Restrictions"] !== undefined) {
    contents.Restrictions = deserializeAws_restXmlRestrictions(output["Restrictions"], context);
  }
  if (output["Status"] !== undefined) {
    contents.Status = output["Status"];
  }
  if (output["ViewerCertificate"] !== undefined) {
    contents.ViewerCertificate = deserializeAws_restXmlViewerCertificate(output["ViewerCertificate"], context);
  }
  if (output["WebACLId"] !== undefined) {
    contents.WebACLId = output["WebACLId"];
  }
  return contents;
};

const deserializeAws_restXmlDistributionSummaryList = (output: any, context: __SerdeContext): DistributionSummary[] => {
  return (output || []).map((entry: any) => deserializeAws_restXmlDistributionSummary(entry, context));
};

const deserializeAws_restXmlEncryptionEntities = (output: any, context: __SerdeContext): EncryptionEntities => {
  let contents: any = {
    __type: "EncryptionEntities",
    Items: undefined,
    Quantity: undefined,
  };
  if (output.Items === "") {
    contents.Items = [];
  }
  if (output["Items"] !== undefined && output["Items"]["EncryptionEntity"] !== undefined) {
    contents.Items = deserializeAws_restXmlEncryptionEntityList(
      __getArrayIfSingleItem(output["Items"]["EncryptionEntity"]),
      context
    );
  }
  if (output["Quantity"] !== undefined) {
    contents.Quantity = parseInt(output["Quantity"]);
  }
  return contents;
};

const deserializeAws_restXmlEncryptionEntity = (output: any, context: __SerdeContext): EncryptionEntity => {
  let contents: any = {
    __type: "EncryptionEntity",
    FieldPatterns: undefined,
    ProviderId: undefined,
    PublicKeyId: undefined,
  };
  if (output["FieldPatterns"] !== undefined) {
    contents.FieldPatterns = deserializeAws_restXmlFieldPatterns(output["FieldPatterns"], context);
  }
  if (output["ProviderId"] !== undefined) {
    contents.ProviderId = output["ProviderId"];
  }
  if (output["PublicKeyId"] !== undefined) {
    contents.PublicKeyId = output["PublicKeyId"];
  }
  return contents;
};

const deserializeAws_restXmlEncryptionEntityList = (output: any, context: __SerdeContext): EncryptionEntity[] => {
  return (output || []).map((entry: any) => deserializeAws_restXmlEncryptionEntity(entry, context));
};

const deserializeAws_restXmlFieldLevelEncryption = (output: any, context: __SerdeContext): FieldLevelEncryption => {
  let contents: any = {
    __type: "FieldLevelEncryption",
    FieldLevelEncryptionConfig: undefined,
    Id: undefined,
    LastModifiedTime: undefined,
  };
  if (output["FieldLevelEncryptionConfig"] !== undefined) {
    contents.FieldLevelEncryptionConfig = deserializeAws_restXmlFieldLevelEncryptionConfig(
      output["FieldLevelEncryptionConfig"],
      context
    );
  }
  if (output["Id"] !== undefined) {
    contents.Id = output["Id"];
  }
  if (output["LastModifiedTime"] !== undefined) {
    contents.LastModifiedTime = new Date(output["LastModifiedTime"]);
  }
  return contents;
};

const deserializeAws_restXmlFieldLevelEncryptionConfig = (
  output: any,
  context: __SerdeContext
): FieldLevelEncryptionConfig => {
  let contents: any = {
    __type: "FieldLevelEncryptionConfig",
    CallerReference: undefined,
    Comment: undefined,
    ContentTypeProfileConfig: undefined,
    QueryArgProfileConfig: undefined,
  };
  if (output["CallerReference"] !== undefined) {
    contents.CallerReference = output["CallerReference"];
  }
  if (output["Comment"] !== undefined) {
    contents.Comment = output["Comment"];
  }
  if (output["ContentTypeProfileConfig"] !== undefined) {
    contents.ContentTypeProfileConfig = deserializeAws_restXmlContentTypeProfileConfig(
      output["ContentTypeProfileConfig"],
      context
    );
  }
  if (output["QueryArgProfileConfig"] !== undefined) {
    contents.QueryArgProfileConfig = deserializeAws_restXmlQueryArgProfileConfig(
      output["QueryArgProfileConfig"],
      context
    );
  }
  return contents;
};

const deserializeAws_restXmlFieldLevelEncryptionList = (
  output: any,
  context: __SerdeContext
): FieldLevelEncryptionList => {
  let contents: any = {
    __type: "FieldLevelEncryptionList",
    Items: undefined,
    MaxItems: undefined,
    NextMarker: undefined,
    Quantity: undefined,
  };
  if (output.Items === "") {
    contents.Items = [];
  }
  if (output["Items"] !== undefined && output["Items"]["FieldLevelEncryptionSummary"] !== undefined) {
    contents.Items = deserializeAws_restXmlFieldLevelEncryptionSummaryList(
      __getArrayIfSingleItem(output["Items"]["FieldLevelEncryptionSummary"]),
      context
    );
  }
  if (output["MaxItems"] !== undefined) {
    contents.MaxItems = parseInt(output["MaxItems"]);
  }
  if (output["NextMarker"] !== undefined) {
    contents.NextMarker = output["NextMarker"];
  }
  if (output["Quantity"] !== undefined) {
    contents.Quantity = parseInt(output["Quantity"]);
  }
  return contents;
};

const deserializeAws_restXmlFieldLevelEncryptionProfile = (
  output: any,
  context: __SerdeContext
): FieldLevelEncryptionProfile => {
  let contents: any = {
    __type: "FieldLevelEncryptionProfile",
    FieldLevelEncryptionProfileConfig: undefined,
    Id: undefined,
    LastModifiedTime: undefined,
  };
  if (output["FieldLevelEncryptionProfileConfig"] !== undefined) {
    contents.FieldLevelEncryptionProfileConfig = deserializeAws_restXmlFieldLevelEncryptionProfileConfig(
      output["FieldLevelEncryptionProfileConfig"],
      context
    );
  }
  if (output["Id"] !== undefined) {
    contents.Id = output["Id"];
  }
  if (output["LastModifiedTime"] !== undefined) {
    contents.LastModifiedTime = new Date(output["LastModifiedTime"]);
  }
  return contents;
};

const deserializeAws_restXmlFieldLevelEncryptionProfileConfig = (
  output: any,
  context: __SerdeContext
): FieldLevelEncryptionProfileConfig => {
  let contents: any = {
    __type: "FieldLevelEncryptionProfileConfig",
    CallerReference: undefined,
    Comment: undefined,
    EncryptionEntities: undefined,
    Name: undefined,
  };
  if (output["CallerReference"] !== undefined) {
    contents.CallerReference = output["CallerReference"];
  }
  if (output["Comment"] !== undefined) {
    contents.Comment = output["Comment"];
  }
  if (output["EncryptionEntities"] !== undefined) {
    contents.EncryptionEntities = deserializeAws_restXmlEncryptionEntities(output["EncryptionEntities"], context);
  }
  if (output["Name"] !== undefined) {
    contents.Name = output["Name"];
  }
  return contents;
};

const deserializeAws_restXmlFieldLevelEncryptionProfileList = (
  output: any,
  context: __SerdeContext
): FieldLevelEncryptionProfileList => {
  let contents: any = {
    __type: "FieldLevelEncryptionProfileList",
    Items: undefined,
    MaxItems: undefined,
    NextMarker: undefined,
    Quantity: undefined,
  };
  if (output.Items === "") {
    contents.Items = [];
  }
  if (output["Items"] !== undefined && output["Items"]["FieldLevelEncryptionProfileSummary"] !== undefined) {
    contents.Items = deserializeAws_restXmlFieldLevelEncryptionProfileSummaryList(
      __getArrayIfSingleItem(output["Items"]["FieldLevelEncryptionProfileSummary"]),
      context
    );
  }
  if (output["MaxItems"] !== undefined) {
    contents.MaxItems = parseInt(output["MaxItems"]);
  }
  if (output["NextMarker"] !== undefined) {
    contents.NextMarker = output["NextMarker"];
  }
  if (output["Quantity"] !== undefined) {
    contents.Quantity = parseInt(output["Quantity"]);
  }
  return contents;
};

const deserializeAws_restXmlFieldLevelEncryptionProfileSummary = (
  output: any,
  context: __SerdeContext
): FieldLevelEncryptionProfileSummary => {
  let contents: any = {
    __type: "FieldLevelEncryptionProfileSummary",
    Comment: undefined,
    EncryptionEntities: undefined,
    Id: undefined,
    LastModifiedTime: undefined,
    Name: undefined,
  };
  if (output["Comment"] !== undefined) {
    contents.Comment = output["Comment"];
  }
  if (output["EncryptionEntities"] !== undefined) {
    contents.EncryptionEntities = deserializeAws_restXmlEncryptionEntities(output["EncryptionEntities"], context);
  }
  if (output["Id"] !== undefined) {
    contents.Id = output["Id"];
  }
  if (output["LastModifiedTime"] !== undefined) {
    contents.LastModifiedTime = new Date(output["LastModifiedTime"]);
  }
  if (output["Name"] !== undefined) {
    contents.Name = output["Name"];
  }
  return contents;
};

const deserializeAws_restXmlFieldLevelEncryptionProfileSummaryList = (
  output: any,
  context: __SerdeContext
): FieldLevelEncryptionProfileSummary[] => {
  return (output || []).map((entry: any) => deserializeAws_restXmlFieldLevelEncryptionProfileSummary(entry, context));
};

const deserializeAws_restXmlFieldLevelEncryptionSummary = (
  output: any,
  context: __SerdeContext
): FieldLevelEncryptionSummary => {
  let contents: any = {
    __type: "FieldLevelEncryptionSummary",
    Comment: undefined,
    ContentTypeProfileConfig: undefined,
    Id: undefined,
    LastModifiedTime: undefined,
    QueryArgProfileConfig: undefined,
  };
  if (output["Comment"] !== undefined) {
    contents.Comment = output["Comment"];
  }
  if (output["ContentTypeProfileConfig"] !== undefined) {
    contents.ContentTypeProfileConfig = deserializeAws_restXmlContentTypeProfileConfig(
      output["ContentTypeProfileConfig"],
      context
    );
  }
  if (output["Id"] !== undefined) {
    contents.Id = output["Id"];
  }
  if (output["LastModifiedTime"] !== undefined) {
    contents.LastModifiedTime = new Date(output["LastModifiedTime"]);
  }
  if (output["QueryArgProfileConfig"] !== undefined) {
    contents.QueryArgProfileConfig = deserializeAws_restXmlQueryArgProfileConfig(
      output["QueryArgProfileConfig"],
      context
    );
  }
  return contents;
};

const deserializeAws_restXmlFieldLevelEncryptionSummaryList = (
  output: any,
  context: __SerdeContext
): FieldLevelEncryptionSummary[] => {
  return (output || []).map((entry: any) => deserializeAws_restXmlFieldLevelEncryptionSummary(entry, context));
};

const deserializeAws_restXmlFieldPatternList = (output: any, context: __SerdeContext): string[] => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_restXmlFieldPatterns = (output: any, context: __SerdeContext): FieldPatterns => {
  let contents: any = {
    __type: "FieldPatterns",
    Items: undefined,
    Quantity: undefined,
  };
  if (output.Items === "") {
    contents.Items = [];
  }
  if (output["Items"] !== undefined && output["Items"]["FieldPattern"] !== undefined) {
    contents.Items = deserializeAws_restXmlFieldPatternList(
      __getArrayIfSingleItem(output["Items"]["FieldPattern"]),
      context
    );
  }
  if (output["Quantity"] !== undefined) {
    contents.Quantity = parseInt(output["Quantity"]);
  }
  return contents;
};

const deserializeAws_restXmlForwardedValues = (output: any, context: __SerdeContext): ForwardedValues => {
  let contents: any = {
    __type: "ForwardedValues",
    Cookies: undefined,
    Headers: undefined,
    QueryString: undefined,
    QueryStringCacheKeys: undefined,
  };
  if (output["Cookies"] !== undefined) {
    contents.Cookies = deserializeAws_restXmlCookiePreference(output["Cookies"], context);
  }
  if (output["Headers"] !== undefined) {
    contents.Headers = deserializeAws_restXmlHeaders(output["Headers"], context);
  }
  if (output["QueryString"] !== undefined) {
    contents.QueryString = output["QueryString"] == "true";
  }
  if (output["QueryStringCacheKeys"] !== undefined) {
    contents.QueryStringCacheKeys = deserializeAws_restXmlQueryStringCacheKeys(output["QueryStringCacheKeys"], context);
  }
  return contents;
};

const deserializeAws_restXmlGeoRestriction = (output: any, context: __SerdeContext): GeoRestriction => {
  let contents: any = {
    __type: "GeoRestriction",
    Items: undefined,
    Quantity: undefined,
    RestrictionType: undefined,
  };
  if (output.Items === "") {
    contents.Items = [];
  }
  if (output["Items"] !== undefined && output["Items"]["Location"] !== undefined) {
    contents.Items = deserializeAws_restXmlLocationList(__getArrayIfSingleItem(output["Items"]["Location"]), context);
  }
  if (output["Quantity"] !== undefined) {
    contents.Quantity = parseInt(output["Quantity"]);
  }
  if (output["RestrictionType"] !== undefined) {
    contents.RestrictionType = output["RestrictionType"];
  }
  return contents;
};

const deserializeAws_restXmlHeaderList = (output: any, context: __SerdeContext): string[] => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_restXmlHeaders = (output: any, context: __SerdeContext): Headers => {
  let contents: any = {
    __type: "Headers",
    Items: undefined,
    Quantity: undefined,
  };
  if (output.Items === "") {
    contents.Items = [];
  }
  if (output["Items"] !== undefined && output["Items"]["Name"] !== undefined) {
    contents.Items = deserializeAws_restXmlHeaderList(__getArrayIfSingleItem(output["Items"]["Name"]), context);
  }
  if (output["Quantity"] !== undefined) {
    contents.Quantity = parseInt(output["Quantity"]);
  }
  return contents;
};

const deserializeAws_restXmlInvalidation = (output: any, context: __SerdeContext): Invalidation => {
  let contents: any = {
    __type: "Invalidation",
    CreateTime: undefined,
    Id: undefined,
    InvalidationBatch: undefined,
    Status: undefined,
  };
  if (output["CreateTime"] !== undefined) {
    contents.CreateTime = new Date(output["CreateTime"]);
  }
  if (output["Id"] !== undefined) {
    contents.Id = output["Id"];
  }
  if (output["InvalidationBatch"] !== undefined) {
    contents.InvalidationBatch = deserializeAws_restXmlInvalidationBatch(output["InvalidationBatch"], context);
  }
  if (output["Status"] !== undefined) {
    contents.Status = output["Status"];
  }
  return contents;
};

const deserializeAws_restXmlInvalidationBatch = (output: any, context: __SerdeContext): InvalidationBatch => {
  let contents: any = {
    __type: "InvalidationBatch",
    CallerReference: undefined,
    Paths: undefined,
  };
  if (output["CallerReference"] !== undefined) {
    contents.CallerReference = output["CallerReference"];
  }
  if (output["Paths"] !== undefined) {
    contents.Paths = deserializeAws_restXmlPaths(output["Paths"], context);
  }
  return contents;
};

const deserializeAws_restXmlInvalidationList = (output: any, context: __SerdeContext): InvalidationList => {
  let contents: any = {
    __type: "InvalidationList",
    IsTruncated: undefined,
    Items: undefined,
    Marker: undefined,
    MaxItems: undefined,
    NextMarker: undefined,
    Quantity: undefined,
  };
  if (output["IsTruncated"] !== undefined) {
    contents.IsTruncated = output["IsTruncated"] == "true";
  }
  if (output.Items === "") {
    contents.Items = [];
  }
  if (output["Items"] !== undefined && output["Items"]["InvalidationSummary"] !== undefined) {
    contents.Items = deserializeAws_restXmlInvalidationSummaryList(
      __getArrayIfSingleItem(output["Items"]["InvalidationSummary"]),
      context
    );
  }
  if (output["Marker"] !== undefined) {
    contents.Marker = output["Marker"];
  }
  if (output["MaxItems"] !== undefined) {
    contents.MaxItems = parseInt(output["MaxItems"]);
  }
  if (output["NextMarker"] !== undefined) {
    contents.NextMarker = output["NextMarker"];
  }
  if (output["Quantity"] !== undefined) {
    contents.Quantity = parseInt(output["Quantity"]);
  }
  return contents;
};

const deserializeAws_restXmlInvalidationSummary = (output: any, context: __SerdeContext): InvalidationSummary => {
  let contents: any = {
    __type: "InvalidationSummary",
    CreateTime: undefined,
    Id: undefined,
    Status: undefined,
  };
  if (output["CreateTime"] !== undefined) {
    contents.CreateTime = new Date(output["CreateTime"]);
  }
  if (output["Id"] !== undefined) {
    contents.Id = output["Id"];
  }
  if (output["Status"] !== undefined) {
    contents.Status = output["Status"];
  }
  return contents;
};

const deserializeAws_restXmlInvalidationSummaryList = (output: any, context: __SerdeContext): InvalidationSummary[] => {
  return (output || []).map((entry: any) => deserializeAws_restXmlInvalidationSummary(entry, context));
};

const deserializeAws_restXmlKeyPairIdList = (output: any, context: __SerdeContext): string[] => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_restXmlKeyPairIds = (output: any, context: __SerdeContext): KeyPairIds => {
  let contents: any = {
    __type: "KeyPairIds",
    Items: undefined,
    Quantity: undefined,
  };
  if (output.Items === "") {
    contents.Items = [];
  }
  if (output["Items"] !== undefined && output["Items"]["KeyPairId"] !== undefined) {
    contents.Items = deserializeAws_restXmlKeyPairIdList(__getArrayIfSingleItem(output["Items"]["KeyPairId"]), context);
  }
  if (output["Quantity"] !== undefined) {
    contents.Quantity = parseInt(output["Quantity"]);
  }
  return contents;
};

const deserializeAws_restXmlLambdaFunctionAssociation = (
  output: any,
  context: __SerdeContext
): LambdaFunctionAssociation => {
  let contents: any = {
    __type: "LambdaFunctionAssociation",
    EventType: undefined,
    IncludeBody: undefined,
    LambdaFunctionARN: undefined,
  };
  if (output["EventType"] !== undefined) {
    contents.EventType = output["EventType"];
  }
  if (output["IncludeBody"] !== undefined) {
    contents.IncludeBody = output["IncludeBody"] == "true";
  }
  if (output["LambdaFunctionARN"] !== undefined) {
    contents.LambdaFunctionARN = output["LambdaFunctionARN"];
  }
  return contents;
};

const deserializeAws_restXmlLambdaFunctionAssociationList = (
  output: any,
  context: __SerdeContext
): LambdaFunctionAssociation[] => {
  return (output || []).map((entry: any) => deserializeAws_restXmlLambdaFunctionAssociation(entry, context));
};

const deserializeAws_restXmlLambdaFunctionAssociations = (
  output: any,
  context: __SerdeContext
): LambdaFunctionAssociations => {
  let contents: any = {
    __type: "LambdaFunctionAssociations",
    Items: undefined,
    Quantity: undefined,
  };
  if (output.Items === "") {
    contents.Items = [];
  }
  if (output["Items"] !== undefined && output["Items"]["LambdaFunctionAssociation"] !== undefined) {
    contents.Items = deserializeAws_restXmlLambdaFunctionAssociationList(
      __getArrayIfSingleItem(output["Items"]["LambdaFunctionAssociation"]),
      context
    );
  }
  if (output["Quantity"] !== undefined) {
    contents.Quantity = parseInt(output["Quantity"]);
  }
  return contents;
};

const deserializeAws_restXmlLocationList = (output: any, context: __SerdeContext): string[] => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_restXmlLoggingConfig = (output: any, context: __SerdeContext): LoggingConfig => {
  let contents: any = {
    __type: "LoggingConfig",
    Bucket: undefined,
    Enabled: undefined,
    IncludeCookies: undefined,
    Prefix: undefined,
  };
  if (output["Bucket"] !== undefined) {
    contents.Bucket = output["Bucket"];
  }
  if (output["Enabled"] !== undefined) {
    contents.Enabled = output["Enabled"] == "true";
  }
  if (output["IncludeCookies"] !== undefined) {
    contents.IncludeCookies = output["IncludeCookies"] == "true";
  }
  if (output["Prefix"] !== undefined) {
    contents.Prefix = output["Prefix"];
  }
  return contents;
};

const deserializeAws_restXmlMethodsList = (output: any, context: __SerdeContext): (Method | string)[] => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_restXmlOrigin = (output: any, context: __SerdeContext): Origin => {
  let contents: any = {
    __type: "Origin",
    CustomHeaders: undefined,
    CustomOriginConfig: undefined,
    DomainName: undefined,
    Id: undefined,
    OriginPath: undefined,
    S3OriginConfig: undefined,
  };
  if (output["CustomHeaders"] !== undefined) {
    contents.CustomHeaders = deserializeAws_restXmlCustomHeaders(output["CustomHeaders"], context);
  }
  if (output["CustomOriginConfig"] !== undefined) {
    contents.CustomOriginConfig = deserializeAws_restXmlCustomOriginConfig(output["CustomOriginConfig"], context);
  }
  if (output["DomainName"] !== undefined) {
    contents.DomainName = output["DomainName"];
  }
  if (output["Id"] !== undefined) {
    contents.Id = output["Id"];
  }
  if (output["OriginPath"] !== undefined) {
    contents.OriginPath = output["OriginPath"];
  }
  if (output["S3OriginConfig"] !== undefined) {
    contents.S3OriginConfig = deserializeAws_restXmlS3OriginConfig(output["S3OriginConfig"], context);
  }
  return contents;
};

const deserializeAws_restXmlOriginCustomHeader = (output: any, context: __SerdeContext): OriginCustomHeader => {
  let contents: any = {
    __type: "OriginCustomHeader",
    HeaderName: undefined,
    HeaderValue: undefined,
  };
  if (output["HeaderName"] !== undefined) {
    contents.HeaderName = output["HeaderName"];
  }
  if (output["HeaderValue"] !== undefined) {
    contents.HeaderValue = output["HeaderValue"];
  }
  return contents;
};

const deserializeAws_restXmlOriginCustomHeadersList = (output: any, context: __SerdeContext): OriginCustomHeader[] => {
  return (output || []).map((entry: any) => deserializeAws_restXmlOriginCustomHeader(entry, context));
};

const deserializeAws_restXmlOriginGroup = (output: any, context: __SerdeContext): OriginGroup => {
  let contents: any = {
    __type: "OriginGroup",
    FailoverCriteria: undefined,
    Id: undefined,
    Members: undefined,
  };
  if (output["FailoverCriteria"] !== undefined) {
    contents.FailoverCriteria = deserializeAws_restXmlOriginGroupFailoverCriteria(output["FailoverCriteria"], context);
  }
  if (output["Id"] !== undefined) {
    contents.Id = output["Id"];
  }
  if (output["Members"] !== undefined) {
    contents.Members = deserializeAws_restXmlOriginGroupMembers(output["Members"], context);
  }
  return contents;
};

const deserializeAws_restXmlOriginGroupFailoverCriteria = (
  output: any,
  context: __SerdeContext
): OriginGroupFailoverCriteria => {
  let contents: any = {
    __type: "OriginGroupFailoverCriteria",
    StatusCodes: undefined,
  };
  if (output["StatusCodes"] !== undefined) {
    contents.StatusCodes = deserializeAws_restXmlStatusCodes(output["StatusCodes"], context);
  }
  return contents;
};

const deserializeAws_restXmlOriginGroupList = (output: any, context: __SerdeContext): OriginGroup[] => {
  return (output || []).map((entry: any) => deserializeAws_restXmlOriginGroup(entry, context));
};

const deserializeAws_restXmlOriginGroupMember = (output: any, context: __SerdeContext): OriginGroupMember => {
  let contents: any = {
    __type: "OriginGroupMember",
    OriginId: undefined,
  };
  if (output["OriginId"] !== undefined) {
    contents.OriginId = output["OriginId"];
  }
  return contents;
};

const deserializeAws_restXmlOriginGroupMemberList = (output: any, context: __SerdeContext): OriginGroupMember[] => {
  return (output || []).map((entry: any) => deserializeAws_restXmlOriginGroupMember(entry, context));
};

const deserializeAws_restXmlOriginGroupMembers = (output: any, context: __SerdeContext): OriginGroupMembers => {
  let contents: any = {
    __type: "OriginGroupMembers",
    Items: undefined,
    Quantity: undefined,
  };
  if (output.Items === "") {
    contents.Items = [];
  }
  if (output["Items"] !== undefined && output["Items"]["OriginGroupMember"] !== undefined) {
    contents.Items = deserializeAws_restXmlOriginGroupMemberList(
      __getArrayIfSingleItem(output["Items"]["OriginGroupMember"]),
      context
    );
  }
  if (output["Quantity"] !== undefined) {
    contents.Quantity = parseInt(output["Quantity"]);
  }
  return contents;
};

const deserializeAws_restXmlOriginGroups = (output: any, context: __SerdeContext): OriginGroups => {
  let contents: any = {
    __type: "OriginGroups",
    Items: undefined,
    Quantity: undefined,
  };
  if (output.Items === "") {
    contents.Items = [];
  }
  if (output["Items"] !== undefined && output["Items"]["OriginGroup"] !== undefined) {
    contents.Items = deserializeAws_restXmlOriginGroupList(
      __getArrayIfSingleItem(output["Items"]["OriginGroup"]),
      context
    );
  }
  if (output["Quantity"] !== undefined) {
    contents.Quantity = parseInt(output["Quantity"]);
  }
  return contents;
};

const deserializeAws_restXmlOriginList = (output: any, context: __SerdeContext): Origin[] => {
  return (output || []).map((entry: any) => deserializeAws_restXmlOrigin(entry, context));
};

const deserializeAws_restXmlOrigins = (output: any, context: __SerdeContext): Origins => {
  let contents: any = {
    __type: "Origins",
    Items: undefined,
    Quantity: undefined,
  };
  if (output.Items === "") {
    contents.Items = [];
  }
  if (output["Items"] !== undefined && output["Items"]["Origin"] !== undefined) {
    contents.Items = deserializeAws_restXmlOriginList(__getArrayIfSingleItem(output["Items"]["Origin"]), context);
  }
  if (output["Quantity"] !== undefined) {
    contents.Quantity = parseInt(output["Quantity"]);
  }
  return contents;
};

const deserializeAws_restXmlOriginSslProtocols = (output: any, context: __SerdeContext): OriginSslProtocols => {
  let contents: any = {
    __type: "OriginSslProtocols",
    Items: undefined,
    Quantity: undefined,
  };
  if (output.Items === "") {
    contents.Items = [];
  }
  if (output["Items"] !== undefined && output["Items"]["SslProtocol"] !== undefined) {
    contents.Items = deserializeAws_restXmlSslProtocolsList(
      __getArrayIfSingleItem(output["Items"]["SslProtocol"]),
      context
    );
  }
  if (output["Quantity"] !== undefined) {
    contents.Quantity = parseInt(output["Quantity"]);
  }
  return contents;
};

const deserializeAws_restXmlPathList = (output: any, context: __SerdeContext): string[] => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_restXmlPaths = (output: any, context: __SerdeContext): Paths => {
  let contents: any = {
    __type: "Paths",
    Items: undefined,
    Quantity: undefined,
  };
  if (output.Items === "") {
    contents.Items = [];
  }
  if (output["Items"] !== undefined && output["Items"]["Path"] !== undefined) {
    contents.Items = deserializeAws_restXmlPathList(__getArrayIfSingleItem(output["Items"]["Path"]), context);
  }
  if (output["Quantity"] !== undefined) {
    contents.Quantity = parseInt(output["Quantity"]);
  }
  return contents;
};

const deserializeAws_restXmlPublicKey = (output: any, context: __SerdeContext): PublicKey => {
  let contents: any = {
    __type: "PublicKey",
    CreatedTime: undefined,
    Id: undefined,
    PublicKeyConfig: undefined,
  };
  if (output["CreatedTime"] !== undefined) {
    contents.CreatedTime = new Date(output["CreatedTime"]);
  }
  if (output["Id"] !== undefined) {
    contents.Id = output["Id"];
  }
  if (output["PublicKeyConfig"] !== undefined) {
    contents.PublicKeyConfig = deserializeAws_restXmlPublicKeyConfig(output["PublicKeyConfig"], context);
  }
  return contents;
};

const deserializeAws_restXmlPublicKeyConfig = (output: any, context: __SerdeContext): PublicKeyConfig => {
  let contents: any = {
    __type: "PublicKeyConfig",
    CallerReference: undefined,
    Comment: undefined,
    EncodedKey: undefined,
    Name: undefined,
  };
  if (output["CallerReference"] !== undefined) {
    contents.CallerReference = output["CallerReference"];
  }
  if (output["Comment"] !== undefined) {
    contents.Comment = output["Comment"];
  }
  if (output["EncodedKey"] !== undefined) {
    contents.EncodedKey = output["EncodedKey"];
  }
  if (output["Name"] !== undefined) {
    contents.Name = output["Name"];
  }
  return contents;
};

const deserializeAws_restXmlPublicKeyList = (output: any, context: __SerdeContext): PublicKeyList => {
  let contents: any = {
    __type: "PublicKeyList",
    Items: undefined,
    MaxItems: undefined,
    NextMarker: undefined,
    Quantity: undefined,
  };
  if (output.Items === "") {
    contents.Items = [];
  }
  if (output["Items"] !== undefined && output["Items"]["PublicKeySummary"] !== undefined) {
    contents.Items = deserializeAws_restXmlPublicKeySummaryList(
      __getArrayIfSingleItem(output["Items"]["PublicKeySummary"]),
      context
    );
  }
  if (output["MaxItems"] !== undefined) {
    contents.MaxItems = parseInt(output["MaxItems"]);
  }
  if (output["NextMarker"] !== undefined) {
    contents.NextMarker = output["NextMarker"];
  }
  if (output["Quantity"] !== undefined) {
    contents.Quantity = parseInt(output["Quantity"]);
  }
  return contents;
};

const deserializeAws_restXmlPublicKeySummary = (output: any, context: __SerdeContext): PublicKeySummary => {
  let contents: any = {
    __type: "PublicKeySummary",
    Comment: undefined,
    CreatedTime: undefined,
    EncodedKey: undefined,
    Id: undefined,
    Name: undefined,
  };
  if (output["Comment"] !== undefined) {
    contents.Comment = output["Comment"];
  }
  if (output["CreatedTime"] !== undefined) {
    contents.CreatedTime = new Date(output["CreatedTime"]);
  }
  if (output["EncodedKey"] !== undefined) {
    contents.EncodedKey = output["EncodedKey"];
  }
  if (output["Id"] !== undefined) {
    contents.Id = output["Id"];
  }
  if (output["Name"] !== undefined) {
    contents.Name = output["Name"];
  }
  return contents;
};

const deserializeAws_restXmlPublicKeySummaryList = (output: any, context: __SerdeContext): PublicKeySummary[] => {
  return (output || []).map((entry: any) => deserializeAws_restXmlPublicKeySummary(entry, context));
};

const deserializeAws_restXmlQueryArgProfile = (output: any, context: __SerdeContext): QueryArgProfile => {
  let contents: any = {
    __type: "QueryArgProfile",
    ProfileId: undefined,
    QueryArg: undefined,
  };
  if (output["ProfileId"] !== undefined) {
    contents.ProfileId = output["ProfileId"];
  }
  if (output["QueryArg"] !== undefined) {
    contents.QueryArg = output["QueryArg"];
  }
  return contents;
};

const deserializeAws_restXmlQueryArgProfileConfig = (output: any, context: __SerdeContext): QueryArgProfileConfig => {
  let contents: any = {
    __type: "QueryArgProfileConfig",
    ForwardWhenQueryArgProfileIsUnknown: undefined,
    QueryArgProfiles: undefined,
  };
  if (output["ForwardWhenQueryArgProfileIsUnknown"] !== undefined) {
    contents.ForwardWhenQueryArgProfileIsUnknown = output["ForwardWhenQueryArgProfileIsUnknown"] == "true";
  }
  if (output["QueryArgProfiles"] !== undefined) {
    contents.QueryArgProfiles = deserializeAws_restXmlQueryArgProfiles(output["QueryArgProfiles"], context);
  }
  return contents;
};

const deserializeAws_restXmlQueryArgProfileList = (output: any, context: __SerdeContext): QueryArgProfile[] => {
  return (output || []).map((entry: any) => deserializeAws_restXmlQueryArgProfile(entry, context));
};

const deserializeAws_restXmlQueryArgProfiles = (output: any, context: __SerdeContext): QueryArgProfiles => {
  let contents: any = {
    __type: "QueryArgProfiles",
    Items: undefined,
    Quantity: undefined,
  };
  if (output.Items === "") {
    contents.Items = [];
  }
  if (output["Items"] !== undefined && output["Items"]["QueryArgProfile"] !== undefined) {
    contents.Items = deserializeAws_restXmlQueryArgProfileList(
      __getArrayIfSingleItem(output["Items"]["QueryArgProfile"]),
      context
    );
  }
  if (output["Quantity"] !== undefined) {
    contents.Quantity = parseInt(output["Quantity"]);
  }
  return contents;
};

const deserializeAws_restXmlQueryStringCacheKeys = (output: any, context: __SerdeContext): QueryStringCacheKeys => {
  let contents: any = {
    __type: "QueryStringCacheKeys",
    Items: undefined,
    Quantity: undefined,
  };
  if (output.Items === "") {
    contents.Items = [];
  }
  if (output["Items"] !== undefined && output["Items"]["Name"] !== undefined) {
    contents.Items = deserializeAws_restXmlQueryStringCacheKeysList(
      __getArrayIfSingleItem(output["Items"]["Name"]),
      context
    );
  }
  if (output["Quantity"] !== undefined) {
    contents.Quantity = parseInt(output["Quantity"]);
  }
  return contents;
};

const deserializeAws_restXmlQueryStringCacheKeysList = (output: any, context: __SerdeContext): string[] => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_restXmlRestrictions = (output: any, context: __SerdeContext): Restrictions => {
  let contents: any = {
    __type: "Restrictions",
    GeoRestriction: undefined,
  };
  if (output["GeoRestriction"] !== undefined) {
    contents.GeoRestriction = deserializeAws_restXmlGeoRestriction(output["GeoRestriction"], context);
  }
  return contents;
};

const deserializeAws_restXmlS3Origin = (output: any, context: __SerdeContext): S3Origin => {
  let contents: any = {
    __type: "S3Origin",
    DomainName: undefined,
    OriginAccessIdentity: undefined,
  };
  if (output["DomainName"] !== undefined) {
    contents.DomainName = output["DomainName"];
  }
  if (output["OriginAccessIdentity"] !== undefined) {
    contents.OriginAccessIdentity = output["OriginAccessIdentity"];
  }
  return contents;
};

const deserializeAws_restXmlS3OriginConfig = (output: any, context: __SerdeContext): S3OriginConfig => {
  let contents: any = {
    __type: "S3OriginConfig",
    OriginAccessIdentity: undefined,
  };
  if (output["OriginAccessIdentity"] !== undefined) {
    contents.OriginAccessIdentity = output["OriginAccessIdentity"];
  }
  return contents;
};

const deserializeAws_restXmlSigner = (output: any, context: __SerdeContext): Signer => {
  let contents: any = {
    __type: "Signer",
    AwsAccountNumber: undefined,
    KeyPairIds: undefined,
  };
  if (output["AwsAccountNumber"] !== undefined) {
    contents.AwsAccountNumber = output["AwsAccountNumber"];
  }
  if (output["KeyPairIds"] !== undefined) {
    contents.KeyPairIds = deserializeAws_restXmlKeyPairIds(output["KeyPairIds"], context);
  }
  return contents;
};

const deserializeAws_restXmlSignerList = (output: any, context: __SerdeContext): Signer[] => {
  return (output || []).map((entry: any) => deserializeAws_restXmlSigner(entry, context));
};

const deserializeAws_restXmlSslProtocolsList = (output: any, context: __SerdeContext): (SslProtocol | string)[] => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_restXmlStatusCodeList = (output: any, context: __SerdeContext): number[] => {
  return (output || []).map((entry: any) => parseInt(entry));
};

const deserializeAws_restXmlStatusCodes = (output: any, context: __SerdeContext): StatusCodes => {
  let contents: any = {
    __type: "StatusCodes",
    Items: undefined,
    Quantity: undefined,
  };
  if (output.Items === "") {
    contents.Items = [];
  }
  if (output["Items"] !== undefined && output["Items"]["StatusCode"] !== undefined) {
    contents.Items = deserializeAws_restXmlStatusCodeList(
      __getArrayIfSingleItem(output["Items"]["StatusCode"]),
      context
    );
  }
  if (output["Quantity"] !== undefined) {
    contents.Quantity = parseInt(output["Quantity"]);
  }
  return contents;
};

const deserializeAws_restXmlStreamingDistribution = (output: any, context: __SerdeContext): StreamingDistribution => {
  let contents: any = {
    __type: "StreamingDistribution",
    ARN: undefined,
    ActiveTrustedSigners: undefined,
    DomainName: undefined,
    Id: undefined,
    LastModifiedTime: undefined,
    Status: undefined,
    StreamingDistributionConfig: undefined,
  };
  if (output["ARN"] !== undefined) {
    contents.ARN = output["ARN"];
  }
  if (output["ActiveTrustedSigners"] !== undefined) {
    contents.ActiveTrustedSigners = deserializeAws_restXmlActiveTrustedSigners(output["ActiveTrustedSigners"], context);
  }
  if (output["DomainName"] !== undefined) {
    contents.DomainName = output["DomainName"];
  }
  if (output["Id"] !== undefined) {
    contents.Id = output["Id"];
  }
  if (output["LastModifiedTime"] !== undefined) {
    contents.LastModifiedTime = new Date(output["LastModifiedTime"]);
  }
  if (output["Status"] !== undefined) {
    contents.Status = output["Status"];
  }
  if (output["StreamingDistributionConfig"] !== undefined) {
    contents.StreamingDistributionConfig = deserializeAws_restXmlStreamingDistributionConfig(
      output["StreamingDistributionConfig"],
      context
    );
  }
  return contents;
};

const deserializeAws_restXmlStreamingDistributionConfig = (
  output: any,
  context: __SerdeContext
): StreamingDistributionConfig => {
  let contents: any = {
    __type: "StreamingDistributionConfig",
    Aliases: undefined,
    CallerReference: undefined,
    Comment: undefined,
    Enabled: undefined,
    Logging: undefined,
    PriceClass: undefined,
    S3Origin: undefined,
    TrustedSigners: undefined,
  };
  if (output["Aliases"] !== undefined) {
    contents.Aliases = deserializeAws_restXmlAliases(output["Aliases"], context);
  }
  if (output["CallerReference"] !== undefined) {
    contents.CallerReference = output["CallerReference"];
  }
  if (output["Comment"] !== undefined) {
    contents.Comment = output["Comment"];
  }
  if (output["Enabled"] !== undefined) {
    contents.Enabled = output["Enabled"] == "true";
  }
  if (output["Logging"] !== undefined) {
    contents.Logging = deserializeAws_restXmlStreamingLoggingConfig(output["Logging"], context);
  }
  if (output["PriceClass"] !== undefined) {
    contents.PriceClass = output["PriceClass"];
  }
  if (output["S3Origin"] !== undefined) {
    contents.S3Origin = deserializeAws_restXmlS3Origin(output["S3Origin"], context);
  }
  if (output["TrustedSigners"] !== undefined) {
    contents.TrustedSigners = deserializeAws_restXmlTrustedSigners(output["TrustedSigners"], context);
  }
  return contents;
};

const deserializeAws_restXmlStreamingDistributionList = (
  output: any,
  context: __SerdeContext
): StreamingDistributionList => {
  let contents: any = {
    __type: "StreamingDistributionList",
    IsTruncated: undefined,
    Items: undefined,
    Marker: undefined,
    MaxItems: undefined,
    NextMarker: undefined,
    Quantity: undefined,
  };
  if (output["IsTruncated"] !== undefined) {
    contents.IsTruncated = output["IsTruncated"] == "true";
  }
  if (output.Items === "") {
    contents.Items = [];
  }
  if (output["Items"] !== undefined && output["Items"]["StreamingDistributionSummary"] !== undefined) {
    contents.Items = deserializeAws_restXmlStreamingDistributionSummaryList(
      __getArrayIfSingleItem(output["Items"]["StreamingDistributionSummary"]),
      context
    );
  }
  if (output["Marker"] !== undefined) {
    contents.Marker = output["Marker"];
  }
  if (output["MaxItems"] !== undefined) {
    contents.MaxItems = parseInt(output["MaxItems"]);
  }
  if (output["NextMarker"] !== undefined) {
    contents.NextMarker = output["NextMarker"];
  }
  if (output["Quantity"] !== undefined) {
    contents.Quantity = parseInt(output["Quantity"]);
  }
  return contents;
};

const deserializeAws_restXmlStreamingDistributionSummary = (
  output: any,
  context: __SerdeContext
): StreamingDistributionSummary => {
  let contents: any = {
    __type: "StreamingDistributionSummary",
    ARN: undefined,
    Aliases: undefined,
    Comment: undefined,
    DomainName: undefined,
    Enabled: undefined,
    Id: undefined,
    LastModifiedTime: undefined,
    PriceClass: undefined,
    S3Origin: undefined,
    Status: undefined,
    TrustedSigners: undefined,
  };
  if (output["ARN"] !== undefined) {
    contents.ARN = output["ARN"];
  }
  if (output["Aliases"] !== undefined) {
    contents.Aliases = deserializeAws_restXmlAliases(output["Aliases"], context);
  }
  if (output["Comment"] !== undefined) {
    contents.Comment = output["Comment"];
  }
  if (output["DomainName"] !== undefined) {
    contents.DomainName = output["DomainName"];
  }
  if (output["Enabled"] !== undefined) {
    contents.Enabled = output["Enabled"] == "true";
  }
  if (output["Id"] !== undefined) {
    contents.Id = output["Id"];
  }
  if (output["LastModifiedTime"] !== undefined) {
    contents.LastModifiedTime = new Date(output["LastModifiedTime"]);
  }
  if (output["PriceClass"] !== undefined) {
    contents.PriceClass = output["PriceClass"];
  }
  if (output["S3Origin"] !== undefined) {
    contents.S3Origin = deserializeAws_restXmlS3Origin(output["S3Origin"], context);
  }
  if (output["Status"] !== undefined) {
    contents.Status = output["Status"];
  }
  if (output["TrustedSigners"] !== undefined) {
    contents.TrustedSigners = deserializeAws_restXmlTrustedSigners(output["TrustedSigners"], context);
  }
  return contents;
};

const deserializeAws_restXmlStreamingDistributionSummaryList = (
  output: any,
  context: __SerdeContext
): StreamingDistributionSummary[] => {
  return (output || []).map((entry: any) => deserializeAws_restXmlStreamingDistributionSummary(entry, context));
};

const deserializeAws_restXmlStreamingLoggingConfig = (output: any, context: __SerdeContext): StreamingLoggingConfig => {
  let contents: any = {
    __type: "StreamingLoggingConfig",
    Bucket: undefined,
    Enabled: undefined,
    Prefix: undefined,
  };
  if (output["Bucket"] !== undefined) {
    contents.Bucket = output["Bucket"];
  }
  if (output["Enabled"] !== undefined) {
    contents.Enabled = output["Enabled"] == "true";
  }
  if (output["Prefix"] !== undefined) {
    contents.Prefix = output["Prefix"];
  }
  return contents;
};

const deserializeAws_restXmlTag = (output: any, context: __SerdeContext): Tag => {
  let contents: any = {
    __type: "Tag",
    Key: undefined,
    Value: undefined,
  };
  if (output["Key"] !== undefined) {
    contents.Key = output["Key"];
  }
  if (output["Value"] !== undefined) {
    contents.Value = output["Value"];
  }
  return contents;
};

const deserializeAws_restXmlTagList = (output: any, context: __SerdeContext): Tag[] => {
  return (output || []).map((entry: any) => deserializeAws_restXmlTag(entry, context));
};

const deserializeAws_restXmlTags = (output: any, context: __SerdeContext): Tags => {
  let contents: any = {
    __type: "Tags",
    Items: undefined,
  };
  if (output.Items === "") {
    contents.Items = [];
  }
  if (output["Items"] !== undefined && output["Items"]["Tag"] !== undefined) {
    contents.Items = deserializeAws_restXmlTagList(__getArrayIfSingleItem(output["Items"]["Tag"]), context);
  }
  return contents;
};

const deserializeAws_restXmlTrustedSigners = (output: any, context: __SerdeContext): TrustedSigners => {
  let contents: any = {
    __type: "TrustedSigners",
    Enabled: undefined,
    Items: undefined,
    Quantity: undefined,
  };
  if (output["Enabled"] !== undefined) {
    contents.Enabled = output["Enabled"] == "true";
  }
  if (output.Items === "") {
    contents.Items = [];
  }
  if (output["Items"] !== undefined && output["Items"]["AwsAccountNumber"] !== undefined) {
    contents.Items = deserializeAws_restXmlAwsAccountNumberList(
      __getArrayIfSingleItem(output["Items"]["AwsAccountNumber"]),
      context
    );
  }
  if (output["Quantity"] !== undefined) {
    contents.Quantity = parseInt(output["Quantity"]);
  }
  return contents;
};

const deserializeAws_restXmlViewerCertificate = (output: any, context: __SerdeContext): ViewerCertificate => {
  let contents: any = {
    __type: "ViewerCertificate",
    ACMCertificateArn: undefined,
    Certificate: undefined,
    CertificateSource: undefined,
    CloudFrontDefaultCertificate: undefined,
    IAMCertificateId: undefined,
    MinimumProtocolVersion: undefined,
    SSLSupportMethod: undefined,
  };
  if (output["ACMCertificateArn"] !== undefined) {
    contents.ACMCertificateArn = output["ACMCertificateArn"];
  }
  if (output["Certificate"] !== undefined) {
    contents.Certificate = output["Certificate"];
  }
  if (output["CertificateSource"] !== undefined) {
    contents.CertificateSource = output["CertificateSource"];
  }
  if (output["CloudFrontDefaultCertificate"] !== undefined) {
    contents.CloudFrontDefaultCertificate = output["CloudFrontDefaultCertificate"] == "true";
  }
  if (output["IAMCertificateId"] !== undefined) {
    contents.IAMCertificateId = output["IAMCertificateId"];
  }
  if (output["MinimumProtocolVersion"] !== undefined) {
    contents.MinimumProtocolVersion = output["MinimumProtocolVersion"];
  }
  if (output["SSLSupportMethod"] !== undefined) {
    contents.SSLSupportMethod = output["SSLSupportMethod"];
  }
  return contents;
};

const deserializeMetadata = (output: __HttpResponse): __ResponseMetadata => ({
  httpStatusCode: output.statusCode,
  httpHeaders: output.headers,
  requestId: output.headers["x-amzn-requestid"],
});

// Collect low-level response body stream to Uint8Array.
const collectBody = (streamBody: any = new Uint8Array(), context: __SerdeContext): Promise<Uint8Array> => {
  if (streamBody instanceof Uint8Array) {
    return Promise.resolve(streamBody);
  }
  return context.streamCollector(streamBody) || Promise.resolve(new Uint8Array());
};

// Encode Uint8Array data into string with utf-8.
const collectBodyString = (streamBody: any, context: __SerdeContext): Promise<string> =>
  collectBody(streamBody, context).then((body) => context.utf8Encoder(body));

const isSerializableHeaderValue = (value: any): boolean =>
  value !== undefined &&
  value !== "" &&
  (!Object.getOwnPropertyNames(value).includes("length") || value.length != 0) &&
  (!Object.getOwnPropertyNames(value).includes("size") || value.size != 0);

const decodeEscapedXML = (str: string) =>
  str
    .replace(/&amp;/g, "&")
    .replace(/&apos;/g, "'")
    .replace(/&quot;/g, '"')
    .replace(/&gt;/g, ">")
    .replace(/&lt;/g, "<");

const parseBody = (streamBody: any, context: __SerdeContext): any =>
  collectBodyString(streamBody, context).then((encoded) => {
    if (encoded.length) {
      const parsedObj = xmlParse(encoded, {
        attributeNamePrefix: "",
        ignoreAttributes: false,
        parseNodeValue: false,
        tagValueProcessor: (val, tagName) => decodeEscapedXML(val),
      });
      const textNodeName = "#text";
      const key = Object.keys(parsedObj)[0];
      const parsedObjToReturn = parsedObj[key];
      if (parsedObjToReturn[textNodeName]) {
        parsedObjToReturn[key] = parsedObjToReturn[textNodeName];
        delete parsedObjToReturn[textNodeName];
      }
      return __getValueFromTextNode(parsedObjToReturn);
    }
    return {};
  });

const loadRestXmlErrorCode = (output: __HttpResponse, data: any): string => {
  if (data.Error.Code !== undefined) {
    return data.Error.Code;
  }
  if (output.statusCode == 404) {
    return "NotFound";
  }
  return "";
};
