import {
  CreateCloudFrontOriginAccessIdentityCommandInput,
  CreateCloudFrontOriginAccessIdentityCommandOutput
} from "../commands/CreateCloudFrontOriginAccessIdentityCommand";
import {
  CreateDistributionCommandInput,
  CreateDistributionCommandOutput
} from "../commands/CreateDistributionCommand";
import {
  CreateDistributionWithTagsCommandInput,
  CreateDistributionWithTagsCommandOutput
} from "../commands/CreateDistributionWithTagsCommand";
import {
  CreateFieldLevelEncryptionConfigCommandInput,
  CreateFieldLevelEncryptionConfigCommandOutput
} from "../commands/CreateFieldLevelEncryptionConfigCommand";
import {
  CreateFieldLevelEncryptionProfileCommandInput,
  CreateFieldLevelEncryptionProfileCommandOutput
} from "../commands/CreateFieldLevelEncryptionProfileCommand";
import {
  CreateInvalidationCommandInput,
  CreateInvalidationCommandOutput
} from "../commands/CreateInvalidationCommand";
import {
  CreatePublicKeyCommandInput,
  CreatePublicKeyCommandOutput
} from "../commands/CreatePublicKeyCommand";
import {
  CreateStreamingDistributionCommandInput,
  CreateStreamingDistributionCommandOutput
} from "../commands/CreateStreamingDistributionCommand";
import {
  CreateStreamingDistributionWithTagsCommandInput,
  CreateStreamingDistributionWithTagsCommandOutput
} from "../commands/CreateStreamingDistributionWithTagsCommand";
import {
  DeleteCloudFrontOriginAccessIdentityCommandInput,
  DeleteCloudFrontOriginAccessIdentityCommandOutput
} from "../commands/DeleteCloudFrontOriginAccessIdentityCommand";
import {
  DeleteDistributionCommandInput,
  DeleteDistributionCommandOutput
} from "../commands/DeleteDistributionCommand";
import {
  DeleteFieldLevelEncryptionConfigCommandInput,
  DeleteFieldLevelEncryptionConfigCommandOutput
} from "../commands/DeleteFieldLevelEncryptionConfigCommand";
import {
  DeleteFieldLevelEncryptionProfileCommandInput,
  DeleteFieldLevelEncryptionProfileCommandOutput
} from "../commands/DeleteFieldLevelEncryptionProfileCommand";
import {
  DeletePublicKeyCommandInput,
  DeletePublicKeyCommandOutput
} from "../commands/DeletePublicKeyCommand";
import {
  DeleteStreamingDistributionCommandInput,
  DeleteStreamingDistributionCommandOutput
} from "../commands/DeleteStreamingDistributionCommand";
import {
  GetCloudFrontOriginAccessIdentityCommandInput,
  GetCloudFrontOriginAccessIdentityCommandOutput
} from "../commands/GetCloudFrontOriginAccessIdentityCommand";
import {
  GetCloudFrontOriginAccessIdentityConfigCommandInput,
  GetCloudFrontOriginAccessIdentityConfigCommandOutput
} from "../commands/GetCloudFrontOriginAccessIdentityConfigCommand";
import {
  GetDistributionCommandInput,
  GetDistributionCommandOutput
} from "../commands/GetDistributionCommand";
import {
  GetDistributionConfigCommandInput,
  GetDistributionConfigCommandOutput
} from "../commands/GetDistributionConfigCommand";
import {
  GetFieldLevelEncryptionCommandInput,
  GetFieldLevelEncryptionCommandOutput
} from "../commands/GetFieldLevelEncryptionCommand";
import {
  GetFieldLevelEncryptionConfigCommandInput,
  GetFieldLevelEncryptionConfigCommandOutput
} from "../commands/GetFieldLevelEncryptionConfigCommand";
import {
  GetFieldLevelEncryptionProfileCommandInput,
  GetFieldLevelEncryptionProfileCommandOutput
} from "../commands/GetFieldLevelEncryptionProfileCommand";
import {
  GetFieldLevelEncryptionProfileConfigCommandInput,
  GetFieldLevelEncryptionProfileConfigCommandOutput
} from "../commands/GetFieldLevelEncryptionProfileConfigCommand";
import {
  GetInvalidationCommandInput,
  GetInvalidationCommandOutput
} from "../commands/GetInvalidationCommand";
import {
  GetPublicKeyCommandInput,
  GetPublicKeyCommandOutput
} from "../commands/GetPublicKeyCommand";
import {
  GetPublicKeyConfigCommandInput,
  GetPublicKeyConfigCommandOutput
} from "../commands/GetPublicKeyConfigCommand";
import {
  GetStreamingDistributionCommandInput,
  GetStreamingDistributionCommandOutput
} from "../commands/GetStreamingDistributionCommand";
import {
  GetStreamingDistributionConfigCommandInput,
  GetStreamingDistributionConfigCommandOutput
} from "../commands/GetStreamingDistributionConfigCommand";
import {
  ListCloudFrontOriginAccessIdentitiesCommandInput,
  ListCloudFrontOriginAccessIdentitiesCommandOutput
} from "../commands/ListCloudFrontOriginAccessIdentitiesCommand";
import {
  ListDistributionsByWebACLIdCommandInput,
  ListDistributionsByWebACLIdCommandOutput
} from "../commands/ListDistributionsByWebACLIdCommand";
import {
  ListDistributionsCommandInput,
  ListDistributionsCommandOutput
} from "../commands/ListDistributionsCommand";
import {
  ListFieldLevelEncryptionConfigsCommandInput,
  ListFieldLevelEncryptionConfigsCommandOutput
} from "../commands/ListFieldLevelEncryptionConfigsCommand";
import {
  ListFieldLevelEncryptionProfilesCommandInput,
  ListFieldLevelEncryptionProfilesCommandOutput
} from "../commands/ListFieldLevelEncryptionProfilesCommand";
import {
  ListInvalidationsCommandInput,
  ListInvalidationsCommandOutput
} from "../commands/ListInvalidationsCommand";
import {
  ListPublicKeysCommandInput,
  ListPublicKeysCommandOutput
} from "../commands/ListPublicKeysCommand";
import {
  ListStreamingDistributionsCommandInput,
  ListStreamingDistributionsCommandOutput
} from "../commands/ListStreamingDistributionsCommand";
import {
  ListTagsForResourceCommandInput,
  ListTagsForResourceCommandOutput
} from "../commands/ListTagsForResourceCommand";
import {
  TagResourceCommandInput,
  TagResourceCommandOutput
} from "../commands/TagResourceCommand";
import {
  UntagResourceCommandInput,
  UntagResourceCommandOutput
} from "../commands/UntagResourceCommand";
import {
  UpdateCloudFrontOriginAccessIdentityCommandInput,
  UpdateCloudFrontOriginAccessIdentityCommandOutput
} from "../commands/UpdateCloudFrontOriginAccessIdentityCommand";
import {
  UpdateDistributionCommandInput,
  UpdateDistributionCommandOutput
} from "../commands/UpdateDistributionCommand";
import {
  UpdateFieldLevelEncryptionConfigCommandInput,
  UpdateFieldLevelEncryptionConfigCommandOutput
} from "../commands/UpdateFieldLevelEncryptionConfigCommand";
import {
  UpdateFieldLevelEncryptionProfileCommandInput,
  UpdateFieldLevelEncryptionProfileCommandOutput
} from "../commands/UpdateFieldLevelEncryptionProfileCommand";
import {
  UpdatePublicKeyCommandInput,
  UpdatePublicKeyCommandOutput
} from "../commands/UpdatePublicKeyCommand";
import {
  UpdateStreamingDistributionCommandInput,
  UpdateStreamingDistributionCommandOutput
} from "../commands/UpdateStreamingDistributionCommand";
import {
  AccessDenied,
  ActiveTrustedSigners,
  AliasICPRecordal,
  Aliases,
  AllowedMethods,
  BatchTooLarge,
  CNAMEAlreadyExists,
  CacheBehavior,
  CacheBehaviors,
  CachedMethods,
  CannotChangeImmutablePublicKeyFields,
  CloudFrontOriginAccessIdentity,
  CloudFrontOriginAccessIdentityAlreadyExists,
  CloudFrontOriginAccessIdentityConfig,
  CloudFrontOriginAccessIdentityInUse,
  CloudFrontOriginAccessIdentityList,
  CloudFrontOriginAccessIdentitySummary,
  ContentTypeProfile,
  ContentTypeProfileConfig,
  ContentTypeProfiles,
  CookieNames,
  CookiePreference,
  CustomErrorResponse,
  CustomErrorResponses,
  CustomHeaders,
  CustomOriginConfig,
  DefaultCacheBehavior,
  Distribution,
  DistributionAlreadyExists,
  DistributionConfig,
  DistributionConfigWithTags,
  DistributionList,
  DistributionNotDisabled,
  DistributionSummary,
  EncryptionEntities,
  EncryptionEntity,
  FieldLevelEncryption,
  FieldLevelEncryptionConfig,
  FieldLevelEncryptionConfigAlreadyExists,
  FieldLevelEncryptionConfigInUse,
  FieldLevelEncryptionList,
  FieldLevelEncryptionProfile,
  FieldLevelEncryptionProfileAlreadyExists,
  FieldLevelEncryptionProfileConfig,
  FieldLevelEncryptionProfileInUse,
  FieldLevelEncryptionProfileList,
  FieldLevelEncryptionProfileSizeExceeded,
  FieldLevelEncryptionProfileSummary,
  FieldLevelEncryptionSummary,
  FieldPatterns,
  ForwardedValues,
  GeoRestriction,
  Headers,
  IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior,
  IllegalUpdate,
  InconsistentQuantities,
  InvalidArgument,
  InvalidDefaultRootObject,
  InvalidErrorCode,
  InvalidForwardCookies,
  InvalidGeoRestrictionParameter,
  InvalidHeadersForS3Origin,
  InvalidIfMatchVersion,
  InvalidLambdaFunctionAssociation,
  InvalidLocationCode,
  InvalidMinimumProtocolVersion,
  InvalidOrigin,
  InvalidOriginAccessIdentity,
  InvalidOriginKeepaliveTimeout,
  InvalidOriginReadTimeout,
  InvalidProtocolSettings,
  InvalidQueryStringParameters,
  InvalidRelativePath,
  InvalidRequiredProtocol,
  InvalidResponseCode,
  InvalidTTLOrder,
  InvalidTagging,
  InvalidViewerCertificate,
  InvalidWebACLId,
  Invalidation,
  InvalidationBatch,
  InvalidationList,
  InvalidationSummary,
  KeyPairIds,
  LambdaFunctionAssociation,
  LambdaFunctionAssociations,
  LoggingConfig,
  Method,
  MissingBody,
  NoSuchCloudFrontOriginAccessIdentity,
  NoSuchDistribution,
  NoSuchFieldLevelEncryptionConfig,
  NoSuchFieldLevelEncryptionProfile,
  NoSuchInvalidation,
  NoSuchOrigin,
  NoSuchPublicKey,
  NoSuchResource,
  NoSuchStreamingDistribution,
  Origin,
  OriginCustomHeader,
  OriginGroup,
  OriginGroupFailoverCriteria,
  OriginGroupMember,
  OriginGroupMembers,
  OriginGroups,
  OriginSslProtocols,
  Origins,
  Paths,
  PreconditionFailed,
  PublicKey,
  PublicKeyAlreadyExists,
  PublicKeyConfig,
  PublicKeyInUse,
  PublicKeyList,
  PublicKeySummary,
  QueryArgProfile,
  QueryArgProfileConfig,
  QueryArgProfileEmpty,
  QueryArgProfiles,
  QueryStringCacheKeys,
  Restrictions,
  S3Origin,
  S3OriginConfig,
  Signer,
  SslProtocol,
  StatusCodes,
  StreamingDistribution,
  StreamingDistributionAlreadyExists,
  StreamingDistributionConfig,
  StreamingDistributionConfigWithTags,
  StreamingDistributionList,
  StreamingDistributionNotDisabled,
  StreamingDistributionSummary,
  StreamingLoggingConfig,
  Tag,
  TagKeys,
  Tags,
  TooManyCacheBehaviors,
  TooManyCertificates,
  TooManyCloudFrontOriginAccessIdentities,
  TooManyCookieNamesInWhiteList,
  TooManyDistributionCNAMEs,
  TooManyDistributions,
  TooManyDistributionsAssociatedToFieldLevelEncryptionConfig,
  TooManyDistributionsWithLambdaAssociations,
  TooManyFieldLevelEncryptionConfigs,
  TooManyFieldLevelEncryptionContentTypeProfiles,
  TooManyFieldLevelEncryptionEncryptionEntities,
  TooManyFieldLevelEncryptionFieldPatterns,
  TooManyFieldLevelEncryptionProfiles,
  TooManyFieldLevelEncryptionQueryArgProfiles,
  TooManyHeadersInForwardedValues,
  TooManyInvalidationsInProgress,
  TooManyLambdaFunctionAssociations,
  TooManyOriginCustomHeaders,
  TooManyOriginGroupsPerDistribution,
  TooManyOrigins,
  TooManyPublicKeys,
  TooManyQueryStringParameters,
  TooManyStreamingDistributionCNAMEs,
  TooManyStreamingDistributions,
  TooManyTrustedSigners,
  TrustedSignerDoesNotExist,
  TrustedSigners,
  ViewerCertificate
} from "../models/index";
import {
  HttpRequest as __HttpRequest,
  HttpResponse as __HttpResponse
} from "@aws-sdk/protocol-http";
import {
  SmithyException as __SmithyException,
  extendedEncodeURIComponent as __extendedEncodeURIComponent,
  getArrayIfSingleItem as __getArrayIfSingleItem,
  getValueFromTextNode as __getValueFromTextNode
} from "@aws-sdk/smithy-client";
import {
  Endpoint as __Endpoint,
  MetadataBearer as __MetadataBearer,
  ResponseMetadata as __ResponseMetadata,
  SerdeContext as __SerdeContext
} from "@aws-sdk/types";
import {
  XmlNode as __XmlNode,
  XmlText as __XmlText
} from "@aws-sdk/xml-builder";
import { parse as xmlParse } from "fast-xml-parser";

export const serializeAws_restXmlCreateCloudFrontOriginAccessIdentityCommand = async (
  input: CreateCloudFrontOriginAccessIdentityCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/xml"
  };
  let resolvedPath = "/2019-03-26/origin-access-identity/cloudfront";
  let body: any;
  let contents: any;
  if (input.CloudFrontOriginAccessIdentityConfig !== undefined) {
    contents = serializeAws_restXmlCloudFrontOriginAccessIdentityConfig(
      input.CloudFrontOriginAccessIdentityConfig,
      context
    );
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    contents.addAttribute(
      "xmlns",
      "http://cloudfront.amazonaws.com/doc/2019-03-26/"
    );
    body += contents.toString();
  }
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restXmlCreateDistributionCommand = async (
  input: CreateDistributionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/xml"
  };
  let resolvedPath = "/2019-03-26/distribution";
  let body: any;
  let contents: any;
  if (input.DistributionConfig !== undefined) {
    contents = serializeAws_restXmlDistributionConfig(
      input.DistributionConfig,
      context
    );
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    contents.addAttribute(
      "xmlns",
      "http://cloudfront.amazonaws.com/doc/2019-03-26/"
    );
    body += contents.toString();
  }
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restXmlCreateDistributionWithTagsCommand = async (
  input: CreateDistributionWithTagsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/xml"
  };
  let resolvedPath = "/2019-03-26/distribution";
  const query: any = {
    WithTags: ""
  };
  let body: any;
  let contents: any;
  if (input.DistributionConfigWithTags !== undefined) {
    contents = serializeAws_restXmlDistributionConfigWithTags(
      input.DistributionConfigWithTags,
      context
    );
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    contents.addAttribute(
      "xmlns",
      "http://cloudfront.amazonaws.com/doc/2019-03-26/"
    );
    body += contents.toString();
  }
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    query,
    body
  });
};

export const serializeAws_restXmlCreateFieldLevelEncryptionConfigCommand = async (
  input: CreateFieldLevelEncryptionConfigCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/xml"
  };
  let resolvedPath = "/2019-03-26/field-level-encryption";
  let body: any;
  let contents: any;
  if (input.FieldLevelEncryptionConfig !== undefined) {
    contents = serializeAws_restXmlFieldLevelEncryptionConfig(
      input.FieldLevelEncryptionConfig,
      context
    );
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    contents.addAttribute(
      "xmlns",
      "http://cloudfront.amazonaws.com/doc/2019-03-26/"
    );
    body += contents.toString();
  }
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restXmlCreateFieldLevelEncryptionProfileCommand = async (
  input: CreateFieldLevelEncryptionProfileCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/xml"
  };
  let resolvedPath = "/2019-03-26/field-level-encryption-profile";
  let body: any;
  let contents: any;
  if (input.FieldLevelEncryptionProfileConfig !== undefined) {
    contents = serializeAws_restXmlFieldLevelEncryptionProfileConfig(
      input.FieldLevelEncryptionProfileConfig,
      context
    );
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    contents.addAttribute(
      "xmlns",
      "http://cloudfront.amazonaws.com/doc/2019-03-26/"
    );
    body += contents.toString();
  }
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restXmlCreateInvalidationCommand = async (
  input: CreateInvalidationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/xml"
  };
  let resolvedPath = "/2019-03-26/distribution/{DistributionId}/invalidation";
  if (input.DistributionId !== undefined) {
    const labelValue: string = input.DistributionId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: DistributionId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{DistributionId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: DistributionId.");
  }
  let body: any;
  let contents: any;
  if (input.InvalidationBatch !== undefined) {
    contents = serializeAws_restXmlInvalidationBatch(
      input.InvalidationBatch,
      context
    );
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    contents.addAttribute(
      "xmlns",
      "http://cloudfront.amazonaws.com/doc/2019-03-26/"
    );
    body += contents.toString();
  }
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restXmlCreatePublicKeyCommand = async (
  input: CreatePublicKeyCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/xml"
  };
  let resolvedPath = "/2019-03-26/public-key";
  let body: any;
  let contents: any;
  if (input.PublicKeyConfig !== undefined) {
    contents = serializeAws_restXmlPublicKeyConfig(
      input.PublicKeyConfig,
      context
    );
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    contents.addAttribute(
      "xmlns",
      "http://cloudfront.amazonaws.com/doc/2019-03-26/"
    );
    body += contents.toString();
  }
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restXmlCreateStreamingDistributionCommand = async (
  input: CreateStreamingDistributionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/xml"
  };
  let resolvedPath = "/2019-03-26/streaming-distribution";
  let body: any;
  let contents: any;
  if (input.StreamingDistributionConfig !== undefined) {
    contents = serializeAws_restXmlStreamingDistributionConfig(
      input.StreamingDistributionConfig,
      context
    );
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    contents.addAttribute(
      "xmlns",
      "http://cloudfront.amazonaws.com/doc/2019-03-26/"
    );
    body += contents.toString();
  }
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restXmlCreateStreamingDistributionWithTagsCommand = async (
  input: CreateStreamingDistributionWithTagsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/xml"
  };
  let resolvedPath = "/2019-03-26/streaming-distribution";
  const query: any = {
    WithTags: ""
  };
  let body: any;
  let contents: any;
  if (input.StreamingDistributionConfigWithTags !== undefined) {
    contents = serializeAws_restXmlStreamingDistributionConfigWithTags(
      input.StreamingDistributionConfigWithTags,
      context
    );
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    contents.addAttribute(
      "xmlns",
      "http://cloudfront.amazonaws.com/doc/2019-03-26/"
    );
    body += contents.toString();
  }
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    query,
    body
  });
};

export const serializeAws_restXmlDeleteCloudFrontOriginAccessIdentityCommand = async (
  input: DeleteCloudFrontOriginAccessIdentityCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "",
    ...(isSerializableHeaderValue(input.IfMatch) && {
      "If-Match": input.IfMatch!
    })
  };
  let resolvedPath = "/2019-03-26/origin-access-identity/cloudfront/{Id}";
  if (input.Id !== undefined) {
    const labelValue: string = input.Id;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Id.");
    }
    resolvedPath = resolvedPath.replace(
      "{Id}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Id.");
  }
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restXmlDeleteDistributionCommand = async (
  input: DeleteDistributionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "",
    ...(isSerializableHeaderValue(input.IfMatch) && {
      "If-Match": input.IfMatch!
    })
  };
  let resolvedPath = "/2019-03-26/distribution/{Id}";
  if (input.Id !== undefined) {
    const labelValue: string = input.Id;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Id.");
    }
    resolvedPath = resolvedPath.replace(
      "{Id}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Id.");
  }
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restXmlDeleteFieldLevelEncryptionConfigCommand = async (
  input: DeleteFieldLevelEncryptionConfigCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "",
    ...(isSerializableHeaderValue(input.IfMatch) && {
      "If-Match": input.IfMatch!
    })
  };
  let resolvedPath = "/2019-03-26/field-level-encryption/{Id}";
  if (input.Id !== undefined) {
    const labelValue: string = input.Id;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Id.");
    }
    resolvedPath = resolvedPath.replace(
      "{Id}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Id.");
  }
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restXmlDeleteFieldLevelEncryptionProfileCommand = async (
  input: DeleteFieldLevelEncryptionProfileCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "",
    ...(isSerializableHeaderValue(input.IfMatch) && {
      "If-Match": input.IfMatch!
    })
  };
  let resolvedPath = "/2019-03-26/field-level-encryption-profile/{Id}";
  if (input.Id !== undefined) {
    const labelValue: string = input.Id;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Id.");
    }
    resolvedPath = resolvedPath.replace(
      "{Id}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Id.");
  }
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restXmlDeletePublicKeyCommand = async (
  input: DeletePublicKeyCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "",
    ...(isSerializableHeaderValue(input.IfMatch) && {
      "If-Match": input.IfMatch!
    })
  };
  let resolvedPath = "/2019-03-26/public-key/{Id}";
  if (input.Id !== undefined) {
    const labelValue: string = input.Id;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Id.");
    }
    resolvedPath = resolvedPath.replace(
      "{Id}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Id.");
  }
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restXmlDeleteStreamingDistributionCommand = async (
  input: DeleteStreamingDistributionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "",
    ...(isSerializableHeaderValue(input.IfMatch) && {
      "If-Match": input.IfMatch!
    })
  };
  let resolvedPath = "/2019-03-26/streaming-distribution/{Id}";
  if (input.Id !== undefined) {
    const labelValue: string = input.Id;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Id.");
    }
    resolvedPath = resolvedPath.replace(
      "{Id}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Id.");
  }
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restXmlGetCloudFrontOriginAccessIdentityCommand = async (
  input: GetCloudFrontOriginAccessIdentityCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": ""
  };
  let resolvedPath = "/2019-03-26/origin-access-identity/cloudfront/{Id}";
  if (input.Id !== undefined) {
    const labelValue: string = input.Id;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Id.");
    }
    resolvedPath = resolvedPath.replace(
      "{Id}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Id.");
  }
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restXmlGetCloudFrontOriginAccessIdentityConfigCommand = async (
  input: GetCloudFrontOriginAccessIdentityConfigCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": ""
  };
  let resolvedPath =
    "/2019-03-26/origin-access-identity/cloudfront/{Id}/config";
  if (input.Id !== undefined) {
    const labelValue: string = input.Id;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Id.");
    }
    resolvedPath = resolvedPath.replace(
      "{Id}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Id.");
  }
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restXmlGetDistributionCommand = async (
  input: GetDistributionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": ""
  };
  let resolvedPath = "/2019-03-26/distribution/{Id}";
  if (input.Id !== undefined) {
    const labelValue: string = input.Id;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Id.");
    }
    resolvedPath = resolvedPath.replace(
      "{Id}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Id.");
  }
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restXmlGetDistributionConfigCommand = async (
  input: GetDistributionConfigCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": ""
  };
  let resolvedPath = "/2019-03-26/distribution/{Id}/config";
  if (input.Id !== undefined) {
    const labelValue: string = input.Id;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Id.");
    }
    resolvedPath = resolvedPath.replace(
      "{Id}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Id.");
  }
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restXmlGetFieldLevelEncryptionCommand = async (
  input: GetFieldLevelEncryptionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": ""
  };
  let resolvedPath = "/2019-03-26/field-level-encryption/{Id}";
  if (input.Id !== undefined) {
    const labelValue: string = input.Id;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Id.");
    }
    resolvedPath = resolvedPath.replace(
      "{Id}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Id.");
  }
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restXmlGetFieldLevelEncryptionConfigCommand = async (
  input: GetFieldLevelEncryptionConfigCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": ""
  };
  let resolvedPath = "/2019-03-26/field-level-encryption/{Id}/config";
  if (input.Id !== undefined) {
    const labelValue: string = input.Id;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Id.");
    }
    resolvedPath = resolvedPath.replace(
      "{Id}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Id.");
  }
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restXmlGetFieldLevelEncryptionProfileCommand = async (
  input: GetFieldLevelEncryptionProfileCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": ""
  };
  let resolvedPath = "/2019-03-26/field-level-encryption-profile/{Id}";
  if (input.Id !== undefined) {
    const labelValue: string = input.Id;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Id.");
    }
    resolvedPath = resolvedPath.replace(
      "{Id}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Id.");
  }
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restXmlGetFieldLevelEncryptionProfileConfigCommand = async (
  input: GetFieldLevelEncryptionProfileConfigCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": ""
  };
  let resolvedPath = "/2019-03-26/field-level-encryption-profile/{Id}/config";
  if (input.Id !== undefined) {
    const labelValue: string = input.Id;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Id.");
    }
    resolvedPath = resolvedPath.replace(
      "{Id}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Id.");
  }
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restXmlGetInvalidationCommand = async (
  input: GetInvalidationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": ""
  };
  let resolvedPath =
    "/2019-03-26/distribution/{DistributionId}/invalidation/{Id}";
  if (input.DistributionId !== undefined) {
    const labelValue: string = input.DistributionId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: DistributionId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{DistributionId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: DistributionId.");
  }
  if (input.Id !== undefined) {
    const labelValue: string = input.Id;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Id.");
    }
    resolvedPath = resolvedPath.replace(
      "{Id}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Id.");
  }
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restXmlGetPublicKeyCommand = async (
  input: GetPublicKeyCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": ""
  };
  let resolvedPath = "/2019-03-26/public-key/{Id}";
  if (input.Id !== undefined) {
    const labelValue: string = input.Id;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Id.");
    }
    resolvedPath = resolvedPath.replace(
      "{Id}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Id.");
  }
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restXmlGetPublicKeyConfigCommand = async (
  input: GetPublicKeyConfigCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": ""
  };
  let resolvedPath = "/2019-03-26/public-key/{Id}/config";
  if (input.Id !== undefined) {
    const labelValue: string = input.Id;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Id.");
    }
    resolvedPath = resolvedPath.replace(
      "{Id}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Id.");
  }
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restXmlGetStreamingDistributionCommand = async (
  input: GetStreamingDistributionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": ""
  };
  let resolvedPath = "/2019-03-26/streaming-distribution/{Id}";
  if (input.Id !== undefined) {
    const labelValue: string = input.Id;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Id.");
    }
    resolvedPath = resolvedPath.replace(
      "{Id}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Id.");
  }
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restXmlGetStreamingDistributionConfigCommand = async (
  input: GetStreamingDistributionConfigCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": ""
  };
  let resolvedPath = "/2019-03-26/streaming-distribution/{Id}/config";
  if (input.Id !== undefined) {
    const labelValue: string = input.Id;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Id.");
    }
    resolvedPath = resolvedPath.replace(
      "{Id}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Id.");
  }
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restXmlListCloudFrontOriginAccessIdentitiesCommand = async (
  input: ListCloudFrontOriginAccessIdentitiesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": ""
  };
  let resolvedPath = "/2019-03-26/origin-access-identity/cloudfront";
  const query: any = {
    ...(input.Marker !== undefined && { Marker: input.Marker }),
    ...(input.MaxItems !== undefined && { MaxItems: input.MaxItems })
  };
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body
  });
};

export const serializeAws_restXmlListDistributionsCommand = async (
  input: ListDistributionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": ""
  };
  let resolvedPath = "/2019-03-26/distribution";
  const query: any = {
    ...(input.Marker !== undefined && { Marker: input.Marker }),
    ...(input.MaxItems !== undefined && { MaxItems: input.MaxItems })
  };
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body
  });
};

export const serializeAws_restXmlListDistributionsByWebACLIdCommand = async (
  input: ListDistributionsByWebACLIdCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": ""
  };
  let resolvedPath = "/2019-03-26/distributionsByWebACLId/{WebACLId}";
  if (input.WebACLId !== undefined) {
    const labelValue: string = input.WebACLId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: WebACLId.");
    }
    resolvedPath = resolvedPath.replace(
      "{WebACLId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: WebACLId.");
  }
  const query: any = {
    ...(input.Marker !== undefined && { Marker: input.Marker }),
    ...(input.MaxItems !== undefined && { MaxItems: input.MaxItems })
  };
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body
  });
};

export const serializeAws_restXmlListFieldLevelEncryptionConfigsCommand = async (
  input: ListFieldLevelEncryptionConfigsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": ""
  };
  let resolvedPath = "/2019-03-26/field-level-encryption";
  const query: any = {
    ...(input.Marker !== undefined && { Marker: input.Marker }),
    ...(input.MaxItems !== undefined && { MaxItems: input.MaxItems })
  };
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body
  });
};

export const serializeAws_restXmlListFieldLevelEncryptionProfilesCommand = async (
  input: ListFieldLevelEncryptionProfilesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": ""
  };
  let resolvedPath = "/2019-03-26/field-level-encryption-profile";
  const query: any = {
    ...(input.Marker !== undefined && { Marker: input.Marker }),
    ...(input.MaxItems !== undefined && { MaxItems: input.MaxItems })
  };
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body
  });
};

export const serializeAws_restXmlListInvalidationsCommand = async (
  input: ListInvalidationsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": ""
  };
  let resolvedPath = "/2019-03-26/distribution/{DistributionId}/invalidation";
  if (input.DistributionId !== undefined) {
    const labelValue: string = input.DistributionId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: DistributionId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{DistributionId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: DistributionId.");
  }
  const query: any = {
    ...(input.Marker !== undefined && { Marker: input.Marker }),
    ...(input.MaxItems !== undefined && { MaxItems: input.MaxItems })
  };
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body
  });
};

export const serializeAws_restXmlListPublicKeysCommand = async (
  input: ListPublicKeysCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": ""
  };
  let resolvedPath = "/2019-03-26/public-key";
  const query: any = {
    ...(input.Marker !== undefined && { Marker: input.Marker }),
    ...(input.MaxItems !== undefined && { MaxItems: input.MaxItems })
  };
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body
  });
};

export const serializeAws_restXmlListStreamingDistributionsCommand = async (
  input: ListStreamingDistributionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": ""
  };
  let resolvedPath = "/2019-03-26/streaming-distribution";
  const query: any = {
    ...(input.Marker !== undefined && { Marker: input.Marker }),
    ...(input.MaxItems !== undefined && { MaxItems: input.MaxItems })
  };
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body
  });
};

export const serializeAws_restXmlListTagsForResourceCommand = async (
  input: ListTagsForResourceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": ""
  };
  let resolvedPath = "/2019-03-26/tagging";
  const query: any = {
    ...(input.Resource !== undefined && { Resource: input.Resource })
  };
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body
  });
};

export const serializeAws_restXmlTagResourceCommand = async (
  input: TagResourceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/xml"
  };
  let resolvedPath = "/2019-03-26/tagging";
  const query: any = {
    Operation: "Tag",
    ...(input.Resource !== undefined && { Resource: input.Resource })
  };
  let body: any;
  let contents: any;
  if (input.Tags !== undefined) {
    contents = serializeAws_restXmlTags(input.Tags, context);
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    contents.addAttribute(
      "xmlns",
      "http://cloudfront.amazonaws.com/doc/2019-03-26/"
    );
    body += contents.toString();
  }
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    query,
    body
  });
};

export const serializeAws_restXmlUntagResourceCommand = async (
  input: UntagResourceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/xml"
  };
  let resolvedPath = "/2019-03-26/tagging";
  const query: any = {
    Operation: "Untag",
    ...(input.Resource !== undefined && { Resource: input.Resource })
  };
  let body: any;
  let contents: any;
  if (input.TagKeys !== undefined) {
    contents = serializeAws_restXmlTagKeys(input.TagKeys, context);
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    contents.addAttribute(
      "xmlns",
      "http://cloudfront.amazonaws.com/doc/2019-03-26/"
    );
    body += contents.toString();
  }
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    query,
    body
  });
};

export const serializeAws_restXmlUpdateCloudFrontOriginAccessIdentityCommand = async (
  input: UpdateCloudFrontOriginAccessIdentityCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/xml",
    ...(isSerializableHeaderValue(input.IfMatch) && {
      "If-Match": input.IfMatch!
    })
  };
  let resolvedPath =
    "/2019-03-26/origin-access-identity/cloudfront/{Id}/config";
  if (input.Id !== undefined) {
    const labelValue: string = input.Id;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Id.");
    }
    resolvedPath = resolvedPath.replace(
      "{Id}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Id.");
  }
  let body: any;
  let contents: any;
  if (input.CloudFrontOriginAccessIdentityConfig !== undefined) {
    contents = serializeAws_restXmlCloudFrontOriginAccessIdentityConfig(
      input.CloudFrontOriginAccessIdentityConfig,
      context
    );
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    contents.addAttribute(
      "xmlns",
      "http://cloudfront.amazonaws.com/doc/2019-03-26/"
    );
    body += contents.toString();
  }
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "PUT",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restXmlUpdateDistributionCommand = async (
  input: UpdateDistributionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/xml",
    ...(isSerializableHeaderValue(input.IfMatch) && {
      "If-Match": input.IfMatch!
    })
  };
  let resolvedPath = "/2019-03-26/distribution/{Id}/config";
  if (input.Id !== undefined) {
    const labelValue: string = input.Id;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Id.");
    }
    resolvedPath = resolvedPath.replace(
      "{Id}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Id.");
  }
  let body: any;
  let contents: any;
  if (input.DistributionConfig !== undefined) {
    contents = serializeAws_restXmlDistributionConfig(
      input.DistributionConfig,
      context
    );
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    contents.addAttribute(
      "xmlns",
      "http://cloudfront.amazonaws.com/doc/2019-03-26/"
    );
    body += contents.toString();
  }
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "PUT",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restXmlUpdateFieldLevelEncryptionConfigCommand = async (
  input: UpdateFieldLevelEncryptionConfigCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/xml",
    ...(isSerializableHeaderValue(input.IfMatch) && {
      "If-Match": input.IfMatch!
    })
  };
  let resolvedPath = "/2019-03-26/field-level-encryption/{Id}/config";
  if (input.Id !== undefined) {
    const labelValue: string = input.Id;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Id.");
    }
    resolvedPath = resolvedPath.replace(
      "{Id}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Id.");
  }
  let body: any;
  let contents: any;
  if (input.FieldLevelEncryptionConfig !== undefined) {
    contents = serializeAws_restXmlFieldLevelEncryptionConfig(
      input.FieldLevelEncryptionConfig,
      context
    );
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    contents.addAttribute(
      "xmlns",
      "http://cloudfront.amazonaws.com/doc/2019-03-26/"
    );
    body += contents.toString();
  }
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "PUT",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restXmlUpdateFieldLevelEncryptionProfileCommand = async (
  input: UpdateFieldLevelEncryptionProfileCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/xml",
    ...(isSerializableHeaderValue(input.IfMatch) && {
      "If-Match": input.IfMatch!
    })
  };
  let resolvedPath = "/2019-03-26/field-level-encryption-profile/{Id}/config";
  if (input.Id !== undefined) {
    const labelValue: string = input.Id;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Id.");
    }
    resolvedPath = resolvedPath.replace(
      "{Id}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Id.");
  }
  let body: any;
  let contents: any;
  if (input.FieldLevelEncryptionProfileConfig !== undefined) {
    contents = serializeAws_restXmlFieldLevelEncryptionProfileConfig(
      input.FieldLevelEncryptionProfileConfig,
      context
    );
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    contents.addAttribute(
      "xmlns",
      "http://cloudfront.amazonaws.com/doc/2019-03-26/"
    );
    body += contents.toString();
  }
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "PUT",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restXmlUpdatePublicKeyCommand = async (
  input: UpdatePublicKeyCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/xml",
    ...(isSerializableHeaderValue(input.IfMatch) && {
      "If-Match": input.IfMatch!
    })
  };
  let resolvedPath = "/2019-03-26/public-key/{Id}/config";
  if (input.Id !== undefined) {
    const labelValue: string = input.Id;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Id.");
    }
    resolvedPath = resolvedPath.replace(
      "{Id}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Id.");
  }
  let body: any;
  let contents: any;
  if (input.PublicKeyConfig !== undefined) {
    contents = serializeAws_restXmlPublicKeyConfig(
      input.PublicKeyConfig,
      context
    );
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    contents.addAttribute(
      "xmlns",
      "http://cloudfront.amazonaws.com/doc/2019-03-26/"
    );
    body += contents.toString();
  }
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "PUT",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restXmlUpdateStreamingDistributionCommand = async (
  input: UpdateStreamingDistributionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/xml",
    ...(isSerializableHeaderValue(input.IfMatch) && {
      "If-Match": input.IfMatch!
    })
  };
  let resolvedPath = "/2019-03-26/streaming-distribution/{Id}/config";
  if (input.Id !== undefined) {
    const labelValue: string = input.Id;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Id.");
    }
    resolvedPath = resolvedPath.replace(
      "{Id}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Id.");
  }
  let body: any;
  let contents: any;
  if (input.StreamingDistributionConfig !== undefined) {
    contents = serializeAws_restXmlStreamingDistributionConfig(
      input.StreamingDistributionConfig,
      context
    );
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    contents.addAttribute(
      "xmlns",
      "http://cloudfront.amazonaws.com/doc/2019-03-26/"
    );
    body += contents.toString();
  }
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "PUT",
    headers,
    path: resolvedPath,
    body
  });
};

export const deserializeAws_restXmlCreateCloudFrontOriginAccessIdentityCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateCloudFrontOriginAccessIdentityCommandOutput> => {
  if (output.statusCode !== 201 && output.statusCode >= 400) {
    return deserializeAws_restXmlCreateCloudFrontOriginAccessIdentityCommandError(
      output,
      context
    );
  }
  const contents: CreateCloudFrontOriginAccessIdentityCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateCloudFrontOriginAccessIdentityResult",
    CloudFrontOriginAccessIdentity: undefined,
    ETag: undefined,
    Location: undefined
  };
  if (output.headers["etag"] !== undefined) {
    contents.ETag = output.headers["etag"];
  }
  if (output.headers["location"] !== undefined) {
    contents.Location = output.headers["location"];
  }
  const data: any = await parseBody(output.body, context);
  contents.CloudFrontOriginAccessIdentity = deserializeAws_restXmlCloudFrontOriginAccessIdentity(
    data,
    context
  );
  return Promise.resolve(contents);
};

const deserializeAws_restXmlCreateCloudFrontOriginAccessIdentityCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateCloudFrontOriginAccessIdentityCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "CloudFrontOriginAccessIdentityAlreadyExists":
    case "com.amazonaws.cloudfront#CloudFrontOriginAccessIdentityAlreadyExists":
      response = {
        ...(await deserializeAws_restXmlCloudFrontOriginAccessIdentityAlreadyExistsResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InconsistentQuantities":
    case "com.amazonaws.cloudfront#InconsistentQuantities":
      response = {
        ...(await deserializeAws_restXmlInconsistentQuantitiesResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidArgument":
    case "com.amazonaws.cloudfront#InvalidArgument":
      response = {
        ...(await deserializeAws_restXmlInvalidArgumentResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MissingBody":
    case "com.amazonaws.cloudfront#MissingBody":
      response = {
        ...(await deserializeAws_restXmlMissingBodyResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyCloudFrontOriginAccessIdentities":
    case "com.amazonaws.cloudfront#TooManyCloudFrontOriginAccessIdentities":
      response = {
        ...(await deserializeAws_restXmlTooManyCloudFrontOriginAccessIdentitiesResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlCreateDistributionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDistributionCommandOutput> => {
  if (output.statusCode !== 201 && output.statusCode >= 400) {
    return deserializeAws_restXmlCreateDistributionCommandError(
      output,
      context
    );
  }
  const contents: CreateDistributionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateDistributionResult",
    Distribution: undefined,
    ETag: undefined,
    Location: undefined
  };
  if (output.headers["etag"] !== undefined) {
    contents.ETag = output.headers["etag"];
  }
  if (output.headers["location"] !== undefined) {
    contents.Location = output.headers["location"];
  }
  const data: any = await parseBody(output.body, context);
  contents.Distribution = deserializeAws_restXmlDistribution(data, context);
  return Promise.resolve(contents);
};

const deserializeAws_restXmlCreateDistributionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDistributionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDenied":
    case "com.amazonaws.cloudfront#AccessDenied":
      response = {
        ...(await deserializeAws_restXmlAccessDeniedResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "CNAMEAlreadyExists":
    case "com.amazonaws.cloudfront#CNAMEAlreadyExists":
      response = {
        ...(await deserializeAws_restXmlCNAMEAlreadyExistsResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DistributionAlreadyExists":
    case "com.amazonaws.cloudfront#DistributionAlreadyExists":
      response = {
        ...(await deserializeAws_restXmlDistributionAlreadyExistsResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior":
    case "com.amazonaws.cloudfront#IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior":
      response = {
        ...(await deserializeAws_restXmlIllegalFieldLevelEncryptionConfigAssociationWithCacheBehaviorResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InconsistentQuantities":
    case "com.amazonaws.cloudfront#InconsistentQuantities":
      response = {
        ...(await deserializeAws_restXmlInconsistentQuantitiesResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidArgument":
    case "com.amazonaws.cloudfront#InvalidArgument":
      response = {
        ...(await deserializeAws_restXmlInvalidArgumentResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDefaultRootObject":
    case "com.amazonaws.cloudfront#InvalidDefaultRootObject":
      response = {
        ...(await deserializeAws_restXmlInvalidDefaultRootObjectResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidErrorCode":
    case "com.amazonaws.cloudfront#InvalidErrorCode":
      response = {
        ...(await deserializeAws_restXmlInvalidErrorCodeResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidForwardCookies":
    case "com.amazonaws.cloudfront#InvalidForwardCookies":
      response = {
        ...(await deserializeAws_restXmlInvalidForwardCookiesResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidGeoRestrictionParameter":
    case "com.amazonaws.cloudfront#InvalidGeoRestrictionParameter":
      response = {
        ...(await deserializeAws_restXmlInvalidGeoRestrictionParameterResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidHeadersForS3Origin":
    case "com.amazonaws.cloudfront#InvalidHeadersForS3Origin":
      response = {
        ...(await deserializeAws_restXmlInvalidHeadersForS3OriginResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidLambdaFunctionAssociation":
    case "com.amazonaws.cloudfront#InvalidLambdaFunctionAssociation":
      response = {
        ...(await deserializeAws_restXmlInvalidLambdaFunctionAssociationResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidLocationCode":
    case "com.amazonaws.cloudfront#InvalidLocationCode":
      response = {
        ...(await deserializeAws_restXmlInvalidLocationCodeResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidMinimumProtocolVersion":
    case "com.amazonaws.cloudfront#InvalidMinimumProtocolVersion":
      response = {
        ...(await deserializeAws_restXmlInvalidMinimumProtocolVersionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidOrigin":
    case "com.amazonaws.cloudfront#InvalidOrigin":
      response = {
        ...(await deserializeAws_restXmlInvalidOriginResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidOriginAccessIdentity":
    case "com.amazonaws.cloudfront#InvalidOriginAccessIdentity":
      response = {
        ...(await deserializeAws_restXmlInvalidOriginAccessIdentityResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidOriginKeepaliveTimeout":
    case "com.amazonaws.cloudfront#InvalidOriginKeepaliveTimeout":
      response = {
        ...(await deserializeAws_restXmlInvalidOriginKeepaliveTimeoutResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidOriginReadTimeout":
    case "com.amazonaws.cloudfront#InvalidOriginReadTimeout":
      response = {
        ...(await deserializeAws_restXmlInvalidOriginReadTimeoutResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidProtocolSettings":
    case "com.amazonaws.cloudfront#InvalidProtocolSettings":
      response = {
        ...(await deserializeAws_restXmlInvalidProtocolSettingsResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidQueryStringParameters":
    case "com.amazonaws.cloudfront#InvalidQueryStringParameters":
      response = {
        ...(await deserializeAws_restXmlInvalidQueryStringParametersResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRelativePath":
    case "com.amazonaws.cloudfront#InvalidRelativePath":
      response = {
        ...(await deserializeAws_restXmlInvalidRelativePathResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequiredProtocol":
    case "com.amazonaws.cloudfront#InvalidRequiredProtocol":
      response = {
        ...(await deserializeAws_restXmlInvalidRequiredProtocolResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidResponseCode":
    case "com.amazonaws.cloudfront#InvalidResponseCode":
      response = {
        ...(await deserializeAws_restXmlInvalidResponseCodeResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidTTLOrder":
    case "com.amazonaws.cloudfront#InvalidTTLOrder":
      response = {
        ...(await deserializeAws_restXmlInvalidTTLOrderResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidViewerCertificate":
    case "com.amazonaws.cloudfront#InvalidViewerCertificate":
      response = {
        ...(await deserializeAws_restXmlInvalidViewerCertificateResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidWebACLId":
    case "com.amazonaws.cloudfront#InvalidWebACLId":
      response = {
        ...(await deserializeAws_restXmlInvalidWebACLIdResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MissingBody":
    case "com.amazonaws.cloudfront#MissingBody":
      response = {
        ...(await deserializeAws_restXmlMissingBodyResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NoSuchFieldLevelEncryptionConfig":
    case "com.amazonaws.cloudfront#NoSuchFieldLevelEncryptionConfig":
      response = {
        ...(await deserializeAws_restXmlNoSuchFieldLevelEncryptionConfigResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NoSuchOrigin":
    case "com.amazonaws.cloudfront#NoSuchOrigin":
      response = {
        ...(await deserializeAws_restXmlNoSuchOriginResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyCacheBehaviors":
    case "com.amazonaws.cloudfront#TooManyCacheBehaviors":
      response = {
        ...(await deserializeAws_restXmlTooManyCacheBehaviorsResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyCertificates":
    case "com.amazonaws.cloudfront#TooManyCertificates":
      response = {
        ...(await deserializeAws_restXmlTooManyCertificatesResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyCookieNamesInWhiteList":
    case "com.amazonaws.cloudfront#TooManyCookieNamesInWhiteList":
      response = {
        ...(await deserializeAws_restXmlTooManyCookieNamesInWhiteListResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyDistributionCNAMEs":
    case "com.amazonaws.cloudfront#TooManyDistributionCNAMEs":
      response = {
        ...(await deserializeAws_restXmlTooManyDistributionCNAMEsResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyDistributions":
    case "com.amazonaws.cloudfront#TooManyDistributions":
      response = {
        ...(await deserializeAws_restXmlTooManyDistributionsResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyDistributionsAssociatedToFieldLevelEncryptionConfig":
    case "com.amazonaws.cloudfront#TooManyDistributionsAssociatedToFieldLevelEncryptionConfig":
      response = {
        ...(await deserializeAws_restXmlTooManyDistributionsAssociatedToFieldLevelEncryptionConfigResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyDistributionsWithLambdaAssociations":
    case "com.amazonaws.cloudfront#TooManyDistributionsWithLambdaAssociations":
      response = {
        ...(await deserializeAws_restXmlTooManyDistributionsWithLambdaAssociationsResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyHeadersInForwardedValues":
    case "com.amazonaws.cloudfront#TooManyHeadersInForwardedValues":
      response = {
        ...(await deserializeAws_restXmlTooManyHeadersInForwardedValuesResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyLambdaFunctionAssociations":
    case "com.amazonaws.cloudfront#TooManyLambdaFunctionAssociations":
      response = {
        ...(await deserializeAws_restXmlTooManyLambdaFunctionAssociationsResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyOriginCustomHeaders":
    case "com.amazonaws.cloudfront#TooManyOriginCustomHeaders":
      response = {
        ...(await deserializeAws_restXmlTooManyOriginCustomHeadersResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyOriginGroupsPerDistribution":
    case "com.amazonaws.cloudfront#TooManyOriginGroupsPerDistribution":
      response = {
        ...(await deserializeAws_restXmlTooManyOriginGroupsPerDistributionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyOrigins":
    case "com.amazonaws.cloudfront#TooManyOrigins":
      response = {
        ...(await deserializeAws_restXmlTooManyOriginsResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyQueryStringParameters":
    case "com.amazonaws.cloudfront#TooManyQueryStringParameters":
      response = {
        ...(await deserializeAws_restXmlTooManyQueryStringParametersResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyTrustedSigners":
    case "com.amazonaws.cloudfront#TooManyTrustedSigners":
      response = {
        ...(await deserializeAws_restXmlTooManyTrustedSignersResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TrustedSignerDoesNotExist":
    case "com.amazonaws.cloudfront#TrustedSignerDoesNotExist":
      response = {
        ...(await deserializeAws_restXmlTrustedSignerDoesNotExistResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlCreateDistributionWithTagsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDistributionWithTagsCommandOutput> => {
  if (output.statusCode !== 201 && output.statusCode >= 400) {
    return deserializeAws_restXmlCreateDistributionWithTagsCommandError(
      output,
      context
    );
  }
  const contents: CreateDistributionWithTagsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateDistributionWithTagsResult",
    Distribution: undefined,
    ETag: undefined,
    Location: undefined
  };
  if (output.headers["etag"] !== undefined) {
    contents.ETag = output.headers["etag"];
  }
  if (output.headers["location"] !== undefined) {
    contents.Location = output.headers["location"];
  }
  const data: any = await parseBody(output.body, context);
  contents.Distribution = deserializeAws_restXmlDistribution(data, context);
  return Promise.resolve(contents);
};

const deserializeAws_restXmlCreateDistributionWithTagsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDistributionWithTagsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDenied":
    case "com.amazonaws.cloudfront#AccessDenied":
      response = {
        ...(await deserializeAws_restXmlAccessDeniedResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "CNAMEAlreadyExists":
    case "com.amazonaws.cloudfront#CNAMEAlreadyExists":
      response = {
        ...(await deserializeAws_restXmlCNAMEAlreadyExistsResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DistributionAlreadyExists":
    case "com.amazonaws.cloudfront#DistributionAlreadyExists":
      response = {
        ...(await deserializeAws_restXmlDistributionAlreadyExistsResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior":
    case "com.amazonaws.cloudfront#IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior":
      response = {
        ...(await deserializeAws_restXmlIllegalFieldLevelEncryptionConfigAssociationWithCacheBehaviorResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InconsistentQuantities":
    case "com.amazonaws.cloudfront#InconsistentQuantities":
      response = {
        ...(await deserializeAws_restXmlInconsistentQuantitiesResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidArgument":
    case "com.amazonaws.cloudfront#InvalidArgument":
      response = {
        ...(await deserializeAws_restXmlInvalidArgumentResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDefaultRootObject":
    case "com.amazonaws.cloudfront#InvalidDefaultRootObject":
      response = {
        ...(await deserializeAws_restXmlInvalidDefaultRootObjectResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidErrorCode":
    case "com.amazonaws.cloudfront#InvalidErrorCode":
      response = {
        ...(await deserializeAws_restXmlInvalidErrorCodeResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidForwardCookies":
    case "com.amazonaws.cloudfront#InvalidForwardCookies":
      response = {
        ...(await deserializeAws_restXmlInvalidForwardCookiesResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidGeoRestrictionParameter":
    case "com.amazonaws.cloudfront#InvalidGeoRestrictionParameter":
      response = {
        ...(await deserializeAws_restXmlInvalidGeoRestrictionParameterResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidHeadersForS3Origin":
    case "com.amazonaws.cloudfront#InvalidHeadersForS3Origin":
      response = {
        ...(await deserializeAws_restXmlInvalidHeadersForS3OriginResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidLambdaFunctionAssociation":
    case "com.amazonaws.cloudfront#InvalidLambdaFunctionAssociation":
      response = {
        ...(await deserializeAws_restXmlInvalidLambdaFunctionAssociationResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidLocationCode":
    case "com.amazonaws.cloudfront#InvalidLocationCode":
      response = {
        ...(await deserializeAws_restXmlInvalidLocationCodeResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidMinimumProtocolVersion":
    case "com.amazonaws.cloudfront#InvalidMinimumProtocolVersion":
      response = {
        ...(await deserializeAws_restXmlInvalidMinimumProtocolVersionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidOrigin":
    case "com.amazonaws.cloudfront#InvalidOrigin":
      response = {
        ...(await deserializeAws_restXmlInvalidOriginResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidOriginAccessIdentity":
    case "com.amazonaws.cloudfront#InvalidOriginAccessIdentity":
      response = {
        ...(await deserializeAws_restXmlInvalidOriginAccessIdentityResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidOriginKeepaliveTimeout":
    case "com.amazonaws.cloudfront#InvalidOriginKeepaliveTimeout":
      response = {
        ...(await deserializeAws_restXmlInvalidOriginKeepaliveTimeoutResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidOriginReadTimeout":
    case "com.amazonaws.cloudfront#InvalidOriginReadTimeout":
      response = {
        ...(await deserializeAws_restXmlInvalidOriginReadTimeoutResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidProtocolSettings":
    case "com.amazonaws.cloudfront#InvalidProtocolSettings":
      response = {
        ...(await deserializeAws_restXmlInvalidProtocolSettingsResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidQueryStringParameters":
    case "com.amazonaws.cloudfront#InvalidQueryStringParameters":
      response = {
        ...(await deserializeAws_restXmlInvalidQueryStringParametersResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRelativePath":
    case "com.amazonaws.cloudfront#InvalidRelativePath":
      response = {
        ...(await deserializeAws_restXmlInvalidRelativePathResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequiredProtocol":
    case "com.amazonaws.cloudfront#InvalidRequiredProtocol":
      response = {
        ...(await deserializeAws_restXmlInvalidRequiredProtocolResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidResponseCode":
    case "com.amazonaws.cloudfront#InvalidResponseCode":
      response = {
        ...(await deserializeAws_restXmlInvalidResponseCodeResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidTagging":
    case "com.amazonaws.cloudfront#InvalidTagging":
      response = {
        ...(await deserializeAws_restXmlInvalidTaggingResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidTTLOrder":
    case "com.amazonaws.cloudfront#InvalidTTLOrder":
      response = {
        ...(await deserializeAws_restXmlInvalidTTLOrderResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidViewerCertificate":
    case "com.amazonaws.cloudfront#InvalidViewerCertificate":
      response = {
        ...(await deserializeAws_restXmlInvalidViewerCertificateResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidWebACLId":
    case "com.amazonaws.cloudfront#InvalidWebACLId":
      response = {
        ...(await deserializeAws_restXmlInvalidWebACLIdResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MissingBody":
    case "com.amazonaws.cloudfront#MissingBody":
      response = {
        ...(await deserializeAws_restXmlMissingBodyResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NoSuchFieldLevelEncryptionConfig":
    case "com.amazonaws.cloudfront#NoSuchFieldLevelEncryptionConfig":
      response = {
        ...(await deserializeAws_restXmlNoSuchFieldLevelEncryptionConfigResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NoSuchOrigin":
    case "com.amazonaws.cloudfront#NoSuchOrigin":
      response = {
        ...(await deserializeAws_restXmlNoSuchOriginResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyCacheBehaviors":
    case "com.amazonaws.cloudfront#TooManyCacheBehaviors":
      response = {
        ...(await deserializeAws_restXmlTooManyCacheBehaviorsResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyCertificates":
    case "com.amazonaws.cloudfront#TooManyCertificates":
      response = {
        ...(await deserializeAws_restXmlTooManyCertificatesResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyCookieNamesInWhiteList":
    case "com.amazonaws.cloudfront#TooManyCookieNamesInWhiteList":
      response = {
        ...(await deserializeAws_restXmlTooManyCookieNamesInWhiteListResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyDistributionCNAMEs":
    case "com.amazonaws.cloudfront#TooManyDistributionCNAMEs":
      response = {
        ...(await deserializeAws_restXmlTooManyDistributionCNAMEsResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyDistributions":
    case "com.amazonaws.cloudfront#TooManyDistributions":
      response = {
        ...(await deserializeAws_restXmlTooManyDistributionsResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyDistributionsAssociatedToFieldLevelEncryptionConfig":
    case "com.amazonaws.cloudfront#TooManyDistributionsAssociatedToFieldLevelEncryptionConfig":
      response = {
        ...(await deserializeAws_restXmlTooManyDistributionsAssociatedToFieldLevelEncryptionConfigResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyDistributionsWithLambdaAssociations":
    case "com.amazonaws.cloudfront#TooManyDistributionsWithLambdaAssociations":
      response = {
        ...(await deserializeAws_restXmlTooManyDistributionsWithLambdaAssociationsResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyHeadersInForwardedValues":
    case "com.amazonaws.cloudfront#TooManyHeadersInForwardedValues":
      response = {
        ...(await deserializeAws_restXmlTooManyHeadersInForwardedValuesResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyLambdaFunctionAssociations":
    case "com.amazonaws.cloudfront#TooManyLambdaFunctionAssociations":
      response = {
        ...(await deserializeAws_restXmlTooManyLambdaFunctionAssociationsResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyOriginCustomHeaders":
    case "com.amazonaws.cloudfront#TooManyOriginCustomHeaders":
      response = {
        ...(await deserializeAws_restXmlTooManyOriginCustomHeadersResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyOriginGroupsPerDistribution":
    case "com.amazonaws.cloudfront#TooManyOriginGroupsPerDistribution":
      response = {
        ...(await deserializeAws_restXmlTooManyOriginGroupsPerDistributionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyOrigins":
    case "com.amazonaws.cloudfront#TooManyOrigins":
      response = {
        ...(await deserializeAws_restXmlTooManyOriginsResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyQueryStringParameters":
    case "com.amazonaws.cloudfront#TooManyQueryStringParameters":
      response = {
        ...(await deserializeAws_restXmlTooManyQueryStringParametersResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyTrustedSigners":
    case "com.amazonaws.cloudfront#TooManyTrustedSigners":
      response = {
        ...(await deserializeAws_restXmlTooManyTrustedSignersResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TrustedSignerDoesNotExist":
    case "com.amazonaws.cloudfront#TrustedSignerDoesNotExist":
      response = {
        ...(await deserializeAws_restXmlTrustedSignerDoesNotExistResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlCreateFieldLevelEncryptionConfigCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateFieldLevelEncryptionConfigCommandOutput> => {
  if (output.statusCode !== 201 && output.statusCode >= 400) {
    return deserializeAws_restXmlCreateFieldLevelEncryptionConfigCommandError(
      output,
      context
    );
  }
  const contents: CreateFieldLevelEncryptionConfigCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateFieldLevelEncryptionConfigResult",
    ETag: undefined,
    FieldLevelEncryption: undefined,
    Location: undefined
  };
  if (output.headers["etag"] !== undefined) {
    contents.ETag = output.headers["etag"];
  }
  if (output.headers["location"] !== undefined) {
    contents.Location = output.headers["location"];
  }
  const data: any = await parseBody(output.body, context);
  contents.FieldLevelEncryption = deserializeAws_restXmlFieldLevelEncryption(
    data,
    context
  );
  return Promise.resolve(contents);
};

const deserializeAws_restXmlCreateFieldLevelEncryptionConfigCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateFieldLevelEncryptionConfigCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "FieldLevelEncryptionConfigAlreadyExists":
    case "com.amazonaws.cloudfront#FieldLevelEncryptionConfigAlreadyExists":
      response = {
        ...(await deserializeAws_restXmlFieldLevelEncryptionConfigAlreadyExistsResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InconsistentQuantities":
    case "com.amazonaws.cloudfront#InconsistentQuantities":
      response = {
        ...(await deserializeAws_restXmlInconsistentQuantitiesResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidArgument":
    case "com.amazonaws.cloudfront#InvalidArgument":
      response = {
        ...(await deserializeAws_restXmlInvalidArgumentResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NoSuchFieldLevelEncryptionProfile":
    case "com.amazonaws.cloudfront#NoSuchFieldLevelEncryptionProfile":
      response = {
        ...(await deserializeAws_restXmlNoSuchFieldLevelEncryptionProfileResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "QueryArgProfileEmpty":
    case "com.amazonaws.cloudfront#QueryArgProfileEmpty":
      response = {
        ...(await deserializeAws_restXmlQueryArgProfileEmptyResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyFieldLevelEncryptionConfigs":
    case "com.amazonaws.cloudfront#TooManyFieldLevelEncryptionConfigs":
      response = {
        ...(await deserializeAws_restXmlTooManyFieldLevelEncryptionConfigsResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyFieldLevelEncryptionContentTypeProfiles":
    case "com.amazonaws.cloudfront#TooManyFieldLevelEncryptionContentTypeProfiles":
      response = {
        ...(await deserializeAws_restXmlTooManyFieldLevelEncryptionContentTypeProfilesResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyFieldLevelEncryptionQueryArgProfiles":
    case "com.amazonaws.cloudfront#TooManyFieldLevelEncryptionQueryArgProfiles":
      response = {
        ...(await deserializeAws_restXmlTooManyFieldLevelEncryptionQueryArgProfilesResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlCreateFieldLevelEncryptionProfileCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateFieldLevelEncryptionProfileCommandOutput> => {
  if (output.statusCode !== 201 && output.statusCode >= 400) {
    return deserializeAws_restXmlCreateFieldLevelEncryptionProfileCommandError(
      output,
      context
    );
  }
  const contents: CreateFieldLevelEncryptionProfileCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateFieldLevelEncryptionProfileResult",
    ETag: undefined,
    FieldLevelEncryptionProfile: undefined,
    Location: undefined
  };
  if (output.headers["etag"] !== undefined) {
    contents.ETag = output.headers["etag"];
  }
  if (output.headers["location"] !== undefined) {
    contents.Location = output.headers["location"];
  }
  const data: any = await parseBody(output.body, context);
  contents.FieldLevelEncryptionProfile = deserializeAws_restXmlFieldLevelEncryptionProfile(
    data,
    context
  );
  return Promise.resolve(contents);
};

const deserializeAws_restXmlCreateFieldLevelEncryptionProfileCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateFieldLevelEncryptionProfileCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "FieldLevelEncryptionProfileAlreadyExists":
    case "com.amazonaws.cloudfront#FieldLevelEncryptionProfileAlreadyExists":
      response = {
        ...(await deserializeAws_restXmlFieldLevelEncryptionProfileAlreadyExistsResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "FieldLevelEncryptionProfileSizeExceeded":
    case "com.amazonaws.cloudfront#FieldLevelEncryptionProfileSizeExceeded":
      response = {
        ...(await deserializeAws_restXmlFieldLevelEncryptionProfileSizeExceededResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InconsistentQuantities":
    case "com.amazonaws.cloudfront#InconsistentQuantities":
      response = {
        ...(await deserializeAws_restXmlInconsistentQuantitiesResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidArgument":
    case "com.amazonaws.cloudfront#InvalidArgument":
      response = {
        ...(await deserializeAws_restXmlInvalidArgumentResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NoSuchPublicKey":
    case "com.amazonaws.cloudfront#NoSuchPublicKey":
      response = {
        ...(await deserializeAws_restXmlNoSuchPublicKeyResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyFieldLevelEncryptionEncryptionEntities":
    case "com.amazonaws.cloudfront#TooManyFieldLevelEncryptionEncryptionEntities":
      response = {
        ...(await deserializeAws_restXmlTooManyFieldLevelEncryptionEncryptionEntitiesResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyFieldLevelEncryptionFieldPatterns":
    case "com.amazonaws.cloudfront#TooManyFieldLevelEncryptionFieldPatterns":
      response = {
        ...(await deserializeAws_restXmlTooManyFieldLevelEncryptionFieldPatternsResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyFieldLevelEncryptionProfiles":
    case "com.amazonaws.cloudfront#TooManyFieldLevelEncryptionProfiles":
      response = {
        ...(await deserializeAws_restXmlTooManyFieldLevelEncryptionProfilesResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlCreateInvalidationCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateInvalidationCommandOutput> => {
  if (output.statusCode !== 201 && output.statusCode >= 400) {
    return deserializeAws_restXmlCreateInvalidationCommandError(
      output,
      context
    );
  }
  const contents: CreateInvalidationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateInvalidationResult",
    Invalidation: undefined,
    Location: undefined
  };
  if (output.headers["location"] !== undefined) {
    contents.Location = output.headers["location"];
  }
  const data: any = await parseBody(output.body, context);
  contents.Invalidation = deserializeAws_restXmlInvalidation(data, context);
  return Promise.resolve(contents);
};

const deserializeAws_restXmlCreateInvalidationCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateInvalidationCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDenied":
    case "com.amazonaws.cloudfront#AccessDenied":
      response = {
        ...(await deserializeAws_restXmlAccessDeniedResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "BatchTooLarge":
    case "com.amazonaws.cloudfront#BatchTooLarge":
      response = {
        ...(await deserializeAws_restXmlBatchTooLargeResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InconsistentQuantities":
    case "com.amazonaws.cloudfront#InconsistentQuantities":
      response = {
        ...(await deserializeAws_restXmlInconsistentQuantitiesResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidArgument":
    case "com.amazonaws.cloudfront#InvalidArgument":
      response = {
        ...(await deserializeAws_restXmlInvalidArgumentResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MissingBody":
    case "com.amazonaws.cloudfront#MissingBody":
      response = {
        ...(await deserializeAws_restXmlMissingBodyResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NoSuchDistribution":
    case "com.amazonaws.cloudfront#NoSuchDistribution":
      response = {
        ...(await deserializeAws_restXmlNoSuchDistributionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyInvalidationsInProgress":
    case "com.amazonaws.cloudfront#TooManyInvalidationsInProgress":
      response = {
        ...(await deserializeAws_restXmlTooManyInvalidationsInProgressResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlCreatePublicKeyCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreatePublicKeyCommandOutput> => {
  if (output.statusCode !== 201 && output.statusCode >= 400) {
    return deserializeAws_restXmlCreatePublicKeyCommandError(output, context);
  }
  const contents: CreatePublicKeyCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreatePublicKeyResult",
    ETag: undefined,
    Location: undefined,
    PublicKey: undefined
  };
  if (output.headers["etag"] !== undefined) {
    contents.ETag = output.headers["etag"];
  }
  if (output.headers["location"] !== undefined) {
    contents.Location = output.headers["location"];
  }
  const data: any = await parseBody(output.body, context);
  contents.PublicKey = deserializeAws_restXmlPublicKey(data, context);
  return Promise.resolve(contents);
};

const deserializeAws_restXmlCreatePublicKeyCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreatePublicKeyCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidArgument":
    case "com.amazonaws.cloudfront#InvalidArgument":
      response = {
        ...(await deserializeAws_restXmlInvalidArgumentResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "PublicKeyAlreadyExists":
    case "com.amazonaws.cloudfront#PublicKeyAlreadyExists":
      response = {
        ...(await deserializeAws_restXmlPublicKeyAlreadyExistsResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyPublicKeys":
    case "com.amazonaws.cloudfront#TooManyPublicKeys":
      response = {
        ...(await deserializeAws_restXmlTooManyPublicKeysResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlCreateStreamingDistributionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateStreamingDistributionCommandOutput> => {
  if (output.statusCode !== 201 && output.statusCode >= 400) {
    return deserializeAws_restXmlCreateStreamingDistributionCommandError(
      output,
      context
    );
  }
  const contents: CreateStreamingDistributionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateStreamingDistributionResult",
    ETag: undefined,
    Location: undefined,
    StreamingDistribution: undefined
  };
  if (output.headers["etag"] !== undefined) {
    contents.ETag = output.headers["etag"];
  }
  if (output.headers["location"] !== undefined) {
    contents.Location = output.headers["location"];
  }
  const data: any = await parseBody(output.body, context);
  contents.StreamingDistribution = deserializeAws_restXmlStreamingDistribution(
    data,
    context
  );
  return Promise.resolve(contents);
};

const deserializeAws_restXmlCreateStreamingDistributionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateStreamingDistributionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDenied":
    case "com.amazonaws.cloudfront#AccessDenied":
      response = {
        ...(await deserializeAws_restXmlAccessDeniedResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "CNAMEAlreadyExists":
    case "com.amazonaws.cloudfront#CNAMEAlreadyExists":
      response = {
        ...(await deserializeAws_restXmlCNAMEAlreadyExistsResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InconsistentQuantities":
    case "com.amazonaws.cloudfront#InconsistentQuantities":
      response = {
        ...(await deserializeAws_restXmlInconsistentQuantitiesResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidArgument":
    case "com.amazonaws.cloudfront#InvalidArgument":
      response = {
        ...(await deserializeAws_restXmlInvalidArgumentResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidOrigin":
    case "com.amazonaws.cloudfront#InvalidOrigin":
      response = {
        ...(await deserializeAws_restXmlInvalidOriginResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidOriginAccessIdentity":
    case "com.amazonaws.cloudfront#InvalidOriginAccessIdentity":
      response = {
        ...(await deserializeAws_restXmlInvalidOriginAccessIdentityResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MissingBody":
    case "com.amazonaws.cloudfront#MissingBody":
      response = {
        ...(await deserializeAws_restXmlMissingBodyResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "StreamingDistributionAlreadyExists":
    case "com.amazonaws.cloudfront#StreamingDistributionAlreadyExists":
      response = {
        ...(await deserializeAws_restXmlStreamingDistributionAlreadyExistsResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyStreamingDistributionCNAMEs":
    case "com.amazonaws.cloudfront#TooManyStreamingDistributionCNAMEs":
      response = {
        ...(await deserializeAws_restXmlTooManyStreamingDistributionCNAMEsResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyStreamingDistributions":
    case "com.amazonaws.cloudfront#TooManyStreamingDistributions":
      response = {
        ...(await deserializeAws_restXmlTooManyStreamingDistributionsResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyTrustedSigners":
    case "com.amazonaws.cloudfront#TooManyTrustedSigners":
      response = {
        ...(await deserializeAws_restXmlTooManyTrustedSignersResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TrustedSignerDoesNotExist":
    case "com.amazonaws.cloudfront#TrustedSignerDoesNotExist":
      response = {
        ...(await deserializeAws_restXmlTrustedSignerDoesNotExistResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlCreateStreamingDistributionWithTagsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateStreamingDistributionWithTagsCommandOutput> => {
  if (output.statusCode !== 201 && output.statusCode >= 400) {
    return deserializeAws_restXmlCreateStreamingDistributionWithTagsCommandError(
      output,
      context
    );
  }
  const contents: CreateStreamingDistributionWithTagsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateStreamingDistributionWithTagsResult",
    ETag: undefined,
    Location: undefined,
    StreamingDistribution: undefined
  };
  if (output.headers["etag"] !== undefined) {
    contents.ETag = output.headers["etag"];
  }
  if (output.headers["location"] !== undefined) {
    contents.Location = output.headers["location"];
  }
  const data: any = await parseBody(output.body, context);
  contents.StreamingDistribution = deserializeAws_restXmlStreamingDistribution(
    data,
    context
  );
  return Promise.resolve(contents);
};

const deserializeAws_restXmlCreateStreamingDistributionWithTagsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateStreamingDistributionWithTagsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDenied":
    case "com.amazonaws.cloudfront#AccessDenied":
      response = {
        ...(await deserializeAws_restXmlAccessDeniedResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "CNAMEAlreadyExists":
    case "com.amazonaws.cloudfront#CNAMEAlreadyExists":
      response = {
        ...(await deserializeAws_restXmlCNAMEAlreadyExistsResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InconsistentQuantities":
    case "com.amazonaws.cloudfront#InconsistentQuantities":
      response = {
        ...(await deserializeAws_restXmlInconsistentQuantitiesResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidArgument":
    case "com.amazonaws.cloudfront#InvalidArgument":
      response = {
        ...(await deserializeAws_restXmlInvalidArgumentResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidOrigin":
    case "com.amazonaws.cloudfront#InvalidOrigin":
      response = {
        ...(await deserializeAws_restXmlInvalidOriginResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidOriginAccessIdentity":
    case "com.amazonaws.cloudfront#InvalidOriginAccessIdentity":
      response = {
        ...(await deserializeAws_restXmlInvalidOriginAccessIdentityResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidTagging":
    case "com.amazonaws.cloudfront#InvalidTagging":
      response = {
        ...(await deserializeAws_restXmlInvalidTaggingResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MissingBody":
    case "com.amazonaws.cloudfront#MissingBody":
      response = {
        ...(await deserializeAws_restXmlMissingBodyResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "StreamingDistributionAlreadyExists":
    case "com.amazonaws.cloudfront#StreamingDistributionAlreadyExists":
      response = {
        ...(await deserializeAws_restXmlStreamingDistributionAlreadyExistsResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyStreamingDistributionCNAMEs":
    case "com.amazonaws.cloudfront#TooManyStreamingDistributionCNAMEs":
      response = {
        ...(await deserializeAws_restXmlTooManyStreamingDistributionCNAMEsResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyStreamingDistributions":
    case "com.amazonaws.cloudfront#TooManyStreamingDistributions":
      response = {
        ...(await deserializeAws_restXmlTooManyStreamingDistributionsResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyTrustedSigners":
    case "com.amazonaws.cloudfront#TooManyTrustedSigners":
      response = {
        ...(await deserializeAws_restXmlTooManyTrustedSignersResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TrustedSignerDoesNotExist":
    case "com.amazonaws.cloudfront#TrustedSignerDoesNotExist":
      response = {
        ...(await deserializeAws_restXmlTrustedSignerDoesNotExistResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlDeleteCloudFrontOriginAccessIdentityCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteCloudFrontOriginAccessIdentityCommandOutput> => {
  if (output.statusCode !== 204 && output.statusCode >= 400) {
    return deserializeAws_restXmlDeleteCloudFrontOriginAccessIdentityCommandError(
      output,
      context
    );
  }
  const contents: DeleteCloudFrontOriginAccessIdentityCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restXmlDeleteCloudFrontOriginAccessIdentityCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteCloudFrontOriginAccessIdentityCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDenied":
    case "com.amazonaws.cloudfront#AccessDenied":
      response = {
        ...(await deserializeAws_restXmlAccessDeniedResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "CloudFrontOriginAccessIdentityInUse":
    case "com.amazonaws.cloudfront#CloudFrontOriginAccessIdentityInUse":
      response = {
        ...(await deserializeAws_restXmlCloudFrontOriginAccessIdentityInUseResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidIfMatchVersion":
    case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
      response = {
        ...(await deserializeAws_restXmlInvalidIfMatchVersionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NoSuchCloudFrontOriginAccessIdentity":
    case "com.amazonaws.cloudfront#NoSuchCloudFrontOriginAccessIdentity":
      response = {
        ...(await deserializeAws_restXmlNoSuchCloudFrontOriginAccessIdentityResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "PreconditionFailed":
    case "com.amazonaws.cloudfront#PreconditionFailed":
      response = {
        ...(await deserializeAws_restXmlPreconditionFailedResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlDeleteDistributionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteDistributionCommandOutput> => {
  if (output.statusCode !== 204 && output.statusCode >= 400) {
    return deserializeAws_restXmlDeleteDistributionCommandError(
      output,
      context
    );
  }
  const contents: DeleteDistributionCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restXmlDeleteDistributionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteDistributionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDenied":
    case "com.amazonaws.cloudfront#AccessDenied":
      response = {
        ...(await deserializeAws_restXmlAccessDeniedResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DistributionNotDisabled":
    case "com.amazonaws.cloudfront#DistributionNotDisabled":
      response = {
        ...(await deserializeAws_restXmlDistributionNotDisabledResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidIfMatchVersion":
    case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
      response = {
        ...(await deserializeAws_restXmlInvalidIfMatchVersionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NoSuchDistribution":
    case "com.amazonaws.cloudfront#NoSuchDistribution":
      response = {
        ...(await deserializeAws_restXmlNoSuchDistributionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "PreconditionFailed":
    case "com.amazonaws.cloudfront#PreconditionFailed":
      response = {
        ...(await deserializeAws_restXmlPreconditionFailedResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlDeleteFieldLevelEncryptionConfigCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteFieldLevelEncryptionConfigCommandOutput> => {
  if (output.statusCode !== 204 && output.statusCode >= 400) {
    return deserializeAws_restXmlDeleteFieldLevelEncryptionConfigCommandError(
      output,
      context
    );
  }
  const contents: DeleteFieldLevelEncryptionConfigCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restXmlDeleteFieldLevelEncryptionConfigCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteFieldLevelEncryptionConfigCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDenied":
    case "com.amazonaws.cloudfront#AccessDenied":
      response = {
        ...(await deserializeAws_restXmlAccessDeniedResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "FieldLevelEncryptionConfigInUse":
    case "com.amazonaws.cloudfront#FieldLevelEncryptionConfigInUse":
      response = {
        ...(await deserializeAws_restXmlFieldLevelEncryptionConfigInUseResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidIfMatchVersion":
    case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
      response = {
        ...(await deserializeAws_restXmlInvalidIfMatchVersionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NoSuchFieldLevelEncryptionConfig":
    case "com.amazonaws.cloudfront#NoSuchFieldLevelEncryptionConfig":
      response = {
        ...(await deserializeAws_restXmlNoSuchFieldLevelEncryptionConfigResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "PreconditionFailed":
    case "com.amazonaws.cloudfront#PreconditionFailed":
      response = {
        ...(await deserializeAws_restXmlPreconditionFailedResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlDeleteFieldLevelEncryptionProfileCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteFieldLevelEncryptionProfileCommandOutput> => {
  if (output.statusCode !== 204 && output.statusCode >= 400) {
    return deserializeAws_restXmlDeleteFieldLevelEncryptionProfileCommandError(
      output,
      context
    );
  }
  const contents: DeleteFieldLevelEncryptionProfileCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restXmlDeleteFieldLevelEncryptionProfileCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteFieldLevelEncryptionProfileCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDenied":
    case "com.amazonaws.cloudfront#AccessDenied":
      response = {
        ...(await deserializeAws_restXmlAccessDeniedResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "FieldLevelEncryptionProfileInUse":
    case "com.amazonaws.cloudfront#FieldLevelEncryptionProfileInUse":
      response = {
        ...(await deserializeAws_restXmlFieldLevelEncryptionProfileInUseResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidIfMatchVersion":
    case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
      response = {
        ...(await deserializeAws_restXmlInvalidIfMatchVersionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NoSuchFieldLevelEncryptionProfile":
    case "com.amazonaws.cloudfront#NoSuchFieldLevelEncryptionProfile":
      response = {
        ...(await deserializeAws_restXmlNoSuchFieldLevelEncryptionProfileResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "PreconditionFailed":
    case "com.amazonaws.cloudfront#PreconditionFailed":
      response = {
        ...(await deserializeAws_restXmlPreconditionFailedResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlDeletePublicKeyCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeletePublicKeyCommandOutput> => {
  if (output.statusCode !== 204 && output.statusCode >= 400) {
    return deserializeAws_restXmlDeletePublicKeyCommandError(output, context);
  }
  const contents: DeletePublicKeyCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restXmlDeletePublicKeyCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeletePublicKeyCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDenied":
    case "com.amazonaws.cloudfront#AccessDenied":
      response = {
        ...(await deserializeAws_restXmlAccessDeniedResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidIfMatchVersion":
    case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
      response = {
        ...(await deserializeAws_restXmlInvalidIfMatchVersionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NoSuchPublicKey":
    case "com.amazonaws.cloudfront#NoSuchPublicKey":
      response = {
        ...(await deserializeAws_restXmlNoSuchPublicKeyResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "PreconditionFailed":
    case "com.amazonaws.cloudfront#PreconditionFailed":
      response = {
        ...(await deserializeAws_restXmlPreconditionFailedResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "PublicKeyInUse":
    case "com.amazonaws.cloudfront#PublicKeyInUse":
      response = {
        ...(await deserializeAws_restXmlPublicKeyInUseResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlDeleteStreamingDistributionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteStreamingDistributionCommandOutput> => {
  if (output.statusCode !== 204 && output.statusCode >= 400) {
    return deserializeAws_restXmlDeleteStreamingDistributionCommandError(
      output,
      context
    );
  }
  const contents: DeleteStreamingDistributionCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restXmlDeleteStreamingDistributionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteStreamingDistributionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDenied":
    case "com.amazonaws.cloudfront#AccessDenied":
      response = {
        ...(await deserializeAws_restXmlAccessDeniedResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidIfMatchVersion":
    case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
      response = {
        ...(await deserializeAws_restXmlInvalidIfMatchVersionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NoSuchStreamingDistribution":
    case "com.amazonaws.cloudfront#NoSuchStreamingDistribution":
      response = {
        ...(await deserializeAws_restXmlNoSuchStreamingDistributionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "PreconditionFailed":
    case "com.amazonaws.cloudfront#PreconditionFailed":
      response = {
        ...(await deserializeAws_restXmlPreconditionFailedResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "StreamingDistributionNotDisabled":
    case "com.amazonaws.cloudfront#StreamingDistributionNotDisabled":
      response = {
        ...(await deserializeAws_restXmlStreamingDistributionNotDisabledResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlGetCloudFrontOriginAccessIdentityCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetCloudFrontOriginAccessIdentityCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlGetCloudFrontOriginAccessIdentityCommandError(
      output,
      context
    );
  }
  const contents: GetCloudFrontOriginAccessIdentityCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetCloudFrontOriginAccessIdentityResult",
    CloudFrontOriginAccessIdentity: undefined,
    ETag: undefined
  };
  if (output.headers["etag"] !== undefined) {
    contents.ETag = output.headers["etag"];
  }
  const data: any = await parseBody(output.body, context);
  contents.CloudFrontOriginAccessIdentity = deserializeAws_restXmlCloudFrontOriginAccessIdentity(
    data,
    context
  );
  return Promise.resolve(contents);
};

const deserializeAws_restXmlGetCloudFrontOriginAccessIdentityCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetCloudFrontOriginAccessIdentityCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDenied":
    case "com.amazonaws.cloudfront#AccessDenied":
      response = {
        ...(await deserializeAws_restXmlAccessDeniedResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NoSuchCloudFrontOriginAccessIdentity":
    case "com.amazonaws.cloudfront#NoSuchCloudFrontOriginAccessIdentity":
      response = {
        ...(await deserializeAws_restXmlNoSuchCloudFrontOriginAccessIdentityResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlGetCloudFrontOriginAccessIdentityConfigCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetCloudFrontOriginAccessIdentityConfigCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlGetCloudFrontOriginAccessIdentityConfigCommandError(
      output,
      context
    );
  }
  const contents: GetCloudFrontOriginAccessIdentityConfigCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetCloudFrontOriginAccessIdentityConfigResult",
    CloudFrontOriginAccessIdentityConfig: undefined,
    ETag: undefined
  };
  if (output.headers["etag"] !== undefined) {
    contents.ETag = output.headers["etag"];
  }
  const data: any = await parseBody(output.body, context);
  contents.CloudFrontOriginAccessIdentityConfig = deserializeAws_restXmlCloudFrontOriginAccessIdentityConfig(
    data,
    context
  );
  return Promise.resolve(contents);
};

const deserializeAws_restXmlGetCloudFrontOriginAccessIdentityConfigCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetCloudFrontOriginAccessIdentityConfigCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDenied":
    case "com.amazonaws.cloudfront#AccessDenied":
      response = {
        ...(await deserializeAws_restXmlAccessDeniedResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NoSuchCloudFrontOriginAccessIdentity":
    case "com.amazonaws.cloudfront#NoSuchCloudFrontOriginAccessIdentity":
      response = {
        ...(await deserializeAws_restXmlNoSuchCloudFrontOriginAccessIdentityResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlGetDistributionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetDistributionCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlGetDistributionCommandError(output, context);
  }
  const contents: GetDistributionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetDistributionResult",
    Distribution: undefined,
    ETag: undefined
  };
  if (output.headers["etag"] !== undefined) {
    contents.ETag = output.headers["etag"];
  }
  const data: any = await parseBody(output.body, context);
  contents.Distribution = deserializeAws_restXmlDistribution(data, context);
  return Promise.resolve(contents);
};

const deserializeAws_restXmlGetDistributionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetDistributionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDenied":
    case "com.amazonaws.cloudfront#AccessDenied":
      response = {
        ...(await deserializeAws_restXmlAccessDeniedResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NoSuchDistribution":
    case "com.amazonaws.cloudfront#NoSuchDistribution":
      response = {
        ...(await deserializeAws_restXmlNoSuchDistributionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlGetDistributionConfigCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetDistributionConfigCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlGetDistributionConfigCommandError(
      output,
      context
    );
  }
  const contents: GetDistributionConfigCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetDistributionConfigResult",
    DistributionConfig: undefined,
    ETag: undefined
  };
  if (output.headers["etag"] !== undefined) {
    contents.ETag = output.headers["etag"];
  }
  const data: any = await parseBody(output.body, context);
  contents.DistributionConfig = deserializeAws_restXmlDistributionConfig(
    data,
    context
  );
  return Promise.resolve(contents);
};

const deserializeAws_restXmlGetDistributionConfigCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetDistributionConfigCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDenied":
    case "com.amazonaws.cloudfront#AccessDenied":
      response = {
        ...(await deserializeAws_restXmlAccessDeniedResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NoSuchDistribution":
    case "com.amazonaws.cloudfront#NoSuchDistribution":
      response = {
        ...(await deserializeAws_restXmlNoSuchDistributionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlGetFieldLevelEncryptionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetFieldLevelEncryptionCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlGetFieldLevelEncryptionCommandError(
      output,
      context
    );
  }
  const contents: GetFieldLevelEncryptionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetFieldLevelEncryptionResult",
    ETag: undefined,
    FieldLevelEncryption: undefined
  };
  if (output.headers["etag"] !== undefined) {
    contents.ETag = output.headers["etag"];
  }
  const data: any = await parseBody(output.body, context);
  contents.FieldLevelEncryption = deserializeAws_restXmlFieldLevelEncryption(
    data,
    context
  );
  return Promise.resolve(contents);
};

const deserializeAws_restXmlGetFieldLevelEncryptionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetFieldLevelEncryptionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDenied":
    case "com.amazonaws.cloudfront#AccessDenied":
      response = {
        ...(await deserializeAws_restXmlAccessDeniedResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NoSuchFieldLevelEncryptionConfig":
    case "com.amazonaws.cloudfront#NoSuchFieldLevelEncryptionConfig":
      response = {
        ...(await deserializeAws_restXmlNoSuchFieldLevelEncryptionConfigResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlGetFieldLevelEncryptionConfigCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetFieldLevelEncryptionConfigCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlGetFieldLevelEncryptionConfigCommandError(
      output,
      context
    );
  }
  const contents: GetFieldLevelEncryptionConfigCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetFieldLevelEncryptionConfigResult",
    ETag: undefined,
    FieldLevelEncryptionConfig: undefined
  };
  if (output.headers["etag"] !== undefined) {
    contents.ETag = output.headers["etag"];
  }
  const data: any = await parseBody(output.body, context);
  contents.FieldLevelEncryptionConfig = deserializeAws_restXmlFieldLevelEncryptionConfig(
    data,
    context
  );
  return Promise.resolve(contents);
};

const deserializeAws_restXmlGetFieldLevelEncryptionConfigCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetFieldLevelEncryptionConfigCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDenied":
    case "com.amazonaws.cloudfront#AccessDenied":
      response = {
        ...(await deserializeAws_restXmlAccessDeniedResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NoSuchFieldLevelEncryptionConfig":
    case "com.amazonaws.cloudfront#NoSuchFieldLevelEncryptionConfig":
      response = {
        ...(await deserializeAws_restXmlNoSuchFieldLevelEncryptionConfigResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlGetFieldLevelEncryptionProfileCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetFieldLevelEncryptionProfileCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlGetFieldLevelEncryptionProfileCommandError(
      output,
      context
    );
  }
  const contents: GetFieldLevelEncryptionProfileCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetFieldLevelEncryptionProfileResult",
    ETag: undefined,
    FieldLevelEncryptionProfile: undefined
  };
  if (output.headers["etag"] !== undefined) {
    contents.ETag = output.headers["etag"];
  }
  const data: any = await parseBody(output.body, context);
  contents.FieldLevelEncryptionProfile = deserializeAws_restXmlFieldLevelEncryptionProfile(
    data,
    context
  );
  return Promise.resolve(contents);
};

const deserializeAws_restXmlGetFieldLevelEncryptionProfileCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetFieldLevelEncryptionProfileCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDenied":
    case "com.amazonaws.cloudfront#AccessDenied":
      response = {
        ...(await deserializeAws_restXmlAccessDeniedResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NoSuchFieldLevelEncryptionProfile":
    case "com.amazonaws.cloudfront#NoSuchFieldLevelEncryptionProfile":
      response = {
        ...(await deserializeAws_restXmlNoSuchFieldLevelEncryptionProfileResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlGetFieldLevelEncryptionProfileConfigCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetFieldLevelEncryptionProfileConfigCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlGetFieldLevelEncryptionProfileConfigCommandError(
      output,
      context
    );
  }
  const contents: GetFieldLevelEncryptionProfileConfigCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetFieldLevelEncryptionProfileConfigResult",
    ETag: undefined,
    FieldLevelEncryptionProfileConfig: undefined
  };
  if (output.headers["etag"] !== undefined) {
    contents.ETag = output.headers["etag"];
  }
  const data: any = await parseBody(output.body, context);
  contents.FieldLevelEncryptionProfileConfig = deserializeAws_restXmlFieldLevelEncryptionProfileConfig(
    data,
    context
  );
  return Promise.resolve(contents);
};

const deserializeAws_restXmlGetFieldLevelEncryptionProfileConfigCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetFieldLevelEncryptionProfileConfigCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDenied":
    case "com.amazonaws.cloudfront#AccessDenied":
      response = {
        ...(await deserializeAws_restXmlAccessDeniedResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NoSuchFieldLevelEncryptionProfile":
    case "com.amazonaws.cloudfront#NoSuchFieldLevelEncryptionProfile":
      response = {
        ...(await deserializeAws_restXmlNoSuchFieldLevelEncryptionProfileResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlGetInvalidationCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetInvalidationCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlGetInvalidationCommandError(output, context);
  }
  const contents: GetInvalidationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetInvalidationResult",
    Invalidation: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.Invalidation = deserializeAws_restXmlInvalidation(data, context);
  return Promise.resolve(contents);
};

const deserializeAws_restXmlGetInvalidationCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetInvalidationCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDenied":
    case "com.amazonaws.cloudfront#AccessDenied":
      response = {
        ...(await deserializeAws_restXmlAccessDeniedResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NoSuchDistribution":
    case "com.amazonaws.cloudfront#NoSuchDistribution":
      response = {
        ...(await deserializeAws_restXmlNoSuchDistributionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NoSuchInvalidation":
    case "com.amazonaws.cloudfront#NoSuchInvalidation":
      response = {
        ...(await deserializeAws_restXmlNoSuchInvalidationResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlGetPublicKeyCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetPublicKeyCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlGetPublicKeyCommandError(output, context);
  }
  const contents: GetPublicKeyCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetPublicKeyResult",
    ETag: undefined,
    PublicKey: undefined
  };
  if (output.headers["etag"] !== undefined) {
    contents.ETag = output.headers["etag"];
  }
  const data: any = await parseBody(output.body, context);
  contents.PublicKey = deserializeAws_restXmlPublicKey(data, context);
  return Promise.resolve(contents);
};

const deserializeAws_restXmlGetPublicKeyCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetPublicKeyCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDenied":
    case "com.amazonaws.cloudfront#AccessDenied":
      response = {
        ...(await deserializeAws_restXmlAccessDeniedResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NoSuchPublicKey":
    case "com.amazonaws.cloudfront#NoSuchPublicKey":
      response = {
        ...(await deserializeAws_restXmlNoSuchPublicKeyResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlGetPublicKeyConfigCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetPublicKeyConfigCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlGetPublicKeyConfigCommandError(
      output,
      context
    );
  }
  const contents: GetPublicKeyConfigCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetPublicKeyConfigResult",
    ETag: undefined,
    PublicKeyConfig: undefined
  };
  if (output.headers["etag"] !== undefined) {
    contents.ETag = output.headers["etag"];
  }
  const data: any = await parseBody(output.body, context);
  contents.PublicKeyConfig = deserializeAws_restXmlPublicKeyConfig(
    data,
    context
  );
  return Promise.resolve(contents);
};

const deserializeAws_restXmlGetPublicKeyConfigCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetPublicKeyConfigCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDenied":
    case "com.amazonaws.cloudfront#AccessDenied":
      response = {
        ...(await deserializeAws_restXmlAccessDeniedResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NoSuchPublicKey":
    case "com.amazonaws.cloudfront#NoSuchPublicKey":
      response = {
        ...(await deserializeAws_restXmlNoSuchPublicKeyResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlGetStreamingDistributionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetStreamingDistributionCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlGetStreamingDistributionCommandError(
      output,
      context
    );
  }
  const contents: GetStreamingDistributionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetStreamingDistributionResult",
    ETag: undefined,
    StreamingDistribution: undefined
  };
  if (output.headers["etag"] !== undefined) {
    contents.ETag = output.headers["etag"];
  }
  const data: any = await parseBody(output.body, context);
  contents.StreamingDistribution = deserializeAws_restXmlStreamingDistribution(
    data,
    context
  );
  return Promise.resolve(contents);
};

const deserializeAws_restXmlGetStreamingDistributionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetStreamingDistributionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDenied":
    case "com.amazonaws.cloudfront#AccessDenied":
      response = {
        ...(await deserializeAws_restXmlAccessDeniedResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NoSuchStreamingDistribution":
    case "com.amazonaws.cloudfront#NoSuchStreamingDistribution":
      response = {
        ...(await deserializeAws_restXmlNoSuchStreamingDistributionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlGetStreamingDistributionConfigCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetStreamingDistributionConfigCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlGetStreamingDistributionConfigCommandError(
      output,
      context
    );
  }
  const contents: GetStreamingDistributionConfigCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetStreamingDistributionConfigResult",
    ETag: undefined,
    StreamingDistributionConfig: undefined
  };
  if (output.headers["etag"] !== undefined) {
    contents.ETag = output.headers["etag"];
  }
  const data: any = await parseBody(output.body, context);
  contents.StreamingDistributionConfig = deserializeAws_restXmlStreamingDistributionConfig(
    data,
    context
  );
  return Promise.resolve(contents);
};

const deserializeAws_restXmlGetStreamingDistributionConfigCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetStreamingDistributionConfigCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDenied":
    case "com.amazonaws.cloudfront#AccessDenied":
      response = {
        ...(await deserializeAws_restXmlAccessDeniedResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NoSuchStreamingDistribution":
    case "com.amazonaws.cloudfront#NoSuchStreamingDistribution":
      response = {
        ...(await deserializeAws_restXmlNoSuchStreamingDistributionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlListCloudFrontOriginAccessIdentitiesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListCloudFrontOriginAccessIdentitiesCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlListCloudFrontOriginAccessIdentitiesCommandError(
      output,
      context
    );
  }
  const contents: ListCloudFrontOriginAccessIdentitiesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListCloudFrontOriginAccessIdentitiesResult",
    CloudFrontOriginAccessIdentityList: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.CloudFrontOriginAccessIdentityList = deserializeAws_restXmlCloudFrontOriginAccessIdentityList(
    data,
    context
  );
  return Promise.resolve(contents);
};

const deserializeAws_restXmlListCloudFrontOriginAccessIdentitiesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListCloudFrontOriginAccessIdentitiesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidArgument":
    case "com.amazonaws.cloudfront#InvalidArgument":
      response = {
        ...(await deserializeAws_restXmlInvalidArgumentResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlListDistributionsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListDistributionsCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlListDistributionsCommandError(output, context);
  }
  const contents: ListDistributionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListDistributionsResult",
    DistributionList: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.DistributionList = deserializeAws_restXmlDistributionList(
    data,
    context
  );
  return Promise.resolve(contents);
};

const deserializeAws_restXmlListDistributionsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListDistributionsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidArgument":
    case "com.amazonaws.cloudfront#InvalidArgument":
      response = {
        ...(await deserializeAws_restXmlInvalidArgumentResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlListDistributionsByWebACLIdCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListDistributionsByWebACLIdCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlListDistributionsByWebACLIdCommandError(
      output,
      context
    );
  }
  const contents: ListDistributionsByWebACLIdCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListDistributionsByWebACLIdResult",
    DistributionList: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.DistributionList = deserializeAws_restXmlDistributionList(
    data,
    context
  );
  return Promise.resolve(contents);
};

const deserializeAws_restXmlListDistributionsByWebACLIdCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListDistributionsByWebACLIdCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidArgument":
    case "com.amazonaws.cloudfront#InvalidArgument":
      response = {
        ...(await deserializeAws_restXmlInvalidArgumentResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidWebACLId":
    case "com.amazonaws.cloudfront#InvalidWebACLId":
      response = {
        ...(await deserializeAws_restXmlInvalidWebACLIdResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlListFieldLevelEncryptionConfigsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListFieldLevelEncryptionConfigsCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlListFieldLevelEncryptionConfigsCommandError(
      output,
      context
    );
  }
  const contents: ListFieldLevelEncryptionConfigsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListFieldLevelEncryptionConfigsResult",
    FieldLevelEncryptionList: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.FieldLevelEncryptionList = deserializeAws_restXmlFieldLevelEncryptionList(
    data,
    context
  );
  return Promise.resolve(contents);
};

const deserializeAws_restXmlListFieldLevelEncryptionConfigsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListFieldLevelEncryptionConfigsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidArgument":
    case "com.amazonaws.cloudfront#InvalidArgument":
      response = {
        ...(await deserializeAws_restXmlInvalidArgumentResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlListFieldLevelEncryptionProfilesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListFieldLevelEncryptionProfilesCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlListFieldLevelEncryptionProfilesCommandError(
      output,
      context
    );
  }
  const contents: ListFieldLevelEncryptionProfilesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListFieldLevelEncryptionProfilesResult",
    FieldLevelEncryptionProfileList: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.FieldLevelEncryptionProfileList = deserializeAws_restXmlFieldLevelEncryptionProfileList(
    data,
    context
  );
  return Promise.resolve(contents);
};

const deserializeAws_restXmlListFieldLevelEncryptionProfilesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListFieldLevelEncryptionProfilesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidArgument":
    case "com.amazonaws.cloudfront#InvalidArgument":
      response = {
        ...(await deserializeAws_restXmlInvalidArgumentResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlListInvalidationsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListInvalidationsCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlListInvalidationsCommandError(output, context);
  }
  const contents: ListInvalidationsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListInvalidationsResult",
    InvalidationList: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.InvalidationList = deserializeAws_restXmlInvalidationList(
    data,
    context
  );
  return Promise.resolve(contents);
};

const deserializeAws_restXmlListInvalidationsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListInvalidationsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDenied":
    case "com.amazonaws.cloudfront#AccessDenied":
      response = {
        ...(await deserializeAws_restXmlAccessDeniedResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidArgument":
    case "com.amazonaws.cloudfront#InvalidArgument":
      response = {
        ...(await deserializeAws_restXmlInvalidArgumentResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NoSuchDistribution":
    case "com.amazonaws.cloudfront#NoSuchDistribution":
      response = {
        ...(await deserializeAws_restXmlNoSuchDistributionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlListPublicKeysCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListPublicKeysCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlListPublicKeysCommandError(output, context);
  }
  const contents: ListPublicKeysCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListPublicKeysResult",
    PublicKeyList: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.PublicKeyList = deserializeAws_restXmlPublicKeyList(data, context);
  return Promise.resolve(contents);
};

const deserializeAws_restXmlListPublicKeysCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListPublicKeysCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidArgument":
    case "com.amazonaws.cloudfront#InvalidArgument":
      response = {
        ...(await deserializeAws_restXmlInvalidArgumentResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlListStreamingDistributionsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListStreamingDistributionsCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlListStreamingDistributionsCommandError(
      output,
      context
    );
  }
  const contents: ListStreamingDistributionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListStreamingDistributionsResult",
    StreamingDistributionList: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.StreamingDistributionList = deserializeAws_restXmlStreamingDistributionList(
    data,
    context
  );
  return Promise.resolve(contents);
};

const deserializeAws_restXmlListStreamingDistributionsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListStreamingDistributionsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidArgument":
    case "com.amazonaws.cloudfront#InvalidArgument":
      response = {
        ...(await deserializeAws_restXmlInvalidArgumentResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlListTagsForResourceCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTagsForResourceCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlListTagsForResourceCommandError(
      output,
      context
    );
  }
  const contents: ListTagsForResourceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListTagsForResourceResult",
    Tags: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.Tags = deserializeAws_restXmlTags(data, context);
  return Promise.resolve(contents);
};

const deserializeAws_restXmlListTagsForResourceCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTagsForResourceCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDenied":
    case "com.amazonaws.cloudfront#AccessDenied":
      response = {
        ...(await deserializeAws_restXmlAccessDeniedResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidArgument":
    case "com.amazonaws.cloudfront#InvalidArgument":
      response = {
        ...(await deserializeAws_restXmlInvalidArgumentResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidTagging":
    case "com.amazonaws.cloudfront#InvalidTagging":
      response = {
        ...(await deserializeAws_restXmlInvalidTaggingResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NoSuchResource":
    case "com.amazonaws.cloudfront#NoSuchResource":
      response = {
        ...(await deserializeAws_restXmlNoSuchResourceResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlTagResourceCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<TagResourceCommandOutput> => {
  if (output.statusCode !== 204 && output.statusCode >= 400) {
    return deserializeAws_restXmlTagResourceCommandError(output, context);
  }
  const contents: TagResourceCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restXmlTagResourceCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<TagResourceCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDenied":
    case "com.amazonaws.cloudfront#AccessDenied":
      response = {
        ...(await deserializeAws_restXmlAccessDeniedResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidArgument":
    case "com.amazonaws.cloudfront#InvalidArgument":
      response = {
        ...(await deserializeAws_restXmlInvalidArgumentResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidTagging":
    case "com.amazonaws.cloudfront#InvalidTagging":
      response = {
        ...(await deserializeAws_restXmlInvalidTaggingResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NoSuchResource":
    case "com.amazonaws.cloudfront#NoSuchResource":
      response = {
        ...(await deserializeAws_restXmlNoSuchResourceResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlUntagResourceCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UntagResourceCommandOutput> => {
  if (output.statusCode !== 204 && output.statusCode >= 400) {
    return deserializeAws_restXmlUntagResourceCommandError(output, context);
  }
  const contents: UntagResourceCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restXmlUntagResourceCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UntagResourceCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDenied":
    case "com.amazonaws.cloudfront#AccessDenied":
      response = {
        ...(await deserializeAws_restXmlAccessDeniedResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidArgument":
    case "com.amazonaws.cloudfront#InvalidArgument":
      response = {
        ...(await deserializeAws_restXmlInvalidArgumentResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidTagging":
    case "com.amazonaws.cloudfront#InvalidTagging":
      response = {
        ...(await deserializeAws_restXmlInvalidTaggingResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NoSuchResource":
    case "com.amazonaws.cloudfront#NoSuchResource":
      response = {
        ...(await deserializeAws_restXmlNoSuchResourceResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlUpdateCloudFrontOriginAccessIdentityCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateCloudFrontOriginAccessIdentityCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlUpdateCloudFrontOriginAccessIdentityCommandError(
      output,
      context
    );
  }
  const contents: UpdateCloudFrontOriginAccessIdentityCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateCloudFrontOriginAccessIdentityResult",
    CloudFrontOriginAccessIdentity: undefined,
    ETag: undefined
  };
  if (output.headers["etag"] !== undefined) {
    contents.ETag = output.headers["etag"];
  }
  const data: any = await parseBody(output.body, context);
  contents.CloudFrontOriginAccessIdentity = deserializeAws_restXmlCloudFrontOriginAccessIdentity(
    data,
    context
  );
  return Promise.resolve(contents);
};

const deserializeAws_restXmlUpdateCloudFrontOriginAccessIdentityCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateCloudFrontOriginAccessIdentityCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDenied":
    case "com.amazonaws.cloudfront#AccessDenied":
      response = {
        ...(await deserializeAws_restXmlAccessDeniedResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "IllegalUpdate":
    case "com.amazonaws.cloudfront#IllegalUpdate":
      response = {
        ...(await deserializeAws_restXmlIllegalUpdateResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InconsistentQuantities":
    case "com.amazonaws.cloudfront#InconsistentQuantities":
      response = {
        ...(await deserializeAws_restXmlInconsistentQuantitiesResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidArgument":
    case "com.amazonaws.cloudfront#InvalidArgument":
      response = {
        ...(await deserializeAws_restXmlInvalidArgumentResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidIfMatchVersion":
    case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
      response = {
        ...(await deserializeAws_restXmlInvalidIfMatchVersionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MissingBody":
    case "com.amazonaws.cloudfront#MissingBody":
      response = {
        ...(await deserializeAws_restXmlMissingBodyResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NoSuchCloudFrontOriginAccessIdentity":
    case "com.amazonaws.cloudfront#NoSuchCloudFrontOriginAccessIdentity":
      response = {
        ...(await deserializeAws_restXmlNoSuchCloudFrontOriginAccessIdentityResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "PreconditionFailed":
    case "com.amazonaws.cloudfront#PreconditionFailed":
      response = {
        ...(await deserializeAws_restXmlPreconditionFailedResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlUpdateDistributionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateDistributionCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlUpdateDistributionCommandError(
      output,
      context
    );
  }
  const contents: UpdateDistributionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateDistributionResult",
    Distribution: undefined,
    ETag: undefined
  };
  if (output.headers["etag"] !== undefined) {
    contents.ETag = output.headers["etag"];
  }
  const data: any = await parseBody(output.body, context);
  contents.Distribution = deserializeAws_restXmlDistribution(data, context);
  return Promise.resolve(contents);
};

const deserializeAws_restXmlUpdateDistributionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateDistributionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDenied":
    case "com.amazonaws.cloudfront#AccessDenied":
      response = {
        ...(await deserializeAws_restXmlAccessDeniedResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "CNAMEAlreadyExists":
    case "com.amazonaws.cloudfront#CNAMEAlreadyExists":
      response = {
        ...(await deserializeAws_restXmlCNAMEAlreadyExistsResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior":
    case "com.amazonaws.cloudfront#IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior":
      response = {
        ...(await deserializeAws_restXmlIllegalFieldLevelEncryptionConfigAssociationWithCacheBehaviorResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "IllegalUpdate":
    case "com.amazonaws.cloudfront#IllegalUpdate":
      response = {
        ...(await deserializeAws_restXmlIllegalUpdateResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InconsistentQuantities":
    case "com.amazonaws.cloudfront#InconsistentQuantities":
      response = {
        ...(await deserializeAws_restXmlInconsistentQuantitiesResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidArgument":
    case "com.amazonaws.cloudfront#InvalidArgument":
      response = {
        ...(await deserializeAws_restXmlInvalidArgumentResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDefaultRootObject":
    case "com.amazonaws.cloudfront#InvalidDefaultRootObject":
      response = {
        ...(await deserializeAws_restXmlInvalidDefaultRootObjectResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidErrorCode":
    case "com.amazonaws.cloudfront#InvalidErrorCode":
      response = {
        ...(await deserializeAws_restXmlInvalidErrorCodeResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidForwardCookies":
    case "com.amazonaws.cloudfront#InvalidForwardCookies":
      response = {
        ...(await deserializeAws_restXmlInvalidForwardCookiesResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidGeoRestrictionParameter":
    case "com.amazonaws.cloudfront#InvalidGeoRestrictionParameter":
      response = {
        ...(await deserializeAws_restXmlInvalidGeoRestrictionParameterResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidHeadersForS3Origin":
    case "com.amazonaws.cloudfront#InvalidHeadersForS3Origin":
      response = {
        ...(await deserializeAws_restXmlInvalidHeadersForS3OriginResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidIfMatchVersion":
    case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
      response = {
        ...(await deserializeAws_restXmlInvalidIfMatchVersionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidLambdaFunctionAssociation":
    case "com.amazonaws.cloudfront#InvalidLambdaFunctionAssociation":
      response = {
        ...(await deserializeAws_restXmlInvalidLambdaFunctionAssociationResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidLocationCode":
    case "com.amazonaws.cloudfront#InvalidLocationCode":
      response = {
        ...(await deserializeAws_restXmlInvalidLocationCodeResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidMinimumProtocolVersion":
    case "com.amazonaws.cloudfront#InvalidMinimumProtocolVersion":
      response = {
        ...(await deserializeAws_restXmlInvalidMinimumProtocolVersionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidOriginAccessIdentity":
    case "com.amazonaws.cloudfront#InvalidOriginAccessIdentity":
      response = {
        ...(await deserializeAws_restXmlInvalidOriginAccessIdentityResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidOriginKeepaliveTimeout":
    case "com.amazonaws.cloudfront#InvalidOriginKeepaliveTimeout":
      response = {
        ...(await deserializeAws_restXmlInvalidOriginKeepaliveTimeoutResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidOriginReadTimeout":
    case "com.amazonaws.cloudfront#InvalidOriginReadTimeout":
      response = {
        ...(await deserializeAws_restXmlInvalidOriginReadTimeoutResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidQueryStringParameters":
    case "com.amazonaws.cloudfront#InvalidQueryStringParameters":
      response = {
        ...(await deserializeAws_restXmlInvalidQueryStringParametersResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRelativePath":
    case "com.amazonaws.cloudfront#InvalidRelativePath":
      response = {
        ...(await deserializeAws_restXmlInvalidRelativePathResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequiredProtocol":
    case "com.amazonaws.cloudfront#InvalidRequiredProtocol":
      response = {
        ...(await deserializeAws_restXmlInvalidRequiredProtocolResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidResponseCode":
    case "com.amazonaws.cloudfront#InvalidResponseCode":
      response = {
        ...(await deserializeAws_restXmlInvalidResponseCodeResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidTTLOrder":
    case "com.amazonaws.cloudfront#InvalidTTLOrder":
      response = {
        ...(await deserializeAws_restXmlInvalidTTLOrderResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidViewerCertificate":
    case "com.amazonaws.cloudfront#InvalidViewerCertificate":
      response = {
        ...(await deserializeAws_restXmlInvalidViewerCertificateResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidWebACLId":
    case "com.amazonaws.cloudfront#InvalidWebACLId":
      response = {
        ...(await deserializeAws_restXmlInvalidWebACLIdResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MissingBody":
    case "com.amazonaws.cloudfront#MissingBody":
      response = {
        ...(await deserializeAws_restXmlMissingBodyResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NoSuchDistribution":
    case "com.amazonaws.cloudfront#NoSuchDistribution":
      response = {
        ...(await deserializeAws_restXmlNoSuchDistributionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NoSuchFieldLevelEncryptionConfig":
    case "com.amazonaws.cloudfront#NoSuchFieldLevelEncryptionConfig":
      response = {
        ...(await deserializeAws_restXmlNoSuchFieldLevelEncryptionConfigResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NoSuchOrigin":
    case "com.amazonaws.cloudfront#NoSuchOrigin":
      response = {
        ...(await deserializeAws_restXmlNoSuchOriginResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "PreconditionFailed":
    case "com.amazonaws.cloudfront#PreconditionFailed":
      response = {
        ...(await deserializeAws_restXmlPreconditionFailedResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyCacheBehaviors":
    case "com.amazonaws.cloudfront#TooManyCacheBehaviors":
      response = {
        ...(await deserializeAws_restXmlTooManyCacheBehaviorsResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyCertificates":
    case "com.amazonaws.cloudfront#TooManyCertificates":
      response = {
        ...(await deserializeAws_restXmlTooManyCertificatesResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyCookieNamesInWhiteList":
    case "com.amazonaws.cloudfront#TooManyCookieNamesInWhiteList":
      response = {
        ...(await deserializeAws_restXmlTooManyCookieNamesInWhiteListResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyDistributionCNAMEs":
    case "com.amazonaws.cloudfront#TooManyDistributionCNAMEs":
      response = {
        ...(await deserializeAws_restXmlTooManyDistributionCNAMEsResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyDistributionsAssociatedToFieldLevelEncryptionConfig":
    case "com.amazonaws.cloudfront#TooManyDistributionsAssociatedToFieldLevelEncryptionConfig":
      response = {
        ...(await deserializeAws_restXmlTooManyDistributionsAssociatedToFieldLevelEncryptionConfigResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyDistributionsWithLambdaAssociations":
    case "com.amazonaws.cloudfront#TooManyDistributionsWithLambdaAssociations":
      response = {
        ...(await deserializeAws_restXmlTooManyDistributionsWithLambdaAssociationsResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyHeadersInForwardedValues":
    case "com.amazonaws.cloudfront#TooManyHeadersInForwardedValues":
      response = {
        ...(await deserializeAws_restXmlTooManyHeadersInForwardedValuesResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyLambdaFunctionAssociations":
    case "com.amazonaws.cloudfront#TooManyLambdaFunctionAssociations":
      response = {
        ...(await deserializeAws_restXmlTooManyLambdaFunctionAssociationsResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyOriginCustomHeaders":
    case "com.amazonaws.cloudfront#TooManyOriginCustomHeaders":
      response = {
        ...(await deserializeAws_restXmlTooManyOriginCustomHeadersResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyOriginGroupsPerDistribution":
    case "com.amazonaws.cloudfront#TooManyOriginGroupsPerDistribution":
      response = {
        ...(await deserializeAws_restXmlTooManyOriginGroupsPerDistributionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyOrigins":
    case "com.amazonaws.cloudfront#TooManyOrigins":
      response = {
        ...(await deserializeAws_restXmlTooManyOriginsResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyQueryStringParameters":
    case "com.amazonaws.cloudfront#TooManyQueryStringParameters":
      response = {
        ...(await deserializeAws_restXmlTooManyQueryStringParametersResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyTrustedSigners":
    case "com.amazonaws.cloudfront#TooManyTrustedSigners":
      response = {
        ...(await deserializeAws_restXmlTooManyTrustedSignersResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TrustedSignerDoesNotExist":
    case "com.amazonaws.cloudfront#TrustedSignerDoesNotExist":
      response = {
        ...(await deserializeAws_restXmlTrustedSignerDoesNotExistResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlUpdateFieldLevelEncryptionConfigCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateFieldLevelEncryptionConfigCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlUpdateFieldLevelEncryptionConfigCommandError(
      output,
      context
    );
  }
  const contents: UpdateFieldLevelEncryptionConfigCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateFieldLevelEncryptionConfigResult",
    ETag: undefined,
    FieldLevelEncryption: undefined
  };
  if (output.headers["etag"] !== undefined) {
    contents.ETag = output.headers["etag"];
  }
  const data: any = await parseBody(output.body, context);
  contents.FieldLevelEncryption = deserializeAws_restXmlFieldLevelEncryption(
    data,
    context
  );
  return Promise.resolve(contents);
};

const deserializeAws_restXmlUpdateFieldLevelEncryptionConfigCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateFieldLevelEncryptionConfigCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDenied":
    case "com.amazonaws.cloudfront#AccessDenied":
      response = {
        ...(await deserializeAws_restXmlAccessDeniedResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "IllegalUpdate":
    case "com.amazonaws.cloudfront#IllegalUpdate":
      response = {
        ...(await deserializeAws_restXmlIllegalUpdateResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InconsistentQuantities":
    case "com.amazonaws.cloudfront#InconsistentQuantities":
      response = {
        ...(await deserializeAws_restXmlInconsistentQuantitiesResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidArgument":
    case "com.amazonaws.cloudfront#InvalidArgument":
      response = {
        ...(await deserializeAws_restXmlInvalidArgumentResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidIfMatchVersion":
    case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
      response = {
        ...(await deserializeAws_restXmlInvalidIfMatchVersionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NoSuchFieldLevelEncryptionConfig":
    case "com.amazonaws.cloudfront#NoSuchFieldLevelEncryptionConfig":
      response = {
        ...(await deserializeAws_restXmlNoSuchFieldLevelEncryptionConfigResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NoSuchFieldLevelEncryptionProfile":
    case "com.amazonaws.cloudfront#NoSuchFieldLevelEncryptionProfile":
      response = {
        ...(await deserializeAws_restXmlNoSuchFieldLevelEncryptionProfileResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "PreconditionFailed":
    case "com.amazonaws.cloudfront#PreconditionFailed":
      response = {
        ...(await deserializeAws_restXmlPreconditionFailedResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "QueryArgProfileEmpty":
    case "com.amazonaws.cloudfront#QueryArgProfileEmpty":
      response = {
        ...(await deserializeAws_restXmlQueryArgProfileEmptyResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyFieldLevelEncryptionContentTypeProfiles":
    case "com.amazonaws.cloudfront#TooManyFieldLevelEncryptionContentTypeProfiles":
      response = {
        ...(await deserializeAws_restXmlTooManyFieldLevelEncryptionContentTypeProfilesResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyFieldLevelEncryptionQueryArgProfiles":
    case "com.amazonaws.cloudfront#TooManyFieldLevelEncryptionQueryArgProfiles":
      response = {
        ...(await deserializeAws_restXmlTooManyFieldLevelEncryptionQueryArgProfilesResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlUpdateFieldLevelEncryptionProfileCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateFieldLevelEncryptionProfileCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlUpdateFieldLevelEncryptionProfileCommandError(
      output,
      context
    );
  }
  const contents: UpdateFieldLevelEncryptionProfileCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateFieldLevelEncryptionProfileResult",
    ETag: undefined,
    FieldLevelEncryptionProfile: undefined
  };
  if (output.headers["etag"] !== undefined) {
    contents.ETag = output.headers["etag"];
  }
  const data: any = await parseBody(output.body, context);
  contents.FieldLevelEncryptionProfile = deserializeAws_restXmlFieldLevelEncryptionProfile(
    data,
    context
  );
  return Promise.resolve(contents);
};

const deserializeAws_restXmlUpdateFieldLevelEncryptionProfileCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateFieldLevelEncryptionProfileCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDenied":
    case "com.amazonaws.cloudfront#AccessDenied":
      response = {
        ...(await deserializeAws_restXmlAccessDeniedResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "FieldLevelEncryptionProfileAlreadyExists":
    case "com.amazonaws.cloudfront#FieldLevelEncryptionProfileAlreadyExists":
      response = {
        ...(await deserializeAws_restXmlFieldLevelEncryptionProfileAlreadyExistsResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "FieldLevelEncryptionProfileSizeExceeded":
    case "com.amazonaws.cloudfront#FieldLevelEncryptionProfileSizeExceeded":
      response = {
        ...(await deserializeAws_restXmlFieldLevelEncryptionProfileSizeExceededResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "IllegalUpdate":
    case "com.amazonaws.cloudfront#IllegalUpdate":
      response = {
        ...(await deserializeAws_restXmlIllegalUpdateResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InconsistentQuantities":
    case "com.amazonaws.cloudfront#InconsistentQuantities":
      response = {
        ...(await deserializeAws_restXmlInconsistentQuantitiesResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidArgument":
    case "com.amazonaws.cloudfront#InvalidArgument":
      response = {
        ...(await deserializeAws_restXmlInvalidArgumentResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidIfMatchVersion":
    case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
      response = {
        ...(await deserializeAws_restXmlInvalidIfMatchVersionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NoSuchFieldLevelEncryptionProfile":
    case "com.amazonaws.cloudfront#NoSuchFieldLevelEncryptionProfile":
      response = {
        ...(await deserializeAws_restXmlNoSuchFieldLevelEncryptionProfileResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NoSuchPublicKey":
    case "com.amazonaws.cloudfront#NoSuchPublicKey":
      response = {
        ...(await deserializeAws_restXmlNoSuchPublicKeyResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "PreconditionFailed":
    case "com.amazonaws.cloudfront#PreconditionFailed":
      response = {
        ...(await deserializeAws_restXmlPreconditionFailedResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyFieldLevelEncryptionEncryptionEntities":
    case "com.amazonaws.cloudfront#TooManyFieldLevelEncryptionEncryptionEntities":
      response = {
        ...(await deserializeAws_restXmlTooManyFieldLevelEncryptionEncryptionEntitiesResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyFieldLevelEncryptionFieldPatterns":
    case "com.amazonaws.cloudfront#TooManyFieldLevelEncryptionFieldPatterns":
      response = {
        ...(await deserializeAws_restXmlTooManyFieldLevelEncryptionFieldPatternsResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlUpdatePublicKeyCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdatePublicKeyCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlUpdatePublicKeyCommandError(output, context);
  }
  const contents: UpdatePublicKeyCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdatePublicKeyResult",
    ETag: undefined,
    PublicKey: undefined
  };
  if (output.headers["etag"] !== undefined) {
    contents.ETag = output.headers["etag"];
  }
  const data: any = await parseBody(output.body, context);
  contents.PublicKey = deserializeAws_restXmlPublicKey(data, context);
  return Promise.resolve(contents);
};

const deserializeAws_restXmlUpdatePublicKeyCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdatePublicKeyCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDenied":
    case "com.amazonaws.cloudfront#AccessDenied":
      response = {
        ...(await deserializeAws_restXmlAccessDeniedResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "CannotChangeImmutablePublicKeyFields":
    case "com.amazonaws.cloudfront#CannotChangeImmutablePublicKeyFields":
      response = {
        ...(await deserializeAws_restXmlCannotChangeImmutablePublicKeyFieldsResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "IllegalUpdate":
    case "com.amazonaws.cloudfront#IllegalUpdate":
      response = {
        ...(await deserializeAws_restXmlIllegalUpdateResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidArgument":
    case "com.amazonaws.cloudfront#InvalidArgument":
      response = {
        ...(await deserializeAws_restXmlInvalidArgumentResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidIfMatchVersion":
    case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
      response = {
        ...(await deserializeAws_restXmlInvalidIfMatchVersionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NoSuchPublicKey":
    case "com.amazonaws.cloudfront#NoSuchPublicKey":
      response = {
        ...(await deserializeAws_restXmlNoSuchPublicKeyResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "PreconditionFailed":
    case "com.amazonaws.cloudfront#PreconditionFailed":
      response = {
        ...(await deserializeAws_restXmlPreconditionFailedResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlUpdateStreamingDistributionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateStreamingDistributionCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlUpdateStreamingDistributionCommandError(
      output,
      context
    );
  }
  const contents: UpdateStreamingDistributionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateStreamingDistributionResult",
    ETag: undefined,
    StreamingDistribution: undefined
  };
  if (output.headers["etag"] !== undefined) {
    contents.ETag = output.headers["etag"];
  }
  const data: any = await parseBody(output.body, context);
  contents.StreamingDistribution = deserializeAws_restXmlStreamingDistribution(
    data,
    context
  );
  return Promise.resolve(contents);
};

const deserializeAws_restXmlUpdateStreamingDistributionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateStreamingDistributionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDenied":
    case "com.amazonaws.cloudfront#AccessDenied":
      response = {
        ...(await deserializeAws_restXmlAccessDeniedResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "CNAMEAlreadyExists":
    case "com.amazonaws.cloudfront#CNAMEAlreadyExists":
      response = {
        ...(await deserializeAws_restXmlCNAMEAlreadyExistsResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "IllegalUpdate":
    case "com.amazonaws.cloudfront#IllegalUpdate":
      response = {
        ...(await deserializeAws_restXmlIllegalUpdateResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InconsistentQuantities":
    case "com.amazonaws.cloudfront#InconsistentQuantities":
      response = {
        ...(await deserializeAws_restXmlInconsistentQuantitiesResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidArgument":
    case "com.amazonaws.cloudfront#InvalidArgument":
      response = {
        ...(await deserializeAws_restXmlInvalidArgumentResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidIfMatchVersion":
    case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
      response = {
        ...(await deserializeAws_restXmlInvalidIfMatchVersionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidOriginAccessIdentity":
    case "com.amazonaws.cloudfront#InvalidOriginAccessIdentity":
      response = {
        ...(await deserializeAws_restXmlInvalidOriginAccessIdentityResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MissingBody":
    case "com.amazonaws.cloudfront#MissingBody":
      response = {
        ...(await deserializeAws_restXmlMissingBodyResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NoSuchStreamingDistribution":
    case "com.amazonaws.cloudfront#NoSuchStreamingDistribution":
      response = {
        ...(await deserializeAws_restXmlNoSuchStreamingDistributionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "PreconditionFailed":
    case "com.amazonaws.cloudfront#PreconditionFailed":
      response = {
        ...(await deserializeAws_restXmlPreconditionFailedResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyStreamingDistributionCNAMEs":
    case "com.amazonaws.cloudfront#TooManyStreamingDistributionCNAMEs":
      response = {
        ...(await deserializeAws_restXmlTooManyStreamingDistributionCNAMEsResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyTrustedSigners":
    case "com.amazonaws.cloudfront#TooManyTrustedSigners":
      response = {
        ...(await deserializeAws_restXmlTooManyTrustedSignersResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TrustedSignerDoesNotExist":
    case "com.amazonaws.cloudfront#TrustedSignerDoesNotExist":
      response = {
        ...(await deserializeAws_restXmlTrustedSignerDoesNotExistResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

const deserializeAws_restXmlAccessDeniedResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<AccessDenied> => {
  const contents: AccessDenied = {
    name: "AccessDenied",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlBatchTooLargeResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<BatchTooLarge> => {
  const contents: BatchTooLarge = {
    name: "BatchTooLarge",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlCannotChangeImmutablePublicKeyFieldsResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<CannotChangeImmutablePublicKeyFields> => {
  const contents: CannotChangeImmutablePublicKeyFields = {
    name: "CannotChangeImmutablePublicKeyFields",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlCloudFrontOriginAccessIdentityAlreadyExistsResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<CloudFrontOriginAccessIdentityAlreadyExists> => {
  const contents: CloudFrontOriginAccessIdentityAlreadyExists = {
    name: "CloudFrontOriginAccessIdentityAlreadyExists",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlCloudFrontOriginAccessIdentityInUseResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<CloudFrontOriginAccessIdentityInUse> => {
  const contents: CloudFrontOriginAccessIdentityInUse = {
    name: "CloudFrontOriginAccessIdentityInUse",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlCNAMEAlreadyExistsResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<CNAMEAlreadyExists> => {
  const contents: CNAMEAlreadyExists = {
    name: "CNAMEAlreadyExists",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlDistributionAlreadyExistsResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<DistributionAlreadyExists> => {
  const contents: DistributionAlreadyExists = {
    name: "DistributionAlreadyExists",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlDistributionNotDisabledResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<DistributionNotDisabled> => {
  const contents: DistributionNotDisabled = {
    name: "DistributionNotDisabled",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlFieldLevelEncryptionConfigAlreadyExistsResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<FieldLevelEncryptionConfigAlreadyExists> => {
  const contents: FieldLevelEncryptionConfigAlreadyExists = {
    name: "FieldLevelEncryptionConfigAlreadyExists",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlFieldLevelEncryptionConfigInUseResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<FieldLevelEncryptionConfigInUse> => {
  const contents: FieldLevelEncryptionConfigInUse = {
    name: "FieldLevelEncryptionConfigInUse",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlFieldLevelEncryptionProfileAlreadyExistsResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<FieldLevelEncryptionProfileAlreadyExists> => {
  const contents: FieldLevelEncryptionProfileAlreadyExists = {
    name: "FieldLevelEncryptionProfileAlreadyExists",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlFieldLevelEncryptionProfileInUseResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<FieldLevelEncryptionProfileInUse> => {
  const contents: FieldLevelEncryptionProfileInUse = {
    name: "FieldLevelEncryptionProfileInUse",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlFieldLevelEncryptionProfileSizeExceededResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<FieldLevelEncryptionProfileSizeExceeded> => {
  const contents: FieldLevelEncryptionProfileSizeExceeded = {
    name: "FieldLevelEncryptionProfileSizeExceeded",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlIllegalFieldLevelEncryptionConfigAssociationWithCacheBehaviorResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior> => {
  const contents: IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior = {
    name: "IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlIllegalUpdateResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<IllegalUpdate> => {
  const contents: IllegalUpdate = {
    name: "IllegalUpdate",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlInconsistentQuantitiesResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InconsistentQuantities> => {
  const contents: InconsistentQuantities = {
    name: "InconsistentQuantities",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlInvalidArgumentResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidArgument> => {
  const contents: InvalidArgument = {
    name: "InvalidArgument",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlInvalidDefaultRootObjectResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidDefaultRootObject> => {
  const contents: InvalidDefaultRootObject = {
    name: "InvalidDefaultRootObject",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlInvalidErrorCodeResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidErrorCode> => {
  const contents: InvalidErrorCode = {
    name: "InvalidErrorCode",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlInvalidForwardCookiesResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidForwardCookies> => {
  const contents: InvalidForwardCookies = {
    name: "InvalidForwardCookies",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlInvalidGeoRestrictionParameterResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidGeoRestrictionParameter> => {
  const contents: InvalidGeoRestrictionParameter = {
    name: "InvalidGeoRestrictionParameter",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlInvalidHeadersForS3OriginResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidHeadersForS3Origin> => {
  const contents: InvalidHeadersForS3Origin = {
    name: "InvalidHeadersForS3Origin",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlInvalidIfMatchVersionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidIfMatchVersion> => {
  const contents: InvalidIfMatchVersion = {
    name: "InvalidIfMatchVersion",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlInvalidLambdaFunctionAssociationResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidLambdaFunctionAssociation> => {
  const contents: InvalidLambdaFunctionAssociation = {
    name: "InvalidLambdaFunctionAssociation",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlInvalidLocationCodeResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidLocationCode> => {
  const contents: InvalidLocationCode = {
    name: "InvalidLocationCode",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlInvalidMinimumProtocolVersionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidMinimumProtocolVersion> => {
  const contents: InvalidMinimumProtocolVersion = {
    name: "InvalidMinimumProtocolVersion",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlInvalidOriginResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidOrigin> => {
  const contents: InvalidOrigin = {
    name: "InvalidOrigin",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlInvalidOriginAccessIdentityResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidOriginAccessIdentity> => {
  const contents: InvalidOriginAccessIdentity = {
    name: "InvalidOriginAccessIdentity",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlInvalidOriginKeepaliveTimeoutResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidOriginKeepaliveTimeout> => {
  const contents: InvalidOriginKeepaliveTimeout = {
    name: "InvalidOriginKeepaliveTimeout",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlInvalidOriginReadTimeoutResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidOriginReadTimeout> => {
  const contents: InvalidOriginReadTimeout = {
    name: "InvalidOriginReadTimeout",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlInvalidProtocolSettingsResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidProtocolSettings> => {
  const contents: InvalidProtocolSettings = {
    name: "InvalidProtocolSettings",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlInvalidQueryStringParametersResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidQueryStringParameters> => {
  const contents: InvalidQueryStringParameters = {
    name: "InvalidQueryStringParameters",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlInvalidRelativePathResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidRelativePath> => {
  const contents: InvalidRelativePath = {
    name: "InvalidRelativePath",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlInvalidRequiredProtocolResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidRequiredProtocol> => {
  const contents: InvalidRequiredProtocol = {
    name: "InvalidRequiredProtocol",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlInvalidResponseCodeResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidResponseCode> => {
  const contents: InvalidResponseCode = {
    name: "InvalidResponseCode",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlInvalidTaggingResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidTagging> => {
  const contents: InvalidTagging = {
    name: "InvalidTagging",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlInvalidTTLOrderResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidTTLOrder> => {
  const contents: InvalidTTLOrder = {
    name: "InvalidTTLOrder",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlInvalidViewerCertificateResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidViewerCertificate> => {
  const contents: InvalidViewerCertificate = {
    name: "InvalidViewerCertificate",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlInvalidWebACLIdResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidWebACLId> => {
  const contents: InvalidWebACLId = {
    name: "InvalidWebACLId",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlMissingBodyResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<MissingBody> => {
  const contents: MissingBody = {
    name: "MissingBody",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlNoSuchCloudFrontOriginAccessIdentityResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<NoSuchCloudFrontOriginAccessIdentity> => {
  const contents: NoSuchCloudFrontOriginAccessIdentity = {
    name: "NoSuchCloudFrontOriginAccessIdentity",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlNoSuchDistributionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<NoSuchDistribution> => {
  const contents: NoSuchDistribution = {
    name: "NoSuchDistribution",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlNoSuchFieldLevelEncryptionConfigResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<NoSuchFieldLevelEncryptionConfig> => {
  const contents: NoSuchFieldLevelEncryptionConfig = {
    name: "NoSuchFieldLevelEncryptionConfig",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlNoSuchFieldLevelEncryptionProfileResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<NoSuchFieldLevelEncryptionProfile> => {
  const contents: NoSuchFieldLevelEncryptionProfile = {
    name: "NoSuchFieldLevelEncryptionProfile",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlNoSuchInvalidationResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<NoSuchInvalidation> => {
  const contents: NoSuchInvalidation = {
    name: "NoSuchInvalidation",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlNoSuchOriginResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<NoSuchOrigin> => {
  const contents: NoSuchOrigin = {
    name: "NoSuchOrigin",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlNoSuchPublicKeyResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<NoSuchPublicKey> => {
  const contents: NoSuchPublicKey = {
    name: "NoSuchPublicKey",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlNoSuchResourceResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<NoSuchResource> => {
  const contents: NoSuchResource = {
    name: "NoSuchResource",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlNoSuchStreamingDistributionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<NoSuchStreamingDistribution> => {
  const contents: NoSuchStreamingDistribution = {
    name: "NoSuchStreamingDistribution",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlPreconditionFailedResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<PreconditionFailed> => {
  const contents: PreconditionFailed = {
    name: "PreconditionFailed",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlPublicKeyAlreadyExistsResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<PublicKeyAlreadyExists> => {
  const contents: PublicKeyAlreadyExists = {
    name: "PublicKeyAlreadyExists",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlPublicKeyInUseResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<PublicKeyInUse> => {
  const contents: PublicKeyInUse = {
    name: "PublicKeyInUse",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlQueryArgProfileEmptyResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<QueryArgProfileEmpty> => {
  const contents: QueryArgProfileEmpty = {
    name: "QueryArgProfileEmpty",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlStreamingDistributionAlreadyExistsResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<StreamingDistributionAlreadyExists> => {
  const contents: StreamingDistributionAlreadyExists = {
    name: "StreamingDistributionAlreadyExists",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlStreamingDistributionNotDisabledResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<StreamingDistributionNotDisabled> => {
  const contents: StreamingDistributionNotDisabled = {
    name: "StreamingDistributionNotDisabled",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlTooManyCacheBehaviorsResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<TooManyCacheBehaviors> => {
  const contents: TooManyCacheBehaviors = {
    name: "TooManyCacheBehaviors",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlTooManyCertificatesResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<TooManyCertificates> => {
  const contents: TooManyCertificates = {
    name: "TooManyCertificates",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlTooManyCloudFrontOriginAccessIdentitiesResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<TooManyCloudFrontOriginAccessIdentities> => {
  const contents: TooManyCloudFrontOriginAccessIdentities = {
    name: "TooManyCloudFrontOriginAccessIdentities",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlTooManyCookieNamesInWhiteListResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<TooManyCookieNamesInWhiteList> => {
  const contents: TooManyCookieNamesInWhiteList = {
    name: "TooManyCookieNamesInWhiteList",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlTooManyDistributionCNAMEsResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<TooManyDistributionCNAMEs> => {
  const contents: TooManyDistributionCNAMEs = {
    name: "TooManyDistributionCNAMEs",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlTooManyDistributionsResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<TooManyDistributions> => {
  const contents: TooManyDistributions = {
    name: "TooManyDistributions",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlTooManyDistributionsAssociatedToFieldLevelEncryptionConfigResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<TooManyDistributionsAssociatedToFieldLevelEncryptionConfig> => {
  const contents: TooManyDistributionsAssociatedToFieldLevelEncryptionConfig = {
    name: "TooManyDistributionsAssociatedToFieldLevelEncryptionConfig",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlTooManyDistributionsWithLambdaAssociationsResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<TooManyDistributionsWithLambdaAssociations> => {
  const contents: TooManyDistributionsWithLambdaAssociations = {
    name: "TooManyDistributionsWithLambdaAssociations",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlTooManyFieldLevelEncryptionConfigsResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<TooManyFieldLevelEncryptionConfigs> => {
  const contents: TooManyFieldLevelEncryptionConfigs = {
    name: "TooManyFieldLevelEncryptionConfigs",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlTooManyFieldLevelEncryptionContentTypeProfilesResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<TooManyFieldLevelEncryptionContentTypeProfiles> => {
  const contents: TooManyFieldLevelEncryptionContentTypeProfiles = {
    name: "TooManyFieldLevelEncryptionContentTypeProfiles",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlTooManyFieldLevelEncryptionEncryptionEntitiesResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<TooManyFieldLevelEncryptionEncryptionEntities> => {
  const contents: TooManyFieldLevelEncryptionEncryptionEntities = {
    name: "TooManyFieldLevelEncryptionEncryptionEntities",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlTooManyFieldLevelEncryptionFieldPatternsResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<TooManyFieldLevelEncryptionFieldPatterns> => {
  const contents: TooManyFieldLevelEncryptionFieldPatterns = {
    name: "TooManyFieldLevelEncryptionFieldPatterns",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlTooManyFieldLevelEncryptionProfilesResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<TooManyFieldLevelEncryptionProfiles> => {
  const contents: TooManyFieldLevelEncryptionProfiles = {
    name: "TooManyFieldLevelEncryptionProfiles",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlTooManyFieldLevelEncryptionQueryArgProfilesResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<TooManyFieldLevelEncryptionQueryArgProfiles> => {
  const contents: TooManyFieldLevelEncryptionQueryArgProfiles = {
    name: "TooManyFieldLevelEncryptionQueryArgProfiles",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlTooManyHeadersInForwardedValuesResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<TooManyHeadersInForwardedValues> => {
  const contents: TooManyHeadersInForwardedValues = {
    name: "TooManyHeadersInForwardedValues",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlTooManyInvalidationsInProgressResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<TooManyInvalidationsInProgress> => {
  const contents: TooManyInvalidationsInProgress = {
    name: "TooManyInvalidationsInProgress",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlTooManyLambdaFunctionAssociationsResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<TooManyLambdaFunctionAssociations> => {
  const contents: TooManyLambdaFunctionAssociations = {
    name: "TooManyLambdaFunctionAssociations",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlTooManyOriginCustomHeadersResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<TooManyOriginCustomHeaders> => {
  const contents: TooManyOriginCustomHeaders = {
    name: "TooManyOriginCustomHeaders",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlTooManyOriginGroupsPerDistributionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<TooManyOriginGroupsPerDistribution> => {
  const contents: TooManyOriginGroupsPerDistribution = {
    name: "TooManyOriginGroupsPerDistribution",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlTooManyOriginsResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<TooManyOrigins> => {
  const contents: TooManyOrigins = {
    name: "TooManyOrigins",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlTooManyPublicKeysResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<TooManyPublicKeys> => {
  const contents: TooManyPublicKeys = {
    name: "TooManyPublicKeys",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlTooManyQueryStringParametersResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<TooManyQueryStringParameters> => {
  const contents: TooManyQueryStringParameters = {
    name: "TooManyQueryStringParameters",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlTooManyStreamingDistributionCNAMEsResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<TooManyStreamingDistributionCNAMEs> => {
  const contents: TooManyStreamingDistributionCNAMEs = {
    name: "TooManyStreamingDistributionCNAMEs",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlTooManyStreamingDistributionsResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<TooManyStreamingDistributions> => {
  const contents: TooManyStreamingDistributions = {
    name: "TooManyStreamingDistributions",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlTooManyTrustedSignersResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<TooManyTrustedSigners> => {
  const contents: TooManyTrustedSigners = {
    name: "TooManyTrustedSigners",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const deserializeAws_restXmlTrustedSignerDoesNotExistResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<TrustedSignerDoesNotExist> => {
  const contents: TrustedSignerDoesNotExist = {
    name: "TrustedSignerDoesNotExist",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["Message"] !== undefined) {
    contents.Message = data["Message"];
  }
  return contents;
};

const serializeAws_restXmlAliases = (
  input: Aliases,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("Aliases");
  if (input.Items !== undefined) {
    const nodes = serializeAws_restXmlAliasList(input.Items, context);
    const containerNode = new __XmlNode("Items");
    nodes.map((node: any) => {
      containerNode.addChildNode(node);
    });
    bodyNode.addChildNode(containerNode);
  }
  if (input.Quantity !== undefined) {
    const node = new __XmlNode("integer")
      .addChildNode(new __XmlText(String(input.Quantity)))
      .withName("Quantity");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlAliasList = (
  input: string[],
  context: __SerdeContext
): any => {
  return input.map(entry => {
    const node = new __XmlNode("string").addChildNode(new __XmlText(entry));
    return node.withName("CNAME");
  });
};

const serializeAws_restXmlAllowedMethods = (
  input: AllowedMethods,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("AllowedMethods");
  if (input.CachedMethods !== undefined) {
    const node = serializeAws_restXmlCachedMethods(
      input.CachedMethods,
      context
    ).withName("CachedMethods");
    bodyNode.addChildNode(node);
  }
  if (input.Items !== undefined) {
    const nodes = serializeAws_restXmlMethodsList(input.Items, context);
    const containerNode = new __XmlNode("Items");
    nodes.map((node: any) => {
      containerNode.addChildNode(node);
    });
    bodyNode.addChildNode(containerNode);
  }
  if (input.Quantity !== undefined) {
    const node = new __XmlNode("integer")
      .addChildNode(new __XmlText(String(input.Quantity)))
      .withName("Quantity");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlAwsAccountNumberList = (
  input: string[],
  context: __SerdeContext
): any => {
  return input.map(entry => {
    const node = new __XmlNode("string").addChildNode(new __XmlText(entry));
    return node.withName("AwsAccountNumber");
  });
};

const serializeAws_restXmlCacheBehavior = (
  input: CacheBehavior,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("CacheBehavior");
  if (input.AllowedMethods !== undefined) {
    const node = serializeAws_restXmlAllowedMethods(
      input.AllowedMethods,
      context
    ).withName("AllowedMethods");
    bodyNode.addChildNode(node);
  }
  if (input.Compress !== undefined) {
    const node = new __XmlNode("boolean")
      .addChildNode(new __XmlText(String(input.Compress)))
      .withName("Compress");
    bodyNode.addChildNode(node);
  }
  if (input.DefaultTTL !== undefined) {
    const node = new __XmlNode("long")
      .addChildNode(new __XmlText(String(input.DefaultTTL)))
      .withName("DefaultTTL");
    bodyNode.addChildNode(node);
  }
  if (input.FieldLevelEncryptionId !== undefined) {
    const node = new __XmlNode("string")
      .addChildNode(new __XmlText(input.FieldLevelEncryptionId))
      .withName("FieldLevelEncryptionId");
    bodyNode.addChildNode(node);
  }
  if (input.ForwardedValues !== undefined) {
    const node = serializeAws_restXmlForwardedValues(
      input.ForwardedValues,
      context
    ).withName("ForwardedValues");
    bodyNode.addChildNode(node);
  }
  if (input.LambdaFunctionAssociations !== undefined) {
    const node = serializeAws_restXmlLambdaFunctionAssociations(
      input.LambdaFunctionAssociations,
      context
    ).withName("LambdaFunctionAssociations");
    bodyNode.addChildNode(node);
  }
  if (input.MaxTTL !== undefined) {
    const node = new __XmlNode("long")
      .addChildNode(new __XmlText(String(input.MaxTTL)))
      .withName("MaxTTL");
    bodyNode.addChildNode(node);
  }
  if (input.MinTTL !== undefined) {
    const node = new __XmlNode("long")
      .addChildNode(new __XmlText(String(input.MinTTL)))
      .withName("MinTTL");
    bodyNode.addChildNode(node);
  }
  if (input.PathPattern !== undefined) {
    const node = new __XmlNode("string")
      .addChildNode(new __XmlText(input.PathPattern))
      .withName("PathPattern");
    bodyNode.addChildNode(node);
  }
  if (input.SmoothStreaming !== undefined) {
    const node = new __XmlNode("boolean")
      .addChildNode(new __XmlText(String(input.SmoothStreaming)))
      .withName("SmoothStreaming");
    bodyNode.addChildNode(node);
  }
  if (input.TargetOriginId !== undefined) {
    const node = new __XmlNode("string")
      .addChildNode(new __XmlText(input.TargetOriginId))
      .withName("TargetOriginId");
    bodyNode.addChildNode(node);
  }
  if (input.TrustedSigners !== undefined) {
    const node = serializeAws_restXmlTrustedSigners(
      input.TrustedSigners,
      context
    ).withName("TrustedSigners");
    bodyNode.addChildNode(node);
  }
  if (input.ViewerProtocolPolicy !== undefined) {
    const node = new __XmlNode("ViewerProtocolPolicy")
      .addChildNode(new __XmlText(input.ViewerProtocolPolicy))
      .withName("ViewerProtocolPolicy");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlCacheBehaviorList = (
  input: CacheBehavior[],
  context: __SerdeContext
): any => {
  return input.map(entry => {
    const node = serializeAws_restXmlCacheBehavior(entry, context);
    return node.withName("CacheBehavior");
  });
};

const serializeAws_restXmlCacheBehaviors = (
  input: CacheBehaviors,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("CacheBehaviors");
  if (input.Items !== undefined) {
    const nodes = serializeAws_restXmlCacheBehaviorList(input.Items, context);
    const containerNode = new __XmlNode("Items");
    nodes.map((node: any) => {
      containerNode.addChildNode(node);
    });
    bodyNode.addChildNode(containerNode);
  }
  if (input.Quantity !== undefined) {
    const node = new __XmlNode("integer")
      .addChildNode(new __XmlText(String(input.Quantity)))
      .withName("Quantity");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlCachedMethods = (
  input: CachedMethods,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("CachedMethods");
  if (input.Items !== undefined) {
    const nodes = serializeAws_restXmlMethodsList(input.Items, context);
    const containerNode = new __XmlNode("Items");
    nodes.map((node: any) => {
      containerNode.addChildNode(node);
    });
    bodyNode.addChildNode(containerNode);
  }
  if (input.Quantity !== undefined) {
    const node = new __XmlNode("integer")
      .addChildNode(new __XmlText(String(input.Quantity)))
      .withName("Quantity");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlCloudFrontOriginAccessIdentityConfig = (
  input: CloudFrontOriginAccessIdentityConfig,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("CloudFrontOriginAccessIdentityConfig");
  if (input.CallerReference !== undefined) {
    const node = new __XmlNode("string")
      .addChildNode(new __XmlText(input.CallerReference))
      .withName("CallerReference");
    bodyNode.addChildNode(node);
  }
  if (input.Comment !== undefined) {
    const node = new __XmlNode("string")
      .addChildNode(new __XmlText(input.Comment))
      .withName("Comment");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlContentTypeProfile = (
  input: ContentTypeProfile,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("ContentTypeProfile");
  if (input.ContentType !== undefined) {
    const node = new __XmlNode("string")
      .addChildNode(new __XmlText(input.ContentType))
      .withName("ContentType");
    bodyNode.addChildNode(node);
  }
  if (input.Format !== undefined) {
    const node = new __XmlNode("Format")
      .addChildNode(new __XmlText(input.Format))
      .withName("Format");
    bodyNode.addChildNode(node);
  }
  if (input.ProfileId !== undefined) {
    const node = new __XmlNode("string")
      .addChildNode(new __XmlText(input.ProfileId))
      .withName("ProfileId");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlContentTypeProfileConfig = (
  input: ContentTypeProfileConfig,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("ContentTypeProfileConfig");
  if (input.ContentTypeProfiles !== undefined) {
    const node = serializeAws_restXmlContentTypeProfiles(
      input.ContentTypeProfiles,
      context
    ).withName("ContentTypeProfiles");
    bodyNode.addChildNode(node);
  }
  if (input.ForwardWhenContentTypeIsUnknown !== undefined) {
    const node = new __XmlNode("boolean")
      .addChildNode(
        new __XmlText(String(input.ForwardWhenContentTypeIsUnknown))
      )
      .withName("ForwardWhenContentTypeIsUnknown");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlContentTypeProfileList = (
  input: ContentTypeProfile[],
  context: __SerdeContext
): any => {
  return input.map(entry => {
    const node = serializeAws_restXmlContentTypeProfile(entry, context);
    return node.withName("ContentTypeProfile");
  });
};

const serializeAws_restXmlContentTypeProfiles = (
  input: ContentTypeProfiles,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("ContentTypeProfiles");
  if (input.Items !== undefined) {
    const nodes = serializeAws_restXmlContentTypeProfileList(
      input.Items,
      context
    );
    const containerNode = new __XmlNode("Items");
    nodes.map((node: any) => {
      containerNode.addChildNode(node);
    });
    bodyNode.addChildNode(containerNode);
  }
  if (input.Quantity !== undefined) {
    const node = new __XmlNode("integer")
      .addChildNode(new __XmlText(String(input.Quantity)))
      .withName("Quantity");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlCookieNameList = (
  input: string[],
  context: __SerdeContext
): any => {
  return input.map(entry => {
    const node = new __XmlNode("string").addChildNode(new __XmlText(entry));
    return node.withName("Name");
  });
};

const serializeAws_restXmlCookieNames = (
  input: CookieNames,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("CookieNames");
  if (input.Items !== undefined) {
    const nodes = serializeAws_restXmlCookieNameList(input.Items, context);
    const containerNode = new __XmlNode("Items");
    nodes.map((node: any) => {
      containerNode.addChildNode(node);
    });
    bodyNode.addChildNode(containerNode);
  }
  if (input.Quantity !== undefined) {
    const node = new __XmlNode("integer")
      .addChildNode(new __XmlText(String(input.Quantity)))
      .withName("Quantity");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlCookiePreference = (
  input: CookiePreference,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("CookiePreference");
  if (input.Forward !== undefined) {
    const node = new __XmlNode("ItemSelection")
      .addChildNode(new __XmlText(input.Forward))
      .withName("Forward");
    bodyNode.addChildNode(node);
  }
  if (input.WhitelistedNames !== undefined) {
    const node = serializeAws_restXmlCookieNames(
      input.WhitelistedNames,
      context
    ).withName("WhitelistedNames");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlCustomErrorResponse = (
  input: CustomErrorResponse,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("CustomErrorResponse");
  if (input.ErrorCachingMinTTL !== undefined) {
    const node = new __XmlNode("long")
      .addChildNode(new __XmlText(String(input.ErrorCachingMinTTL)))
      .withName("ErrorCachingMinTTL");
    bodyNode.addChildNode(node);
  }
  if (input.ErrorCode !== undefined) {
    const node = new __XmlNode("integer")
      .addChildNode(new __XmlText(String(input.ErrorCode)))
      .withName("ErrorCode");
    bodyNode.addChildNode(node);
  }
  if (input.ResponseCode !== undefined) {
    const node = new __XmlNode("string")
      .addChildNode(new __XmlText(input.ResponseCode))
      .withName("ResponseCode");
    bodyNode.addChildNode(node);
  }
  if (input.ResponsePagePath !== undefined) {
    const node = new __XmlNode("string")
      .addChildNode(new __XmlText(input.ResponsePagePath))
      .withName("ResponsePagePath");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlCustomErrorResponseList = (
  input: CustomErrorResponse[],
  context: __SerdeContext
): any => {
  return input.map(entry => {
    const node = serializeAws_restXmlCustomErrorResponse(entry, context);
    return node.withName("CustomErrorResponse");
  });
};

const serializeAws_restXmlCustomErrorResponses = (
  input: CustomErrorResponses,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("CustomErrorResponses");
  if (input.Items !== undefined) {
    const nodes = serializeAws_restXmlCustomErrorResponseList(
      input.Items,
      context
    );
    const containerNode = new __XmlNode("Items");
    nodes.map((node: any) => {
      containerNode.addChildNode(node);
    });
    bodyNode.addChildNode(containerNode);
  }
  if (input.Quantity !== undefined) {
    const node = new __XmlNode("integer")
      .addChildNode(new __XmlText(String(input.Quantity)))
      .withName("Quantity");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlCustomHeaders = (
  input: CustomHeaders,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("CustomHeaders");
  if (input.Items !== undefined) {
    const nodes = serializeAws_restXmlOriginCustomHeadersList(
      input.Items,
      context
    );
    const containerNode = new __XmlNode("Items");
    nodes.map((node: any) => {
      containerNode.addChildNode(node);
    });
    bodyNode.addChildNode(containerNode);
  }
  if (input.Quantity !== undefined) {
    const node = new __XmlNode("integer")
      .addChildNode(new __XmlText(String(input.Quantity)))
      .withName("Quantity");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlCustomOriginConfig = (
  input: CustomOriginConfig,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("CustomOriginConfig");
  if (input.HTTPPort !== undefined) {
    const node = new __XmlNode("integer")
      .addChildNode(new __XmlText(String(input.HTTPPort)))
      .withName("HTTPPort");
    bodyNode.addChildNode(node);
  }
  if (input.HTTPSPort !== undefined) {
    const node = new __XmlNode("integer")
      .addChildNode(new __XmlText(String(input.HTTPSPort)))
      .withName("HTTPSPort");
    bodyNode.addChildNode(node);
  }
  if (input.OriginKeepaliveTimeout !== undefined) {
    const node = new __XmlNode("integer")
      .addChildNode(new __XmlText(String(input.OriginKeepaliveTimeout)))
      .withName("OriginKeepaliveTimeout");
    bodyNode.addChildNode(node);
  }
  if (input.OriginProtocolPolicy !== undefined) {
    const node = new __XmlNode("OriginProtocolPolicy")
      .addChildNode(new __XmlText(input.OriginProtocolPolicy))
      .withName("OriginProtocolPolicy");
    bodyNode.addChildNode(node);
  }
  if (input.OriginReadTimeout !== undefined) {
    const node = new __XmlNode("integer")
      .addChildNode(new __XmlText(String(input.OriginReadTimeout)))
      .withName("OriginReadTimeout");
    bodyNode.addChildNode(node);
  }
  if (input.OriginSslProtocols !== undefined) {
    const node = serializeAws_restXmlOriginSslProtocols(
      input.OriginSslProtocols,
      context
    ).withName("OriginSslProtocols");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlDefaultCacheBehavior = (
  input: DefaultCacheBehavior,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("DefaultCacheBehavior");
  if (input.AllowedMethods !== undefined) {
    const node = serializeAws_restXmlAllowedMethods(
      input.AllowedMethods,
      context
    ).withName("AllowedMethods");
    bodyNode.addChildNode(node);
  }
  if (input.Compress !== undefined) {
    const node = new __XmlNode("boolean")
      .addChildNode(new __XmlText(String(input.Compress)))
      .withName("Compress");
    bodyNode.addChildNode(node);
  }
  if (input.DefaultTTL !== undefined) {
    const node = new __XmlNode("long")
      .addChildNode(new __XmlText(String(input.DefaultTTL)))
      .withName("DefaultTTL");
    bodyNode.addChildNode(node);
  }
  if (input.FieldLevelEncryptionId !== undefined) {
    const node = new __XmlNode("string")
      .addChildNode(new __XmlText(input.FieldLevelEncryptionId))
      .withName("FieldLevelEncryptionId");
    bodyNode.addChildNode(node);
  }
  if (input.ForwardedValues !== undefined) {
    const node = serializeAws_restXmlForwardedValues(
      input.ForwardedValues,
      context
    ).withName("ForwardedValues");
    bodyNode.addChildNode(node);
  }
  if (input.LambdaFunctionAssociations !== undefined) {
    const node = serializeAws_restXmlLambdaFunctionAssociations(
      input.LambdaFunctionAssociations,
      context
    ).withName("LambdaFunctionAssociations");
    bodyNode.addChildNode(node);
  }
  if (input.MaxTTL !== undefined) {
    const node = new __XmlNode("long")
      .addChildNode(new __XmlText(String(input.MaxTTL)))
      .withName("MaxTTL");
    bodyNode.addChildNode(node);
  }
  if (input.MinTTL !== undefined) {
    const node = new __XmlNode("long")
      .addChildNode(new __XmlText(String(input.MinTTL)))
      .withName("MinTTL");
    bodyNode.addChildNode(node);
  }
  if (input.SmoothStreaming !== undefined) {
    const node = new __XmlNode("boolean")
      .addChildNode(new __XmlText(String(input.SmoothStreaming)))
      .withName("SmoothStreaming");
    bodyNode.addChildNode(node);
  }
  if (input.TargetOriginId !== undefined) {
    const node = new __XmlNode("string")
      .addChildNode(new __XmlText(input.TargetOriginId))
      .withName("TargetOriginId");
    bodyNode.addChildNode(node);
  }
  if (input.TrustedSigners !== undefined) {
    const node = serializeAws_restXmlTrustedSigners(
      input.TrustedSigners,
      context
    ).withName("TrustedSigners");
    bodyNode.addChildNode(node);
  }
  if (input.ViewerProtocolPolicy !== undefined) {
    const node = new __XmlNode("ViewerProtocolPolicy")
      .addChildNode(new __XmlText(input.ViewerProtocolPolicy))
      .withName("ViewerProtocolPolicy");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlDistributionConfig = (
  input: DistributionConfig,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("DistributionConfig");
  if (input.Aliases !== undefined) {
    const node = serializeAws_restXmlAliases(input.Aliases, context).withName(
      "Aliases"
    );
    bodyNode.addChildNode(node);
  }
  if (input.CacheBehaviors !== undefined) {
    const node = serializeAws_restXmlCacheBehaviors(
      input.CacheBehaviors,
      context
    ).withName("CacheBehaviors");
    bodyNode.addChildNode(node);
  }
  if (input.CallerReference !== undefined) {
    const node = new __XmlNode("string")
      .addChildNode(new __XmlText(input.CallerReference))
      .withName("CallerReference");
    bodyNode.addChildNode(node);
  }
  if (input.Comment !== undefined) {
    const node = new __XmlNode("CommentType")
      .addChildNode(new __XmlText(input.Comment))
      .withName("Comment");
    bodyNode.addChildNode(node);
  }
  if (input.CustomErrorResponses !== undefined) {
    const node = serializeAws_restXmlCustomErrorResponses(
      input.CustomErrorResponses,
      context
    ).withName("CustomErrorResponses");
    bodyNode.addChildNode(node);
  }
  if (input.DefaultCacheBehavior !== undefined) {
    const node = serializeAws_restXmlDefaultCacheBehavior(
      input.DefaultCacheBehavior,
      context
    ).withName("DefaultCacheBehavior");
    bodyNode.addChildNode(node);
  }
  if (input.DefaultRootObject !== undefined) {
    const node = new __XmlNode("string")
      .addChildNode(new __XmlText(input.DefaultRootObject))
      .withName("DefaultRootObject");
    bodyNode.addChildNode(node);
  }
  if (input.Enabled !== undefined) {
    const node = new __XmlNode("boolean")
      .addChildNode(new __XmlText(String(input.Enabled)))
      .withName("Enabled");
    bodyNode.addChildNode(node);
  }
  if (input.HttpVersion !== undefined) {
    const node = new __XmlNode("HttpVersion")
      .addChildNode(new __XmlText(input.HttpVersion))
      .withName("HttpVersion");
    bodyNode.addChildNode(node);
  }
  if (input.IsIPV6Enabled !== undefined) {
    const node = new __XmlNode("boolean")
      .addChildNode(new __XmlText(String(input.IsIPV6Enabled)))
      .withName("IsIPV6Enabled");
    bodyNode.addChildNode(node);
  }
  if (input.Logging !== undefined) {
    const node = serializeAws_restXmlLoggingConfig(
      input.Logging,
      context
    ).withName("Logging");
    bodyNode.addChildNode(node);
  }
  if (input.OriginGroups !== undefined) {
    const node = serializeAws_restXmlOriginGroups(
      input.OriginGroups,
      context
    ).withName("OriginGroups");
    bodyNode.addChildNode(node);
  }
  if (input.Origins !== undefined) {
    const node = serializeAws_restXmlOrigins(input.Origins, context).withName(
      "Origins"
    );
    bodyNode.addChildNode(node);
  }
  if (input.PriceClass !== undefined) {
    const node = new __XmlNode("PriceClass")
      .addChildNode(new __XmlText(input.PriceClass))
      .withName("PriceClass");
    bodyNode.addChildNode(node);
  }
  if (input.Restrictions !== undefined) {
    const node = serializeAws_restXmlRestrictions(
      input.Restrictions,
      context
    ).withName("Restrictions");
    bodyNode.addChildNode(node);
  }
  if (input.ViewerCertificate !== undefined) {
    const node = serializeAws_restXmlViewerCertificate(
      input.ViewerCertificate,
      context
    ).withName("ViewerCertificate");
    bodyNode.addChildNode(node);
  }
  if (input.WebACLId !== undefined) {
    const node = new __XmlNode("string")
      .addChildNode(new __XmlText(input.WebACLId))
      .withName("WebACLId");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlDistributionConfigWithTags = (
  input: DistributionConfigWithTags,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("DistributionConfigWithTags");
  if (input.DistributionConfig !== undefined) {
    const node = serializeAws_restXmlDistributionConfig(
      input.DistributionConfig,
      context
    ).withName("DistributionConfig");
    bodyNode.addChildNode(node);
  }
  if (input.Tags !== undefined) {
    const node = serializeAws_restXmlTags(input.Tags, context).withName("Tags");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlEncryptionEntities = (
  input: EncryptionEntities,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("EncryptionEntities");
  if (input.Items !== undefined) {
    const nodes = serializeAws_restXmlEncryptionEntityList(
      input.Items,
      context
    );
    const containerNode = new __XmlNode("Items");
    nodes.map((node: any) => {
      containerNode.addChildNode(node);
    });
    bodyNode.addChildNode(containerNode);
  }
  if (input.Quantity !== undefined) {
    const node = new __XmlNode("integer")
      .addChildNode(new __XmlText(String(input.Quantity)))
      .withName("Quantity");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlEncryptionEntity = (
  input: EncryptionEntity,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("EncryptionEntity");
  if (input.FieldPatterns !== undefined) {
    const node = serializeAws_restXmlFieldPatterns(
      input.FieldPatterns,
      context
    ).withName("FieldPatterns");
    bodyNode.addChildNode(node);
  }
  if (input.ProviderId !== undefined) {
    const node = new __XmlNode("string")
      .addChildNode(new __XmlText(input.ProviderId))
      .withName("ProviderId");
    bodyNode.addChildNode(node);
  }
  if (input.PublicKeyId !== undefined) {
    const node = new __XmlNode("string")
      .addChildNode(new __XmlText(input.PublicKeyId))
      .withName("PublicKeyId");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlEncryptionEntityList = (
  input: EncryptionEntity[],
  context: __SerdeContext
): any => {
  return input.map(entry => {
    const node = serializeAws_restXmlEncryptionEntity(entry, context);
    return node.withName("EncryptionEntity");
  });
};

const serializeAws_restXmlFieldLevelEncryptionConfig = (
  input: FieldLevelEncryptionConfig,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("FieldLevelEncryptionConfig");
  if (input.CallerReference !== undefined) {
    const node = new __XmlNode("string")
      .addChildNode(new __XmlText(input.CallerReference))
      .withName("CallerReference");
    bodyNode.addChildNode(node);
  }
  if (input.Comment !== undefined) {
    const node = new __XmlNode("string")
      .addChildNode(new __XmlText(input.Comment))
      .withName("Comment");
    bodyNode.addChildNode(node);
  }
  if (input.ContentTypeProfileConfig !== undefined) {
    const node = serializeAws_restXmlContentTypeProfileConfig(
      input.ContentTypeProfileConfig,
      context
    ).withName("ContentTypeProfileConfig");
    bodyNode.addChildNode(node);
  }
  if (input.QueryArgProfileConfig !== undefined) {
    const node = serializeAws_restXmlQueryArgProfileConfig(
      input.QueryArgProfileConfig,
      context
    ).withName("QueryArgProfileConfig");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlFieldLevelEncryptionProfileConfig = (
  input: FieldLevelEncryptionProfileConfig,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("FieldLevelEncryptionProfileConfig");
  if (input.CallerReference !== undefined) {
    const node = new __XmlNode("string")
      .addChildNode(new __XmlText(input.CallerReference))
      .withName("CallerReference");
    bodyNode.addChildNode(node);
  }
  if (input.Comment !== undefined) {
    const node = new __XmlNode("string")
      .addChildNode(new __XmlText(input.Comment))
      .withName("Comment");
    bodyNode.addChildNode(node);
  }
  if (input.EncryptionEntities !== undefined) {
    const node = serializeAws_restXmlEncryptionEntities(
      input.EncryptionEntities,
      context
    ).withName("EncryptionEntities");
    bodyNode.addChildNode(node);
  }
  if (input.Name !== undefined) {
    const node = new __XmlNode("string")
      .addChildNode(new __XmlText(input.Name))
      .withName("Name");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlFieldPatternList = (
  input: string[],
  context: __SerdeContext
): any => {
  return input.map(entry => {
    const node = new __XmlNode("string").addChildNode(new __XmlText(entry));
    return node.withName("FieldPattern");
  });
};

const serializeAws_restXmlFieldPatterns = (
  input: FieldPatterns,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("FieldPatterns");
  if (input.Items !== undefined) {
    const nodes = serializeAws_restXmlFieldPatternList(input.Items, context);
    const containerNode = new __XmlNode("Items");
    nodes.map((node: any) => {
      containerNode.addChildNode(node);
    });
    bodyNode.addChildNode(containerNode);
  }
  if (input.Quantity !== undefined) {
    const node = new __XmlNode("integer")
      .addChildNode(new __XmlText(String(input.Quantity)))
      .withName("Quantity");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlForwardedValues = (
  input: ForwardedValues,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("ForwardedValues");
  if (input.Cookies !== undefined) {
    const node = serializeAws_restXmlCookiePreference(
      input.Cookies,
      context
    ).withName("Cookies");
    bodyNode.addChildNode(node);
  }
  if (input.Headers !== undefined) {
    const node = serializeAws_restXmlHeaders(input.Headers, context).withName(
      "Headers"
    );
    bodyNode.addChildNode(node);
  }
  if (input.QueryString !== undefined) {
    const node = new __XmlNode("boolean")
      .addChildNode(new __XmlText(String(input.QueryString)))
      .withName("QueryString");
    bodyNode.addChildNode(node);
  }
  if (input.QueryStringCacheKeys !== undefined) {
    const node = serializeAws_restXmlQueryStringCacheKeys(
      input.QueryStringCacheKeys,
      context
    ).withName("QueryStringCacheKeys");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlGeoRestriction = (
  input: GeoRestriction,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("GeoRestriction");
  if (input.Items !== undefined) {
    const nodes = serializeAws_restXmlLocationList(input.Items, context);
    const containerNode = new __XmlNode("Items");
    nodes.map((node: any) => {
      containerNode.addChildNode(node);
    });
    bodyNode.addChildNode(containerNode);
  }
  if (input.Quantity !== undefined) {
    const node = new __XmlNode("integer")
      .addChildNode(new __XmlText(String(input.Quantity)))
      .withName("Quantity");
    bodyNode.addChildNode(node);
  }
  if (input.RestrictionType !== undefined) {
    const node = new __XmlNode("GeoRestrictionType")
      .addChildNode(new __XmlText(input.RestrictionType))
      .withName("RestrictionType");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlHeaderList = (
  input: string[],
  context: __SerdeContext
): any => {
  return input.map(entry => {
    const node = new __XmlNode("string").addChildNode(new __XmlText(entry));
    return node.withName("Name");
  });
};

const serializeAws_restXmlHeaders = (
  input: Headers,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("Headers");
  if (input.Items !== undefined) {
    const nodes = serializeAws_restXmlHeaderList(input.Items, context);
    const containerNode = new __XmlNode("Items");
    nodes.map((node: any) => {
      containerNode.addChildNode(node);
    });
    bodyNode.addChildNode(containerNode);
  }
  if (input.Quantity !== undefined) {
    const node = new __XmlNode("integer")
      .addChildNode(new __XmlText(String(input.Quantity)))
      .withName("Quantity");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlInvalidationBatch = (
  input: InvalidationBatch,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("InvalidationBatch");
  if (input.CallerReference !== undefined) {
    const node = new __XmlNode("string")
      .addChildNode(new __XmlText(input.CallerReference))
      .withName("CallerReference");
    bodyNode.addChildNode(node);
  }
  if (input.Paths !== undefined) {
    const node = serializeAws_restXmlPaths(input.Paths, context).withName(
      "Paths"
    );
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlLambdaFunctionAssociation = (
  input: LambdaFunctionAssociation,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("LambdaFunctionAssociation");
  if (input.EventType !== undefined) {
    const node = new __XmlNode("EventType")
      .addChildNode(new __XmlText(input.EventType))
      .withName("EventType");
    bodyNode.addChildNode(node);
  }
  if (input.IncludeBody !== undefined) {
    const node = new __XmlNode("boolean")
      .addChildNode(new __XmlText(String(input.IncludeBody)))
      .withName("IncludeBody");
    bodyNode.addChildNode(node);
  }
  if (input.LambdaFunctionARN !== undefined) {
    const node = new __XmlNode("LambdaFunctionARN")
      .addChildNode(new __XmlText(input.LambdaFunctionARN))
      .withName("LambdaFunctionARN");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlLambdaFunctionAssociationList = (
  input: LambdaFunctionAssociation[],
  context: __SerdeContext
): any => {
  return input.map(entry => {
    const node = serializeAws_restXmlLambdaFunctionAssociation(entry, context);
    return node.withName("LambdaFunctionAssociation");
  });
};

const serializeAws_restXmlLambdaFunctionAssociations = (
  input: LambdaFunctionAssociations,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("LambdaFunctionAssociations");
  if (input.Items !== undefined) {
    const nodes = serializeAws_restXmlLambdaFunctionAssociationList(
      input.Items,
      context
    );
    const containerNode = new __XmlNode("Items");
    nodes.map((node: any) => {
      containerNode.addChildNode(node);
    });
    bodyNode.addChildNode(containerNode);
  }
  if (input.Quantity !== undefined) {
    const node = new __XmlNode("integer")
      .addChildNode(new __XmlText(String(input.Quantity)))
      .withName("Quantity");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlLocationList = (
  input: string[],
  context: __SerdeContext
): any => {
  return input.map(entry => {
    const node = new __XmlNode("string").addChildNode(new __XmlText(entry));
    return node.withName("Location");
  });
};

const serializeAws_restXmlLoggingConfig = (
  input: LoggingConfig,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("LoggingConfig");
  if (input.Bucket !== undefined) {
    const node = new __XmlNode("string")
      .addChildNode(new __XmlText(input.Bucket))
      .withName("Bucket");
    bodyNode.addChildNode(node);
  }
  if (input.Enabled !== undefined) {
    const node = new __XmlNode("boolean")
      .addChildNode(new __XmlText(String(input.Enabled)))
      .withName("Enabled");
    bodyNode.addChildNode(node);
  }
  if (input.IncludeCookies !== undefined) {
    const node = new __XmlNode("boolean")
      .addChildNode(new __XmlText(String(input.IncludeCookies)))
      .withName("IncludeCookies");
    bodyNode.addChildNode(node);
  }
  if (input.Prefix !== undefined) {
    const node = new __XmlNode("string")
      .addChildNode(new __XmlText(input.Prefix))
      .withName("Prefix");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlMethodsList = (
  input: (Method | string)[],
  context: __SerdeContext
): any => {
  return input.map(entry => {
    const node = new __XmlNode("Method").addChildNode(new __XmlText(entry));
    return node.withName("Method");
  });
};

const serializeAws_restXmlOrigin = (
  input: Origin,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("Origin");
  if (input.CustomHeaders !== undefined) {
    const node = serializeAws_restXmlCustomHeaders(
      input.CustomHeaders,
      context
    ).withName("CustomHeaders");
    bodyNode.addChildNode(node);
  }
  if (input.CustomOriginConfig !== undefined) {
    const node = serializeAws_restXmlCustomOriginConfig(
      input.CustomOriginConfig,
      context
    ).withName("CustomOriginConfig");
    bodyNode.addChildNode(node);
  }
  if (input.DomainName !== undefined) {
    const node = new __XmlNode("string")
      .addChildNode(new __XmlText(input.DomainName))
      .withName("DomainName");
    bodyNode.addChildNode(node);
  }
  if (input.Id !== undefined) {
    const node = new __XmlNode("string")
      .addChildNode(new __XmlText(input.Id))
      .withName("Id");
    bodyNode.addChildNode(node);
  }
  if (input.OriginPath !== undefined) {
    const node = new __XmlNode("string")
      .addChildNode(new __XmlText(input.OriginPath))
      .withName("OriginPath");
    bodyNode.addChildNode(node);
  }
  if (input.S3OriginConfig !== undefined) {
    const node = serializeAws_restXmlS3OriginConfig(
      input.S3OriginConfig,
      context
    ).withName("S3OriginConfig");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlOriginCustomHeader = (
  input: OriginCustomHeader,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("OriginCustomHeader");
  if (input.HeaderName !== undefined) {
    const node = new __XmlNode("string")
      .addChildNode(new __XmlText(input.HeaderName))
      .withName("HeaderName");
    bodyNode.addChildNode(node);
  }
  if (input.HeaderValue !== undefined) {
    const node = new __XmlNode("string")
      .addChildNode(new __XmlText(input.HeaderValue))
      .withName("HeaderValue");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlOriginCustomHeadersList = (
  input: OriginCustomHeader[],
  context: __SerdeContext
): any => {
  return input.map(entry => {
    const node = serializeAws_restXmlOriginCustomHeader(entry, context);
    return node.withName("OriginCustomHeader");
  });
};

const serializeAws_restXmlOriginGroup = (
  input: OriginGroup,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("OriginGroup");
  if (input.FailoverCriteria !== undefined) {
    const node = serializeAws_restXmlOriginGroupFailoverCriteria(
      input.FailoverCriteria,
      context
    ).withName("FailoverCriteria");
    bodyNode.addChildNode(node);
  }
  if (input.Id !== undefined) {
    const node = new __XmlNode("string")
      .addChildNode(new __XmlText(input.Id))
      .withName("Id");
    bodyNode.addChildNode(node);
  }
  if (input.Members !== undefined) {
    const node = serializeAws_restXmlOriginGroupMembers(
      input.Members,
      context
    ).withName("Members");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlOriginGroupFailoverCriteria = (
  input: OriginGroupFailoverCriteria,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("OriginGroupFailoverCriteria");
  if (input.StatusCodes !== undefined) {
    const node = serializeAws_restXmlStatusCodes(
      input.StatusCodes,
      context
    ).withName("StatusCodes");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlOriginGroupList = (
  input: OriginGroup[],
  context: __SerdeContext
): any => {
  return input.map(entry => {
    const node = serializeAws_restXmlOriginGroup(entry, context);
    return node.withName("OriginGroup");
  });
};

const serializeAws_restXmlOriginGroupMember = (
  input: OriginGroupMember,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("OriginGroupMember");
  if (input.OriginId !== undefined) {
    const node = new __XmlNode("string")
      .addChildNode(new __XmlText(input.OriginId))
      .withName("OriginId");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlOriginGroupMemberList = (
  input: OriginGroupMember[],
  context: __SerdeContext
): any => {
  return input.map(entry => {
    const node = serializeAws_restXmlOriginGroupMember(entry, context);
    return node.withName("OriginGroupMember");
  });
};

const serializeAws_restXmlOriginGroupMembers = (
  input: OriginGroupMembers,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("OriginGroupMembers");
  if (input.Items !== undefined) {
    const nodes = serializeAws_restXmlOriginGroupMemberList(
      input.Items,
      context
    );
    const containerNode = new __XmlNode("Items");
    nodes.map((node: any) => {
      containerNode.addChildNode(node);
    });
    bodyNode.addChildNode(containerNode);
  }
  if (input.Quantity !== undefined) {
    const node = new __XmlNode("integer")
      .addChildNode(new __XmlText(String(input.Quantity)))
      .withName("Quantity");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlOriginGroups = (
  input: OriginGroups,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("OriginGroups");
  if (input.Items !== undefined) {
    const nodes = serializeAws_restXmlOriginGroupList(input.Items, context);
    const containerNode = new __XmlNode("Items");
    nodes.map((node: any) => {
      containerNode.addChildNode(node);
    });
    bodyNode.addChildNode(containerNode);
  }
  if (input.Quantity !== undefined) {
    const node = new __XmlNode("integer")
      .addChildNode(new __XmlText(String(input.Quantity)))
      .withName("Quantity");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlOriginList = (
  input: Origin[],
  context: __SerdeContext
): any => {
  return input.map(entry => {
    const node = serializeAws_restXmlOrigin(entry, context);
    return node.withName("Origin");
  });
};

const serializeAws_restXmlOrigins = (
  input: Origins,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("Origins");
  if (input.Items !== undefined) {
    const nodes = serializeAws_restXmlOriginList(input.Items, context);
    const containerNode = new __XmlNode("Items");
    nodes.map((node: any) => {
      containerNode.addChildNode(node);
    });
    bodyNode.addChildNode(containerNode);
  }
  if (input.Quantity !== undefined) {
    const node = new __XmlNode("integer")
      .addChildNode(new __XmlText(String(input.Quantity)))
      .withName("Quantity");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlOriginSslProtocols = (
  input: OriginSslProtocols,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("OriginSslProtocols");
  if (input.Items !== undefined) {
    const nodes = serializeAws_restXmlSslProtocolsList(input.Items, context);
    const containerNode = new __XmlNode("Items");
    nodes.map((node: any) => {
      containerNode.addChildNode(node);
    });
    bodyNode.addChildNode(containerNode);
  }
  if (input.Quantity !== undefined) {
    const node = new __XmlNode("integer")
      .addChildNode(new __XmlText(String(input.Quantity)))
      .withName("Quantity");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlPathList = (
  input: string[],
  context: __SerdeContext
): any => {
  return input.map(entry => {
    const node = new __XmlNode("string").addChildNode(new __XmlText(entry));
    return node.withName("Path");
  });
};

const serializeAws_restXmlPaths = (
  input: Paths,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("Paths");
  if (input.Items !== undefined) {
    const nodes = serializeAws_restXmlPathList(input.Items, context);
    const containerNode = new __XmlNode("Items");
    nodes.map((node: any) => {
      containerNode.addChildNode(node);
    });
    bodyNode.addChildNode(containerNode);
  }
  if (input.Quantity !== undefined) {
    const node = new __XmlNode("integer")
      .addChildNode(new __XmlText(String(input.Quantity)))
      .withName("Quantity");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlPublicKeyConfig = (
  input: PublicKeyConfig,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("PublicKeyConfig");
  if (input.CallerReference !== undefined) {
    const node = new __XmlNode("string")
      .addChildNode(new __XmlText(input.CallerReference))
      .withName("CallerReference");
    bodyNode.addChildNode(node);
  }
  if (input.Comment !== undefined) {
    const node = new __XmlNode("string")
      .addChildNode(new __XmlText(input.Comment))
      .withName("Comment");
    bodyNode.addChildNode(node);
  }
  if (input.EncodedKey !== undefined) {
    const node = new __XmlNode("string")
      .addChildNode(new __XmlText(input.EncodedKey))
      .withName("EncodedKey");
    bodyNode.addChildNode(node);
  }
  if (input.Name !== undefined) {
    const node = new __XmlNode("string")
      .addChildNode(new __XmlText(input.Name))
      .withName("Name");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlQueryArgProfile = (
  input: QueryArgProfile,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("QueryArgProfile");
  if (input.ProfileId !== undefined) {
    const node = new __XmlNode("string")
      .addChildNode(new __XmlText(input.ProfileId))
      .withName("ProfileId");
    bodyNode.addChildNode(node);
  }
  if (input.QueryArg !== undefined) {
    const node = new __XmlNode("string")
      .addChildNode(new __XmlText(input.QueryArg))
      .withName("QueryArg");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlQueryArgProfileConfig = (
  input: QueryArgProfileConfig,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("QueryArgProfileConfig");
  if (input.ForwardWhenQueryArgProfileIsUnknown !== undefined) {
    const node = new __XmlNode("boolean")
      .addChildNode(
        new __XmlText(String(input.ForwardWhenQueryArgProfileIsUnknown))
      )
      .withName("ForwardWhenQueryArgProfileIsUnknown");
    bodyNode.addChildNode(node);
  }
  if (input.QueryArgProfiles !== undefined) {
    const node = serializeAws_restXmlQueryArgProfiles(
      input.QueryArgProfiles,
      context
    ).withName("QueryArgProfiles");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlQueryArgProfileList = (
  input: QueryArgProfile[],
  context: __SerdeContext
): any => {
  return input.map(entry => {
    const node = serializeAws_restXmlQueryArgProfile(entry, context);
    return node.withName("QueryArgProfile");
  });
};

const serializeAws_restXmlQueryArgProfiles = (
  input: QueryArgProfiles,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("QueryArgProfiles");
  if (input.Items !== undefined) {
    const nodes = serializeAws_restXmlQueryArgProfileList(input.Items, context);
    const containerNode = new __XmlNode("Items");
    nodes.map((node: any) => {
      containerNode.addChildNode(node);
    });
    bodyNode.addChildNode(containerNode);
  }
  if (input.Quantity !== undefined) {
    const node = new __XmlNode("integer")
      .addChildNode(new __XmlText(String(input.Quantity)))
      .withName("Quantity");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlQueryStringCacheKeys = (
  input: QueryStringCacheKeys,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("QueryStringCacheKeys");
  if (input.Items !== undefined) {
    const nodes = serializeAws_restXmlQueryStringCacheKeysList(
      input.Items,
      context
    );
    const containerNode = new __XmlNode("Items");
    nodes.map((node: any) => {
      containerNode.addChildNode(node);
    });
    bodyNode.addChildNode(containerNode);
  }
  if (input.Quantity !== undefined) {
    const node = new __XmlNode("integer")
      .addChildNode(new __XmlText(String(input.Quantity)))
      .withName("Quantity");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlQueryStringCacheKeysList = (
  input: string[],
  context: __SerdeContext
): any => {
  return input.map(entry => {
    const node = new __XmlNode("string").addChildNode(new __XmlText(entry));
    return node.withName("Name");
  });
};

const serializeAws_restXmlRestrictions = (
  input: Restrictions,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("Restrictions");
  if (input.GeoRestriction !== undefined) {
    const node = serializeAws_restXmlGeoRestriction(
      input.GeoRestriction,
      context
    ).withName("GeoRestriction");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlS3Origin = (
  input: S3Origin,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("S3Origin");
  if (input.DomainName !== undefined) {
    const node = new __XmlNode("string")
      .addChildNode(new __XmlText(input.DomainName))
      .withName("DomainName");
    bodyNode.addChildNode(node);
  }
  if (input.OriginAccessIdentity !== undefined) {
    const node = new __XmlNode("string")
      .addChildNode(new __XmlText(input.OriginAccessIdentity))
      .withName("OriginAccessIdentity");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlS3OriginConfig = (
  input: S3OriginConfig,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("S3OriginConfig");
  if (input.OriginAccessIdentity !== undefined) {
    const node = new __XmlNode("string")
      .addChildNode(new __XmlText(input.OriginAccessIdentity))
      .withName("OriginAccessIdentity");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlSslProtocolsList = (
  input: (SslProtocol | string)[],
  context: __SerdeContext
): any => {
  return input.map(entry => {
    const node = new __XmlNode("SslProtocol").addChildNode(
      new __XmlText(entry)
    );
    return node.withName("SslProtocol");
  });
};

const serializeAws_restXmlStatusCodeList = (
  input: number[],
  context: __SerdeContext
): any => {
  return input.map(entry => {
    const node = new __XmlNode("integer").addChildNode(
      new __XmlText(String(entry))
    );
    return node.withName("StatusCode");
  });
};

const serializeAws_restXmlStatusCodes = (
  input: StatusCodes,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("StatusCodes");
  if (input.Items !== undefined) {
    const nodes = serializeAws_restXmlStatusCodeList(input.Items, context);
    const containerNode = new __XmlNode("Items");
    nodes.map((node: any) => {
      containerNode.addChildNode(node);
    });
    bodyNode.addChildNode(containerNode);
  }
  if (input.Quantity !== undefined) {
    const node = new __XmlNode("integer")
      .addChildNode(new __XmlText(String(input.Quantity)))
      .withName("Quantity");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlStreamingDistributionConfig = (
  input: StreamingDistributionConfig,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("StreamingDistributionConfig");
  if (input.Aliases !== undefined) {
    const node = serializeAws_restXmlAliases(input.Aliases, context).withName(
      "Aliases"
    );
    bodyNode.addChildNode(node);
  }
  if (input.CallerReference !== undefined) {
    const node = new __XmlNode("string")
      .addChildNode(new __XmlText(input.CallerReference))
      .withName("CallerReference");
    bodyNode.addChildNode(node);
  }
  if (input.Comment !== undefined) {
    const node = new __XmlNode("string")
      .addChildNode(new __XmlText(input.Comment))
      .withName("Comment");
    bodyNode.addChildNode(node);
  }
  if (input.Enabled !== undefined) {
    const node = new __XmlNode("boolean")
      .addChildNode(new __XmlText(String(input.Enabled)))
      .withName("Enabled");
    bodyNode.addChildNode(node);
  }
  if (input.Logging !== undefined) {
    const node = serializeAws_restXmlStreamingLoggingConfig(
      input.Logging,
      context
    ).withName("Logging");
    bodyNode.addChildNode(node);
  }
  if (input.PriceClass !== undefined) {
    const node = new __XmlNode("PriceClass")
      .addChildNode(new __XmlText(input.PriceClass))
      .withName("PriceClass");
    bodyNode.addChildNode(node);
  }
  if (input.S3Origin !== undefined) {
    const node = serializeAws_restXmlS3Origin(input.S3Origin, context).withName(
      "S3Origin"
    );
    bodyNode.addChildNode(node);
  }
  if (input.TrustedSigners !== undefined) {
    const node = serializeAws_restXmlTrustedSigners(
      input.TrustedSigners,
      context
    ).withName("TrustedSigners");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlStreamingDistributionConfigWithTags = (
  input: StreamingDistributionConfigWithTags,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("StreamingDistributionConfigWithTags");
  if (input.StreamingDistributionConfig !== undefined) {
    const node = serializeAws_restXmlStreamingDistributionConfig(
      input.StreamingDistributionConfig,
      context
    ).withName("StreamingDistributionConfig");
    bodyNode.addChildNode(node);
  }
  if (input.Tags !== undefined) {
    const node = serializeAws_restXmlTags(input.Tags, context).withName("Tags");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlStreamingLoggingConfig = (
  input: StreamingLoggingConfig,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("StreamingLoggingConfig");
  if (input.Bucket !== undefined) {
    const node = new __XmlNode("string")
      .addChildNode(new __XmlText(input.Bucket))
      .withName("Bucket");
    bodyNode.addChildNode(node);
  }
  if (input.Enabled !== undefined) {
    const node = new __XmlNode("boolean")
      .addChildNode(new __XmlText(String(input.Enabled)))
      .withName("Enabled");
    bodyNode.addChildNode(node);
  }
  if (input.Prefix !== undefined) {
    const node = new __XmlNode("string")
      .addChildNode(new __XmlText(input.Prefix))
      .withName("Prefix");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlTag = (input: Tag, context: __SerdeContext): any => {
  const bodyNode = new __XmlNode("Tag");
  if (input.Key !== undefined) {
    const node = new __XmlNode("TagKey")
      .addChildNode(new __XmlText(input.Key))
      .withName("Key");
    bodyNode.addChildNode(node);
  }
  if (input.Value !== undefined) {
    const node = new __XmlNode("TagValue")
      .addChildNode(new __XmlText(input.Value))
      .withName("Value");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlTagKeyList = (
  input: string[],
  context: __SerdeContext
): any => {
  return input.map(entry => {
    const node = new __XmlNode("TagKey").addChildNode(new __XmlText(entry));
    return node.withName("Key");
  });
};

const serializeAws_restXmlTagKeys = (
  input: TagKeys,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("TagKeys");
  if (input.Items !== undefined) {
    const nodes = serializeAws_restXmlTagKeyList(input.Items, context);
    const containerNode = new __XmlNode("Items");
    nodes.map((node: any) => {
      containerNode.addChildNode(node);
    });
    bodyNode.addChildNode(containerNode);
  }
  return bodyNode;
};

const serializeAws_restXmlTagList = (
  input: Tag[],
  context: __SerdeContext
): any => {
  return input.map(entry => {
    const node = serializeAws_restXmlTag(entry, context);
    return node.withName("Tag");
  });
};

const serializeAws_restXmlTags = (
  input: Tags,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("Tags");
  if (input.Items !== undefined) {
    const nodes = serializeAws_restXmlTagList(input.Items, context);
    const containerNode = new __XmlNode("Items");
    nodes.map((node: any) => {
      containerNode.addChildNode(node);
    });
    bodyNode.addChildNode(containerNode);
  }
  return bodyNode;
};

const serializeAws_restXmlTrustedSigners = (
  input: TrustedSigners,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("TrustedSigners");
  if (input.Enabled !== undefined) {
    const node = new __XmlNode("boolean")
      .addChildNode(new __XmlText(String(input.Enabled)))
      .withName("Enabled");
    bodyNode.addChildNode(node);
  }
  if (input.Items !== undefined) {
    const nodes = serializeAws_restXmlAwsAccountNumberList(
      input.Items,
      context
    );
    const containerNode = new __XmlNode("Items");
    nodes.map((node: any) => {
      containerNode.addChildNode(node);
    });
    bodyNode.addChildNode(containerNode);
  }
  if (input.Quantity !== undefined) {
    const node = new __XmlNode("integer")
      .addChildNode(new __XmlText(String(input.Quantity)))
      .withName("Quantity");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlViewerCertificate = (
  input: ViewerCertificate,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("ViewerCertificate");
  if (input.ACMCertificateArn !== undefined) {
    const node = new __XmlNode("string")
      .addChildNode(new __XmlText(input.ACMCertificateArn))
      .withName("ACMCertificateArn");
    bodyNode.addChildNode(node);
  }
  if (input.Certificate !== undefined) {
    const node = new __XmlNode("string")
      .addChildNode(new __XmlText(input.Certificate))
      .withName("Certificate");
    bodyNode.addChildNode(node);
  }
  if (input.CertificateSource !== undefined) {
    const node = new __XmlNode("CertificateSource")
      .addChildNode(new __XmlText(input.CertificateSource))
      .withName("CertificateSource");
    bodyNode.addChildNode(node);
  }
  if (input.CloudFrontDefaultCertificate !== undefined) {
    const node = new __XmlNode("boolean")
      .addChildNode(new __XmlText(String(input.CloudFrontDefaultCertificate)))
      .withName("CloudFrontDefaultCertificate");
    bodyNode.addChildNode(node);
  }
  if (input.IAMCertificateId !== undefined) {
    const node = new __XmlNode("string")
      .addChildNode(new __XmlText(input.IAMCertificateId))
      .withName("IAMCertificateId");
    bodyNode.addChildNode(node);
  }
  if (input.MinimumProtocolVersion !== undefined) {
    const node = new __XmlNode("MinimumProtocolVersion")
      .addChildNode(new __XmlText(input.MinimumProtocolVersion))
      .withName("MinimumProtocolVersion");
    bodyNode.addChildNode(node);
  }
  if (input.SSLSupportMethod !== undefined) {
    const node = new __XmlNode("SSLSupportMethod")
      .addChildNode(new __XmlText(input.SSLSupportMethod))
      .withName("SSLSupportMethod");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const deserializeAws_restXmlActiveTrustedSigners = (
  output: any,
  context: __SerdeContext
): ActiveTrustedSigners => {
  let contents: any = {
    __type: "ActiveTrustedSigners",
    Enabled: undefined,
    Items: undefined,
    Quantity: undefined
  };
  if (output["Enabled"] !== undefined) {
    contents.Enabled = output["Enabled"] == "true";
  }
  if (output.Items === "") {
    contents.Items = [];
  }
  if (
    output["Items"] !== undefined &&
    output["Items"]["Signer"] !== undefined
  ) {
    contents.Items = deserializeAws_restXmlSignerList(
      __getArrayIfSingleItem(output["Items"]["Signer"]),
      context
    );
  }
  if (output["Quantity"] !== undefined) {
    contents.Quantity = parseInt(output["Quantity"]);
  }
  return contents;
};

const deserializeAws_restXmlAliases = (
  output: any,
  context: __SerdeContext
): Aliases => {
  let contents: any = {
    __type: "Aliases",
    Items: undefined,
    Quantity: undefined
  };
  if (output.Items === "") {
    contents.Items = [];
  }
  if (output["Items"] !== undefined && output["Items"]["CNAME"] !== undefined) {
    contents.Items = deserializeAws_restXmlAliasList(
      __getArrayIfSingleItem(output["Items"]["CNAME"]),
      context
    );
  }
  if (output["Quantity"] !== undefined) {
    contents.Quantity = parseInt(output["Quantity"]);
  }
  return contents;
};

const deserializeAws_restXmlAliasICPRecordal = (
  output: any,
  context: __SerdeContext
): AliasICPRecordal => {
  let contents: any = {
    __type: "AliasICPRecordal",
    CNAME: undefined,
    ICPRecordalStatus: undefined
  };
  if (output["CNAME"] !== undefined) {
    contents.CNAME = output["CNAME"];
  }
  if (output["ICPRecordalStatus"] !== undefined) {
    contents.ICPRecordalStatus = output["ICPRecordalStatus"];
  }
  return contents;
};

const deserializeAws_restXmlAliasICPRecordals = (
  output: any,
  context: __SerdeContext
): AliasICPRecordal[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_restXmlAliasICPRecordal(entry, context)
  );
};

const deserializeAws_restXmlAliasList = (
  output: any,
  context: __SerdeContext
): string[] => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_restXmlAllowedMethods = (
  output: any,
  context: __SerdeContext
): AllowedMethods => {
  let contents: any = {
    __type: "AllowedMethods",
    CachedMethods: undefined,
    Items: undefined,
    Quantity: undefined
  };
  if (output["CachedMethods"] !== undefined) {
    contents.CachedMethods = deserializeAws_restXmlCachedMethods(
      output["CachedMethods"],
      context
    );
  }
  if (output.Items === "") {
    contents.Items = [];
  }
  if (
    output["Items"] !== undefined &&
    output["Items"]["Method"] !== undefined
  ) {
    contents.Items = deserializeAws_restXmlMethodsList(
      __getArrayIfSingleItem(output["Items"]["Method"]),
      context
    );
  }
  if (output["Quantity"] !== undefined) {
    contents.Quantity = parseInt(output["Quantity"]);
  }
  return contents;
};

const deserializeAws_restXmlAwsAccountNumberList = (
  output: any,
  context: __SerdeContext
): string[] => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_restXmlCacheBehavior = (
  output: any,
  context: __SerdeContext
): CacheBehavior => {
  let contents: any = {
    __type: "CacheBehavior",
    AllowedMethods: undefined,
    Compress: undefined,
    DefaultTTL: undefined,
    FieldLevelEncryptionId: undefined,
    ForwardedValues: undefined,
    LambdaFunctionAssociations: undefined,
    MaxTTL: undefined,
    MinTTL: undefined,
    PathPattern: undefined,
    SmoothStreaming: undefined,
    TargetOriginId: undefined,
    TrustedSigners: undefined,
    ViewerProtocolPolicy: undefined
  };
  if (output["AllowedMethods"] !== undefined) {
    contents.AllowedMethods = deserializeAws_restXmlAllowedMethods(
      output["AllowedMethods"],
      context
    );
  }
  if (output["Compress"] !== undefined) {
    contents.Compress = output["Compress"] == "true";
  }
  if (output["DefaultTTL"] !== undefined) {
    contents.DefaultTTL = parseInt(output["DefaultTTL"]);
  }
  if (output["FieldLevelEncryptionId"] !== undefined) {
    contents.FieldLevelEncryptionId = output["FieldLevelEncryptionId"];
  }
  if (output["ForwardedValues"] !== undefined) {
    contents.ForwardedValues = deserializeAws_restXmlForwardedValues(
      output["ForwardedValues"],
      context
    );
  }
  if (output["LambdaFunctionAssociations"] !== undefined) {
    contents.LambdaFunctionAssociations = deserializeAws_restXmlLambdaFunctionAssociations(
      output["LambdaFunctionAssociations"],
      context
    );
  }
  if (output["MaxTTL"] !== undefined) {
    contents.MaxTTL = parseInt(output["MaxTTL"]);
  }
  if (output["MinTTL"] !== undefined) {
    contents.MinTTL = parseInt(output["MinTTL"]);
  }
  if (output["PathPattern"] !== undefined) {
    contents.PathPattern = output["PathPattern"];
  }
  if (output["SmoothStreaming"] !== undefined) {
    contents.SmoothStreaming = output["SmoothStreaming"] == "true";
  }
  if (output["TargetOriginId"] !== undefined) {
    contents.TargetOriginId = output["TargetOriginId"];
  }
  if (output["TrustedSigners"] !== undefined) {
    contents.TrustedSigners = deserializeAws_restXmlTrustedSigners(
      output["TrustedSigners"],
      context
    );
  }
  if (output["ViewerProtocolPolicy"] !== undefined) {
    contents.ViewerProtocolPolicy = output["ViewerProtocolPolicy"];
  }
  return contents;
};

const deserializeAws_restXmlCacheBehaviorList = (
  output: any,
  context: __SerdeContext
): CacheBehavior[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_restXmlCacheBehavior(entry, context)
  );
};

const deserializeAws_restXmlCacheBehaviors = (
  output: any,
  context: __SerdeContext
): CacheBehaviors => {
  let contents: any = {
    __type: "CacheBehaviors",
    Items: undefined,
    Quantity: undefined
  };
  if (output.Items === "") {
    contents.Items = [];
  }
  if (
    output["Items"] !== undefined &&
    output["Items"]["CacheBehavior"] !== undefined
  ) {
    contents.Items = deserializeAws_restXmlCacheBehaviorList(
      __getArrayIfSingleItem(output["Items"]["CacheBehavior"]),
      context
    );
  }
  if (output["Quantity"] !== undefined) {
    contents.Quantity = parseInt(output["Quantity"]);
  }
  return contents;
};

const deserializeAws_restXmlCachedMethods = (
  output: any,
  context: __SerdeContext
): CachedMethods => {
  let contents: any = {
    __type: "CachedMethods",
    Items: undefined,
    Quantity: undefined
  };
  if (output.Items === "") {
    contents.Items = [];
  }
  if (
    output["Items"] !== undefined &&
    output["Items"]["Method"] !== undefined
  ) {
    contents.Items = deserializeAws_restXmlMethodsList(
      __getArrayIfSingleItem(output["Items"]["Method"]),
      context
    );
  }
  if (output["Quantity"] !== undefined) {
    contents.Quantity = parseInt(output["Quantity"]);
  }
  return contents;
};

const deserializeAws_restXmlCloudFrontOriginAccessIdentity = (
  output: any,
  context: __SerdeContext
): CloudFrontOriginAccessIdentity => {
  let contents: any = {
    __type: "CloudFrontOriginAccessIdentity",
    CloudFrontOriginAccessIdentityConfig: undefined,
    Id: undefined,
    S3CanonicalUserId: undefined
  };
  if (output["CloudFrontOriginAccessIdentityConfig"] !== undefined) {
    contents.CloudFrontOriginAccessIdentityConfig = deserializeAws_restXmlCloudFrontOriginAccessIdentityConfig(
      output["CloudFrontOriginAccessIdentityConfig"],
      context
    );
  }
  if (output["Id"] !== undefined) {
    contents.Id = output["Id"];
  }
  if (output["S3CanonicalUserId"] !== undefined) {
    contents.S3CanonicalUserId = output["S3CanonicalUserId"];
  }
  return contents;
};

const deserializeAws_restXmlCloudFrontOriginAccessIdentityConfig = (
  output: any,
  context: __SerdeContext
): CloudFrontOriginAccessIdentityConfig => {
  let contents: any = {
    __type: "CloudFrontOriginAccessIdentityConfig",
    CallerReference: undefined,
    Comment: undefined
  };
  if (output["CallerReference"] !== undefined) {
    contents.CallerReference = output["CallerReference"];
  }
  if (output["Comment"] !== undefined) {
    contents.Comment = output["Comment"];
  }
  return contents;
};

const deserializeAws_restXmlCloudFrontOriginAccessIdentityList = (
  output: any,
  context: __SerdeContext
): CloudFrontOriginAccessIdentityList => {
  let contents: any = {
    __type: "CloudFrontOriginAccessIdentityList",
    IsTruncated: undefined,
    Items: undefined,
    Marker: undefined,
    MaxItems: undefined,
    NextMarker: undefined,
    Quantity: undefined
  };
  if (output["IsTruncated"] !== undefined) {
    contents.IsTruncated = output["IsTruncated"] == "true";
  }
  if (output.Items === "") {
    contents.Items = [];
  }
  if (
    output["Items"] !== undefined &&
    output["Items"]["CloudFrontOriginAccessIdentitySummary"] !== undefined
  ) {
    contents.Items = deserializeAws_restXmlCloudFrontOriginAccessIdentitySummaryList(
      __getArrayIfSingleItem(
        output["Items"]["CloudFrontOriginAccessIdentitySummary"]
      ),
      context
    );
  }
  if (output["Marker"] !== undefined) {
    contents.Marker = output["Marker"];
  }
  if (output["MaxItems"] !== undefined) {
    contents.MaxItems = parseInt(output["MaxItems"]);
  }
  if (output["NextMarker"] !== undefined) {
    contents.NextMarker = output["NextMarker"];
  }
  if (output["Quantity"] !== undefined) {
    contents.Quantity = parseInt(output["Quantity"]);
  }
  return contents;
};

const deserializeAws_restXmlCloudFrontOriginAccessIdentitySummary = (
  output: any,
  context: __SerdeContext
): CloudFrontOriginAccessIdentitySummary => {
  let contents: any = {
    __type: "CloudFrontOriginAccessIdentitySummary",
    Comment: undefined,
    Id: undefined,
    S3CanonicalUserId: undefined
  };
  if (output["Comment"] !== undefined) {
    contents.Comment = output["Comment"];
  }
  if (output["Id"] !== undefined) {
    contents.Id = output["Id"];
  }
  if (output["S3CanonicalUserId"] !== undefined) {
    contents.S3CanonicalUserId = output["S3CanonicalUserId"];
  }
  return contents;
};

const deserializeAws_restXmlCloudFrontOriginAccessIdentitySummaryList = (
  output: any,
  context: __SerdeContext
): CloudFrontOriginAccessIdentitySummary[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_restXmlCloudFrontOriginAccessIdentitySummary(entry, context)
  );
};

const deserializeAws_restXmlContentTypeProfile = (
  output: any,
  context: __SerdeContext
): ContentTypeProfile => {
  let contents: any = {
    __type: "ContentTypeProfile",
    ContentType: undefined,
    Format: undefined,
    ProfileId: undefined
  };
  if (output["ContentType"] !== undefined) {
    contents.ContentType = output["ContentType"];
  }
  if (output["Format"] !== undefined) {
    contents.Format = output["Format"];
  }
  if (output["ProfileId"] !== undefined) {
    contents.ProfileId = output["ProfileId"];
  }
  return contents;
};

const deserializeAws_restXmlContentTypeProfileConfig = (
  output: any,
  context: __SerdeContext
): ContentTypeProfileConfig => {
  let contents: any = {
    __type: "ContentTypeProfileConfig",
    ContentTypeProfiles: undefined,
    ForwardWhenContentTypeIsUnknown: undefined
  };
  if (output["ContentTypeProfiles"] !== undefined) {
    contents.ContentTypeProfiles = deserializeAws_restXmlContentTypeProfiles(
      output["ContentTypeProfiles"],
      context
    );
  }
  if (output["ForwardWhenContentTypeIsUnknown"] !== undefined) {
    contents.ForwardWhenContentTypeIsUnknown =
      output["ForwardWhenContentTypeIsUnknown"] == "true";
  }
  return contents;
};

const deserializeAws_restXmlContentTypeProfileList = (
  output: any,
  context: __SerdeContext
): ContentTypeProfile[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_restXmlContentTypeProfile(entry, context)
  );
};

const deserializeAws_restXmlContentTypeProfiles = (
  output: any,
  context: __SerdeContext
): ContentTypeProfiles => {
  let contents: any = {
    __type: "ContentTypeProfiles",
    Items: undefined,
    Quantity: undefined
  };
  if (output.Items === "") {
    contents.Items = [];
  }
  if (
    output["Items"] !== undefined &&
    output["Items"]["ContentTypeProfile"] !== undefined
  ) {
    contents.Items = deserializeAws_restXmlContentTypeProfileList(
      __getArrayIfSingleItem(output["Items"]["ContentTypeProfile"]),
      context
    );
  }
  if (output["Quantity"] !== undefined) {
    contents.Quantity = parseInt(output["Quantity"]);
  }
  return contents;
};

const deserializeAws_restXmlCookieNameList = (
  output: any,
  context: __SerdeContext
): string[] => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_restXmlCookieNames = (
  output: any,
  context: __SerdeContext
): CookieNames => {
  let contents: any = {
    __type: "CookieNames",
    Items: undefined,
    Quantity: undefined
  };
  if (output.Items === "") {
    contents.Items = [];
  }
  if (output["Items"] !== undefined && output["Items"]["Name"] !== undefined) {
    contents.Items = deserializeAws_restXmlCookieNameList(
      __getArrayIfSingleItem(output["Items"]["Name"]),
      context
    );
  }
  if (output["Quantity"] !== undefined) {
    contents.Quantity = parseInt(output["Quantity"]);
  }
  return contents;
};

const deserializeAws_restXmlCookiePreference = (
  output: any,
  context: __SerdeContext
): CookiePreference => {
  let contents: any = {
    __type: "CookiePreference",
    Forward: undefined,
    WhitelistedNames: undefined
  };
  if (output["Forward"] !== undefined) {
    contents.Forward = output["Forward"];
  }
  if (output["WhitelistedNames"] !== undefined) {
    contents.WhitelistedNames = deserializeAws_restXmlCookieNames(
      output["WhitelistedNames"],
      context
    );
  }
  return contents;
};

const deserializeAws_restXmlCustomErrorResponse = (
  output: any,
  context: __SerdeContext
): CustomErrorResponse => {
  let contents: any = {
    __type: "CustomErrorResponse",
    ErrorCachingMinTTL: undefined,
    ErrorCode: undefined,
    ResponseCode: undefined,
    ResponsePagePath: undefined
  };
  if (output["ErrorCachingMinTTL"] !== undefined) {
    contents.ErrorCachingMinTTL = parseInt(output["ErrorCachingMinTTL"]);
  }
  if (output["ErrorCode"] !== undefined) {
    contents.ErrorCode = parseInt(output["ErrorCode"]);
  }
  if (output["ResponseCode"] !== undefined) {
    contents.ResponseCode = output["ResponseCode"];
  }
  if (output["ResponsePagePath"] !== undefined) {
    contents.ResponsePagePath = output["ResponsePagePath"];
  }
  return contents;
};

const deserializeAws_restXmlCustomErrorResponseList = (
  output: any,
  context: __SerdeContext
): CustomErrorResponse[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_restXmlCustomErrorResponse(entry, context)
  );
};

const deserializeAws_restXmlCustomErrorResponses = (
  output: any,
  context: __SerdeContext
): CustomErrorResponses => {
  let contents: any = {
    __type: "CustomErrorResponses",
    Items: undefined,
    Quantity: undefined
  };
  if (output.Items === "") {
    contents.Items = [];
  }
  if (
    output["Items"] !== undefined &&
    output["Items"]["CustomErrorResponse"] !== undefined
  ) {
    contents.Items = deserializeAws_restXmlCustomErrorResponseList(
      __getArrayIfSingleItem(output["Items"]["CustomErrorResponse"]),
      context
    );
  }
  if (output["Quantity"] !== undefined) {
    contents.Quantity = parseInt(output["Quantity"]);
  }
  return contents;
};

const deserializeAws_restXmlCustomHeaders = (
  output: any,
  context: __SerdeContext
): CustomHeaders => {
  let contents: any = {
    __type: "CustomHeaders",
    Items: undefined,
    Quantity: undefined
  };
  if (output.Items === "") {
    contents.Items = [];
  }
  if (
    output["Items"] !== undefined &&
    output["Items"]["OriginCustomHeader"] !== undefined
  ) {
    contents.Items = deserializeAws_restXmlOriginCustomHeadersList(
      __getArrayIfSingleItem(output["Items"]["OriginCustomHeader"]),
      context
    );
  }
  if (output["Quantity"] !== undefined) {
    contents.Quantity = parseInt(output["Quantity"]);
  }
  return contents;
};

const deserializeAws_restXmlCustomOriginConfig = (
  output: any,
  context: __SerdeContext
): CustomOriginConfig => {
  let contents: any = {
    __type: "CustomOriginConfig",
    HTTPPort: undefined,
    HTTPSPort: undefined,
    OriginKeepaliveTimeout: undefined,
    OriginProtocolPolicy: undefined,
    OriginReadTimeout: undefined,
    OriginSslProtocols: undefined
  };
  if (output["HTTPPort"] !== undefined) {
    contents.HTTPPort = parseInt(output["HTTPPort"]);
  }
  if (output["HTTPSPort"] !== undefined) {
    contents.HTTPSPort = parseInt(output["HTTPSPort"]);
  }
  if (output["OriginKeepaliveTimeout"] !== undefined) {
    contents.OriginKeepaliveTimeout = parseInt(
      output["OriginKeepaliveTimeout"]
    );
  }
  if (output["OriginProtocolPolicy"] !== undefined) {
    contents.OriginProtocolPolicy = output["OriginProtocolPolicy"];
  }
  if (output["OriginReadTimeout"] !== undefined) {
    contents.OriginReadTimeout = parseInt(output["OriginReadTimeout"]);
  }
  if (output["OriginSslProtocols"] !== undefined) {
    contents.OriginSslProtocols = deserializeAws_restXmlOriginSslProtocols(
      output["OriginSslProtocols"],
      context
    );
  }
  return contents;
};

const deserializeAws_restXmlDefaultCacheBehavior = (
  output: any,
  context: __SerdeContext
): DefaultCacheBehavior => {
  let contents: any = {
    __type: "DefaultCacheBehavior",
    AllowedMethods: undefined,
    Compress: undefined,
    DefaultTTL: undefined,
    FieldLevelEncryptionId: undefined,
    ForwardedValues: undefined,
    LambdaFunctionAssociations: undefined,
    MaxTTL: undefined,
    MinTTL: undefined,
    SmoothStreaming: undefined,
    TargetOriginId: undefined,
    TrustedSigners: undefined,
    ViewerProtocolPolicy: undefined
  };
  if (output["AllowedMethods"] !== undefined) {
    contents.AllowedMethods = deserializeAws_restXmlAllowedMethods(
      output["AllowedMethods"],
      context
    );
  }
  if (output["Compress"] !== undefined) {
    contents.Compress = output["Compress"] == "true";
  }
  if (output["DefaultTTL"] !== undefined) {
    contents.DefaultTTL = parseInt(output["DefaultTTL"]);
  }
  if (output["FieldLevelEncryptionId"] !== undefined) {
    contents.FieldLevelEncryptionId = output["FieldLevelEncryptionId"];
  }
  if (output["ForwardedValues"] !== undefined) {
    contents.ForwardedValues = deserializeAws_restXmlForwardedValues(
      output["ForwardedValues"],
      context
    );
  }
  if (output["LambdaFunctionAssociations"] !== undefined) {
    contents.LambdaFunctionAssociations = deserializeAws_restXmlLambdaFunctionAssociations(
      output["LambdaFunctionAssociations"],
      context
    );
  }
  if (output["MaxTTL"] !== undefined) {
    contents.MaxTTL = parseInt(output["MaxTTL"]);
  }
  if (output["MinTTL"] !== undefined) {
    contents.MinTTL = parseInt(output["MinTTL"]);
  }
  if (output["SmoothStreaming"] !== undefined) {
    contents.SmoothStreaming = output["SmoothStreaming"] == "true";
  }
  if (output["TargetOriginId"] !== undefined) {
    contents.TargetOriginId = output["TargetOriginId"];
  }
  if (output["TrustedSigners"] !== undefined) {
    contents.TrustedSigners = deserializeAws_restXmlTrustedSigners(
      output["TrustedSigners"],
      context
    );
  }
  if (output["ViewerProtocolPolicy"] !== undefined) {
    contents.ViewerProtocolPolicy = output["ViewerProtocolPolicy"];
  }
  return contents;
};

const deserializeAws_restXmlDistribution = (
  output: any,
  context: __SerdeContext
): Distribution => {
  let contents: any = {
    __type: "Distribution",
    ARN: undefined,
    ActiveTrustedSigners: undefined,
    AliasICPRecordals: undefined,
    DistributionConfig: undefined,
    DomainName: undefined,
    Id: undefined,
    InProgressInvalidationBatches: undefined,
    LastModifiedTime: undefined,
    Status: undefined
  };
  if (output["ARN"] !== undefined) {
    contents.ARN = output["ARN"];
  }
  if (output["ActiveTrustedSigners"] !== undefined) {
    contents.ActiveTrustedSigners = deserializeAws_restXmlActiveTrustedSigners(
      output["ActiveTrustedSigners"],
      context
    );
  }
  if (output.AliasICPRecordals === "") {
    contents.AliasICPRecordals = [];
  }
  if (
    output["AliasICPRecordals"] !== undefined &&
    output["AliasICPRecordals"]["AliasICPRecordal"] !== undefined
  ) {
    contents.AliasICPRecordals = deserializeAws_restXmlAliasICPRecordals(
      __getArrayIfSingleItem(output["AliasICPRecordals"]["AliasICPRecordal"]),
      context
    );
  }
  if (output["DistributionConfig"] !== undefined) {
    contents.DistributionConfig = deserializeAws_restXmlDistributionConfig(
      output["DistributionConfig"],
      context
    );
  }
  if (output["DomainName"] !== undefined) {
    contents.DomainName = output["DomainName"];
  }
  if (output["Id"] !== undefined) {
    contents.Id = output["Id"];
  }
  if (output["InProgressInvalidationBatches"] !== undefined) {
    contents.InProgressInvalidationBatches = parseInt(
      output["InProgressInvalidationBatches"]
    );
  }
  if (output["LastModifiedTime"] !== undefined) {
    contents.LastModifiedTime = new Date(output["LastModifiedTime"]);
  }
  if (output["Status"] !== undefined) {
    contents.Status = output["Status"];
  }
  return contents;
};

const deserializeAws_restXmlDistributionConfig = (
  output: any,
  context: __SerdeContext
): DistributionConfig => {
  let contents: any = {
    __type: "DistributionConfig",
    Aliases: undefined,
    CacheBehaviors: undefined,
    CallerReference: undefined,
    Comment: undefined,
    CustomErrorResponses: undefined,
    DefaultCacheBehavior: undefined,
    DefaultRootObject: undefined,
    Enabled: undefined,
    HttpVersion: undefined,
    IsIPV6Enabled: undefined,
    Logging: undefined,
    OriginGroups: undefined,
    Origins: undefined,
    PriceClass: undefined,
    Restrictions: undefined,
    ViewerCertificate: undefined,
    WebACLId: undefined
  };
  if (output["Aliases"] !== undefined) {
    contents.Aliases = deserializeAws_restXmlAliases(
      output["Aliases"],
      context
    );
  }
  if (output["CacheBehaviors"] !== undefined) {
    contents.CacheBehaviors = deserializeAws_restXmlCacheBehaviors(
      output["CacheBehaviors"],
      context
    );
  }
  if (output["CallerReference"] !== undefined) {
    contents.CallerReference = output["CallerReference"];
  }
  if (output["Comment"] !== undefined) {
    contents.Comment = output["Comment"];
  }
  if (output["CustomErrorResponses"] !== undefined) {
    contents.CustomErrorResponses = deserializeAws_restXmlCustomErrorResponses(
      output["CustomErrorResponses"],
      context
    );
  }
  if (output["DefaultCacheBehavior"] !== undefined) {
    contents.DefaultCacheBehavior = deserializeAws_restXmlDefaultCacheBehavior(
      output["DefaultCacheBehavior"],
      context
    );
  }
  if (output["DefaultRootObject"] !== undefined) {
    contents.DefaultRootObject = output["DefaultRootObject"];
  }
  if (output["Enabled"] !== undefined) {
    contents.Enabled = output["Enabled"] == "true";
  }
  if (output["HttpVersion"] !== undefined) {
    contents.HttpVersion = output["HttpVersion"];
  }
  if (output["IsIPV6Enabled"] !== undefined) {
    contents.IsIPV6Enabled = output["IsIPV6Enabled"] == "true";
  }
  if (output["Logging"] !== undefined) {
    contents.Logging = deserializeAws_restXmlLoggingConfig(
      output["Logging"],
      context
    );
  }
  if (output["OriginGroups"] !== undefined) {
    contents.OriginGroups = deserializeAws_restXmlOriginGroups(
      output["OriginGroups"],
      context
    );
  }
  if (output["Origins"] !== undefined) {
    contents.Origins = deserializeAws_restXmlOrigins(
      output["Origins"],
      context
    );
  }
  if (output["PriceClass"] !== undefined) {
    contents.PriceClass = output["PriceClass"];
  }
  if (output["Restrictions"] !== undefined) {
    contents.Restrictions = deserializeAws_restXmlRestrictions(
      output["Restrictions"],
      context
    );
  }
  if (output["ViewerCertificate"] !== undefined) {
    contents.ViewerCertificate = deserializeAws_restXmlViewerCertificate(
      output["ViewerCertificate"],
      context
    );
  }
  if (output["WebACLId"] !== undefined) {
    contents.WebACLId = output["WebACLId"];
  }
  return contents;
};

const deserializeAws_restXmlDistributionList = (
  output: any,
  context: __SerdeContext
): DistributionList => {
  let contents: any = {
    __type: "DistributionList",
    IsTruncated: undefined,
    Items: undefined,
    Marker: undefined,
    MaxItems: undefined,
    NextMarker: undefined,
    Quantity: undefined
  };
  if (output["IsTruncated"] !== undefined) {
    contents.IsTruncated = output["IsTruncated"] == "true";
  }
  if (output.Items === "") {
    contents.Items = [];
  }
  if (
    output["Items"] !== undefined &&
    output["Items"]["DistributionSummary"] !== undefined
  ) {
    contents.Items = deserializeAws_restXmlDistributionSummaryList(
      __getArrayIfSingleItem(output["Items"]["DistributionSummary"]),
      context
    );
  }
  if (output["Marker"] !== undefined) {
    contents.Marker = output["Marker"];
  }
  if (output["MaxItems"] !== undefined) {
    contents.MaxItems = parseInt(output["MaxItems"]);
  }
  if (output["NextMarker"] !== undefined) {
    contents.NextMarker = output["NextMarker"];
  }
  if (output["Quantity"] !== undefined) {
    contents.Quantity = parseInt(output["Quantity"]);
  }
  return contents;
};

const deserializeAws_restXmlDistributionSummary = (
  output: any,
  context: __SerdeContext
): DistributionSummary => {
  let contents: any = {
    __type: "DistributionSummary",
    ARN: undefined,
    AliasICPRecordals: undefined,
    Aliases: undefined,
    CacheBehaviors: undefined,
    Comment: undefined,
    CustomErrorResponses: undefined,
    DefaultCacheBehavior: undefined,
    DomainName: undefined,
    Enabled: undefined,
    HttpVersion: undefined,
    Id: undefined,
    IsIPV6Enabled: undefined,
    LastModifiedTime: undefined,
    OriginGroups: undefined,
    Origins: undefined,
    PriceClass: undefined,
    Restrictions: undefined,
    Status: undefined,
    ViewerCertificate: undefined,
    WebACLId: undefined
  };
  if (output["ARN"] !== undefined) {
    contents.ARN = output["ARN"];
  }
  if (output.AliasICPRecordals === "") {
    contents.AliasICPRecordals = [];
  }
  if (
    output["AliasICPRecordals"] !== undefined &&
    output["AliasICPRecordals"]["AliasICPRecordal"] !== undefined
  ) {
    contents.AliasICPRecordals = deserializeAws_restXmlAliasICPRecordals(
      __getArrayIfSingleItem(output["AliasICPRecordals"]["AliasICPRecordal"]),
      context
    );
  }
  if (output["Aliases"] !== undefined) {
    contents.Aliases = deserializeAws_restXmlAliases(
      output["Aliases"],
      context
    );
  }
  if (output["CacheBehaviors"] !== undefined) {
    contents.CacheBehaviors = deserializeAws_restXmlCacheBehaviors(
      output["CacheBehaviors"],
      context
    );
  }
  if (output["Comment"] !== undefined) {
    contents.Comment = output["Comment"];
  }
  if (output["CustomErrorResponses"] !== undefined) {
    contents.CustomErrorResponses = deserializeAws_restXmlCustomErrorResponses(
      output["CustomErrorResponses"],
      context
    );
  }
  if (output["DefaultCacheBehavior"] !== undefined) {
    contents.DefaultCacheBehavior = deserializeAws_restXmlDefaultCacheBehavior(
      output["DefaultCacheBehavior"],
      context
    );
  }
  if (output["DomainName"] !== undefined) {
    contents.DomainName = output["DomainName"];
  }
  if (output["Enabled"] !== undefined) {
    contents.Enabled = output["Enabled"] == "true";
  }
  if (output["HttpVersion"] !== undefined) {
    contents.HttpVersion = output["HttpVersion"];
  }
  if (output["Id"] !== undefined) {
    contents.Id = output["Id"];
  }
  if (output["IsIPV6Enabled"] !== undefined) {
    contents.IsIPV6Enabled = output["IsIPV6Enabled"] == "true";
  }
  if (output["LastModifiedTime"] !== undefined) {
    contents.LastModifiedTime = new Date(output["LastModifiedTime"]);
  }
  if (output["OriginGroups"] !== undefined) {
    contents.OriginGroups = deserializeAws_restXmlOriginGroups(
      output["OriginGroups"],
      context
    );
  }
  if (output["Origins"] !== undefined) {
    contents.Origins = deserializeAws_restXmlOrigins(
      output["Origins"],
      context
    );
  }
  if (output["PriceClass"] !== undefined) {
    contents.PriceClass = output["PriceClass"];
  }
  if (output["Restrictions"] !== undefined) {
    contents.Restrictions = deserializeAws_restXmlRestrictions(
      output["Restrictions"],
      context
    );
  }
  if (output["Status"] !== undefined) {
    contents.Status = output["Status"];
  }
  if (output["ViewerCertificate"] !== undefined) {
    contents.ViewerCertificate = deserializeAws_restXmlViewerCertificate(
      output["ViewerCertificate"],
      context
    );
  }
  if (output["WebACLId"] !== undefined) {
    contents.WebACLId = output["WebACLId"];
  }
  return contents;
};

const deserializeAws_restXmlDistributionSummaryList = (
  output: any,
  context: __SerdeContext
): DistributionSummary[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_restXmlDistributionSummary(entry, context)
  );
};

const deserializeAws_restXmlEncryptionEntities = (
  output: any,
  context: __SerdeContext
): EncryptionEntities => {
  let contents: any = {
    __type: "EncryptionEntities",
    Items: undefined,
    Quantity: undefined
  };
  if (output.Items === "") {
    contents.Items = [];
  }
  if (
    output["Items"] !== undefined &&
    output["Items"]["EncryptionEntity"] !== undefined
  ) {
    contents.Items = deserializeAws_restXmlEncryptionEntityList(
      __getArrayIfSingleItem(output["Items"]["EncryptionEntity"]),
      context
    );
  }
  if (output["Quantity"] !== undefined) {
    contents.Quantity = parseInt(output["Quantity"]);
  }
  return contents;
};

const deserializeAws_restXmlEncryptionEntity = (
  output: any,
  context: __SerdeContext
): EncryptionEntity => {
  let contents: any = {
    __type: "EncryptionEntity",
    FieldPatterns: undefined,
    ProviderId: undefined,
    PublicKeyId: undefined
  };
  if (output["FieldPatterns"] !== undefined) {
    contents.FieldPatterns = deserializeAws_restXmlFieldPatterns(
      output["FieldPatterns"],
      context
    );
  }
  if (output["ProviderId"] !== undefined) {
    contents.ProviderId = output["ProviderId"];
  }
  if (output["PublicKeyId"] !== undefined) {
    contents.PublicKeyId = output["PublicKeyId"];
  }
  return contents;
};

const deserializeAws_restXmlEncryptionEntityList = (
  output: any,
  context: __SerdeContext
): EncryptionEntity[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_restXmlEncryptionEntity(entry, context)
  );
};

const deserializeAws_restXmlFieldLevelEncryption = (
  output: any,
  context: __SerdeContext
): FieldLevelEncryption => {
  let contents: any = {
    __type: "FieldLevelEncryption",
    FieldLevelEncryptionConfig: undefined,
    Id: undefined,
    LastModifiedTime: undefined
  };
  if (output["FieldLevelEncryptionConfig"] !== undefined) {
    contents.FieldLevelEncryptionConfig = deserializeAws_restXmlFieldLevelEncryptionConfig(
      output["FieldLevelEncryptionConfig"],
      context
    );
  }
  if (output["Id"] !== undefined) {
    contents.Id = output["Id"];
  }
  if (output["LastModifiedTime"] !== undefined) {
    contents.LastModifiedTime = new Date(output["LastModifiedTime"]);
  }
  return contents;
};

const deserializeAws_restXmlFieldLevelEncryptionConfig = (
  output: any,
  context: __SerdeContext
): FieldLevelEncryptionConfig => {
  let contents: any = {
    __type: "FieldLevelEncryptionConfig",
    CallerReference: undefined,
    Comment: undefined,
    ContentTypeProfileConfig: undefined,
    QueryArgProfileConfig: undefined
  };
  if (output["CallerReference"] !== undefined) {
    contents.CallerReference = output["CallerReference"];
  }
  if (output["Comment"] !== undefined) {
    contents.Comment = output["Comment"];
  }
  if (output["ContentTypeProfileConfig"] !== undefined) {
    contents.ContentTypeProfileConfig = deserializeAws_restXmlContentTypeProfileConfig(
      output["ContentTypeProfileConfig"],
      context
    );
  }
  if (output["QueryArgProfileConfig"] !== undefined) {
    contents.QueryArgProfileConfig = deserializeAws_restXmlQueryArgProfileConfig(
      output["QueryArgProfileConfig"],
      context
    );
  }
  return contents;
};

const deserializeAws_restXmlFieldLevelEncryptionList = (
  output: any,
  context: __SerdeContext
): FieldLevelEncryptionList => {
  let contents: any = {
    __type: "FieldLevelEncryptionList",
    Items: undefined,
    MaxItems: undefined,
    NextMarker: undefined,
    Quantity: undefined
  };
  if (output.Items === "") {
    contents.Items = [];
  }
  if (
    output["Items"] !== undefined &&
    output["Items"]["FieldLevelEncryptionSummary"] !== undefined
  ) {
    contents.Items = deserializeAws_restXmlFieldLevelEncryptionSummaryList(
      __getArrayIfSingleItem(output["Items"]["FieldLevelEncryptionSummary"]),
      context
    );
  }
  if (output["MaxItems"] !== undefined) {
    contents.MaxItems = parseInt(output["MaxItems"]);
  }
  if (output["NextMarker"] !== undefined) {
    contents.NextMarker = output["NextMarker"];
  }
  if (output["Quantity"] !== undefined) {
    contents.Quantity = parseInt(output["Quantity"]);
  }
  return contents;
};

const deserializeAws_restXmlFieldLevelEncryptionProfile = (
  output: any,
  context: __SerdeContext
): FieldLevelEncryptionProfile => {
  let contents: any = {
    __type: "FieldLevelEncryptionProfile",
    FieldLevelEncryptionProfileConfig: undefined,
    Id: undefined,
    LastModifiedTime: undefined
  };
  if (output["FieldLevelEncryptionProfileConfig"] !== undefined) {
    contents.FieldLevelEncryptionProfileConfig = deserializeAws_restXmlFieldLevelEncryptionProfileConfig(
      output["FieldLevelEncryptionProfileConfig"],
      context
    );
  }
  if (output["Id"] !== undefined) {
    contents.Id = output["Id"];
  }
  if (output["LastModifiedTime"] !== undefined) {
    contents.LastModifiedTime = new Date(output["LastModifiedTime"]);
  }
  return contents;
};

const deserializeAws_restXmlFieldLevelEncryptionProfileConfig = (
  output: any,
  context: __SerdeContext
): FieldLevelEncryptionProfileConfig => {
  let contents: any = {
    __type: "FieldLevelEncryptionProfileConfig",
    CallerReference: undefined,
    Comment: undefined,
    EncryptionEntities: undefined,
    Name: undefined
  };
  if (output["CallerReference"] !== undefined) {
    contents.CallerReference = output["CallerReference"];
  }
  if (output["Comment"] !== undefined) {
    contents.Comment = output["Comment"];
  }
  if (output["EncryptionEntities"] !== undefined) {
    contents.EncryptionEntities = deserializeAws_restXmlEncryptionEntities(
      output["EncryptionEntities"],
      context
    );
  }
  if (output["Name"] !== undefined) {
    contents.Name = output["Name"];
  }
  return contents;
};

const deserializeAws_restXmlFieldLevelEncryptionProfileList = (
  output: any,
  context: __SerdeContext
): FieldLevelEncryptionProfileList => {
  let contents: any = {
    __type: "FieldLevelEncryptionProfileList",
    Items: undefined,
    MaxItems: undefined,
    NextMarker: undefined,
    Quantity: undefined
  };
  if (output.Items === "") {
    contents.Items = [];
  }
  if (
    output["Items"] !== undefined &&
    output["Items"]["FieldLevelEncryptionProfileSummary"] !== undefined
  ) {
    contents.Items = deserializeAws_restXmlFieldLevelEncryptionProfileSummaryList(
      __getArrayIfSingleItem(
        output["Items"]["FieldLevelEncryptionProfileSummary"]
      ),
      context
    );
  }
  if (output["MaxItems"] !== undefined) {
    contents.MaxItems = parseInt(output["MaxItems"]);
  }
  if (output["NextMarker"] !== undefined) {
    contents.NextMarker = output["NextMarker"];
  }
  if (output["Quantity"] !== undefined) {
    contents.Quantity = parseInt(output["Quantity"]);
  }
  return contents;
};

const deserializeAws_restXmlFieldLevelEncryptionProfileSummary = (
  output: any,
  context: __SerdeContext
): FieldLevelEncryptionProfileSummary => {
  let contents: any = {
    __type: "FieldLevelEncryptionProfileSummary",
    Comment: undefined,
    EncryptionEntities: undefined,
    Id: undefined,
    LastModifiedTime: undefined,
    Name: undefined
  };
  if (output["Comment"] !== undefined) {
    contents.Comment = output["Comment"];
  }
  if (output["EncryptionEntities"] !== undefined) {
    contents.EncryptionEntities = deserializeAws_restXmlEncryptionEntities(
      output["EncryptionEntities"],
      context
    );
  }
  if (output["Id"] !== undefined) {
    contents.Id = output["Id"];
  }
  if (output["LastModifiedTime"] !== undefined) {
    contents.LastModifiedTime = new Date(output["LastModifiedTime"]);
  }
  if (output["Name"] !== undefined) {
    contents.Name = output["Name"];
  }
  return contents;
};

const deserializeAws_restXmlFieldLevelEncryptionProfileSummaryList = (
  output: any,
  context: __SerdeContext
): FieldLevelEncryptionProfileSummary[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_restXmlFieldLevelEncryptionProfileSummary(entry, context)
  );
};

const deserializeAws_restXmlFieldLevelEncryptionSummary = (
  output: any,
  context: __SerdeContext
): FieldLevelEncryptionSummary => {
  let contents: any = {
    __type: "FieldLevelEncryptionSummary",
    Comment: undefined,
    ContentTypeProfileConfig: undefined,
    Id: undefined,
    LastModifiedTime: undefined,
    QueryArgProfileConfig: undefined
  };
  if (output["Comment"] !== undefined) {
    contents.Comment = output["Comment"];
  }
  if (output["ContentTypeProfileConfig"] !== undefined) {
    contents.ContentTypeProfileConfig = deserializeAws_restXmlContentTypeProfileConfig(
      output["ContentTypeProfileConfig"],
      context
    );
  }
  if (output["Id"] !== undefined) {
    contents.Id = output["Id"];
  }
  if (output["LastModifiedTime"] !== undefined) {
    contents.LastModifiedTime = new Date(output["LastModifiedTime"]);
  }
  if (output["QueryArgProfileConfig"] !== undefined) {
    contents.QueryArgProfileConfig = deserializeAws_restXmlQueryArgProfileConfig(
      output["QueryArgProfileConfig"],
      context
    );
  }
  return contents;
};

const deserializeAws_restXmlFieldLevelEncryptionSummaryList = (
  output: any,
  context: __SerdeContext
): FieldLevelEncryptionSummary[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_restXmlFieldLevelEncryptionSummary(entry, context)
  );
};

const deserializeAws_restXmlFieldPatternList = (
  output: any,
  context: __SerdeContext
): string[] => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_restXmlFieldPatterns = (
  output: any,
  context: __SerdeContext
): FieldPatterns => {
  let contents: any = {
    __type: "FieldPatterns",
    Items: undefined,
    Quantity: undefined
  };
  if (output.Items === "") {
    contents.Items = [];
  }
  if (
    output["Items"] !== undefined &&
    output["Items"]["FieldPattern"] !== undefined
  ) {
    contents.Items = deserializeAws_restXmlFieldPatternList(
      __getArrayIfSingleItem(output["Items"]["FieldPattern"]),
      context
    );
  }
  if (output["Quantity"] !== undefined) {
    contents.Quantity = parseInt(output["Quantity"]);
  }
  return contents;
};

const deserializeAws_restXmlForwardedValues = (
  output: any,
  context: __SerdeContext
): ForwardedValues => {
  let contents: any = {
    __type: "ForwardedValues",
    Cookies: undefined,
    Headers: undefined,
    QueryString: undefined,
    QueryStringCacheKeys: undefined
  };
  if (output["Cookies"] !== undefined) {
    contents.Cookies = deserializeAws_restXmlCookiePreference(
      output["Cookies"],
      context
    );
  }
  if (output["Headers"] !== undefined) {
    contents.Headers = deserializeAws_restXmlHeaders(
      output["Headers"],
      context
    );
  }
  if (output["QueryString"] !== undefined) {
    contents.QueryString = output["QueryString"] == "true";
  }
  if (output["QueryStringCacheKeys"] !== undefined) {
    contents.QueryStringCacheKeys = deserializeAws_restXmlQueryStringCacheKeys(
      output["QueryStringCacheKeys"],
      context
    );
  }
  return contents;
};

const deserializeAws_restXmlGeoRestriction = (
  output: any,
  context: __SerdeContext
): GeoRestriction => {
  let contents: any = {
    __type: "GeoRestriction",
    Items: undefined,
    Quantity: undefined,
    RestrictionType: undefined
  };
  if (output.Items === "") {
    contents.Items = [];
  }
  if (
    output["Items"] !== undefined &&
    output["Items"]["Location"] !== undefined
  ) {
    contents.Items = deserializeAws_restXmlLocationList(
      __getArrayIfSingleItem(output["Items"]["Location"]),
      context
    );
  }
  if (output["Quantity"] !== undefined) {
    contents.Quantity = parseInt(output["Quantity"]);
  }
  if (output["RestrictionType"] !== undefined) {
    contents.RestrictionType = output["RestrictionType"];
  }
  return contents;
};

const deserializeAws_restXmlHeaderList = (
  output: any,
  context: __SerdeContext
): string[] => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_restXmlHeaders = (
  output: any,
  context: __SerdeContext
): Headers => {
  let contents: any = {
    __type: "Headers",
    Items: undefined,
    Quantity: undefined
  };
  if (output.Items === "") {
    contents.Items = [];
  }
  if (output["Items"] !== undefined && output["Items"]["Name"] !== undefined) {
    contents.Items = deserializeAws_restXmlHeaderList(
      __getArrayIfSingleItem(output["Items"]["Name"]),
      context
    );
  }
  if (output["Quantity"] !== undefined) {
    contents.Quantity = parseInt(output["Quantity"]);
  }
  return contents;
};

const deserializeAws_restXmlInvalidation = (
  output: any,
  context: __SerdeContext
): Invalidation => {
  let contents: any = {
    __type: "Invalidation",
    CreateTime: undefined,
    Id: undefined,
    InvalidationBatch: undefined,
    Status: undefined
  };
  if (output["CreateTime"] !== undefined) {
    contents.CreateTime = new Date(output["CreateTime"]);
  }
  if (output["Id"] !== undefined) {
    contents.Id = output["Id"];
  }
  if (output["InvalidationBatch"] !== undefined) {
    contents.InvalidationBatch = deserializeAws_restXmlInvalidationBatch(
      output["InvalidationBatch"],
      context
    );
  }
  if (output["Status"] !== undefined) {
    contents.Status = output["Status"];
  }
  return contents;
};

const deserializeAws_restXmlInvalidationBatch = (
  output: any,
  context: __SerdeContext
): InvalidationBatch => {
  let contents: any = {
    __type: "InvalidationBatch",
    CallerReference: undefined,
    Paths: undefined
  };
  if (output["CallerReference"] !== undefined) {
    contents.CallerReference = output["CallerReference"];
  }
  if (output["Paths"] !== undefined) {
    contents.Paths = deserializeAws_restXmlPaths(output["Paths"], context);
  }
  return contents;
};

const deserializeAws_restXmlInvalidationList = (
  output: any,
  context: __SerdeContext
): InvalidationList => {
  let contents: any = {
    __type: "InvalidationList",
    IsTruncated: undefined,
    Items: undefined,
    Marker: undefined,
    MaxItems: undefined,
    NextMarker: undefined,
    Quantity: undefined
  };
  if (output["IsTruncated"] !== undefined) {
    contents.IsTruncated = output["IsTruncated"] == "true";
  }
  if (output.Items === "") {
    contents.Items = [];
  }
  if (
    output["Items"] !== undefined &&
    output["Items"]["InvalidationSummary"] !== undefined
  ) {
    contents.Items = deserializeAws_restXmlInvalidationSummaryList(
      __getArrayIfSingleItem(output["Items"]["InvalidationSummary"]),
      context
    );
  }
  if (output["Marker"] !== undefined) {
    contents.Marker = output["Marker"];
  }
  if (output["MaxItems"] !== undefined) {
    contents.MaxItems = parseInt(output["MaxItems"]);
  }
  if (output["NextMarker"] !== undefined) {
    contents.NextMarker = output["NextMarker"];
  }
  if (output["Quantity"] !== undefined) {
    contents.Quantity = parseInt(output["Quantity"]);
  }
  return contents;
};

const deserializeAws_restXmlInvalidationSummary = (
  output: any,
  context: __SerdeContext
): InvalidationSummary => {
  let contents: any = {
    __type: "InvalidationSummary",
    CreateTime: undefined,
    Id: undefined,
    Status: undefined
  };
  if (output["CreateTime"] !== undefined) {
    contents.CreateTime = new Date(output["CreateTime"]);
  }
  if (output["Id"] !== undefined) {
    contents.Id = output["Id"];
  }
  if (output["Status"] !== undefined) {
    contents.Status = output["Status"];
  }
  return contents;
};

const deserializeAws_restXmlInvalidationSummaryList = (
  output: any,
  context: __SerdeContext
): InvalidationSummary[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_restXmlInvalidationSummary(entry, context)
  );
};

const deserializeAws_restXmlKeyPairIdList = (
  output: any,
  context: __SerdeContext
): string[] => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_restXmlKeyPairIds = (
  output: any,
  context: __SerdeContext
): KeyPairIds => {
  let contents: any = {
    __type: "KeyPairIds",
    Items: undefined,
    Quantity: undefined
  };
  if (output.Items === "") {
    contents.Items = [];
  }
  if (
    output["Items"] !== undefined &&
    output["Items"]["KeyPairId"] !== undefined
  ) {
    contents.Items = deserializeAws_restXmlKeyPairIdList(
      __getArrayIfSingleItem(output["Items"]["KeyPairId"]),
      context
    );
  }
  if (output["Quantity"] !== undefined) {
    contents.Quantity = parseInt(output["Quantity"]);
  }
  return contents;
};

const deserializeAws_restXmlLambdaFunctionAssociation = (
  output: any,
  context: __SerdeContext
): LambdaFunctionAssociation => {
  let contents: any = {
    __type: "LambdaFunctionAssociation",
    EventType: undefined,
    IncludeBody: undefined,
    LambdaFunctionARN: undefined
  };
  if (output["EventType"] !== undefined) {
    contents.EventType = output["EventType"];
  }
  if (output["IncludeBody"] !== undefined) {
    contents.IncludeBody = output["IncludeBody"] == "true";
  }
  if (output["LambdaFunctionARN"] !== undefined) {
    contents.LambdaFunctionARN = output["LambdaFunctionARN"];
  }
  return contents;
};

const deserializeAws_restXmlLambdaFunctionAssociationList = (
  output: any,
  context: __SerdeContext
): LambdaFunctionAssociation[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_restXmlLambdaFunctionAssociation(entry, context)
  );
};

const deserializeAws_restXmlLambdaFunctionAssociations = (
  output: any,
  context: __SerdeContext
): LambdaFunctionAssociations => {
  let contents: any = {
    __type: "LambdaFunctionAssociations",
    Items: undefined,
    Quantity: undefined
  };
  if (output.Items === "") {
    contents.Items = [];
  }
  if (
    output["Items"] !== undefined &&
    output["Items"]["LambdaFunctionAssociation"] !== undefined
  ) {
    contents.Items = deserializeAws_restXmlLambdaFunctionAssociationList(
      __getArrayIfSingleItem(output["Items"]["LambdaFunctionAssociation"]),
      context
    );
  }
  if (output["Quantity"] !== undefined) {
    contents.Quantity = parseInt(output["Quantity"]);
  }
  return contents;
};

const deserializeAws_restXmlLocationList = (
  output: any,
  context: __SerdeContext
): string[] => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_restXmlLoggingConfig = (
  output: any,
  context: __SerdeContext
): LoggingConfig => {
  let contents: any = {
    __type: "LoggingConfig",
    Bucket: undefined,
    Enabled: undefined,
    IncludeCookies: undefined,
    Prefix: undefined
  };
  if (output["Bucket"] !== undefined) {
    contents.Bucket = output["Bucket"];
  }
  if (output["Enabled"] !== undefined) {
    contents.Enabled = output["Enabled"] == "true";
  }
  if (output["IncludeCookies"] !== undefined) {
    contents.IncludeCookies = output["IncludeCookies"] == "true";
  }
  if (output["Prefix"] !== undefined) {
    contents.Prefix = output["Prefix"];
  }
  return contents;
};

const deserializeAws_restXmlMethodsList = (
  output: any,
  context: __SerdeContext
): (Method | string)[] => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_restXmlOrigin = (
  output: any,
  context: __SerdeContext
): Origin => {
  let contents: any = {
    __type: "Origin",
    CustomHeaders: undefined,
    CustomOriginConfig: undefined,
    DomainName: undefined,
    Id: undefined,
    OriginPath: undefined,
    S3OriginConfig: undefined
  };
  if (output["CustomHeaders"] !== undefined) {
    contents.CustomHeaders = deserializeAws_restXmlCustomHeaders(
      output["CustomHeaders"],
      context
    );
  }
  if (output["CustomOriginConfig"] !== undefined) {
    contents.CustomOriginConfig = deserializeAws_restXmlCustomOriginConfig(
      output["CustomOriginConfig"],
      context
    );
  }
  if (output["DomainName"] !== undefined) {
    contents.DomainName = output["DomainName"];
  }
  if (output["Id"] !== undefined) {
    contents.Id = output["Id"];
  }
  if (output["OriginPath"] !== undefined) {
    contents.OriginPath = output["OriginPath"];
  }
  if (output["S3OriginConfig"] !== undefined) {
    contents.S3OriginConfig = deserializeAws_restXmlS3OriginConfig(
      output["S3OriginConfig"],
      context
    );
  }
  return contents;
};

const deserializeAws_restXmlOriginCustomHeader = (
  output: any,
  context: __SerdeContext
): OriginCustomHeader => {
  let contents: any = {
    __type: "OriginCustomHeader",
    HeaderName: undefined,
    HeaderValue: undefined
  };
  if (output["HeaderName"] !== undefined) {
    contents.HeaderName = output["HeaderName"];
  }
  if (output["HeaderValue"] !== undefined) {
    contents.HeaderValue = output["HeaderValue"];
  }
  return contents;
};

const deserializeAws_restXmlOriginCustomHeadersList = (
  output: any,
  context: __SerdeContext
): OriginCustomHeader[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_restXmlOriginCustomHeader(entry, context)
  );
};

const deserializeAws_restXmlOriginGroup = (
  output: any,
  context: __SerdeContext
): OriginGroup => {
  let contents: any = {
    __type: "OriginGroup",
    FailoverCriteria: undefined,
    Id: undefined,
    Members: undefined
  };
  if (output["FailoverCriteria"] !== undefined) {
    contents.FailoverCriteria = deserializeAws_restXmlOriginGroupFailoverCriteria(
      output["FailoverCriteria"],
      context
    );
  }
  if (output["Id"] !== undefined) {
    contents.Id = output["Id"];
  }
  if (output["Members"] !== undefined) {
    contents.Members = deserializeAws_restXmlOriginGroupMembers(
      output["Members"],
      context
    );
  }
  return contents;
};

const deserializeAws_restXmlOriginGroupFailoverCriteria = (
  output: any,
  context: __SerdeContext
): OriginGroupFailoverCriteria => {
  let contents: any = {
    __type: "OriginGroupFailoverCriteria",
    StatusCodes: undefined
  };
  if (output["StatusCodes"] !== undefined) {
    contents.StatusCodes = deserializeAws_restXmlStatusCodes(
      output["StatusCodes"],
      context
    );
  }
  return contents;
};

const deserializeAws_restXmlOriginGroupList = (
  output: any,
  context: __SerdeContext
): OriginGroup[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_restXmlOriginGroup(entry, context)
  );
};

const deserializeAws_restXmlOriginGroupMember = (
  output: any,
  context: __SerdeContext
): OriginGroupMember => {
  let contents: any = {
    __type: "OriginGroupMember",
    OriginId: undefined
  };
  if (output["OriginId"] !== undefined) {
    contents.OriginId = output["OriginId"];
  }
  return contents;
};

const deserializeAws_restXmlOriginGroupMemberList = (
  output: any,
  context: __SerdeContext
): OriginGroupMember[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_restXmlOriginGroupMember(entry, context)
  );
};

const deserializeAws_restXmlOriginGroupMembers = (
  output: any,
  context: __SerdeContext
): OriginGroupMembers => {
  let contents: any = {
    __type: "OriginGroupMembers",
    Items: undefined,
    Quantity: undefined
  };
  if (output.Items === "") {
    contents.Items = [];
  }
  if (
    output["Items"] !== undefined &&
    output["Items"]["OriginGroupMember"] !== undefined
  ) {
    contents.Items = deserializeAws_restXmlOriginGroupMemberList(
      __getArrayIfSingleItem(output["Items"]["OriginGroupMember"]),
      context
    );
  }
  if (output["Quantity"] !== undefined) {
    contents.Quantity = parseInt(output["Quantity"]);
  }
  return contents;
};

const deserializeAws_restXmlOriginGroups = (
  output: any,
  context: __SerdeContext
): OriginGroups => {
  let contents: any = {
    __type: "OriginGroups",
    Items: undefined,
    Quantity: undefined
  };
  if (output.Items === "") {
    contents.Items = [];
  }
  if (
    output["Items"] !== undefined &&
    output["Items"]["OriginGroup"] !== undefined
  ) {
    contents.Items = deserializeAws_restXmlOriginGroupList(
      __getArrayIfSingleItem(output["Items"]["OriginGroup"]),
      context
    );
  }
  if (output["Quantity"] !== undefined) {
    contents.Quantity = parseInt(output["Quantity"]);
  }
  return contents;
};

const deserializeAws_restXmlOriginList = (
  output: any,
  context: __SerdeContext
): Origin[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_restXmlOrigin(entry, context)
  );
};

const deserializeAws_restXmlOrigins = (
  output: any,
  context: __SerdeContext
): Origins => {
  let contents: any = {
    __type: "Origins",
    Items: undefined,
    Quantity: undefined
  };
  if (output.Items === "") {
    contents.Items = [];
  }
  if (
    output["Items"] !== undefined &&
    output["Items"]["Origin"] !== undefined
  ) {
    contents.Items = deserializeAws_restXmlOriginList(
      __getArrayIfSingleItem(output["Items"]["Origin"]),
      context
    );
  }
  if (output["Quantity"] !== undefined) {
    contents.Quantity = parseInt(output["Quantity"]);
  }
  return contents;
};

const deserializeAws_restXmlOriginSslProtocols = (
  output: any,
  context: __SerdeContext
): OriginSslProtocols => {
  let contents: any = {
    __type: "OriginSslProtocols",
    Items: undefined,
    Quantity: undefined
  };
  if (output.Items === "") {
    contents.Items = [];
  }
  if (
    output["Items"] !== undefined &&
    output["Items"]["SslProtocol"] !== undefined
  ) {
    contents.Items = deserializeAws_restXmlSslProtocolsList(
      __getArrayIfSingleItem(output["Items"]["SslProtocol"]),
      context
    );
  }
  if (output["Quantity"] !== undefined) {
    contents.Quantity = parseInt(output["Quantity"]);
  }
  return contents;
};

const deserializeAws_restXmlPathList = (
  output: any,
  context: __SerdeContext
): string[] => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_restXmlPaths = (
  output: any,
  context: __SerdeContext
): Paths => {
  let contents: any = {
    __type: "Paths",
    Items: undefined,
    Quantity: undefined
  };
  if (output.Items === "") {
    contents.Items = [];
  }
  if (output["Items"] !== undefined && output["Items"]["Path"] !== undefined) {
    contents.Items = deserializeAws_restXmlPathList(
      __getArrayIfSingleItem(output["Items"]["Path"]),
      context
    );
  }
  if (output["Quantity"] !== undefined) {
    contents.Quantity = parseInt(output["Quantity"]);
  }
  return contents;
};

const deserializeAws_restXmlPublicKey = (
  output: any,
  context: __SerdeContext
): PublicKey => {
  let contents: any = {
    __type: "PublicKey",
    CreatedTime: undefined,
    Id: undefined,
    PublicKeyConfig: undefined
  };
  if (output["CreatedTime"] !== undefined) {
    contents.CreatedTime = new Date(output["CreatedTime"]);
  }
  if (output["Id"] !== undefined) {
    contents.Id = output["Id"];
  }
  if (output["PublicKeyConfig"] !== undefined) {
    contents.PublicKeyConfig = deserializeAws_restXmlPublicKeyConfig(
      output["PublicKeyConfig"],
      context
    );
  }
  return contents;
};

const deserializeAws_restXmlPublicKeyConfig = (
  output: any,
  context: __SerdeContext
): PublicKeyConfig => {
  let contents: any = {
    __type: "PublicKeyConfig",
    CallerReference: undefined,
    Comment: undefined,
    EncodedKey: undefined,
    Name: undefined
  };
  if (output["CallerReference"] !== undefined) {
    contents.CallerReference = output["CallerReference"];
  }
  if (output["Comment"] !== undefined) {
    contents.Comment = output["Comment"];
  }
  if (output["EncodedKey"] !== undefined) {
    contents.EncodedKey = output["EncodedKey"];
  }
  if (output["Name"] !== undefined) {
    contents.Name = output["Name"];
  }
  return contents;
};

const deserializeAws_restXmlPublicKeyList = (
  output: any,
  context: __SerdeContext
): PublicKeyList => {
  let contents: any = {
    __type: "PublicKeyList",
    Items: undefined,
    MaxItems: undefined,
    NextMarker: undefined,
    Quantity: undefined
  };
  if (output.Items === "") {
    contents.Items = [];
  }
  if (
    output["Items"] !== undefined &&
    output["Items"]["PublicKeySummary"] !== undefined
  ) {
    contents.Items = deserializeAws_restXmlPublicKeySummaryList(
      __getArrayIfSingleItem(output["Items"]["PublicKeySummary"]),
      context
    );
  }
  if (output["MaxItems"] !== undefined) {
    contents.MaxItems = parseInt(output["MaxItems"]);
  }
  if (output["NextMarker"] !== undefined) {
    contents.NextMarker = output["NextMarker"];
  }
  if (output["Quantity"] !== undefined) {
    contents.Quantity = parseInt(output["Quantity"]);
  }
  return contents;
};

const deserializeAws_restXmlPublicKeySummary = (
  output: any,
  context: __SerdeContext
): PublicKeySummary => {
  let contents: any = {
    __type: "PublicKeySummary",
    Comment: undefined,
    CreatedTime: undefined,
    EncodedKey: undefined,
    Id: undefined,
    Name: undefined
  };
  if (output["Comment"] !== undefined) {
    contents.Comment = output["Comment"];
  }
  if (output["CreatedTime"] !== undefined) {
    contents.CreatedTime = new Date(output["CreatedTime"]);
  }
  if (output["EncodedKey"] !== undefined) {
    contents.EncodedKey = output["EncodedKey"];
  }
  if (output["Id"] !== undefined) {
    contents.Id = output["Id"];
  }
  if (output["Name"] !== undefined) {
    contents.Name = output["Name"];
  }
  return contents;
};

const deserializeAws_restXmlPublicKeySummaryList = (
  output: any,
  context: __SerdeContext
): PublicKeySummary[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_restXmlPublicKeySummary(entry, context)
  );
};

const deserializeAws_restXmlQueryArgProfile = (
  output: any,
  context: __SerdeContext
): QueryArgProfile => {
  let contents: any = {
    __type: "QueryArgProfile",
    ProfileId: undefined,
    QueryArg: undefined
  };
  if (output["ProfileId"] !== undefined) {
    contents.ProfileId = output["ProfileId"];
  }
  if (output["QueryArg"] !== undefined) {
    contents.QueryArg = output["QueryArg"];
  }
  return contents;
};

const deserializeAws_restXmlQueryArgProfileConfig = (
  output: any,
  context: __SerdeContext
): QueryArgProfileConfig => {
  let contents: any = {
    __type: "QueryArgProfileConfig",
    ForwardWhenQueryArgProfileIsUnknown: undefined,
    QueryArgProfiles: undefined
  };
  if (output["ForwardWhenQueryArgProfileIsUnknown"] !== undefined) {
    contents.ForwardWhenQueryArgProfileIsUnknown =
      output["ForwardWhenQueryArgProfileIsUnknown"] == "true";
  }
  if (output["QueryArgProfiles"] !== undefined) {
    contents.QueryArgProfiles = deserializeAws_restXmlQueryArgProfiles(
      output["QueryArgProfiles"],
      context
    );
  }
  return contents;
};

const deserializeAws_restXmlQueryArgProfileList = (
  output: any,
  context: __SerdeContext
): QueryArgProfile[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_restXmlQueryArgProfile(entry, context)
  );
};

const deserializeAws_restXmlQueryArgProfiles = (
  output: any,
  context: __SerdeContext
): QueryArgProfiles => {
  let contents: any = {
    __type: "QueryArgProfiles",
    Items: undefined,
    Quantity: undefined
  };
  if (output.Items === "") {
    contents.Items = [];
  }
  if (
    output["Items"] !== undefined &&
    output["Items"]["QueryArgProfile"] !== undefined
  ) {
    contents.Items = deserializeAws_restXmlQueryArgProfileList(
      __getArrayIfSingleItem(output["Items"]["QueryArgProfile"]),
      context
    );
  }
  if (output["Quantity"] !== undefined) {
    contents.Quantity = parseInt(output["Quantity"]);
  }
  return contents;
};

const deserializeAws_restXmlQueryStringCacheKeys = (
  output: any,
  context: __SerdeContext
): QueryStringCacheKeys => {
  let contents: any = {
    __type: "QueryStringCacheKeys",
    Items: undefined,
    Quantity: undefined
  };
  if (output.Items === "") {
    contents.Items = [];
  }
  if (output["Items"] !== undefined && output["Items"]["Name"] !== undefined) {
    contents.Items = deserializeAws_restXmlQueryStringCacheKeysList(
      __getArrayIfSingleItem(output["Items"]["Name"]),
      context
    );
  }
  if (output["Quantity"] !== undefined) {
    contents.Quantity = parseInt(output["Quantity"]);
  }
  return contents;
};

const deserializeAws_restXmlQueryStringCacheKeysList = (
  output: any,
  context: __SerdeContext
): string[] => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_restXmlRestrictions = (
  output: any,
  context: __SerdeContext
): Restrictions => {
  let contents: any = {
    __type: "Restrictions",
    GeoRestriction: undefined
  };
  if (output["GeoRestriction"] !== undefined) {
    contents.GeoRestriction = deserializeAws_restXmlGeoRestriction(
      output["GeoRestriction"],
      context
    );
  }
  return contents;
};

const deserializeAws_restXmlS3Origin = (
  output: any,
  context: __SerdeContext
): S3Origin => {
  let contents: any = {
    __type: "S3Origin",
    DomainName: undefined,
    OriginAccessIdentity: undefined
  };
  if (output["DomainName"] !== undefined) {
    contents.DomainName = output["DomainName"];
  }
  if (output["OriginAccessIdentity"] !== undefined) {
    contents.OriginAccessIdentity = output["OriginAccessIdentity"];
  }
  return contents;
};

const deserializeAws_restXmlS3OriginConfig = (
  output: any,
  context: __SerdeContext
): S3OriginConfig => {
  let contents: any = {
    __type: "S3OriginConfig",
    OriginAccessIdentity: undefined
  };
  if (output["OriginAccessIdentity"] !== undefined) {
    contents.OriginAccessIdentity = output["OriginAccessIdentity"];
  }
  return contents;
};

const deserializeAws_restXmlSigner = (
  output: any,
  context: __SerdeContext
): Signer => {
  let contents: any = {
    __type: "Signer",
    AwsAccountNumber: undefined,
    KeyPairIds: undefined
  };
  if (output["AwsAccountNumber"] !== undefined) {
    contents.AwsAccountNumber = output["AwsAccountNumber"];
  }
  if (output["KeyPairIds"] !== undefined) {
    contents.KeyPairIds = deserializeAws_restXmlKeyPairIds(
      output["KeyPairIds"],
      context
    );
  }
  return contents;
};

const deserializeAws_restXmlSignerList = (
  output: any,
  context: __SerdeContext
): Signer[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_restXmlSigner(entry, context)
  );
};

const deserializeAws_restXmlSslProtocolsList = (
  output: any,
  context: __SerdeContext
): (SslProtocol | string)[] => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_restXmlStatusCodeList = (
  output: any,
  context: __SerdeContext
): number[] => {
  return (output || []).map((entry: any) => parseInt(entry));
};

const deserializeAws_restXmlStatusCodes = (
  output: any,
  context: __SerdeContext
): StatusCodes => {
  let contents: any = {
    __type: "StatusCodes",
    Items: undefined,
    Quantity: undefined
  };
  if (output.Items === "") {
    contents.Items = [];
  }
  if (
    output["Items"] !== undefined &&
    output["Items"]["StatusCode"] !== undefined
  ) {
    contents.Items = deserializeAws_restXmlStatusCodeList(
      __getArrayIfSingleItem(output["Items"]["StatusCode"]),
      context
    );
  }
  if (output["Quantity"] !== undefined) {
    contents.Quantity = parseInt(output["Quantity"]);
  }
  return contents;
};

const deserializeAws_restXmlStreamingDistribution = (
  output: any,
  context: __SerdeContext
): StreamingDistribution => {
  let contents: any = {
    __type: "StreamingDistribution",
    ARN: undefined,
    ActiveTrustedSigners: undefined,
    DomainName: undefined,
    Id: undefined,
    LastModifiedTime: undefined,
    Status: undefined,
    StreamingDistributionConfig: undefined
  };
  if (output["ARN"] !== undefined) {
    contents.ARN = output["ARN"];
  }
  if (output["ActiveTrustedSigners"] !== undefined) {
    contents.ActiveTrustedSigners = deserializeAws_restXmlActiveTrustedSigners(
      output["ActiveTrustedSigners"],
      context
    );
  }
  if (output["DomainName"] !== undefined) {
    contents.DomainName = output["DomainName"];
  }
  if (output["Id"] !== undefined) {
    contents.Id = output["Id"];
  }
  if (output["LastModifiedTime"] !== undefined) {
    contents.LastModifiedTime = new Date(output["LastModifiedTime"]);
  }
  if (output["Status"] !== undefined) {
    contents.Status = output["Status"];
  }
  if (output["StreamingDistributionConfig"] !== undefined) {
    contents.StreamingDistributionConfig = deserializeAws_restXmlStreamingDistributionConfig(
      output["StreamingDistributionConfig"],
      context
    );
  }
  return contents;
};

const deserializeAws_restXmlStreamingDistributionConfig = (
  output: any,
  context: __SerdeContext
): StreamingDistributionConfig => {
  let contents: any = {
    __type: "StreamingDistributionConfig",
    Aliases: undefined,
    CallerReference: undefined,
    Comment: undefined,
    Enabled: undefined,
    Logging: undefined,
    PriceClass: undefined,
    S3Origin: undefined,
    TrustedSigners: undefined
  };
  if (output["Aliases"] !== undefined) {
    contents.Aliases = deserializeAws_restXmlAliases(
      output["Aliases"],
      context
    );
  }
  if (output["CallerReference"] !== undefined) {
    contents.CallerReference = output["CallerReference"];
  }
  if (output["Comment"] !== undefined) {
    contents.Comment = output["Comment"];
  }
  if (output["Enabled"] !== undefined) {
    contents.Enabled = output["Enabled"] == "true";
  }
  if (output["Logging"] !== undefined) {
    contents.Logging = deserializeAws_restXmlStreamingLoggingConfig(
      output["Logging"],
      context
    );
  }
  if (output["PriceClass"] !== undefined) {
    contents.PriceClass = output["PriceClass"];
  }
  if (output["S3Origin"] !== undefined) {
    contents.S3Origin = deserializeAws_restXmlS3Origin(
      output["S3Origin"],
      context
    );
  }
  if (output["TrustedSigners"] !== undefined) {
    contents.TrustedSigners = deserializeAws_restXmlTrustedSigners(
      output["TrustedSigners"],
      context
    );
  }
  return contents;
};

const deserializeAws_restXmlStreamingDistributionList = (
  output: any,
  context: __SerdeContext
): StreamingDistributionList => {
  let contents: any = {
    __type: "StreamingDistributionList",
    IsTruncated: undefined,
    Items: undefined,
    Marker: undefined,
    MaxItems: undefined,
    NextMarker: undefined,
    Quantity: undefined
  };
  if (output["IsTruncated"] !== undefined) {
    contents.IsTruncated = output["IsTruncated"] == "true";
  }
  if (output.Items === "") {
    contents.Items = [];
  }
  if (
    output["Items"] !== undefined &&
    output["Items"]["StreamingDistributionSummary"] !== undefined
  ) {
    contents.Items = deserializeAws_restXmlStreamingDistributionSummaryList(
      __getArrayIfSingleItem(output["Items"]["StreamingDistributionSummary"]),
      context
    );
  }
  if (output["Marker"] !== undefined) {
    contents.Marker = output["Marker"];
  }
  if (output["MaxItems"] !== undefined) {
    contents.MaxItems = parseInt(output["MaxItems"]);
  }
  if (output["NextMarker"] !== undefined) {
    contents.NextMarker = output["NextMarker"];
  }
  if (output["Quantity"] !== undefined) {
    contents.Quantity = parseInt(output["Quantity"]);
  }
  return contents;
};

const deserializeAws_restXmlStreamingDistributionSummary = (
  output: any,
  context: __SerdeContext
): StreamingDistributionSummary => {
  let contents: any = {
    __type: "StreamingDistributionSummary",
    ARN: undefined,
    Aliases: undefined,
    Comment: undefined,
    DomainName: undefined,
    Enabled: undefined,
    Id: undefined,
    LastModifiedTime: undefined,
    PriceClass: undefined,
    S3Origin: undefined,
    Status: undefined,
    TrustedSigners: undefined
  };
  if (output["ARN"] !== undefined) {
    contents.ARN = output["ARN"];
  }
  if (output["Aliases"] !== undefined) {
    contents.Aliases = deserializeAws_restXmlAliases(
      output["Aliases"],
      context
    );
  }
  if (output["Comment"] !== undefined) {
    contents.Comment = output["Comment"];
  }
  if (output["DomainName"] !== undefined) {
    contents.DomainName = output["DomainName"];
  }
  if (output["Enabled"] !== undefined) {
    contents.Enabled = output["Enabled"] == "true";
  }
  if (output["Id"] !== undefined) {
    contents.Id = output["Id"];
  }
  if (output["LastModifiedTime"] !== undefined) {
    contents.LastModifiedTime = new Date(output["LastModifiedTime"]);
  }
  if (output["PriceClass"] !== undefined) {
    contents.PriceClass = output["PriceClass"];
  }
  if (output["S3Origin"] !== undefined) {
    contents.S3Origin = deserializeAws_restXmlS3Origin(
      output["S3Origin"],
      context
    );
  }
  if (output["Status"] !== undefined) {
    contents.Status = output["Status"];
  }
  if (output["TrustedSigners"] !== undefined) {
    contents.TrustedSigners = deserializeAws_restXmlTrustedSigners(
      output["TrustedSigners"],
      context
    );
  }
  return contents;
};

const deserializeAws_restXmlStreamingDistributionSummaryList = (
  output: any,
  context: __SerdeContext
): StreamingDistributionSummary[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_restXmlStreamingDistributionSummary(entry, context)
  );
};

const deserializeAws_restXmlStreamingLoggingConfig = (
  output: any,
  context: __SerdeContext
): StreamingLoggingConfig => {
  let contents: any = {
    __type: "StreamingLoggingConfig",
    Bucket: undefined,
    Enabled: undefined,
    Prefix: undefined
  };
  if (output["Bucket"] !== undefined) {
    contents.Bucket = output["Bucket"];
  }
  if (output["Enabled"] !== undefined) {
    contents.Enabled = output["Enabled"] == "true";
  }
  if (output["Prefix"] !== undefined) {
    contents.Prefix = output["Prefix"];
  }
  return contents;
};

const deserializeAws_restXmlTag = (
  output: any,
  context: __SerdeContext
): Tag => {
  let contents: any = {
    __type: "Tag",
    Key: undefined,
    Value: undefined
  };
  if (output["Key"] !== undefined) {
    contents.Key = output["Key"];
  }
  if (output["Value"] !== undefined) {
    contents.Value = output["Value"];
  }
  return contents;
};

const deserializeAws_restXmlTagList = (
  output: any,
  context: __SerdeContext
): Tag[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_restXmlTag(entry, context)
  );
};

const deserializeAws_restXmlTags = (
  output: any,
  context: __SerdeContext
): Tags => {
  let contents: any = {
    __type: "Tags",
    Items: undefined
  };
  if (output.Items === "") {
    contents.Items = [];
  }
  if (output["Items"] !== undefined && output["Items"]["Tag"] !== undefined) {
    contents.Items = deserializeAws_restXmlTagList(
      __getArrayIfSingleItem(output["Items"]["Tag"]),
      context
    );
  }
  return contents;
};

const deserializeAws_restXmlTrustedSigners = (
  output: any,
  context: __SerdeContext
): TrustedSigners => {
  let contents: any = {
    __type: "TrustedSigners",
    Enabled: undefined,
    Items: undefined,
    Quantity: undefined
  };
  if (output["Enabled"] !== undefined) {
    contents.Enabled = output["Enabled"] == "true";
  }
  if (output.Items === "") {
    contents.Items = [];
  }
  if (
    output["Items"] !== undefined &&
    output["Items"]["AwsAccountNumber"] !== undefined
  ) {
    contents.Items = deserializeAws_restXmlAwsAccountNumberList(
      __getArrayIfSingleItem(output["Items"]["AwsAccountNumber"]),
      context
    );
  }
  if (output["Quantity"] !== undefined) {
    contents.Quantity = parseInt(output["Quantity"]);
  }
  return contents;
};

const deserializeAws_restXmlViewerCertificate = (
  output: any,
  context: __SerdeContext
): ViewerCertificate => {
  let contents: any = {
    __type: "ViewerCertificate",
    ACMCertificateArn: undefined,
    Certificate: undefined,
    CertificateSource: undefined,
    CloudFrontDefaultCertificate: undefined,
    IAMCertificateId: undefined,
    MinimumProtocolVersion: undefined,
    SSLSupportMethod: undefined
  };
  if (output["ACMCertificateArn"] !== undefined) {
    contents.ACMCertificateArn = output["ACMCertificateArn"];
  }
  if (output["Certificate"] !== undefined) {
    contents.Certificate = output["Certificate"];
  }
  if (output["CertificateSource"] !== undefined) {
    contents.CertificateSource = output["CertificateSource"];
  }
  if (output["CloudFrontDefaultCertificate"] !== undefined) {
    contents.CloudFrontDefaultCertificate =
      output["CloudFrontDefaultCertificate"] == "true";
  }
  if (output["IAMCertificateId"] !== undefined) {
    contents.IAMCertificateId = output["IAMCertificateId"];
  }
  if (output["MinimumProtocolVersion"] !== undefined) {
    contents.MinimumProtocolVersion = output["MinimumProtocolVersion"];
  }
  if (output["SSLSupportMethod"] !== undefined) {
    contents.SSLSupportMethod = output["SSLSupportMethod"];
  }
  return contents;
};

const deserializeMetadata = (output: __HttpResponse): __ResponseMetadata => ({
  httpStatusCode: output.statusCode,
  httpHeaders: output.headers,
  requestId: output.headers["x-amzn-requestid"]
});

// Collect low-level response body stream to Uint8Array.
const collectBody = (
  streamBody: any = new Uint8Array(),
  context: __SerdeContext
): Promise<Uint8Array> => {
  if (streamBody instanceof Uint8Array) {
    return Promise.resolve(streamBody);
  }
  return (
    context.streamCollector(streamBody) || Promise.resolve(new Uint8Array())
  );
};

// Encode Uint8Array data into string with utf-8.
const collectBodyString = (
  streamBody: any,
  context: __SerdeContext
): Promise<string> =>
  collectBody(streamBody, context).then(body => context.utf8Encoder(body));

const isSerializableHeaderValue = (value: any): boolean =>
  value !== undefined &&
  value !== "" &&
  (!Object.getOwnPropertyNames(value).includes("length") ||
    value.length != 0) &&
  (!Object.getOwnPropertyNames(value).includes("size") || value.size != 0);

const decodeEscapedXML = (str: string) =>
  str
    .replace(/&amp;/g, "&")
    .replace(/&apos;/g, "'")
    .replace(/&quot;/g, '"')
    .replace(/&gt;/g, ">")
    .replace(/&lt;/g, "<");

const parseBody = (streamBody: any, context: __SerdeContext): any =>
  collectBodyString(streamBody, context).then(encoded => {
    if (encoded.length) {
      const parsedObj = xmlParse(encoded, {
        attributeNamePrefix: "",
        ignoreAttributes: false,
        parseNodeValue: false,
        tagValueProcessor: (val, tagName) => decodeEscapedXML(val)
      });
      const textNodeName = "#text";
      const key = Object.keys(parsedObj)[0];
      const parsedObjToReturn = parsedObj[key];
      if (parsedObjToReturn[textNodeName]) {
        parsedObjToReturn[key] = parsedObjToReturn[textNodeName];
        delete parsedObjToReturn[textNodeName];
      }
      return __getValueFromTextNode(parsedObjToReturn);
    }
    return {};
  });

const loadRestXmlErrorCode = (output: __HttpResponse, data: any): string => {
  if (data.Error.Code !== undefined) {
    return data.Error.Code;
  }
  if (output.statusCode == 404) {
    return "NotFound";
  }
  return "";
};
