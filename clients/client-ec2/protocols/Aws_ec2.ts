import {
  AcceptReservedInstancesExchangeQuoteCommandInput,
  AcceptReservedInstancesExchangeQuoteCommandOutput
} from "../commands/AcceptReservedInstancesExchangeQuoteCommand";
import {
  AcceptTransitGatewayPeeringAttachmentCommandInput,
  AcceptTransitGatewayPeeringAttachmentCommandOutput
} from "../commands/AcceptTransitGatewayPeeringAttachmentCommand";
import {
  AcceptTransitGatewayVpcAttachmentCommandInput,
  AcceptTransitGatewayVpcAttachmentCommandOutput
} from "../commands/AcceptTransitGatewayVpcAttachmentCommand";
import {
  AcceptVpcEndpointConnectionsCommandInput,
  AcceptVpcEndpointConnectionsCommandOutput
} from "../commands/AcceptVpcEndpointConnectionsCommand";
import {
  AcceptVpcPeeringConnectionCommandInput,
  AcceptVpcPeeringConnectionCommandOutput
} from "../commands/AcceptVpcPeeringConnectionCommand";
import {
  AdvertiseByoipCidrCommandInput,
  AdvertiseByoipCidrCommandOutput
} from "../commands/AdvertiseByoipCidrCommand";
import {
  AllocateAddressCommandInput,
  AllocateAddressCommandOutput
} from "../commands/AllocateAddressCommand";
import {
  AllocateHostsCommandInput,
  AllocateHostsCommandOutput
} from "../commands/AllocateHostsCommand";
import {
  ApplySecurityGroupsToClientVpnTargetNetworkCommandInput,
  ApplySecurityGroupsToClientVpnTargetNetworkCommandOutput
} from "../commands/ApplySecurityGroupsToClientVpnTargetNetworkCommand";
import {
  AssignIpv6AddressesCommandInput,
  AssignIpv6AddressesCommandOutput
} from "../commands/AssignIpv6AddressesCommand";
import {
  AssignPrivateIpAddressesCommandInput,
  AssignPrivateIpAddressesCommandOutput
} from "../commands/AssignPrivateIpAddressesCommand";
import {
  AssociateAddressCommandInput,
  AssociateAddressCommandOutput
} from "../commands/AssociateAddressCommand";
import {
  AssociateClientVpnTargetNetworkCommandInput,
  AssociateClientVpnTargetNetworkCommandOutput
} from "../commands/AssociateClientVpnTargetNetworkCommand";
import {
  AssociateDhcpOptionsCommandInput,
  AssociateDhcpOptionsCommandOutput
} from "../commands/AssociateDhcpOptionsCommand";
import {
  AssociateIamInstanceProfileCommandInput,
  AssociateIamInstanceProfileCommandOutput
} from "../commands/AssociateIamInstanceProfileCommand";
import {
  AssociateRouteTableCommandInput,
  AssociateRouteTableCommandOutput
} from "../commands/AssociateRouteTableCommand";
import {
  AssociateSubnetCidrBlockCommandInput,
  AssociateSubnetCidrBlockCommandOutput
} from "../commands/AssociateSubnetCidrBlockCommand";
import {
  AssociateTransitGatewayMulticastDomainCommandInput,
  AssociateTransitGatewayMulticastDomainCommandOutput
} from "../commands/AssociateTransitGatewayMulticastDomainCommand";
import {
  AssociateTransitGatewayRouteTableCommandInput,
  AssociateTransitGatewayRouteTableCommandOutput
} from "../commands/AssociateTransitGatewayRouteTableCommand";
import {
  AssociateVpcCidrBlockCommandInput,
  AssociateVpcCidrBlockCommandOutput
} from "../commands/AssociateVpcCidrBlockCommand";
import {
  AttachClassicLinkVpcCommandInput,
  AttachClassicLinkVpcCommandOutput
} from "../commands/AttachClassicLinkVpcCommand";
import {
  AttachInternetGatewayCommandInput,
  AttachInternetGatewayCommandOutput
} from "../commands/AttachInternetGatewayCommand";
import {
  AttachNetworkInterfaceCommandInput,
  AttachNetworkInterfaceCommandOutput
} from "../commands/AttachNetworkInterfaceCommand";
import {
  AttachVolumeCommandInput,
  AttachVolumeCommandOutput
} from "../commands/AttachVolumeCommand";
import {
  AttachVpnGatewayCommandInput,
  AttachVpnGatewayCommandOutput
} from "../commands/AttachVpnGatewayCommand";
import {
  AuthorizeClientVpnIngressCommandInput,
  AuthorizeClientVpnIngressCommandOutput
} from "../commands/AuthorizeClientVpnIngressCommand";
import {
  AuthorizeSecurityGroupEgressCommandInput,
  AuthorizeSecurityGroupEgressCommandOutput
} from "../commands/AuthorizeSecurityGroupEgressCommand";
import {
  AuthorizeSecurityGroupIngressCommandInput,
  AuthorizeSecurityGroupIngressCommandOutput
} from "../commands/AuthorizeSecurityGroupIngressCommand";
import {
  BundleInstanceCommandInput,
  BundleInstanceCommandOutput
} from "../commands/BundleInstanceCommand";
import {
  CancelBundleTaskCommandInput,
  CancelBundleTaskCommandOutput
} from "../commands/CancelBundleTaskCommand";
import {
  CancelCapacityReservationCommandInput,
  CancelCapacityReservationCommandOutput
} from "../commands/CancelCapacityReservationCommand";
import {
  CancelConversionTaskCommandInput,
  CancelConversionTaskCommandOutput
} from "../commands/CancelConversionTaskCommand";
import {
  CancelExportTaskCommandInput,
  CancelExportTaskCommandOutput
} from "../commands/CancelExportTaskCommand";
import {
  CancelImportTaskCommandInput,
  CancelImportTaskCommandOutput
} from "../commands/CancelImportTaskCommand";
import {
  CancelReservedInstancesListingCommandInput,
  CancelReservedInstancesListingCommandOutput
} from "../commands/CancelReservedInstancesListingCommand";
import {
  CancelSpotFleetRequestsCommandInput,
  CancelSpotFleetRequestsCommandOutput
} from "../commands/CancelSpotFleetRequestsCommand";
import {
  CancelSpotInstanceRequestsCommandInput,
  CancelSpotInstanceRequestsCommandOutput
} from "../commands/CancelSpotInstanceRequestsCommand";
import {
  ConfirmProductInstanceCommandInput,
  ConfirmProductInstanceCommandOutput
} from "../commands/ConfirmProductInstanceCommand";
import {
  CopyFpgaImageCommandInput,
  CopyFpgaImageCommandOutput
} from "../commands/CopyFpgaImageCommand";
import {
  CopyImageCommandInput,
  CopyImageCommandOutput
} from "../commands/CopyImageCommand";
import {
  CopySnapshotCommandInput,
  CopySnapshotCommandOutput
} from "../commands/CopySnapshotCommand";
import {
  CreateCapacityReservationCommandInput,
  CreateCapacityReservationCommandOutput
} from "../commands/CreateCapacityReservationCommand";
import {
  CreateClientVpnEndpointCommandInput,
  CreateClientVpnEndpointCommandOutput
} from "../commands/CreateClientVpnEndpointCommand";
import {
  CreateClientVpnRouteCommandInput,
  CreateClientVpnRouteCommandOutput
} from "../commands/CreateClientVpnRouteCommand";
import {
  CreateCustomerGatewayCommandInput,
  CreateCustomerGatewayCommandOutput
} from "../commands/CreateCustomerGatewayCommand";
import {
  CreateDefaultSubnetCommandInput,
  CreateDefaultSubnetCommandOutput
} from "../commands/CreateDefaultSubnetCommand";
import {
  CreateDefaultVpcCommandInput,
  CreateDefaultVpcCommandOutput
} from "../commands/CreateDefaultVpcCommand";
import {
  CreateDhcpOptionsCommandInput,
  CreateDhcpOptionsCommandOutput
} from "../commands/CreateDhcpOptionsCommand";
import {
  CreateEgressOnlyInternetGatewayCommandInput,
  CreateEgressOnlyInternetGatewayCommandOutput
} from "../commands/CreateEgressOnlyInternetGatewayCommand";
import {
  CreateFleetCommandInput,
  CreateFleetCommandOutput
} from "../commands/CreateFleetCommand";
import {
  CreateFlowLogsCommandInput,
  CreateFlowLogsCommandOutput
} from "../commands/CreateFlowLogsCommand";
import {
  CreateFpgaImageCommandInput,
  CreateFpgaImageCommandOutput
} from "../commands/CreateFpgaImageCommand";
import {
  CreateImageCommandInput,
  CreateImageCommandOutput
} from "../commands/CreateImageCommand";
import {
  CreateInstanceExportTaskCommandInput,
  CreateInstanceExportTaskCommandOutput
} from "../commands/CreateInstanceExportTaskCommand";
import {
  CreateInternetGatewayCommandInput,
  CreateInternetGatewayCommandOutput
} from "../commands/CreateInternetGatewayCommand";
import {
  CreateKeyPairCommandInput,
  CreateKeyPairCommandOutput
} from "../commands/CreateKeyPairCommand";
import {
  CreateLaunchTemplateCommandInput,
  CreateLaunchTemplateCommandOutput
} from "../commands/CreateLaunchTemplateCommand";
import {
  CreateLaunchTemplateVersionCommandInput,
  CreateLaunchTemplateVersionCommandOutput
} from "../commands/CreateLaunchTemplateVersionCommand";
import {
  CreateLocalGatewayRouteCommandInput,
  CreateLocalGatewayRouteCommandOutput
} from "../commands/CreateLocalGatewayRouteCommand";
import {
  CreateLocalGatewayRouteTableVpcAssociationCommandInput,
  CreateLocalGatewayRouteTableVpcAssociationCommandOutput
} from "../commands/CreateLocalGatewayRouteTableVpcAssociationCommand";
import {
  CreateNatGatewayCommandInput,
  CreateNatGatewayCommandOutput
} from "../commands/CreateNatGatewayCommand";
import {
  CreateNetworkAclCommandInput,
  CreateNetworkAclCommandOutput
} from "../commands/CreateNetworkAclCommand";
import {
  CreateNetworkAclEntryCommandInput,
  CreateNetworkAclEntryCommandOutput
} from "../commands/CreateNetworkAclEntryCommand";
import {
  CreateNetworkInterfaceCommandInput,
  CreateNetworkInterfaceCommandOutput
} from "../commands/CreateNetworkInterfaceCommand";
import {
  CreateNetworkInterfacePermissionCommandInput,
  CreateNetworkInterfacePermissionCommandOutput
} from "../commands/CreateNetworkInterfacePermissionCommand";
import {
  CreatePlacementGroupCommandInput,
  CreatePlacementGroupCommandOutput
} from "../commands/CreatePlacementGroupCommand";
import {
  CreateReservedInstancesListingCommandInput,
  CreateReservedInstancesListingCommandOutput
} from "../commands/CreateReservedInstancesListingCommand";
import {
  CreateRouteCommandInput,
  CreateRouteCommandOutput
} from "../commands/CreateRouteCommand";
import {
  CreateRouteTableCommandInput,
  CreateRouteTableCommandOutput
} from "../commands/CreateRouteTableCommand";
import {
  CreateSecurityGroupCommandInput,
  CreateSecurityGroupCommandOutput
} from "../commands/CreateSecurityGroupCommand";
import {
  CreateSnapshotCommandInput,
  CreateSnapshotCommandOutput
} from "../commands/CreateSnapshotCommand";
import {
  CreateSnapshotsCommandInput,
  CreateSnapshotsCommandOutput
} from "../commands/CreateSnapshotsCommand";
import {
  CreateSpotDatafeedSubscriptionCommandInput,
  CreateSpotDatafeedSubscriptionCommandOutput
} from "../commands/CreateSpotDatafeedSubscriptionCommand";
import {
  CreateSubnetCommandInput,
  CreateSubnetCommandOutput
} from "../commands/CreateSubnetCommand";
import {
  CreateTagsCommandInput,
  CreateTagsCommandOutput
} from "../commands/CreateTagsCommand";
import {
  CreateTrafficMirrorFilterCommandInput,
  CreateTrafficMirrorFilterCommandOutput
} from "../commands/CreateTrafficMirrorFilterCommand";
import {
  CreateTrafficMirrorFilterRuleCommandInput,
  CreateTrafficMirrorFilterRuleCommandOutput
} from "../commands/CreateTrafficMirrorFilterRuleCommand";
import {
  CreateTrafficMirrorSessionCommandInput,
  CreateTrafficMirrorSessionCommandOutput
} from "../commands/CreateTrafficMirrorSessionCommand";
import {
  CreateTrafficMirrorTargetCommandInput,
  CreateTrafficMirrorTargetCommandOutput
} from "../commands/CreateTrafficMirrorTargetCommand";
import {
  CreateTransitGatewayCommandInput,
  CreateTransitGatewayCommandOutput
} from "../commands/CreateTransitGatewayCommand";
import {
  CreateTransitGatewayMulticastDomainCommandInput,
  CreateTransitGatewayMulticastDomainCommandOutput
} from "../commands/CreateTransitGatewayMulticastDomainCommand";
import {
  CreateTransitGatewayPeeringAttachmentCommandInput,
  CreateTransitGatewayPeeringAttachmentCommandOutput
} from "../commands/CreateTransitGatewayPeeringAttachmentCommand";
import {
  CreateTransitGatewayRouteCommandInput,
  CreateTransitGatewayRouteCommandOutput
} from "../commands/CreateTransitGatewayRouteCommand";
import {
  CreateTransitGatewayRouteTableCommandInput,
  CreateTransitGatewayRouteTableCommandOutput
} from "../commands/CreateTransitGatewayRouteTableCommand";
import {
  CreateTransitGatewayVpcAttachmentCommandInput,
  CreateTransitGatewayVpcAttachmentCommandOutput
} from "../commands/CreateTransitGatewayVpcAttachmentCommand";
import {
  CreateVolumeCommandInput,
  CreateVolumeCommandOutput
} from "../commands/CreateVolumeCommand";
import {
  CreateVpcCommandInput,
  CreateVpcCommandOutput
} from "../commands/CreateVpcCommand";
import {
  CreateVpcEndpointCommandInput,
  CreateVpcEndpointCommandOutput
} from "../commands/CreateVpcEndpointCommand";
import {
  CreateVpcEndpointConnectionNotificationCommandInput,
  CreateVpcEndpointConnectionNotificationCommandOutput
} from "../commands/CreateVpcEndpointConnectionNotificationCommand";
import {
  CreateVpcEndpointServiceConfigurationCommandInput,
  CreateVpcEndpointServiceConfigurationCommandOutput
} from "../commands/CreateVpcEndpointServiceConfigurationCommand";
import {
  CreateVpcPeeringConnectionCommandInput,
  CreateVpcPeeringConnectionCommandOutput
} from "../commands/CreateVpcPeeringConnectionCommand";
import {
  CreateVpnConnectionCommandInput,
  CreateVpnConnectionCommandOutput
} from "../commands/CreateVpnConnectionCommand";
import {
  CreateVpnConnectionRouteCommandInput,
  CreateVpnConnectionRouteCommandOutput
} from "../commands/CreateVpnConnectionRouteCommand";
import {
  CreateVpnGatewayCommandInput,
  CreateVpnGatewayCommandOutput
} from "../commands/CreateVpnGatewayCommand";
import {
  DeleteClientVpnEndpointCommandInput,
  DeleteClientVpnEndpointCommandOutput
} from "../commands/DeleteClientVpnEndpointCommand";
import {
  DeleteClientVpnRouteCommandInput,
  DeleteClientVpnRouteCommandOutput
} from "../commands/DeleteClientVpnRouteCommand";
import {
  DeleteCustomerGatewayCommandInput,
  DeleteCustomerGatewayCommandOutput
} from "../commands/DeleteCustomerGatewayCommand";
import {
  DeleteDhcpOptionsCommandInput,
  DeleteDhcpOptionsCommandOutput
} from "../commands/DeleteDhcpOptionsCommand";
import {
  DeleteEgressOnlyInternetGatewayCommandInput,
  DeleteEgressOnlyInternetGatewayCommandOutput
} from "../commands/DeleteEgressOnlyInternetGatewayCommand";
import {
  DeleteFleetsCommandInput,
  DeleteFleetsCommandOutput
} from "../commands/DeleteFleetsCommand";
import {
  DeleteFlowLogsCommandInput,
  DeleteFlowLogsCommandOutput
} from "../commands/DeleteFlowLogsCommand";
import {
  DeleteFpgaImageCommandInput,
  DeleteFpgaImageCommandOutput
} from "../commands/DeleteFpgaImageCommand";
import {
  DeleteInternetGatewayCommandInput,
  DeleteInternetGatewayCommandOutput
} from "../commands/DeleteInternetGatewayCommand";
import {
  DeleteKeyPairCommandInput,
  DeleteKeyPairCommandOutput
} from "../commands/DeleteKeyPairCommand";
import {
  DeleteLaunchTemplateCommandInput,
  DeleteLaunchTemplateCommandOutput
} from "../commands/DeleteLaunchTemplateCommand";
import {
  DeleteLaunchTemplateVersionsCommandInput,
  DeleteLaunchTemplateVersionsCommandOutput
} from "../commands/DeleteLaunchTemplateVersionsCommand";
import {
  DeleteLocalGatewayRouteCommandInput,
  DeleteLocalGatewayRouteCommandOutput
} from "../commands/DeleteLocalGatewayRouteCommand";
import {
  DeleteLocalGatewayRouteTableVpcAssociationCommandInput,
  DeleteLocalGatewayRouteTableVpcAssociationCommandOutput
} from "../commands/DeleteLocalGatewayRouteTableVpcAssociationCommand";
import {
  DeleteNatGatewayCommandInput,
  DeleteNatGatewayCommandOutput
} from "../commands/DeleteNatGatewayCommand";
import {
  DeleteNetworkAclCommandInput,
  DeleteNetworkAclCommandOutput
} from "../commands/DeleteNetworkAclCommand";
import {
  DeleteNetworkAclEntryCommandInput,
  DeleteNetworkAclEntryCommandOutput
} from "../commands/DeleteNetworkAclEntryCommand";
import {
  DeleteNetworkInterfaceCommandInput,
  DeleteNetworkInterfaceCommandOutput
} from "../commands/DeleteNetworkInterfaceCommand";
import {
  DeleteNetworkInterfacePermissionCommandInput,
  DeleteNetworkInterfacePermissionCommandOutput
} from "../commands/DeleteNetworkInterfacePermissionCommand";
import {
  DeletePlacementGroupCommandInput,
  DeletePlacementGroupCommandOutput
} from "../commands/DeletePlacementGroupCommand";
import {
  DeleteQueuedReservedInstancesCommandInput,
  DeleteQueuedReservedInstancesCommandOutput
} from "../commands/DeleteQueuedReservedInstancesCommand";
import {
  DeleteRouteCommandInput,
  DeleteRouteCommandOutput
} from "../commands/DeleteRouteCommand";
import {
  DeleteRouteTableCommandInput,
  DeleteRouteTableCommandOutput
} from "../commands/DeleteRouteTableCommand";
import {
  DeleteSecurityGroupCommandInput,
  DeleteSecurityGroupCommandOutput
} from "../commands/DeleteSecurityGroupCommand";
import {
  DeleteSnapshotCommandInput,
  DeleteSnapshotCommandOutput
} from "../commands/DeleteSnapshotCommand";
import {
  DeleteSpotDatafeedSubscriptionCommandInput,
  DeleteSpotDatafeedSubscriptionCommandOutput
} from "../commands/DeleteSpotDatafeedSubscriptionCommand";
import {
  DeleteSubnetCommandInput,
  DeleteSubnetCommandOutput
} from "../commands/DeleteSubnetCommand";
import {
  DeleteTagsCommandInput,
  DeleteTagsCommandOutput
} from "../commands/DeleteTagsCommand";
import {
  DeleteTrafficMirrorFilterCommandInput,
  DeleteTrafficMirrorFilterCommandOutput
} from "../commands/DeleteTrafficMirrorFilterCommand";
import {
  DeleteTrafficMirrorFilterRuleCommandInput,
  DeleteTrafficMirrorFilterRuleCommandOutput
} from "../commands/DeleteTrafficMirrorFilterRuleCommand";
import {
  DeleteTrafficMirrorSessionCommandInput,
  DeleteTrafficMirrorSessionCommandOutput
} from "../commands/DeleteTrafficMirrorSessionCommand";
import {
  DeleteTrafficMirrorTargetCommandInput,
  DeleteTrafficMirrorTargetCommandOutput
} from "../commands/DeleteTrafficMirrorTargetCommand";
import {
  DeleteTransitGatewayCommandInput,
  DeleteTransitGatewayCommandOutput
} from "../commands/DeleteTransitGatewayCommand";
import {
  DeleteTransitGatewayMulticastDomainCommandInput,
  DeleteTransitGatewayMulticastDomainCommandOutput
} from "../commands/DeleteTransitGatewayMulticastDomainCommand";
import {
  DeleteTransitGatewayPeeringAttachmentCommandInput,
  DeleteTransitGatewayPeeringAttachmentCommandOutput
} from "../commands/DeleteTransitGatewayPeeringAttachmentCommand";
import {
  DeleteTransitGatewayRouteCommandInput,
  DeleteTransitGatewayRouteCommandOutput
} from "../commands/DeleteTransitGatewayRouteCommand";
import {
  DeleteTransitGatewayRouteTableCommandInput,
  DeleteTransitGatewayRouteTableCommandOutput
} from "../commands/DeleteTransitGatewayRouteTableCommand";
import {
  DeleteTransitGatewayVpcAttachmentCommandInput,
  DeleteTransitGatewayVpcAttachmentCommandOutput
} from "../commands/DeleteTransitGatewayVpcAttachmentCommand";
import {
  DeleteVolumeCommandInput,
  DeleteVolumeCommandOutput
} from "../commands/DeleteVolumeCommand";
import {
  DeleteVpcCommandInput,
  DeleteVpcCommandOutput
} from "../commands/DeleteVpcCommand";
import {
  DeleteVpcEndpointConnectionNotificationsCommandInput,
  DeleteVpcEndpointConnectionNotificationsCommandOutput
} from "../commands/DeleteVpcEndpointConnectionNotificationsCommand";
import {
  DeleteVpcEndpointServiceConfigurationsCommandInput,
  DeleteVpcEndpointServiceConfigurationsCommandOutput
} from "../commands/DeleteVpcEndpointServiceConfigurationsCommand";
import {
  DeleteVpcEndpointsCommandInput,
  DeleteVpcEndpointsCommandOutput
} from "../commands/DeleteVpcEndpointsCommand";
import {
  DeleteVpcPeeringConnectionCommandInput,
  DeleteVpcPeeringConnectionCommandOutput
} from "../commands/DeleteVpcPeeringConnectionCommand";
import {
  DeleteVpnConnectionCommandInput,
  DeleteVpnConnectionCommandOutput
} from "../commands/DeleteVpnConnectionCommand";
import {
  DeleteVpnConnectionRouteCommandInput,
  DeleteVpnConnectionRouteCommandOutput
} from "../commands/DeleteVpnConnectionRouteCommand";
import {
  DeleteVpnGatewayCommandInput,
  DeleteVpnGatewayCommandOutput
} from "../commands/DeleteVpnGatewayCommand";
import {
  DeprovisionByoipCidrCommandInput,
  DeprovisionByoipCidrCommandOutput
} from "../commands/DeprovisionByoipCidrCommand";
import {
  DeregisterImageCommandInput,
  DeregisterImageCommandOutput
} from "../commands/DeregisterImageCommand";
import {
  DeregisterTransitGatewayMulticastGroupMembersCommandInput,
  DeregisterTransitGatewayMulticastGroupMembersCommandOutput
} from "../commands/DeregisterTransitGatewayMulticastGroupMembersCommand";
import {
  DeregisterTransitGatewayMulticastGroupSourcesCommandInput,
  DeregisterTransitGatewayMulticastGroupSourcesCommandOutput
} from "../commands/DeregisterTransitGatewayMulticastGroupSourcesCommand";
import {
  DescribeAccountAttributesCommandInput,
  DescribeAccountAttributesCommandOutput
} from "../commands/DescribeAccountAttributesCommand";
import {
  DescribeAddressesCommandInput,
  DescribeAddressesCommandOutput
} from "../commands/DescribeAddressesCommand";
import {
  DescribeAggregateIdFormatCommandInput,
  DescribeAggregateIdFormatCommandOutput
} from "../commands/DescribeAggregateIdFormatCommand";
import {
  DescribeAvailabilityZonesCommandInput,
  DescribeAvailabilityZonesCommandOutput
} from "../commands/DescribeAvailabilityZonesCommand";
import {
  DescribeBundleTasksCommandInput,
  DescribeBundleTasksCommandOutput
} from "../commands/DescribeBundleTasksCommand";
import {
  DescribeByoipCidrsCommandInput,
  DescribeByoipCidrsCommandOutput
} from "../commands/DescribeByoipCidrsCommand";
import {
  DescribeCapacityReservationsCommandInput,
  DescribeCapacityReservationsCommandOutput
} from "../commands/DescribeCapacityReservationsCommand";
import {
  DescribeClassicLinkInstancesCommandInput,
  DescribeClassicLinkInstancesCommandOutput
} from "../commands/DescribeClassicLinkInstancesCommand";
import {
  DescribeClientVpnAuthorizationRulesCommandInput,
  DescribeClientVpnAuthorizationRulesCommandOutput
} from "../commands/DescribeClientVpnAuthorizationRulesCommand";
import {
  DescribeClientVpnConnectionsCommandInput,
  DescribeClientVpnConnectionsCommandOutput
} from "../commands/DescribeClientVpnConnectionsCommand";
import {
  DescribeClientVpnEndpointsCommandInput,
  DescribeClientVpnEndpointsCommandOutput
} from "../commands/DescribeClientVpnEndpointsCommand";
import {
  DescribeClientVpnRoutesCommandInput,
  DescribeClientVpnRoutesCommandOutput
} from "../commands/DescribeClientVpnRoutesCommand";
import {
  DescribeClientVpnTargetNetworksCommandInput,
  DescribeClientVpnTargetNetworksCommandOutput
} from "../commands/DescribeClientVpnTargetNetworksCommand";
import {
  DescribeCoipPoolsCommandInput,
  DescribeCoipPoolsCommandOutput
} from "../commands/DescribeCoipPoolsCommand";
import {
  DescribeConversionTasksCommandInput,
  DescribeConversionTasksCommandOutput
} from "../commands/DescribeConversionTasksCommand";
import {
  DescribeCustomerGatewaysCommandInput,
  DescribeCustomerGatewaysCommandOutput
} from "../commands/DescribeCustomerGatewaysCommand";
import {
  DescribeDhcpOptionsCommandInput,
  DescribeDhcpOptionsCommandOutput
} from "../commands/DescribeDhcpOptionsCommand";
import {
  DescribeEgressOnlyInternetGatewaysCommandInput,
  DescribeEgressOnlyInternetGatewaysCommandOutput
} from "../commands/DescribeEgressOnlyInternetGatewaysCommand";
import {
  DescribeElasticGpusCommandInput,
  DescribeElasticGpusCommandOutput
} from "../commands/DescribeElasticGpusCommand";
import {
  DescribeExportImageTasksCommandInput,
  DescribeExportImageTasksCommandOutput
} from "../commands/DescribeExportImageTasksCommand";
import {
  DescribeExportTasksCommandInput,
  DescribeExportTasksCommandOutput
} from "../commands/DescribeExportTasksCommand";
import {
  DescribeFastSnapshotRestoresCommandInput,
  DescribeFastSnapshotRestoresCommandOutput
} from "../commands/DescribeFastSnapshotRestoresCommand";
import {
  DescribeFleetHistoryCommandInput,
  DescribeFleetHistoryCommandOutput
} from "../commands/DescribeFleetHistoryCommand";
import {
  DescribeFleetInstancesCommandInput,
  DescribeFleetInstancesCommandOutput
} from "../commands/DescribeFleetInstancesCommand";
import {
  DescribeFleetsCommandInput,
  DescribeFleetsCommandOutput
} from "../commands/DescribeFleetsCommand";
import {
  DescribeFlowLogsCommandInput,
  DescribeFlowLogsCommandOutput
} from "../commands/DescribeFlowLogsCommand";
import {
  DescribeFpgaImageAttributeCommandInput,
  DescribeFpgaImageAttributeCommandOutput
} from "../commands/DescribeFpgaImageAttributeCommand";
import {
  DescribeFpgaImagesCommandInput,
  DescribeFpgaImagesCommandOutput
} from "../commands/DescribeFpgaImagesCommand";
import {
  DescribeHostReservationOfferingsCommandInput,
  DescribeHostReservationOfferingsCommandOutput
} from "../commands/DescribeHostReservationOfferingsCommand";
import {
  DescribeHostReservationsCommandInput,
  DescribeHostReservationsCommandOutput
} from "../commands/DescribeHostReservationsCommand";
import {
  DescribeHostsCommandInput,
  DescribeHostsCommandOutput
} from "../commands/DescribeHostsCommand";
import {
  DescribeIamInstanceProfileAssociationsCommandInput,
  DescribeIamInstanceProfileAssociationsCommandOutput
} from "../commands/DescribeIamInstanceProfileAssociationsCommand";
import {
  DescribeIdFormatCommandInput,
  DescribeIdFormatCommandOutput
} from "../commands/DescribeIdFormatCommand";
import {
  DescribeIdentityIdFormatCommandInput,
  DescribeIdentityIdFormatCommandOutput
} from "../commands/DescribeIdentityIdFormatCommand";
import {
  DescribeImageAttributeCommandInput,
  DescribeImageAttributeCommandOutput
} from "../commands/DescribeImageAttributeCommand";
import {
  DescribeImagesCommandInput,
  DescribeImagesCommandOutput
} from "../commands/DescribeImagesCommand";
import {
  DescribeImportImageTasksCommandInput,
  DescribeImportImageTasksCommandOutput
} from "../commands/DescribeImportImageTasksCommand";
import {
  DescribeImportSnapshotTasksCommandInput,
  DescribeImportSnapshotTasksCommandOutput
} from "../commands/DescribeImportSnapshotTasksCommand";
import {
  DescribeInstanceAttributeCommandInput,
  DescribeInstanceAttributeCommandOutput
} from "../commands/DescribeInstanceAttributeCommand";
import {
  DescribeInstanceCreditSpecificationsCommandInput,
  DescribeInstanceCreditSpecificationsCommandOutput
} from "../commands/DescribeInstanceCreditSpecificationsCommand";
import {
  DescribeInstanceStatusCommandInput,
  DescribeInstanceStatusCommandOutput
} from "../commands/DescribeInstanceStatusCommand";
import {
  DescribeInstanceTypeOfferingsCommandInput,
  DescribeInstanceTypeOfferingsCommandOutput
} from "../commands/DescribeInstanceTypeOfferingsCommand";
import {
  DescribeInstanceTypesCommandInput,
  DescribeInstanceTypesCommandOutput
} from "../commands/DescribeInstanceTypesCommand";
import {
  DescribeInstancesCommandInput,
  DescribeInstancesCommandOutput
} from "../commands/DescribeInstancesCommand";
import {
  DescribeInternetGatewaysCommandInput,
  DescribeInternetGatewaysCommandOutput
} from "../commands/DescribeInternetGatewaysCommand";
import {
  DescribeIpv6PoolsCommandInput,
  DescribeIpv6PoolsCommandOutput
} from "../commands/DescribeIpv6PoolsCommand";
import {
  DescribeKeyPairsCommandInput,
  DescribeKeyPairsCommandOutput
} from "../commands/DescribeKeyPairsCommand";
import {
  DescribeLaunchTemplateVersionsCommandInput,
  DescribeLaunchTemplateVersionsCommandOutput
} from "../commands/DescribeLaunchTemplateVersionsCommand";
import {
  DescribeLaunchTemplatesCommandInput,
  DescribeLaunchTemplatesCommandOutput
} from "../commands/DescribeLaunchTemplatesCommand";
import {
  DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsCommandInput,
  DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsCommandOutput
} from "../commands/DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsCommand";
import {
  DescribeLocalGatewayRouteTableVpcAssociationsCommandInput,
  DescribeLocalGatewayRouteTableVpcAssociationsCommandOutput
} from "../commands/DescribeLocalGatewayRouteTableVpcAssociationsCommand";
import {
  DescribeLocalGatewayRouteTablesCommandInput,
  DescribeLocalGatewayRouteTablesCommandOutput
} from "../commands/DescribeLocalGatewayRouteTablesCommand";
import {
  DescribeLocalGatewayVirtualInterfaceGroupsCommandInput,
  DescribeLocalGatewayVirtualInterfaceGroupsCommandOutput
} from "../commands/DescribeLocalGatewayVirtualInterfaceGroupsCommand";
import {
  DescribeLocalGatewayVirtualInterfacesCommandInput,
  DescribeLocalGatewayVirtualInterfacesCommandOutput
} from "../commands/DescribeLocalGatewayVirtualInterfacesCommand";
import {
  DescribeLocalGatewaysCommandInput,
  DescribeLocalGatewaysCommandOutput
} from "../commands/DescribeLocalGatewaysCommand";
import {
  DescribeMovingAddressesCommandInput,
  DescribeMovingAddressesCommandOutput
} from "../commands/DescribeMovingAddressesCommand";
import {
  DescribeNatGatewaysCommandInput,
  DescribeNatGatewaysCommandOutput
} from "../commands/DescribeNatGatewaysCommand";
import {
  DescribeNetworkAclsCommandInput,
  DescribeNetworkAclsCommandOutput
} from "../commands/DescribeNetworkAclsCommand";
import {
  DescribeNetworkInterfaceAttributeCommandInput,
  DescribeNetworkInterfaceAttributeCommandOutput
} from "../commands/DescribeNetworkInterfaceAttributeCommand";
import {
  DescribeNetworkInterfacePermissionsCommandInput,
  DescribeNetworkInterfacePermissionsCommandOutput
} from "../commands/DescribeNetworkInterfacePermissionsCommand";
import {
  DescribeNetworkInterfacesCommandInput,
  DescribeNetworkInterfacesCommandOutput
} from "../commands/DescribeNetworkInterfacesCommand";
import {
  DescribePlacementGroupsCommandInput,
  DescribePlacementGroupsCommandOutput
} from "../commands/DescribePlacementGroupsCommand";
import {
  DescribePrefixListsCommandInput,
  DescribePrefixListsCommandOutput
} from "../commands/DescribePrefixListsCommand";
import {
  DescribePrincipalIdFormatCommandInput,
  DescribePrincipalIdFormatCommandOutput
} from "../commands/DescribePrincipalIdFormatCommand";
import {
  DescribePublicIpv4PoolsCommandInput,
  DescribePublicIpv4PoolsCommandOutput
} from "../commands/DescribePublicIpv4PoolsCommand";
import {
  DescribeRegionsCommandInput,
  DescribeRegionsCommandOutput
} from "../commands/DescribeRegionsCommand";
import {
  DescribeReservedInstancesCommandInput,
  DescribeReservedInstancesCommandOutput
} from "../commands/DescribeReservedInstancesCommand";
import {
  DescribeReservedInstancesListingsCommandInput,
  DescribeReservedInstancesListingsCommandOutput
} from "../commands/DescribeReservedInstancesListingsCommand";
import {
  DescribeReservedInstancesModificationsCommandInput,
  DescribeReservedInstancesModificationsCommandOutput
} from "../commands/DescribeReservedInstancesModificationsCommand";
import {
  DescribeReservedInstancesOfferingsCommandInput,
  DescribeReservedInstancesOfferingsCommandOutput
} from "../commands/DescribeReservedInstancesOfferingsCommand";
import {
  DescribeRouteTablesCommandInput,
  DescribeRouteTablesCommandOutput
} from "../commands/DescribeRouteTablesCommand";
import {
  DescribeScheduledInstanceAvailabilityCommandInput,
  DescribeScheduledInstanceAvailabilityCommandOutput
} from "../commands/DescribeScheduledInstanceAvailabilityCommand";
import {
  DescribeScheduledInstancesCommandInput,
  DescribeScheduledInstancesCommandOutput
} from "../commands/DescribeScheduledInstancesCommand";
import {
  DescribeSecurityGroupReferencesCommandInput,
  DescribeSecurityGroupReferencesCommandOutput
} from "../commands/DescribeSecurityGroupReferencesCommand";
import {
  DescribeSecurityGroupsCommandInput,
  DescribeSecurityGroupsCommandOutput
} from "../commands/DescribeSecurityGroupsCommand";
import {
  DescribeSnapshotAttributeCommandInput,
  DescribeSnapshotAttributeCommandOutput
} from "../commands/DescribeSnapshotAttributeCommand";
import {
  DescribeSnapshotsCommandInput,
  DescribeSnapshotsCommandOutput
} from "../commands/DescribeSnapshotsCommand";
import {
  DescribeSpotDatafeedSubscriptionCommandInput,
  DescribeSpotDatafeedSubscriptionCommandOutput
} from "../commands/DescribeSpotDatafeedSubscriptionCommand";
import {
  DescribeSpotFleetInstancesCommandInput,
  DescribeSpotFleetInstancesCommandOutput
} from "../commands/DescribeSpotFleetInstancesCommand";
import {
  DescribeSpotFleetRequestHistoryCommandInput,
  DescribeSpotFleetRequestHistoryCommandOutput
} from "../commands/DescribeSpotFleetRequestHistoryCommand";
import {
  DescribeSpotFleetRequestsCommandInput,
  DescribeSpotFleetRequestsCommandOutput
} from "../commands/DescribeSpotFleetRequestsCommand";
import {
  DescribeSpotInstanceRequestsCommandInput,
  DescribeSpotInstanceRequestsCommandOutput
} from "../commands/DescribeSpotInstanceRequestsCommand";
import {
  DescribeSpotPriceHistoryCommandInput,
  DescribeSpotPriceHistoryCommandOutput
} from "../commands/DescribeSpotPriceHistoryCommand";
import {
  DescribeStaleSecurityGroupsCommandInput,
  DescribeStaleSecurityGroupsCommandOutput
} from "../commands/DescribeStaleSecurityGroupsCommand";
import {
  DescribeSubnetsCommandInput,
  DescribeSubnetsCommandOutput
} from "../commands/DescribeSubnetsCommand";
import {
  DescribeTagsCommandInput,
  DescribeTagsCommandOutput
} from "../commands/DescribeTagsCommand";
import {
  DescribeTrafficMirrorFiltersCommandInput,
  DescribeTrafficMirrorFiltersCommandOutput
} from "../commands/DescribeTrafficMirrorFiltersCommand";
import {
  DescribeTrafficMirrorSessionsCommandInput,
  DescribeTrafficMirrorSessionsCommandOutput
} from "../commands/DescribeTrafficMirrorSessionsCommand";
import {
  DescribeTrafficMirrorTargetsCommandInput,
  DescribeTrafficMirrorTargetsCommandOutput
} from "../commands/DescribeTrafficMirrorTargetsCommand";
import {
  DescribeTransitGatewayAttachmentsCommandInput,
  DescribeTransitGatewayAttachmentsCommandOutput
} from "../commands/DescribeTransitGatewayAttachmentsCommand";
import {
  DescribeTransitGatewayMulticastDomainsCommandInput,
  DescribeTransitGatewayMulticastDomainsCommandOutput
} from "../commands/DescribeTransitGatewayMulticastDomainsCommand";
import {
  DescribeTransitGatewayPeeringAttachmentsCommandInput,
  DescribeTransitGatewayPeeringAttachmentsCommandOutput
} from "../commands/DescribeTransitGatewayPeeringAttachmentsCommand";
import {
  DescribeTransitGatewayRouteTablesCommandInput,
  DescribeTransitGatewayRouteTablesCommandOutput
} from "../commands/DescribeTransitGatewayRouteTablesCommand";
import {
  DescribeTransitGatewayVpcAttachmentsCommandInput,
  DescribeTransitGatewayVpcAttachmentsCommandOutput
} from "../commands/DescribeTransitGatewayVpcAttachmentsCommand";
import {
  DescribeTransitGatewaysCommandInput,
  DescribeTransitGatewaysCommandOutput
} from "../commands/DescribeTransitGatewaysCommand";
import {
  DescribeVolumeAttributeCommandInput,
  DescribeVolumeAttributeCommandOutput
} from "../commands/DescribeVolumeAttributeCommand";
import {
  DescribeVolumeStatusCommandInput,
  DescribeVolumeStatusCommandOutput
} from "../commands/DescribeVolumeStatusCommand";
import {
  DescribeVolumesCommandInput,
  DescribeVolumesCommandOutput
} from "../commands/DescribeVolumesCommand";
import {
  DescribeVolumesModificationsCommandInput,
  DescribeVolumesModificationsCommandOutput
} from "../commands/DescribeVolumesModificationsCommand";
import {
  DescribeVpcAttributeCommandInput,
  DescribeVpcAttributeCommandOutput
} from "../commands/DescribeVpcAttributeCommand";
import {
  DescribeVpcClassicLinkCommandInput,
  DescribeVpcClassicLinkCommandOutput
} from "../commands/DescribeVpcClassicLinkCommand";
import {
  DescribeVpcClassicLinkDnsSupportCommandInput,
  DescribeVpcClassicLinkDnsSupportCommandOutput
} from "../commands/DescribeVpcClassicLinkDnsSupportCommand";
import {
  DescribeVpcEndpointConnectionNotificationsCommandInput,
  DescribeVpcEndpointConnectionNotificationsCommandOutput
} from "../commands/DescribeVpcEndpointConnectionNotificationsCommand";
import {
  DescribeVpcEndpointConnectionsCommandInput,
  DescribeVpcEndpointConnectionsCommandOutput
} from "../commands/DescribeVpcEndpointConnectionsCommand";
import {
  DescribeVpcEndpointServiceConfigurationsCommandInput,
  DescribeVpcEndpointServiceConfigurationsCommandOutput
} from "../commands/DescribeVpcEndpointServiceConfigurationsCommand";
import {
  DescribeVpcEndpointServicePermissionsCommandInput,
  DescribeVpcEndpointServicePermissionsCommandOutput
} from "../commands/DescribeVpcEndpointServicePermissionsCommand";
import {
  DescribeVpcEndpointServicesCommandInput,
  DescribeVpcEndpointServicesCommandOutput
} from "../commands/DescribeVpcEndpointServicesCommand";
import {
  DescribeVpcEndpointsCommandInput,
  DescribeVpcEndpointsCommandOutput
} from "../commands/DescribeVpcEndpointsCommand";
import {
  DescribeVpcPeeringConnectionsCommandInput,
  DescribeVpcPeeringConnectionsCommandOutput
} from "../commands/DescribeVpcPeeringConnectionsCommand";
import {
  DescribeVpcsCommandInput,
  DescribeVpcsCommandOutput
} from "../commands/DescribeVpcsCommand";
import {
  DescribeVpnConnectionsCommandInput,
  DescribeVpnConnectionsCommandOutput
} from "../commands/DescribeVpnConnectionsCommand";
import {
  DescribeVpnGatewaysCommandInput,
  DescribeVpnGatewaysCommandOutput
} from "../commands/DescribeVpnGatewaysCommand";
import {
  DetachClassicLinkVpcCommandInput,
  DetachClassicLinkVpcCommandOutput
} from "../commands/DetachClassicLinkVpcCommand";
import {
  DetachInternetGatewayCommandInput,
  DetachInternetGatewayCommandOutput
} from "../commands/DetachInternetGatewayCommand";
import {
  DetachNetworkInterfaceCommandInput,
  DetachNetworkInterfaceCommandOutput
} from "../commands/DetachNetworkInterfaceCommand";
import {
  DetachVolumeCommandInput,
  DetachVolumeCommandOutput
} from "../commands/DetachVolumeCommand";
import {
  DetachVpnGatewayCommandInput,
  DetachVpnGatewayCommandOutput
} from "../commands/DetachVpnGatewayCommand";
import {
  DisableEbsEncryptionByDefaultCommandInput,
  DisableEbsEncryptionByDefaultCommandOutput
} from "../commands/DisableEbsEncryptionByDefaultCommand";
import {
  DisableFastSnapshotRestoresCommandInput,
  DisableFastSnapshotRestoresCommandOutput
} from "../commands/DisableFastSnapshotRestoresCommand";
import {
  DisableTransitGatewayRouteTablePropagationCommandInput,
  DisableTransitGatewayRouteTablePropagationCommandOutput
} from "../commands/DisableTransitGatewayRouteTablePropagationCommand";
import {
  DisableVgwRoutePropagationCommandInput,
  DisableVgwRoutePropagationCommandOutput
} from "../commands/DisableVgwRoutePropagationCommand";
import {
  DisableVpcClassicLinkCommandInput,
  DisableVpcClassicLinkCommandOutput
} from "../commands/DisableVpcClassicLinkCommand";
import {
  DisableVpcClassicLinkDnsSupportCommandInput,
  DisableVpcClassicLinkDnsSupportCommandOutput
} from "../commands/DisableVpcClassicLinkDnsSupportCommand";
import {
  DisassociateAddressCommandInput,
  DisassociateAddressCommandOutput
} from "../commands/DisassociateAddressCommand";
import {
  DisassociateClientVpnTargetNetworkCommandInput,
  DisassociateClientVpnTargetNetworkCommandOutput
} from "../commands/DisassociateClientVpnTargetNetworkCommand";
import {
  DisassociateIamInstanceProfileCommandInput,
  DisassociateIamInstanceProfileCommandOutput
} from "../commands/DisassociateIamInstanceProfileCommand";
import {
  DisassociateRouteTableCommandInput,
  DisassociateRouteTableCommandOutput
} from "../commands/DisassociateRouteTableCommand";
import {
  DisassociateSubnetCidrBlockCommandInput,
  DisassociateSubnetCidrBlockCommandOutput
} from "../commands/DisassociateSubnetCidrBlockCommand";
import {
  DisassociateTransitGatewayMulticastDomainCommandInput,
  DisassociateTransitGatewayMulticastDomainCommandOutput
} from "../commands/DisassociateTransitGatewayMulticastDomainCommand";
import {
  DisassociateTransitGatewayRouteTableCommandInput,
  DisassociateTransitGatewayRouteTableCommandOutput
} from "../commands/DisassociateTransitGatewayRouteTableCommand";
import {
  DisassociateVpcCidrBlockCommandInput,
  DisassociateVpcCidrBlockCommandOutput
} from "../commands/DisassociateVpcCidrBlockCommand";
import {
  EnableEbsEncryptionByDefaultCommandInput,
  EnableEbsEncryptionByDefaultCommandOutput
} from "../commands/EnableEbsEncryptionByDefaultCommand";
import {
  EnableFastSnapshotRestoresCommandInput,
  EnableFastSnapshotRestoresCommandOutput
} from "../commands/EnableFastSnapshotRestoresCommand";
import {
  EnableTransitGatewayRouteTablePropagationCommandInput,
  EnableTransitGatewayRouteTablePropagationCommandOutput
} from "../commands/EnableTransitGatewayRouteTablePropagationCommand";
import {
  EnableVgwRoutePropagationCommandInput,
  EnableVgwRoutePropagationCommandOutput
} from "../commands/EnableVgwRoutePropagationCommand";
import {
  EnableVolumeIOCommandInput,
  EnableVolumeIOCommandOutput
} from "../commands/EnableVolumeIOCommand";
import {
  EnableVpcClassicLinkCommandInput,
  EnableVpcClassicLinkCommandOutput
} from "../commands/EnableVpcClassicLinkCommand";
import {
  EnableVpcClassicLinkDnsSupportCommandInput,
  EnableVpcClassicLinkDnsSupportCommandOutput
} from "../commands/EnableVpcClassicLinkDnsSupportCommand";
import {
  ExportClientVpnClientCertificateRevocationListCommandInput,
  ExportClientVpnClientCertificateRevocationListCommandOutput
} from "../commands/ExportClientVpnClientCertificateRevocationListCommand";
import {
  ExportClientVpnClientConfigurationCommandInput,
  ExportClientVpnClientConfigurationCommandOutput
} from "../commands/ExportClientVpnClientConfigurationCommand";
import {
  ExportImageCommandInput,
  ExportImageCommandOutput
} from "../commands/ExportImageCommand";
import {
  ExportTransitGatewayRoutesCommandInput,
  ExportTransitGatewayRoutesCommandOutput
} from "../commands/ExportTransitGatewayRoutesCommand";
import {
  GetAssociatedIpv6PoolCidrsCommandInput,
  GetAssociatedIpv6PoolCidrsCommandOutput
} from "../commands/GetAssociatedIpv6PoolCidrsCommand";
import {
  GetCapacityReservationUsageCommandInput,
  GetCapacityReservationUsageCommandOutput
} from "../commands/GetCapacityReservationUsageCommand";
import {
  GetCoipPoolUsageCommandInput,
  GetCoipPoolUsageCommandOutput
} from "../commands/GetCoipPoolUsageCommand";
import {
  GetConsoleOutputCommandInput,
  GetConsoleOutputCommandOutput
} from "../commands/GetConsoleOutputCommand";
import {
  GetConsoleScreenshotCommandInput,
  GetConsoleScreenshotCommandOutput
} from "../commands/GetConsoleScreenshotCommand";
import {
  GetDefaultCreditSpecificationCommandInput,
  GetDefaultCreditSpecificationCommandOutput
} from "../commands/GetDefaultCreditSpecificationCommand";
import {
  GetEbsDefaultKmsKeyIdCommandInput,
  GetEbsDefaultKmsKeyIdCommandOutput
} from "../commands/GetEbsDefaultKmsKeyIdCommand";
import {
  GetEbsEncryptionByDefaultCommandInput,
  GetEbsEncryptionByDefaultCommandOutput
} from "../commands/GetEbsEncryptionByDefaultCommand";
import {
  GetHostReservationPurchasePreviewCommandInput,
  GetHostReservationPurchasePreviewCommandOutput
} from "../commands/GetHostReservationPurchasePreviewCommand";
import {
  GetLaunchTemplateDataCommandInput,
  GetLaunchTemplateDataCommandOutput
} from "../commands/GetLaunchTemplateDataCommand";
import {
  GetPasswordDataCommandInput,
  GetPasswordDataCommandOutput
} from "../commands/GetPasswordDataCommand";
import {
  GetReservedInstancesExchangeQuoteCommandInput,
  GetReservedInstancesExchangeQuoteCommandOutput
} from "../commands/GetReservedInstancesExchangeQuoteCommand";
import {
  GetTransitGatewayAttachmentPropagationsCommandInput,
  GetTransitGatewayAttachmentPropagationsCommandOutput
} from "../commands/GetTransitGatewayAttachmentPropagationsCommand";
import {
  GetTransitGatewayMulticastDomainAssociationsCommandInput,
  GetTransitGatewayMulticastDomainAssociationsCommandOutput
} from "../commands/GetTransitGatewayMulticastDomainAssociationsCommand";
import {
  GetTransitGatewayRouteTableAssociationsCommandInput,
  GetTransitGatewayRouteTableAssociationsCommandOutput
} from "../commands/GetTransitGatewayRouteTableAssociationsCommand";
import {
  GetTransitGatewayRouteTablePropagationsCommandInput,
  GetTransitGatewayRouteTablePropagationsCommandOutput
} from "../commands/GetTransitGatewayRouteTablePropagationsCommand";
import {
  ImportClientVpnClientCertificateRevocationListCommandInput,
  ImportClientVpnClientCertificateRevocationListCommandOutput
} from "../commands/ImportClientVpnClientCertificateRevocationListCommand";
import {
  ImportImageCommandInput,
  ImportImageCommandOutput
} from "../commands/ImportImageCommand";
import {
  ImportInstanceCommandInput,
  ImportInstanceCommandOutput
} from "../commands/ImportInstanceCommand";
import {
  ImportKeyPairCommandInput,
  ImportKeyPairCommandOutput
} from "../commands/ImportKeyPairCommand";
import {
  ImportSnapshotCommandInput,
  ImportSnapshotCommandOutput
} from "../commands/ImportSnapshotCommand";
import {
  ImportVolumeCommandInput,
  ImportVolumeCommandOutput
} from "../commands/ImportVolumeCommand";
import {
  ModifyCapacityReservationCommandInput,
  ModifyCapacityReservationCommandOutput
} from "../commands/ModifyCapacityReservationCommand";
import {
  ModifyClientVpnEndpointCommandInput,
  ModifyClientVpnEndpointCommandOutput
} from "../commands/ModifyClientVpnEndpointCommand";
import {
  ModifyDefaultCreditSpecificationCommandInput,
  ModifyDefaultCreditSpecificationCommandOutput
} from "../commands/ModifyDefaultCreditSpecificationCommand";
import {
  ModifyEbsDefaultKmsKeyIdCommandInput,
  ModifyEbsDefaultKmsKeyIdCommandOutput
} from "../commands/ModifyEbsDefaultKmsKeyIdCommand";
import {
  ModifyFleetCommandInput,
  ModifyFleetCommandOutput
} from "../commands/ModifyFleetCommand";
import {
  ModifyFpgaImageAttributeCommandInput,
  ModifyFpgaImageAttributeCommandOutput
} from "../commands/ModifyFpgaImageAttributeCommand";
import {
  ModifyHostsCommandInput,
  ModifyHostsCommandOutput
} from "../commands/ModifyHostsCommand";
import {
  ModifyIdFormatCommandInput,
  ModifyIdFormatCommandOutput
} from "../commands/ModifyIdFormatCommand";
import {
  ModifyIdentityIdFormatCommandInput,
  ModifyIdentityIdFormatCommandOutput
} from "../commands/ModifyIdentityIdFormatCommand";
import {
  ModifyImageAttributeCommandInput,
  ModifyImageAttributeCommandOutput
} from "../commands/ModifyImageAttributeCommand";
import {
  ModifyInstanceAttributeCommandInput,
  ModifyInstanceAttributeCommandOutput
} from "../commands/ModifyInstanceAttributeCommand";
import {
  ModifyInstanceCapacityReservationAttributesCommandInput,
  ModifyInstanceCapacityReservationAttributesCommandOutput
} from "../commands/ModifyInstanceCapacityReservationAttributesCommand";
import {
  ModifyInstanceCreditSpecificationCommandInput,
  ModifyInstanceCreditSpecificationCommandOutput
} from "../commands/ModifyInstanceCreditSpecificationCommand";
import {
  ModifyInstanceEventStartTimeCommandInput,
  ModifyInstanceEventStartTimeCommandOutput
} from "../commands/ModifyInstanceEventStartTimeCommand";
import {
  ModifyInstanceMetadataOptionsCommandInput,
  ModifyInstanceMetadataOptionsCommandOutput
} from "../commands/ModifyInstanceMetadataOptionsCommand";
import {
  ModifyInstancePlacementCommandInput,
  ModifyInstancePlacementCommandOutput
} from "../commands/ModifyInstancePlacementCommand";
import {
  ModifyLaunchTemplateCommandInput,
  ModifyLaunchTemplateCommandOutput
} from "../commands/ModifyLaunchTemplateCommand";
import {
  ModifyNetworkInterfaceAttributeCommandInput,
  ModifyNetworkInterfaceAttributeCommandOutput
} from "../commands/ModifyNetworkInterfaceAttributeCommand";
import {
  ModifyReservedInstancesCommandInput,
  ModifyReservedInstancesCommandOutput
} from "../commands/ModifyReservedInstancesCommand";
import {
  ModifySnapshotAttributeCommandInput,
  ModifySnapshotAttributeCommandOutput
} from "../commands/ModifySnapshotAttributeCommand";
import {
  ModifySpotFleetRequestCommandInput,
  ModifySpotFleetRequestCommandOutput
} from "../commands/ModifySpotFleetRequestCommand";
import {
  ModifySubnetAttributeCommandInput,
  ModifySubnetAttributeCommandOutput
} from "../commands/ModifySubnetAttributeCommand";
import {
  ModifyTrafficMirrorFilterNetworkServicesCommandInput,
  ModifyTrafficMirrorFilterNetworkServicesCommandOutput
} from "../commands/ModifyTrafficMirrorFilterNetworkServicesCommand";
import {
  ModifyTrafficMirrorFilterRuleCommandInput,
  ModifyTrafficMirrorFilterRuleCommandOutput
} from "../commands/ModifyTrafficMirrorFilterRuleCommand";
import {
  ModifyTrafficMirrorSessionCommandInput,
  ModifyTrafficMirrorSessionCommandOutput
} from "../commands/ModifyTrafficMirrorSessionCommand";
import {
  ModifyTransitGatewayVpcAttachmentCommandInput,
  ModifyTransitGatewayVpcAttachmentCommandOutput
} from "../commands/ModifyTransitGatewayVpcAttachmentCommand";
import {
  ModifyVolumeAttributeCommandInput,
  ModifyVolumeAttributeCommandOutput
} from "../commands/ModifyVolumeAttributeCommand";
import {
  ModifyVolumeCommandInput,
  ModifyVolumeCommandOutput
} from "../commands/ModifyVolumeCommand";
import {
  ModifyVpcAttributeCommandInput,
  ModifyVpcAttributeCommandOutput
} from "../commands/ModifyVpcAttributeCommand";
import {
  ModifyVpcEndpointCommandInput,
  ModifyVpcEndpointCommandOutput
} from "../commands/ModifyVpcEndpointCommand";
import {
  ModifyVpcEndpointConnectionNotificationCommandInput,
  ModifyVpcEndpointConnectionNotificationCommandOutput
} from "../commands/ModifyVpcEndpointConnectionNotificationCommand";
import {
  ModifyVpcEndpointServiceConfigurationCommandInput,
  ModifyVpcEndpointServiceConfigurationCommandOutput
} from "../commands/ModifyVpcEndpointServiceConfigurationCommand";
import {
  ModifyVpcEndpointServicePermissionsCommandInput,
  ModifyVpcEndpointServicePermissionsCommandOutput
} from "../commands/ModifyVpcEndpointServicePermissionsCommand";
import {
  ModifyVpcPeeringConnectionOptionsCommandInput,
  ModifyVpcPeeringConnectionOptionsCommandOutput
} from "../commands/ModifyVpcPeeringConnectionOptionsCommand";
import {
  ModifyVpcTenancyCommandInput,
  ModifyVpcTenancyCommandOutput
} from "../commands/ModifyVpcTenancyCommand";
import {
  ModifyVpnConnectionCommandInput,
  ModifyVpnConnectionCommandOutput
} from "../commands/ModifyVpnConnectionCommand";
import {
  ModifyVpnTunnelCertificateCommandInput,
  ModifyVpnTunnelCertificateCommandOutput
} from "../commands/ModifyVpnTunnelCertificateCommand";
import {
  ModifyVpnTunnelOptionsCommandInput,
  ModifyVpnTunnelOptionsCommandOutput
} from "../commands/ModifyVpnTunnelOptionsCommand";
import {
  MonitorInstancesCommandInput,
  MonitorInstancesCommandOutput
} from "../commands/MonitorInstancesCommand";
import {
  MoveAddressToVpcCommandInput,
  MoveAddressToVpcCommandOutput
} from "../commands/MoveAddressToVpcCommand";
import {
  ProvisionByoipCidrCommandInput,
  ProvisionByoipCidrCommandOutput
} from "../commands/ProvisionByoipCidrCommand";
import {
  PurchaseHostReservationCommandInput,
  PurchaseHostReservationCommandOutput
} from "../commands/PurchaseHostReservationCommand";
import {
  PurchaseReservedInstancesOfferingCommandInput,
  PurchaseReservedInstancesOfferingCommandOutput
} from "../commands/PurchaseReservedInstancesOfferingCommand";
import {
  PurchaseScheduledInstancesCommandInput,
  PurchaseScheduledInstancesCommandOutput
} from "../commands/PurchaseScheduledInstancesCommand";
import {
  RebootInstancesCommandInput,
  RebootInstancesCommandOutput
} from "../commands/RebootInstancesCommand";
import {
  RegisterImageCommandInput,
  RegisterImageCommandOutput
} from "../commands/RegisterImageCommand";
import {
  RegisterTransitGatewayMulticastGroupMembersCommandInput,
  RegisterTransitGatewayMulticastGroupMembersCommandOutput
} from "../commands/RegisterTransitGatewayMulticastGroupMembersCommand";
import {
  RegisterTransitGatewayMulticastGroupSourcesCommandInput,
  RegisterTransitGatewayMulticastGroupSourcesCommandOutput
} from "../commands/RegisterTransitGatewayMulticastGroupSourcesCommand";
import {
  RejectTransitGatewayPeeringAttachmentCommandInput,
  RejectTransitGatewayPeeringAttachmentCommandOutput
} from "../commands/RejectTransitGatewayPeeringAttachmentCommand";
import {
  RejectTransitGatewayVpcAttachmentCommandInput,
  RejectTransitGatewayVpcAttachmentCommandOutput
} from "../commands/RejectTransitGatewayVpcAttachmentCommand";
import {
  RejectVpcEndpointConnectionsCommandInput,
  RejectVpcEndpointConnectionsCommandOutput
} from "../commands/RejectVpcEndpointConnectionsCommand";
import {
  RejectVpcPeeringConnectionCommandInput,
  RejectVpcPeeringConnectionCommandOutput
} from "../commands/RejectVpcPeeringConnectionCommand";
import {
  ReleaseAddressCommandInput,
  ReleaseAddressCommandOutput
} from "../commands/ReleaseAddressCommand";
import {
  ReleaseHostsCommandInput,
  ReleaseHostsCommandOutput
} from "../commands/ReleaseHostsCommand";
import {
  ReplaceIamInstanceProfileAssociationCommandInput,
  ReplaceIamInstanceProfileAssociationCommandOutput
} from "../commands/ReplaceIamInstanceProfileAssociationCommand";
import {
  ReplaceNetworkAclAssociationCommandInput,
  ReplaceNetworkAclAssociationCommandOutput
} from "../commands/ReplaceNetworkAclAssociationCommand";
import {
  ReplaceNetworkAclEntryCommandInput,
  ReplaceNetworkAclEntryCommandOutput
} from "../commands/ReplaceNetworkAclEntryCommand";
import {
  ReplaceRouteCommandInput,
  ReplaceRouteCommandOutput
} from "../commands/ReplaceRouteCommand";
import {
  ReplaceRouteTableAssociationCommandInput,
  ReplaceRouteTableAssociationCommandOutput
} from "../commands/ReplaceRouteTableAssociationCommand";
import {
  ReplaceTransitGatewayRouteCommandInput,
  ReplaceTransitGatewayRouteCommandOutput
} from "../commands/ReplaceTransitGatewayRouteCommand";
import {
  ReportInstanceStatusCommandInput,
  ReportInstanceStatusCommandOutput
} from "../commands/ReportInstanceStatusCommand";
import {
  RequestSpotFleetCommandInput,
  RequestSpotFleetCommandOutput
} from "../commands/RequestSpotFleetCommand";
import {
  RequestSpotInstancesCommandInput,
  RequestSpotInstancesCommandOutput
} from "../commands/RequestSpotInstancesCommand";
import {
  ResetEbsDefaultKmsKeyIdCommandInput,
  ResetEbsDefaultKmsKeyIdCommandOutput
} from "../commands/ResetEbsDefaultKmsKeyIdCommand";
import {
  ResetFpgaImageAttributeCommandInput,
  ResetFpgaImageAttributeCommandOutput
} from "../commands/ResetFpgaImageAttributeCommand";
import {
  ResetImageAttributeCommandInput,
  ResetImageAttributeCommandOutput
} from "../commands/ResetImageAttributeCommand";
import {
  ResetInstanceAttributeCommandInput,
  ResetInstanceAttributeCommandOutput
} from "../commands/ResetInstanceAttributeCommand";
import {
  ResetNetworkInterfaceAttributeCommandInput,
  ResetNetworkInterfaceAttributeCommandOutput
} from "../commands/ResetNetworkInterfaceAttributeCommand";
import {
  ResetSnapshotAttributeCommandInput,
  ResetSnapshotAttributeCommandOutput
} from "../commands/ResetSnapshotAttributeCommand";
import {
  RestoreAddressToClassicCommandInput,
  RestoreAddressToClassicCommandOutput
} from "../commands/RestoreAddressToClassicCommand";
import {
  RevokeClientVpnIngressCommandInput,
  RevokeClientVpnIngressCommandOutput
} from "../commands/RevokeClientVpnIngressCommand";
import {
  RevokeSecurityGroupEgressCommandInput,
  RevokeSecurityGroupEgressCommandOutput
} from "../commands/RevokeSecurityGroupEgressCommand";
import {
  RevokeSecurityGroupIngressCommandInput,
  RevokeSecurityGroupIngressCommandOutput
} from "../commands/RevokeSecurityGroupIngressCommand";
import {
  RunInstancesCommandInput,
  RunInstancesCommandOutput
} from "../commands/RunInstancesCommand";
import {
  RunScheduledInstancesCommandInput,
  RunScheduledInstancesCommandOutput
} from "../commands/RunScheduledInstancesCommand";
import {
  SearchLocalGatewayRoutesCommandInput,
  SearchLocalGatewayRoutesCommandOutput
} from "../commands/SearchLocalGatewayRoutesCommand";
import {
  SearchTransitGatewayMulticastGroupsCommandInput,
  SearchTransitGatewayMulticastGroupsCommandOutput
} from "../commands/SearchTransitGatewayMulticastGroupsCommand";
import {
  SearchTransitGatewayRoutesCommandInput,
  SearchTransitGatewayRoutesCommandOutput
} from "../commands/SearchTransitGatewayRoutesCommand";
import {
  SendDiagnosticInterruptCommandInput,
  SendDiagnosticInterruptCommandOutput
} from "../commands/SendDiagnosticInterruptCommand";
import {
  StartInstancesCommandInput,
  StartInstancesCommandOutput
} from "../commands/StartInstancesCommand";
import {
  StartVpcEndpointServicePrivateDnsVerificationCommandInput,
  StartVpcEndpointServicePrivateDnsVerificationCommandOutput
} from "../commands/StartVpcEndpointServicePrivateDnsVerificationCommand";
import {
  StopInstancesCommandInput,
  StopInstancesCommandOutput
} from "../commands/StopInstancesCommand";
import {
  TerminateClientVpnConnectionsCommandInput,
  TerminateClientVpnConnectionsCommandOutput
} from "../commands/TerminateClientVpnConnectionsCommand";
import {
  TerminateInstancesCommandInput,
  TerminateInstancesCommandOutput
} from "../commands/TerminateInstancesCommand";
import {
  UnassignIpv6AddressesCommandInput,
  UnassignIpv6AddressesCommandOutput
} from "../commands/UnassignIpv6AddressesCommand";
import {
  UnassignPrivateIpAddressesCommandInput,
  UnassignPrivateIpAddressesCommandOutput
} from "../commands/UnassignPrivateIpAddressesCommand";
import {
  UnmonitorInstancesCommandInput,
  UnmonitorInstancesCommandOutput
} from "../commands/UnmonitorInstancesCommand";
import {
  UpdateSecurityGroupRuleDescriptionsEgressCommandInput,
  UpdateSecurityGroupRuleDescriptionsEgressCommandOutput
} from "../commands/UpdateSecurityGroupRuleDescriptionsEgressCommand";
import {
  UpdateSecurityGroupRuleDescriptionsIngressCommandInput,
  UpdateSecurityGroupRuleDescriptionsIngressCommandOutput
} from "../commands/UpdateSecurityGroupRuleDescriptionsIngressCommand";
import {
  WithdrawByoipCidrCommandInput,
  WithdrawByoipCidrCommandOutput
} from "../commands/WithdrawByoipCidrCommand";
import {
  AcceptReservedInstancesExchangeQuoteRequest,
  AcceptReservedInstancesExchangeQuoteResult,
  AcceptTransitGatewayPeeringAttachmentRequest,
  AcceptTransitGatewayPeeringAttachmentResult,
  AcceptTransitGatewayVpcAttachmentRequest,
  AcceptTransitGatewayVpcAttachmentResult,
  AcceptVpcEndpointConnectionsRequest,
  AcceptVpcEndpointConnectionsResult,
  AcceptVpcPeeringConnectionRequest,
  AcceptVpcPeeringConnectionResult,
  AccountAttribute,
  AccountAttributeName,
  AccountAttributeValue,
  ActiveInstance,
  Address,
  AdvertiseByoipCidrRequest,
  AdvertiseByoipCidrResult,
  AllocateAddressRequest,
  AllocateAddressResult,
  AllocateHostsRequest,
  AllocateHostsResult,
  AllowedPrincipal,
  ApplySecurityGroupsToClientVpnTargetNetworkRequest,
  ApplySecurityGroupsToClientVpnTargetNetworkResult,
  ArchitectureType,
  AssignIpv6AddressesRequest,
  AssignIpv6AddressesResult,
  AssignPrivateIpAddressesRequest,
  AssignPrivateIpAddressesResult,
  AssignedPrivateIpAddress,
  AssociateAddressRequest,
  AssociateAddressResult,
  AssociateClientVpnTargetNetworkRequest,
  AssociateClientVpnTargetNetworkResult,
  AssociateDhcpOptionsRequest,
  AssociateIamInstanceProfileRequest,
  AssociateIamInstanceProfileResult,
  AssociateRouteTableRequest,
  AssociateRouteTableResult,
  AssociateSubnetCidrBlockRequest,
  AssociateSubnetCidrBlockResult,
  AssociateTransitGatewayMulticastDomainRequest,
  AssociateTransitGatewayMulticastDomainResult,
  AssociateTransitGatewayRouteTableRequest,
  AssociateTransitGatewayRouteTableResult,
  AssociateVpcCidrBlockRequest,
  AssociateVpcCidrBlockResult,
  AssociatedTargetNetwork,
  AssociationStatus,
  AttachClassicLinkVpcRequest,
  AttachClassicLinkVpcResult,
  AttachInternetGatewayRequest,
  AttachNetworkInterfaceRequest,
  AttachNetworkInterfaceResult,
  AttachVolumeRequest,
  AttachVpnGatewayRequest,
  AttachVpnGatewayResult,
  AttributeBooleanValue,
  AttributeValue,
  AuthorizationRule,
  AuthorizeClientVpnIngressRequest,
  AuthorizeClientVpnIngressResult,
  AuthorizeSecurityGroupEgressRequest,
  AuthorizeSecurityGroupIngressRequest,
  AvailabilityZone,
  AvailabilityZoneMessage,
  AvailableCapacity,
  BlobAttributeValue,
  BlockDeviceMapping,
  BundleInstanceRequest,
  BundleInstanceResult,
  BundleTask,
  BundleTaskError,
  ByoipCidr,
  CancelBundleTaskRequest,
  CancelBundleTaskResult,
  CancelCapacityReservationRequest,
  CancelCapacityReservationResult,
  CancelConversionRequest,
  CancelExportTaskRequest,
  CancelImportTaskRequest,
  CancelImportTaskResult,
  CancelReservedInstancesListingRequest,
  CancelReservedInstancesListingResult,
  CancelSpotFleetRequestsError,
  CancelSpotFleetRequestsErrorItem,
  CancelSpotFleetRequestsRequest,
  CancelSpotFleetRequestsResponse,
  CancelSpotFleetRequestsSuccessItem,
  CancelSpotInstanceRequestsRequest,
  CancelSpotInstanceRequestsResult,
  CancelledSpotInstanceRequest,
  CapacityReservation,
  CapacityReservationOptions,
  CapacityReservationOptionsRequest,
  CapacityReservationSpecification,
  CapacityReservationSpecificationResponse,
  CapacityReservationTarget,
  CapacityReservationTargetResponse,
  CertificateAuthentication,
  CertificateAuthenticationRequest,
  CidrAuthorizationContext,
  CidrBlock,
  ClassicLinkDnsSupport,
  ClassicLinkInstance,
  ClassicLoadBalancer,
  ClassicLoadBalancersConfig,
  ClientCertificateRevocationListStatus,
  ClientData,
  ClientVpnAuthentication,
  ClientVpnAuthenticationRequest,
  ClientVpnAuthorizationRuleStatus,
  ClientVpnConnection,
  ClientVpnConnectionStatus,
  ClientVpnEndpoint,
  ClientVpnEndpointStatus,
  ClientVpnRoute,
  ClientVpnRouteStatus,
  CoipAddressUsage,
  CoipPool,
  ConfirmProductInstanceRequest,
  ConfirmProductInstanceResult,
  ConnectionLogOptions,
  ConnectionLogResponseOptions,
  ConnectionNotification,
  ConversionTask,
  CopyFpgaImageRequest,
  CopyFpgaImageResult,
  CopyImageRequest,
  CopyImageResult,
  CopySnapshotRequest,
  CopySnapshotResult,
  CpuOptions,
  CpuOptionsRequest,
  CreateCapacityReservationRequest,
  CreateCapacityReservationResult,
  CreateClientVpnEndpointRequest,
  CreateClientVpnEndpointResult,
  CreateClientVpnRouteRequest,
  CreateClientVpnRouteResult,
  CreateCustomerGatewayRequest,
  CreateCustomerGatewayResult,
  CreateDefaultSubnetRequest,
  CreateDefaultSubnetResult,
  CreateDefaultVpcRequest,
  CreateDefaultVpcResult,
  CreateDhcpOptionsRequest,
  CreateDhcpOptionsResult,
  CreateEgressOnlyInternetGatewayRequest,
  CreateEgressOnlyInternetGatewayResult,
  CreateFleetError,
  CreateFleetInstance,
  CreateFleetRequest,
  CreateFleetResult,
  CreateFlowLogsRequest,
  CreateFlowLogsResult,
  CreateFpgaImageRequest,
  CreateFpgaImageResult,
  CreateImageRequest,
  CreateImageResult,
  CreateInstanceExportTaskRequest,
  CreateInstanceExportTaskResult,
  CreateInternetGatewayRequest,
  CreateInternetGatewayResult,
  CreateKeyPairRequest,
  CreateLaunchTemplateRequest,
  CreateLaunchTemplateResult,
  CreateLaunchTemplateVersionRequest,
  CreateLaunchTemplateVersionResult,
  CreateLocalGatewayRouteRequest,
  CreateLocalGatewayRouteResult,
  CreateLocalGatewayRouteTableVpcAssociationRequest,
  CreateLocalGatewayRouteTableVpcAssociationResult,
  CreateNatGatewayRequest,
  CreateNatGatewayResult,
  CreateNetworkAclEntryRequest,
  CreateNetworkAclRequest,
  CreateNetworkAclResult,
  CreateNetworkInterfacePermissionRequest,
  CreateNetworkInterfacePermissionResult,
  CreateNetworkInterfaceRequest,
  CreateNetworkInterfaceResult,
  CreatePlacementGroupRequest,
  CreateReservedInstancesListingRequest,
  CreateReservedInstancesListingResult,
  CreateRouteRequest,
  CreateRouteResult,
  CreateRouteTableRequest,
  CreateRouteTableResult,
  CreateSecurityGroupRequest,
  CreateSecurityGroupResult,
  CreateSnapshotRequest,
  CreateSnapshotsRequest,
  CreateSnapshotsResult,
  CreateSpotDatafeedSubscriptionRequest,
  CreateSpotDatafeedSubscriptionResult,
  CreateSubnetRequest,
  CreateSubnetResult,
  CreateTagsRequest,
  CreateTrafficMirrorFilterRequest,
  CreateTrafficMirrorFilterResult,
  CreateTrafficMirrorFilterRuleRequest,
  CreateTrafficMirrorFilterRuleResult,
  CreateTrafficMirrorSessionRequest,
  CreateTrafficMirrorSessionResult,
  CreateTrafficMirrorTargetRequest,
  CreateTrafficMirrorTargetResult,
  CreateTransitGatewayMulticastDomainRequest,
  CreateTransitGatewayMulticastDomainResult,
  CreateTransitGatewayPeeringAttachmentRequest,
  CreateTransitGatewayPeeringAttachmentResult,
  CreateTransitGatewayRequest,
  CreateTransitGatewayResult,
  CreateTransitGatewayRouteRequest,
  CreateTransitGatewayRouteResult,
  CreateTransitGatewayRouteTableRequest,
  CreateTransitGatewayRouteTableResult,
  CreateTransitGatewayVpcAttachmentRequest,
  CreateTransitGatewayVpcAttachmentRequestOptions,
  CreateTransitGatewayVpcAttachmentResult,
  CreateVolumePermission,
  CreateVolumePermissionModifications,
  CreateVolumeRequest,
  CreateVpcEndpointConnectionNotificationRequest,
  CreateVpcEndpointConnectionNotificationResult,
  CreateVpcEndpointRequest,
  CreateVpcEndpointResult,
  CreateVpcEndpointServiceConfigurationRequest,
  CreateVpcEndpointServiceConfigurationResult,
  CreateVpcPeeringConnectionRequest,
  CreateVpcPeeringConnectionResult,
  CreateVpcRequest,
  CreateVpcResult,
  CreateVpnConnectionRequest,
  CreateVpnConnectionResult,
  CreateVpnConnectionRouteRequest,
  CreateVpnGatewayRequest,
  CreateVpnGatewayResult,
  CreditSpecification,
  CreditSpecificationRequest,
  CustomerGateway,
  DeleteClientVpnEndpointRequest,
  DeleteClientVpnEndpointResult,
  DeleteClientVpnRouteRequest,
  DeleteClientVpnRouteResult,
  DeleteCustomerGatewayRequest,
  DeleteDhcpOptionsRequest,
  DeleteEgressOnlyInternetGatewayRequest,
  DeleteEgressOnlyInternetGatewayResult,
  DeleteFleetError,
  DeleteFleetErrorItem,
  DeleteFleetSuccessItem,
  DeleteFleetsRequest,
  DeleteFleetsResult,
  DeleteFlowLogsRequest,
  DeleteFlowLogsResult,
  DeleteFpgaImageRequest,
  DeleteFpgaImageResult,
  DeleteInternetGatewayRequest,
  DeleteKeyPairRequest,
  DeleteLaunchTemplateRequest,
  DeleteLaunchTemplateResult,
  DeleteLaunchTemplateVersionsRequest,
  DeleteLaunchTemplateVersionsResponseErrorItem,
  DeleteLaunchTemplateVersionsResponseSuccessItem,
  DeleteLaunchTemplateVersionsResult,
  DeleteLocalGatewayRouteRequest,
  DeleteLocalGatewayRouteResult,
  DeleteLocalGatewayRouteTableVpcAssociationRequest,
  DeleteLocalGatewayRouteTableVpcAssociationResult,
  DeleteNatGatewayRequest,
  DeleteNatGatewayResult,
  DeleteNetworkAclEntryRequest,
  DeleteNetworkAclRequest,
  DeleteNetworkInterfacePermissionRequest,
  DeleteNetworkInterfacePermissionResult,
  DeleteNetworkInterfaceRequest,
  DeletePlacementGroupRequest,
  DeleteQueuedReservedInstancesError,
  DeleteQueuedReservedInstancesRequest,
  DeleteQueuedReservedInstancesResult,
  DeleteRouteRequest,
  DeleteRouteTableRequest,
  DeleteSecurityGroupRequest,
  DeleteSnapshotRequest,
  DeleteSpotDatafeedSubscriptionRequest,
  DeleteSubnetRequest,
  DeleteTagsRequest,
  DeleteTrafficMirrorFilterRequest,
  DeleteTrafficMirrorFilterResult,
  DeleteTrafficMirrorFilterRuleRequest,
  DeleteTrafficMirrorFilterRuleResult,
  DeleteTrafficMirrorSessionRequest,
  DeleteTrafficMirrorSessionResult,
  DeleteTrafficMirrorTargetRequest,
  DeleteTrafficMirrorTargetResult,
  DeleteTransitGatewayMulticastDomainRequest,
  DeleteTransitGatewayMulticastDomainResult,
  DeleteTransitGatewayPeeringAttachmentRequest,
  DeleteTransitGatewayPeeringAttachmentResult,
  DeleteTransitGatewayRequest,
  DeleteTransitGatewayResult,
  DeleteTransitGatewayRouteRequest,
  DeleteTransitGatewayRouteResult,
  DeleteTransitGatewayRouteTableRequest,
  DeleteTransitGatewayRouteTableResult,
  DeleteTransitGatewayVpcAttachmentRequest,
  DeleteTransitGatewayVpcAttachmentResult,
  DeleteVolumeRequest,
  DeleteVpcEndpointConnectionNotificationsRequest,
  DeleteVpcEndpointConnectionNotificationsResult,
  DeleteVpcEndpointServiceConfigurationsRequest,
  DeleteVpcEndpointServiceConfigurationsResult,
  DeleteVpcEndpointsRequest,
  DeleteVpcEndpointsResult,
  DeleteVpcPeeringConnectionRequest,
  DeleteVpcPeeringConnectionResult,
  DeleteVpcRequest,
  DeleteVpnConnectionRequest,
  DeleteVpnConnectionRouteRequest,
  DeleteVpnGatewayRequest,
  DeprovisionByoipCidrRequest,
  DeprovisionByoipCidrResult,
  DeregisterImageRequest,
  DeregisterTransitGatewayMulticastGroupMembersRequest,
  DeregisterTransitGatewayMulticastGroupMembersResult,
  DeregisterTransitGatewayMulticastGroupSourcesRequest,
  DeregisterTransitGatewayMulticastGroupSourcesResult,
  DescribeAccountAttributesRequest,
  DescribeAccountAttributesResult,
  DescribeAddressesRequest,
  DescribeAddressesResult,
  DescribeAggregateIdFormatRequest,
  DescribeAggregateIdFormatResult,
  DescribeAvailabilityZonesRequest,
  DescribeAvailabilityZonesResult,
  DescribeBundleTasksRequest,
  DescribeBundleTasksResult,
  DescribeByoipCidrsRequest,
  DescribeByoipCidrsResult,
  DescribeCapacityReservationsRequest,
  DescribeCapacityReservationsResult,
  DescribeClassicLinkInstancesRequest,
  DescribeClassicLinkInstancesResult,
  DescribeClientVpnAuthorizationRulesRequest,
  DescribeClientVpnAuthorizationRulesResult,
  DescribeClientVpnConnectionsRequest,
  DescribeClientVpnConnectionsResult,
  DescribeClientVpnEndpointsRequest,
  DescribeClientVpnEndpointsResult,
  DescribeClientVpnRoutesRequest,
  DescribeClientVpnRoutesResult,
  DescribeClientVpnTargetNetworksRequest,
  DescribeClientVpnTargetNetworksResult,
  DescribeCoipPoolsRequest,
  DescribeCoipPoolsResult,
  DescribeConversionTasksRequest,
  DescribeConversionTasksResult,
  DescribeCustomerGatewaysRequest,
  DescribeCustomerGatewaysResult,
  DescribeDhcpOptionsRequest,
  DescribeDhcpOptionsResult,
  DescribeEgressOnlyInternetGatewaysRequest,
  DescribeEgressOnlyInternetGatewaysResult,
  DescribeElasticGpusRequest,
  DescribeElasticGpusResult,
  DescribeExportImageTasksRequest,
  DescribeExportImageTasksResult,
  DescribeExportTasksRequest,
  DescribeExportTasksResult,
  DescribeFastSnapshotRestoreSuccessItem,
  DescribeFastSnapshotRestoresRequest,
  DescribeFastSnapshotRestoresResult,
  DescribeFleetError,
  DescribeFleetHistoryRequest,
  DescribeFleetHistoryResult,
  DescribeFleetInstancesRequest,
  DescribeFleetInstancesResult,
  DescribeFleetsInstances,
  DescribeFleetsRequest,
  DescribeFleetsResult,
  DescribeFlowLogsRequest,
  DescribeFlowLogsResult,
  DescribeFpgaImageAttributeRequest,
  DescribeFpgaImageAttributeResult,
  DescribeFpgaImagesRequest,
  DescribeFpgaImagesResult,
  DescribeHostReservationOfferingsRequest,
  DescribeHostReservationOfferingsResult,
  DescribeHostReservationsRequest,
  DescribeHostReservationsResult,
  DescribeHostsRequest,
  DescribeHostsResult,
  DescribeIamInstanceProfileAssociationsRequest,
  DescribeIamInstanceProfileAssociationsResult,
  DescribeIdFormatRequest,
  DescribeIdFormatResult,
  DescribeIdentityIdFormatRequest,
  DescribeIdentityIdFormatResult,
  DescribeImageAttributeRequest,
  DescribeImagesRequest,
  DescribeImagesResult,
  DescribeImportImageTasksRequest,
  DescribeImportImageTasksResult,
  DescribeImportSnapshotTasksRequest,
  DescribeImportSnapshotTasksResult,
  DescribeInstanceAttributeRequest,
  DescribeInstanceCreditSpecificationsRequest,
  DescribeInstanceCreditSpecificationsResult,
  DescribeInstanceStatusRequest,
  DescribeInstanceStatusResult,
  DescribeInstanceTypeOfferingsRequest,
  DescribeInstanceTypeOfferingsResult,
  DescribeInstanceTypesRequest,
  DescribeInstanceTypesResult,
  DescribeInstancesRequest,
  DescribeInstancesResult,
  DescribeInternetGatewaysRequest,
  DescribeInternetGatewaysResult,
  DescribeIpv6PoolsRequest,
  DescribeIpv6PoolsResult,
  DescribeKeyPairsRequest,
  DescribeKeyPairsResult,
  DescribeLaunchTemplateVersionsRequest,
  DescribeLaunchTemplateVersionsResult,
  DescribeLaunchTemplatesRequest,
  DescribeLaunchTemplatesResult,
  DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsRequest,
  DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsResult,
  DescribeLocalGatewayRouteTableVpcAssociationsRequest,
  DescribeLocalGatewayRouteTableVpcAssociationsResult,
  DescribeLocalGatewayRouteTablesRequest,
  DescribeLocalGatewayRouteTablesResult,
  DescribeLocalGatewayVirtualInterfaceGroupsRequest,
  DescribeLocalGatewayVirtualInterfaceGroupsResult,
  DescribeLocalGatewayVirtualInterfacesRequest,
  DescribeLocalGatewayVirtualInterfacesResult,
  DescribeLocalGatewaysRequest,
  DescribeLocalGatewaysResult,
  DescribeMovingAddressesRequest,
  DescribeMovingAddressesResult,
  DescribeNatGatewaysRequest,
  DescribeNatGatewaysResult,
  DescribeNetworkAclsRequest,
  DescribeNetworkAclsResult,
  DescribeNetworkInterfaceAttributeRequest,
  DescribeNetworkInterfaceAttributeResult,
  DescribeNetworkInterfacePermissionsRequest,
  DescribeNetworkInterfacePermissionsResult,
  DescribeNetworkInterfacesRequest,
  DescribeNetworkInterfacesResult,
  DescribePlacementGroupsRequest,
  DescribePlacementGroupsResult,
  DescribePrefixListsRequest,
  DescribePrefixListsResult,
  DescribePrincipalIdFormatRequest,
  DescribePrincipalIdFormatResult,
  DescribePublicIpv4PoolsRequest,
  DescribePublicIpv4PoolsResult,
  DescribeRegionsRequest,
  DescribeRegionsResult,
  DescribeReservedInstancesListingsRequest,
  DescribeReservedInstancesListingsResult,
  DescribeReservedInstancesModificationsRequest,
  DescribeReservedInstancesModificationsResult,
  DescribeReservedInstancesOfferingsRequest,
  DescribeReservedInstancesOfferingsResult,
  DescribeReservedInstancesRequest,
  DescribeReservedInstancesResult,
  DescribeRouteTablesRequest,
  DescribeRouteTablesResult,
  DescribeScheduledInstanceAvailabilityRequest,
  DescribeScheduledInstanceAvailabilityResult,
  DescribeScheduledInstancesRequest,
  DescribeScheduledInstancesResult,
  DescribeSecurityGroupReferencesRequest,
  DescribeSecurityGroupReferencesResult,
  DescribeSecurityGroupsRequest,
  DescribeSecurityGroupsResult,
  DescribeSnapshotAttributeRequest,
  DescribeSnapshotAttributeResult,
  DescribeSnapshotsRequest,
  DescribeSnapshotsResult,
  DescribeSpotDatafeedSubscriptionRequest,
  DescribeSpotDatafeedSubscriptionResult,
  DescribeSpotFleetInstancesRequest,
  DescribeSpotFleetInstancesResponse,
  DescribeSpotFleetRequestHistoryRequest,
  DescribeSpotFleetRequestHistoryResponse,
  DescribeSpotFleetRequestsRequest,
  DescribeSpotFleetRequestsResponse,
  DescribeSpotInstanceRequestsRequest,
  DescribeSpotInstanceRequestsResult,
  DescribeSpotPriceHistoryRequest,
  DescribeSpotPriceHistoryResult,
  DescribeStaleSecurityGroupsRequest,
  DescribeStaleSecurityGroupsResult,
  DescribeSubnetsRequest,
  DescribeSubnetsResult,
  DescribeTagsRequest,
  DescribeTagsResult,
  DescribeTrafficMirrorFiltersRequest,
  DescribeTrafficMirrorFiltersResult,
  DescribeTrafficMirrorSessionsRequest,
  DescribeTrafficMirrorSessionsResult,
  DescribeTrafficMirrorTargetsRequest,
  DescribeTrafficMirrorTargetsResult,
  DescribeTransitGatewayAttachmentsRequest,
  DescribeTransitGatewayAttachmentsResult,
  DescribeTransitGatewayMulticastDomainsRequest,
  DescribeTransitGatewayMulticastDomainsResult,
  DescribeTransitGatewayPeeringAttachmentsRequest,
  DescribeTransitGatewayPeeringAttachmentsResult,
  DescribeTransitGatewayRouteTablesRequest,
  DescribeTransitGatewayRouteTablesResult,
  DescribeTransitGatewayVpcAttachmentsRequest,
  DescribeTransitGatewayVpcAttachmentsResult,
  DescribeTransitGatewaysRequest,
  DescribeTransitGatewaysResult,
  DescribeVolumeAttributeRequest,
  DescribeVolumeAttributeResult,
  DescribeVolumeStatusRequest,
  DescribeVolumeStatusResult,
  DescribeVolumesModificationsRequest,
  DescribeVolumesModificationsResult,
  DescribeVolumesRequest,
  DescribeVolumesResult,
  DescribeVpcAttributeRequest,
  DescribeVpcAttributeResult,
  DescribeVpcClassicLinkDnsSupportRequest,
  DescribeVpcClassicLinkDnsSupportResult,
  DescribeVpcClassicLinkRequest,
  DescribeVpcClassicLinkResult,
  DescribeVpcEndpointConnectionNotificationsRequest,
  DescribeVpcEndpointConnectionNotificationsResult,
  DescribeVpcEndpointConnectionsRequest,
  DescribeVpcEndpointConnectionsResult,
  DescribeVpcEndpointServiceConfigurationsRequest,
  DescribeVpcEndpointServiceConfigurationsResult,
  DescribeVpcEndpointServicePermissionsRequest,
  DescribeVpcEndpointServicePermissionsResult,
  DescribeVpcEndpointServicesRequest,
  DescribeVpcEndpointServicesResult,
  DescribeVpcEndpointsRequest,
  DescribeVpcEndpointsResult,
  DescribeVpcPeeringConnectionsRequest,
  DescribeVpcPeeringConnectionsResult,
  DescribeVpcsRequest,
  DescribeVpcsResult,
  DescribeVpnConnectionsRequest,
  DescribeVpnConnectionsResult,
  DescribeVpnGatewaysRequest,
  DescribeVpnGatewaysResult,
  DetachClassicLinkVpcRequest,
  DetachClassicLinkVpcResult,
  DetachInternetGatewayRequest,
  DetachNetworkInterfaceRequest,
  DetachVolumeRequest,
  DetachVpnGatewayRequest,
  DhcpConfiguration,
  DhcpOptions,
  DirectoryServiceAuthentication,
  DirectoryServiceAuthenticationRequest,
  DisableEbsEncryptionByDefaultRequest,
  DisableEbsEncryptionByDefaultResult,
  DisableFastSnapshotRestoreErrorItem,
  DisableFastSnapshotRestoreStateError,
  DisableFastSnapshotRestoreStateErrorItem,
  DisableFastSnapshotRestoreSuccessItem,
  DisableFastSnapshotRestoresRequest,
  DisableFastSnapshotRestoresResult,
  DisableTransitGatewayRouteTablePropagationRequest,
  DisableTransitGatewayRouteTablePropagationResult,
  DisableVgwRoutePropagationRequest,
  DisableVpcClassicLinkDnsSupportRequest,
  DisableVpcClassicLinkDnsSupportResult,
  DisableVpcClassicLinkRequest,
  DisableVpcClassicLinkResult,
  DisassociateAddressRequest,
  DisassociateClientVpnTargetNetworkRequest,
  DisassociateClientVpnTargetNetworkResult,
  DisassociateIamInstanceProfileRequest,
  DisassociateIamInstanceProfileResult,
  DisassociateRouteTableRequest,
  DisassociateSubnetCidrBlockRequest,
  DisassociateSubnetCidrBlockResult,
  DisassociateTransitGatewayMulticastDomainRequest,
  DisassociateTransitGatewayMulticastDomainResult,
  DisassociateTransitGatewayRouteTableRequest,
  DisassociateTransitGatewayRouteTableResult,
  DisassociateVpcCidrBlockRequest,
  DisassociateVpcCidrBlockResult,
  DiskImage,
  DiskImageDescription,
  DiskImageDetail,
  DiskImageVolumeDescription,
  DiskInfo,
  DnsEntry,
  DnsServersOptionsModifyStructure,
  EbsBlockDevice,
  EbsInfo,
  EbsInstanceBlockDevice,
  EbsInstanceBlockDeviceSpecification,
  EgressOnlyInternetGateway,
  ElasticGpuAssociation,
  ElasticGpuHealth,
  ElasticGpuSpecification,
  ElasticGpuSpecificationResponse,
  ElasticGpus,
  ElasticInferenceAccelerator,
  ElasticInferenceAcceleratorAssociation,
  EnableEbsEncryptionByDefaultRequest,
  EnableEbsEncryptionByDefaultResult,
  EnableFastSnapshotRestoreErrorItem,
  EnableFastSnapshotRestoreStateError,
  EnableFastSnapshotRestoreStateErrorItem,
  EnableFastSnapshotRestoreSuccessItem,
  EnableFastSnapshotRestoresRequest,
  EnableFastSnapshotRestoresResult,
  EnableTransitGatewayRouteTablePropagationRequest,
  EnableTransitGatewayRouteTablePropagationResult,
  EnableVgwRoutePropagationRequest,
  EnableVolumeIORequest,
  EnableVpcClassicLinkDnsSupportRequest,
  EnableVpcClassicLinkDnsSupportResult,
  EnableVpcClassicLinkRequest,
  EnableVpcClassicLinkResult,
  EventInformation,
  ExportClientVpnClientCertificateRevocationListRequest,
  ExportClientVpnClientCertificateRevocationListResult,
  ExportClientVpnClientConfigurationRequest,
  ExportClientVpnClientConfigurationResult,
  ExportImageRequest,
  ExportImageResult,
  ExportImageTask,
  ExportTask,
  ExportTaskS3Location,
  ExportTaskS3LocationRequest,
  ExportToS3Task,
  ExportToS3TaskSpecification,
  ExportTransitGatewayRoutesRequest,
  ExportTransitGatewayRoutesResult,
  FailedQueuedPurchaseDeletion,
  Filter,
  FleetData,
  FleetLaunchTemplateConfig,
  FleetLaunchTemplateConfigRequest,
  FleetLaunchTemplateOverrides,
  FleetLaunchTemplateOverridesRequest,
  FleetLaunchTemplateSpecification,
  FleetLaunchTemplateSpecificationRequest,
  FlowLog,
  FpgaDeviceInfo,
  FpgaDeviceMemoryInfo,
  FpgaImage,
  FpgaImageAttribute,
  FpgaImageState,
  FpgaInfo,
  GetAssociatedIpv6PoolCidrsRequest,
  GetAssociatedIpv6PoolCidrsResult,
  GetCapacityReservationUsageRequest,
  GetCapacityReservationUsageResult,
  GetCoipPoolUsageRequest,
  GetCoipPoolUsageResult,
  GetConsoleOutputRequest,
  GetConsoleOutputResult,
  GetConsoleScreenshotRequest,
  GetConsoleScreenshotResult,
  GetDefaultCreditSpecificationRequest,
  GetDefaultCreditSpecificationResult,
  GetEbsDefaultKmsKeyIdRequest,
  GetEbsDefaultKmsKeyIdResult,
  GetEbsEncryptionByDefaultRequest,
  GetEbsEncryptionByDefaultResult,
  GetHostReservationPurchasePreviewRequest,
  GetHostReservationPurchasePreviewResult,
  GetLaunchTemplateDataRequest,
  GetLaunchTemplateDataResult,
  GetPasswordDataRequest,
  GetPasswordDataResult,
  GetReservedInstancesExchangeQuoteRequest,
  GetReservedInstancesExchangeQuoteResult,
  GetTransitGatewayAttachmentPropagationsRequest,
  GetTransitGatewayAttachmentPropagationsResult,
  GetTransitGatewayMulticastDomainAssociationsRequest,
  GetTransitGatewayMulticastDomainAssociationsResult,
  GetTransitGatewayRouteTableAssociationsRequest,
  GetTransitGatewayRouteTableAssociationsResult,
  GetTransitGatewayRouteTablePropagationsRequest,
  GetTransitGatewayRouteTablePropagationsResult,
  GpuDeviceInfo,
  GpuDeviceMemoryInfo,
  GpuInfo,
  GroupIdentifier,
  HibernationOptions,
  HibernationOptionsRequest,
  HistoryRecord,
  HistoryRecordEntry,
  Host,
  HostInstance,
  HostOffering,
  HostProperties,
  HostReservation,
  IKEVersionsListValue,
  IKEVersionsRequestListValue,
  IamInstanceProfile,
  IamInstanceProfileAssociation,
  IamInstanceProfileSpecification,
  IcmpTypeCode,
  IdFormat,
  Image,
  ImageAttribute,
  ImageDiskContainer,
  ImportClientVpnClientCertificateRevocationListRequest,
  ImportClientVpnClientCertificateRevocationListResult,
  ImportImageLicenseConfigurationRequest,
  ImportImageLicenseConfigurationResponse,
  ImportImageRequest,
  ImportImageResult,
  ImportImageTask,
  ImportInstanceLaunchSpecification,
  ImportInstanceRequest,
  ImportInstanceResult,
  ImportInstanceTaskDetails,
  ImportInstanceVolumeDetailItem,
  ImportKeyPairRequest,
  ImportKeyPairResult,
  ImportSnapshotRequest,
  ImportSnapshotResult,
  ImportSnapshotTask,
  ImportVolumeRequest,
  ImportVolumeResult,
  ImportVolumeTaskDetails,
  InferenceAcceleratorInfo,
  InferenceDeviceInfo,
  Instance,
  InstanceAttribute,
  InstanceBlockDeviceMapping,
  InstanceBlockDeviceMappingSpecification,
  InstanceCapacity,
  InstanceCount,
  InstanceCreditSpecification,
  InstanceCreditSpecificationRequest,
  InstanceExportDetails,
  InstanceFamilyCreditSpecification,
  InstanceIpv6Address,
  InstanceIpv6AddressRequest,
  InstanceMarketOptionsRequest,
  InstanceMetadataOptionsRequest,
  InstanceMetadataOptionsResponse,
  InstanceMonitoring,
  InstanceNetworkInterface,
  InstanceNetworkInterfaceAssociation,
  InstanceNetworkInterfaceAttachment,
  InstanceNetworkInterfaceSpecification,
  InstancePrivateIpAddress,
  InstanceSpecification,
  InstanceState,
  InstanceStateChange,
  InstanceStatus,
  InstanceStatusDetails,
  InstanceStatusEvent,
  InstanceStatusSummary,
  InstanceStorageInfo,
  InstanceTypeInfo,
  InstanceTypeOffering,
  InstanceUsage,
  InternetGateway,
  InternetGatewayAttachment,
  IpPermission,
  IpRange,
  Ipv6CidrAssociation,
  Ipv6CidrBlock,
  Ipv6Pool,
  Ipv6Range,
  KeyPair,
  KeyPairInfo,
  LastError,
  LaunchPermission,
  LaunchPermissionModifications,
  LaunchSpecification,
  LaunchTemplate,
  LaunchTemplateAndOverridesResponse,
  LaunchTemplateBlockDeviceMapping,
  LaunchTemplateBlockDeviceMappingRequest,
  LaunchTemplateCapacityReservationSpecificationRequest,
  LaunchTemplateCapacityReservationSpecificationResponse,
  LaunchTemplateConfig,
  LaunchTemplateCpuOptions,
  LaunchTemplateCpuOptionsRequest,
  LaunchTemplateEbsBlockDevice,
  LaunchTemplateEbsBlockDeviceRequest,
  LaunchTemplateElasticInferenceAccelerator,
  LaunchTemplateElasticInferenceAcceleratorResponse,
  LaunchTemplateHibernationOptions,
  LaunchTemplateHibernationOptionsRequest,
  LaunchTemplateIamInstanceProfileSpecification,
  LaunchTemplateIamInstanceProfileSpecificationRequest,
  LaunchTemplateInstanceMarketOptions,
  LaunchTemplateInstanceMarketOptionsRequest,
  LaunchTemplateInstanceMetadataOptions,
  LaunchTemplateInstanceMetadataOptionsRequest,
  LaunchTemplateInstanceNetworkInterfaceSpecification,
  LaunchTemplateInstanceNetworkInterfaceSpecificationRequest,
  LaunchTemplateLicenseConfiguration,
  LaunchTemplateLicenseConfigurationRequest,
  LaunchTemplateOverrides,
  LaunchTemplatePlacement,
  LaunchTemplatePlacementRequest,
  LaunchTemplateSpecification,
  LaunchTemplateSpotMarketOptions,
  LaunchTemplateSpotMarketOptionsRequest,
  LaunchTemplateTagSpecification,
  LaunchTemplateTagSpecificationRequest,
  LaunchTemplateVersion,
  LaunchTemplatesMonitoring,
  LaunchTemplatesMonitoringRequest,
  LicenseConfiguration,
  LicenseConfigurationRequest,
  LoadBalancersConfig,
  LoadPermission,
  LoadPermissionModifications,
  LoadPermissionRequest,
  LocalGateway,
  LocalGatewayRoute,
  LocalGatewayRouteTable,
  LocalGatewayRouteTableVirtualInterfaceGroupAssociation,
  LocalGatewayRouteTableVpcAssociation,
  LocalGatewayVirtualInterface,
  LocalGatewayVirtualInterfaceGroup,
  MemoryInfo,
  ModifyCapacityReservationRequest,
  ModifyCapacityReservationResult,
  ModifyClientVpnEndpointRequest,
  ModifyClientVpnEndpointResult,
  ModifyDefaultCreditSpecificationRequest,
  ModifyDefaultCreditSpecificationResult,
  ModifyEbsDefaultKmsKeyIdRequest,
  ModifyEbsDefaultKmsKeyIdResult,
  ModifyFleetRequest,
  ModifyFleetResult,
  ModifyFpgaImageAttributeRequest,
  ModifyFpgaImageAttributeResult,
  ModifyHostsRequest,
  ModifyHostsResult,
  ModifyIdFormatRequest,
  ModifyIdentityIdFormatRequest,
  ModifyImageAttributeRequest,
  ModifyInstanceAttributeRequest,
  ModifyInstanceCapacityReservationAttributesRequest,
  ModifyInstanceCapacityReservationAttributesResult,
  ModifyInstanceCreditSpecificationRequest,
  ModifyInstanceCreditSpecificationResult,
  ModifyInstanceEventStartTimeRequest,
  ModifyInstanceEventStartTimeResult,
  ModifyInstanceMetadataOptionsRequest,
  ModifyInstanceMetadataOptionsResult,
  ModifyInstancePlacementRequest,
  ModifyInstancePlacementResult,
  ModifyLaunchTemplateRequest,
  ModifyLaunchTemplateResult,
  ModifyNetworkInterfaceAttributeRequest,
  ModifyReservedInstancesRequest,
  ModifyReservedInstancesResult,
  ModifySnapshotAttributeRequest,
  ModifySpotFleetRequestRequest,
  ModifySpotFleetRequestResponse,
  ModifySubnetAttributeRequest,
  ModifyTrafficMirrorFilterNetworkServicesRequest,
  ModifyTrafficMirrorFilterNetworkServicesResult,
  ModifyTrafficMirrorFilterRuleRequest,
  ModifyTrafficMirrorFilterRuleResult,
  ModifyTrafficMirrorSessionRequest,
  ModifyTrafficMirrorSessionResult,
  ModifyTransitGatewayVpcAttachmentRequest,
  ModifyTransitGatewayVpcAttachmentRequestOptions,
  ModifyTransitGatewayVpcAttachmentResult,
  ModifyVolumeAttributeRequest,
  ModifyVolumeRequest,
  ModifyVolumeResult,
  ModifyVpcAttributeRequest,
  ModifyVpcEndpointConnectionNotificationRequest,
  ModifyVpcEndpointConnectionNotificationResult,
  ModifyVpcEndpointRequest,
  ModifyVpcEndpointResult,
  ModifyVpcEndpointServiceConfigurationRequest,
  ModifyVpcEndpointServiceConfigurationResult,
  ModifyVpcEndpointServicePermissionsRequest,
  ModifyVpcEndpointServicePermissionsResult,
  ModifyVpcPeeringConnectionOptionsRequest,
  ModifyVpcPeeringConnectionOptionsResult,
  ModifyVpcTenancyRequest,
  ModifyVpcTenancyResult,
  ModifyVpnConnectionRequest,
  ModifyVpnConnectionResult,
  ModifyVpnTunnelCertificateRequest,
  ModifyVpnTunnelCertificateResult,
  ModifyVpnTunnelOptionsRequest,
  ModifyVpnTunnelOptionsResult,
  ModifyVpnTunnelOptionsSpecification,
  MonitorInstancesRequest,
  MonitorInstancesResult,
  Monitoring,
  MoveAddressToVpcRequest,
  MoveAddressToVpcResult,
  MovingAddressStatus,
  NatGateway,
  NatGatewayAddress,
  NetworkAcl,
  NetworkAclAssociation,
  NetworkAclEntry,
  NetworkInfo,
  NetworkInterface,
  NetworkInterfaceAssociation,
  NetworkInterfaceAttachment,
  NetworkInterfaceAttachmentChanges,
  NetworkInterfaceIpv6Address,
  NetworkInterfacePermission,
  NetworkInterfacePermissionState,
  NetworkInterfacePrivateIpAddress,
  NewDhcpConfiguration,
  OnDemandOptions,
  OnDemandOptionsRequest,
  PciId,
  PeeringAttachmentStatus,
  PeeringConnectionOptions,
  PeeringConnectionOptionsRequest,
  PeeringTgwInfo,
  Phase1DHGroupNumbersListValue,
  Phase1DHGroupNumbersRequestListValue,
  Phase1EncryptionAlgorithmsListValue,
  Phase1EncryptionAlgorithmsRequestListValue,
  Phase1IntegrityAlgorithmsListValue,
  Phase1IntegrityAlgorithmsRequestListValue,
  Phase2DHGroupNumbersListValue,
  Phase2DHGroupNumbersRequestListValue,
  Phase2EncryptionAlgorithmsListValue,
  Phase2EncryptionAlgorithmsRequestListValue,
  Phase2IntegrityAlgorithmsListValue,
  Phase2IntegrityAlgorithmsRequestListValue,
  Placement,
  PlacementGroup,
  PlacementGroupInfo,
  PlacementGroupStrategy,
  PlacementResponse,
  PoolCidrBlock,
  PortRange,
  PrefixList,
  PrefixListId,
  PriceSchedule,
  PriceScheduleSpecification,
  PricingDetail,
  PrincipalIdFormat,
  PrivateDnsNameConfiguration,
  PrivateIpAddressSpecification,
  ProcessorInfo,
  ProductCode,
  PropagatingVgw,
  ProvisionByoipCidrRequest,
  ProvisionByoipCidrResult,
  ProvisionedBandwidth,
  PublicIpv4Pool,
  PublicIpv4PoolRange,
  Purchase,
  PurchaseHostReservationRequest,
  PurchaseHostReservationResult,
  PurchaseRequest,
  PurchaseReservedInstancesOfferingRequest,
  PurchaseReservedInstancesOfferingResult,
  PurchaseScheduledInstancesRequest,
  PurchaseScheduledInstancesResult,
  RebootInstancesRequest,
  RecurringCharge,
  Region,
  RegisterImageRequest,
  RegisterImageResult,
  RegisterTransitGatewayMulticastGroupMembersRequest,
  RegisterTransitGatewayMulticastGroupMembersResult,
  RegisterTransitGatewayMulticastGroupSourcesRequest,
  RegisterTransitGatewayMulticastGroupSourcesResult,
  RejectTransitGatewayPeeringAttachmentRequest,
  RejectTransitGatewayPeeringAttachmentResult,
  RejectTransitGatewayVpcAttachmentRequest,
  RejectTransitGatewayVpcAttachmentResult,
  RejectVpcEndpointConnectionsRequest,
  RejectVpcEndpointConnectionsResult,
  RejectVpcPeeringConnectionRequest,
  RejectVpcPeeringConnectionResult,
  ReleaseAddressRequest,
  ReleaseHostsRequest,
  ReleaseHostsResult,
  ReplaceIamInstanceProfileAssociationRequest,
  ReplaceIamInstanceProfileAssociationResult,
  ReplaceNetworkAclAssociationRequest,
  ReplaceNetworkAclAssociationResult,
  ReplaceNetworkAclEntryRequest,
  ReplaceRouteRequest,
  ReplaceRouteTableAssociationRequest,
  ReplaceRouteTableAssociationResult,
  ReplaceTransitGatewayRouteRequest,
  ReplaceTransitGatewayRouteResult,
  ReportInstanceReasonCodes,
  ReportInstanceStatusRequest,
  RequestLaunchTemplateData,
  RequestSpotFleetRequest,
  RequestSpotFleetResponse,
  RequestSpotInstancesRequest,
  RequestSpotInstancesResult,
  RequestSpotLaunchSpecification,
  Reservation,
  ReservationValue,
  ReservedInstanceLimitPrice,
  ReservedInstanceReservationValue,
  ReservedInstances,
  ReservedInstancesConfiguration,
  ReservedInstancesId,
  ReservedInstancesListing,
  ReservedInstancesModification,
  ReservedInstancesModificationResult,
  ReservedInstancesOffering,
  ResetEbsDefaultKmsKeyIdRequest,
  ResetEbsDefaultKmsKeyIdResult,
  ResetFpgaImageAttributeRequest,
  ResetFpgaImageAttributeResult,
  ResetImageAttributeRequest,
  ResetInstanceAttributeRequest,
  ResetNetworkInterfaceAttributeRequest,
  ResetSnapshotAttributeRequest,
  ResponseError,
  ResponseLaunchTemplateData,
  RestoreAddressToClassicRequest,
  RestoreAddressToClassicResult,
  RevokeClientVpnIngressRequest,
  RevokeClientVpnIngressResult,
  RevokeSecurityGroupEgressRequest,
  RevokeSecurityGroupIngressRequest,
  RootDeviceType,
  Route,
  RouteTable,
  RouteTableAssociation,
  RouteTableAssociationState,
  RunInstancesMonitoringEnabled,
  RunInstancesRequest,
  RunScheduledInstancesRequest,
  RunScheduledInstancesResult,
  S3Storage,
  ScheduledInstance,
  ScheduledInstanceAvailability,
  ScheduledInstanceRecurrence,
  ScheduledInstanceRecurrenceRequest,
  ScheduledInstancesBlockDeviceMapping,
  ScheduledInstancesEbs,
  ScheduledInstancesIamInstanceProfile,
  ScheduledInstancesIpv6Address,
  ScheduledInstancesLaunchSpecification,
  ScheduledInstancesMonitoring,
  ScheduledInstancesNetworkInterface,
  ScheduledInstancesPlacement,
  ScheduledInstancesPrivateIpAddressConfig,
  SearchLocalGatewayRoutesRequest,
  SearchLocalGatewayRoutesResult,
  SearchTransitGatewayMulticastGroupsRequest,
  SearchTransitGatewayMulticastGroupsResult,
  SearchTransitGatewayRoutesRequest,
  SearchTransitGatewayRoutesResult,
  SecurityGroup,
  SecurityGroupIdentifier,
  SecurityGroupReference,
  SendDiagnosticInterruptRequest,
  ServiceConfiguration,
  ServiceDetail,
  ServiceTypeDetail,
  SlotDateTimeRangeRequest,
  SlotStartTimeRangeRequest,
  Snapshot,
  SnapshotDetail,
  SnapshotDiskContainer,
  SnapshotInfo,
  SnapshotTaskDetail,
  SpotDatafeedSubscription,
  SpotFleetLaunchSpecification,
  SpotFleetMonitoring,
  SpotFleetRequestConfig,
  SpotFleetRequestConfigData,
  SpotFleetTagSpecification,
  SpotInstanceRequest,
  SpotInstanceStateFault,
  SpotInstanceStatus,
  SpotMarketOptions,
  SpotOptions,
  SpotOptionsRequest,
  SpotPlacement,
  SpotPrice,
  StaleIpPermission,
  StaleSecurityGroup,
  StartInstancesRequest,
  StartInstancesResult,
  StartVpcEndpointServicePrivateDnsVerificationRequest,
  StartVpcEndpointServicePrivateDnsVerificationResult,
  StateReason,
  StopInstancesRequest,
  StopInstancesResult,
  Storage,
  StorageLocation,
  Subnet,
  SubnetAssociation,
  SubnetCidrBlockState,
  SubnetIpv6CidrBlockAssociation,
  SuccessfulInstanceCreditSpecificationItem,
  SuccessfulQueuedPurchaseDeletion,
  Tag,
  TagDescription,
  TagSpecification,
  TargetCapacitySpecification,
  TargetCapacitySpecificationRequest,
  TargetConfiguration,
  TargetConfigurationRequest,
  TargetGroup,
  TargetGroupsConfig,
  TargetNetwork,
  TargetReservationValue,
  TerminateClientVpnConnectionsRequest,
  TerminateClientVpnConnectionsResult,
  TerminateConnectionStatus,
  TerminateInstancesRequest,
  TerminateInstancesResult,
  TrafficMirrorFilter,
  TrafficMirrorFilterRule,
  TrafficMirrorFilterRuleField,
  TrafficMirrorNetworkService,
  TrafficMirrorPortRange,
  TrafficMirrorPortRangeRequest,
  TrafficMirrorSession,
  TrafficMirrorSessionField,
  TrafficMirrorTarget,
  TransitGateway,
  TransitGatewayAssociation,
  TransitGatewayAttachment,
  TransitGatewayAttachmentAssociation,
  TransitGatewayAttachmentPropagation,
  TransitGatewayMulticastDeregisteredGroupMembers,
  TransitGatewayMulticastDeregisteredGroupSources,
  TransitGatewayMulticastDomain,
  TransitGatewayMulticastDomainAssociation,
  TransitGatewayMulticastDomainAssociations,
  TransitGatewayMulticastGroup,
  TransitGatewayMulticastRegisteredGroupMembers,
  TransitGatewayMulticastRegisteredGroupSources,
  TransitGatewayOptions,
  TransitGatewayPeeringAttachment,
  TransitGatewayPropagation,
  TransitGatewayRequestOptions,
  TransitGatewayRoute,
  TransitGatewayRouteAttachment,
  TransitGatewayRouteTable,
  TransitGatewayRouteTableAssociation,
  TransitGatewayRouteTablePropagation,
  TransitGatewayVpcAttachment,
  TransitGatewayVpcAttachmentOptions,
  TunnelOption,
  UnassignIpv6AddressesRequest,
  UnassignIpv6AddressesResult,
  UnassignPrivateIpAddressesRequest,
  UnmonitorInstancesRequest,
  UnmonitorInstancesResult,
  UnsuccessfulInstanceCreditSpecificationItem,
  UnsuccessfulInstanceCreditSpecificationItemError,
  UnsuccessfulItem,
  UnsuccessfulItemError,
  UpdateSecurityGroupRuleDescriptionsEgressRequest,
  UpdateSecurityGroupRuleDescriptionsEgressResult,
  UpdateSecurityGroupRuleDescriptionsIngressRequest,
  UpdateSecurityGroupRuleDescriptionsIngressResult,
  UsageClassType,
  UserBucket,
  UserBucketDetails,
  UserData,
  UserIdGroupPair,
  VCpuInfo,
  VgwTelemetry,
  Volume,
  VolumeAttachment,
  VolumeDetail,
  VolumeModification,
  VolumeStatusAction,
  VolumeStatusDetails,
  VolumeStatusEvent,
  VolumeStatusInfo,
  VolumeStatusItem,
  Vpc,
  VpcAttachment,
  VpcCidrBlockAssociation,
  VpcCidrBlockState,
  VpcClassicLink,
  VpcEndpoint,
  VpcEndpointConnection,
  VpcIpv6CidrBlockAssociation,
  VpcPeeringConnection,
  VpcPeeringConnectionOptionsDescription,
  VpcPeeringConnectionStateReason,
  VpcPeeringConnectionVpcInfo,
  VpnConnection,
  VpnConnectionOptions,
  VpnConnectionOptionsSpecification,
  VpnGateway,
  VpnStaticRoute,
  VpnTunnelOptionsSpecification,
  WithdrawByoipCidrRequest,
  WithdrawByoipCidrResult,
  _InstanceType
} from "../models/index";
import {
  HttpRequest as __HttpRequest,
  HttpResponse as __HttpResponse
} from "@aws-sdk/protocol-http";
import {
  SmithyException as __SmithyException,
  extendedEncodeURIComponent as __extendedEncodeURIComponent,
  getArrayIfSingleItem as __getArrayIfSingleItem,
  getValueFromTextNode as __getValueFromTextNode
} from "@aws-sdk/smithy-client";
import {
  Endpoint as __Endpoint,
  HeaderBag as __HeaderBag,
  MetadataBearer as __MetadataBearer,
  ResponseMetadata as __ResponseMetadata,
  SerdeContext as __SerdeContext
} from "@aws-sdk/types";
import { parse as xmlParse } from "fast-xml-parser";
import { v4 as generateIdempotencyToken } from "uuid";

export const serializeAws_ec2AcceptReservedInstancesExchangeQuoteCommand = async (
  input: AcceptReservedInstancesExchangeQuoteCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2AcceptReservedInstancesExchangeQuoteRequest(
      input,
      context
    ),
    Action: "AcceptReservedInstancesExchangeQuote",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2AcceptTransitGatewayPeeringAttachmentCommand = async (
  input: AcceptTransitGatewayPeeringAttachmentCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2AcceptTransitGatewayPeeringAttachmentRequest(
      input,
      context
    ),
    Action: "AcceptTransitGatewayPeeringAttachment",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2AcceptTransitGatewayVpcAttachmentCommand = async (
  input: AcceptTransitGatewayVpcAttachmentCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2AcceptTransitGatewayVpcAttachmentRequest(input, context),
    Action: "AcceptTransitGatewayVpcAttachment",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2AcceptVpcEndpointConnectionsCommand = async (
  input: AcceptVpcEndpointConnectionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2AcceptVpcEndpointConnectionsRequest(input, context),
    Action: "AcceptVpcEndpointConnections",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2AcceptVpcPeeringConnectionCommand = async (
  input: AcceptVpcPeeringConnectionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2AcceptVpcPeeringConnectionRequest(input, context),
    Action: "AcceptVpcPeeringConnection",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2AdvertiseByoipCidrCommand = async (
  input: AdvertiseByoipCidrCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2AdvertiseByoipCidrRequest(input, context),
    Action: "AdvertiseByoipCidr",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2AllocateAddressCommand = async (
  input: AllocateAddressCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2AllocateAddressRequest(input, context),
    Action: "AllocateAddress",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2AllocateHostsCommand = async (
  input: AllocateHostsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2AllocateHostsRequest(input, context),
    Action: "AllocateHosts",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2ApplySecurityGroupsToClientVpnTargetNetworkCommand = async (
  input: ApplySecurityGroupsToClientVpnTargetNetworkCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2ApplySecurityGroupsToClientVpnTargetNetworkRequest(
      input,
      context
    ),
    Action: "ApplySecurityGroupsToClientVpnTargetNetwork",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2AssignIpv6AddressesCommand = async (
  input: AssignIpv6AddressesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2AssignIpv6AddressesRequest(input, context),
    Action: "AssignIpv6Addresses",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2AssignPrivateIpAddressesCommand = async (
  input: AssignPrivateIpAddressesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2AssignPrivateIpAddressesRequest(input, context),
    Action: "AssignPrivateIpAddresses",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2AssociateAddressCommand = async (
  input: AssociateAddressCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2AssociateAddressRequest(input, context),
    Action: "AssociateAddress",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2AssociateClientVpnTargetNetworkCommand = async (
  input: AssociateClientVpnTargetNetworkCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2AssociateClientVpnTargetNetworkRequest(input, context),
    Action: "AssociateClientVpnTargetNetwork",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2AssociateDhcpOptionsCommand = async (
  input: AssociateDhcpOptionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2AssociateDhcpOptionsRequest(input, context),
    Action: "AssociateDhcpOptions",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2AssociateIamInstanceProfileCommand = async (
  input: AssociateIamInstanceProfileCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2AssociateIamInstanceProfileRequest(input, context),
    Action: "AssociateIamInstanceProfile",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2AssociateRouteTableCommand = async (
  input: AssociateRouteTableCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2AssociateRouteTableRequest(input, context),
    Action: "AssociateRouteTable",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2AssociateSubnetCidrBlockCommand = async (
  input: AssociateSubnetCidrBlockCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2AssociateSubnetCidrBlockRequest(input, context),
    Action: "AssociateSubnetCidrBlock",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2AssociateTransitGatewayMulticastDomainCommand = async (
  input: AssociateTransitGatewayMulticastDomainCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2AssociateTransitGatewayMulticastDomainRequest(
      input,
      context
    ),
    Action: "AssociateTransitGatewayMulticastDomain",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2AssociateTransitGatewayRouteTableCommand = async (
  input: AssociateTransitGatewayRouteTableCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2AssociateTransitGatewayRouteTableRequest(input, context),
    Action: "AssociateTransitGatewayRouteTable",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2AssociateVpcCidrBlockCommand = async (
  input: AssociateVpcCidrBlockCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2AssociateVpcCidrBlockRequest(input, context),
    Action: "AssociateVpcCidrBlock",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2AttachClassicLinkVpcCommand = async (
  input: AttachClassicLinkVpcCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2AttachClassicLinkVpcRequest(input, context),
    Action: "AttachClassicLinkVpc",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2AttachInternetGatewayCommand = async (
  input: AttachInternetGatewayCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2AttachInternetGatewayRequest(input, context),
    Action: "AttachInternetGateway",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2AttachNetworkInterfaceCommand = async (
  input: AttachNetworkInterfaceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2AttachNetworkInterfaceRequest(input, context),
    Action: "AttachNetworkInterface",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2AttachVolumeCommand = async (
  input: AttachVolumeCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2AttachVolumeRequest(input, context),
    Action: "AttachVolume",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2AttachVpnGatewayCommand = async (
  input: AttachVpnGatewayCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2AttachVpnGatewayRequest(input, context),
    Action: "AttachVpnGateway",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2AuthorizeClientVpnIngressCommand = async (
  input: AuthorizeClientVpnIngressCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2AuthorizeClientVpnIngressRequest(input, context),
    Action: "AuthorizeClientVpnIngress",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2AuthorizeSecurityGroupEgressCommand = async (
  input: AuthorizeSecurityGroupEgressCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2AuthorizeSecurityGroupEgressRequest(input, context),
    Action: "AuthorizeSecurityGroupEgress",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2AuthorizeSecurityGroupIngressCommand = async (
  input: AuthorizeSecurityGroupIngressCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2AuthorizeSecurityGroupIngressRequest(input, context),
    Action: "AuthorizeSecurityGroupIngress",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2BundleInstanceCommand = async (
  input: BundleInstanceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2BundleInstanceRequest(input, context),
    Action: "BundleInstance",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2CancelBundleTaskCommand = async (
  input: CancelBundleTaskCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2CancelBundleTaskRequest(input, context),
    Action: "CancelBundleTask",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2CancelCapacityReservationCommand = async (
  input: CancelCapacityReservationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2CancelCapacityReservationRequest(input, context),
    Action: "CancelCapacityReservation",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2CancelConversionTaskCommand = async (
  input: CancelConversionTaskCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2CancelConversionRequest(input, context),
    Action: "CancelConversionTask",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2CancelExportTaskCommand = async (
  input: CancelExportTaskCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2CancelExportTaskRequest(input, context),
    Action: "CancelExportTask",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2CancelImportTaskCommand = async (
  input: CancelImportTaskCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2CancelImportTaskRequest(input, context),
    Action: "CancelImportTask",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2CancelReservedInstancesListingCommand = async (
  input: CancelReservedInstancesListingCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2CancelReservedInstancesListingRequest(input, context),
    Action: "CancelReservedInstancesListing",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2CancelSpotFleetRequestsCommand = async (
  input: CancelSpotFleetRequestsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2CancelSpotFleetRequestsRequest(input, context),
    Action: "CancelSpotFleetRequests",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2CancelSpotInstanceRequestsCommand = async (
  input: CancelSpotInstanceRequestsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2CancelSpotInstanceRequestsRequest(input, context),
    Action: "CancelSpotInstanceRequests",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2ConfirmProductInstanceCommand = async (
  input: ConfirmProductInstanceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2ConfirmProductInstanceRequest(input, context),
    Action: "ConfirmProductInstance",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2CopyFpgaImageCommand = async (
  input: CopyFpgaImageCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2CopyFpgaImageRequest(input, context),
    Action: "CopyFpgaImage",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2CopyImageCommand = async (
  input: CopyImageCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2CopyImageRequest(input, context),
    Action: "CopyImage",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2CopySnapshotCommand = async (
  input: CopySnapshotCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2CopySnapshotRequest(input, context),
    Action: "CopySnapshot",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2CreateCapacityReservationCommand = async (
  input: CreateCapacityReservationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2CreateCapacityReservationRequest(input, context),
    Action: "CreateCapacityReservation",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2CreateClientVpnEndpointCommand = async (
  input: CreateClientVpnEndpointCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2CreateClientVpnEndpointRequest(input, context),
    Action: "CreateClientVpnEndpoint",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2CreateClientVpnRouteCommand = async (
  input: CreateClientVpnRouteCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2CreateClientVpnRouteRequest(input, context),
    Action: "CreateClientVpnRoute",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2CreateCustomerGatewayCommand = async (
  input: CreateCustomerGatewayCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2CreateCustomerGatewayRequest(input, context),
    Action: "CreateCustomerGateway",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2CreateDefaultSubnetCommand = async (
  input: CreateDefaultSubnetCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2CreateDefaultSubnetRequest(input, context),
    Action: "CreateDefaultSubnet",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2CreateDefaultVpcCommand = async (
  input: CreateDefaultVpcCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2CreateDefaultVpcRequest(input, context),
    Action: "CreateDefaultVpc",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2CreateDhcpOptionsCommand = async (
  input: CreateDhcpOptionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2CreateDhcpOptionsRequest(input, context),
    Action: "CreateDhcpOptions",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2CreateEgressOnlyInternetGatewayCommand = async (
  input: CreateEgressOnlyInternetGatewayCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2CreateEgressOnlyInternetGatewayRequest(input, context),
    Action: "CreateEgressOnlyInternetGateway",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2CreateFleetCommand = async (
  input: CreateFleetCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2CreateFleetRequest(input, context),
    Action: "CreateFleet",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2CreateFlowLogsCommand = async (
  input: CreateFlowLogsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2CreateFlowLogsRequest(input, context),
    Action: "CreateFlowLogs",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2CreateFpgaImageCommand = async (
  input: CreateFpgaImageCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2CreateFpgaImageRequest(input, context),
    Action: "CreateFpgaImage",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2CreateImageCommand = async (
  input: CreateImageCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2CreateImageRequest(input, context),
    Action: "CreateImage",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2CreateInstanceExportTaskCommand = async (
  input: CreateInstanceExportTaskCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2CreateInstanceExportTaskRequest(input, context),
    Action: "CreateInstanceExportTask",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2CreateInternetGatewayCommand = async (
  input: CreateInternetGatewayCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2CreateInternetGatewayRequest(input, context),
    Action: "CreateInternetGateway",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2CreateKeyPairCommand = async (
  input: CreateKeyPairCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2CreateKeyPairRequest(input, context),
    Action: "CreateKeyPair",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2CreateLaunchTemplateCommand = async (
  input: CreateLaunchTemplateCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2CreateLaunchTemplateRequest(input, context),
    Action: "CreateLaunchTemplate",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2CreateLaunchTemplateVersionCommand = async (
  input: CreateLaunchTemplateVersionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2CreateLaunchTemplateVersionRequest(input, context),
    Action: "CreateLaunchTemplateVersion",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2CreateLocalGatewayRouteCommand = async (
  input: CreateLocalGatewayRouteCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2CreateLocalGatewayRouteRequest(input, context),
    Action: "CreateLocalGatewayRoute",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2CreateLocalGatewayRouteTableVpcAssociationCommand = async (
  input: CreateLocalGatewayRouteTableVpcAssociationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2CreateLocalGatewayRouteTableVpcAssociationRequest(
      input,
      context
    ),
    Action: "CreateLocalGatewayRouteTableVpcAssociation",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2CreateNatGatewayCommand = async (
  input: CreateNatGatewayCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2CreateNatGatewayRequest(input, context),
    Action: "CreateNatGateway",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2CreateNetworkAclCommand = async (
  input: CreateNetworkAclCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2CreateNetworkAclRequest(input, context),
    Action: "CreateNetworkAcl",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2CreateNetworkAclEntryCommand = async (
  input: CreateNetworkAclEntryCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2CreateNetworkAclEntryRequest(input, context),
    Action: "CreateNetworkAclEntry",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2CreateNetworkInterfaceCommand = async (
  input: CreateNetworkInterfaceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2CreateNetworkInterfaceRequest(input, context),
    Action: "CreateNetworkInterface",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2CreateNetworkInterfacePermissionCommand = async (
  input: CreateNetworkInterfacePermissionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2CreateNetworkInterfacePermissionRequest(input, context),
    Action: "CreateNetworkInterfacePermission",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2CreatePlacementGroupCommand = async (
  input: CreatePlacementGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2CreatePlacementGroupRequest(input, context),
    Action: "CreatePlacementGroup",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2CreateReservedInstancesListingCommand = async (
  input: CreateReservedInstancesListingCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2CreateReservedInstancesListingRequest(input, context),
    Action: "CreateReservedInstancesListing",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2CreateRouteCommand = async (
  input: CreateRouteCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2CreateRouteRequest(input, context),
    Action: "CreateRoute",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2CreateRouteTableCommand = async (
  input: CreateRouteTableCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2CreateRouteTableRequest(input, context),
    Action: "CreateRouteTable",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2CreateSecurityGroupCommand = async (
  input: CreateSecurityGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2CreateSecurityGroupRequest(input, context),
    Action: "CreateSecurityGroup",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2CreateSnapshotCommand = async (
  input: CreateSnapshotCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2CreateSnapshotRequest(input, context),
    Action: "CreateSnapshot",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2CreateSnapshotsCommand = async (
  input: CreateSnapshotsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2CreateSnapshotsRequest(input, context),
    Action: "CreateSnapshots",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2CreateSpotDatafeedSubscriptionCommand = async (
  input: CreateSpotDatafeedSubscriptionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2CreateSpotDatafeedSubscriptionRequest(input, context),
    Action: "CreateSpotDatafeedSubscription",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2CreateSubnetCommand = async (
  input: CreateSubnetCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2CreateSubnetRequest(input, context),
    Action: "CreateSubnet",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2CreateTagsCommand = async (
  input: CreateTagsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2CreateTagsRequest(input, context),
    Action: "CreateTags",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2CreateTrafficMirrorFilterCommand = async (
  input: CreateTrafficMirrorFilterCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2CreateTrafficMirrorFilterRequest(input, context),
    Action: "CreateTrafficMirrorFilter",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2CreateTrafficMirrorFilterRuleCommand = async (
  input: CreateTrafficMirrorFilterRuleCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2CreateTrafficMirrorFilterRuleRequest(input, context),
    Action: "CreateTrafficMirrorFilterRule",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2CreateTrafficMirrorSessionCommand = async (
  input: CreateTrafficMirrorSessionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2CreateTrafficMirrorSessionRequest(input, context),
    Action: "CreateTrafficMirrorSession",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2CreateTrafficMirrorTargetCommand = async (
  input: CreateTrafficMirrorTargetCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2CreateTrafficMirrorTargetRequest(input, context),
    Action: "CreateTrafficMirrorTarget",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2CreateTransitGatewayCommand = async (
  input: CreateTransitGatewayCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2CreateTransitGatewayRequest(input, context),
    Action: "CreateTransitGateway",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2CreateTransitGatewayMulticastDomainCommand = async (
  input: CreateTransitGatewayMulticastDomainCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2CreateTransitGatewayMulticastDomainRequest(
      input,
      context
    ),
    Action: "CreateTransitGatewayMulticastDomain",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2CreateTransitGatewayPeeringAttachmentCommand = async (
  input: CreateTransitGatewayPeeringAttachmentCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2CreateTransitGatewayPeeringAttachmentRequest(
      input,
      context
    ),
    Action: "CreateTransitGatewayPeeringAttachment",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2CreateTransitGatewayRouteCommand = async (
  input: CreateTransitGatewayRouteCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2CreateTransitGatewayRouteRequest(input, context),
    Action: "CreateTransitGatewayRoute",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2CreateTransitGatewayRouteTableCommand = async (
  input: CreateTransitGatewayRouteTableCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2CreateTransitGatewayRouteTableRequest(input, context),
    Action: "CreateTransitGatewayRouteTable",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2CreateTransitGatewayVpcAttachmentCommand = async (
  input: CreateTransitGatewayVpcAttachmentCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2CreateTransitGatewayVpcAttachmentRequest(input, context),
    Action: "CreateTransitGatewayVpcAttachment",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2CreateVolumeCommand = async (
  input: CreateVolumeCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2CreateVolumeRequest(input, context),
    Action: "CreateVolume",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2CreateVpcCommand = async (
  input: CreateVpcCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2CreateVpcRequest(input, context),
    Action: "CreateVpc",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2CreateVpcEndpointCommand = async (
  input: CreateVpcEndpointCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2CreateVpcEndpointRequest(input, context),
    Action: "CreateVpcEndpoint",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2CreateVpcEndpointConnectionNotificationCommand = async (
  input: CreateVpcEndpointConnectionNotificationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2CreateVpcEndpointConnectionNotificationRequest(
      input,
      context
    ),
    Action: "CreateVpcEndpointConnectionNotification",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2CreateVpcEndpointServiceConfigurationCommand = async (
  input: CreateVpcEndpointServiceConfigurationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2CreateVpcEndpointServiceConfigurationRequest(
      input,
      context
    ),
    Action: "CreateVpcEndpointServiceConfiguration",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2CreateVpcPeeringConnectionCommand = async (
  input: CreateVpcPeeringConnectionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2CreateVpcPeeringConnectionRequest(input, context),
    Action: "CreateVpcPeeringConnection",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2CreateVpnConnectionCommand = async (
  input: CreateVpnConnectionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2CreateVpnConnectionRequest(input, context),
    Action: "CreateVpnConnection",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2CreateVpnConnectionRouteCommand = async (
  input: CreateVpnConnectionRouteCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2CreateVpnConnectionRouteRequest(input, context),
    Action: "CreateVpnConnectionRoute",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2CreateVpnGatewayCommand = async (
  input: CreateVpnGatewayCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2CreateVpnGatewayRequest(input, context),
    Action: "CreateVpnGateway",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DeleteClientVpnEndpointCommand = async (
  input: DeleteClientVpnEndpointCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DeleteClientVpnEndpointRequest(input, context),
    Action: "DeleteClientVpnEndpoint",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DeleteClientVpnRouteCommand = async (
  input: DeleteClientVpnRouteCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DeleteClientVpnRouteRequest(input, context),
    Action: "DeleteClientVpnRoute",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DeleteCustomerGatewayCommand = async (
  input: DeleteCustomerGatewayCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DeleteCustomerGatewayRequest(input, context),
    Action: "DeleteCustomerGateway",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DeleteDhcpOptionsCommand = async (
  input: DeleteDhcpOptionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DeleteDhcpOptionsRequest(input, context),
    Action: "DeleteDhcpOptions",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DeleteEgressOnlyInternetGatewayCommand = async (
  input: DeleteEgressOnlyInternetGatewayCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DeleteEgressOnlyInternetGatewayRequest(input, context),
    Action: "DeleteEgressOnlyInternetGateway",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DeleteFleetsCommand = async (
  input: DeleteFleetsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DeleteFleetsRequest(input, context),
    Action: "DeleteFleets",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DeleteFlowLogsCommand = async (
  input: DeleteFlowLogsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DeleteFlowLogsRequest(input, context),
    Action: "DeleteFlowLogs",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DeleteFpgaImageCommand = async (
  input: DeleteFpgaImageCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DeleteFpgaImageRequest(input, context),
    Action: "DeleteFpgaImage",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DeleteInternetGatewayCommand = async (
  input: DeleteInternetGatewayCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DeleteInternetGatewayRequest(input, context),
    Action: "DeleteInternetGateway",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DeleteKeyPairCommand = async (
  input: DeleteKeyPairCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DeleteKeyPairRequest(input, context),
    Action: "DeleteKeyPair",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DeleteLaunchTemplateCommand = async (
  input: DeleteLaunchTemplateCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DeleteLaunchTemplateRequest(input, context),
    Action: "DeleteLaunchTemplate",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DeleteLaunchTemplateVersionsCommand = async (
  input: DeleteLaunchTemplateVersionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DeleteLaunchTemplateVersionsRequest(input, context),
    Action: "DeleteLaunchTemplateVersions",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DeleteLocalGatewayRouteCommand = async (
  input: DeleteLocalGatewayRouteCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DeleteLocalGatewayRouteRequest(input, context),
    Action: "DeleteLocalGatewayRoute",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DeleteLocalGatewayRouteTableVpcAssociationCommand = async (
  input: DeleteLocalGatewayRouteTableVpcAssociationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DeleteLocalGatewayRouteTableVpcAssociationRequest(
      input,
      context
    ),
    Action: "DeleteLocalGatewayRouteTableVpcAssociation",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DeleteNatGatewayCommand = async (
  input: DeleteNatGatewayCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DeleteNatGatewayRequest(input, context),
    Action: "DeleteNatGateway",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DeleteNetworkAclCommand = async (
  input: DeleteNetworkAclCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DeleteNetworkAclRequest(input, context),
    Action: "DeleteNetworkAcl",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DeleteNetworkAclEntryCommand = async (
  input: DeleteNetworkAclEntryCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DeleteNetworkAclEntryRequest(input, context),
    Action: "DeleteNetworkAclEntry",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DeleteNetworkInterfaceCommand = async (
  input: DeleteNetworkInterfaceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DeleteNetworkInterfaceRequest(input, context),
    Action: "DeleteNetworkInterface",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DeleteNetworkInterfacePermissionCommand = async (
  input: DeleteNetworkInterfacePermissionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DeleteNetworkInterfacePermissionRequest(input, context),
    Action: "DeleteNetworkInterfacePermission",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DeletePlacementGroupCommand = async (
  input: DeletePlacementGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DeletePlacementGroupRequest(input, context),
    Action: "DeletePlacementGroup",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DeleteQueuedReservedInstancesCommand = async (
  input: DeleteQueuedReservedInstancesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DeleteQueuedReservedInstancesRequest(input, context),
    Action: "DeleteQueuedReservedInstances",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DeleteRouteCommand = async (
  input: DeleteRouteCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DeleteRouteRequest(input, context),
    Action: "DeleteRoute",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DeleteRouteTableCommand = async (
  input: DeleteRouteTableCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DeleteRouteTableRequest(input, context),
    Action: "DeleteRouteTable",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DeleteSecurityGroupCommand = async (
  input: DeleteSecurityGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DeleteSecurityGroupRequest(input, context),
    Action: "DeleteSecurityGroup",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DeleteSnapshotCommand = async (
  input: DeleteSnapshotCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DeleteSnapshotRequest(input, context),
    Action: "DeleteSnapshot",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DeleteSpotDatafeedSubscriptionCommand = async (
  input: DeleteSpotDatafeedSubscriptionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DeleteSpotDatafeedSubscriptionRequest(input, context),
    Action: "DeleteSpotDatafeedSubscription",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DeleteSubnetCommand = async (
  input: DeleteSubnetCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DeleteSubnetRequest(input, context),
    Action: "DeleteSubnet",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DeleteTagsCommand = async (
  input: DeleteTagsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DeleteTagsRequest(input, context),
    Action: "DeleteTags",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DeleteTrafficMirrorFilterCommand = async (
  input: DeleteTrafficMirrorFilterCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DeleteTrafficMirrorFilterRequest(input, context),
    Action: "DeleteTrafficMirrorFilter",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DeleteTrafficMirrorFilterRuleCommand = async (
  input: DeleteTrafficMirrorFilterRuleCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DeleteTrafficMirrorFilterRuleRequest(input, context),
    Action: "DeleteTrafficMirrorFilterRule",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DeleteTrafficMirrorSessionCommand = async (
  input: DeleteTrafficMirrorSessionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DeleteTrafficMirrorSessionRequest(input, context),
    Action: "DeleteTrafficMirrorSession",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DeleteTrafficMirrorTargetCommand = async (
  input: DeleteTrafficMirrorTargetCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DeleteTrafficMirrorTargetRequest(input, context),
    Action: "DeleteTrafficMirrorTarget",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DeleteTransitGatewayCommand = async (
  input: DeleteTransitGatewayCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DeleteTransitGatewayRequest(input, context),
    Action: "DeleteTransitGateway",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DeleteTransitGatewayMulticastDomainCommand = async (
  input: DeleteTransitGatewayMulticastDomainCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DeleteTransitGatewayMulticastDomainRequest(
      input,
      context
    ),
    Action: "DeleteTransitGatewayMulticastDomain",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DeleteTransitGatewayPeeringAttachmentCommand = async (
  input: DeleteTransitGatewayPeeringAttachmentCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DeleteTransitGatewayPeeringAttachmentRequest(
      input,
      context
    ),
    Action: "DeleteTransitGatewayPeeringAttachment",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DeleteTransitGatewayRouteCommand = async (
  input: DeleteTransitGatewayRouteCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DeleteTransitGatewayRouteRequest(input, context),
    Action: "DeleteTransitGatewayRoute",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DeleteTransitGatewayRouteTableCommand = async (
  input: DeleteTransitGatewayRouteTableCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DeleteTransitGatewayRouteTableRequest(input, context),
    Action: "DeleteTransitGatewayRouteTable",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DeleteTransitGatewayVpcAttachmentCommand = async (
  input: DeleteTransitGatewayVpcAttachmentCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DeleteTransitGatewayVpcAttachmentRequest(input, context),
    Action: "DeleteTransitGatewayVpcAttachment",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DeleteVolumeCommand = async (
  input: DeleteVolumeCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DeleteVolumeRequest(input, context),
    Action: "DeleteVolume",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DeleteVpcCommand = async (
  input: DeleteVpcCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DeleteVpcRequest(input, context),
    Action: "DeleteVpc",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DeleteVpcEndpointConnectionNotificationsCommand = async (
  input: DeleteVpcEndpointConnectionNotificationsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DeleteVpcEndpointConnectionNotificationsRequest(
      input,
      context
    ),
    Action: "DeleteVpcEndpointConnectionNotifications",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DeleteVpcEndpointsCommand = async (
  input: DeleteVpcEndpointsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DeleteVpcEndpointsRequest(input, context),
    Action: "DeleteVpcEndpoints",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DeleteVpcEndpointServiceConfigurationsCommand = async (
  input: DeleteVpcEndpointServiceConfigurationsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DeleteVpcEndpointServiceConfigurationsRequest(
      input,
      context
    ),
    Action: "DeleteVpcEndpointServiceConfigurations",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DeleteVpcPeeringConnectionCommand = async (
  input: DeleteVpcPeeringConnectionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DeleteVpcPeeringConnectionRequest(input, context),
    Action: "DeleteVpcPeeringConnection",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DeleteVpnConnectionCommand = async (
  input: DeleteVpnConnectionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DeleteVpnConnectionRequest(input, context),
    Action: "DeleteVpnConnection",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DeleteVpnConnectionRouteCommand = async (
  input: DeleteVpnConnectionRouteCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DeleteVpnConnectionRouteRequest(input, context),
    Action: "DeleteVpnConnectionRoute",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DeleteVpnGatewayCommand = async (
  input: DeleteVpnGatewayCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DeleteVpnGatewayRequest(input, context),
    Action: "DeleteVpnGateway",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DeprovisionByoipCidrCommand = async (
  input: DeprovisionByoipCidrCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DeprovisionByoipCidrRequest(input, context),
    Action: "DeprovisionByoipCidr",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DeregisterImageCommand = async (
  input: DeregisterImageCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DeregisterImageRequest(input, context),
    Action: "DeregisterImage",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DeregisterTransitGatewayMulticastGroupMembersCommand = async (
  input: DeregisterTransitGatewayMulticastGroupMembersCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DeregisterTransitGatewayMulticastGroupMembersRequest(
      input,
      context
    ),
    Action: "DeregisterTransitGatewayMulticastGroupMembers",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DeregisterTransitGatewayMulticastGroupSourcesCommand = async (
  input: DeregisterTransitGatewayMulticastGroupSourcesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DeregisterTransitGatewayMulticastGroupSourcesRequest(
      input,
      context
    ),
    Action: "DeregisterTransitGatewayMulticastGroupSources",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeAccountAttributesCommand = async (
  input: DescribeAccountAttributesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeAccountAttributesRequest(input, context),
    Action: "DescribeAccountAttributes",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeAddressesCommand = async (
  input: DescribeAddressesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeAddressesRequest(input, context),
    Action: "DescribeAddresses",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeAggregateIdFormatCommand = async (
  input: DescribeAggregateIdFormatCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeAggregateIdFormatRequest(input, context),
    Action: "DescribeAggregateIdFormat",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeAvailabilityZonesCommand = async (
  input: DescribeAvailabilityZonesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeAvailabilityZonesRequest(input, context),
    Action: "DescribeAvailabilityZones",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeBundleTasksCommand = async (
  input: DescribeBundleTasksCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeBundleTasksRequest(input, context),
    Action: "DescribeBundleTasks",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeByoipCidrsCommand = async (
  input: DescribeByoipCidrsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeByoipCidrsRequest(input, context),
    Action: "DescribeByoipCidrs",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeCapacityReservationsCommand = async (
  input: DescribeCapacityReservationsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeCapacityReservationsRequest(input, context),
    Action: "DescribeCapacityReservations",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeClassicLinkInstancesCommand = async (
  input: DescribeClassicLinkInstancesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeClassicLinkInstancesRequest(input, context),
    Action: "DescribeClassicLinkInstances",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeClientVpnAuthorizationRulesCommand = async (
  input: DescribeClientVpnAuthorizationRulesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeClientVpnAuthorizationRulesRequest(
      input,
      context
    ),
    Action: "DescribeClientVpnAuthorizationRules",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeClientVpnConnectionsCommand = async (
  input: DescribeClientVpnConnectionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeClientVpnConnectionsRequest(input, context),
    Action: "DescribeClientVpnConnections",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeClientVpnEndpointsCommand = async (
  input: DescribeClientVpnEndpointsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeClientVpnEndpointsRequest(input, context),
    Action: "DescribeClientVpnEndpoints",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeClientVpnRoutesCommand = async (
  input: DescribeClientVpnRoutesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeClientVpnRoutesRequest(input, context),
    Action: "DescribeClientVpnRoutes",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeClientVpnTargetNetworksCommand = async (
  input: DescribeClientVpnTargetNetworksCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeClientVpnTargetNetworksRequest(input, context),
    Action: "DescribeClientVpnTargetNetworks",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeCoipPoolsCommand = async (
  input: DescribeCoipPoolsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeCoipPoolsRequest(input, context),
    Action: "DescribeCoipPools",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeConversionTasksCommand = async (
  input: DescribeConversionTasksCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeConversionTasksRequest(input, context),
    Action: "DescribeConversionTasks",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeCustomerGatewaysCommand = async (
  input: DescribeCustomerGatewaysCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeCustomerGatewaysRequest(input, context),
    Action: "DescribeCustomerGateways",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeDhcpOptionsCommand = async (
  input: DescribeDhcpOptionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeDhcpOptionsRequest(input, context),
    Action: "DescribeDhcpOptions",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeEgressOnlyInternetGatewaysCommand = async (
  input: DescribeEgressOnlyInternetGatewaysCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeEgressOnlyInternetGatewaysRequest(
      input,
      context
    ),
    Action: "DescribeEgressOnlyInternetGateways",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeElasticGpusCommand = async (
  input: DescribeElasticGpusCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeElasticGpusRequest(input, context),
    Action: "DescribeElasticGpus",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeExportImageTasksCommand = async (
  input: DescribeExportImageTasksCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeExportImageTasksRequest(input, context),
    Action: "DescribeExportImageTasks",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeExportTasksCommand = async (
  input: DescribeExportTasksCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeExportTasksRequest(input, context),
    Action: "DescribeExportTasks",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeFastSnapshotRestoresCommand = async (
  input: DescribeFastSnapshotRestoresCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeFastSnapshotRestoresRequest(input, context),
    Action: "DescribeFastSnapshotRestores",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeFleetHistoryCommand = async (
  input: DescribeFleetHistoryCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeFleetHistoryRequest(input, context),
    Action: "DescribeFleetHistory",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeFleetInstancesCommand = async (
  input: DescribeFleetInstancesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeFleetInstancesRequest(input, context),
    Action: "DescribeFleetInstances",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeFleetsCommand = async (
  input: DescribeFleetsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeFleetsRequest(input, context),
    Action: "DescribeFleets",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeFlowLogsCommand = async (
  input: DescribeFlowLogsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeFlowLogsRequest(input, context),
    Action: "DescribeFlowLogs",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeFpgaImageAttributeCommand = async (
  input: DescribeFpgaImageAttributeCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeFpgaImageAttributeRequest(input, context),
    Action: "DescribeFpgaImageAttribute",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeFpgaImagesCommand = async (
  input: DescribeFpgaImagesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeFpgaImagesRequest(input, context),
    Action: "DescribeFpgaImages",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeHostReservationOfferingsCommand = async (
  input: DescribeHostReservationOfferingsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeHostReservationOfferingsRequest(input, context),
    Action: "DescribeHostReservationOfferings",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeHostReservationsCommand = async (
  input: DescribeHostReservationsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeHostReservationsRequest(input, context),
    Action: "DescribeHostReservations",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeHostsCommand = async (
  input: DescribeHostsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeHostsRequest(input, context),
    Action: "DescribeHosts",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeIamInstanceProfileAssociationsCommand = async (
  input: DescribeIamInstanceProfileAssociationsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeIamInstanceProfileAssociationsRequest(
      input,
      context
    ),
    Action: "DescribeIamInstanceProfileAssociations",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeIdentityIdFormatCommand = async (
  input: DescribeIdentityIdFormatCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeIdentityIdFormatRequest(input, context),
    Action: "DescribeIdentityIdFormat",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeIdFormatCommand = async (
  input: DescribeIdFormatCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeIdFormatRequest(input, context),
    Action: "DescribeIdFormat",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeImageAttributeCommand = async (
  input: DescribeImageAttributeCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeImageAttributeRequest(input, context),
    Action: "DescribeImageAttribute",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeImagesCommand = async (
  input: DescribeImagesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeImagesRequest(input, context),
    Action: "DescribeImages",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeImportImageTasksCommand = async (
  input: DescribeImportImageTasksCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeImportImageTasksRequest(input, context),
    Action: "DescribeImportImageTasks",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeImportSnapshotTasksCommand = async (
  input: DescribeImportSnapshotTasksCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeImportSnapshotTasksRequest(input, context),
    Action: "DescribeImportSnapshotTasks",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeInstanceAttributeCommand = async (
  input: DescribeInstanceAttributeCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeInstanceAttributeRequest(input, context),
    Action: "DescribeInstanceAttribute",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeInstanceCreditSpecificationsCommand = async (
  input: DescribeInstanceCreditSpecificationsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeInstanceCreditSpecificationsRequest(
      input,
      context
    ),
    Action: "DescribeInstanceCreditSpecifications",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeInstancesCommand = async (
  input: DescribeInstancesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeInstancesRequest(input, context),
    Action: "DescribeInstances",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeInstanceStatusCommand = async (
  input: DescribeInstanceStatusCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeInstanceStatusRequest(input, context),
    Action: "DescribeInstanceStatus",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeInstanceTypeOfferingsCommand = async (
  input: DescribeInstanceTypeOfferingsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeInstanceTypeOfferingsRequest(input, context),
    Action: "DescribeInstanceTypeOfferings",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeInstanceTypesCommand = async (
  input: DescribeInstanceTypesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeInstanceTypesRequest(input, context),
    Action: "DescribeInstanceTypes",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeInternetGatewaysCommand = async (
  input: DescribeInternetGatewaysCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeInternetGatewaysRequest(input, context),
    Action: "DescribeInternetGateways",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeIpv6PoolsCommand = async (
  input: DescribeIpv6PoolsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeIpv6PoolsRequest(input, context),
    Action: "DescribeIpv6Pools",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeKeyPairsCommand = async (
  input: DescribeKeyPairsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeKeyPairsRequest(input, context),
    Action: "DescribeKeyPairs",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeLaunchTemplatesCommand = async (
  input: DescribeLaunchTemplatesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeLaunchTemplatesRequest(input, context),
    Action: "DescribeLaunchTemplates",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeLaunchTemplateVersionsCommand = async (
  input: DescribeLaunchTemplateVersionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeLaunchTemplateVersionsRequest(input, context),
    Action: "DescribeLaunchTemplateVersions",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeLocalGatewayRouteTablesCommand = async (
  input: DescribeLocalGatewayRouteTablesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeLocalGatewayRouteTablesRequest(input, context),
    Action: "DescribeLocalGatewayRouteTables",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsCommand = async (
  input: DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsRequest(
      input,
      context
    ),
    Action: "DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociations",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeLocalGatewayRouteTableVpcAssociationsCommand = async (
  input: DescribeLocalGatewayRouteTableVpcAssociationsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeLocalGatewayRouteTableVpcAssociationsRequest(
      input,
      context
    ),
    Action: "DescribeLocalGatewayRouteTableVpcAssociations",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeLocalGatewaysCommand = async (
  input: DescribeLocalGatewaysCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeLocalGatewaysRequest(input, context),
    Action: "DescribeLocalGateways",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeLocalGatewayVirtualInterfaceGroupsCommand = async (
  input: DescribeLocalGatewayVirtualInterfaceGroupsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeLocalGatewayVirtualInterfaceGroupsRequest(
      input,
      context
    ),
    Action: "DescribeLocalGatewayVirtualInterfaceGroups",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeLocalGatewayVirtualInterfacesCommand = async (
  input: DescribeLocalGatewayVirtualInterfacesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeLocalGatewayVirtualInterfacesRequest(
      input,
      context
    ),
    Action: "DescribeLocalGatewayVirtualInterfaces",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeMovingAddressesCommand = async (
  input: DescribeMovingAddressesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeMovingAddressesRequest(input, context),
    Action: "DescribeMovingAddresses",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeNatGatewaysCommand = async (
  input: DescribeNatGatewaysCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeNatGatewaysRequest(input, context),
    Action: "DescribeNatGateways",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeNetworkAclsCommand = async (
  input: DescribeNetworkAclsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeNetworkAclsRequest(input, context),
    Action: "DescribeNetworkAcls",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeNetworkInterfaceAttributeCommand = async (
  input: DescribeNetworkInterfaceAttributeCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeNetworkInterfaceAttributeRequest(input, context),
    Action: "DescribeNetworkInterfaceAttribute",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeNetworkInterfacePermissionsCommand = async (
  input: DescribeNetworkInterfacePermissionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeNetworkInterfacePermissionsRequest(
      input,
      context
    ),
    Action: "DescribeNetworkInterfacePermissions",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeNetworkInterfacesCommand = async (
  input: DescribeNetworkInterfacesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeNetworkInterfacesRequest(input, context),
    Action: "DescribeNetworkInterfaces",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribePlacementGroupsCommand = async (
  input: DescribePlacementGroupsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribePlacementGroupsRequest(input, context),
    Action: "DescribePlacementGroups",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribePrefixListsCommand = async (
  input: DescribePrefixListsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribePrefixListsRequest(input, context),
    Action: "DescribePrefixLists",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribePrincipalIdFormatCommand = async (
  input: DescribePrincipalIdFormatCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribePrincipalIdFormatRequest(input, context),
    Action: "DescribePrincipalIdFormat",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribePublicIpv4PoolsCommand = async (
  input: DescribePublicIpv4PoolsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribePublicIpv4PoolsRequest(input, context),
    Action: "DescribePublicIpv4Pools",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeRegionsCommand = async (
  input: DescribeRegionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeRegionsRequest(input, context),
    Action: "DescribeRegions",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeReservedInstancesCommand = async (
  input: DescribeReservedInstancesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeReservedInstancesRequest(input, context),
    Action: "DescribeReservedInstances",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeReservedInstancesListingsCommand = async (
  input: DescribeReservedInstancesListingsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeReservedInstancesListingsRequest(input, context),
    Action: "DescribeReservedInstancesListings",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeReservedInstancesModificationsCommand = async (
  input: DescribeReservedInstancesModificationsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeReservedInstancesModificationsRequest(
      input,
      context
    ),
    Action: "DescribeReservedInstancesModifications",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeReservedInstancesOfferingsCommand = async (
  input: DescribeReservedInstancesOfferingsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeReservedInstancesOfferingsRequest(
      input,
      context
    ),
    Action: "DescribeReservedInstancesOfferings",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeRouteTablesCommand = async (
  input: DescribeRouteTablesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeRouteTablesRequest(input, context),
    Action: "DescribeRouteTables",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeScheduledInstanceAvailabilityCommand = async (
  input: DescribeScheduledInstanceAvailabilityCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeScheduledInstanceAvailabilityRequest(
      input,
      context
    ),
    Action: "DescribeScheduledInstanceAvailability",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeScheduledInstancesCommand = async (
  input: DescribeScheduledInstancesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeScheduledInstancesRequest(input, context),
    Action: "DescribeScheduledInstances",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeSecurityGroupReferencesCommand = async (
  input: DescribeSecurityGroupReferencesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeSecurityGroupReferencesRequest(input, context),
    Action: "DescribeSecurityGroupReferences",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeSecurityGroupsCommand = async (
  input: DescribeSecurityGroupsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeSecurityGroupsRequest(input, context),
    Action: "DescribeSecurityGroups",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeSnapshotAttributeCommand = async (
  input: DescribeSnapshotAttributeCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeSnapshotAttributeRequest(input, context),
    Action: "DescribeSnapshotAttribute",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeSnapshotsCommand = async (
  input: DescribeSnapshotsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeSnapshotsRequest(input, context),
    Action: "DescribeSnapshots",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeSpotDatafeedSubscriptionCommand = async (
  input: DescribeSpotDatafeedSubscriptionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeSpotDatafeedSubscriptionRequest(input, context),
    Action: "DescribeSpotDatafeedSubscription",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeSpotFleetInstancesCommand = async (
  input: DescribeSpotFleetInstancesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeSpotFleetInstancesRequest(input, context),
    Action: "DescribeSpotFleetInstances",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeSpotFleetRequestHistoryCommand = async (
  input: DescribeSpotFleetRequestHistoryCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeSpotFleetRequestHistoryRequest(input, context),
    Action: "DescribeSpotFleetRequestHistory",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeSpotFleetRequestsCommand = async (
  input: DescribeSpotFleetRequestsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeSpotFleetRequestsRequest(input, context),
    Action: "DescribeSpotFleetRequests",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeSpotInstanceRequestsCommand = async (
  input: DescribeSpotInstanceRequestsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeSpotInstanceRequestsRequest(input, context),
    Action: "DescribeSpotInstanceRequests",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeSpotPriceHistoryCommand = async (
  input: DescribeSpotPriceHistoryCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeSpotPriceHistoryRequest(input, context),
    Action: "DescribeSpotPriceHistory",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeStaleSecurityGroupsCommand = async (
  input: DescribeStaleSecurityGroupsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeStaleSecurityGroupsRequest(input, context),
    Action: "DescribeStaleSecurityGroups",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeSubnetsCommand = async (
  input: DescribeSubnetsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeSubnetsRequest(input, context),
    Action: "DescribeSubnets",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeTagsCommand = async (
  input: DescribeTagsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeTagsRequest(input, context),
    Action: "DescribeTags",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeTrafficMirrorFiltersCommand = async (
  input: DescribeTrafficMirrorFiltersCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeTrafficMirrorFiltersRequest(input, context),
    Action: "DescribeTrafficMirrorFilters",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeTrafficMirrorSessionsCommand = async (
  input: DescribeTrafficMirrorSessionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeTrafficMirrorSessionsRequest(input, context),
    Action: "DescribeTrafficMirrorSessions",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeTrafficMirrorTargetsCommand = async (
  input: DescribeTrafficMirrorTargetsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeTrafficMirrorTargetsRequest(input, context),
    Action: "DescribeTrafficMirrorTargets",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeTransitGatewayAttachmentsCommand = async (
  input: DescribeTransitGatewayAttachmentsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeTransitGatewayAttachmentsRequest(input, context),
    Action: "DescribeTransitGatewayAttachments",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeTransitGatewayMulticastDomainsCommand = async (
  input: DescribeTransitGatewayMulticastDomainsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeTransitGatewayMulticastDomainsRequest(
      input,
      context
    ),
    Action: "DescribeTransitGatewayMulticastDomains",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeTransitGatewayPeeringAttachmentsCommand = async (
  input: DescribeTransitGatewayPeeringAttachmentsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeTransitGatewayPeeringAttachmentsRequest(
      input,
      context
    ),
    Action: "DescribeTransitGatewayPeeringAttachments",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeTransitGatewayRouteTablesCommand = async (
  input: DescribeTransitGatewayRouteTablesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeTransitGatewayRouteTablesRequest(input, context),
    Action: "DescribeTransitGatewayRouteTables",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeTransitGatewaysCommand = async (
  input: DescribeTransitGatewaysCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeTransitGatewaysRequest(input, context),
    Action: "DescribeTransitGateways",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeTransitGatewayVpcAttachmentsCommand = async (
  input: DescribeTransitGatewayVpcAttachmentsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeTransitGatewayVpcAttachmentsRequest(
      input,
      context
    ),
    Action: "DescribeTransitGatewayVpcAttachments",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeVolumeAttributeCommand = async (
  input: DescribeVolumeAttributeCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeVolumeAttributeRequest(input, context),
    Action: "DescribeVolumeAttribute",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeVolumesCommand = async (
  input: DescribeVolumesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeVolumesRequest(input, context),
    Action: "DescribeVolumes",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeVolumesModificationsCommand = async (
  input: DescribeVolumesModificationsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeVolumesModificationsRequest(input, context),
    Action: "DescribeVolumesModifications",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeVolumeStatusCommand = async (
  input: DescribeVolumeStatusCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeVolumeStatusRequest(input, context),
    Action: "DescribeVolumeStatus",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeVpcAttributeCommand = async (
  input: DescribeVpcAttributeCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeVpcAttributeRequest(input, context),
    Action: "DescribeVpcAttribute",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeVpcClassicLinkCommand = async (
  input: DescribeVpcClassicLinkCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeVpcClassicLinkRequest(input, context),
    Action: "DescribeVpcClassicLink",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeVpcClassicLinkDnsSupportCommand = async (
  input: DescribeVpcClassicLinkDnsSupportCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeVpcClassicLinkDnsSupportRequest(input, context),
    Action: "DescribeVpcClassicLinkDnsSupport",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeVpcEndpointConnectionNotificationsCommand = async (
  input: DescribeVpcEndpointConnectionNotificationsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeVpcEndpointConnectionNotificationsRequest(
      input,
      context
    ),
    Action: "DescribeVpcEndpointConnectionNotifications",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeVpcEndpointConnectionsCommand = async (
  input: DescribeVpcEndpointConnectionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeVpcEndpointConnectionsRequest(input, context),
    Action: "DescribeVpcEndpointConnections",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeVpcEndpointsCommand = async (
  input: DescribeVpcEndpointsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeVpcEndpointsRequest(input, context),
    Action: "DescribeVpcEndpoints",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeVpcEndpointServiceConfigurationsCommand = async (
  input: DescribeVpcEndpointServiceConfigurationsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeVpcEndpointServiceConfigurationsRequest(
      input,
      context
    ),
    Action: "DescribeVpcEndpointServiceConfigurations",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeVpcEndpointServicePermissionsCommand = async (
  input: DescribeVpcEndpointServicePermissionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeVpcEndpointServicePermissionsRequest(
      input,
      context
    ),
    Action: "DescribeVpcEndpointServicePermissions",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeVpcEndpointServicesCommand = async (
  input: DescribeVpcEndpointServicesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeVpcEndpointServicesRequest(input, context),
    Action: "DescribeVpcEndpointServices",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeVpcPeeringConnectionsCommand = async (
  input: DescribeVpcPeeringConnectionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeVpcPeeringConnectionsRequest(input, context),
    Action: "DescribeVpcPeeringConnections",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeVpcsCommand = async (
  input: DescribeVpcsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeVpcsRequest(input, context),
    Action: "DescribeVpcs",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeVpnConnectionsCommand = async (
  input: DescribeVpnConnectionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeVpnConnectionsRequest(input, context),
    Action: "DescribeVpnConnections",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DescribeVpnGatewaysCommand = async (
  input: DescribeVpnGatewaysCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DescribeVpnGatewaysRequest(input, context),
    Action: "DescribeVpnGateways",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DetachClassicLinkVpcCommand = async (
  input: DetachClassicLinkVpcCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DetachClassicLinkVpcRequest(input, context),
    Action: "DetachClassicLinkVpc",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DetachInternetGatewayCommand = async (
  input: DetachInternetGatewayCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DetachInternetGatewayRequest(input, context),
    Action: "DetachInternetGateway",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DetachNetworkInterfaceCommand = async (
  input: DetachNetworkInterfaceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DetachNetworkInterfaceRequest(input, context),
    Action: "DetachNetworkInterface",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DetachVolumeCommand = async (
  input: DetachVolumeCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DetachVolumeRequest(input, context),
    Action: "DetachVolume",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DetachVpnGatewayCommand = async (
  input: DetachVpnGatewayCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DetachVpnGatewayRequest(input, context),
    Action: "DetachVpnGateway",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DisableEbsEncryptionByDefaultCommand = async (
  input: DisableEbsEncryptionByDefaultCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DisableEbsEncryptionByDefaultRequest(input, context),
    Action: "DisableEbsEncryptionByDefault",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DisableFastSnapshotRestoresCommand = async (
  input: DisableFastSnapshotRestoresCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DisableFastSnapshotRestoresRequest(input, context),
    Action: "DisableFastSnapshotRestores",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DisableTransitGatewayRouteTablePropagationCommand = async (
  input: DisableTransitGatewayRouteTablePropagationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DisableTransitGatewayRouteTablePropagationRequest(
      input,
      context
    ),
    Action: "DisableTransitGatewayRouteTablePropagation",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DisableVgwRoutePropagationCommand = async (
  input: DisableVgwRoutePropagationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DisableVgwRoutePropagationRequest(input, context),
    Action: "DisableVgwRoutePropagation",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DisableVpcClassicLinkCommand = async (
  input: DisableVpcClassicLinkCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DisableVpcClassicLinkRequest(input, context),
    Action: "DisableVpcClassicLink",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DisableVpcClassicLinkDnsSupportCommand = async (
  input: DisableVpcClassicLinkDnsSupportCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DisableVpcClassicLinkDnsSupportRequest(input, context),
    Action: "DisableVpcClassicLinkDnsSupport",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DisassociateAddressCommand = async (
  input: DisassociateAddressCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DisassociateAddressRequest(input, context),
    Action: "DisassociateAddress",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DisassociateClientVpnTargetNetworkCommand = async (
  input: DisassociateClientVpnTargetNetworkCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DisassociateClientVpnTargetNetworkRequest(
      input,
      context
    ),
    Action: "DisassociateClientVpnTargetNetwork",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DisassociateIamInstanceProfileCommand = async (
  input: DisassociateIamInstanceProfileCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DisassociateIamInstanceProfileRequest(input, context),
    Action: "DisassociateIamInstanceProfile",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DisassociateRouteTableCommand = async (
  input: DisassociateRouteTableCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DisassociateRouteTableRequest(input, context),
    Action: "DisassociateRouteTable",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DisassociateSubnetCidrBlockCommand = async (
  input: DisassociateSubnetCidrBlockCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DisassociateSubnetCidrBlockRequest(input, context),
    Action: "DisassociateSubnetCidrBlock",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DisassociateTransitGatewayMulticastDomainCommand = async (
  input: DisassociateTransitGatewayMulticastDomainCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DisassociateTransitGatewayMulticastDomainRequest(
      input,
      context
    ),
    Action: "DisassociateTransitGatewayMulticastDomain",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DisassociateTransitGatewayRouteTableCommand = async (
  input: DisassociateTransitGatewayRouteTableCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DisassociateTransitGatewayRouteTableRequest(
      input,
      context
    ),
    Action: "DisassociateTransitGatewayRouteTable",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2DisassociateVpcCidrBlockCommand = async (
  input: DisassociateVpcCidrBlockCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2DisassociateVpcCidrBlockRequest(input, context),
    Action: "DisassociateVpcCidrBlock",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2EnableEbsEncryptionByDefaultCommand = async (
  input: EnableEbsEncryptionByDefaultCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2EnableEbsEncryptionByDefaultRequest(input, context),
    Action: "EnableEbsEncryptionByDefault",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2EnableFastSnapshotRestoresCommand = async (
  input: EnableFastSnapshotRestoresCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2EnableFastSnapshotRestoresRequest(input, context),
    Action: "EnableFastSnapshotRestores",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2EnableTransitGatewayRouteTablePropagationCommand = async (
  input: EnableTransitGatewayRouteTablePropagationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2EnableTransitGatewayRouteTablePropagationRequest(
      input,
      context
    ),
    Action: "EnableTransitGatewayRouteTablePropagation",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2EnableVgwRoutePropagationCommand = async (
  input: EnableVgwRoutePropagationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2EnableVgwRoutePropagationRequest(input, context),
    Action: "EnableVgwRoutePropagation",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2EnableVolumeIOCommand = async (
  input: EnableVolumeIOCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2EnableVolumeIORequest(input, context),
    Action: "EnableVolumeIO",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2EnableVpcClassicLinkCommand = async (
  input: EnableVpcClassicLinkCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2EnableVpcClassicLinkRequest(input, context),
    Action: "EnableVpcClassicLink",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2EnableVpcClassicLinkDnsSupportCommand = async (
  input: EnableVpcClassicLinkDnsSupportCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2EnableVpcClassicLinkDnsSupportRequest(input, context),
    Action: "EnableVpcClassicLinkDnsSupport",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2ExportClientVpnClientCertificateRevocationListCommand = async (
  input: ExportClientVpnClientCertificateRevocationListCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2ExportClientVpnClientCertificateRevocationListRequest(
      input,
      context
    ),
    Action: "ExportClientVpnClientCertificateRevocationList",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2ExportClientVpnClientConfigurationCommand = async (
  input: ExportClientVpnClientConfigurationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2ExportClientVpnClientConfigurationRequest(
      input,
      context
    ),
    Action: "ExportClientVpnClientConfiguration",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2ExportImageCommand = async (
  input: ExportImageCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2ExportImageRequest(input, context),
    Action: "ExportImage",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2ExportTransitGatewayRoutesCommand = async (
  input: ExportTransitGatewayRoutesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2ExportTransitGatewayRoutesRequest(input, context),
    Action: "ExportTransitGatewayRoutes",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2GetAssociatedIpv6PoolCidrsCommand = async (
  input: GetAssociatedIpv6PoolCidrsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2GetAssociatedIpv6PoolCidrsRequest(input, context),
    Action: "GetAssociatedIpv6PoolCidrs",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2GetCapacityReservationUsageCommand = async (
  input: GetCapacityReservationUsageCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2GetCapacityReservationUsageRequest(input, context),
    Action: "GetCapacityReservationUsage",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2GetCoipPoolUsageCommand = async (
  input: GetCoipPoolUsageCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2GetCoipPoolUsageRequest(input, context),
    Action: "GetCoipPoolUsage",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2GetConsoleOutputCommand = async (
  input: GetConsoleOutputCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2GetConsoleOutputRequest(input, context),
    Action: "GetConsoleOutput",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2GetConsoleScreenshotCommand = async (
  input: GetConsoleScreenshotCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2GetConsoleScreenshotRequest(input, context),
    Action: "GetConsoleScreenshot",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2GetDefaultCreditSpecificationCommand = async (
  input: GetDefaultCreditSpecificationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2GetDefaultCreditSpecificationRequest(input, context),
    Action: "GetDefaultCreditSpecification",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2GetEbsDefaultKmsKeyIdCommand = async (
  input: GetEbsDefaultKmsKeyIdCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2GetEbsDefaultKmsKeyIdRequest(input, context),
    Action: "GetEbsDefaultKmsKeyId",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2GetEbsEncryptionByDefaultCommand = async (
  input: GetEbsEncryptionByDefaultCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2GetEbsEncryptionByDefaultRequest(input, context),
    Action: "GetEbsEncryptionByDefault",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2GetHostReservationPurchasePreviewCommand = async (
  input: GetHostReservationPurchasePreviewCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2GetHostReservationPurchasePreviewRequest(input, context),
    Action: "GetHostReservationPurchasePreview",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2GetLaunchTemplateDataCommand = async (
  input: GetLaunchTemplateDataCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2GetLaunchTemplateDataRequest(input, context),
    Action: "GetLaunchTemplateData",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2GetPasswordDataCommand = async (
  input: GetPasswordDataCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2GetPasswordDataRequest(input, context),
    Action: "GetPasswordData",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2GetReservedInstancesExchangeQuoteCommand = async (
  input: GetReservedInstancesExchangeQuoteCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2GetReservedInstancesExchangeQuoteRequest(input, context),
    Action: "GetReservedInstancesExchangeQuote",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2GetTransitGatewayAttachmentPropagationsCommand = async (
  input: GetTransitGatewayAttachmentPropagationsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2GetTransitGatewayAttachmentPropagationsRequest(
      input,
      context
    ),
    Action: "GetTransitGatewayAttachmentPropagations",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2GetTransitGatewayMulticastDomainAssociationsCommand = async (
  input: GetTransitGatewayMulticastDomainAssociationsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2GetTransitGatewayMulticastDomainAssociationsRequest(
      input,
      context
    ),
    Action: "GetTransitGatewayMulticastDomainAssociations",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2GetTransitGatewayRouteTableAssociationsCommand = async (
  input: GetTransitGatewayRouteTableAssociationsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2GetTransitGatewayRouteTableAssociationsRequest(
      input,
      context
    ),
    Action: "GetTransitGatewayRouteTableAssociations",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2GetTransitGatewayRouteTablePropagationsCommand = async (
  input: GetTransitGatewayRouteTablePropagationsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2GetTransitGatewayRouteTablePropagationsRequest(
      input,
      context
    ),
    Action: "GetTransitGatewayRouteTablePropagations",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2ImportClientVpnClientCertificateRevocationListCommand = async (
  input: ImportClientVpnClientCertificateRevocationListCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2ImportClientVpnClientCertificateRevocationListRequest(
      input,
      context
    ),
    Action: "ImportClientVpnClientCertificateRevocationList",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2ImportImageCommand = async (
  input: ImportImageCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2ImportImageRequest(input, context),
    Action: "ImportImage",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2ImportInstanceCommand = async (
  input: ImportInstanceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2ImportInstanceRequest(input, context),
    Action: "ImportInstance",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2ImportKeyPairCommand = async (
  input: ImportKeyPairCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2ImportKeyPairRequest(input, context),
    Action: "ImportKeyPair",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2ImportSnapshotCommand = async (
  input: ImportSnapshotCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2ImportSnapshotRequest(input, context),
    Action: "ImportSnapshot",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2ImportVolumeCommand = async (
  input: ImportVolumeCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2ImportVolumeRequest(input, context),
    Action: "ImportVolume",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2ModifyCapacityReservationCommand = async (
  input: ModifyCapacityReservationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2ModifyCapacityReservationRequest(input, context),
    Action: "ModifyCapacityReservation",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2ModifyClientVpnEndpointCommand = async (
  input: ModifyClientVpnEndpointCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2ModifyClientVpnEndpointRequest(input, context),
    Action: "ModifyClientVpnEndpoint",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2ModifyDefaultCreditSpecificationCommand = async (
  input: ModifyDefaultCreditSpecificationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2ModifyDefaultCreditSpecificationRequest(input, context),
    Action: "ModifyDefaultCreditSpecification",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2ModifyEbsDefaultKmsKeyIdCommand = async (
  input: ModifyEbsDefaultKmsKeyIdCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2ModifyEbsDefaultKmsKeyIdRequest(input, context),
    Action: "ModifyEbsDefaultKmsKeyId",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2ModifyFleetCommand = async (
  input: ModifyFleetCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2ModifyFleetRequest(input, context),
    Action: "ModifyFleet",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2ModifyFpgaImageAttributeCommand = async (
  input: ModifyFpgaImageAttributeCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2ModifyFpgaImageAttributeRequest(input, context),
    Action: "ModifyFpgaImageAttribute",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2ModifyHostsCommand = async (
  input: ModifyHostsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2ModifyHostsRequest(input, context),
    Action: "ModifyHosts",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2ModifyIdentityIdFormatCommand = async (
  input: ModifyIdentityIdFormatCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2ModifyIdentityIdFormatRequest(input, context),
    Action: "ModifyIdentityIdFormat",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2ModifyIdFormatCommand = async (
  input: ModifyIdFormatCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2ModifyIdFormatRequest(input, context),
    Action: "ModifyIdFormat",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2ModifyImageAttributeCommand = async (
  input: ModifyImageAttributeCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2ModifyImageAttributeRequest(input, context),
    Action: "ModifyImageAttribute",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2ModifyInstanceAttributeCommand = async (
  input: ModifyInstanceAttributeCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2ModifyInstanceAttributeRequest(input, context),
    Action: "ModifyInstanceAttribute",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2ModifyInstanceCapacityReservationAttributesCommand = async (
  input: ModifyInstanceCapacityReservationAttributesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2ModifyInstanceCapacityReservationAttributesRequest(
      input,
      context
    ),
    Action: "ModifyInstanceCapacityReservationAttributes",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2ModifyInstanceCreditSpecificationCommand = async (
  input: ModifyInstanceCreditSpecificationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2ModifyInstanceCreditSpecificationRequest(input, context),
    Action: "ModifyInstanceCreditSpecification",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2ModifyInstanceEventStartTimeCommand = async (
  input: ModifyInstanceEventStartTimeCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2ModifyInstanceEventStartTimeRequest(input, context),
    Action: "ModifyInstanceEventStartTime",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2ModifyInstanceMetadataOptionsCommand = async (
  input: ModifyInstanceMetadataOptionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2ModifyInstanceMetadataOptionsRequest(input, context),
    Action: "ModifyInstanceMetadataOptions",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2ModifyInstancePlacementCommand = async (
  input: ModifyInstancePlacementCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2ModifyInstancePlacementRequest(input, context),
    Action: "ModifyInstancePlacement",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2ModifyLaunchTemplateCommand = async (
  input: ModifyLaunchTemplateCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2ModifyLaunchTemplateRequest(input, context),
    Action: "ModifyLaunchTemplate",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2ModifyNetworkInterfaceAttributeCommand = async (
  input: ModifyNetworkInterfaceAttributeCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2ModifyNetworkInterfaceAttributeRequest(input, context),
    Action: "ModifyNetworkInterfaceAttribute",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2ModifyReservedInstancesCommand = async (
  input: ModifyReservedInstancesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2ModifyReservedInstancesRequest(input, context),
    Action: "ModifyReservedInstances",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2ModifySnapshotAttributeCommand = async (
  input: ModifySnapshotAttributeCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2ModifySnapshotAttributeRequest(input, context),
    Action: "ModifySnapshotAttribute",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2ModifySpotFleetRequestCommand = async (
  input: ModifySpotFleetRequestCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2ModifySpotFleetRequestRequest(input, context),
    Action: "ModifySpotFleetRequest",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2ModifySubnetAttributeCommand = async (
  input: ModifySubnetAttributeCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2ModifySubnetAttributeRequest(input, context),
    Action: "ModifySubnetAttribute",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2ModifyTrafficMirrorFilterNetworkServicesCommand = async (
  input: ModifyTrafficMirrorFilterNetworkServicesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2ModifyTrafficMirrorFilterNetworkServicesRequest(
      input,
      context
    ),
    Action: "ModifyTrafficMirrorFilterNetworkServices",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2ModifyTrafficMirrorFilterRuleCommand = async (
  input: ModifyTrafficMirrorFilterRuleCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2ModifyTrafficMirrorFilterRuleRequest(input, context),
    Action: "ModifyTrafficMirrorFilterRule",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2ModifyTrafficMirrorSessionCommand = async (
  input: ModifyTrafficMirrorSessionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2ModifyTrafficMirrorSessionRequest(input, context),
    Action: "ModifyTrafficMirrorSession",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2ModifyTransitGatewayVpcAttachmentCommand = async (
  input: ModifyTransitGatewayVpcAttachmentCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2ModifyTransitGatewayVpcAttachmentRequest(input, context),
    Action: "ModifyTransitGatewayVpcAttachment",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2ModifyVolumeCommand = async (
  input: ModifyVolumeCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2ModifyVolumeRequest(input, context),
    Action: "ModifyVolume",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2ModifyVolumeAttributeCommand = async (
  input: ModifyVolumeAttributeCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2ModifyVolumeAttributeRequest(input, context),
    Action: "ModifyVolumeAttribute",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2ModifyVpcAttributeCommand = async (
  input: ModifyVpcAttributeCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2ModifyVpcAttributeRequest(input, context),
    Action: "ModifyVpcAttribute",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2ModifyVpcEndpointCommand = async (
  input: ModifyVpcEndpointCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2ModifyVpcEndpointRequest(input, context),
    Action: "ModifyVpcEndpoint",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2ModifyVpcEndpointConnectionNotificationCommand = async (
  input: ModifyVpcEndpointConnectionNotificationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2ModifyVpcEndpointConnectionNotificationRequest(
      input,
      context
    ),
    Action: "ModifyVpcEndpointConnectionNotification",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2ModifyVpcEndpointServiceConfigurationCommand = async (
  input: ModifyVpcEndpointServiceConfigurationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2ModifyVpcEndpointServiceConfigurationRequest(
      input,
      context
    ),
    Action: "ModifyVpcEndpointServiceConfiguration",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2ModifyVpcEndpointServicePermissionsCommand = async (
  input: ModifyVpcEndpointServicePermissionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2ModifyVpcEndpointServicePermissionsRequest(
      input,
      context
    ),
    Action: "ModifyVpcEndpointServicePermissions",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2ModifyVpcPeeringConnectionOptionsCommand = async (
  input: ModifyVpcPeeringConnectionOptionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2ModifyVpcPeeringConnectionOptionsRequest(input, context),
    Action: "ModifyVpcPeeringConnectionOptions",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2ModifyVpcTenancyCommand = async (
  input: ModifyVpcTenancyCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2ModifyVpcTenancyRequest(input, context),
    Action: "ModifyVpcTenancy",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2ModifyVpnConnectionCommand = async (
  input: ModifyVpnConnectionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2ModifyVpnConnectionRequest(input, context),
    Action: "ModifyVpnConnection",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2ModifyVpnTunnelCertificateCommand = async (
  input: ModifyVpnTunnelCertificateCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2ModifyVpnTunnelCertificateRequest(input, context),
    Action: "ModifyVpnTunnelCertificate",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2ModifyVpnTunnelOptionsCommand = async (
  input: ModifyVpnTunnelOptionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2ModifyVpnTunnelOptionsRequest(input, context),
    Action: "ModifyVpnTunnelOptions",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2MonitorInstancesCommand = async (
  input: MonitorInstancesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2MonitorInstancesRequest(input, context),
    Action: "MonitorInstances",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2MoveAddressToVpcCommand = async (
  input: MoveAddressToVpcCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2MoveAddressToVpcRequest(input, context),
    Action: "MoveAddressToVpc",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2ProvisionByoipCidrCommand = async (
  input: ProvisionByoipCidrCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2ProvisionByoipCidrRequest(input, context),
    Action: "ProvisionByoipCidr",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2PurchaseHostReservationCommand = async (
  input: PurchaseHostReservationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2PurchaseHostReservationRequest(input, context),
    Action: "PurchaseHostReservation",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2PurchaseReservedInstancesOfferingCommand = async (
  input: PurchaseReservedInstancesOfferingCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2PurchaseReservedInstancesOfferingRequest(input, context),
    Action: "PurchaseReservedInstancesOffering",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2PurchaseScheduledInstancesCommand = async (
  input: PurchaseScheduledInstancesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2PurchaseScheduledInstancesRequest(input, context),
    Action: "PurchaseScheduledInstances",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2RebootInstancesCommand = async (
  input: RebootInstancesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2RebootInstancesRequest(input, context),
    Action: "RebootInstances",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2RegisterImageCommand = async (
  input: RegisterImageCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2RegisterImageRequest(input, context),
    Action: "RegisterImage",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2RegisterTransitGatewayMulticastGroupMembersCommand = async (
  input: RegisterTransitGatewayMulticastGroupMembersCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2RegisterTransitGatewayMulticastGroupMembersRequest(
      input,
      context
    ),
    Action: "RegisterTransitGatewayMulticastGroupMembers",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2RegisterTransitGatewayMulticastGroupSourcesCommand = async (
  input: RegisterTransitGatewayMulticastGroupSourcesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2RegisterTransitGatewayMulticastGroupSourcesRequest(
      input,
      context
    ),
    Action: "RegisterTransitGatewayMulticastGroupSources",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2RejectTransitGatewayPeeringAttachmentCommand = async (
  input: RejectTransitGatewayPeeringAttachmentCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2RejectTransitGatewayPeeringAttachmentRequest(
      input,
      context
    ),
    Action: "RejectTransitGatewayPeeringAttachment",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2RejectTransitGatewayVpcAttachmentCommand = async (
  input: RejectTransitGatewayVpcAttachmentCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2RejectTransitGatewayVpcAttachmentRequest(input, context),
    Action: "RejectTransitGatewayVpcAttachment",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2RejectVpcEndpointConnectionsCommand = async (
  input: RejectVpcEndpointConnectionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2RejectVpcEndpointConnectionsRequest(input, context),
    Action: "RejectVpcEndpointConnections",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2RejectVpcPeeringConnectionCommand = async (
  input: RejectVpcPeeringConnectionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2RejectVpcPeeringConnectionRequest(input, context),
    Action: "RejectVpcPeeringConnection",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2ReleaseAddressCommand = async (
  input: ReleaseAddressCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2ReleaseAddressRequest(input, context),
    Action: "ReleaseAddress",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2ReleaseHostsCommand = async (
  input: ReleaseHostsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2ReleaseHostsRequest(input, context),
    Action: "ReleaseHosts",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2ReplaceIamInstanceProfileAssociationCommand = async (
  input: ReplaceIamInstanceProfileAssociationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2ReplaceIamInstanceProfileAssociationRequest(
      input,
      context
    ),
    Action: "ReplaceIamInstanceProfileAssociation",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2ReplaceNetworkAclAssociationCommand = async (
  input: ReplaceNetworkAclAssociationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2ReplaceNetworkAclAssociationRequest(input, context),
    Action: "ReplaceNetworkAclAssociation",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2ReplaceNetworkAclEntryCommand = async (
  input: ReplaceNetworkAclEntryCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2ReplaceNetworkAclEntryRequest(input, context),
    Action: "ReplaceNetworkAclEntry",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2ReplaceRouteCommand = async (
  input: ReplaceRouteCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2ReplaceRouteRequest(input, context),
    Action: "ReplaceRoute",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2ReplaceRouteTableAssociationCommand = async (
  input: ReplaceRouteTableAssociationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2ReplaceRouteTableAssociationRequest(input, context),
    Action: "ReplaceRouteTableAssociation",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2ReplaceTransitGatewayRouteCommand = async (
  input: ReplaceTransitGatewayRouteCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2ReplaceTransitGatewayRouteRequest(input, context),
    Action: "ReplaceTransitGatewayRoute",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2ReportInstanceStatusCommand = async (
  input: ReportInstanceStatusCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2ReportInstanceStatusRequest(input, context),
    Action: "ReportInstanceStatus",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2RequestSpotFleetCommand = async (
  input: RequestSpotFleetCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2RequestSpotFleetRequest(input, context),
    Action: "RequestSpotFleet",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2RequestSpotInstancesCommand = async (
  input: RequestSpotInstancesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2RequestSpotInstancesRequest(input, context),
    Action: "RequestSpotInstances",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2ResetEbsDefaultKmsKeyIdCommand = async (
  input: ResetEbsDefaultKmsKeyIdCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2ResetEbsDefaultKmsKeyIdRequest(input, context),
    Action: "ResetEbsDefaultKmsKeyId",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2ResetFpgaImageAttributeCommand = async (
  input: ResetFpgaImageAttributeCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2ResetFpgaImageAttributeRequest(input, context),
    Action: "ResetFpgaImageAttribute",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2ResetImageAttributeCommand = async (
  input: ResetImageAttributeCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2ResetImageAttributeRequest(input, context),
    Action: "ResetImageAttribute",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2ResetInstanceAttributeCommand = async (
  input: ResetInstanceAttributeCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2ResetInstanceAttributeRequest(input, context),
    Action: "ResetInstanceAttribute",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2ResetNetworkInterfaceAttributeCommand = async (
  input: ResetNetworkInterfaceAttributeCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2ResetNetworkInterfaceAttributeRequest(input, context),
    Action: "ResetNetworkInterfaceAttribute",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2ResetSnapshotAttributeCommand = async (
  input: ResetSnapshotAttributeCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2ResetSnapshotAttributeRequest(input, context),
    Action: "ResetSnapshotAttribute",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2RestoreAddressToClassicCommand = async (
  input: RestoreAddressToClassicCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2RestoreAddressToClassicRequest(input, context),
    Action: "RestoreAddressToClassic",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2RevokeClientVpnIngressCommand = async (
  input: RevokeClientVpnIngressCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2RevokeClientVpnIngressRequest(input, context),
    Action: "RevokeClientVpnIngress",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2RevokeSecurityGroupEgressCommand = async (
  input: RevokeSecurityGroupEgressCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2RevokeSecurityGroupEgressRequest(input, context),
    Action: "RevokeSecurityGroupEgress",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2RevokeSecurityGroupIngressCommand = async (
  input: RevokeSecurityGroupIngressCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2RevokeSecurityGroupIngressRequest(input, context),
    Action: "RevokeSecurityGroupIngress",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2RunInstancesCommand = async (
  input: RunInstancesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2RunInstancesRequest(input, context),
    Action: "RunInstances",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2RunScheduledInstancesCommand = async (
  input: RunScheduledInstancesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2RunScheduledInstancesRequest(input, context),
    Action: "RunScheduledInstances",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2SearchLocalGatewayRoutesCommand = async (
  input: SearchLocalGatewayRoutesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2SearchLocalGatewayRoutesRequest(input, context),
    Action: "SearchLocalGatewayRoutes",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2SearchTransitGatewayMulticastGroupsCommand = async (
  input: SearchTransitGatewayMulticastGroupsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2SearchTransitGatewayMulticastGroupsRequest(
      input,
      context
    ),
    Action: "SearchTransitGatewayMulticastGroups",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2SearchTransitGatewayRoutesCommand = async (
  input: SearchTransitGatewayRoutesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2SearchTransitGatewayRoutesRequest(input, context),
    Action: "SearchTransitGatewayRoutes",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2SendDiagnosticInterruptCommand = async (
  input: SendDiagnosticInterruptCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2SendDiagnosticInterruptRequest(input, context),
    Action: "SendDiagnosticInterrupt",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2StartInstancesCommand = async (
  input: StartInstancesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2StartInstancesRequest(input, context),
    Action: "StartInstances",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2StartVpcEndpointServicePrivateDnsVerificationCommand = async (
  input: StartVpcEndpointServicePrivateDnsVerificationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2StartVpcEndpointServicePrivateDnsVerificationRequest(
      input,
      context
    ),
    Action: "StartVpcEndpointServicePrivateDnsVerification",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2StopInstancesCommand = async (
  input: StopInstancesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2StopInstancesRequest(input, context),
    Action: "StopInstances",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2TerminateClientVpnConnectionsCommand = async (
  input: TerminateClientVpnConnectionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2TerminateClientVpnConnectionsRequest(input, context),
    Action: "TerminateClientVpnConnections",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2TerminateInstancesCommand = async (
  input: TerminateInstancesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2TerminateInstancesRequest(input, context),
    Action: "TerminateInstances",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2UnassignIpv6AddressesCommand = async (
  input: UnassignIpv6AddressesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2UnassignIpv6AddressesRequest(input, context),
    Action: "UnassignIpv6Addresses",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2UnassignPrivateIpAddressesCommand = async (
  input: UnassignPrivateIpAddressesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2UnassignPrivateIpAddressesRequest(input, context),
    Action: "UnassignPrivateIpAddresses",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2UnmonitorInstancesCommand = async (
  input: UnmonitorInstancesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2UnmonitorInstancesRequest(input, context),
    Action: "UnmonitorInstances",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2UpdateSecurityGroupRuleDescriptionsEgressCommand = async (
  input: UpdateSecurityGroupRuleDescriptionsEgressCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2UpdateSecurityGroupRuleDescriptionsEgressRequest(
      input,
      context
    ),
    Action: "UpdateSecurityGroupRuleDescriptionsEgress",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2UpdateSecurityGroupRuleDescriptionsIngressCommand = async (
  input: UpdateSecurityGroupRuleDescriptionsIngressCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2UpdateSecurityGroupRuleDescriptionsIngressRequest(
      input,
      context
    ),
    Action: "UpdateSecurityGroupRuleDescriptionsIngress",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_ec2WithdrawByoipCidrCommand = async (
  input: WithdrawByoipCidrCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  let body: any;
  body = buildFormUrlencodedString({
    ...serializeAws_ec2WithdrawByoipCidrRequest(input, context),
    Action: "WithdrawByoipCidr",
    Version: "2016-11-15"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const deserializeAws_ec2AcceptReservedInstancesExchangeQuoteCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AcceptReservedInstancesExchangeQuoteCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2AcceptReservedInstancesExchangeQuoteCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2AcceptReservedInstancesExchangeQuoteResult(
    data,
    context
  );
  const response: AcceptReservedInstancesExchangeQuoteCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "AcceptReservedInstancesExchangeQuoteResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2AcceptReservedInstancesExchangeQuoteCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AcceptReservedInstancesExchangeQuoteCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2AcceptTransitGatewayPeeringAttachmentCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AcceptTransitGatewayPeeringAttachmentCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2AcceptTransitGatewayPeeringAttachmentCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2AcceptTransitGatewayPeeringAttachmentResult(
    data,
    context
  );
  const response: AcceptTransitGatewayPeeringAttachmentCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "AcceptTransitGatewayPeeringAttachmentResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2AcceptTransitGatewayPeeringAttachmentCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AcceptTransitGatewayPeeringAttachmentCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2AcceptTransitGatewayVpcAttachmentCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AcceptTransitGatewayVpcAttachmentCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2AcceptTransitGatewayVpcAttachmentCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2AcceptTransitGatewayVpcAttachmentResult(
    data,
    context
  );
  const response: AcceptTransitGatewayVpcAttachmentCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "AcceptTransitGatewayVpcAttachmentResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2AcceptTransitGatewayVpcAttachmentCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AcceptTransitGatewayVpcAttachmentCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2AcceptVpcEndpointConnectionsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AcceptVpcEndpointConnectionsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2AcceptVpcEndpointConnectionsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2AcceptVpcEndpointConnectionsResult(
    data,
    context
  );
  const response: AcceptVpcEndpointConnectionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "AcceptVpcEndpointConnectionsResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2AcceptVpcEndpointConnectionsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AcceptVpcEndpointConnectionsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2AcceptVpcPeeringConnectionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AcceptVpcPeeringConnectionCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2AcceptVpcPeeringConnectionCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2AcceptVpcPeeringConnectionResult(data, context);
  const response: AcceptVpcPeeringConnectionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "AcceptVpcPeeringConnectionResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2AcceptVpcPeeringConnectionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AcceptVpcPeeringConnectionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2AdvertiseByoipCidrCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AdvertiseByoipCidrCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2AdvertiseByoipCidrCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2AdvertiseByoipCidrResult(data, context);
  const response: AdvertiseByoipCidrCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "AdvertiseByoipCidrResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2AdvertiseByoipCidrCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AdvertiseByoipCidrCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2AllocateAddressCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AllocateAddressCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2AllocateAddressCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2AllocateAddressResult(data, context);
  const response: AllocateAddressCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "AllocateAddressResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2AllocateAddressCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AllocateAddressCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2AllocateHostsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AllocateHostsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2AllocateHostsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2AllocateHostsResult(data, context);
  const response: AllocateHostsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "AllocateHostsResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2AllocateHostsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AllocateHostsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2ApplySecurityGroupsToClientVpnTargetNetworkCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ApplySecurityGroupsToClientVpnTargetNetworkCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2ApplySecurityGroupsToClientVpnTargetNetworkCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2ApplySecurityGroupsToClientVpnTargetNetworkResult(
    data,
    context
  );
  const response: ApplySecurityGroupsToClientVpnTargetNetworkCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ApplySecurityGroupsToClientVpnTargetNetworkResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2ApplySecurityGroupsToClientVpnTargetNetworkCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ApplySecurityGroupsToClientVpnTargetNetworkCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2AssignIpv6AddressesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AssignIpv6AddressesCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2AssignIpv6AddressesCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2AssignIpv6AddressesResult(data, context);
  const response: AssignIpv6AddressesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "AssignIpv6AddressesResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2AssignIpv6AddressesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AssignIpv6AddressesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2AssignPrivateIpAddressesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AssignPrivateIpAddressesCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2AssignPrivateIpAddressesCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2AssignPrivateIpAddressesResult(data, context);
  const response: AssignPrivateIpAddressesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "AssignPrivateIpAddressesResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2AssignPrivateIpAddressesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AssignPrivateIpAddressesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2AssociateAddressCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AssociateAddressCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2AssociateAddressCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2AssociateAddressResult(data, context);
  const response: AssociateAddressCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "AssociateAddressResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2AssociateAddressCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AssociateAddressCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2AssociateClientVpnTargetNetworkCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AssociateClientVpnTargetNetworkCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2AssociateClientVpnTargetNetworkCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2AssociateClientVpnTargetNetworkResult(
    data,
    context
  );
  const response: AssociateClientVpnTargetNetworkCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "AssociateClientVpnTargetNetworkResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2AssociateClientVpnTargetNetworkCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AssociateClientVpnTargetNetworkCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2AssociateDhcpOptionsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AssociateDhcpOptionsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2AssociateDhcpOptionsCommandError(output, context);
  }
  await collectBody(output.body, context);
  const response: AssociateDhcpOptionsCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2AssociateDhcpOptionsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AssociateDhcpOptionsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2AssociateIamInstanceProfileCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AssociateIamInstanceProfileCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2AssociateIamInstanceProfileCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2AssociateIamInstanceProfileResult(data, context);
  const response: AssociateIamInstanceProfileCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "AssociateIamInstanceProfileResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2AssociateIamInstanceProfileCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AssociateIamInstanceProfileCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2AssociateRouteTableCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AssociateRouteTableCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2AssociateRouteTableCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2AssociateRouteTableResult(data, context);
  const response: AssociateRouteTableCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "AssociateRouteTableResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2AssociateRouteTableCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AssociateRouteTableCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2AssociateSubnetCidrBlockCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AssociateSubnetCidrBlockCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2AssociateSubnetCidrBlockCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2AssociateSubnetCidrBlockResult(data, context);
  const response: AssociateSubnetCidrBlockCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "AssociateSubnetCidrBlockResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2AssociateSubnetCidrBlockCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AssociateSubnetCidrBlockCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2AssociateTransitGatewayMulticastDomainCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AssociateTransitGatewayMulticastDomainCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2AssociateTransitGatewayMulticastDomainCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2AssociateTransitGatewayMulticastDomainResult(
    data,
    context
  );
  const response: AssociateTransitGatewayMulticastDomainCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "AssociateTransitGatewayMulticastDomainResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2AssociateTransitGatewayMulticastDomainCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AssociateTransitGatewayMulticastDomainCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2AssociateTransitGatewayRouteTableCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AssociateTransitGatewayRouteTableCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2AssociateTransitGatewayRouteTableCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2AssociateTransitGatewayRouteTableResult(
    data,
    context
  );
  const response: AssociateTransitGatewayRouteTableCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "AssociateTransitGatewayRouteTableResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2AssociateTransitGatewayRouteTableCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AssociateTransitGatewayRouteTableCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2AssociateVpcCidrBlockCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AssociateVpcCidrBlockCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2AssociateVpcCidrBlockCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2AssociateVpcCidrBlockResult(data, context);
  const response: AssociateVpcCidrBlockCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "AssociateVpcCidrBlockResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2AssociateVpcCidrBlockCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AssociateVpcCidrBlockCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2AttachClassicLinkVpcCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AttachClassicLinkVpcCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2AttachClassicLinkVpcCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2AttachClassicLinkVpcResult(data, context);
  const response: AttachClassicLinkVpcCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "AttachClassicLinkVpcResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2AttachClassicLinkVpcCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AttachClassicLinkVpcCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2AttachInternetGatewayCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AttachInternetGatewayCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2AttachInternetGatewayCommandError(output, context);
  }
  await collectBody(output.body, context);
  const response: AttachInternetGatewayCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2AttachInternetGatewayCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AttachInternetGatewayCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2AttachNetworkInterfaceCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AttachNetworkInterfaceCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2AttachNetworkInterfaceCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2AttachNetworkInterfaceResult(data, context);
  const response: AttachNetworkInterfaceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "AttachNetworkInterfaceResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2AttachNetworkInterfaceCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AttachNetworkInterfaceCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2AttachVolumeCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AttachVolumeCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2AttachVolumeCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2VolumeAttachment(data, context);
  const response: AttachVolumeCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "VolumeAttachment",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2AttachVolumeCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AttachVolumeCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2AttachVpnGatewayCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AttachVpnGatewayCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2AttachVpnGatewayCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2AttachVpnGatewayResult(data, context);
  const response: AttachVpnGatewayCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "AttachVpnGatewayResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2AttachVpnGatewayCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AttachVpnGatewayCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2AuthorizeClientVpnIngressCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AuthorizeClientVpnIngressCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2AuthorizeClientVpnIngressCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2AuthorizeClientVpnIngressResult(data, context);
  const response: AuthorizeClientVpnIngressCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "AuthorizeClientVpnIngressResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2AuthorizeClientVpnIngressCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AuthorizeClientVpnIngressCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2AuthorizeSecurityGroupEgressCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AuthorizeSecurityGroupEgressCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2AuthorizeSecurityGroupEgressCommandError(
      output,
      context
    );
  }
  await collectBody(output.body, context);
  const response: AuthorizeSecurityGroupEgressCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2AuthorizeSecurityGroupEgressCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AuthorizeSecurityGroupEgressCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2AuthorizeSecurityGroupIngressCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AuthorizeSecurityGroupIngressCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2AuthorizeSecurityGroupIngressCommandError(
      output,
      context
    );
  }
  await collectBody(output.body, context);
  const response: AuthorizeSecurityGroupIngressCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2AuthorizeSecurityGroupIngressCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AuthorizeSecurityGroupIngressCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2BundleInstanceCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BundleInstanceCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2BundleInstanceCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2BundleInstanceResult(data, context);
  const response: BundleInstanceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "BundleInstanceResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2BundleInstanceCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BundleInstanceCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2CancelBundleTaskCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CancelBundleTaskCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2CancelBundleTaskCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2CancelBundleTaskResult(data, context);
  const response: CancelBundleTaskCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CancelBundleTaskResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2CancelBundleTaskCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CancelBundleTaskCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2CancelCapacityReservationCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CancelCapacityReservationCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2CancelCapacityReservationCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2CancelCapacityReservationResult(data, context);
  const response: CancelCapacityReservationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CancelCapacityReservationResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2CancelCapacityReservationCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CancelCapacityReservationCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2CancelConversionTaskCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CancelConversionTaskCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2CancelConversionTaskCommandError(output, context);
  }
  await collectBody(output.body, context);
  const response: CancelConversionTaskCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2CancelConversionTaskCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CancelConversionTaskCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2CancelExportTaskCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CancelExportTaskCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2CancelExportTaskCommandError(output, context);
  }
  await collectBody(output.body, context);
  const response: CancelExportTaskCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2CancelExportTaskCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CancelExportTaskCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2CancelImportTaskCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CancelImportTaskCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2CancelImportTaskCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2CancelImportTaskResult(data, context);
  const response: CancelImportTaskCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CancelImportTaskResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2CancelImportTaskCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CancelImportTaskCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2CancelReservedInstancesListingCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CancelReservedInstancesListingCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2CancelReservedInstancesListingCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2CancelReservedInstancesListingResult(
    data,
    context
  );
  const response: CancelReservedInstancesListingCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CancelReservedInstancesListingResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2CancelReservedInstancesListingCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CancelReservedInstancesListingCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2CancelSpotFleetRequestsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CancelSpotFleetRequestsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2CancelSpotFleetRequestsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2CancelSpotFleetRequestsResponse(data, context);
  const response: CancelSpotFleetRequestsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CancelSpotFleetRequestsResponse",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2CancelSpotFleetRequestsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CancelSpotFleetRequestsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2CancelSpotInstanceRequestsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CancelSpotInstanceRequestsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2CancelSpotInstanceRequestsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2CancelSpotInstanceRequestsResult(data, context);
  const response: CancelSpotInstanceRequestsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CancelSpotInstanceRequestsResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2CancelSpotInstanceRequestsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CancelSpotInstanceRequestsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2ConfirmProductInstanceCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ConfirmProductInstanceCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2ConfirmProductInstanceCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2ConfirmProductInstanceResult(data, context);
  const response: ConfirmProductInstanceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ConfirmProductInstanceResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2ConfirmProductInstanceCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ConfirmProductInstanceCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2CopyFpgaImageCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CopyFpgaImageCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2CopyFpgaImageCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2CopyFpgaImageResult(data, context);
  const response: CopyFpgaImageCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CopyFpgaImageResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2CopyFpgaImageCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CopyFpgaImageCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2CopyImageCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CopyImageCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2CopyImageCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2CopyImageResult(data, context);
  const response: CopyImageCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CopyImageResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2CopyImageCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CopyImageCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2CopySnapshotCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CopySnapshotCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2CopySnapshotCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2CopySnapshotResult(data, context);
  const response: CopySnapshotCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CopySnapshotResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2CopySnapshotCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CopySnapshotCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2CreateCapacityReservationCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateCapacityReservationCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2CreateCapacityReservationCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2CreateCapacityReservationResult(data, context);
  const response: CreateCapacityReservationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateCapacityReservationResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2CreateCapacityReservationCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateCapacityReservationCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2CreateClientVpnEndpointCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateClientVpnEndpointCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2CreateClientVpnEndpointCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2CreateClientVpnEndpointResult(data, context);
  const response: CreateClientVpnEndpointCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateClientVpnEndpointResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2CreateClientVpnEndpointCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateClientVpnEndpointCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2CreateClientVpnRouteCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateClientVpnRouteCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2CreateClientVpnRouteCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2CreateClientVpnRouteResult(data, context);
  const response: CreateClientVpnRouteCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateClientVpnRouteResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2CreateClientVpnRouteCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateClientVpnRouteCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2CreateCustomerGatewayCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateCustomerGatewayCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2CreateCustomerGatewayCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2CreateCustomerGatewayResult(data, context);
  const response: CreateCustomerGatewayCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateCustomerGatewayResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2CreateCustomerGatewayCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateCustomerGatewayCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2CreateDefaultSubnetCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDefaultSubnetCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2CreateDefaultSubnetCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2CreateDefaultSubnetResult(data, context);
  const response: CreateDefaultSubnetCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateDefaultSubnetResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2CreateDefaultSubnetCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDefaultSubnetCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2CreateDefaultVpcCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDefaultVpcCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2CreateDefaultVpcCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2CreateDefaultVpcResult(data, context);
  const response: CreateDefaultVpcCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateDefaultVpcResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2CreateDefaultVpcCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDefaultVpcCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2CreateDhcpOptionsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDhcpOptionsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2CreateDhcpOptionsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2CreateDhcpOptionsResult(data, context);
  const response: CreateDhcpOptionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateDhcpOptionsResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2CreateDhcpOptionsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDhcpOptionsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2CreateEgressOnlyInternetGatewayCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateEgressOnlyInternetGatewayCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2CreateEgressOnlyInternetGatewayCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2CreateEgressOnlyInternetGatewayResult(
    data,
    context
  );
  const response: CreateEgressOnlyInternetGatewayCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateEgressOnlyInternetGatewayResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2CreateEgressOnlyInternetGatewayCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateEgressOnlyInternetGatewayCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2CreateFleetCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateFleetCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2CreateFleetCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2CreateFleetResult(data, context);
  const response: CreateFleetCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateFleetResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2CreateFleetCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateFleetCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2CreateFlowLogsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateFlowLogsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2CreateFlowLogsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2CreateFlowLogsResult(data, context);
  const response: CreateFlowLogsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateFlowLogsResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2CreateFlowLogsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateFlowLogsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2CreateFpgaImageCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateFpgaImageCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2CreateFpgaImageCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2CreateFpgaImageResult(data, context);
  const response: CreateFpgaImageCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateFpgaImageResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2CreateFpgaImageCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateFpgaImageCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2CreateImageCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateImageCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2CreateImageCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2CreateImageResult(data, context);
  const response: CreateImageCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateImageResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2CreateImageCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateImageCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2CreateInstanceExportTaskCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateInstanceExportTaskCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2CreateInstanceExportTaskCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2CreateInstanceExportTaskResult(data, context);
  const response: CreateInstanceExportTaskCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateInstanceExportTaskResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2CreateInstanceExportTaskCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateInstanceExportTaskCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2CreateInternetGatewayCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateInternetGatewayCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2CreateInternetGatewayCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2CreateInternetGatewayResult(data, context);
  const response: CreateInternetGatewayCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateInternetGatewayResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2CreateInternetGatewayCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateInternetGatewayCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2CreateKeyPairCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateKeyPairCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2CreateKeyPairCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2KeyPair(data, context);
  const response: CreateKeyPairCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "KeyPair",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2CreateKeyPairCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateKeyPairCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2CreateLaunchTemplateCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateLaunchTemplateCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2CreateLaunchTemplateCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2CreateLaunchTemplateResult(data, context);
  const response: CreateLaunchTemplateCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateLaunchTemplateResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2CreateLaunchTemplateCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateLaunchTemplateCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2CreateLaunchTemplateVersionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateLaunchTemplateVersionCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2CreateLaunchTemplateVersionCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2CreateLaunchTemplateVersionResult(data, context);
  const response: CreateLaunchTemplateVersionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateLaunchTemplateVersionResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2CreateLaunchTemplateVersionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateLaunchTemplateVersionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2CreateLocalGatewayRouteCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateLocalGatewayRouteCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2CreateLocalGatewayRouteCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2CreateLocalGatewayRouteResult(data, context);
  const response: CreateLocalGatewayRouteCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateLocalGatewayRouteResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2CreateLocalGatewayRouteCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateLocalGatewayRouteCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2CreateLocalGatewayRouteTableVpcAssociationCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateLocalGatewayRouteTableVpcAssociationCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2CreateLocalGatewayRouteTableVpcAssociationCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2CreateLocalGatewayRouteTableVpcAssociationResult(
    data,
    context
  );
  const response: CreateLocalGatewayRouteTableVpcAssociationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateLocalGatewayRouteTableVpcAssociationResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2CreateLocalGatewayRouteTableVpcAssociationCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateLocalGatewayRouteTableVpcAssociationCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2CreateNatGatewayCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateNatGatewayCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2CreateNatGatewayCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2CreateNatGatewayResult(data, context);
  const response: CreateNatGatewayCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateNatGatewayResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2CreateNatGatewayCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateNatGatewayCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2CreateNetworkAclCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateNetworkAclCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2CreateNetworkAclCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2CreateNetworkAclResult(data, context);
  const response: CreateNetworkAclCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateNetworkAclResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2CreateNetworkAclCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateNetworkAclCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2CreateNetworkAclEntryCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateNetworkAclEntryCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2CreateNetworkAclEntryCommandError(output, context);
  }
  await collectBody(output.body, context);
  const response: CreateNetworkAclEntryCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2CreateNetworkAclEntryCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateNetworkAclEntryCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2CreateNetworkInterfaceCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateNetworkInterfaceCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2CreateNetworkInterfaceCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2CreateNetworkInterfaceResult(data, context);
  const response: CreateNetworkInterfaceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateNetworkInterfaceResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2CreateNetworkInterfaceCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateNetworkInterfaceCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2CreateNetworkInterfacePermissionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateNetworkInterfacePermissionCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2CreateNetworkInterfacePermissionCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2CreateNetworkInterfacePermissionResult(
    data,
    context
  );
  const response: CreateNetworkInterfacePermissionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateNetworkInterfacePermissionResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2CreateNetworkInterfacePermissionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateNetworkInterfacePermissionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2CreatePlacementGroupCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreatePlacementGroupCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2CreatePlacementGroupCommandError(output, context);
  }
  await collectBody(output.body, context);
  const response: CreatePlacementGroupCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2CreatePlacementGroupCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreatePlacementGroupCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2CreateReservedInstancesListingCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateReservedInstancesListingCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2CreateReservedInstancesListingCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2CreateReservedInstancesListingResult(
    data,
    context
  );
  const response: CreateReservedInstancesListingCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateReservedInstancesListingResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2CreateReservedInstancesListingCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateReservedInstancesListingCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2CreateRouteCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateRouteCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2CreateRouteCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2CreateRouteResult(data, context);
  const response: CreateRouteCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateRouteResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2CreateRouteCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateRouteCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2CreateRouteTableCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateRouteTableCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2CreateRouteTableCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2CreateRouteTableResult(data, context);
  const response: CreateRouteTableCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateRouteTableResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2CreateRouteTableCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateRouteTableCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2CreateSecurityGroupCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateSecurityGroupCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2CreateSecurityGroupCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2CreateSecurityGroupResult(data, context);
  const response: CreateSecurityGroupCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateSecurityGroupResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2CreateSecurityGroupCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateSecurityGroupCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2CreateSnapshotCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateSnapshotCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2CreateSnapshotCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2Snapshot(data, context);
  const response: CreateSnapshotCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "Snapshot",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2CreateSnapshotCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateSnapshotCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2CreateSnapshotsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateSnapshotsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2CreateSnapshotsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2CreateSnapshotsResult(data, context);
  const response: CreateSnapshotsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateSnapshotsResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2CreateSnapshotsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateSnapshotsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2CreateSpotDatafeedSubscriptionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateSpotDatafeedSubscriptionCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2CreateSpotDatafeedSubscriptionCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2CreateSpotDatafeedSubscriptionResult(
    data,
    context
  );
  const response: CreateSpotDatafeedSubscriptionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateSpotDatafeedSubscriptionResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2CreateSpotDatafeedSubscriptionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateSpotDatafeedSubscriptionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2CreateSubnetCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateSubnetCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2CreateSubnetCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2CreateSubnetResult(data, context);
  const response: CreateSubnetCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateSubnetResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2CreateSubnetCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateSubnetCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2CreateTagsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateTagsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2CreateTagsCommandError(output, context);
  }
  await collectBody(output.body, context);
  const response: CreateTagsCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2CreateTagsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateTagsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2CreateTrafficMirrorFilterCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateTrafficMirrorFilterCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2CreateTrafficMirrorFilterCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2CreateTrafficMirrorFilterResult(data, context);
  const response: CreateTrafficMirrorFilterCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateTrafficMirrorFilterResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2CreateTrafficMirrorFilterCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateTrafficMirrorFilterCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2CreateTrafficMirrorFilterRuleCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateTrafficMirrorFilterRuleCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2CreateTrafficMirrorFilterRuleCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2CreateTrafficMirrorFilterRuleResult(
    data,
    context
  );
  const response: CreateTrafficMirrorFilterRuleCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateTrafficMirrorFilterRuleResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2CreateTrafficMirrorFilterRuleCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateTrafficMirrorFilterRuleCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2CreateTrafficMirrorSessionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateTrafficMirrorSessionCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2CreateTrafficMirrorSessionCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2CreateTrafficMirrorSessionResult(data, context);
  const response: CreateTrafficMirrorSessionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateTrafficMirrorSessionResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2CreateTrafficMirrorSessionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateTrafficMirrorSessionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2CreateTrafficMirrorTargetCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateTrafficMirrorTargetCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2CreateTrafficMirrorTargetCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2CreateTrafficMirrorTargetResult(data, context);
  const response: CreateTrafficMirrorTargetCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateTrafficMirrorTargetResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2CreateTrafficMirrorTargetCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateTrafficMirrorTargetCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2CreateTransitGatewayCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateTransitGatewayCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2CreateTransitGatewayCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2CreateTransitGatewayResult(data, context);
  const response: CreateTransitGatewayCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateTransitGatewayResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2CreateTransitGatewayCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateTransitGatewayCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2CreateTransitGatewayMulticastDomainCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateTransitGatewayMulticastDomainCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2CreateTransitGatewayMulticastDomainCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2CreateTransitGatewayMulticastDomainResult(
    data,
    context
  );
  const response: CreateTransitGatewayMulticastDomainCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateTransitGatewayMulticastDomainResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2CreateTransitGatewayMulticastDomainCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateTransitGatewayMulticastDomainCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2CreateTransitGatewayPeeringAttachmentCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateTransitGatewayPeeringAttachmentCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2CreateTransitGatewayPeeringAttachmentCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2CreateTransitGatewayPeeringAttachmentResult(
    data,
    context
  );
  const response: CreateTransitGatewayPeeringAttachmentCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateTransitGatewayPeeringAttachmentResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2CreateTransitGatewayPeeringAttachmentCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateTransitGatewayPeeringAttachmentCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2CreateTransitGatewayRouteCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateTransitGatewayRouteCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2CreateTransitGatewayRouteCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2CreateTransitGatewayRouteResult(data, context);
  const response: CreateTransitGatewayRouteCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateTransitGatewayRouteResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2CreateTransitGatewayRouteCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateTransitGatewayRouteCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2CreateTransitGatewayRouteTableCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateTransitGatewayRouteTableCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2CreateTransitGatewayRouteTableCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2CreateTransitGatewayRouteTableResult(
    data,
    context
  );
  const response: CreateTransitGatewayRouteTableCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateTransitGatewayRouteTableResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2CreateTransitGatewayRouteTableCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateTransitGatewayRouteTableCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2CreateTransitGatewayVpcAttachmentCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateTransitGatewayVpcAttachmentCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2CreateTransitGatewayVpcAttachmentCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2CreateTransitGatewayVpcAttachmentResult(
    data,
    context
  );
  const response: CreateTransitGatewayVpcAttachmentCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateTransitGatewayVpcAttachmentResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2CreateTransitGatewayVpcAttachmentCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateTransitGatewayVpcAttachmentCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2CreateVolumeCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateVolumeCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2CreateVolumeCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2Volume(data, context);
  const response: CreateVolumeCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "Volume",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2CreateVolumeCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateVolumeCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2CreateVpcCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateVpcCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2CreateVpcCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2CreateVpcResult(data, context);
  const response: CreateVpcCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateVpcResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2CreateVpcCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateVpcCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2CreateVpcEndpointCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateVpcEndpointCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2CreateVpcEndpointCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2CreateVpcEndpointResult(data, context);
  const response: CreateVpcEndpointCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateVpcEndpointResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2CreateVpcEndpointCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateVpcEndpointCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2CreateVpcEndpointConnectionNotificationCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateVpcEndpointConnectionNotificationCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2CreateVpcEndpointConnectionNotificationCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2CreateVpcEndpointConnectionNotificationResult(
    data,
    context
  );
  const response: CreateVpcEndpointConnectionNotificationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateVpcEndpointConnectionNotificationResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2CreateVpcEndpointConnectionNotificationCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateVpcEndpointConnectionNotificationCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2CreateVpcEndpointServiceConfigurationCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateVpcEndpointServiceConfigurationCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2CreateVpcEndpointServiceConfigurationCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2CreateVpcEndpointServiceConfigurationResult(
    data,
    context
  );
  const response: CreateVpcEndpointServiceConfigurationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateVpcEndpointServiceConfigurationResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2CreateVpcEndpointServiceConfigurationCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateVpcEndpointServiceConfigurationCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2CreateVpcPeeringConnectionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateVpcPeeringConnectionCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2CreateVpcPeeringConnectionCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2CreateVpcPeeringConnectionResult(data, context);
  const response: CreateVpcPeeringConnectionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateVpcPeeringConnectionResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2CreateVpcPeeringConnectionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateVpcPeeringConnectionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2CreateVpnConnectionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateVpnConnectionCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2CreateVpnConnectionCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2CreateVpnConnectionResult(data, context);
  const response: CreateVpnConnectionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateVpnConnectionResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2CreateVpnConnectionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateVpnConnectionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2CreateVpnConnectionRouteCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateVpnConnectionRouteCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2CreateVpnConnectionRouteCommandError(
      output,
      context
    );
  }
  await collectBody(output.body, context);
  const response: CreateVpnConnectionRouteCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2CreateVpnConnectionRouteCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateVpnConnectionRouteCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2CreateVpnGatewayCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateVpnGatewayCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2CreateVpnGatewayCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2CreateVpnGatewayResult(data, context);
  const response: CreateVpnGatewayCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateVpnGatewayResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2CreateVpnGatewayCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateVpnGatewayCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DeleteClientVpnEndpointCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteClientVpnEndpointCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DeleteClientVpnEndpointCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DeleteClientVpnEndpointResult(data, context);
  const response: DeleteClientVpnEndpointCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteClientVpnEndpointResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DeleteClientVpnEndpointCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteClientVpnEndpointCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DeleteClientVpnRouteCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteClientVpnRouteCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DeleteClientVpnRouteCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DeleteClientVpnRouteResult(data, context);
  const response: DeleteClientVpnRouteCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteClientVpnRouteResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DeleteClientVpnRouteCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteClientVpnRouteCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DeleteCustomerGatewayCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteCustomerGatewayCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DeleteCustomerGatewayCommandError(output, context);
  }
  await collectBody(output.body, context);
  const response: DeleteCustomerGatewayCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DeleteCustomerGatewayCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteCustomerGatewayCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DeleteDhcpOptionsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteDhcpOptionsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DeleteDhcpOptionsCommandError(output, context);
  }
  await collectBody(output.body, context);
  const response: DeleteDhcpOptionsCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DeleteDhcpOptionsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteDhcpOptionsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DeleteEgressOnlyInternetGatewayCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteEgressOnlyInternetGatewayCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DeleteEgressOnlyInternetGatewayCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DeleteEgressOnlyInternetGatewayResult(
    data,
    context
  );
  const response: DeleteEgressOnlyInternetGatewayCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteEgressOnlyInternetGatewayResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DeleteEgressOnlyInternetGatewayCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteEgressOnlyInternetGatewayCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DeleteFleetsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteFleetsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DeleteFleetsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DeleteFleetsResult(data, context);
  const response: DeleteFleetsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteFleetsResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DeleteFleetsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteFleetsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DeleteFlowLogsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteFlowLogsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DeleteFlowLogsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DeleteFlowLogsResult(data, context);
  const response: DeleteFlowLogsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteFlowLogsResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DeleteFlowLogsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteFlowLogsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DeleteFpgaImageCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteFpgaImageCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DeleteFpgaImageCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DeleteFpgaImageResult(data, context);
  const response: DeleteFpgaImageCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteFpgaImageResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DeleteFpgaImageCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteFpgaImageCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DeleteInternetGatewayCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteInternetGatewayCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DeleteInternetGatewayCommandError(output, context);
  }
  await collectBody(output.body, context);
  const response: DeleteInternetGatewayCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DeleteInternetGatewayCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteInternetGatewayCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DeleteKeyPairCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteKeyPairCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DeleteKeyPairCommandError(output, context);
  }
  await collectBody(output.body, context);
  const response: DeleteKeyPairCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DeleteKeyPairCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteKeyPairCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DeleteLaunchTemplateCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteLaunchTemplateCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DeleteLaunchTemplateCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DeleteLaunchTemplateResult(data, context);
  const response: DeleteLaunchTemplateCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteLaunchTemplateResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DeleteLaunchTemplateCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteLaunchTemplateCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DeleteLaunchTemplateVersionsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteLaunchTemplateVersionsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DeleteLaunchTemplateVersionsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DeleteLaunchTemplateVersionsResult(
    data,
    context
  );
  const response: DeleteLaunchTemplateVersionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteLaunchTemplateVersionsResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DeleteLaunchTemplateVersionsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteLaunchTemplateVersionsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DeleteLocalGatewayRouteCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteLocalGatewayRouteCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DeleteLocalGatewayRouteCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DeleteLocalGatewayRouteResult(data, context);
  const response: DeleteLocalGatewayRouteCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteLocalGatewayRouteResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DeleteLocalGatewayRouteCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteLocalGatewayRouteCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DeleteLocalGatewayRouteTableVpcAssociationCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteLocalGatewayRouteTableVpcAssociationCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DeleteLocalGatewayRouteTableVpcAssociationCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DeleteLocalGatewayRouteTableVpcAssociationResult(
    data,
    context
  );
  const response: DeleteLocalGatewayRouteTableVpcAssociationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteLocalGatewayRouteTableVpcAssociationResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DeleteLocalGatewayRouteTableVpcAssociationCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteLocalGatewayRouteTableVpcAssociationCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DeleteNatGatewayCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteNatGatewayCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DeleteNatGatewayCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DeleteNatGatewayResult(data, context);
  const response: DeleteNatGatewayCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteNatGatewayResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DeleteNatGatewayCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteNatGatewayCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DeleteNetworkAclCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteNetworkAclCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DeleteNetworkAclCommandError(output, context);
  }
  await collectBody(output.body, context);
  const response: DeleteNetworkAclCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DeleteNetworkAclCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteNetworkAclCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DeleteNetworkAclEntryCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteNetworkAclEntryCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DeleteNetworkAclEntryCommandError(output, context);
  }
  await collectBody(output.body, context);
  const response: DeleteNetworkAclEntryCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DeleteNetworkAclEntryCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteNetworkAclEntryCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DeleteNetworkInterfaceCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteNetworkInterfaceCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DeleteNetworkInterfaceCommandError(
      output,
      context
    );
  }
  await collectBody(output.body, context);
  const response: DeleteNetworkInterfaceCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DeleteNetworkInterfaceCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteNetworkInterfaceCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DeleteNetworkInterfacePermissionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteNetworkInterfacePermissionCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DeleteNetworkInterfacePermissionCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DeleteNetworkInterfacePermissionResult(
    data,
    context
  );
  const response: DeleteNetworkInterfacePermissionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteNetworkInterfacePermissionResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DeleteNetworkInterfacePermissionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteNetworkInterfacePermissionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DeletePlacementGroupCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeletePlacementGroupCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DeletePlacementGroupCommandError(output, context);
  }
  await collectBody(output.body, context);
  const response: DeletePlacementGroupCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DeletePlacementGroupCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeletePlacementGroupCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DeleteQueuedReservedInstancesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteQueuedReservedInstancesCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DeleteQueuedReservedInstancesCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DeleteQueuedReservedInstancesResult(
    data,
    context
  );
  const response: DeleteQueuedReservedInstancesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteQueuedReservedInstancesResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DeleteQueuedReservedInstancesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteQueuedReservedInstancesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DeleteRouteCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteRouteCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DeleteRouteCommandError(output, context);
  }
  await collectBody(output.body, context);
  const response: DeleteRouteCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DeleteRouteCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteRouteCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DeleteRouteTableCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteRouteTableCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DeleteRouteTableCommandError(output, context);
  }
  await collectBody(output.body, context);
  const response: DeleteRouteTableCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DeleteRouteTableCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteRouteTableCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DeleteSecurityGroupCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteSecurityGroupCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DeleteSecurityGroupCommandError(output, context);
  }
  await collectBody(output.body, context);
  const response: DeleteSecurityGroupCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DeleteSecurityGroupCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteSecurityGroupCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DeleteSnapshotCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteSnapshotCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DeleteSnapshotCommandError(output, context);
  }
  await collectBody(output.body, context);
  const response: DeleteSnapshotCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DeleteSnapshotCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteSnapshotCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DeleteSpotDatafeedSubscriptionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteSpotDatafeedSubscriptionCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DeleteSpotDatafeedSubscriptionCommandError(
      output,
      context
    );
  }
  await collectBody(output.body, context);
  const response: DeleteSpotDatafeedSubscriptionCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DeleteSpotDatafeedSubscriptionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteSpotDatafeedSubscriptionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DeleteSubnetCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteSubnetCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DeleteSubnetCommandError(output, context);
  }
  await collectBody(output.body, context);
  const response: DeleteSubnetCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DeleteSubnetCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteSubnetCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DeleteTagsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteTagsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DeleteTagsCommandError(output, context);
  }
  await collectBody(output.body, context);
  const response: DeleteTagsCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DeleteTagsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteTagsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DeleteTrafficMirrorFilterCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteTrafficMirrorFilterCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DeleteTrafficMirrorFilterCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DeleteTrafficMirrorFilterResult(data, context);
  const response: DeleteTrafficMirrorFilterCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteTrafficMirrorFilterResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DeleteTrafficMirrorFilterCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteTrafficMirrorFilterCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DeleteTrafficMirrorFilterRuleCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteTrafficMirrorFilterRuleCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DeleteTrafficMirrorFilterRuleCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DeleteTrafficMirrorFilterRuleResult(
    data,
    context
  );
  const response: DeleteTrafficMirrorFilterRuleCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteTrafficMirrorFilterRuleResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DeleteTrafficMirrorFilterRuleCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteTrafficMirrorFilterRuleCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DeleteTrafficMirrorSessionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteTrafficMirrorSessionCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DeleteTrafficMirrorSessionCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DeleteTrafficMirrorSessionResult(data, context);
  const response: DeleteTrafficMirrorSessionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteTrafficMirrorSessionResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DeleteTrafficMirrorSessionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteTrafficMirrorSessionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DeleteTrafficMirrorTargetCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteTrafficMirrorTargetCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DeleteTrafficMirrorTargetCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DeleteTrafficMirrorTargetResult(data, context);
  const response: DeleteTrafficMirrorTargetCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteTrafficMirrorTargetResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DeleteTrafficMirrorTargetCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteTrafficMirrorTargetCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DeleteTransitGatewayCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteTransitGatewayCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DeleteTransitGatewayCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DeleteTransitGatewayResult(data, context);
  const response: DeleteTransitGatewayCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteTransitGatewayResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DeleteTransitGatewayCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteTransitGatewayCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DeleteTransitGatewayMulticastDomainCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteTransitGatewayMulticastDomainCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DeleteTransitGatewayMulticastDomainCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DeleteTransitGatewayMulticastDomainResult(
    data,
    context
  );
  const response: DeleteTransitGatewayMulticastDomainCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteTransitGatewayMulticastDomainResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DeleteTransitGatewayMulticastDomainCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteTransitGatewayMulticastDomainCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DeleteTransitGatewayPeeringAttachmentCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteTransitGatewayPeeringAttachmentCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DeleteTransitGatewayPeeringAttachmentCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DeleteTransitGatewayPeeringAttachmentResult(
    data,
    context
  );
  const response: DeleteTransitGatewayPeeringAttachmentCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteTransitGatewayPeeringAttachmentResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DeleteTransitGatewayPeeringAttachmentCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteTransitGatewayPeeringAttachmentCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DeleteTransitGatewayRouteCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteTransitGatewayRouteCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DeleteTransitGatewayRouteCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DeleteTransitGatewayRouteResult(data, context);
  const response: DeleteTransitGatewayRouteCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteTransitGatewayRouteResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DeleteTransitGatewayRouteCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteTransitGatewayRouteCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DeleteTransitGatewayRouteTableCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteTransitGatewayRouteTableCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DeleteTransitGatewayRouteTableCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DeleteTransitGatewayRouteTableResult(
    data,
    context
  );
  const response: DeleteTransitGatewayRouteTableCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteTransitGatewayRouteTableResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DeleteTransitGatewayRouteTableCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteTransitGatewayRouteTableCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DeleteTransitGatewayVpcAttachmentCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteTransitGatewayVpcAttachmentCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DeleteTransitGatewayVpcAttachmentCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DeleteTransitGatewayVpcAttachmentResult(
    data,
    context
  );
  const response: DeleteTransitGatewayVpcAttachmentCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteTransitGatewayVpcAttachmentResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DeleteTransitGatewayVpcAttachmentCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteTransitGatewayVpcAttachmentCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DeleteVolumeCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteVolumeCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DeleteVolumeCommandError(output, context);
  }
  await collectBody(output.body, context);
  const response: DeleteVolumeCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DeleteVolumeCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteVolumeCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DeleteVpcCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteVpcCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DeleteVpcCommandError(output, context);
  }
  await collectBody(output.body, context);
  const response: DeleteVpcCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DeleteVpcCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteVpcCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DeleteVpcEndpointConnectionNotificationsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteVpcEndpointConnectionNotificationsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DeleteVpcEndpointConnectionNotificationsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DeleteVpcEndpointConnectionNotificationsResult(
    data,
    context
  );
  const response: DeleteVpcEndpointConnectionNotificationsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteVpcEndpointConnectionNotificationsResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DeleteVpcEndpointConnectionNotificationsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteVpcEndpointConnectionNotificationsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DeleteVpcEndpointsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteVpcEndpointsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DeleteVpcEndpointsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DeleteVpcEndpointsResult(data, context);
  const response: DeleteVpcEndpointsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteVpcEndpointsResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DeleteVpcEndpointsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteVpcEndpointsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DeleteVpcEndpointServiceConfigurationsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteVpcEndpointServiceConfigurationsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DeleteVpcEndpointServiceConfigurationsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DeleteVpcEndpointServiceConfigurationsResult(
    data,
    context
  );
  const response: DeleteVpcEndpointServiceConfigurationsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteVpcEndpointServiceConfigurationsResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DeleteVpcEndpointServiceConfigurationsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteVpcEndpointServiceConfigurationsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DeleteVpcPeeringConnectionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteVpcPeeringConnectionCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DeleteVpcPeeringConnectionCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DeleteVpcPeeringConnectionResult(data, context);
  const response: DeleteVpcPeeringConnectionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteVpcPeeringConnectionResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DeleteVpcPeeringConnectionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteVpcPeeringConnectionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DeleteVpnConnectionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteVpnConnectionCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DeleteVpnConnectionCommandError(output, context);
  }
  await collectBody(output.body, context);
  const response: DeleteVpnConnectionCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DeleteVpnConnectionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteVpnConnectionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DeleteVpnConnectionRouteCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteVpnConnectionRouteCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DeleteVpnConnectionRouteCommandError(
      output,
      context
    );
  }
  await collectBody(output.body, context);
  const response: DeleteVpnConnectionRouteCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DeleteVpnConnectionRouteCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteVpnConnectionRouteCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DeleteVpnGatewayCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteVpnGatewayCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DeleteVpnGatewayCommandError(output, context);
  }
  await collectBody(output.body, context);
  const response: DeleteVpnGatewayCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DeleteVpnGatewayCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteVpnGatewayCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DeprovisionByoipCidrCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeprovisionByoipCidrCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DeprovisionByoipCidrCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DeprovisionByoipCidrResult(data, context);
  const response: DeprovisionByoipCidrCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeprovisionByoipCidrResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DeprovisionByoipCidrCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeprovisionByoipCidrCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DeregisterImageCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeregisterImageCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DeregisterImageCommandError(output, context);
  }
  await collectBody(output.body, context);
  const response: DeregisterImageCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DeregisterImageCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeregisterImageCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DeregisterTransitGatewayMulticastGroupMembersCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeregisterTransitGatewayMulticastGroupMembersCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DeregisterTransitGatewayMulticastGroupMembersCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DeregisterTransitGatewayMulticastGroupMembersResult(
    data,
    context
  );
  const response: DeregisterTransitGatewayMulticastGroupMembersCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeregisterTransitGatewayMulticastGroupMembersResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DeregisterTransitGatewayMulticastGroupMembersCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeregisterTransitGatewayMulticastGroupMembersCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DeregisterTransitGatewayMulticastGroupSourcesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeregisterTransitGatewayMulticastGroupSourcesCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DeregisterTransitGatewayMulticastGroupSourcesCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DeregisterTransitGatewayMulticastGroupSourcesResult(
    data,
    context
  );
  const response: DeregisterTransitGatewayMulticastGroupSourcesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeregisterTransitGatewayMulticastGroupSourcesResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DeregisterTransitGatewayMulticastGroupSourcesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeregisterTransitGatewayMulticastGroupSourcesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeAccountAttributesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeAccountAttributesCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeAccountAttributesCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribeAccountAttributesResult(data, context);
  const response: DescribeAccountAttributesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeAccountAttributesResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeAccountAttributesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeAccountAttributesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeAddressesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeAddressesCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeAddressesCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribeAddressesResult(data, context);
  const response: DescribeAddressesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeAddressesResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeAddressesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeAddressesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeAggregateIdFormatCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeAggregateIdFormatCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeAggregateIdFormatCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribeAggregateIdFormatResult(data, context);
  const response: DescribeAggregateIdFormatCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeAggregateIdFormatResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeAggregateIdFormatCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeAggregateIdFormatCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeAvailabilityZonesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeAvailabilityZonesCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeAvailabilityZonesCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribeAvailabilityZonesResult(data, context);
  const response: DescribeAvailabilityZonesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeAvailabilityZonesResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeAvailabilityZonesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeAvailabilityZonesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeBundleTasksCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeBundleTasksCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeBundleTasksCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribeBundleTasksResult(data, context);
  const response: DescribeBundleTasksCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeBundleTasksResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeBundleTasksCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeBundleTasksCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeByoipCidrsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeByoipCidrsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeByoipCidrsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribeByoipCidrsResult(data, context);
  const response: DescribeByoipCidrsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeByoipCidrsResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeByoipCidrsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeByoipCidrsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeCapacityReservationsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeCapacityReservationsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeCapacityReservationsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribeCapacityReservationsResult(
    data,
    context
  );
  const response: DescribeCapacityReservationsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeCapacityReservationsResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeCapacityReservationsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeCapacityReservationsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeClassicLinkInstancesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeClassicLinkInstancesCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeClassicLinkInstancesCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribeClassicLinkInstancesResult(
    data,
    context
  );
  const response: DescribeClassicLinkInstancesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeClassicLinkInstancesResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeClassicLinkInstancesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeClassicLinkInstancesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeClientVpnAuthorizationRulesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeClientVpnAuthorizationRulesCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeClientVpnAuthorizationRulesCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribeClientVpnAuthorizationRulesResult(
    data,
    context
  );
  const response: DescribeClientVpnAuthorizationRulesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeClientVpnAuthorizationRulesResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeClientVpnAuthorizationRulesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeClientVpnAuthorizationRulesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeClientVpnConnectionsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeClientVpnConnectionsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeClientVpnConnectionsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribeClientVpnConnectionsResult(
    data,
    context
  );
  const response: DescribeClientVpnConnectionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeClientVpnConnectionsResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeClientVpnConnectionsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeClientVpnConnectionsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeClientVpnEndpointsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeClientVpnEndpointsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeClientVpnEndpointsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribeClientVpnEndpointsResult(data, context);
  const response: DescribeClientVpnEndpointsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeClientVpnEndpointsResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeClientVpnEndpointsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeClientVpnEndpointsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeClientVpnRoutesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeClientVpnRoutesCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeClientVpnRoutesCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribeClientVpnRoutesResult(data, context);
  const response: DescribeClientVpnRoutesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeClientVpnRoutesResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeClientVpnRoutesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeClientVpnRoutesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeClientVpnTargetNetworksCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeClientVpnTargetNetworksCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeClientVpnTargetNetworksCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribeClientVpnTargetNetworksResult(
    data,
    context
  );
  const response: DescribeClientVpnTargetNetworksCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeClientVpnTargetNetworksResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeClientVpnTargetNetworksCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeClientVpnTargetNetworksCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeCoipPoolsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeCoipPoolsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeCoipPoolsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribeCoipPoolsResult(data, context);
  const response: DescribeCoipPoolsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeCoipPoolsResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeCoipPoolsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeCoipPoolsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeConversionTasksCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeConversionTasksCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeConversionTasksCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribeConversionTasksResult(data, context);
  const response: DescribeConversionTasksCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeConversionTasksResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeConversionTasksCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeConversionTasksCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeCustomerGatewaysCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeCustomerGatewaysCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeCustomerGatewaysCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribeCustomerGatewaysResult(data, context);
  const response: DescribeCustomerGatewaysCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeCustomerGatewaysResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeCustomerGatewaysCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeCustomerGatewaysCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeDhcpOptionsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDhcpOptionsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeDhcpOptionsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribeDhcpOptionsResult(data, context);
  const response: DescribeDhcpOptionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeDhcpOptionsResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeDhcpOptionsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDhcpOptionsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeEgressOnlyInternetGatewaysCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeEgressOnlyInternetGatewaysCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeEgressOnlyInternetGatewaysCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribeEgressOnlyInternetGatewaysResult(
    data,
    context
  );
  const response: DescribeEgressOnlyInternetGatewaysCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeEgressOnlyInternetGatewaysResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeEgressOnlyInternetGatewaysCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeEgressOnlyInternetGatewaysCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeElasticGpusCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeElasticGpusCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeElasticGpusCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribeElasticGpusResult(data, context);
  const response: DescribeElasticGpusCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeElasticGpusResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeElasticGpusCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeElasticGpusCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeExportImageTasksCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeExportImageTasksCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeExportImageTasksCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribeExportImageTasksResult(data, context);
  const response: DescribeExportImageTasksCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeExportImageTasksResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeExportImageTasksCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeExportImageTasksCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeExportTasksCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeExportTasksCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeExportTasksCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribeExportTasksResult(data, context);
  const response: DescribeExportTasksCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeExportTasksResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeExportTasksCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeExportTasksCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeFastSnapshotRestoresCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeFastSnapshotRestoresCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeFastSnapshotRestoresCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribeFastSnapshotRestoresResult(
    data,
    context
  );
  const response: DescribeFastSnapshotRestoresCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeFastSnapshotRestoresResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeFastSnapshotRestoresCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeFastSnapshotRestoresCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeFleetHistoryCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeFleetHistoryCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeFleetHistoryCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribeFleetHistoryResult(data, context);
  const response: DescribeFleetHistoryCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeFleetHistoryResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeFleetHistoryCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeFleetHistoryCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeFleetInstancesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeFleetInstancesCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeFleetInstancesCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribeFleetInstancesResult(data, context);
  const response: DescribeFleetInstancesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeFleetInstancesResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeFleetInstancesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeFleetInstancesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeFleetsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeFleetsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeFleetsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribeFleetsResult(data, context);
  const response: DescribeFleetsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeFleetsResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeFleetsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeFleetsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeFlowLogsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeFlowLogsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeFlowLogsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribeFlowLogsResult(data, context);
  const response: DescribeFlowLogsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeFlowLogsResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeFlowLogsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeFlowLogsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeFpgaImageAttributeCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeFpgaImageAttributeCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeFpgaImageAttributeCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribeFpgaImageAttributeResult(data, context);
  const response: DescribeFpgaImageAttributeCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeFpgaImageAttributeResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeFpgaImageAttributeCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeFpgaImageAttributeCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeFpgaImagesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeFpgaImagesCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeFpgaImagesCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribeFpgaImagesResult(data, context);
  const response: DescribeFpgaImagesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeFpgaImagesResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeFpgaImagesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeFpgaImagesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeHostReservationOfferingsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeHostReservationOfferingsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeHostReservationOfferingsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribeHostReservationOfferingsResult(
    data,
    context
  );
  const response: DescribeHostReservationOfferingsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeHostReservationOfferingsResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeHostReservationOfferingsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeHostReservationOfferingsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeHostReservationsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeHostReservationsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeHostReservationsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribeHostReservationsResult(data, context);
  const response: DescribeHostReservationsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeHostReservationsResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeHostReservationsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeHostReservationsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeHostsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeHostsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeHostsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribeHostsResult(data, context);
  const response: DescribeHostsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeHostsResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeHostsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeHostsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeIamInstanceProfileAssociationsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeIamInstanceProfileAssociationsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeIamInstanceProfileAssociationsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribeIamInstanceProfileAssociationsResult(
    data,
    context
  );
  const response: DescribeIamInstanceProfileAssociationsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeIamInstanceProfileAssociationsResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeIamInstanceProfileAssociationsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeIamInstanceProfileAssociationsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeIdentityIdFormatCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeIdentityIdFormatCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeIdentityIdFormatCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribeIdentityIdFormatResult(data, context);
  const response: DescribeIdentityIdFormatCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeIdentityIdFormatResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeIdentityIdFormatCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeIdentityIdFormatCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeIdFormatCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeIdFormatCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeIdFormatCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribeIdFormatResult(data, context);
  const response: DescribeIdFormatCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeIdFormatResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeIdFormatCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeIdFormatCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeImageAttributeCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeImageAttributeCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeImageAttributeCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2ImageAttribute(data, context);
  const response: DescribeImageAttributeCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ImageAttribute",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeImageAttributeCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeImageAttributeCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeImagesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeImagesCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeImagesCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribeImagesResult(data, context);
  const response: DescribeImagesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeImagesResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeImagesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeImagesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeImportImageTasksCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeImportImageTasksCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeImportImageTasksCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribeImportImageTasksResult(data, context);
  const response: DescribeImportImageTasksCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeImportImageTasksResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeImportImageTasksCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeImportImageTasksCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeImportSnapshotTasksCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeImportSnapshotTasksCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeImportSnapshotTasksCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribeImportSnapshotTasksResult(data, context);
  const response: DescribeImportSnapshotTasksCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeImportSnapshotTasksResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeImportSnapshotTasksCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeImportSnapshotTasksCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeInstanceAttributeCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeInstanceAttributeCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeInstanceAttributeCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2InstanceAttribute(data, context);
  const response: DescribeInstanceAttributeCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "InstanceAttribute",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeInstanceAttributeCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeInstanceAttributeCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeInstanceCreditSpecificationsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeInstanceCreditSpecificationsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeInstanceCreditSpecificationsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribeInstanceCreditSpecificationsResult(
    data,
    context
  );
  const response: DescribeInstanceCreditSpecificationsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeInstanceCreditSpecificationsResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeInstanceCreditSpecificationsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeInstanceCreditSpecificationsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeInstancesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeInstancesCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeInstancesCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribeInstancesResult(data, context);
  const response: DescribeInstancesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeInstancesResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeInstancesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeInstancesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeInstanceStatusCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeInstanceStatusCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeInstanceStatusCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribeInstanceStatusResult(data, context);
  const response: DescribeInstanceStatusCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeInstanceStatusResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeInstanceStatusCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeInstanceStatusCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeInstanceTypeOfferingsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeInstanceTypeOfferingsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeInstanceTypeOfferingsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribeInstanceTypeOfferingsResult(
    data,
    context
  );
  const response: DescribeInstanceTypeOfferingsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeInstanceTypeOfferingsResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeInstanceTypeOfferingsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeInstanceTypeOfferingsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeInstanceTypesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeInstanceTypesCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeInstanceTypesCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribeInstanceTypesResult(data, context);
  const response: DescribeInstanceTypesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeInstanceTypesResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeInstanceTypesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeInstanceTypesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeInternetGatewaysCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeInternetGatewaysCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeInternetGatewaysCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribeInternetGatewaysResult(data, context);
  const response: DescribeInternetGatewaysCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeInternetGatewaysResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeInternetGatewaysCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeInternetGatewaysCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeIpv6PoolsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeIpv6PoolsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeIpv6PoolsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribeIpv6PoolsResult(data, context);
  const response: DescribeIpv6PoolsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeIpv6PoolsResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeIpv6PoolsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeIpv6PoolsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeKeyPairsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeKeyPairsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeKeyPairsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribeKeyPairsResult(data, context);
  const response: DescribeKeyPairsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeKeyPairsResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeKeyPairsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeKeyPairsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeLaunchTemplatesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeLaunchTemplatesCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeLaunchTemplatesCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribeLaunchTemplatesResult(data, context);
  const response: DescribeLaunchTemplatesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeLaunchTemplatesResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeLaunchTemplatesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeLaunchTemplatesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeLaunchTemplateVersionsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeLaunchTemplateVersionsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeLaunchTemplateVersionsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribeLaunchTemplateVersionsResult(
    data,
    context
  );
  const response: DescribeLaunchTemplateVersionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeLaunchTemplateVersionsResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeLaunchTemplateVersionsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeLaunchTemplateVersionsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeLocalGatewayRouteTablesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeLocalGatewayRouteTablesCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeLocalGatewayRouteTablesCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribeLocalGatewayRouteTablesResult(
    data,
    context
  );
  const response: DescribeLocalGatewayRouteTablesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeLocalGatewayRouteTablesResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeLocalGatewayRouteTablesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeLocalGatewayRouteTablesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<
  DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsCommandOutput
> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsResult(
    data,
    context
  );
  const response: DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type:
      "DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<
  DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsCommandOutput
> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeLocalGatewayRouteTableVpcAssociationsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeLocalGatewayRouteTableVpcAssociationsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeLocalGatewayRouteTableVpcAssociationsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribeLocalGatewayRouteTableVpcAssociationsResult(
    data,
    context
  );
  const response: DescribeLocalGatewayRouteTableVpcAssociationsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeLocalGatewayRouteTableVpcAssociationsResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeLocalGatewayRouteTableVpcAssociationsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeLocalGatewayRouteTableVpcAssociationsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeLocalGatewaysCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeLocalGatewaysCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeLocalGatewaysCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribeLocalGatewaysResult(data, context);
  const response: DescribeLocalGatewaysCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeLocalGatewaysResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeLocalGatewaysCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeLocalGatewaysCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeLocalGatewayVirtualInterfaceGroupsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeLocalGatewayVirtualInterfaceGroupsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeLocalGatewayVirtualInterfaceGroupsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribeLocalGatewayVirtualInterfaceGroupsResult(
    data,
    context
  );
  const response: DescribeLocalGatewayVirtualInterfaceGroupsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeLocalGatewayVirtualInterfaceGroupsResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeLocalGatewayVirtualInterfaceGroupsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeLocalGatewayVirtualInterfaceGroupsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeLocalGatewayVirtualInterfacesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeLocalGatewayVirtualInterfacesCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeLocalGatewayVirtualInterfacesCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribeLocalGatewayVirtualInterfacesResult(
    data,
    context
  );
  const response: DescribeLocalGatewayVirtualInterfacesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeLocalGatewayVirtualInterfacesResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeLocalGatewayVirtualInterfacesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeLocalGatewayVirtualInterfacesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeMovingAddressesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeMovingAddressesCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeMovingAddressesCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribeMovingAddressesResult(data, context);
  const response: DescribeMovingAddressesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeMovingAddressesResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeMovingAddressesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeMovingAddressesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeNatGatewaysCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeNatGatewaysCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeNatGatewaysCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribeNatGatewaysResult(data, context);
  const response: DescribeNatGatewaysCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeNatGatewaysResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeNatGatewaysCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeNatGatewaysCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeNetworkAclsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeNetworkAclsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeNetworkAclsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribeNetworkAclsResult(data, context);
  const response: DescribeNetworkAclsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeNetworkAclsResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeNetworkAclsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeNetworkAclsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeNetworkInterfaceAttributeCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeNetworkInterfaceAttributeCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeNetworkInterfaceAttributeCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribeNetworkInterfaceAttributeResult(
    data,
    context
  );
  const response: DescribeNetworkInterfaceAttributeCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeNetworkInterfaceAttributeResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeNetworkInterfaceAttributeCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeNetworkInterfaceAttributeCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeNetworkInterfacePermissionsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeNetworkInterfacePermissionsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeNetworkInterfacePermissionsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribeNetworkInterfacePermissionsResult(
    data,
    context
  );
  const response: DescribeNetworkInterfacePermissionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeNetworkInterfacePermissionsResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeNetworkInterfacePermissionsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeNetworkInterfacePermissionsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeNetworkInterfacesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeNetworkInterfacesCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeNetworkInterfacesCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribeNetworkInterfacesResult(data, context);
  const response: DescribeNetworkInterfacesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeNetworkInterfacesResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeNetworkInterfacesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeNetworkInterfacesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribePlacementGroupsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribePlacementGroupsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribePlacementGroupsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribePlacementGroupsResult(data, context);
  const response: DescribePlacementGroupsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribePlacementGroupsResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribePlacementGroupsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribePlacementGroupsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribePrefixListsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribePrefixListsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribePrefixListsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribePrefixListsResult(data, context);
  const response: DescribePrefixListsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribePrefixListsResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribePrefixListsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribePrefixListsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribePrincipalIdFormatCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribePrincipalIdFormatCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribePrincipalIdFormatCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribePrincipalIdFormatResult(data, context);
  const response: DescribePrincipalIdFormatCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribePrincipalIdFormatResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribePrincipalIdFormatCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribePrincipalIdFormatCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribePublicIpv4PoolsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribePublicIpv4PoolsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribePublicIpv4PoolsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribePublicIpv4PoolsResult(data, context);
  const response: DescribePublicIpv4PoolsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribePublicIpv4PoolsResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribePublicIpv4PoolsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribePublicIpv4PoolsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeRegionsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeRegionsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeRegionsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribeRegionsResult(data, context);
  const response: DescribeRegionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeRegionsResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeRegionsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeRegionsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeReservedInstancesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeReservedInstancesCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeReservedInstancesCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribeReservedInstancesResult(data, context);
  const response: DescribeReservedInstancesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeReservedInstancesResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeReservedInstancesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeReservedInstancesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeReservedInstancesListingsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeReservedInstancesListingsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeReservedInstancesListingsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribeReservedInstancesListingsResult(
    data,
    context
  );
  const response: DescribeReservedInstancesListingsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeReservedInstancesListingsResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeReservedInstancesListingsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeReservedInstancesListingsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeReservedInstancesModificationsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeReservedInstancesModificationsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeReservedInstancesModificationsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribeReservedInstancesModificationsResult(
    data,
    context
  );
  const response: DescribeReservedInstancesModificationsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeReservedInstancesModificationsResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeReservedInstancesModificationsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeReservedInstancesModificationsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeReservedInstancesOfferingsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeReservedInstancesOfferingsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeReservedInstancesOfferingsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribeReservedInstancesOfferingsResult(
    data,
    context
  );
  const response: DescribeReservedInstancesOfferingsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeReservedInstancesOfferingsResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeReservedInstancesOfferingsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeReservedInstancesOfferingsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeRouteTablesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeRouteTablesCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeRouteTablesCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribeRouteTablesResult(data, context);
  const response: DescribeRouteTablesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeRouteTablesResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeRouteTablesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeRouteTablesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeScheduledInstanceAvailabilityCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeScheduledInstanceAvailabilityCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeScheduledInstanceAvailabilityCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribeScheduledInstanceAvailabilityResult(
    data,
    context
  );
  const response: DescribeScheduledInstanceAvailabilityCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeScheduledInstanceAvailabilityResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeScheduledInstanceAvailabilityCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeScheduledInstanceAvailabilityCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeScheduledInstancesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeScheduledInstancesCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeScheduledInstancesCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribeScheduledInstancesResult(data, context);
  const response: DescribeScheduledInstancesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeScheduledInstancesResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeScheduledInstancesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeScheduledInstancesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeSecurityGroupReferencesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeSecurityGroupReferencesCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeSecurityGroupReferencesCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribeSecurityGroupReferencesResult(
    data,
    context
  );
  const response: DescribeSecurityGroupReferencesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeSecurityGroupReferencesResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeSecurityGroupReferencesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeSecurityGroupReferencesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeSecurityGroupsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeSecurityGroupsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeSecurityGroupsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribeSecurityGroupsResult(data, context);
  const response: DescribeSecurityGroupsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeSecurityGroupsResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeSecurityGroupsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeSecurityGroupsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeSnapshotAttributeCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeSnapshotAttributeCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeSnapshotAttributeCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribeSnapshotAttributeResult(data, context);
  const response: DescribeSnapshotAttributeCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeSnapshotAttributeResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeSnapshotAttributeCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeSnapshotAttributeCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeSnapshotsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeSnapshotsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeSnapshotsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribeSnapshotsResult(data, context);
  const response: DescribeSnapshotsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeSnapshotsResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeSnapshotsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeSnapshotsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeSpotDatafeedSubscriptionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeSpotDatafeedSubscriptionCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeSpotDatafeedSubscriptionCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribeSpotDatafeedSubscriptionResult(
    data,
    context
  );
  const response: DescribeSpotDatafeedSubscriptionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeSpotDatafeedSubscriptionResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeSpotDatafeedSubscriptionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeSpotDatafeedSubscriptionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeSpotFleetInstancesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeSpotFleetInstancesCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeSpotFleetInstancesCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribeSpotFleetInstancesResponse(
    data,
    context
  );
  const response: DescribeSpotFleetInstancesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeSpotFleetInstancesResponse",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeSpotFleetInstancesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeSpotFleetInstancesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeSpotFleetRequestHistoryCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeSpotFleetRequestHistoryCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeSpotFleetRequestHistoryCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribeSpotFleetRequestHistoryResponse(
    data,
    context
  );
  const response: DescribeSpotFleetRequestHistoryCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeSpotFleetRequestHistoryResponse",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeSpotFleetRequestHistoryCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeSpotFleetRequestHistoryCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeSpotFleetRequestsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeSpotFleetRequestsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeSpotFleetRequestsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribeSpotFleetRequestsResponse(data, context);
  const response: DescribeSpotFleetRequestsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeSpotFleetRequestsResponse",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeSpotFleetRequestsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeSpotFleetRequestsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeSpotInstanceRequestsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeSpotInstanceRequestsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeSpotInstanceRequestsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribeSpotInstanceRequestsResult(
    data,
    context
  );
  const response: DescribeSpotInstanceRequestsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeSpotInstanceRequestsResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeSpotInstanceRequestsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeSpotInstanceRequestsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeSpotPriceHistoryCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeSpotPriceHistoryCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeSpotPriceHistoryCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribeSpotPriceHistoryResult(data, context);
  const response: DescribeSpotPriceHistoryCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeSpotPriceHistoryResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeSpotPriceHistoryCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeSpotPriceHistoryCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeStaleSecurityGroupsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeStaleSecurityGroupsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeStaleSecurityGroupsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribeStaleSecurityGroupsResult(data, context);
  const response: DescribeStaleSecurityGroupsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeStaleSecurityGroupsResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeStaleSecurityGroupsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeStaleSecurityGroupsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeSubnetsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeSubnetsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeSubnetsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribeSubnetsResult(data, context);
  const response: DescribeSubnetsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeSubnetsResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeSubnetsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeSubnetsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeTagsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeTagsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeTagsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribeTagsResult(data, context);
  const response: DescribeTagsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeTagsResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeTagsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeTagsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeTrafficMirrorFiltersCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeTrafficMirrorFiltersCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeTrafficMirrorFiltersCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribeTrafficMirrorFiltersResult(
    data,
    context
  );
  const response: DescribeTrafficMirrorFiltersCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeTrafficMirrorFiltersResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeTrafficMirrorFiltersCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeTrafficMirrorFiltersCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeTrafficMirrorSessionsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeTrafficMirrorSessionsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeTrafficMirrorSessionsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribeTrafficMirrorSessionsResult(
    data,
    context
  );
  const response: DescribeTrafficMirrorSessionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeTrafficMirrorSessionsResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeTrafficMirrorSessionsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeTrafficMirrorSessionsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeTrafficMirrorTargetsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeTrafficMirrorTargetsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeTrafficMirrorTargetsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribeTrafficMirrorTargetsResult(
    data,
    context
  );
  const response: DescribeTrafficMirrorTargetsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeTrafficMirrorTargetsResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeTrafficMirrorTargetsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeTrafficMirrorTargetsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeTransitGatewayAttachmentsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeTransitGatewayAttachmentsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeTransitGatewayAttachmentsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribeTransitGatewayAttachmentsResult(
    data,
    context
  );
  const response: DescribeTransitGatewayAttachmentsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeTransitGatewayAttachmentsResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeTransitGatewayAttachmentsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeTransitGatewayAttachmentsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeTransitGatewayMulticastDomainsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeTransitGatewayMulticastDomainsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeTransitGatewayMulticastDomainsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribeTransitGatewayMulticastDomainsResult(
    data,
    context
  );
  const response: DescribeTransitGatewayMulticastDomainsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeTransitGatewayMulticastDomainsResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeTransitGatewayMulticastDomainsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeTransitGatewayMulticastDomainsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeTransitGatewayPeeringAttachmentsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeTransitGatewayPeeringAttachmentsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeTransitGatewayPeeringAttachmentsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribeTransitGatewayPeeringAttachmentsResult(
    data,
    context
  );
  const response: DescribeTransitGatewayPeeringAttachmentsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeTransitGatewayPeeringAttachmentsResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeTransitGatewayPeeringAttachmentsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeTransitGatewayPeeringAttachmentsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeTransitGatewayRouteTablesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeTransitGatewayRouteTablesCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeTransitGatewayRouteTablesCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribeTransitGatewayRouteTablesResult(
    data,
    context
  );
  const response: DescribeTransitGatewayRouteTablesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeTransitGatewayRouteTablesResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeTransitGatewayRouteTablesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeTransitGatewayRouteTablesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeTransitGatewaysCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeTransitGatewaysCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeTransitGatewaysCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribeTransitGatewaysResult(data, context);
  const response: DescribeTransitGatewaysCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeTransitGatewaysResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeTransitGatewaysCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeTransitGatewaysCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeTransitGatewayVpcAttachmentsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeTransitGatewayVpcAttachmentsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeTransitGatewayVpcAttachmentsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribeTransitGatewayVpcAttachmentsResult(
    data,
    context
  );
  const response: DescribeTransitGatewayVpcAttachmentsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeTransitGatewayVpcAttachmentsResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeTransitGatewayVpcAttachmentsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeTransitGatewayVpcAttachmentsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeVolumeAttributeCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeVolumeAttributeCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeVolumeAttributeCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribeVolumeAttributeResult(data, context);
  const response: DescribeVolumeAttributeCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeVolumeAttributeResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeVolumeAttributeCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeVolumeAttributeCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeVolumesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeVolumesCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeVolumesCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribeVolumesResult(data, context);
  const response: DescribeVolumesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeVolumesResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeVolumesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeVolumesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeVolumesModificationsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeVolumesModificationsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeVolumesModificationsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribeVolumesModificationsResult(
    data,
    context
  );
  const response: DescribeVolumesModificationsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeVolumesModificationsResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeVolumesModificationsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeVolumesModificationsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeVolumeStatusCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeVolumeStatusCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeVolumeStatusCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribeVolumeStatusResult(data, context);
  const response: DescribeVolumeStatusCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeVolumeStatusResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeVolumeStatusCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeVolumeStatusCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeVpcAttributeCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeVpcAttributeCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeVpcAttributeCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribeVpcAttributeResult(data, context);
  const response: DescribeVpcAttributeCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeVpcAttributeResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeVpcAttributeCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeVpcAttributeCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeVpcClassicLinkCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeVpcClassicLinkCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeVpcClassicLinkCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribeVpcClassicLinkResult(data, context);
  const response: DescribeVpcClassicLinkCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeVpcClassicLinkResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeVpcClassicLinkCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeVpcClassicLinkCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeVpcClassicLinkDnsSupportCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeVpcClassicLinkDnsSupportCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeVpcClassicLinkDnsSupportCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribeVpcClassicLinkDnsSupportResult(
    data,
    context
  );
  const response: DescribeVpcClassicLinkDnsSupportCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeVpcClassicLinkDnsSupportResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeVpcClassicLinkDnsSupportCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeVpcClassicLinkDnsSupportCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeVpcEndpointConnectionNotificationsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeVpcEndpointConnectionNotificationsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeVpcEndpointConnectionNotificationsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribeVpcEndpointConnectionNotificationsResult(
    data,
    context
  );
  const response: DescribeVpcEndpointConnectionNotificationsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeVpcEndpointConnectionNotificationsResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeVpcEndpointConnectionNotificationsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeVpcEndpointConnectionNotificationsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeVpcEndpointConnectionsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeVpcEndpointConnectionsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeVpcEndpointConnectionsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribeVpcEndpointConnectionsResult(
    data,
    context
  );
  const response: DescribeVpcEndpointConnectionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeVpcEndpointConnectionsResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeVpcEndpointConnectionsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeVpcEndpointConnectionsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeVpcEndpointsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeVpcEndpointsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeVpcEndpointsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribeVpcEndpointsResult(data, context);
  const response: DescribeVpcEndpointsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeVpcEndpointsResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeVpcEndpointsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeVpcEndpointsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeVpcEndpointServiceConfigurationsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeVpcEndpointServiceConfigurationsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeVpcEndpointServiceConfigurationsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribeVpcEndpointServiceConfigurationsResult(
    data,
    context
  );
  const response: DescribeVpcEndpointServiceConfigurationsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeVpcEndpointServiceConfigurationsResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeVpcEndpointServiceConfigurationsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeVpcEndpointServiceConfigurationsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeVpcEndpointServicePermissionsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeVpcEndpointServicePermissionsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeVpcEndpointServicePermissionsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribeVpcEndpointServicePermissionsResult(
    data,
    context
  );
  const response: DescribeVpcEndpointServicePermissionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeVpcEndpointServicePermissionsResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeVpcEndpointServicePermissionsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeVpcEndpointServicePermissionsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeVpcEndpointServicesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeVpcEndpointServicesCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeVpcEndpointServicesCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribeVpcEndpointServicesResult(data, context);
  const response: DescribeVpcEndpointServicesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeVpcEndpointServicesResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeVpcEndpointServicesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeVpcEndpointServicesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeVpcPeeringConnectionsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeVpcPeeringConnectionsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeVpcPeeringConnectionsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribeVpcPeeringConnectionsResult(
    data,
    context
  );
  const response: DescribeVpcPeeringConnectionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeVpcPeeringConnectionsResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeVpcPeeringConnectionsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeVpcPeeringConnectionsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeVpcsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeVpcsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeVpcsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribeVpcsResult(data, context);
  const response: DescribeVpcsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeVpcsResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeVpcsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeVpcsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeVpnConnectionsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeVpnConnectionsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeVpnConnectionsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribeVpnConnectionsResult(data, context);
  const response: DescribeVpnConnectionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeVpnConnectionsResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeVpnConnectionsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeVpnConnectionsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DescribeVpnGatewaysCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeVpnGatewaysCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DescribeVpnGatewaysCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DescribeVpnGatewaysResult(data, context);
  const response: DescribeVpnGatewaysCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeVpnGatewaysResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DescribeVpnGatewaysCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeVpnGatewaysCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DetachClassicLinkVpcCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DetachClassicLinkVpcCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DetachClassicLinkVpcCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DetachClassicLinkVpcResult(data, context);
  const response: DetachClassicLinkVpcCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DetachClassicLinkVpcResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DetachClassicLinkVpcCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DetachClassicLinkVpcCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DetachInternetGatewayCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DetachInternetGatewayCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DetachInternetGatewayCommandError(output, context);
  }
  await collectBody(output.body, context);
  const response: DetachInternetGatewayCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DetachInternetGatewayCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DetachInternetGatewayCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DetachNetworkInterfaceCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DetachNetworkInterfaceCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DetachNetworkInterfaceCommandError(
      output,
      context
    );
  }
  await collectBody(output.body, context);
  const response: DetachNetworkInterfaceCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DetachNetworkInterfaceCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DetachNetworkInterfaceCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DetachVolumeCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DetachVolumeCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DetachVolumeCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2VolumeAttachment(data, context);
  const response: DetachVolumeCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "VolumeAttachment",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DetachVolumeCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DetachVolumeCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DetachVpnGatewayCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DetachVpnGatewayCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DetachVpnGatewayCommandError(output, context);
  }
  await collectBody(output.body, context);
  const response: DetachVpnGatewayCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DetachVpnGatewayCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DetachVpnGatewayCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DisableEbsEncryptionByDefaultCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DisableEbsEncryptionByDefaultCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DisableEbsEncryptionByDefaultCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DisableEbsEncryptionByDefaultResult(
    data,
    context
  );
  const response: DisableEbsEncryptionByDefaultCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DisableEbsEncryptionByDefaultResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DisableEbsEncryptionByDefaultCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DisableEbsEncryptionByDefaultCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DisableFastSnapshotRestoresCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DisableFastSnapshotRestoresCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DisableFastSnapshotRestoresCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DisableFastSnapshotRestoresResult(data, context);
  const response: DisableFastSnapshotRestoresCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DisableFastSnapshotRestoresResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DisableFastSnapshotRestoresCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DisableFastSnapshotRestoresCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DisableTransitGatewayRouteTablePropagationCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DisableTransitGatewayRouteTablePropagationCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DisableTransitGatewayRouteTablePropagationCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DisableTransitGatewayRouteTablePropagationResult(
    data,
    context
  );
  const response: DisableTransitGatewayRouteTablePropagationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DisableTransitGatewayRouteTablePropagationResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DisableTransitGatewayRouteTablePropagationCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DisableTransitGatewayRouteTablePropagationCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DisableVgwRoutePropagationCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DisableVgwRoutePropagationCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DisableVgwRoutePropagationCommandError(
      output,
      context
    );
  }
  await collectBody(output.body, context);
  const response: DisableVgwRoutePropagationCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DisableVgwRoutePropagationCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DisableVgwRoutePropagationCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DisableVpcClassicLinkCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DisableVpcClassicLinkCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DisableVpcClassicLinkCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DisableVpcClassicLinkResult(data, context);
  const response: DisableVpcClassicLinkCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DisableVpcClassicLinkResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DisableVpcClassicLinkCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DisableVpcClassicLinkCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DisableVpcClassicLinkDnsSupportCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DisableVpcClassicLinkDnsSupportCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DisableVpcClassicLinkDnsSupportCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DisableVpcClassicLinkDnsSupportResult(
    data,
    context
  );
  const response: DisableVpcClassicLinkDnsSupportCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DisableVpcClassicLinkDnsSupportResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DisableVpcClassicLinkDnsSupportCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DisableVpcClassicLinkDnsSupportCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DisassociateAddressCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DisassociateAddressCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DisassociateAddressCommandError(output, context);
  }
  await collectBody(output.body, context);
  const response: DisassociateAddressCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DisassociateAddressCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DisassociateAddressCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DisassociateClientVpnTargetNetworkCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DisassociateClientVpnTargetNetworkCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DisassociateClientVpnTargetNetworkCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DisassociateClientVpnTargetNetworkResult(
    data,
    context
  );
  const response: DisassociateClientVpnTargetNetworkCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DisassociateClientVpnTargetNetworkResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DisassociateClientVpnTargetNetworkCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DisassociateClientVpnTargetNetworkCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DisassociateIamInstanceProfileCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DisassociateIamInstanceProfileCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DisassociateIamInstanceProfileCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DisassociateIamInstanceProfileResult(
    data,
    context
  );
  const response: DisassociateIamInstanceProfileCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DisassociateIamInstanceProfileResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DisassociateIamInstanceProfileCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DisassociateIamInstanceProfileCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DisassociateRouteTableCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DisassociateRouteTableCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DisassociateRouteTableCommandError(
      output,
      context
    );
  }
  await collectBody(output.body, context);
  const response: DisassociateRouteTableCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DisassociateRouteTableCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DisassociateRouteTableCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DisassociateSubnetCidrBlockCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DisassociateSubnetCidrBlockCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DisassociateSubnetCidrBlockCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DisassociateSubnetCidrBlockResult(data, context);
  const response: DisassociateSubnetCidrBlockCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DisassociateSubnetCidrBlockResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DisassociateSubnetCidrBlockCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DisassociateSubnetCidrBlockCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DisassociateTransitGatewayMulticastDomainCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DisassociateTransitGatewayMulticastDomainCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DisassociateTransitGatewayMulticastDomainCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DisassociateTransitGatewayMulticastDomainResult(
    data,
    context
  );
  const response: DisassociateTransitGatewayMulticastDomainCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DisassociateTransitGatewayMulticastDomainResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DisassociateTransitGatewayMulticastDomainCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DisassociateTransitGatewayMulticastDomainCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DisassociateTransitGatewayRouteTableCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DisassociateTransitGatewayRouteTableCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DisassociateTransitGatewayRouteTableCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DisassociateTransitGatewayRouteTableResult(
    data,
    context
  );
  const response: DisassociateTransitGatewayRouteTableCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DisassociateTransitGatewayRouteTableResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DisassociateTransitGatewayRouteTableCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DisassociateTransitGatewayRouteTableCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2DisassociateVpcCidrBlockCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DisassociateVpcCidrBlockCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2DisassociateVpcCidrBlockCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2DisassociateVpcCidrBlockResult(data, context);
  const response: DisassociateVpcCidrBlockCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DisassociateVpcCidrBlockResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2DisassociateVpcCidrBlockCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DisassociateVpcCidrBlockCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2EnableEbsEncryptionByDefaultCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<EnableEbsEncryptionByDefaultCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2EnableEbsEncryptionByDefaultCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2EnableEbsEncryptionByDefaultResult(
    data,
    context
  );
  const response: EnableEbsEncryptionByDefaultCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "EnableEbsEncryptionByDefaultResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2EnableEbsEncryptionByDefaultCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<EnableEbsEncryptionByDefaultCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2EnableFastSnapshotRestoresCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<EnableFastSnapshotRestoresCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2EnableFastSnapshotRestoresCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2EnableFastSnapshotRestoresResult(data, context);
  const response: EnableFastSnapshotRestoresCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "EnableFastSnapshotRestoresResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2EnableFastSnapshotRestoresCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<EnableFastSnapshotRestoresCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2EnableTransitGatewayRouteTablePropagationCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<EnableTransitGatewayRouteTablePropagationCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2EnableTransitGatewayRouteTablePropagationCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2EnableTransitGatewayRouteTablePropagationResult(
    data,
    context
  );
  const response: EnableTransitGatewayRouteTablePropagationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "EnableTransitGatewayRouteTablePropagationResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2EnableTransitGatewayRouteTablePropagationCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<EnableTransitGatewayRouteTablePropagationCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2EnableVgwRoutePropagationCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<EnableVgwRoutePropagationCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2EnableVgwRoutePropagationCommandError(
      output,
      context
    );
  }
  await collectBody(output.body, context);
  const response: EnableVgwRoutePropagationCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2EnableVgwRoutePropagationCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<EnableVgwRoutePropagationCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2EnableVolumeIOCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<EnableVolumeIOCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2EnableVolumeIOCommandError(output, context);
  }
  await collectBody(output.body, context);
  const response: EnableVolumeIOCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2EnableVolumeIOCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<EnableVolumeIOCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2EnableVpcClassicLinkCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<EnableVpcClassicLinkCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2EnableVpcClassicLinkCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2EnableVpcClassicLinkResult(data, context);
  const response: EnableVpcClassicLinkCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "EnableVpcClassicLinkResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2EnableVpcClassicLinkCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<EnableVpcClassicLinkCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2EnableVpcClassicLinkDnsSupportCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<EnableVpcClassicLinkDnsSupportCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2EnableVpcClassicLinkDnsSupportCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2EnableVpcClassicLinkDnsSupportResult(
    data,
    context
  );
  const response: EnableVpcClassicLinkDnsSupportCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "EnableVpcClassicLinkDnsSupportResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2EnableVpcClassicLinkDnsSupportCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<EnableVpcClassicLinkDnsSupportCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2ExportClientVpnClientCertificateRevocationListCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ExportClientVpnClientCertificateRevocationListCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2ExportClientVpnClientCertificateRevocationListCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2ExportClientVpnClientCertificateRevocationListResult(
    data,
    context
  );
  const response: ExportClientVpnClientCertificateRevocationListCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ExportClientVpnClientCertificateRevocationListResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2ExportClientVpnClientCertificateRevocationListCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ExportClientVpnClientCertificateRevocationListCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2ExportClientVpnClientConfigurationCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ExportClientVpnClientConfigurationCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2ExportClientVpnClientConfigurationCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2ExportClientVpnClientConfigurationResult(
    data,
    context
  );
  const response: ExportClientVpnClientConfigurationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ExportClientVpnClientConfigurationResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2ExportClientVpnClientConfigurationCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ExportClientVpnClientConfigurationCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2ExportImageCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ExportImageCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2ExportImageCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2ExportImageResult(data, context);
  const response: ExportImageCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ExportImageResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2ExportImageCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ExportImageCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2ExportTransitGatewayRoutesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ExportTransitGatewayRoutesCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2ExportTransitGatewayRoutesCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2ExportTransitGatewayRoutesResult(data, context);
  const response: ExportTransitGatewayRoutesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ExportTransitGatewayRoutesResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2ExportTransitGatewayRoutesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ExportTransitGatewayRoutesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2GetAssociatedIpv6PoolCidrsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetAssociatedIpv6PoolCidrsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2GetAssociatedIpv6PoolCidrsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2GetAssociatedIpv6PoolCidrsResult(data, context);
  const response: GetAssociatedIpv6PoolCidrsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetAssociatedIpv6PoolCidrsResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2GetAssociatedIpv6PoolCidrsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetAssociatedIpv6PoolCidrsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2GetCapacityReservationUsageCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetCapacityReservationUsageCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2GetCapacityReservationUsageCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2GetCapacityReservationUsageResult(data, context);
  const response: GetCapacityReservationUsageCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetCapacityReservationUsageResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2GetCapacityReservationUsageCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetCapacityReservationUsageCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2GetCoipPoolUsageCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetCoipPoolUsageCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2GetCoipPoolUsageCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2GetCoipPoolUsageResult(data, context);
  const response: GetCoipPoolUsageCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetCoipPoolUsageResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2GetCoipPoolUsageCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetCoipPoolUsageCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2GetConsoleOutputCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetConsoleOutputCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2GetConsoleOutputCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2GetConsoleOutputResult(data, context);
  const response: GetConsoleOutputCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetConsoleOutputResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2GetConsoleOutputCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetConsoleOutputCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2GetConsoleScreenshotCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetConsoleScreenshotCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2GetConsoleScreenshotCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2GetConsoleScreenshotResult(data, context);
  const response: GetConsoleScreenshotCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetConsoleScreenshotResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2GetConsoleScreenshotCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetConsoleScreenshotCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2GetDefaultCreditSpecificationCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetDefaultCreditSpecificationCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2GetDefaultCreditSpecificationCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2GetDefaultCreditSpecificationResult(
    data,
    context
  );
  const response: GetDefaultCreditSpecificationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetDefaultCreditSpecificationResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2GetDefaultCreditSpecificationCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetDefaultCreditSpecificationCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2GetEbsDefaultKmsKeyIdCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetEbsDefaultKmsKeyIdCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2GetEbsDefaultKmsKeyIdCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2GetEbsDefaultKmsKeyIdResult(data, context);
  const response: GetEbsDefaultKmsKeyIdCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetEbsDefaultKmsKeyIdResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2GetEbsDefaultKmsKeyIdCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetEbsDefaultKmsKeyIdCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2GetEbsEncryptionByDefaultCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetEbsEncryptionByDefaultCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2GetEbsEncryptionByDefaultCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2GetEbsEncryptionByDefaultResult(data, context);
  const response: GetEbsEncryptionByDefaultCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetEbsEncryptionByDefaultResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2GetEbsEncryptionByDefaultCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetEbsEncryptionByDefaultCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2GetHostReservationPurchasePreviewCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetHostReservationPurchasePreviewCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2GetHostReservationPurchasePreviewCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2GetHostReservationPurchasePreviewResult(
    data,
    context
  );
  const response: GetHostReservationPurchasePreviewCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetHostReservationPurchasePreviewResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2GetHostReservationPurchasePreviewCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetHostReservationPurchasePreviewCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2GetLaunchTemplateDataCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetLaunchTemplateDataCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2GetLaunchTemplateDataCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2GetLaunchTemplateDataResult(data, context);
  const response: GetLaunchTemplateDataCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetLaunchTemplateDataResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2GetLaunchTemplateDataCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetLaunchTemplateDataCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2GetPasswordDataCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetPasswordDataCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2GetPasswordDataCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2GetPasswordDataResult(data, context);
  const response: GetPasswordDataCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetPasswordDataResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2GetPasswordDataCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetPasswordDataCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2GetReservedInstancesExchangeQuoteCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetReservedInstancesExchangeQuoteCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2GetReservedInstancesExchangeQuoteCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2GetReservedInstancesExchangeQuoteResult(
    data,
    context
  );
  const response: GetReservedInstancesExchangeQuoteCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetReservedInstancesExchangeQuoteResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2GetReservedInstancesExchangeQuoteCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetReservedInstancesExchangeQuoteCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2GetTransitGatewayAttachmentPropagationsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetTransitGatewayAttachmentPropagationsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2GetTransitGatewayAttachmentPropagationsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2GetTransitGatewayAttachmentPropagationsResult(
    data,
    context
  );
  const response: GetTransitGatewayAttachmentPropagationsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetTransitGatewayAttachmentPropagationsResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2GetTransitGatewayAttachmentPropagationsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetTransitGatewayAttachmentPropagationsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2GetTransitGatewayMulticastDomainAssociationsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetTransitGatewayMulticastDomainAssociationsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2GetTransitGatewayMulticastDomainAssociationsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2GetTransitGatewayMulticastDomainAssociationsResult(
    data,
    context
  );
  const response: GetTransitGatewayMulticastDomainAssociationsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetTransitGatewayMulticastDomainAssociationsResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2GetTransitGatewayMulticastDomainAssociationsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetTransitGatewayMulticastDomainAssociationsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2GetTransitGatewayRouteTableAssociationsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetTransitGatewayRouteTableAssociationsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2GetTransitGatewayRouteTableAssociationsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2GetTransitGatewayRouteTableAssociationsResult(
    data,
    context
  );
  const response: GetTransitGatewayRouteTableAssociationsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetTransitGatewayRouteTableAssociationsResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2GetTransitGatewayRouteTableAssociationsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetTransitGatewayRouteTableAssociationsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2GetTransitGatewayRouteTablePropagationsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetTransitGatewayRouteTablePropagationsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2GetTransitGatewayRouteTablePropagationsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2GetTransitGatewayRouteTablePropagationsResult(
    data,
    context
  );
  const response: GetTransitGatewayRouteTablePropagationsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetTransitGatewayRouteTablePropagationsResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2GetTransitGatewayRouteTablePropagationsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetTransitGatewayRouteTablePropagationsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2ImportClientVpnClientCertificateRevocationListCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ImportClientVpnClientCertificateRevocationListCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2ImportClientVpnClientCertificateRevocationListCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2ImportClientVpnClientCertificateRevocationListResult(
    data,
    context
  );
  const response: ImportClientVpnClientCertificateRevocationListCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ImportClientVpnClientCertificateRevocationListResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2ImportClientVpnClientCertificateRevocationListCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ImportClientVpnClientCertificateRevocationListCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2ImportImageCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ImportImageCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2ImportImageCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2ImportImageResult(data, context);
  const response: ImportImageCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ImportImageResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2ImportImageCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ImportImageCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2ImportInstanceCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ImportInstanceCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2ImportInstanceCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2ImportInstanceResult(data, context);
  const response: ImportInstanceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ImportInstanceResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2ImportInstanceCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ImportInstanceCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2ImportKeyPairCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ImportKeyPairCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2ImportKeyPairCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2ImportKeyPairResult(data, context);
  const response: ImportKeyPairCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ImportKeyPairResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2ImportKeyPairCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ImportKeyPairCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2ImportSnapshotCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ImportSnapshotCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2ImportSnapshotCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2ImportSnapshotResult(data, context);
  const response: ImportSnapshotCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ImportSnapshotResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2ImportSnapshotCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ImportSnapshotCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2ImportVolumeCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ImportVolumeCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2ImportVolumeCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2ImportVolumeResult(data, context);
  const response: ImportVolumeCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ImportVolumeResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2ImportVolumeCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ImportVolumeCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2ModifyCapacityReservationCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyCapacityReservationCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2ModifyCapacityReservationCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2ModifyCapacityReservationResult(data, context);
  const response: ModifyCapacityReservationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ModifyCapacityReservationResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2ModifyCapacityReservationCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyCapacityReservationCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2ModifyClientVpnEndpointCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyClientVpnEndpointCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2ModifyClientVpnEndpointCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2ModifyClientVpnEndpointResult(data, context);
  const response: ModifyClientVpnEndpointCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ModifyClientVpnEndpointResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2ModifyClientVpnEndpointCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyClientVpnEndpointCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2ModifyDefaultCreditSpecificationCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyDefaultCreditSpecificationCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2ModifyDefaultCreditSpecificationCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2ModifyDefaultCreditSpecificationResult(
    data,
    context
  );
  const response: ModifyDefaultCreditSpecificationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ModifyDefaultCreditSpecificationResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2ModifyDefaultCreditSpecificationCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyDefaultCreditSpecificationCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2ModifyEbsDefaultKmsKeyIdCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyEbsDefaultKmsKeyIdCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2ModifyEbsDefaultKmsKeyIdCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2ModifyEbsDefaultKmsKeyIdResult(data, context);
  const response: ModifyEbsDefaultKmsKeyIdCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ModifyEbsDefaultKmsKeyIdResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2ModifyEbsDefaultKmsKeyIdCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyEbsDefaultKmsKeyIdCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2ModifyFleetCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyFleetCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2ModifyFleetCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2ModifyFleetResult(data, context);
  const response: ModifyFleetCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ModifyFleetResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2ModifyFleetCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyFleetCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2ModifyFpgaImageAttributeCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyFpgaImageAttributeCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2ModifyFpgaImageAttributeCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2ModifyFpgaImageAttributeResult(data, context);
  const response: ModifyFpgaImageAttributeCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ModifyFpgaImageAttributeResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2ModifyFpgaImageAttributeCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyFpgaImageAttributeCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2ModifyHostsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyHostsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2ModifyHostsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2ModifyHostsResult(data, context);
  const response: ModifyHostsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ModifyHostsResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2ModifyHostsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyHostsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2ModifyIdentityIdFormatCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyIdentityIdFormatCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2ModifyIdentityIdFormatCommandError(
      output,
      context
    );
  }
  await collectBody(output.body, context);
  const response: ModifyIdentityIdFormatCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2ModifyIdentityIdFormatCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyIdentityIdFormatCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2ModifyIdFormatCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyIdFormatCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2ModifyIdFormatCommandError(output, context);
  }
  await collectBody(output.body, context);
  const response: ModifyIdFormatCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2ModifyIdFormatCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyIdFormatCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2ModifyImageAttributeCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyImageAttributeCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2ModifyImageAttributeCommandError(output, context);
  }
  await collectBody(output.body, context);
  const response: ModifyImageAttributeCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2ModifyImageAttributeCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyImageAttributeCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2ModifyInstanceAttributeCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyInstanceAttributeCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2ModifyInstanceAttributeCommandError(
      output,
      context
    );
  }
  await collectBody(output.body, context);
  const response: ModifyInstanceAttributeCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2ModifyInstanceAttributeCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyInstanceAttributeCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2ModifyInstanceCapacityReservationAttributesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyInstanceCapacityReservationAttributesCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2ModifyInstanceCapacityReservationAttributesCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2ModifyInstanceCapacityReservationAttributesResult(
    data,
    context
  );
  const response: ModifyInstanceCapacityReservationAttributesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ModifyInstanceCapacityReservationAttributesResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2ModifyInstanceCapacityReservationAttributesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyInstanceCapacityReservationAttributesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2ModifyInstanceCreditSpecificationCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyInstanceCreditSpecificationCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2ModifyInstanceCreditSpecificationCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2ModifyInstanceCreditSpecificationResult(
    data,
    context
  );
  const response: ModifyInstanceCreditSpecificationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ModifyInstanceCreditSpecificationResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2ModifyInstanceCreditSpecificationCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyInstanceCreditSpecificationCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2ModifyInstanceEventStartTimeCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyInstanceEventStartTimeCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2ModifyInstanceEventStartTimeCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2ModifyInstanceEventStartTimeResult(
    data,
    context
  );
  const response: ModifyInstanceEventStartTimeCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ModifyInstanceEventStartTimeResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2ModifyInstanceEventStartTimeCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyInstanceEventStartTimeCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2ModifyInstanceMetadataOptionsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyInstanceMetadataOptionsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2ModifyInstanceMetadataOptionsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2ModifyInstanceMetadataOptionsResult(
    data,
    context
  );
  const response: ModifyInstanceMetadataOptionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ModifyInstanceMetadataOptionsResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2ModifyInstanceMetadataOptionsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyInstanceMetadataOptionsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2ModifyInstancePlacementCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyInstancePlacementCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2ModifyInstancePlacementCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2ModifyInstancePlacementResult(data, context);
  const response: ModifyInstancePlacementCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ModifyInstancePlacementResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2ModifyInstancePlacementCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyInstancePlacementCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2ModifyLaunchTemplateCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyLaunchTemplateCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2ModifyLaunchTemplateCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2ModifyLaunchTemplateResult(data, context);
  const response: ModifyLaunchTemplateCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ModifyLaunchTemplateResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2ModifyLaunchTemplateCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyLaunchTemplateCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2ModifyNetworkInterfaceAttributeCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyNetworkInterfaceAttributeCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2ModifyNetworkInterfaceAttributeCommandError(
      output,
      context
    );
  }
  await collectBody(output.body, context);
  const response: ModifyNetworkInterfaceAttributeCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2ModifyNetworkInterfaceAttributeCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyNetworkInterfaceAttributeCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2ModifyReservedInstancesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyReservedInstancesCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2ModifyReservedInstancesCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2ModifyReservedInstancesResult(data, context);
  const response: ModifyReservedInstancesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ModifyReservedInstancesResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2ModifyReservedInstancesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyReservedInstancesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2ModifySnapshotAttributeCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifySnapshotAttributeCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2ModifySnapshotAttributeCommandError(
      output,
      context
    );
  }
  await collectBody(output.body, context);
  const response: ModifySnapshotAttributeCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2ModifySnapshotAttributeCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifySnapshotAttributeCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2ModifySpotFleetRequestCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifySpotFleetRequestCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2ModifySpotFleetRequestCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2ModifySpotFleetRequestResponse(data, context);
  const response: ModifySpotFleetRequestCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ModifySpotFleetRequestResponse",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2ModifySpotFleetRequestCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifySpotFleetRequestCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2ModifySubnetAttributeCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifySubnetAttributeCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2ModifySubnetAttributeCommandError(output, context);
  }
  await collectBody(output.body, context);
  const response: ModifySubnetAttributeCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2ModifySubnetAttributeCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifySubnetAttributeCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2ModifyTrafficMirrorFilterNetworkServicesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyTrafficMirrorFilterNetworkServicesCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2ModifyTrafficMirrorFilterNetworkServicesCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2ModifyTrafficMirrorFilterNetworkServicesResult(
    data,
    context
  );
  const response: ModifyTrafficMirrorFilterNetworkServicesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ModifyTrafficMirrorFilterNetworkServicesResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2ModifyTrafficMirrorFilterNetworkServicesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyTrafficMirrorFilterNetworkServicesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2ModifyTrafficMirrorFilterRuleCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyTrafficMirrorFilterRuleCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2ModifyTrafficMirrorFilterRuleCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2ModifyTrafficMirrorFilterRuleResult(
    data,
    context
  );
  const response: ModifyTrafficMirrorFilterRuleCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ModifyTrafficMirrorFilterRuleResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2ModifyTrafficMirrorFilterRuleCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyTrafficMirrorFilterRuleCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2ModifyTrafficMirrorSessionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyTrafficMirrorSessionCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2ModifyTrafficMirrorSessionCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2ModifyTrafficMirrorSessionResult(data, context);
  const response: ModifyTrafficMirrorSessionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ModifyTrafficMirrorSessionResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2ModifyTrafficMirrorSessionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyTrafficMirrorSessionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2ModifyTransitGatewayVpcAttachmentCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyTransitGatewayVpcAttachmentCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2ModifyTransitGatewayVpcAttachmentCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2ModifyTransitGatewayVpcAttachmentResult(
    data,
    context
  );
  const response: ModifyTransitGatewayVpcAttachmentCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ModifyTransitGatewayVpcAttachmentResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2ModifyTransitGatewayVpcAttachmentCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyTransitGatewayVpcAttachmentCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2ModifyVolumeCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyVolumeCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2ModifyVolumeCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2ModifyVolumeResult(data, context);
  const response: ModifyVolumeCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ModifyVolumeResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2ModifyVolumeCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyVolumeCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2ModifyVolumeAttributeCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyVolumeAttributeCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2ModifyVolumeAttributeCommandError(output, context);
  }
  await collectBody(output.body, context);
  const response: ModifyVolumeAttributeCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2ModifyVolumeAttributeCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyVolumeAttributeCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2ModifyVpcAttributeCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyVpcAttributeCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2ModifyVpcAttributeCommandError(output, context);
  }
  await collectBody(output.body, context);
  const response: ModifyVpcAttributeCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2ModifyVpcAttributeCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyVpcAttributeCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2ModifyVpcEndpointCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyVpcEndpointCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2ModifyVpcEndpointCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2ModifyVpcEndpointResult(data, context);
  const response: ModifyVpcEndpointCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ModifyVpcEndpointResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2ModifyVpcEndpointCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyVpcEndpointCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2ModifyVpcEndpointConnectionNotificationCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyVpcEndpointConnectionNotificationCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2ModifyVpcEndpointConnectionNotificationCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2ModifyVpcEndpointConnectionNotificationResult(
    data,
    context
  );
  const response: ModifyVpcEndpointConnectionNotificationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ModifyVpcEndpointConnectionNotificationResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2ModifyVpcEndpointConnectionNotificationCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyVpcEndpointConnectionNotificationCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2ModifyVpcEndpointServiceConfigurationCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyVpcEndpointServiceConfigurationCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2ModifyVpcEndpointServiceConfigurationCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2ModifyVpcEndpointServiceConfigurationResult(
    data,
    context
  );
  const response: ModifyVpcEndpointServiceConfigurationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ModifyVpcEndpointServiceConfigurationResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2ModifyVpcEndpointServiceConfigurationCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyVpcEndpointServiceConfigurationCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2ModifyVpcEndpointServicePermissionsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyVpcEndpointServicePermissionsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2ModifyVpcEndpointServicePermissionsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2ModifyVpcEndpointServicePermissionsResult(
    data,
    context
  );
  const response: ModifyVpcEndpointServicePermissionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ModifyVpcEndpointServicePermissionsResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2ModifyVpcEndpointServicePermissionsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyVpcEndpointServicePermissionsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2ModifyVpcPeeringConnectionOptionsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyVpcPeeringConnectionOptionsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2ModifyVpcPeeringConnectionOptionsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2ModifyVpcPeeringConnectionOptionsResult(
    data,
    context
  );
  const response: ModifyVpcPeeringConnectionOptionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ModifyVpcPeeringConnectionOptionsResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2ModifyVpcPeeringConnectionOptionsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyVpcPeeringConnectionOptionsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2ModifyVpcTenancyCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyVpcTenancyCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2ModifyVpcTenancyCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2ModifyVpcTenancyResult(data, context);
  const response: ModifyVpcTenancyCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ModifyVpcTenancyResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2ModifyVpcTenancyCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyVpcTenancyCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2ModifyVpnConnectionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyVpnConnectionCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2ModifyVpnConnectionCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2ModifyVpnConnectionResult(data, context);
  const response: ModifyVpnConnectionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ModifyVpnConnectionResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2ModifyVpnConnectionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyVpnConnectionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2ModifyVpnTunnelCertificateCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyVpnTunnelCertificateCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2ModifyVpnTunnelCertificateCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2ModifyVpnTunnelCertificateResult(data, context);
  const response: ModifyVpnTunnelCertificateCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ModifyVpnTunnelCertificateResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2ModifyVpnTunnelCertificateCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyVpnTunnelCertificateCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2ModifyVpnTunnelOptionsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyVpnTunnelOptionsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2ModifyVpnTunnelOptionsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2ModifyVpnTunnelOptionsResult(data, context);
  const response: ModifyVpnTunnelOptionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ModifyVpnTunnelOptionsResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2ModifyVpnTunnelOptionsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyVpnTunnelOptionsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2MonitorInstancesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<MonitorInstancesCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2MonitorInstancesCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2MonitorInstancesResult(data, context);
  const response: MonitorInstancesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "MonitorInstancesResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2MonitorInstancesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<MonitorInstancesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2MoveAddressToVpcCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<MoveAddressToVpcCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2MoveAddressToVpcCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2MoveAddressToVpcResult(data, context);
  const response: MoveAddressToVpcCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "MoveAddressToVpcResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2MoveAddressToVpcCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<MoveAddressToVpcCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2ProvisionByoipCidrCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ProvisionByoipCidrCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2ProvisionByoipCidrCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2ProvisionByoipCidrResult(data, context);
  const response: ProvisionByoipCidrCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ProvisionByoipCidrResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2ProvisionByoipCidrCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ProvisionByoipCidrCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2PurchaseHostReservationCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PurchaseHostReservationCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2PurchaseHostReservationCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2PurchaseHostReservationResult(data, context);
  const response: PurchaseHostReservationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "PurchaseHostReservationResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2PurchaseHostReservationCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PurchaseHostReservationCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2PurchaseReservedInstancesOfferingCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PurchaseReservedInstancesOfferingCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2PurchaseReservedInstancesOfferingCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2PurchaseReservedInstancesOfferingResult(
    data,
    context
  );
  const response: PurchaseReservedInstancesOfferingCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "PurchaseReservedInstancesOfferingResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2PurchaseReservedInstancesOfferingCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PurchaseReservedInstancesOfferingCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2PurchaseScheduledInstancesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PurchaseScheduledInstancesCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2PurchaseScheduledInstancesCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2PurchaseScheduledInstancesResult(data, context);
  const response: PurchaseScheduledInstancesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "PurchaseScheduledInstancesResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2PurchaseScheduledInstancesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PurchaseScheduledInstancesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2RebootInstancesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RebootInstancesCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2RebootInstancesCommandError(output, context);
  }
  await collectBody(output.body, context);
  const response: RebootInstancesCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2RebootInstancesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RebootInstancesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2RegisterImageCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RegisterImageCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2RegisterImageCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2RegisterImageResult(data, context);
  const response: RegisterImageCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "RegisterImageResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2RegisterImageCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RegisterImageCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2RegisterTransitGatewayMulticastGroupMembersCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RegisterTransitGatewayMulticastGroupMembersCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2RegisterTransitGatewayMulticastGroupMembersCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2RegisterTransitGatewayMulticastGroupMembersResult(
    data,
    context
  );
  const response: RegisterTransitGatewayMulticastGroupMembersCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "RegisterTransitGatewayMulticastGroupMembersResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2RegisterTransitGatewayMulticastGroupMembersCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RegisterTransitGatewayMulticastGroupMembersCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2RegisterTransitGatewayMulticastGroupSourcesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RegisterTransitGatewayMulticastGroupSourcesCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2RegisterTransitGatewayMulticastGroupSourcesCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2RegisterTransitGatewayMulticastGroupSourcesResult(
    data,
    context
  );
  const response: RegisterTransitGatewayMulticastGroupSourcesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "RegisterTransitGatewayMulticastGroupSourcesResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2RegisterTransitGatewayMulticastGroupSourcesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RegisterTransitGatewayMulticastGroupSourcesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2RejectTransitGatewayPeeringAttachmentCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RejectTransitGatewayPeeringAttachmentCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2RejectTransitGatewayPeeringAttachmentCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2RejectTransitGatewayPeeringAttachmentResult(
    data,
    context
  );
  const response: RejectTransitGatewayPeeringAttachmentCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "RejectTransitGatewayPeeringAttachmentResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2RejectTransitGatewayPeeringAttachmentCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RejectTransitGatewayPeeringAttachmentCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2RejectTransitGatewayVpcAttachmentCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RejectTransitGatewayVpcAttachmentCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2RejectTransitGatewayVpcAttachmentCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2RejectTransitGatewayVpcAttachmentResult(
    data,
    context
  );
  const response: RejectTransitGatewayVpcAttachmentCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "RejectTransitGatewayVpcAttachmentResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2RejectTransitGatewayVpcAttachmentCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RejectTransitGatewayVpcAttachmentCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2RejectVpcEndpointConnectionsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RejectVpcEndpointConnectionsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2RejectVpcEndpointConnectionsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2RejectVpcEndpointConnectionsResult(
    data,
    context
  );
  const response: RejectVpcEndpointConnectionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "RejectVpcEndpointConnectionsResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2RejectVpcEndpointConnectionsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RejectVpcEndpointConnectionsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2RejectVpcPeeringConnectionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RejectVpcPeeringConnectionCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2RejectVpcPeeringConnectionCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2RejectVpcPeeringConnectionResult(data, context);
  const response: RejectVpcPeeringConnectionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "RejectVpcPeeringConnectionResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2RejectVpcPeeringConnectionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RejectVpcPeeringConnectionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2ReleaseAddressCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ReleaseAddressCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2ReleaseAddressCommandError(output, context);
  }
  await collectBody(output.body, context);
  const response: ReleaseAddressCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2ReleaseAddressCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ReleaseAddressCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2ReleaseHostsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ReleaseHostsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2ReleaseHostsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2ReleaseHostsResult(data, context);
  const response: ReleaseHostsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ReleaseHostsResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2ReleaseHostsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ReleaseHostsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2ReplaceIamInstanceProfileAssociationCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ReplaceIamInstanceProfileAssociationCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2ReplaceIamInstanceProfileAssociationCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2ReplaceIamInstanceProfileAssociationResult(
    data,
    context
  );
  const response: ReplaceIamInstanceProfileAssociationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ReplaceIamInstanceProfileAssociationResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2ReplaceIamInstanceProfileAssociationCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ReplaceIamInstanceProfileAssociationCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2ReplaceNetworkAclAssociationCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ReplaceNetworkAclAssociationCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2ReplaceNetworkAclAssociationCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2ReplaceNetworkAclAssociationResult(
    data,
    context
  );
  const response: ReplaceNetworkAclAssociationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ReplaceNetworkAclAssociationResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2ReplaceNetworkAclAssociationCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ReplaceNetworkAclAssociationCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2ReplaceNetworkAclEntryCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ReplaceNetworkAclEntryCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2ReplaceNetworkAclEntryCommandError(
      output,
      context
    );
  }
  await collectBody(output.body, context);
  const response: ReplaceNetworkAclEntryCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2ReplaceNetworkAclEntryCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ReplaceNetworkAclEntryCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2ReplaceRouteCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ReplaceRouteCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2ReplaceRouteCommandError(output, context);
  }
  await collectBody(output.body, context);
  const response: ReplaceRouteCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2ReplaceRouteCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ReplaceRouteCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2ReplaceRouteTableAssociationCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ReplaceRouteTableAssociationCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2ReplaceRouteTableAssociationCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2ReplaceRouteTableAssociationResult(
    data,
    context
  );
  const response: ReplaceRouteTableAssociationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ReplaceRouteTableAssociationResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2ReplaceRouteTableAssociationCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ReplaceRouteTableAssociationCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2ReplaceTransitGatewayRouteCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ReplaceTransitGatewayRouteCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2ReplaceTransitGatewayRouteCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2ReplaceTransitGatewayRouteResult(data, context);
  const response: ReplaceTransitGatewayRouteCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ReplaceTransitGatewayRouteResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2ReplaceTransitGatewayRouteCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ReplaceTransitGatewayRouteCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2ReportInstanceStatusCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ReportInstanceStatusCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2ReportInstanceStatusCommandError(output, context);
  }
  await collectBody(output.body, context);
  const response: ReportInstanceStatusCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2ReportInstanceStatusCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ReportInstanceStatusCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2RequestSpotFleetCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RequestSpotFleetCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2RequestSpotFleetCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2RequestSpotFleetResponse(data, context);
  const response: RequestSpotFleetCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "RequestSpotFleetResponse",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2RequestSpotFleetCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RequestSpotFleetCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2RequestSpotInstancesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RequestSpotInstancesCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2RequestSpotInstancesCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2RequestSpotInstancesResult(data, context);
  const response: RequestSpotInstancesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "RequestSpotInstancesResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2RequestSpotInstancesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RequestSpotInstancesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2ResetEbsDefaultKmsKeyIdCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ResetEbsDefaultKmsKeyIdCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2ResetEbsDefaultKmsKeyIdCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2ResetEbsDefaultKmsKeyIdResult(data, context);
  const response: ResetEbsDefaultKmsKeyIdCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ResetEbsDefaultKmsKeyIdResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2ResetEbsDefaultKmsKeyIdCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ResetEbsDefaultKmsKeyIdCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2ResetFpgaImageAttributeCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ResetFpgaImageAttributeCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2ResetFpgaImageAttributeCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2ResetFpgaImageAttributeResult(data, context);
  const response: ResetFpgaImageAttributeCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ResetFpgaImageAttributeResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2ResetFpgaImageAttributeCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ResetFpgaImageAttributeCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2ResetImageAttributeCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ResetImageAttributeCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2ResetImageAttributeCommandError(output, context);
  }
  await collectBody(output.body, context);
  const response: ResetImageAttributeCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2ResetImageAttributeCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ResetImageAttributeCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2ResetInstanceAttributeCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ResetInstanceAttributeCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2ResetInstanceAttributeCommandError(
      output,
      context
    );
  }
  await collectBody(output.body, context);
  const response: ResetInstanceAttributeCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2ResetInstanceAttributeCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ResetInstanceAttributeCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2ResetNetworkInterfaceAttributeCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ResetNetworkInterfaceAttributeCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2ResetNetworkInterfaceAttributeCommandError(
      output,
      context
    );
  }
  await collectBody(output.body, context);
  const response: ResetNetworkInterfaceAttributeCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2ResetNetworkInterfaceAttributeCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ResetNetworkInterfaceAttributeCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2ResetSnapshotAttributeCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ResetSnapshotAttributeCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2ResetSnapshotAttributeCommandError(
      output,
      context
    );
  }
  await collectBody(output.body, context);
  const response: ResetSnapshotAttributeCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2ResetSnapshotAttributeCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ResetSnapshotAttributeCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2RestoreAddressToClassicCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RestoreAddressToClassicCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2RestoreAddressToClassicCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2RestoreAddressToClassicResult(data, context);
  const response: RestoreAddressToClassicCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "RestoreAddressToClassicResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2RestoreAddressToClassicCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RestoreAddressToClassicCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2RevokeClientVpnIngressCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RevokeClientVpnIngressCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2RevokeClientVpnIngressCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2RevokeClientVpnIngressResult(data, context);
  const response: RevokeClientVpnIngressCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "RevokeClientVpnIngressResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2RevokeClientVpnIngressCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RevokeClientVpnIngressCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2RevokeSecurityGroupEgressCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RevokeSecurityGroupEgressCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2RevokeSecurityGroupEgressCommandError(
      output,
      context
    );
  }
  await collectBody(output.body, context);
  const response: RevokeSecurityGroupEgressCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2RevokeSecurityGroupEgressCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RevokeSecurityGroupEgressCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2RevokeSecurityGroupIngressCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RevokeSecurityGroupIngressCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2RevokeSecurityGroupIngressCommandError(
      output,
      context
    );
  }
  await collectBody(output.body, context);
  const response: RevokeSecurityGroupIngressCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2RevokeSecurityGroupIngressCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RevokeSecurityGroupIngressCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2RunInstancesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RunInstancesCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2RunInstancesCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2Reservation(data, context);
  const response: RunInstancesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "Reservation",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2RunInstancesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RunInstancesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2RunScheduledInstancesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RunScheduledInstancesCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2RunScheduledInstancesCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2RunScheduledInstancesResult(data, context);
  const response: RunScheduledInstancesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "RunScheduledInstancesResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2RunScheduledInstancesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RunScheduledInstancesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2SearchLocalGatewayRoutesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<SearchLocalGatewayRoutesCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2SearchLocalGatewayRoutesCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2SearchLocalGatewayRoutesResult(data, context);
  const response: SearchLocalGatewayRoutesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "SearchLocalGatewayRoutesResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2SearchLocalGatewayRoutesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<SearchLocalGatewayRoutesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2SearchTransitGatewayMulticastGroupsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<SearchTransitGatewayMulticastGroupsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2SearchTransitGatewayMulticastGroupsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2SearchTransitGatewayMulticastGroupsResult(
    data,
    context
  );
  const response: SearchTransitGatewayMulticastGroupsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "SearchTransitGatewayMulticastGroupsResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2SearchTransitGatewayMulticastGroupsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<SearchTransitGatewayMulticastGroupsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2SearchTransitGatewayRoutesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<SearchTransitGatewayRoutesCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2SearchTransitGatewayRoutesCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2SearchTransitGatewayRoutesResult(data, context);
  const response: SearchTransitGatewayRoutesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "SearchTransitGatewayRoutesResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2SearchTransitGatewayRoutesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<SearchTransitGatewayRoutesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2SendDiagnosticInterruptCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<SendDiagnosticInterruptCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2SendDiagnosticInterruptCommandError(
      output,
      context
    );
  }
  await collectBody(output.body, context);
  const response: SendDiagnosticInterruptCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2SendDiagnosticInterruptCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<SendDiagnosticInterruptCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2StartInstancesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartInstancesCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2StartInstancesCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2StartInstancesResult(data, context);
  const response: StartInstancesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "StartInstancesResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2StartInstancesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartInstancesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2StartVpcEndpointServicePrivateDnsVerificationCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartVpcEndpointServicePrivateDnsVerificationCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2StartVpcEndpointServicePrivateDnsVerificationCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2StartVpcEndpointServicePrivateDnsVerificationResult(
    data,
    context
  );
  const response: StartVpcEndpointServicePrivateDnsVerificationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "StartVpcEndpointServicePrivateDnsVerificationResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2StartVpcEndpointServicePrivateDnsVerificationCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartVpcEndpointServicePrivateDnsVerificationCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2StopInstancesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StopInstancesCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2StopInstancesCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2StopInstancesResult(data, context);
  const response: StopInstancesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "StopInstancesResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2StopInstancesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StopInstancesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2TerminateClientVpnConnectionsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<TerminateClientVpnConnectionsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2TerminateClientVpnConnectionsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2TerminateClientVpnConnectionsResult(
    data,
    context
  );
  const response: TerminateClientVpnConnectionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "TerminateClientVpnConnectionsResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2TerminateClientVpnConnectionsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<TerminateClientVpnConnectionsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2TerminateInstancesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<TerminateInstancesCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2TerminateInstancesCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2TerminateInstancesResult(data, context);
  const response: TerminateInstancesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "TerminateInstancesResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2TerminateInstancesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<TerminateInstancesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2UnassignIpv6AddressesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UnassignIpv6AddressesCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2UnassignIpv6AddressesCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2UnassignIpv6AddressesResult(data, context);
  const response: UnassignIpv6AddressesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UnassignIpv6AddressesResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2UnassignIpv6AddressesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UnassignIpv6AddressesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2UnassignPrivateIpAddressesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UnassignPrivateIpAddressesCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2UnassignPrivateIpAddressesCommandError(
      output,
      context
    );
  }
  await collectBody(output.body, context);
  const response: UnassignPrivateIpAddressesCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2UnassignPrivateIpAddressesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UnassignPrivateIpAddressesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2UnmonitorInstancesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UnmonitorInstancesCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2UnmonitorInstancesCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2UnmonitorInstancesResult(data, context);
  const response: UnmonitorInstancesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UnmonitorInstancesResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2UnmonitorInstancesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UnmonitorInstancesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2UpdateSecurityGroupRuleDescriptionsEgressCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateSecurityGroupRuleDescriptionsEgressCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2UpdateSecurityGroupRuleDescriptionsEgressCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2UpdateSecurityGroupRuleDescriptionsEgressResult(
    data,
    context
  );
  const response: UpdateSecurityGroupRuleDescriptionsEgressCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateSecurityGroupRuleDescriptionsEgressResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2UpdateSecurityGroupRuleDescriptionsEgressCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateSecurityGroupRuleDescriptionsEgressCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2UpdateSecurityGroupRuleDescriptionsIngressCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateSecurityGroupRuleDescriptionsIngressCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2UpdateSecurityGroupRuleDescriptionsIngressCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2UpdateSecurityGroupRuleDescriptionsIngressResult(
    data,
    context
  );
  const response: UpdateSecurityGroupRuleDescriptionsIngressCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateSecurityGroupRuleDescriptionsIngressResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2UpdateSecurityGroupRuleDescriptionsIngressCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateSecurityGroupRuleDescriptionsIngressCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_ec2WithdrawByoipCidrCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<WithdrawByoipCidrCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_ec2WithdrawByoipCidrCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_ec2WithdrawByoipCidrResult(data, context);
  const response: WithdrawByoipCidrCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "WithdrawByoipCidrResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_ec2WithdrawByoipCidrCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<WithdrawByoipCidrCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadEc2ErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode =
        parsedBody.Errors.Error.code ||
        parsedBody.Errors.Error.Code ||
        errorCode;
      response = {
        ...parsedBody.Errors.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Errors.Error.message ||
          parsedBody.Errors.Error.Message ||
          errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

const serializeAws_ec2AcceptReservedInstancesExchangeQuoteRequest = (
  input: AcceptReservedInstancesExchangeQuoteRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.ReservedInstanceIds !== undefined) {
    const memberEntries = serializeAws_ec2ReservedInstanceIdSet(
      input.ReservedInstanceIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `ReservedInstanceId.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.TargetConfigurations !== undefined) {
    const memberEntries = serializeAws_ec2TargetConfigurationRequestSet(
      input.TargetConfigurations,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `TargetConfiguration.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2AcceptTransitGatewayPeeringAttachmentRequest = (
  input: AcceptTransitGatewayPeeringAttachmentRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.TransitGatewayAttachmentId !== undefined) {
    entries["TransitGatewayAttachmentId"] = input.TransitGatewayAttachmentId;
  }
  return entries;
};

const serializeAws_ec2AcceptTransitGatewayVpcAttachmentRequest = (
  input: AcceptTransitGatewayVpcAttachmentRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.TransitGatewayAttachmentId !== undefined) {
    entries["TransitGatewayAttachmentId"] = input.TransitGatewayAttachmentId;
  }
  return entries;
};

const serializeAws_ec2AcceptVpcEndpointConnectionsRequest = (
  input: AcceptVpcEndpointConnectionsRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.ServiceId !== undefined) {
    entries["ServiceId"] = input.ServiceId;
  }
  if (input.VpcEndpointIds !== undefined) {
    const memberEntries = serializeAws_ec2ValueStringList(
      input.VpcEndpointIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `VpcEndpointId.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2AcceptVpcPeeringConnectionRequest = (
  input: AcceptVpcPeeringConnectionRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.VpcPeeringConnectionId !== undefined) {
    entries["VpcPeeringConnectionId"] = input.VpcPeeringConnectionId;
  }
  return entries;
};

const serializeAws_ec2AccountAttributeNameStringList = (
  input: (AccountAttributeName | string)[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    entries[`AttributeName.${counter}`] = entry;
    counter++;
  }
  return entries;
};

const serializeAws_ec2AdvertiseByoipCidrRequest = (
  input: AdvertiseByoipCidrRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Cidr !== undefined) {
    entries["Cidr"] = input.Cidr;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  return entries;
};

const serializeAws_ec2AllocateAddressRequest = (
  input: AllocateAddressRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Address !== undefined) {
    entries["Address"] = input.Address;
  }
  if (input.CustomerOwnedIpv4Pool !== undefined) {
    entries["CustomerOwnedIpv4Pool"] = input.CustomerOwnedIpv4Pool;
  }
  if (input.Domain !== undefined) {
    entries["Domain"] = input.Domain;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.NetworkBorderGroup !== undefined) {
    entries["NetworkBorderGroup"] = input.NetworkBorderGroup;
  }
  if (input.PublicIpv4Pool !== undefined) {
    entries["PublicIpv4Pool"] = input.PublicIpv4Pool;
  }
  return entries;
};

const serializeAws_ec2AllocateHostsRequest = (
  input: AllocateHostsRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.AutoPlacement !== undefined) {
    entries["AutoPlacement"] = input.AutoPlacement;
  }
  if (input.AvailabilityZone !== undefined) {
    entries["AvailabilityZone"] = input.AvailabilityZone;
  }
  if (input.ClientToken !== undefined) {
    entries["ClientToken"] = input.ClientToken;
  }
  if (input.HostRecovery !== undefined) {
    entries["HostRecovery"] = input.HostRecovery;
  }
  if (input.InstanceFamily !== undefined) {
    entries["InstanceFamily"] = input.InstanceFamily;
  }
  if (input.InstanceType !== undefined) {
    entries["InstanceType"] = input.InstanceType;
  }
  if (input.Quantity !== undefined) {
    entries["Quantity"] = input.Quantity;
  }
  if (input.TagSpecifications !== undefined) {
    const memberEntries = serializeAws_ec2TagSpecificationList(
      input.TagSpecifications,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2AllocationIdList = (
  input: string[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    entries[`AllocationId.${counter}`] = entry;
    counter++;
  }
  return entries;
};

const serializeAws_ec2ApplySecurityGroupsToClientVpnTargetNetworkRequest = (
  input: ApplySecurityGroupsToClientVpnTargetNetworkRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.ClientVpnEndpointId !== undefined) {
    entries["ClientVpnEndpointId"] = input.ClientVpnEndpointId;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.SecurityGroupIds !== undefined) {
    const memberEntries = serializeAws_ec2ClientVpnSecurityGroupIdSet(
      input.SecurityGroupIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `SecurityGroupId.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.VpcId !== undefined) {
    entries["VpcId"] = input.VpcId;
  }
  return entries;
};

const serializeAws_ec2AssignIpv6AddressesRequest = (
  input: AssignIpv6AddressesRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Ipv6AddressCount !== undefined) {
    entries["Ipv6AddressCount"] = input.Ipv6AddressCount;
  }
  if (input.Ipv6Addresses !== undefined) {
    const memberEntries = serializeAws_ec2Ipv6AddressList(
      input.Ipv6Addresses,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Ipv6Addresses.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.NetworkInterfaceId !== undefined) {
    entries["NetworkInterfaceId"] = input.NetworkInterfaceId;
  }
  return entries;
};

const serializeAws_ec2AssignPrivateIpAddressesRequest = (
  input: AssignPrivateIpAddressesRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.AllowReassignment !== undefined) {
    entries["AllowReassignment"] = input.AllowReassignment;
  }
  if (input.NetworkInterfaceId !== undefined) {
    entries["NetworkInterfaceId"] = input.NetworkInterfaceId;
  }
  if (input.PrivateIpAddresses !== undefined) {
    const memberEntries = serializeAws_ec2PrivateIpAddressStringList(
      input.PrivateIpAddresses,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `PrivateIpAddress.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.SecondaryPrivateIpAddressCount !== undefined) {
    entries["SecondaryPrivateIpAddressCount"] =
      input.SecondaryPrivateIpAddressCount;
  }
  return entries;
};

const serializeAws_ec2AssociateAddressRequest = (
  input: AssociateAddressRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.AllocationId !== undefined) {
    entries["AllocationId"] = input.AllocationId;
  }
  if (input.AllowReassociation !== undefined) {
    entries["AllowReassociation"] = input.AllowReassociation;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.InstanceId !== undefined) {
    entries["InstanceId"] = input.InstanceId;
  }
  if (input.NetworkInterfaceId !== undefined) {
    entries["NetworkInterfaceId"] = input.NetworkInterfaceId;
  }
  if (input.PrivateIpAddress !== undefined) {
    entries["PrivateIpAddress"] = input.PrivateIpAddress;
  }
  if (input.PublicIp !== undefined) {
    entries["PublicIp"] = input.PublicIp;
  }
  return entries;
};

const serializeAws_ec2AssociateClientVpnTargetNetworkRequest = (
  input: AssociateClientVpnTargetNetworkRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.ClientToken === undefined) {
    input.ClientToken = generateIdempotencyToken();
  }
  if (input.ClientToken !== undefined) {
    entries["ClientToken"] = input.ClientToken;
  }
  if (input.ClientVpnEndpointId !== undefined) {
    entries["ClientVpnEndpointId"] = input.ClientVpnEndpointId;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.SubnetId !== undefined) {
    entries["SubnetId"] = input.SubnetId;
  }
  return entries;
};

const serializeAws_ec2AssociateDhcpOptionsRequest = (
  input: AssociateDhcpOptionsRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DhcpOptionsId !== undefined) {
    entries["DhcpOptionsId"] = input.DhcpOptionsId;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.VpcId !== undefined) {
    entries["VpcId"] = input.VpcId;
  }
  return entries;
};

const serializeAws_ec2AssociateIamInstanceProfileRequest = (
  input: AssociateIamInstanceProfileRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.IamInstanceProfile !== undefined) {
    const memberEntries = serializeAws_ec2IamInstanceProfileSpecification(
      input.IamInstanceProfile,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `IamInstanceProfile.${key}`;
      entries[loc] = value;
    });
  }
  if (input.InstanceId !== undefined) {
    entries["InstanceId"] = input.InstanceId;
  }
  return entries;
};

const serializeAws_ec2AssociateRouteTableRequest = (
  input: AssociateRouteTableRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.GatewayId !== undefined) {
    entries["GatewayId"] = input.GatewayId;
  }
  if (input.RouteTableId !== undefined) {
    entries["RouteTableId"] = input.RouteTableId;
  }
  if (input.SubnetId !== undefined) {
    entries["SubnetId"] = input.SubnetId;
  }
  return entries;
};

const serializeAws_ec2AssociateSubnetCidrBlockRequest = (
  input: AssociateSubnetCidrBlockRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Ipv6CidrBlock !== undefined) {
    entries["Ipv6CidrBlock"] = input.Ipv6CidrBlock;
  }
  if (input.SubnetId !== undefined) {
    entries["SubnetId"] = input.SubnetId;
  }
  return entries;
};

const serializeAws_ec2AssociateTransitGatewayMulticastDomainRequest = (
  input: AssociateTransitGatewayMulticastDomainRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.SubnetIds !== undefined) {
    const memberEntries = serializeAws_ec2ValueStringList(
      input.SubnetIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `SubnetIds.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.TransitGatewayAttachmentId !== undefined) {
    entries["TransitGatewayAttachmentId"] = input.TransitGatewayAttachmentId;
  }
  if (input.TransitGatewayMulticastDomainId !== undefined) {
    entries["TransitGatewayMulticastDomainId"] =
      input.TransitGatewayMulticastDomainId;
  }
  return entries;
};

const serializeAws_ec2AssociateTransitGatewayRouteTableRequest = (
  input: AssociateTransitGatewayRouteTableRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.TransitGatewayAttachmentId !== undefined) {
    entries["TransitGatewayAttachmentId"] = input.TransitGatewayAttachmentId;
  }
  if (input.TransitGatewayRouteTableId !== undefined) {
    entries["TransitGatewayRouteTableId"] = input.TransitGatewayRouteTableId;
  }
  return entries;
};

const serializeAws_ec2AssociateVpcCidrBlockRequest = (
  input: AssociateVpcCidrBlockRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.AmazonProvidedIpv6CidrBlock !== undefined) {
    entries["AmazonProvidedIpv6CidrBlock"] = input.AmazonProvidedIpv6CidrBlock;
  }
  if (input.CidrBlock !== undefined) {
    entries["CidrBlock"] = input.CidrBlock;
  }
  if (input.Ipv6CidrBlock !== undefined) {
    entries["Ipv6CidrBlock"] = input.Ipv6CidrBlock;
  }
  if (input.Ipv6CidrBlockNetworkBorderGroup !== undefined) {
    entries["Ipv6CidrBlockNetworkBorderGroup"] =
      input.Ipv6CidrBlockNetworkBorderGroup;
  }
  if (input.Ipv6Pool !== undefined) {
    entries["Ipv6Pool"] = input.Ipv6Pool;
  }
  if (input.VpcId !== undefined) {
    entries["VpcId"] = input.VpcId;
  }
  return entries;
};

const serializeAws_ec2AssociationIdList = (
  input: string[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    entries[`AssociationId.${counter}`] = entry;
    counter++;
  }
  return entries;
};

const serializeAws_ec2AttachClassicLinkVpcRequest = (
  input: AttachClassicLinkVpcRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Groups !== undefined) {
    const memberEntries = serializeAws_ec2GroupIdStringList(
      input.Groups,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `SecurityGroupId.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.InstanceId !== undefined) {
    entries["InstanceId"] = input.InstanceId;
  }
  if (input.VpcId !== undefined) {
    entries["VpcId"] = input.VpcId;
  }
  return entries;
};

const serializeAws_ec2AttachInternetGatewayRequest = (
  input: AttachInternetGatewayRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.InternetGatewayId !== undefined) {
    entries["InternetGatewayId"] = input.InternetGatewayId;
  }
  if (input.VpcId !== undefined) {
    entries["VpcId"] = input.VpcId;
  }
  return entries;
};

const serializeAws_ec2AttachNetworkInterfaceRequest = (
  input: AttachNetworkInterfaceRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DeviceIndex !== undefined) {
    entries["DeviceIndex"] = input.DeviceIndex;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.InstanceId !== undefined) {
    entries["InstanceId"] = input.InstanceId;
  }
  if (input.NetworkInterfaceId !== undefined) {
    entries["NetworkInterfaceId"] = input.NetworkInterfaceId;
  }
  return entries;
};

const serializeAws_ec2AttachVolumeRequest = (
  input: AttachVolumeRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Device !== undefined) {
    entries["Device"] = input.Device;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.InstanceId !== undefined) {
    entries["InstanceId"] = input.InstanceId;
  }
  if (input.VolumeId !== undefined) {
    entries["VolumeId"] = input.VolumeId;
  }
  return entries;
};

const serializeAws_ec2AttachVpnGatewayRequest = (
  input: AttachVpnGatewayRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.VpcId !== undefined) {
    entries["VpcId"] = input.VpcId;
  }
  if (input.VpnGatewayId !== undefined) {
    entries["VpnGatewayId"] = input.VpnGatewayId;
  }
  return entries;
};

const serializeAws_ec2AttributeBooleanValue = (
  input: AttributeBooleanValue,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Value !== undefined) {
    entries["Value"] = input.Value;
  }
  return entries;
};

const serializeAws_ec2AttributeValue = (
  input: AttributeValue,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Value !== undefined) {
    entries["Value"] = input.Value;
  }
  return entries;
};

const serializeAws_ec2AuthorizeClientVpnIngressRequest = (
  input: AuthorizeClientVpnIngressRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.AccessGroupId !== undefined) {
    entries["AccessGroupId"] = input.AccessGroupId;
  }
  if (input.AuthorizeAllGroups !== undefined) {
    entries["AuthorizeAllGroups"] = input.AuthorizeAllGroups;
  }
  if (input.ClientToken === undefined) {
    input.ClientToken = generateIdempotencyToken();
  }
  if (input.ClientToken !== undefined) {
    entries["ClientToken"] = input.ClientToken;
  }
  if (input.ClientVpnEndpointId !== undefined) {
    entries["ClientVpnEndpointId"] = input.ClientVpnEndpointId;
  }
  if (input.Description !== undefined) {
    entries["Description"] = input.Description;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.TargetNetworkCidr !== undefined) {
    entries["TargetNetworkCidr"] = input.TargetNetworkCidr;
  }
  return entries;
};

const serializeAws_ec2AuthorizeSecurityGroupEgressRequest = (
  input: AuthorizeSecurityGroupEgressRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.CidrIp !== undefined) {
    entries["CidrIp"] = input.CidrIp;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.FromPort !== undefined) {
    entries["FromPort"] = input.FromPort;
  }
  if (input.GroupId !== undefined) {
    entries["GroupId"] = input.GroupId;
  }
  if (input.IpPermissions !== undefined) {
    const memberEntries = serializeAws_ec2IpPermissionList(
      input.IpPermissions,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `IpPermissions.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.IpProtocol !== undefined) {
    entries["IpProtocol"] = input.IpProtocol;
  }
  if (input.SourceSecurityGroupName !== undefined) {
    entries["SourceSecurityGroupName"] = input.SourceSecurityGroupName;
  }
  if (input.SourceSecurityGroupOwnerId !== undefined) {
    entries["SourceSecurityGroupOwnerId"] = input.SourceSecurityGroupOwnerId;
  }
  if (input.ToPort !== undefined) {
    entries["ToPort"] = input.ToPort;
  }
  return entries;
};

const serializeAws_ec2AuthorizeSecurityGroupIngressRequest = (
  input: AuthorizeSecurityGroupIngressRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.CidrIp !== undefined) {
    entries["CidrIp"] = input.CidrIp;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.FromPort !== undefined) {
    entries["FromPort"] = input.FromPort;
  }
  if (input.GroupId !== undefined) {
    entries["GroupId"] = input.GroupId;
  }
  if (input.GroupName !== undefined) {
    entries["GroupName"] = input.GroupName;
  }
  if (input.IpPermissions !== undefined) {
    const memberEntries = serializeAws_ec2IpPermissionList(
      input.IpPermissions,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `IpPermissions.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.IpProtocol !== undefined) {
    entries["IpProtocol"] = input.IpProtocol;
  }
  if (input.SourceSecurityGroupName !== undefined) {
    entries["SourceSecurityGroupName"] = input.SourceSecurityGroupName;
  }
  if (input.SourceSecurityGroupOwnerId !== undefined) {
    entries["SourceSecurityGroupOwnerId"] = input.SourceSecurityGroupOwnerId;
  }
  if (input.ToPort !== undefined) {
    entries["ToPort"] = input.ToPort;
  }
  return entries;
};

const serializeAws_ec2AvailabilityZoneStringList = (
  input: string[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    entries[`AvailabilityZone.${counter}`] = entry;
    counter++;
  }
  return entries;
};

const serializeAws_ec2BillingProductList = (
  input: string[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    entries[`Item.${counter}`] = entry;
    counter++;
  }
  return entries;
};

const serializeAws_ec2BlobAttributeValue = (
  input: BlobAttributeValue,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Value !== undefined) {
    entries["Value"] = context.base64Encoder(input.Value);
  }
  return entries;
};

const serializeAws_ec2BlockDeviceMapping = (
  input: BlockDeviceMapping,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DeviceName !== undefined) {
    entries["DeviceName"] = input.DeviceName;
  }
  if (input.Ebs !== undefined) {
    const memberEntries = serializeAws_ec2EbsBlockDevice(input.Ebs, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Ebs.${key}`;
      entries[loc] = value;
    });
  }
  if (input.NoDevice !== undefined) {
    entries["NoDevice"] = input.NoDevice;
  }
  if (input.VirtualName !== undefined) {
    entries["VirtualName"] = input.VirtualName;
  }
  return entries;
};

const serializeAws_ec2BlockDeviceMappingList = (
  input: BlockDeviceMapping[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    const memberEntries = serializeAws_ec2BlockDeviceMapping(entry, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      entries[`Item.${counter}.${key}`] = value;
    });
    counter++;
  }
  return entries;
};

const serializeAws_ec2BlockDeviceMappingRequestList = (
  input: BlockDeviceMapping[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    const memberEntries = serializeAws_ec2BlockDeviceMapping(entry, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      entries[`BlockDeviceMapping.${counter}.${key}`] = value;
    });
    counter++;
  }
  return entries;
};

const serializeAws_ec2BundleIdStringList = (
  input: string[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    entries[`BundleId.${counter}`] = entry;
    counter++;
  }
  return entries;
};

const serializeAws_ec2BundleInstanceRequest = (
  input: BundleInstanceRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.InstanceId !== undefined) {
    entries["InstanceId"] = input.InstanceId;
  }
  if (input.Storage !== undefined) {
    const memberEntries = serializeAws_ec2Storage(input.Storage, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Storage.${key}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2CancelBundleTaskRequest = (
  input: CancelBundleTaskRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.BundleId !== undefined) {
    entries["BundleId"] = input.BundleId;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  return entries;
};

const serializeAws_ec2CancelCapacityReservationRequest = (
  input: CancelCapacityReservationRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.CapacityReservationId !== undefined) {
    entries["CapacityReservationId"] = input.CapacityReservationId;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  return entries;
};

const serializeAws_ec2CancelConversionRequest = (
  input: CancelConversionRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.ConversionTaskId !== undefined) {
    entries["ConversionTaskId"] = input.ConversionTaskId;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.ReasonMessage !== undefined) {
    entries["ReasonMessage"] = input.ReasonMessage;
  }
  return entries;
};

const serializeAws_ec2CancelExportTaskRequest = (
  input: CancelExportTaskRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.ExportTaskId !== undefined) {
    entries["ExportTaskId"] = input.ExportTaskId;
  }
  return entries;
};

const serializeAws_ec2CancelImportTaskRequest = (
  input: CancelImportTaskRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.CancelReason !== undefined) {
    entries["CancelReason"] = input.CancelReason;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.ImportTaskId !== undefined) {
    entries["ImportTaskId"] = input.ImportTaskId;
  }
  return entries;
};

const serializeAws_ec2CancelReservedInstancesListingRequest = (
  input: CancelReservedInstancesListingRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.ReservedInstancesListingId !== undefined) {
    entries["ReservedInstancesListingId"] = input.ReservedInstancesListingId;
  }
  return entries;
};

const serializeAws_ec2CancelSpotFleetRequestsRequest = (
  input: CancelSpotFleetRequestsRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.SpotFleetRequestIds !== undefined) {
    const memberEntries = serializeAws_ec2ValueStringList(
      input.SpotFleetRequestIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `SpotFleetRequestId.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.TerminateInstances !== undefined) {
    entries["TerminateInstances"] = input.TerminateInstances;
  }
  return entries;
};

const serializeAws_ec2CancelSpotInstanceRequestsRequest = (
  input: CancelSpotInstanceRequestsRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.SpotInstanceRequestIds !== undefined) {
    const memberEntries = serializeAws_ec2SpotInstanceRequestIdList(
      input.SpotInstanceRequestIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `SpotInstanceRequestId.${key.substring(
        key.indexOf(".") + 1
      )}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2CapacityReservationIdSet = (
  input: string[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    entries[`Item.${counter}`] = entry;
    counter++;
  }
  return entries;
};

const serializeAws_ec2CapacityReservationOptionsRequest = (
  input: CapacityReservationOptionsRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.UsageStrategy !== undefined) {
    entries["UsageStrategy"] = input.UsageStrategy;
  }
  return entries;
};

const serializeAws_ec2CapacityReservationSpecification = (
  input: CapacityReservationSpecification,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.CapacityReservationPreference !== undefined) {
    entries["CapacityReservationPreference"] =
      input.CapacityReservationPreference;
  }
  if (input.CapacityReservationTarget !== undefined) {
    const memberEntries = serializeAws_ec2CapacityReservationTarget(
      input.CapacityReservationTarget,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `CapacityReservationTarget.${key}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2CapacityReservationTarget = (
  input: CapacityReservationTarget,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.CapacityReservationId !== undefined) {
    entries["CapacityReservationId"] = input.CapacityReservationId;
  }
  return entries;
};

const serializeAws_ec2CertificateAuthenticationRequest = (
  input: CertificateAuthenticationRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.ClientRootCertificateChainArn !== undefined) {
    entries["ClientRootCertificateChainArn"] =
      input.ClientRootCertificateChainArn;
  }
  return entries;
};

const serializeAws_ec2CidrAuthorizationContext = (
  input: CidrAuthorizationContext,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Message !== undefined) {
    entries["Message"] = input.Message;
  }
  if (input.Signature !== undefined) {
    entries["Signature"] = input.Signature;
  }
  return entries;
};

const serializeAws_ec2ClassicLoadBalancer = (
  input: ClassicLoadBalancer,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Name !== undefined) {
    entries["Name"] = input.Name;
  }
  return entries;
};

const serializeAws_ec2ClassicLoadBalancers = (
  input: ClassicLoadBalancer[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    const memberEntries = serializeAws_ec2ClassicLoadBalancer(entry, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      entries[`Item.${counter}.${key}`] = value;
    });
    counter++;
  }
  return entries;
};

const serializeAws_ec2ClassicLoadBalancersConfig = (
  input: ClassicLoadBalancersConfig,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.ClassicLoadBalancers !== undefined) {
    const memberEntries = serializeAws_ec2ClassicLoadBalancers(
      input.ClassicLoadBalancers,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `ClassicLoadBalancers.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2ClientData = (
  input: ClientData,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Comment !== undefined) {
    entries["Comment"] = input.Comment;
  }
  if (input.UploadEnd !== undefined) {
    entries["UploadEnd"] = input.UploadEnd.toISOString().split(".")[0] + "Z";
  }
  if (input.UploadSize !== undefined) {
    entries["UploadSize"] = input.UploadSize;
  }
  if (input.UploadStart !== undefined) {
    entries["UploadStart"] =
      input.UploadStart.toISOString().split(".")[0] + "Z";
  }
  return entries;
};

const serializeAws_ec2ClientVpnAuthenticationRequest = (
  input: ClientVpnAuthenticationRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.ActiveDirectory !== undefined) {
    const memberEntries = serializeAws_ec2DirectoryServiceAuthenticationRequest(
      input.ActiveDirectory,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `ActiveDirectory.${key}`;
      entries[loc] = value;
    });
  }
  if (input.MutualAuthentication !== undefined) {
    const memberEntries = serializeAws_ec2CertificateAuthenticationRequest(
      input.MutualAuthentication,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `MutualAuthentication.${key}`;
      entries[loc] = value;
    });
  }
  if (input.Type !== undefined) {
    entries["Type"] = input.Type;
  }
  return entries;
};

const serializeAws_ec2ClientVpnAuthenticationRequestList = (
  input: ClientVpnAuthenticationRequest[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    const memberEntries = serializeAws_ec2ClientVpnAuthenticationRequest(
      entry,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      entries[`Member.${counter}.${key}`] = value;
    });
    counter++;
  }
  return entries;
};

const serializeAws_ec2ClientVpnSecurityGroupIdSet = (
  input: string[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    entries[`Item.${counter}`] = entry;
    counter++;
  }
  return entries;
};

const serializeAws_ec2CoipPoolIdSet = (
  input: string[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    entries[`Item.${counter}`] = entry;
    counter++;
  }
  return entries;
};

const serializeAws_ec2ConfirmProductInstanceRequest = (
  input: ConfirmProductInstanceRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.InstanceId !== undefined) {
    entries["InstanceId"] = input.InstanceId;
  }
  if (input.ProductCode !== undefined) {
    entries["ProductCode"] = input.ProductCode;
  }
  return entries;
};

const serializeAws_ec2ConnectionLogOptions = (
  input: ConnectionLogOptions,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.CloudwatchLogGroup !== undefined) {
    entries["CloudwatchLogGroup"] = input.CloudwatchLogGroup;
  }
  if (input.CloudwatchLogStream !== undefined) {
    entries["CloudwatchLogStream"] = input.CloudwatchLogStream;
  }
  if (input.Enabled !== undefined) {
    entries["Enabled"] = input.Enabled;
  }
  return entries;
};

const serializeAws_ec2ConversionIdStringList = (
  input: string[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    entries[`Item.${counter}`] = entry;
    counter++;
  }
  return entries;
};

const serializeAws_ec2CopyFpgaImageRequest = (
  input: CopyFpgaImageRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.ClientToken !== undefined) {
    entries["ClientToken"] = input.ClientToken;
  }
  if (input.Description !== undefined) {
    entries["Description"] = input.Description;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Name !== undefined) {
    entries["Name"] = input.Name;
  }
  if (input.SourceFpgaImageId !== undefined) {
    entries["SourceFpgaImageId"] = input.SourceFpgaImageId;
  }
  if (input.SourceRegion !== undefined) {
    entries["SourceRegion"] = input.SourceRegion;
  }
  return entries;
};

const serializeAws_ec2CopyImageRequest = (
  input: CopyImageRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.ClientToken !== undefined) {
    entries["ClientToken"] = input.ClientToken;
  }
  if (input.Description !== undefined) {
    entries["Description"] = input.Description;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Encrypted !== undefined) {
    entries["Encrypted"] = input.Encrypted;
  }
  if (input.KmsKeyId !== undefined) {
    entries["KmsKeyId"] = input.KmsKeyId;
  }
  if (input.Name !== undefined) {
    entries["Name"] = input.Name;
  }
  if (input.SourceImageId !== undefined) {
    entries["SourceImageId"] = input.SourceImageId;
  }
  if (input.SourceRegion !== undefined) {
    entries["SourceRegion"] = input.SourceRegion;
  }
  return entries;
};

const serializeAws_ec2CopySnapshotRequest = (
  input: CopySnapshotRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Description !== undefined) {
    entries["Description"] = input.Description;
  }
  if (input.DestinationRegion !== undefined) {
    entries["DestinationRegion"] = input.DestinationRegion;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Encrypted !== undefined) {
    entries["Encrypted"] = input.Encrypted;
  }
  if (input.KmsKeyId !== undefined) {
    entries["KmsKeyId"] = input.KmsKeyId;
  }
  if (input.PresignedUrl !== undefined) {
    entries["PresignedUrl"] = input.PresignedUrl;
  }
  if (input.SourceRegion !== undefined) {
    entries["SourceRegion"] = input.SourceRegion;
  }
  if (input.SourceSnapshotId !== undefined) {
    entries["SourceSnapshotId"] = input.SourceSnapshotId;
  }
  if (input.TagSpecifications !== undefined) {
    const memberEntries = serializeAws_ec2TagSpecificationList(
      input.TagSpecifications,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2CpuOptionsRequest = (
  input: CpuOptionsRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.CoreCount !== undefined) {
    entries["CoreCount"] = input.CoreCount;
  }
  if (input.ThreadsPerCore !== undefined) {
    entries["ThreadsPerCore"] = input.ThreadsPerCore;
  }
  return entries;
};

const serializeAws_ec2CreateCapacityReservationRequest = (
  input: CreateCapacityReservationRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.AvailabilityZone !== undefined) {
    entries["AvailabilityZone"] = input.AvailabilityZone;
  }
  if (input.AvailabilityZoneId !== undefined) {
    entries["AvailabilityZoneId"] = input.AvailabilityZoneId;
  }
  if (input.ClientToken !== undefined) {
    entries["ClientToken"] = input.ClientToken;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.EbsOptimized !== undefined) {
    entries["EbsOptimized"] = input.EbsOptimized;
  }
  if (input.EndDate !== undefined) {
    entries["EndDate"] = input.EndDate.toISOString().split(".")[0] + "Z";
  }
  if (input.EndDateType !== undefined) {
    entries["EndDateType"] = input.EndDateType;
  }
  if (input.EphemeralStorage !== undefined) {
    entries["EphemeralStorage"] = input.EphemeralStorage;
  }
  if (input.InstanceCount !== undefined) {
    entries["InstanceCount"] = input.InstanceCount;
  }
  if (input.InstanceMatchCriteria !== undefined) {
    entries["InstanceMatchCriteria"] = input.InstanceMatchCriteria;
  }
  if (input.InstancePlatform !== undefined) {
    entries["InstancePlatform"] = input.InstancePlatform;
  }
  if (input.InstanceType !== undefined) {
    entries["InstanceType"] = input.InstanceType;
  }
  if (input.TagSpecifications !== undefined) {
    const memberEntries = serializeAws_ec2TagSpecificationList(
      input.TagSpecifications,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `TagSpecifications.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.Tenancy !== undefined) {
    entries["Tenancy"] = input.Tenancy;
  }
  return entries;
};

const serializeAws_ec2CreateClientVpnEndpointRequest = (
  input: CreateClientVpnEndpointRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.AuthenticationOptions !== undefined) {
    const memberEntries = serializeAws_ec2ClientVpnAuthenticationRequestList(
      input.AuthenticationOptions,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Authentication.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.ClientCidrBlock !== undefined) {
    entries["ClientCidrBlock"] = input.ClientCidrBlock;
  }
  if (input.ClientToken === undefined) {
    input.ClientToken = generateIdempotencyToken();
  }
  if (input.ClientToken !== undefined) {
    entries["ClientToken"] = input.ClientToken;
  }
  if (input.ConnectionLogOptions !== undefined) {
    const memberEntries = serializeAws_ec2ConnectionLogOptions(
      input.ConnectionLogOptions,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `ConnectionLogOptions.${key}`;
      entries[loc] = value;
    });
  }
  if (input.Description !== undefined) {
    entries["Description"] = input.Description;
  }
  if (input.DnsServers !== undefined) {
    const memberEntries = serializeAws_ec2ValueStringList(
      input.DnsServers,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `DnsServers.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.ServerCertificateArn !== undefined) {
    entries["ServerCertificateArn"] = input.ServerCertificateArn;
  }
  if (input.SplitTunnel !== undefined) {
    entries["SplitTunnel"] = input.SplitTunnel;
  }
  if (input.TagSpecifications !== undefined) {
    const memberEntries = serializeAws_ec2TagSpecificationList(
      input.TagSpecifications,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.TransportProtocol !== undefined) {
    entries["TransportProtocol"] = input.TransportProtocol;
  }
  if (input.VpnPort !== undefined) {
    entries["VpnPort"] = input.VpnPort;
  }
  return entries;
};

const serializeAws_ec2CreateClientVpnRouteRequest = (
  input: CreateClientVpnRouteRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.ClientToken === undefined) {
    input.ClientToken = generateIdempotencyToken();
  }
  if (input.ClientToken !== undefined) {
    entries["ClientToken"] = input.ClientToken;
  }
  if (input.ClientVpnEndpointId !== undefined) {
    entries["ClientVpnEndpointId"] = input.ClientVpnEndpointId;
  }
  if (input.Description !== undefined) {
    entries["Description"] = input.Description;
  }
  if (input.DestinationCidrBlock !== undefined) {
    entries["DestinationCidrBlock"] = input.DestinationCidrBlock;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.TargetVpcSubnetId !== undefined) {
    entries["TargetVpcSubnetId"] = input.TargetVpcSubnetId;
  }
  return entries;
};

const serializeAws_ec2CreateCustomerGatewayRequest = (
  input: CreateCustomerGatewayRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.BgpAsn !== undefined) {
    entries["BgpAsn"] = input.BgpAsn;
  }
  if (input.CertificateArn !== undefined) {
    entries["CertificateArn"] = input.CertificateArn;
  }
  if (input.DeviceName !== undefined) {
    entries["DeviceName"] = input.DeviceName;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.PublicIp !== undefined) {
    entries["IpAddress"] = input.PublicIp;
  }
  if (input.Type !== undefined) {
    entries["Type"] = input.Type;
  }
  return entries;
};

const serializeAws_ec2CreateDefaultSubnetRequest = (
  input: CreateDefaultSubnetRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.AvailabilityZone !== undefined) {
    entries["AvailabilityZone"] = input.AvailabilityZone;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  return entries;
};

const serializeAws_ec2CreateDefaultVpcRequest = (
  input: CreateDefaultVpcRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  return entries;
};

const serializeAws_ec2CreateDhcpOptionsRequest = (
  input: CreateDhcpOptionsRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DhcpConfigurations !== undefined) {
    const memberEntries = serializeAws_ec2NewDhcpConfigurationList(
      input.DhcpConfigurations,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `DhcpConfiguration.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  return entries;
};

const serializeAws_ec2CreateEgressOnlyInternetGatewayRequest = (
  input: CreateEgressOnlyInternetGatewayRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.ClientToken !== undefined) {
    entries["ClientToken"] = input.ClientToken;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.VpcId !== undefined) {
    entries["VpcId"] = input.VpcId;
  }
  return entries;
};

const serializeAws_ec2CreateFleetRequest = (
  input: CreateFleetRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.ClientToken !== undefined) {
    entries["ClientToken"] = input.ClientToken;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.ExcessCapacityTerminationPolicy !== undefined) {
    entries["ExcessCapacityTerminationPolicy"] =
      input.ExcessCapacityTerminationPolicy;
  }
  if (input.LaunchTemplateConfigs !== undefined) {
    const memberEntries = serializeAws_ec2FleetLaunchTemplateConfigListRequest(
      input.LaunchTemplateConfigs,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `LaunchTemplateConfigs.${key.substring(
        key.indexOf(".") + 1
      )}`;
      entries[loc] = value;
    });
  }
  if (input.OnDemandOptions !== undefined) {
    const memberEntries = serializeAws_ec2OnDemandOptionsRequest(
      input.OnDemandOptions,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `OnDemandOptions.${key}`;
      entries[loc] = value;
    });
  }
  if (input.ReplaceUnhealthyInstances !== undefined) {
    entries["ReplaceUnhealthyInstances"] = input.ReplaceUnhealthyInstances;
  }
  if (input.SpotOptions !== undefined) {
    const memberEntries = serializeAws_ec2SpotOptionsRequest(
      input.SpotOptions,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `SpotOptions.${key}`;
      entries[loc] = value;
    });
  }
  if (input.TagSpecifications !== undefined) {
    const memberEntries = serializeAws_ec2TagSpecificationList(
      input.TagSpecifications,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.TargetCapacitySpecification !== undefined) {
    const memberEntries = serializeAws_ec2TargetCapacitySpecificationRequest(
      input.TargetCapacitySpecification,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `TargetCapacitySpecification.${key}`;
      entries[loc] = value;
    });
  }
  if (input.TerminateInstancesWithExpiration !== undefined) {
    entries["TerminateInstancesWithExpiration"] =
      input.TerminateInstancesWithExpiration;
  }
  if (input.Type !== undefined) {
    entries["Type"] = input.Type;
  }
  if (input.ValidFrom !== undefined) {
    entries["ValidFrom"] = input.ValidFrom.toISOString().split(".")[0] + "Z";
  }
  if (input.ValidUntil !== undefined) {
    entries["ValidUntil"] = input.ValidUntil.toISOString().split(".")[0] + "Z";
  }
  return entries;
};

const serializeAws_ec2CreateFlowLogsRequest = (
  input: CreateFlowLogsRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.ClientToken !== undefined) {
    entries["ClientToken"] = input.ClientToken;
  }
  if (input.DeliverLogsPermissionArn !== undefined) {
    entries["DeliverLogsPermissionArn"] = input.DeliverLogsPermissionArn;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.LogDestination !== undefined) {
    entries["LogDestination"] = input.LogDestination;
  }
  if (input.LogDestinationType !== undefined) {
    entries["LogDestinationType"] = input.LogDestinationType;
  }
  if (input.LogFormat !== undefined) {
    entries["LogFormat"] = input.LogFormat;
  }
  if (input.LogGroupName !== undefined) {
    entries["LogGroupName"] = input.LogGroupName;
  }
  if (input.ResourceIds !== undefined) {
    const memberEntries = serializeAws_ec2ValueStringList(
      input.ResourceIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `ResourceId.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.ResourceType !== undefined) {
    entries["ResourceType"] = input.ResourceType;
  }
  if (input.TrafficType !== undefined) {
    entries["TrafficType"] = input.TrafficType;
  }
  return entries;
};

const serializeAws_ec2CreateFpgaImageRequest = (
  input: CreateFpgaImageRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.ClientToken !== undefined) {
    entries["ClientToken"] = input.ClientToken;
  }
  if (input.Description !== undefined) {
    entries["Description"] = input.Description;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.InputStorageLocation !== undefined) {
    const memberEntries = serializeAws_ec2StorageLocation(
      input.InputStorageLocation,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `InputStorageLocation.${key}`;
      entries[loc] = value;
    });
  }
  if (input.LogsStorageLocation !== undefined) {
    const memberEntries = serializeAws_ec2StorageLocation(
      input.LogsStorageLocation,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `LogsStorageLocation.${key}`;
      entries[loc] = value;
    });
  }
  if (input.Name !== undefined) {
    entries["Name"] = input.Name;
  }
  if (input.TagSpecifications !== undefined) {
    const memberEntries = serializeAws_ec2TagSpecificationList(
      input.TagSpecifications,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2CreateImageRequest = (
  input: CreateImageRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.BlockDeviceMappings !== undefined) {
    const memberEntries = serializeAws_ec2BlockDeviceMappingRequestList(
      input.BlockDeviceMappings,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `BlockDeviceMapping.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.Description !== undefined) {
    entries["Description"] = input.Description;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.InstanceId !== undefined) {
    entries["InstanceId"] = input.InstanceId;
  }
  if (input.Name !== undefined) {
    entries["Name"] = input.Name;
  }
  if (input.NoReboot !== undefined) {
    entries["NoReboot"] = input.NoReboot;
  }
  return entries;
};

const serializeAws_ec2CreateInstanceExportTaskRequest = (
  input: CreateInstanceExportTaskRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Description !== undefined) {
    entries["Description"] = input.Description;
  }
  if (input.ExportToS3Task !== undefined) {
    const memberEntries = serializeAws_ec2ExportToS3TaskSpecification(
      input.ExportToS3Task,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `ExportToS3.${key}`;
      entries[loc] = value;
    });
  }
  if (input.InstanceId !== undefined) {
    entries["InstanceId"] = input.InstanceId;
  }
  if (input.TargetEnvironment !== undefined) {
    entries["TargetEnvironment"] = input.TargetEnvironment;
  }
  return entries;
};

const serializeAws_ec2CreateInternetGatewayRequest = (
  input: CreateInternetGatewayRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  return entries;
};

const serializeAws_ec2CreateKeyPairRequest = (
  input: CreateKeyPairRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.KeyName !== undefined) {
    entries["KeyName"] = input.KeyName;
  }
  return entries;
};

const serializeAws_ec2CreateLaunchTemplateRequest = (
  input: CreateLaunchTemplateRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.ClientToken !== undefined) {
    entries["ClientToken"] = input.ClientToken;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.LaunchTemplateData !== undefined) {
    const memberEntries = serializeAws_ec2RequestLaunchTemplateData(
      input.LaunchTemplateData,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `LaunchTemplateData.${key}`;
      entries[loc] = value;
    });
  }
  if (input.LaunchTemplateName !== undefined) {
    entries["LaunchTemplateName"] = input.LaunchTemplateName;
  }
  if (input.TagSpecifications !== undefined) {
    const memberEntries = serializeAws_ec2TagSpecificationList(
      input.TagSpecifications,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.VersionDescription !== undefined) {
    entries["VersionDescription"] = input.VersionDescription;
  }
  return entries;
};

const serializeAws_ec2CreateLaunchTemplateVersionRequest = (
  input: CreateLaunchTemplateVersionRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.ClientToken !== undefined) {
    entries["ClientToken"] = input.ClientToken;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.LaunchTemplateData !== undefined) {
    const memberEntries = serializeAws_ec2RequestLaunchTemplateData(
      input.LaunchTemplateData,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `LaunchTemplateData.${key}`;
      entries[loc] = value;
    });
  }
  if (input.LaunchTemplateId !== undefined) {
    entries["LaunchTemplateId"] = input.LaunchTemplateId;
  }
  if (input.LaunchTemplateName !== undefined) {
    entries["LaunchTemplateName"] = input.LaunchTemplateName;
  }
  if (input.SourceVersion !== undefined) {
    entries["SourceVersion"] = input.SourceVersion;
  }
  if (input.VersionDescription !== undefined) {
    entries["VersionDescription"] = input.VersionDescription;
  }
  return entries;
};

const serializeAws_ec2CreateLocalGatewayRouteRequest = (
  input: CreateLocalGatewayRouteRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DestinationCidrBlock !== undefined) {
    entries["DestinationCidrBlock"] = input.DestinationCidrBlock;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.LocalGatewayRouteTableId !== undefined) {
    entries["LocalGatewayRouteTableId"] = input.LocalGatewayRouteTableId;
  }
  if (input.LocalGatewayVirtualInterfaceGroupId !== undefined) {
    entries["LocalGatewayVirtualInterfaceGroupId"] =
      input.LocalGatewayVirtualInterfaceGroupId;
  }
  return entries;
};

const serializeAws_ec2CreateLocalGatewayRouteTableVpcAssociationRequest = (
  input: CreateLocalGatewayRouteTableVpcAssociationRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.LocalGatewayRouteTableId !== undefined) {
    entries["LocalGatewayRouteTableId"] = input.LocalGatewayRouteTableId;
  }
  if (input.VpcId !== undefined) {
    entries["VpcId"] = input.VpcId;
  }
  return entries;
};

const serializeAws_ec2CreateNatGatewayRequest = (
  input: CreateNatGatewayRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.AllocationId !== undefined) {
    entries["AllocationId"] = input.AllocationId;
  }
  if (input.ClientToken !== undefined) {
    entries["ClientToken"] = input.ClientToken;
  }
  if (input.SubnetId !== undefined) {
    entries["SubnetId"] = input.SubnetId;
  }
  return entries;
};

const serializeAws_ec2CreateNetworkAclEntryRequest = (
  input: CreateNetworkAclEntryRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.CidrBlock !== undefined) {
    entries["CidrBlock"] = input.CidrBlock;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Egress !== undefined) {
    entries["Egress"] = input.Egress;
  }
  if (input.IcmpTypeCode !== undefined) {
    const memberEntries = serializeAws_ec2IcmpTypeCode(
      input.IcmpTypeCode,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Icmp.${key}`;
      entries[loc] = value;
    });
  }
  if (input.Ipv6CidrBlock !== undefined) {
    entries["Ipv6CidrBlock"] = input.Ipv6CidrBlock;
  }
  if (input.NetworkAclId !== undefined) {
    entries["NetworkAclId"] = input.NetworkAclId;
  }
  if (input.PortRange !== undefined) {
    const memberEntries = serializeAws_ec2PortRange(input.PortRange, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `PortRange.${key}`;
      entries[loc] = value;
    });
  }
  if (input.Protocol !== undefined) {
    entries["Protocol"] = input.Protocol;
  }
  if (input.RuleAction !== undefined) {
    entries["RuleAction"] = input.RuleAction;
  }
  if (input.RuleNumber !== undefined) {
    entries["RuleNumber"] = input.RuleNumber;
  }
  return entries;
};

const serializeAws_ec2CreateNetworkAclRequest = (
  input: CreateNetworkAclRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.VpcId !== undefined) {
    entries["VpcId"] = input.VpcId;
  }
  return entries;
};

const serializeAws_ec2CreateNetworkInterfacePermissionRequest = (
  input: CreateNetworkInterfacePermissionRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.AwsAccountId !== undefined) {
    entries["AwsAccountId"] = input.AwsAccountId;
  }
  if (input.AwsService !== undefined) {
    entries["AwsService"] = input.AwsService;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.NetworkInterfaceId !== undefined) {
    entries["NetworkInterfaceId"] = input.NetworkInterfaceId;
  }
  if (input.Permission !== undefined) {
    entries["Permission"] = input.Permission;
  }
  return entries;
};

const serializeAws_ec2CreateNetworkInterfaceRequest = (
  input: CreateNetworkInterfaceRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Description !== undefined) {
    entries["Description"] = input.Description;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Groups !== undefined) {
    const memberEntries = serializeAws_ec2SecurityGroupIdStringList(
      input.Groups,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `SecurityGroupId.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.InterfaceType !== undefined) {
    entries["InterfaceType"] = input.InterfaceType;
  }
  if (input.Ipv6AddressCount !== undefined) {
    entries["Ipv6AddressCount"] = input.Ipv6AddressCount;
  }
  if (input.Ipv6Addresses !== undefined) {
    const memberEntries = serializeAws_ec2InstanceIpv6AddressList(
      input.Ipv6Addresses,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Ipv6Addresses.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.PrivateIpAddress !== undefined) {
    entries["PrivateIpAddress"] = input.PrivateIpAddress;
  }
  if (input.PrivateIpAddresses !== undefined) {
    const memberEntries = serializeAws_ec2PrivateIpAddressSpecificationList(
      input.PrivateIpAddresses,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `PrivateIpAddresses.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.SecondaryPrivateIpAddressCount !== undefined) {
    entries["SecondaryPrivateIpAddressCount"] =
      input.SecondaryPrivateIpAddressCount;
  }
  if (input.SubnetId !== undefined) {
    entries["SubnetId"] = input.SubnetId;
  }
  return entries;
};

const serializeAws_ec2CreatePlacementGroupRequest = (
  input: CreatePlacementGroupRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.GroupName !== undefined) {
    entries["GroupName"] = input.GroupName;
  }
  if (input.PartitionCount !== undefined) {
    entries["PartitionCount"] = input.PartitionCount;
  }
  if (input.Strategy !== undefined) {
    entries["Strategy"] = input.Strategy;
  }
  return entries;
};

const serializeAws_ec2CreateReservedInstancesListingRequest = (
  input: CreateReservedInstancesListingRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.ClientToken !== undefined) {
    entries["ClientToken"] = input.ClientToken;
  }
  if (input.InstanceCount !== undefined) {
    entries["InstanceCount"] = input.InstanceCount;
  }
  if (input.PriceSchedules !== undefined) {
    const memberEntries = serializeAws_ec2PriceScheduleSpecificationList(
      input.PriceSchedules,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `PriceSchedules.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.ReservedInstancesId !== undefined) {
    entries["ReservedInstancesId"] = input.ReservedInstancesId;
  }
  return entries;
};

const serializeAws_ec2CreateRouteRequest = (
  input: CreateRouteRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DestinationCidrBlock !== undefined) {
    entries["DestinationCidrBlock"] = input.DestinationCidrBlock;
  }
  if (input.DestinationIpv6CidrBlock !== undefined) {
    entries["DestinationIpv6CidrBlock"] = input.DestinationIpv6CidrBlock;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.EgressOnlyInternetGatewayId !== undefined) {
    entries["EgressOnlyInternetGatewayId"] = input.EgressOnlyInternetGatewayId;
  }
  if (input.GatewayId !== undefined) {
    entries["GatewayId"] = input.GatewayId;
  }
  if (input.InstanceId !== undefined) {
    entries["InstanceId"] = input.InstanceId;
  }
  if (input.LocalGatewayId !== undefined) {
    entries["LocalGatewayId"] = input.LocalGatewayId;
  }
  if (input.NatGatewayId !== undefined) {
    entries["NatGatewayId"] = input.NatGatewayId;
  }
  if (input.NetworkInterfaceId !== undefined) {
    entries["NetworkInterfaceId"] = input.NetworkInterfaceId;
  }
  if (input.RouteTableId !== undefined) {
    entries["RouteTableId"] = input.RouteTableId;
  }
  if (input.TransitGatewayId !== undefined) {
    entries["TransitGatewayId"] = input.TransitGatewayId;
  }
  if (input.VpcPeeringConnectionId !== undefined) {
    entries["VpcPeeringConnectionId"] = input.VpcPeeringConnectionId;
  }
  return entries;
};

const serializeAws_ec2CreateRouteTableRequest = (
  input: CreateRouteTableRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.VpcId !== undefined) {
    entries["VpcId"] = input.VpcId;
  }
  return entries;
};

const serializeAws_ec2CreateSecurityGroupRequest = (
  input: CreateSecurityGroupRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Description !== undefined) {
    entries["GroupDescription"] = input.Description;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.GroupName !== undefined) {
    entries["GroupName"] = input.GroupName;
  }
  if (input.VpcId !== undefined) {
    entries["VpcId"] = input.VpcId;
  }
  return entries;
};

const serializeAws_ec2CreateSnapshotRequest = (
  input: CreateSnapshotRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Description !== undefined) {
    entries["Description"] = input.Description;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.TagSpecifications !== undefined) {
    const memberEntries = serializeAws_ec2TagSpecificationList(
      input.TagSpecifications,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.VolumeId !== undefined) {
    entries["VolumeId"] = input.VolumeId;
  }
  return entries;
};

const serializeAws_ec2CreateSnapshotsRequest = (
  input: CreateSnapshotsRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.CopyTagsFromSource !== undefined) {
    entries["CopyTagsFromSource"] = input.CopyTagsFromSource;
  }
  if (input.Description !== undefined) {
    entries["Description"] = input.Description;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.InstanceSpecification !== undefined) {
    const memberEntries = serializeAws_ec2InstanceSpecification(
      input.InstanceSpecification,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `InstanceSpecification.${key}`;
      entries[loc] = value;
    });
  }
  if (input.TagSpecifications !== undefined) {
    const memberEntries = serializeAws_ec2TagSpecificationList(
      input.TagSpecifications,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2CreateSpotDatafeedSubscriptionRequest = (
  input: CreateSpotDatafeedSubscriptionRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Bucket !== undefined) {
    entries["Bucket"] = input.Bucket;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Prefix !== undefined) {
    entries["Prefix"] = input.Prefix;
  }
  return entries;
};

const serializeAws_ec2CreateSubnetRequest = (
  input: CreateSubnetRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.AvailabilityZone !== undefined) {
    entries["AvailabilityZone"] = input.AvailabilityZone;
  }
  if (input.AvailabilityZoneId !== undefined) {
    entries["AvailabilityZoneId"] = input.AvailabilityZoneId;
  }
  if (input.CidrBlock !== undefined) {
    entries["CidrBlock"] = input.CidrBlock;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Ipv6CidrBlock !== undefined) {
    entries["Ipv6CidrBlock"] = input.Ipv6CidrBlock;
  }
  if (input.OutpostArn !== undefined) {
    entries["OutpostArn"] = input.OutpostArn;
  }
  if (input.VpcId !== undefined) {
    entries["VpcId"] = input.VpcId;
  }
  return entries;
};

const serializeAws_ec2CreateTagsRequest = (
  input: CreateTagsRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Resources !== undefined) {
    const memberEntries = serializeAws_ec2ResourceIdList(
      input.Resources,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `ResourceId.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.Tags !== undefined) {
    const memberEntries = serializeAws_ec2TagList(input.Tags, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Tag.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2CreateTrafficMirrorFilterRequest = (
  input: CreateTrafficMirrorFilterRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.ClientToken === undefined) {
    input.ClientToken = generateIdempotencyToken();
  }
  if (input.ClientToken !== undefined) {
    entries["ClientToken"] = input.ClientToken;
  }
  if (input.Description !== undefined) {
    entries["Description"] = input.Description;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.TagSpecifications !== undefined) {
    const memberEntries = serializeAws_ec2TagSpecificationList(
      input.TagSpecifications,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2CreateTrafficMirrorFilterRuleRequest = (
  input: CreateTrafficMirrorFilterRuleRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.ClientToken === undefined) {
    input.ClientToken = generateIdempotencyToken();
  }
  if (input.ClientToken !== undefined) {
    entries["ClientToken"] = input.ClientToken;
  }
  if (input.Description !== undefined) {
    entries["Description"] = input.Description;
  }
  if (input.DestinationCidrBlock !== undefined) {
    entries["DestinationCidrBlock"] = input.DestinationCidrBlock;
  }
  if (input.DestinationPortRange !== undefined) {
    const memberEntries = serializeAws_ec2TrafficMirrorPortRangeRequest(
      input.DestinationPortRange,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `DestinationPortRange.${key}`;
      entries[loc] = value;
    });
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Protocol !== undefined) {
    entries["Protocol"] = input.Protocol;
  }
  if (input.RuleAction !== undefined) {
    entries["RuleAction"] = input.RuleAction;
  }
  if (input.RuleNumber !== undefined) {
    entries["RuleNumber"] = input.RuleNumber;
  }
  if (input.SourceCidrBlock !== undefined) {
    entries["SourceCidrBlock"] = input.SourceCidrBlock;
  }
  if (input.SourcePortRange !== undefined) {
    const memberEntries = serializeAws_ec2TrafficMirrorPortRangeRequest(
      input.SourcePortRange,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `SourcePortRange.${key}`;
      entries[loc] = value;
    });
  }
  if (input.TrafficDirection !== undefined) {
    entries["TrafficDirection"] = input.TrafficDirection;
  }
  if (input.TrafficMirrorFilterId !== undefined) {
    entries["TrafficMirrorFilterId"] = input.TrafficMirrorFilterId;
  }
  return entries;
};

const serializeAws_ec2CreateTrafficMirrorSessionRequest = (
  input: CreateTrafficMirrorSessionRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.ClientToken === undefined) {
    input.ClientToken = generateIdempotencyToken();
  }
  if (input.ClientToken !== undefined) {
    entries["ClientToken"] = input.ClientToken;
  }
  if (input.Description !== undefined) {
    entries["Description"] = input.Description;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.NetworkInterfaceId !== undefined) {
    entries["NetworkInterfaceId"] = input.NetworkInterfaceId;
  }
  if (input.PacketLength !== undefined) {
    entries["PacketLength"] = input.PacketLength;
  }
  if (input.SessionNumber !== undefined) {
    entries["SessionNumber"] = input.SessionNumber;
  }
  if (input.TagSpecifications !== undefined) {
    const memberEntries = serializeAws_ec2TagSpecificationList(
      input.TagSpecifications,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.TrafficMirrorFilterId !== undefined) {
    entries["TrafficMirrorFilterId"] = input.TrafficMirrorFilterId;
  }
  if (input.TrafficMirrorTargetId !== undefined) {
    entries["TrafficMirrorTargetId"] = input.TrafficMirrorTargetId;
  }
  if (input.VirtualNetworkId !== undefined) {
    entries["VirtualNetworkId"] = input.VirtualNetworkId;
  }
  return entries;
};

const serializeAws_ec2CreateTrafficMirrorTargetRequest = (
  input: CreateTrafficMirrorTargetRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.ClientToken === undefined) {
    input.ClientToken = generateIdempotencyToken();
  }
  if (input.ClientToken !== undefined) {
    entries["ClientToken"] = input.ClientToken;
  }
  if (input.Description !== undefined) {
    entries["Description"] = input.Description;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.NetworkInterfaceId !== undefined) {
    entries["NetworkInterfaceId"] = input.NetworkInterfaceId;
  }
  if (input.NetworkLoadBalancerArn !== undefined) {
    entries["NetworkLoadBalancerArn"] = input.NetworkLoadBalancerArn;
  }
  if (input.TagSpecifications !== undefined) {
    const memberEntries = serializeAws_ec2TagSpecificationList(
      input.TagSpecifications,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2CreateTransitGatewayMulticastDomainRequest = (
  input: CreateTransitGatewayMulticastDomainRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.TagSpecifications !== undefined) {
    const memberEntries = serializeAws_ec2TagSpecificationList(
      input.TagSpecifications,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.TransitGatewayId !== undefined) {
    entries["TransitGatewayId"] = input.TransitGatewayId;
  }
  return entries;
};

const serializeAws_ec2CreateTransitGatewayPeeringAttachmentRequest = (
  input: CreateTransitGatewayPeeringAttachmentRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.PeerAccountId !== undefined) {
    entries["PeerAccountId"] = input.PeerAccountId;
  }
  if (input.PeerRegion !== undefined) {
    entries["PeerRegion"] = input.PeerRegion;
  }
  if (input.PeerTransitGatewayId !== undefined) {
    entries["PeerTransitGatewayId"] = input.PeerTransitGatewayId;
  }
  if (input.TagSpecifications !== undefined) {
    const memberEntries = serializeAws_ec2TagSpecificationList(
      input.TagSpecifications,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.TransitGatewayId !== undefined) {
    entries["TransitGatewayId"] = input.TransitGatewayId;
  }
  return entries;
};

const serializeAws_ec2CreateTransitGatewayRequest = (
  input: CreateTransitGatewayRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Description !== undefined) {
    entries["Description"] = input.Description;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Options !== undefined) {
    const memberEntries = serializeAws_ec2TransitGatewayRequestOptions(
      input.Options,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Options.${key}`;
      entries[loc] = value;
    });
  }
  if (input.TagSpecifications !== undefined) {
    const memberEntries = serializeAws_ec2TagSpecificationList(
      input.TagSpecifications,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2CreateTransitGatewayRouteRequest = (
  input: CreateTransitGatewayRouteRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Blackhole !== undefined) {
    entries["Blackhole"] = input.Blackhole;
  }
  if (input.DestinationCidrBlock !== undefined) {
    entries["DestinationCidrBlock"] = input.DestinationCidrBlock;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.TransitGatewayAttachmentId !== undefined) {
    entries["TransitGatewayAttachmentId"] = input.TransitGatewayAttachmentId;
  }
  if (input.TransitGatewayRouteTableId !== undefined) {
    entries["TransitGatewayRouteTableId"] = input.TransitGatewayRouteTableId;
  }
  return entries;
};

const serializeAws_ec2CreateTransitGatewayRouteTableRequest = (
  input: CreateTransitGatewayRouteTableRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.TagSpecifications !== undefined) {
    const memberEntries = serializeAws_ec2TagSpecificationList(
      input.TagSpecifications,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `TagSpecifications.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.TransitGatewayId !== undefined) {
    entries["TransitGatewayId"] = input.TransitGatewayId;
  }
  return entries;
};

const serializeAws_ec2CreateTransitGatewayVpcAttachmentRequest = (
  input: CreateTransitGatewayVpcAttachmentRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Options !== undefined) {
    const memberEntries = serializeAws_ec2CreateTransitGatewayVpcAttachmentRequestOptions(
      input.Options,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Options.${key}`;
      entries[loc] = value;
    });
  }
  if (input.SubnetIds !== undefined) {
    const memberEntries = serializeAws_ec2ValueStringList(
      input.SubnetIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `SubnetIds.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.TagSpecifications !== undefined) {
    const memberEntries = serializeAws_ec2TagSpecificationList(
      input.TagSpecifications,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `TagSpecifications.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.TransitGatewayId !== undefined) {
    entries["TransitGatewayId"] = input.TransitGatewayId;
  }
  if (input.VpcId !== undefined) {
    entries["VpcId"] = input.VpcId;
  }
  return entries;
};

const serializeAws_ec2CreateTransitGatewayVpcAttachmentRequestOptions = (
  input: CreateTransitGatewayVpcAttachmentRequestOptions,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DnsSupport !== undefined) {
    entries["DnsSupport"] = input.DnsSupport;
  }
  if (input.Ipv6Support !== undefined) {
    entries["Ipv6Support"] = input.Ipv6Support;
  }
  return entries;
};

const serializeAws_ec2CreateVolumePermission = (
  input: CreateVolumePermission,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Group !== undefined) {
    entries["Group"] = input.Group;
  }
  if (input.UserId !== undefined) {
    entries["UserId"] = input.UserId;
  }
  return entries;
};

const serializeAws_ec2CreateVolumePermissionList = (
  input: CreateVolumePermission[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    const memberEntries = serializeAws_ec2CreateVolumePermission(
      entry,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      entries[`Item.${counter}.${key}`] = value;
    });
    counter++;
  }
  return entries;
};

const serializeAws_ec2CreateVolumePermissionModifications = (
  input: CreateVolumePermissionModifications,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Add !== undefined) {
    const memberEntries = serializeAws_ec2CreateVolumePermissionList(
      input.Add,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Add.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.Remove !== undefined) {
    const memberEntries = serializeAws_ec2CreateVolumePermissionList(
      input.Remove,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Remove.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2CreateVolumeRequest = (
  input: CreateVolumeRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.AvailabilityZone !== undefined) {
    entries["AvailabilityZone"] = input.AvailabilityZone;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Encrypted !== undefined) {
    entries["Encrypted"] = input.Encrypted;
  }
  if (input.Iops !== undefined) {
    entries["Iops"] = input.Iops;
  }
  if (input.KmsKeyId !== undefined) {
    entries["KmsKeyId"] = input.KmsKeyId;
  }
  if (input.OutpostArn !== undefined) {
    entries["OutpostArn"] = input.OutpostArn;
  }
  if (input.Size !== undefined) {
    entries["Size"] = input.Size;
  }
  if (input.SnapshotId !== undefined) {
    entries["SnapshotId"] = input.SnapshotId;
  }
  if (input.TagSpecifications !== undefined) {
    const memberEntries = serializeAws_ec2TagSpecificationList(
      input.TagSpecifications,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.VolumeType !== undefined) {
    entries["VolumeType"] = input.VolumeType;
  }
  return entries;
};

const serializeAws_ec2CreateVpcEndpointConnectionNotificationRequest = (
  input: CreateVpcEndpointConnectionNotificationRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.ClientToken !== undefined) {
    entries["ClientToken"] = input.ClientToken;
  }
  if (input.ConnectionEvents !== undefined) {
    const memberEntries = serializeAws_ec2ValueStringList(
      input.ConnectionEvents,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `ConnectionEvents.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.ConnectionNotificationArn !== undefined) {
    entries["ConnectionNotificationArn"] = input.ConnectionNotificationArn;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.ServiceId !== undefined) {
    entries["ServiceId"] = input.ServiceId;
  }
  if (input.VpcEndpointId !== undefined) {
    entries["VpcEndpointId"] = input.VpcEndpointId;
  }
  return entries;
};

const serializeAws_ec2CreateVpcEndpointRequest = (
  input: CreateVpcEndpointRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.ClientToken !== undefined) {
    entries["ClientToken"] = input.ClientToken;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.PolicyDocument !== undefined) {
    entries["PolicyDocument"] = input.PolicyDocument;
  }
  if (input.PrivateDnsEnabled !== undefined) {
    entries["PrivateDnsEnabled"] = input.PrivateDnsEnabled;
  }
  if (input.RouteTableIds !== undefined) {
    const memberEntries = serializeAws_ec2ValueStringList(
      input.RouteTableIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `RouteTableId.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.SecurityGroupIds !== undefined) {
    const memberEntries = serializeAws_ec2ValueStringList(
      input.SecurityGroupIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `SecurityGroupId.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.ServiceName !== undefined) {
    entries["ServiceName"] = input.ServiceName;
  }
  if (input.SubnetIds !== undefined) {
    const memberEntries = serializeAws_ec2ValueStringList(
      input.SubnetIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `SubnetId.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.VpcEndpointType !== undefined) {
    entries["VpcEndpointType"] = input.VpcEndpointType;
  }
  if (input.VpcId !== undefined) {
    entries["VpcId"] = input.VpcId;
  }
  return entries;
};

const serializeAws_ec2CreateVpcEndpointServiceConfigurationRequest = (
  input: CreateVpcEndpointServiceConfigurationRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.AcceptanceRequired !== undefined) {
    entries["AcceptanceRequired"] = input.AcceptanceRequired;
  }
  if (input.ClientToken !== undefined) {
    entries["ClientToken"] = input.ClientToken;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.NetworkLoadBalancerArns !== undefined) {
    const memberEntries = serializeAws_ec2ValueStringList(
      input.NetworkLoadBalancerArns,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `NetworkLoadBalancerArn.${key.substring(
        key.indexOf(".") + 1
      )}`;
      entries[loc] = value;
    });
  }
  if (input.PrivateDnsName !== undefined) {
    entries["PrivateDnsName"] = input.PrivateDnsName;
  }
  return entries;
};

const serializeAws_ec2CreateVpcPeeringConnectionRequest = (
  input: CreateVpcPeeringConnectionRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.PeerOwnerId !== undefined) {
    entries["PeerOwnerId"] = input.PeerOwnerId;
  }
  if (input.PeerRegion !== undefined) {
    entries["PeerRegion"] = input.PeerRegion;
  }
  if (input.PeerVpcId !== undefined) {
    entries["PeerVpcId"] = input.PeerVpcId;
  }
  if (input.VpcId !== undefined) {
    entries["VpcId"] = input.VpcId;
  }
  return entries;
};

const serializeAws_ec2CreateVpcRequest = (
  input: CreateVpcRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.AmazonProvidedIpv6CidrBlock !== undefined) {
    entries["AmazonProvidedIpv6CidrBlock"] = input.AmazonProvidedIpv6CidrBlock;
  }
  if (input.CidrBlock !== undefined) {
    entries["CidrBlock"] = input.CidrBlock;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.InstanceTenancy !== undefined) {
    entries["InstanceTenancy"] = input.InstanceTenancy;
  }
  if (input.Ipv6CidrBlock !== undefined) {
    entries["Ipv6CidrBlock"] = input.Ipv6CidrBlock;
  }
  if (input.Ipv6CidrBlockNetworkBorderGroup !== undefined) {
    entries["Ipv6CidrBlockNetworkBorderGroup"] =
      input.Ipv6CidrBlockNetworkBorderGroup;
  }
  if (input.Ipv6Pool !== undefined) {
    entries["Ipv6Pool"] = input.Ipv6Pool;
  }
  return entries;
};

const serializeAws_ec2CreateVpnConnectionRequest = (
  input: CreateVpnConnectionRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.CustomerGatewayId !== undefined) {
    entries["CustomerGatewayId"] = input.CustomerGatewayId;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Options !== undefined) {
    const memberEntries = serializeAws_ec2VpnConnectionOptionsSpecification(
      input.Options,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Options.${key}`;
      entries[loc] = value;
    });
  }
  if (input.TransitGatewayId !== undefined) {
    entries["TransitGatewayId"] = input.TransitGatewayId;
  }
  if (input.Type !== undefined) {
    entries["Type"] = input.Type;
  }
  if (input.VpnGatewayId !== undefined) {
    entries["VpnGatewayId"] = input.VpnGatewayId;
  }
  return entries;
};

const serializeAws_ec2CreateVpnConnectionRouteRequest = (
  input: CreateVpnConnectionRouteRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DestinationCidrBlock !== undefined) {
    entries["DestinationCidrBlock"] = input.DestinationCidrBlock;
  }
  if (input.VpnConnectionId !== undefined) {
    entries["VpnConnectionId"] = input.VpnConnectionId;
  }
  return entries;
};

const serializeAws_ec2CreateVpnGatewayRequest = (
  input: CreateVpnGatewayRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.AmazonSideAsn !== undefined) {
    entries["AmazonSideAsn"] = input.AmazonSideAsn;
  }
  if (input.AvailabilityZone !== undefined) {
    entries["AvailabilityZone"] = input.AvailabilityZone;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Type !== undefined) {
    entries["Type"] = input.Type;
  }
  return entries;
};

const serializeAws_ec2CreditSpecificationRequest = (
  input: CreditSpecificationRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.CpuCredits !== undefined) {
    entries["CpuCredits"] = input.CpuCredits;
  }
  return entries;
};

const serializeAws_ec2CustomerGatewayIdStringList = (
  input: string[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    entries[`CustomerGatewayId.${counter}`] = entry;
    counter++;
  }
  return entries;
};

const serializeAws_ec2DeleteClientVpnEndpointRequest = (
  input: DeleteClientVpnEndpointRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.ClientVpnEndpointId !== undefined) {
    entries["ClientVpnEndpointId"] = input.ClientVpnEndpointId;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  return entries;
};

const serializeAws_ec2DeleteClientVpnRouteRequest = (
  input: DeleteClientVpnRouteRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.ClientVpnEndpointId !== undefined) {
    entries["ClientVpnEndpointId"] = input.ClientVpnEndpointId;
  }
  if (input.DestinationCidrBlock !== undefined) {
    entries["DestinationCidrBlock"] = input.DestinationCidrBlock;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.TargetVpcSubnetId !== undefined) {
    entries["TargetVpcSubnetId"] = input.TargetVpcSubnetId;
  }
  return entries;
};

const serializeAws_ec2DeleteCustomerGatewayRequest = (
  input: DeleteCustomerGatewayRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.CustomerGatewayId !== undefined) {
    entries["CustomerGatewayId"] = input.CustomerGatewayId;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  return entries;
};

const serializeAws_ec2DeleteDhcpOptionsRequest = (
  input: DeleteDhcpOptionsRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DhcpOptionsId !== undefined) {
    entries["DhcpOptionsId"] = input.DhcpOptionsId;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  return entries;
};

const serializeAws_ec2DeleteEgressOnlyInternetGatewayRequest = (
  input: DeleteEgressOnlyInternetGatewayRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.EgressOnlyInternetGatewayId !== undefined) {
    entries["EgressOnlyInternetGatewayId"] = input.EgressOnlyInternetGatewayId;
  }
  return entries;
};

const serializeAws_ec2DeleteFleetsRequest = (
  input: DeleteFleetsRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.FleetIds !== undefined) {
    const memberEntries = serializeAws_ec2FleetIdSet(input.FleetIds, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `FleetId.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.TerminateInstances !== undefined) {
    entries["TerminateInstances"] = input.TerminateInstances;
  }
  return entries;
};

const serializeAws_ec2DeleteFlowLogsRequest = (
  input: DeleteFlowLogsRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.FlowLogIds !== undefined) {
    const memberEntries = serializeAws_ec2ValueStringList(
      input.FlowLogIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `FlowLogId.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2DeleteFpgaImageRequest = (
  input: DeleteFpgaImageRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.FpgaImageId !== undefined) {
    entries["FpgaImageId"] = input.FpgaImageId;
  }
  return entries;
};

const serializeAws_ec2DeleteInternetGatewayRequest = (
  input: DeleteInternetGatewayRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.InternetGatewayId !== undefined) {
    entries["InternetGatewayId"] = input.InternetGatewayId;
  }
  return entries;
};

const serializeAws_ec2DeleteKeyPairRequest = (
  input: DeleteKeyPairRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.KeyName !== undefined) {
    entries["KeyName"] = input.KeyName;
  }
  return entries;
};

const serializeAws_ec2DeleteLaunchTemplateRequest = (
  input: DeleteLaunchTemplateRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.LaunchTemplateId !== undefined) {
    entries["LaunchTemplateId"] = input.LaunchTemplateId;
  }
  if (input.LaunchTemplateName !== undefined) {
    entries["LaunchTemplateName"] = input.LaunchTemplateName;
  }
  return entries;
};

const serializeAws_ec2DeleteLaunchTemplateVersionsRequest = (
  input: DeleteLaunchTemplateVersionsRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.LaunchTemplateId !== undefined) {
    entries["LaunchTemplateId"] = input.LaunchTemplateId;
  }
  if (input.LaunchTemplateName !== undefined) {
    entries["LaunchTemplateName"] = input.LaunchTemplateName;
  }
  if (input.Versions !== undefined) {
    const memberEntries = serializeAws_ec2VersionStringList(
      input.Versions,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `LaunchTemplateVersion.${key.substring(
        key.indexOf(".") + 1
      )}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2DeleteLocalGatewayRouteRequest = (
  input: DeleteLocalGatewayRouteRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DestinationCidrBlock !== undefined) {
    entries["DestinationCidrBlock"] = input.DestinationCidrBlock;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.LocalGatewayRouteTableId !== undefined) {
    entries["LocalGatewayRouteTableId"] = input.LocalGatewayRouteTableId;
  }
  return entries;
};

const serializeAws_ec2DeleteLocalGatewayRouteTableVpcAssociationRequest = (
  input: DeleteLocalGatewayRouteTableVpcAssociationRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.LocalGatewayRouteTableVpcAssociationId !== undefined) {
    entries["LocalGatewayRouteTableVpcAssociationId"] =
      input.LocalGatewayRouteTableVpcAssociationId;
  }
  return entries;
};

const serializeAws_ec2DeleteNatGatewayRequest = (
  input: DeleteNatGatewayRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.NatGatewayId !== undefined) {
    entries["NatGatewayId"] = input.NatGatewayId;
  }
  return entries;
};

const serializeAws_ec2DeleteNetworkAclEntryRequest = (
  input: DeleteNetworkAclEntryRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Egress !== undefined) {
    entries["Egress"] = input.Egress;
  }
  if (input.NetworkAclId !== undefined) {
    entries["NetworkAclId"] = input.NetworkAclId;
  }
  if (input.RuleNumber !== undefined) {
    entries["RuleNumber"] = input.RuleNumber;
  }
  return entries;
};

const serializeAws_ec2DeleteNetworkAclRequest = (
  input: DeleteNetworkAclRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.NetworkAclId !== undefined) {
    entries["NetworkAclId"] = input.NetworkAclId;
  }
  return entries;
};

const serializeAws_ec2DeleteNetworkInterfacePermissionRequest = (
  input: DeleteNetworkInterfacePermissionRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Force !== undefined) {
    entries["Force"] = input.Force;
  }
  if (input.NetworkInterfacePermissionId !== undefined) {
    entries["NetworkInterfacePermissionId"] =
      input.NetworkInterfacePermissionId;
  }
  return entries;
};

const serializeAws_ec2DeleteNetworkInterfaceRequest = (
  input: DeleteNetworkInterfaceRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.NetworkInterfaceId !== undefined) {
    entries["NetworkInterfaceId"] = input.NetworkInterfaceId;
  }
  return entries;
};

const serializeAws_ec2DeletePlacementGroupRequest = (
  input: DeletePlacementGroupRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.GroupName !== undefined) {
    entries["GroupName"] = input.GroupName;
  }
  return entries;
};

const serializeAws_ec2DeleteQueuedReservedInstancesIdList = (
  input: string[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    entries[`Item.${counter}`] = entry;
    counter++;
  }
  return entries;
};

const serializeAws_ec2DeleteQueuedReservedInstancesRequest = (
  input: DeleteQueuedReservedInstancesRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.ReservedInstancesIds !== undefined) {
    const memberEntries = serializeAws_ec2DeleteQueuedReservedInstancesIdList(
      input.ReservedInstancesIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `ReservedInstancesId.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2DeleteRouteRequest = (
  input: DeleteRouteRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DestinationCidrBlock !== undefined) {
    entries["DestinationCidrBlock"] = input.DestinationCidrBlock;
  }
  if (input.DestinationIpv6CidrBlock !== undefined) {
    entries["DestinationIpv6CidrBlock"] = input.DestinationIpv6CidrBlock;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.RouteTableId !== undefined) {
    entries["RouteTableId"] = input.RouteTableId;
  }
  return entries;
};

const serializeAws_ec2DeleteRouteTableRequest = (
  input: DeleteRouteTableRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.RouteTableId !== undefined) {
    entries["RouteTableId"] = input.RouteTableId;
  }
  return entries;
};

const serializeAws_ec2DeleteSecurityGroupRequest = (
  input: DeleteSecurityGroupRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.GroupId !== undefined) {
    entries["GroupId"] = input.GroupId;
  }
  if (input.GroupName !== undefined) {
    entries["GroupName"] = input.GroupName;
  }
  return entries;
};

const serializeAws_ec2DeleteSnapshotRequest = (
  input: DeleteSnapshotRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.SnapshotId !== undefined) {
    entries["SnapshotId"] = input.SnapshotId;
  }
  return entries;
};

const serializeAws_ec2DeleteSpotDatafeedSubscriptionRequest = (
  input: DeleteSpotDatafeedSubscriptionRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  return entries;
};

const serializeAws_ec2DeleteSubnetRequest = (
  input: DeleteSubnetRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.SubnetId !== undefined) {
    entries["SubnetId"] = input.SubnetId;
  }
  return entries;
};

const serializeAws_ec2DeleteTagsRequest = (
  input: DeleteTagsRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Resources !== undefined) {
    const memberEntries = serializeAws_ec2ResourceIdList(
      input.Resources,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `ResourceId.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.Tags !== undefined) {
    const memberEntries = serializeAws_ec2TagList(input.Tags, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Tag.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2DeleteTrafficMirrorFilterRequest = (
  input: DeleteTrafficMirrorFilterRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.TrafficMirrorFilterId !== undefined) {
    entries["TrafficMirrorFilterId"] = input.TrafficMirrorFilterId;
  }
  return entries;
};

const serializeAws_ec2DeleteTrafficMirrorFilterRuleRequest = (
  input: DeleteTrafficMirrorFilterRuleRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.TrafficMirrorFilterRuleId !== undefined) {
    entries["TrafficMirrorFilterRuleId"] = input.TrafficMirrorFilterRuleId;
  }
  return entries;
};

const serializeAws_ec2DeleteTrafficMirrorSessionRequest = (
  input: DeleteTrafficMirrorSessionRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.TrafficMirrorSessionId !== undefined) {
    entries["TrafficMirrorSessionId"] = input.TrafficMirrorSessionId;
  }
  return entries;
};

const serializeAws_ec2DeleteTrafficMirrorTargetRequest = (
  input: DeleteTrafficMirrorTargetRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.TrafficMirrorTargetId !== undefined) {
    entries["TrafficMirrorTargetId"] = input.TrafficMirrorTargetId;
  }
  return entries;
};

const serializeAws_ec2DeleteTransitGatewayMulticastDomainRequest = (
  input: DeleteTransitGatewayMulticastDomainRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.TransitGatewayMulticastDomainId !== undefined) {
    entries["TransitGatewayMulticastDomainId"] =
      input.TransitGatewayMulticastDomainId;
  }
  return entries;
};

const serializeAws_ec2DeleteTransitGatewayPeeringAttachmentRequest = (
  input: DeleteTransitGatewayPeeringAttachmentRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.TransitGatewayAttachmentId !== undefined) {
    entries["TransitGatewayAttachmentId"] = input.TransitGatewayAttachmentId;
  }
  return entries;
};

const serializeAws_ec2DeleteTransitGatewayRequest = (
  input: DeleteTransitGatewayRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.TransitGatewayId !== undefined) {
    entries["TransitGatewayId"] = input.TransitGatewayId;
  }
  return entries;
};

const serializeAws_ec2DeleteTransitGatewayRouteRequest = (
  input: DeleteTransitGatewayRouteRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DestinationCidrBlock !== undefined) {
    entries["DestinationCidrBlock"] = input.DestinationCidrBlock;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.TransitGatewayRouteTableId !== undefined) {
    entries["TransitGatewayRouteTableId"] = input.TransitGatewayRouteTableId;
  }
  return entries;
};

const serializeAws_ec2DeleteTransitGatewayRouteTableRequest = (
  input: DeleteTransitGatewayRouteTableRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.TransitGatewayRouteTableId !== undefined) {
    entries["TransitGatewayRouteTableId"] = input.TransitGatewayRouteTableId;
  }
  return entries;
};

const serializeAws_ec2DeleteTransitGatewayVpcAttachmentRequest = (
  input: DeleteTransitGatewayVpcAttachmentRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.TransitGatewayAttachmentId !== undefined) {
    entries["TransitGatewayAttachmentId"] = input.TransitGatewayAttachmentId;
  }
  return entries;
};

const serializeAws_ec2DeleteVolumeRequest = (
  input: DeleteVolumeRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.VolumeId !== undefined) {
    entries["VolumeId"] = input.VolumeId;
  }
  return entries;
};

const serializeAws_ec2DeleteVpcEndpointConnectionNotificationsRequest = (
  input: DeleteVpcEndpointConnectionNotificationsRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.ConnectionNotificationIds !== undefined) {
    const memberEntries = serializeAws_ec2ValueStringList(
      input.ConnectionNotificationIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `ConnectionNotificationId.${key.substring(
        key.indexOf(".") + 1
      )}`;
      entries[loc] = value;
    });
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  return entries;
};

const serializeAws_ec2DeleteVpcEndpointServiceConfigurationsRequest = (
  input: DeleteVpcEndpointServiceConfigurationsRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.ServiceIds !== undefined) {
    const memberEntries = serializeAws_ec2ValueStringList(
      input.ServiceIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `ServiceId.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2DeleteVpcEndpointsRequest = (
  input: DeleteVpcEndpointsRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.VpcEndpointIds !== undefined) {
    const memberEntries = serializeAws_ec2ValueStringList(
      input.VpcEndpointIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `VpcEndpointId.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2DeleteVpcPeeringConnectionRequest = (
  input: DeleteVpcPeeringConnectionRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.VpcPeeringConnectionId !== undefined) {
    entries["VpcPeeringConnectionId"] = input.VpcPeeringConnectionId;
  }
  return entries;
};

const serializeAws_ec2DeleteVpcRequest = (
  input: DeleteVpcRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.VpcId !== undefined) {
    entries["VpcId"] = input.VpcId;
  }
  return entries;
};

const serializeAws_ec2DeleteVpnConnectionRequest = (
  input: DeleteVpnConnectionRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.VpnConnectionId !== undefined) {
    entries["VpnConnectionId"] = input.VpnConnectionId;
  }
  return entries;
};

const serializeAws_ec2DeleteVpnConnectionRouteRequest = (
  input: DeleteVpnConnectionRouteRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DestinationCidrBlock !== undefined) {
    entries["DestinationCidrBlock"] = input.DestinationCidrBlock;
  }
  if (input.VpnConnectionId !== undefined) {
    entries["VpnConnectionId"] = input.VpnConnectionId;
  }
  return entries;
};

const serializeAws_ec2DeleteVpnGatewayRequest = (
  input: DeleteVpnGatewayRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.VpnGatewayId !== undefined) {
    entries["VpnGatewayId"] = input.VpnGatewayId;
  }
  return entries;
};

const serializeAws_ec2DeprovisionByoipCidrRequest = (
  input: DeprovisionByoipCidrRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Cidr !== undefined) {
    entries["Cidr"] = input.Cidr;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  return entries;
};

const serializeAws_ec2DeregisterImageRequest = (
  input: DeregisterImageRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.ImageId !== undefined) {
    entries["ImageId"] = input.ImageId;
  }
  return entries;
};

const serializeAws_ec2DeregisterTransitGatewayMulticastGroupMembersRequest = (
  input: DeregisterTransitGatewayMulticastGroupMembersRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.GroupIpAddress !== undefined) {
    entries["GroupIpAddress"] = input.GroupIpAddress;
  }
  if (input.NetworkInterfaceIds !== undefined) {
    const memberEntries = serializeAws_ec2ValueStringList(
      input.NetworkInterfaceIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `NetworkInterfaceIds.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.TransitGatewayMulticastDomainId !== undefined) {
    entries["TransitGatewayMulticastDomainId"] =
      input.TransitGatewayMulticastDomainId;
  }
  return entries;
};

const serializeAws_ec2DeregisterTransitGatewayMulticastGroupSourcesRequest = (
  input: DeregisterTransitGatewayMulticastGroupSourcesRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.GroupIpAddress !== undefined) {
    entries["GroupIpAddress"] = input.GroupIpAddress;
  }
  if (input.NetworkInterfaceIds !== undefined) {
    const memberEntries = serializeAws_ec2ValueStringList(
      input.NetworkInterfaceIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `NetworkInterfaceIds.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.TransitGatewayMulticastDomainId !== undefined) {
    entries["TransitGatewayMulticastDomainId"] =
      input.TransitGatewayMulticastDomainId;
  }
  return entries;
};

const serializeAws_ec2DescribeAccountAttributesRequest = (
  input: DescribeAccountAttributesRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.AttributeNames !== undefined) {
    const memberEntries = serializeAws_ec2AccountAttributeNameStringList(
      input.AttributeNames,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `AttributeName.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  return entries;
};

const serializeAws_ec2DescribeAddressesRequest = (
  input: DescribeAddressesRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.AllocationIds !== undefined) {
    const memberEntries = serializeAws_ec2AllocationIdList(
      input.AllocationIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `AllocationId.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.PublicIps !== undefined) {
    const memberEntries = serializeAws_ec2PublicIpStringList(
      input.PublicIps,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `PublicIp.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2DescribeAggregateIdFormatRequest = (
  input: DescribeAggregateIdFormatRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  return entries;
};

const serializeAws_ec2DescribeAvailabilityZonesRequest = (
  input: DescribeAvailabilityZonesRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.AllAvailabilityZones !== undefined) {
    entries["AllAvailabilityZones"] = input.AllAvailabilityZones;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.ZoneIds !== undefined) {
    const memberEntries = serializeAws_ec2ZoneIdStringList(
      input.ZoneIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `ZoneId.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.ZoneNames !== undefined) {
    const memberEntries = serializeAws_ec2ZoneNameStringList(
      input.ZoneNames,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `ZoneName.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2DescribeBundleTasksRequest = (
  input: DescribeBundleTasksRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.BundleIds !== undefined) {
    const memberEntries = serializeAws_ec2BundleIdStringList(
      input.BundleIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `BundleId.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2DescribeByoipCidrsRequest = (
  input: DescribeByoipCidrsRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.MaxResults !== undefined) {
    entries["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    entries["NextToken"] = input.NextToken;
  }
  return entries;
};

const serializeAws_ec2DescribeCapacityReservationsRequest = (
  input: DescribeCapacityReservationsRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.CapacityReservationIds !== undefined) {
    const memberEntries = serializeAws_ec2CapacityReservationIdSet(
      input.CapacityReservationIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `CapacityReservationId.${key.substring(
        key.indexOf(".") + 1
      )}`;
      entries[loc] = value;
    });
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.MaxResults !== undefined) {
    entries["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    entries["NextToken"] = input.NextToken;
  }
  return entries;
};

const serializeAws_ec2DescribeClassicLinkInstancesRequest = (
  input: DescribeClassicLinkInstancesRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.InstanceIds !== undefined) {
    const memberEntries = serializeAws_ec2InstanceIdStringList(
      input.InstanceIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `InstanceId.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.MaxResults !== undefined) {
    entries["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    entries["NextToken"] = input.NextToken;
  }
  return entries;
};

const serializeAws_ec2DescribeClientVpnAuthorizationRulesRequest = (
  input: DescribeClientVpnAuthorizationRulesRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.ClientVpnEndpointId !== undefined) {
    entries["ClientVpnEndpointId"] = input.ClientVpnEndpointId;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.MaxResults !== undefined) {
    entries["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    entries["NextToken"] = input.NextToken;
  }
  return entries;
};

const serializeAws_ec2DescribeClientVpnConnectionsRequest = (
  input: DescribeClientVpnConnectionsRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.ClientVpnEndpointId !== undefined) {
    entries["ClientVpnEndpointId"] = input.ClientVpnEndpointId;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.MaxResults !== undefined) {
    entries["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    entries["NextToken"] = input.NextToken;
  }
  return entries;
};

const serializeAws_ec2DescribeClientVpnEndpointsRequest = (
  input: DescribeClientVpnEndpointsRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.ClientVpnEndpointIds !== undefined) {
    const memberEntries = serializeAws_ec2ValueStringList(
      input.ClientVpnEndpointIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `ClientVpnEndpointId.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.MaxResults !== undefined) {
    entries["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    entries["NextToken"] = input.NextToken;
  }
  return entries;
};

const serializeAws_ec2DescribeClientVpnRoutesRequest = (
  input: DescribeClientVpnRoutesRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.ClientVpnEndpointId !== undefined) {
    entries["ClientVpnEndpointId"] = input.ClientVpnEndpointId;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.MaxResults !== undefined) {
    entries["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    entries["NextToken"] = input.NextToken;
  }
  return entries;
};

const serializeAws_ec2DescribeClientVpnTargetNetworksRequest = (
  input: DescribeClientVpnTargetNetworksRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.AssociationIds !== undefined) {
    const memberEntries = serializeAws_ec2ValueStringList(
      input.AssociationIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `AssociationIds.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.ClientVpnEndpointId !== undefined) {
    entries["ClientVpnEndpointId"] = input.ClientVpnEndpointId;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.MaxResults !== undefined) {
    entries["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    entries["NextToken"] = input.NextToken;
  }
  return entries;
};

const serializeAws_ec2DescribeCoipPoolsRequest = (
  input: DescribeCoipPoolsRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.MaxResults !== undefined) {
    entries["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    entries["NextToken"] = input.NextToken;
  }
  if (input.PoolIds !== undefined) {
    const memberEntries = serializeAws_ec2CoipPoolIdSet(input.PoolIds, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `PoolId.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2DescribeConversionTasksRequest = (
  input: DescribeConversionTasksRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.ConversionTaskIds !== undefined) {
    const memberEntries = serializeAws_ec2ConversionIdStringList(
      input.ConversionTaskIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `ConversionTaskId.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  return entries;
};

const serializeAws_ec2DescribeCustomerGatewaysRequest = (
  input: DescribeCustomerGatewaysRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.CustomerGatewayIds !== undefined) {
    const memberEntries = serializeAws_ec2CustomerGatewayIdStringList(
      input.CustomerGatewayIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `CustomerGatewayId.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2DescribeDhcpOptionsRequest = (
  input: DescribeDhcpOptionsRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DhcpOptionsIds !== undefined) {
    const memberEntries = serializeAws_ec2DhcpOptionsIdStringList(
      input.DhcpOptionsIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `DhcpOptionsId.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.MaxResults !== undefined) {
    entries["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    entries["NextToken"] = input.NextToken;
  }
  return entries;
};

const serializeAws_ec2DescribeEgressOnlyInternetGatewaysRequest = (
  input: DescribeEgressOnlyInternetGatewaysRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.EgressOnlyInternetGatewayIds !== undefined) {
    const memberEntries = serializeAws_ec2EgressOnlyInternetGatewayIdList(
      input.EgressOnlyInternetGatewayIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `EgressOnlyInternetGatewayId.${key.substring(
        key.indexOf(".") + 1
      )}`;
      entries[loc] = value;
    });
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.MaxResults !== undefined) {
    entries["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    entries["NextToken"] = input.NextToken;
  }
  return entries;
};

const serializeAws_ec2DescribeElasticGpusRequest = (
  input: DescribeElasticGpusRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.ElasticGpuIds !== undefined) {
    const memberEntries = serializeAws_ec2ElasticGpuIdSet(
      input.ElasticGpuIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `ElasticGpuId.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.MaxResults !== undefined) {
    entries["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    entries["NextToken"] = input.NextToken;
  }
  return entries;
};

const serializeAws_ec2DescribeExportImageTasksRequest = (
  input: DescribeExportImageTasksRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.ExportImageTaskIds !== undefined) {
    const memberEntries = serializeAws_ec2ExportImageTaskIdList(
      input.ExportImageTaskIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `ExportImageTaskId.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.MaxResults !== undefined) {
    entries["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    entries["NextToken"] = input.NextToken;
  }
  return entries;
};

const serializeAws_ec2DescribeExportTasksRequest = (
  input: DescribeExportTasksRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.ExportTaskIds !== undefined) {
    const memberEntries = serializeAws_ec2ExportTaskIdStringList(
      input.ExportTaskIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `ExportTaskId.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2DescribeFastSnapshotRestoresRequest = (
  input: DescribeFastSnapshotRestoresRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.MaxResults !== undefined) {
    entries["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    entries["NextToken"] = input.NextToken;
  }
  return entries;
};

const serializeAws_ec2DescribeFleetHistoryRequest = (
  input: DescribeFleetHistoryRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.EventType !== undefined) {
    entries["EventType"] = input.EventType;
  }
  if (input.FleetId !== undefined) {
    entries["FleetId"] = input.FleetId;
  }
  if (input.MaxResults !== undefined) {
    entries["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    entries["NextToken"] = input.NextToken;
  }
  if (input.StartTime !== undefined) {
    entries["StartTime"] = input.StartTime.toISOString().split(".")[0] + "Z";
  }
  return entries;
};

const serializeAws_ec2DescribeFleetInstancesRequest = (
  input: DescribeFleetInstancesRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.FleetId !== undefined) {
    entries["FleetId"] = input.FleetId;
  }
  if (input.MaxResults !== undefined) {
    entries["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    entries["NextToken"] = input.NextToken;
  }
  return entries;
};

const serializeAws_ec2DescribeFleetsRequest = (
  input: DescribeFleetsRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.FleetIds !== undefined) {
    const memberEntries = serializeAws_ec2FleetIdSet(input.FleetIds, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `FleetId.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.MaxResults !== undefined) {
    entries["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    entries["NextToken"] = input.NextToken;
  }
  return entries;
};

const serializeAws_ec2DescribeFlowLogsRequest = (
  input: DescribeFlowLogsRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Filter !== undefined) {
    const memberEntries = serializeAws_ec2FilterList(input.Filter, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.FlowLogIds !== undefined) {
    const memberEntries = serializeAws_ec2ValueStringList(
      input.FlowLogIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `FlowLogId.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.MaxResults !== undefined) {
    entries["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    entries["NextToken"] = input.NextToken;
  }
  return entries;
};

const serializeAws_ec2DescribeFpgaImageAttributeRequest = (
  input: DescribeFpgaImageAttributeRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Attribute !== undefined) {
    entries["Attribute"] = input.Attribute;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.FpgaImageId !== undefined) {
    entries["FpgaImageId"] = input.FpgaImageId;
  }
  return entries;
};

const serializeAws_ec2DescribeFpgaImagesRequest = (
  input: DescribeFpgaImagesRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.FpgaImageIds !== undefined) {
    const memberEntries = serializeAws_ec2FpgaImageIdList(
      input.FpgaImageIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `FpgaImageId.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.MaxResults !== undefined) {
    entries["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    entries["NextToken"] = input.NextToken;
  }
  if (input.Owners !== undefined) {
    const memberEntries = serializeAws_ec2OwnerStringList(
      input.Owners,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Owner.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2DescribeHostReservationOfferingsRequest = (
  input: DescribeHostReservationOfferingsRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Filter !== undefined) {
    const memberEntries = serializeAws_ec2FilterList(input.Filter, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.MaxDuration !== undefined) {
    entries["MaxDuration"] = input.MaxDuration;
  }
  if (input.MaxResults !== undefined) {
    entries["MaxResults"] = input.MaxResults;
  }
  if (input.MinDuration !== undefined) {
    entries["MinDuration"] = input.MinDuration;
  }
  if (input.NextToken !== undefined) {
    entries["NextToken"] = input.NextToken;
  }
  if (input.OfferingId !== undefined) {
    entries["OfferingId"] = input.OfferingId;
  }
  return entries;
};

const serializeAws_ec2DescribeHostReservationsRequest = (
  input: DescribeHostReservationsRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Filter !== undefined) {
    const memberEntries = serializeAws_ec2FilterList(input.Filter, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.HostReservationIdSet !== undefined) {
    const memberEntries = serializeAws_ec2HostReservationIdSet(
      input.HostReservationIdSet,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `HostReservationIdSet.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.MaxResults !== undefined) {
    entries["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    entries["NextToken"] = input.NextToken;
  }
  return entries;
};

const serializeAws_ec2DescribeHostsRequest = (
  input: DescribeHostsRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Filter !== undefined) {
    const memberEntries = serializeAws_ec2FilterList(input.Filter, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.HostIds !== undefined) {
    const memberEntries = serializeAws_ec2RequestHostIdList(
      input.HostIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `HostId.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.MaxResults !== undefined) {
    entries["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    entries["NextToken"] = input.NextToken;
  }
  return entries;
};

const serializeAws_ec2DescribeIamInstanceProfileAssociationsRequest = (
  input: DescribeIamInstanceProfileAssociationsRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.AssociationIds !== undefined) {
    const memberEntries = serializeAws_ec2AssociationIdList(
      input.AssociationIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `AssociationId.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.MaxResults !== undefined) {
    entries["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    entries["NextToken"] = input.NextToken;
  }
  return entries;
};

const serializeAws_ec2DescribeIdentityIdFormatRequest = (
  input: DescribeIdentityIdFormatRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.PrincipalArn !== undefined) {
    entries["PrincipalArn"] = input.PrincipalArn;
  }
  if (input.Resource !== undefined) {
    entries["Resource"] = input.Resource;
  }
  return entries;
};

const serializeAws_ec2DescribeIdFormatRequest = (
  input: DescribeIdFormatRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Resource !== undefined) {
    entries["Resource"] = input.Resource;
  }
  return entries;
};

const serializeAws_ec2DescribeImageAttributeRequest = (
  input: DescribeImageAttributeRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Attribute !== undefined) {
    entries["Attribute"] = input.Attribute;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.ImageId !== undefined) {
    entries["ImageId"] = input.ImageId;
  }
  return entries;
};

const serializeAws_ec2DescribeImagesRequest = (
  input: DescribeImagesRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.ExecutableUsers !== undefined) {
    const memberEntries = serializeAws_ec2ExecutableByStringList(
      input.ExecutableUsers,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `ExecutableBy.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.ImageIds !== undefined) {
    const memberEntries = serializeAws_ec2ImageIdStringList(
      input.ImageIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `ImageId.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.Owners !== undefined) {
    const memberEntries = serializeAws_ec2OwnerStringList(
      input.Owners,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Owner.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2DescribeImportImageTasksRequest = (
  input: DescribeImportImageTasksRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Filters.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.ImportTaskIds !== undefined) {
    const memberEntries = serializeAws_ec2ImportTaskIdList(
      input.ImportTaskIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `ImportTaskId.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.MaxResults !== undefined) {
    entries["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    entries["NextToken"] = input.NextToken;
  }
  return entries;
};

const serializeAws_ec2DescribeImportSnapshotTasksRequest = (
  input: DescribeImportSnapshotTasksRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Filters.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.ImportTaskIds !== undefined) {
    const memberEntries = serializeAws_ec2ImportTaskIdList(
      input.ImportTaskIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `ImportTaskId.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.MaxResults !== undefined) {
    entries["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    entries["NextToken"] = input.NextToken;
  }
  return entries;
};

const serializeAws_ec2DescribeInstanceAttributeRequest = (
  input: DescribeInstanceAttributeRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Attribute !== undefined) {
    entries["Attribute"] = input.Attribute;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.InstanceId !== undefined) {
    entries["InstanceId"] = input.InstanceId;
  }
  return entries;
};

const serializeAws_ec2DescribeInstanceCreditSpecificationsRequest = (
  input: DescribeInstanceCreditSpecificationsRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.InstanceIds !== undefined) {
    const memberEntries = serializeAws_ec2InstanceIdStringList(
      input.InstanceIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `InstanceId.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.MaxResults !== undefined) {
    entries["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    entries["NextToken"] = input.NextToken;
  }
  return entries;
};

const serializeAws_ec2DescribeInstancesRequest = (
  input: DescribeInstancesRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.InstanceIds !== undefined) {
    const memberEntries = serializeAws_ec2InstanceIdStringList(
      input.InstanceIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `InstanceId.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.MaxResults !== undefined) {
    entries["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    entries["NextToken"] = input.NextToken;
  }
  return entries;
};

const serializeAws_ec2DescribeInstanceStatusRequest = (
  input: DescribeInstanceStatusRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.IncludeAllInstances !== undefined) {
    entries["IncludeAllInstances"] = input.IncludeAllInstances;
  }
  if (input.InstanceIds !== undefined) {
    const memberEntries = serializeAws_ec2InstanceIdStringList(
      input.InstanceIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `InstanceId.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.MaxResults !== undefined) {
    entries["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    entries["NextToken"] = input.NextToken;
  }
  return entries;
};

const serializeAws_ec2DescribeInstanceTypeOfferingsRequest = (
  input: DescribeInstanceTypeOfferingsRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.LocationType !== undefined) {
    entries["LocationType"] = input.LocationType;
  }
  if (input.MaxResults !== undefined) {
    entries["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    entries["NextToken"] = input.NextToken;
  }
  return entries;
};

const serializeAws_ec2DescribeInstanceTypesRequest = (
  input: DescribeInstanceTypesRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.InstanceTypes !== undefined) {
    const memberEntries = serializeAws_ec2RequestInstanceTypeList(
      input.InstanceTypes,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `InstanceType.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.MaxResults !== undefined) {
    entries["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    entries["NextToken"] = input.NextToken;
  }
  return entries;
};

const serializeAws_ec2DescribeInternetGatewaysRequest = (
  input: DescribeInternetGatewaysRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.InternetGatewayIds !== undefined) {
    const memberEntries = serializeAws_ec2ValueStringList(
      input.InternetGatewayIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `InternetGatewayId.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.MaxResults !== undefined) {
    entries["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    entries["NextToken"] = input.NextToken;
  }
  return entries;
};

const serializeAws_ec2DescribeIpv6PoolsRequest = (
  input: DescribeIpv6PoolsRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.MaxResults !== undefined) {
    entries["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    entries["NextToken"] = input.NextToken;
  }
  if (input.PoolIds !== undefined) {
    const memberEntries = serializeAws_ec2ValueStringList(
      input.PoolIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `PoolId.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2DescribeKeyPairsRequest = (
  input: DescribeKeyPairsRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.KeyNames !== undefined) {
    const memberEntries = serializeAws_ec2KeyNameStringList(
      input.KeyNames,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `KeyName.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.KeyPairIds !== undefined) {
    const memberEntries = serializeAws_ec2KeyPairIdStringList(
      input.KeyPairIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `KeyPairId.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2DescribeLaunchTemplatesRequest = (
  input: DescribeLaunchTemplatesRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.LaunchTemplateIds !== undefined) {
    const memberEntries = serializeAws_ec2ValueStringList(
      input.LaunchTemplateIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `LaunchTemplateId.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.LaunchTemplateNames !== undefined) {
    const memberEntries = serializeAws_ec2LaunchTemplateNameStringList(
      input.LaunchTemplateNames,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `LaunchTemplateName.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.MaxResults !== undefined) {
    entries["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    entries["NextToken"] = input.NextToken;
  }
  return entries;
};

const serializeAws_ec2DescribeLaunchTemplateVersionsRequest = (
  input: DescribeLaunchTemplateVersionsRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.LaunchTemplateId !== undefined) {
    entries["LaunchTemplateId"] = input.LaunchTemplateId;
  }
  if (input.LaunchTemplateName !== undefined) {
    entries["LaunchTemplateName"] = input.LaunchTemplateName;
  }
  if (input.MaxResults !== undefined) {
    entries["MaxResults"] = input.MaxResults;
  }
  if (input.MaxVersion !== undefined) {
    entries["MaxVersion"] = input.MaxVersion;
  }
  if (input.MinVersion !== undefined) {
    entries["MinVersion"] = input.MinVersion;
  }
  if (input.NextToken !== undefined) {
    entries["NextToken"] = input.NextToken;
  }
  if (input.Versions !== undefined) {
    const memberEntries = serializeAws_ec2VersionStringList(
      input.Versions,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `LaunchTemplateVersion.${key.substring(
        key.indexOf(".") + 1
      )}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2DescribeLocalGatewayRouteTablesRequest = (
  input: DescribeLocalGatewayRouteTablesRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.LocalGatewayRouteTableIds !== undefined) {
    const memberEntries = serializeAws_ec2LocalGatewayRouteTableIdSet(
      input.LocalGatewayRouteTableIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `LocalGatewayRouteTableId.${key.substring(
        key.indexOf(".") + 1
      )}`;
      entries[loc] = value;
    });
  }
  if (input.MaxResults !== undefined) {
    entries["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    entries["NextToken"] = input.NextToken;
  }
  return entries;
};

const serializeAws_ec2DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsRequest = (
  input: DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (
    input.LocalGatewayRouteTableVirtualInterfaceGroupAssociationIds !==
    undefined
  ) {
    const memberEntries = serializeAws_ec2LocalGatewayRouteTableVirtualInterfaceGroupAssociationIdSet(
      input.LocalGatewayRouteTableVirtualInterfaceGroupAssociationIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `LocalGatewayRouteTableVirtualInterfaceGroupAssociationId.${key.substring(
        key.indexOf(".") + 1
      )}`;
      entries[loc] = value;
    });
  }
  if (input.MaxResults !== undefined) {
    entries["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    entries["NextToken"] = input.NextToken;
  }
  return entries;
};

const serializeAws_ec2DescribeLocalGatewayRouteTableVpcAssociationsRequest = (
  input: DescribeLocalGatewayRouteTableVpcAssociationsRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.LocalGatewayRouteTableVpcAssociationIds !== undefined) {
    const memberEntries = serializeAws_ec2LocalGatewayRouteTableVpcAssociationIdSet(
      input.LocalGatewayRouteTableVpcAssociationIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `LocalGatewayRouteTableVpcAssociationId.${key.substring(
        key.indexOf(".") + 1
      )}`;
      entries[loc] = value;
    });
  }
  if (input.MaxResults !== undefined) {
    entries["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    entries["NextToken"] = input.NextToken;
  }
  return entries;
};

const serializeAws_ec2DescribeLocalGatewaysRequest = (
  input: DescribeLocalGatewaysRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.LocalGatewayIds !== undefined) {
    const memberEntries = serializeAws_ec2LocalGatewayIdSet(
      input.LocalGatewayIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `LocalGatewayId.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.MaxResults !== undefined) {
    entries["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    entries["NextToken"] = input.NextToken;
  }
  return entries;
};

const serializeAws_ec2DescribeLocalGatewayVirtualInterfaceGroupsRequest = (
  input: DescribeLocalGatewayVirtualInterfaceGroupsRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.LocalGatewayVirtualInterfaceGroupIds !== undefined) {
    const memberEntries = serializeAws_ec2LocalGatewayVirtualInterfaceGroupIdSet(
      input.LocalGatewayVirtualInterfaceGroupIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `LocalGatewayVirtualInterfaceGroupId.${key.substring(
        key.indexOf(".") + 1
      )}`;
      entries[loc] = value;
    });
  }
  if (input.MaxResults !== undefined) {
    entries["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    entries["NextToken"] = input.NextToken;
  }
  return entries;
};

const serializeAws_ec2DescribeLocalGatewayVirtualInterfacesRequest = (
  input: DescribeLocalGatewayVirtualInterfacesRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.LocalGatewayVirtualInterfaceIds !== undefined) {
    const memberEntries = serializeAws_ec2LocalGatewayVirtualInterfaceIdSet(
      input.LocalGatewayVirtualInterfaceIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `LocalGatewayVirtualInterfaceId.${key.substring(
        key.indexOf(".") + 1
      )}`;
      entries[loc] = value;
    });
  }
  if (input.MaxResults !== undefined) {
    entries["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    entries["NextToken"] = input.NextToken;
  }
  return entries;
};

const serializeAws_ec2DescribeMovingAddressesRequest = (
  input: DescribeMovingAddressesRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.MaxResults !== undefined) {
    entries["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    entries["NextToken"] = input.NextToken;
  }
  if (input.PublicIps !== undefined) {
    const memberEntries = serializeAws_ec2ValueStringList(
      input.PublicIps,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `PublicIp.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2DescribeNatGatewaysRequest = (
  input: DescribeNatGatewaysRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Filter !== undefined) {
    const memberEntries = serializeAws_ec2FilterList(input.Filter, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.MaxResults !== undefined) {
    entries["MaxResults"] = input.MaxResults;
  }
  if (input.NatGatewayIds !== undefined) {
    const memberEntries = serializeAws_ec2ValueStringList(
      input.NatGatewayIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `NatGatewayId.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.NextToken !== undefined) {
    entries["NextToken"] = input.NextToken;
  }
  return entries;
};

const serializeAws_ec2DescribeNetworkAclsRequest = (
  input: DescribeNetworkAclsRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.MaxResults !== undefined) {
    entries["MaxResults"] = input.MaxResults;
  }
  if (input.NetworkAclIds !== undefined) {
    const memberEntries = serializeAws_ec2ValueStringList(
      input.NetworkAclIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `NetworkAclId.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.NextToken !== undefined) {
    entries["NextToken"] = input.NextToken;
  }
  return entries;
};

const serializeAws_ec2DescribeNetworkInterfaceAttributeRequest = (
  input: DescribeNetworkInterfaceAttributeRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Attribute !== undefined) {
    entries["Attribute"] = input.Attribute;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.NetworkInterfaceId !== undefined) {
    entries["NetworkInterfaceId"] = input.NetworkInterfaceId;
  }
  return entries;
};

const serializeAws_ec2DescribeNetworkInterfacePermissionsRequest = (
  input: DescribeNetworkInterfacePermissionsRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.MaxResults !== undefined) {
    entries["MaxResults"] = input.MaxResults;
  }
  if (input.NetworkInterfacePermissionIds !== undefined) {
    const memberEntries = serializeAws_ec2NetworkInterfacePermissionIdList(
      input.NetworkInterfacePermissionIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `NetworkInterfacePermissionId.${key.substring(
        key.indexOf(".") + 1
      )}`;
      entries[loc] = value;
    });
  }
  if (input.NextToken !== undefined) {
    entries["NextToken"] = input.NextToken;
  }
  return entries;
};

const serializeAws_ec2DescribeNetworkInterfacesRequest = (
  input: DescribeNetworkInterfacesRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.MaxResults !== undefined) {
    entries["MaxResults"] = input.MaxResults;
  }
  if (input.NetworkInterfaceIds !== undefined) {
    const memberEntries = serializeAws_ec2NetworkInterfaceIdList(
      input.NetworkInterfaceIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `NetworkInterfaceId.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.NextToken !== undefined) {
    entries["NextToken"] = input.NextToken;
  }
  return entries;
};

const serializeAws_ec2DescribePlacementGroupsRequest = (
  input: DescribePlacementGroupsRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.GroupIds !== undefined) {
    const memberEntries = serializeAws_ec2PlacementGroupIdStringList(
      input.GroupIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `GroupId.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.GroupNames !== undefined) {
    const memberEntries = serializeAws_ec2PlacementGroupStringList(
      input.GroupNames,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `GroupName.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2DescribePrefixListsRequest = (
  input: DescribePrefixListsRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.MaxResults !== undefined) {
    entries["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    entries["NextToken"] = input.NextToken;
  }
  if (input.PrefixListIds !== undefined) {
    const memberEntries = serializeAws_ec2ValueStringList(
      input.PrefixListIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `PrefixListId.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2DescribePrincipalIdFormatRequest = (
  input: DescribePrincipalIdFormatRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.MaxResults !== undefined) {
    entries["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    entries["NextToken"] = input.NextToken;
  }
  if (input.Resources !== undefined) {
    const memberEntries = serializeAws_ec2ResourceList(
      input.Resources,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Resource.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2DescribePublicIpv4PoolsRequest = (
  input: DescribePublicIpv4PoolsRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.MaxResults !== undefined) {
    entries["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    entries["NextToken"] = input.NextToken;
  }
  if (input.PoolIds !== undefined) {
    const memberEntries = serializeAws_ec2ValueStringList(
      input.PoolIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `PoolId.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2DescribeRegionsRequest = (
  input: DescribeRegionsRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.AllRegions !== undefined) {
    entries["AllRegions"] = input.AllRegions;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.RegionNames !== undefined) {
    const memberEntries = serializeAws_ec2RegionNameStringList(
      input.RegionNames,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `RegionName.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2DescribeReservedInstancesListingsRequest = (
  input: DescribeReservedInstancesListingsRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.ReservedInstancesId !== undefined) {
    entries["ReservedInstancesId"] = input.ReservedInstancesId;
  }
  if (input.ReservedInstancesListingId !== undefined) {
    entries["ReservedInstancesListingId"] = input.ReservedInstancesListingId;
  }
  return entries;
};

const serializeAws_ec2DescribeReservedInstancesModificationsRequest = (
  input: DescribeReservedInstancesModificationsRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.NextToken !== undefined) {
    entries["NextToken"] = input.NextToken;
  }
  if (input.ReservedInstancesModificationIds !== undefined) {
    const memberEntries = serializeAws_ec2ReservedInstancesModificationIdStringList(
      input.ReservedInstancesModificationIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `ReservedInstancesModificationId.${key.substring(
        key.indexOf(".") + 1
      )}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2DescribeReservedInstancesOfferingsRequest = (
  input: DescribeReservedInstancesOfferingsRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.AvailabilityZone !== undefined) {
    entries["AvailabilityZone"] = input.AvailabilityZone;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.IncludeMarketplace !== undefined) {
    entries["IncludeMarketplace"] = input.IncludeMarketplace;
  }
  if (input.InstanceTenancy !== undefined) {
    entries["InstanceTenancy"] = input.InstanceTenancy;
  }
  if (input.InstanceType !== undefined) {
    entries["InstanceType"] = input.InstanceType;
  }
  if (input.MaxDuration !== undefined) {
    entries["MaxDuration"] = input.MaxDuration;
  }
  if (input.MaxInstanceCount !== undefined) {
    entries["MaxInstanceCount"] = input.MaxInstanceCount;
  }
  if (input.MaxResults !== undefined) {
    entries["MaxResults"] = input.MaxResults;
  }
  if (input.MinDuration !== undefined) {
    entries["MinDuration"] = input.MinDuration;
  }
  if (input.NextToken !== undefined) {
    entries["NextToken"] = input.NextToken;
  }
  if (input.OfferingClass !== undefined) {
    entries["OfferingClass"] = input.OfferingClass;
  }
  if (input.OfferingType !== undefined) {
    entries["OfferingType"] = input.OfferingType;
  }
  if (input.ProductDescription !== undefined) {
    entries["ProductDescription"] = input.ProductDescription;
  }
  if (input.ReservedInstancesOfferingIds !== undefined) {
    const memberEntries = serializeAws_ec2ReservedInstancesOfferingIdStringList(
      input.ReservedInstancesOfferingIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `ReservedInstancesOfferingId.${key.substring(
        key.indexOf(".") + 1
      )}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2DescribeReservedInstancesRequest = (
  input: DescribeReservedInstancesRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.OfferingClass !== undefined) {
    entries["OfferingClass"] = input.OfferingClass;
  }
  if (input.OfferingType !== undefined) {
    entries["OfferingType"] = input.OfferingType;
  }
  if (input.ReservedInstancesIds !== undefined) {
    const memberEntries = serializeAws_ec2ReservedInstancesIdStringList(
      input.ReservedInstancesIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `ReservedInstancesId.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2DescribeRouteTablesRequest = (
  input: DescribeRouteTablesRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.MaxResults !== undefined) {
    entries["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    entries["NextToken"] = input.NextToken;
  }
  if (input.RouteTableIds !== undefined) {
    const memberEntries = serializeAws_ec2ValueStringList(
      input.RouteTableIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `RouteTableId.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2DescribeScheduledInstanceAvailabilityRequest = (
  input: DescribeScheduledInstanceAvailabilityRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.FirstSlotStartTimeRange !== undefined) {
    const memberEntries = serializeAws_ec2SlotDateTimeRangeRequest(
      input.FirstSlotStartTimeRange,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `FirstSlotStartTimeRange.${key}`;
      entries[loc] = value;
    });
  }
  if (input.MaxResults !== undefined) {
    entries["MaxResults"] = input.MaxResults;
  }
  if (input.MaxSlotDurationInHours !== undefined) {
    entries["MaxSlotDurationInHours"] = input.MaxSlotDurationInHours;
  }
  if (input.MinSlotDurationInHours !== undefined) {
    entries["MinSlotDurationInHours"] = input.MinSlotDurationInHours;
  }
  if (input.NextToken !== undefined) {
    entries["NextToken"] = input.NextToken;
  }
  if (input.Recurrence !== undefined) {
    const memberEntries = serializeAws_ec2ScheduledInstanceRecurrenceRequest(
      input.Recurrence,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Recurrence.${key}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2DescribeScheduledInstancesRequest = (
  input: DescribeScheduledInstancesRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.MaxResults !== undefined) {
    entries["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    entries["NextToken"] = input.NextToken;
  }
  if (input.ScheduledInstanceIds !== undefined) {
    const memberEntries = serializeAws_ec2ScheduledInstanceIdRequestSet(
      input.ScheduledInstanceIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `ScheduledInstanceId.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.SlotStartTimeRange !== undefined) {
    const memberEntries = serializeAws_ec2SlotStartTimeRangeRequest(
      input.SlotStartTimeRange,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `SlotStartTimeRange.${key}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2DescribeSecurityGroupReferencesRequest = (
  input: DescribeSecurityGroupReferencesRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.GroupId !== undefined) {
    const memberEntries = serializeAws_ec2GroupIds(input.GroupId, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `GroupId.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2DescribeSecurityGroupsRequest = (
  input: DescribeSecurityGroupsRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.GroupIds !== undefined) {
    const memberEntries = serializeAws_ec2GroupIdStringList(
      input.GroupIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `GroupId.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.GroupNames !== undefined) {
    const memberEntries = serializeAws_ec2GroupNameStringList(
      input.GroupNames,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `GroupName.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.MaxResults !== undefined) {
    entries["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    entries["NextToken"] = input.NextToken;
  }
  return entries;
};

const serializeAws_ec2DescribeSnapshotAttributeRequest = (
  input: DescribeSnapshotAttributeRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Attribute !== undefined) {
    entries["Attribute"] = input.Attribute;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.SnapshotId !== undefined) {
    entries["SnapshotId"] = input.SnapshotId;
  }
  return entries;
};

const serializeAws_ec2DescribeSnapshotsRequest = (
  input: DescribeSnapshotsRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.MaxResults !== undefined) {
    entries["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    entries["NextToken"] = input.NextToken;
  }
  if (input.OwnerIds !== undefined) {
    const memberEntries = serializeAws_ec2OwnerStringList(
      input.OwnerIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Owner.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.RestorableByUserIds !== undefined) {
    const memberEntries = serializeAws_ec2RestorableByStringList(
      input.RestorableByUserIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `RestorableBy.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.SnapshotIds !== undefined) {
    const memberEntries = serializeAws_ec2SnapshotIdStringList(
      input.SnapshotIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `SnapshotId.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2DescribeSpotDatafeedSubscriptionRequest = (
  input: DescribeSpotDatafeedSubscriptionRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  return entries;
};

const serializeAws_ec2DescribeSpotFleetInstancesRequest = (
  input: DescribeSpotFleetInstancesRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.MaxResults !== undefined) {
    entries["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    entries["NextToken"] = input.NextToken;
  }
  if (input.SpotFleetRequestId !== undefined) {
    entries["SpotFleetRequestId"] = input.SpotFleetRequestId;
  }
  return entries;
};

const serializeAws_ec2DescribeSpotFleetRequestHistoryRequest = (
  input: DescribeSpotFleetRequestHistoryRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.EventType !== undefined) {
    entries["EventType"] = input.EventType;
  }
  if (input.MaxResults !== undefined) {
    entries["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    entries["NextToken"] = input.NextToken;
  }
  if (input.SpotFleetRequestId !== undefined) {
    entries["SpotFleetRequestId"] = input.SpotFleetRequestId;
  }
  if (input.StartTime !== undefined) {
    entries["StartTime"] = input.StartTime.toISOString().split(".")[0] + "Z";
  }
  return entries;
};

const serializeAws_ec2DescribeSpotFleetRequestsRequest = (
  input: DescribeSpotFleetRequestsRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.MaxResults !== undefined) {
    entries["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    entries["NextToken"] = input.NextToken;
  }
  if (input.SpotFleetRequestIds !== undefined) {
    const memberEntries = serializeAws_ec2ValueStringList(
      input.SpotFleetRequestIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `SpotFleetRequestId.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2DescribeSpotInstanceRequestsRequest = (
  input: DescribeSpotInstanceRequestsRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.MaxResults !== undefined) {
    entries["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    entries["NextToken"] = input.NextToken;
  }
  if (input.SpotInstanceRequestIds !== undefined) {
    const memberEntries = serializeAws_ec2SpotInstanceRequestIdList(
      input.SpotInstanceRequestIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `SpotInstanceRequestId.${key.substring(
        key.indexOf(".") + 1
      )}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2DescribeSpotPriceHistoryRequest = (
  input: DescribeSpotPriceHistoryRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.AvailabilityZone !== undefined) {
    entries["AvailabilityZone"] = input.AvailabilityZone;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.EndTime !== undefined) {
    entries["EndTime"] = input.EndTime.toISOString().split(".")[0] + "Z";
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.InstanceTypes !== undefined) {
    const memberEntries = serializeAws_ec2InstanceTypeList(
      input.InstanceTypes,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `InstanceType.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.MaxResults !== undefined) {
    entries["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    entries["NextToken"] = input.NextToken;
  }
  if (input.ProductDescriptions !== undefined) {
    const memberEntries = serializeAws_ec2ProductDescriptionList(
      input.ProductDescriptions,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `ProductDescription.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.StartTime !== undefined) {
    entries["StartTime"] = input.StartTime.toISOString().split(".")[0] + "Z";
  }
  return entries;
};

const serializeAws_ec2DescribeStaleSecurityGroupsRequest = (
  input: DescribeStaleSecurityGroupsRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.MaxResults !== undefined) {
    entries["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    entries["NextToken"] = input.NextToken;
  }
  if (input.VpcId !== undefined) {
    entries["VpcId"] = input.VpcId;
  }
  return entries;
};

const serializeAws_ec2DescribeSubnetsRequest = (
  input: DescribeSubnetsRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.MaxResults !== undefined) {
    entries["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    entries["NextToken"] = input.NextToken;
  }
  if (input.SubnetIds !== undefined) {
    const memberEntries = serializeAws_ec2SubnetIdStringList(
      input.SubnetIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `SubnetId.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2DescribeTagsRequest = (
  input: DescribeTagsRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.MaxResults !== undefined) {
    entries["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    entries["NextToken"] = input.NextToken;
  }
  return entries;
};

const serializeAws_ec2DescribeTrafficMirrorFiltersRequest = (
  input: DescribeTrafficMirrorFiltersRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.MaxResults !== undefined) {
    entries["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    entries["NextToken"] = input.NextToken;
  }
  if (input.TrafficMirrorFilterIds !== undefined) {
    const memberEntries = serializeAws_ec2ValueStringList(
      input.TrafficMirrorFilterIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `TrafficMirrorFilterId.${key.substring(
        key.indexOf(".") + 1
      )}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2DescribeTrafficMirrorSessionsRequest = (
  input: DescribeTrafficMirrorSessionsRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.MaxResults !== undefined) {
    entries["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    entries["NextToken"] = input.NextToken;
  }
  if (input.TrafficMirrorSessionIds !== undefined) {
    const memberEntries = serializeAws_ec2ValueStringList(
      input.TrafficMirrorSessionIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `TrafficMirrorSessionId.${key.substring(
        key.indexOf(".") + 1
      )}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2DescribeTrafficMirrorTargetsRequest = (
  input: DescribeTrafficMirrorTargetsRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.MaxResults !== undefined) {
    entries["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    entries["NextToken"] = input.NextToken;
  }
  if (input.TrafficMirrorTargetIds !== undefined) {
    const memberEntries = serializeAws_ec2ValueStringList(
      input.TrafficMirrorTargetIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `TrafficMirrorTargetId.${key.substring(
        key.indexOf(".") + 1
      )}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2DescribeTransitGatewayAttachmentsRequest = (
  input: DescribeTransitGatewayAttachmentsRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.MaxResults !== undefined) {
    entries["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    entries["NextToken"] = input.NextToken;
  }
  if (input.TransitGatewayAttachmentIds !== undefined) {
    const memberEntries = serializeAws_ec2TransitGatewayAttachmentIdStringList(
      input.TransitGatewayAttachmentIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `TransitGatewayAttachmentIds.${key.substring(
        key.indexOf(".") + 1
      )}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2DescribeTransitGatewayMulticastDomainsRequest = (
  input: DescribeTransitGatewayMulticastDomainsRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.MaxResults !== undefined) {
    entries["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    entries["NextToken"] = input.NextToken;
  }
  if (input.TransitGatewayMulticastDomainIds !== undefined) {
    const memberEntries = serializeAws_ec2TransitGatewayMulticastDomainIdStringList(
      input.TransitGatewayMulticastDomainIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `TransitGatewayMulticastDomainIds.${key.substring(
        key.indexOf(".") + 1
      )}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2DescribeTransitGatewayPeeringAttachmentsRequest = (
  input: DescribeTransitGatewayPeeringAttachmentsRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.MaxResults !== undefined) {
    entries["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    entries["NextToken"] = input.NextToken;
  }
  if (input.TransitGatewayAttachmentIds !== undefined) {
    const memberEntries = serializeAws_ec2TransitGatewayAttachmentIdStringList(
      input.TransitGatewayAttachmentIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `TransitGatewayAttachmentIds.${key.substring(
        key.indexOf(".") + 1
      )}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2DescribeTransitGatewayRouteTablesRequest = (
  input: DescribeTransitGatewayRouteTablesRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.MaxResults !== undefined) {
    entries["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    entries["NextToken"] = input.NextToken;
  }
  if (input.TransitGatewayRouteTableIds !== undefined) {
    const memberEntries = serializeAws_ec2TransitGatewayRouteTableIdStringList(
      input.TransitGatewayRouteTableIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `TransitGatewayRouteTableIds.${key.substring(
        key.indexOf(".") + 1
      )}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2DescribeTransitGatewaysRequest = (
  input: DescribeTransitGatewaysRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.MaxResults !== undefined) {
    entries["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    entries["NextToken"] = input.NextToken;
  }
  if (input.TransitGatewayIds !== undefined) {
    const memberEntries = serializeAws_ec2TransitGatewayIdStringList(
      input.TransitGatewayIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `TransitGatewayIds.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2DescribeTransitGatewayVpcAttachmentsRequest = (
  input: DescribeTransitGatewayVpcAttachmentsRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.MaxResults !== undefined) {
    entries["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    entries["NextToken"] = input.NextToken;
  }
  if (input.TransitGatewayAttachmentIds !== undefined) {
    const memberEntries = serializeAws_ec2TransitGatewayAttachmentIdStringList(
      input.TransitGatewayAttachmentIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `TransitGatewayAttachmentIds.${key.substring(
        key.indexOf(".") + 1
      )}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2DescribeVolumeAttributeRequest = (
  input: DescribeVolumeAttributeRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Attribute !== undefined) {
    entries["Attribute"] = input.Attribute;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.VolumeId !== undefined) {
    entries["VolumeId"] = input.VolumeId;
  }
  return entries;
};

const serializeAws_ec2DescribeVolumesModificationsRequest = (
  input: DescribeVolumesModificationsRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.MaxResults !== undefined) {
    entries["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    entries["NextToken"] = input.NextToken;
  }
  if (input.VolumeIds !== undefined) {
    const memberEntries = serializeAws_ec2VolumeIdStringList(
      input.VolumeIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `VolumeId.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2DescribeVolumesRequest = (
  input: DescribeVolumesRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.MaxResults !== undefined) {
    entries["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    entries["NextToken"] = input.NextToken;
  }
  if (input.VolumeIds !== undefined) {
    const memberEntries = serializeAws_ec2VolumeIdStringList(
      input.VolumeIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `VolumeId.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2DescribeVolumeStatusRequest = (
  input: DescribeVolumeStatusRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.MaxResults !== undefined) {
    entries["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    entries["NextToken"] = input.NextToken;
  }
  if (input.VolumeIds !== undefined) {
    const memberEntries = serializeAws_ec2VolumeIdStringList(
      input.VolumeIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `VolumeId.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2DescribeVpcAttributeRequest = (
  input: DescribeVpcAttributeRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Attribute !== undefined) {
    entries["Attribute"] = input.Attribute;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.VpcId !== undefined) {
    entries["VpcId"] = input.VpcId;
  }
  return entries;
};

const serializeAws_ec2DescribeVpcClassicLinkDnsSupportRequest = (
  input: DescribeVpcClassicLinkDnsSupportRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.MaxResults !== undefined) {
    entries["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    entries["NextToken"] = input.NextToken;
  }
  if (input.VpcIds !== undefined) {
    const memberEntries = serializeAws_ec2VpcClassicLinkIdList(
      input.VpcIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `VpcIds.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2DescribeVpcClassicLinkRequest = (
  input: DescribeVpcClassicLinkRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.VpcIds !== undefined) {
    const memberEntries = serializeAws_ec2VpcClassicLinkIdList(
      input.VpcIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `VpcId.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2DescribeVpcEndpointConnectionNotificationsRequest = (
  input: DescribeVpcEndpointConnectionNotificationsRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.ConnectionNotificationId !== undefined) {
    entries["ConnectionNotificationId"] = input.ConnectionNotificationId;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.MaxResults !== undefined) {
    entries["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    entries["NextToken"] = input.NextToken;
  }
  return entries;
};

const serializeAws_ec2DescribeVpcEndpointConnectionsRequest = (
  input: DescribeVpcEndpointConnectionsRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.MaxResults !== undefined) {
    entries["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    entries["NextToken"] = input.NextToken;
  }
  return entries;
};

const serializeAws_ec2DescribeVpcEndpointServiceConfigurationsRequest = (
  input: DescribeVpcEndpointServiceConfigurationsRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.MaxResults !== undefined) {
    entries["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    entries["NextToken"] = input.NextToken;
  }
  if (input.ServiceIds !== undefined) {
    const memberEntries = serializeAws_ec2ValueStringList(
      input.ServiceIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `ServiceId.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2DescribeVpcEndpointServicePermissionsRequest = (
  input: DescribeVpcEndpointServicePermissionsRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.MaxResults !== undefined) {
    entries["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    entries["NextToken"] = input.NextToken;
  }
  if (input.ServiceId !== undefined) {
    entries["ServiceId"] = input.ServiceId;
  }
  return entries;
};

const serializeAws_ec2DescribeVpcEndpointServicesRequest = (
  input: DescribeVpcEndpointServicesRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.MaxResults !== undefined) {
    entries["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    entries["NextToken"] = input.NextToken;
  }
  if (input.ServiceNames !== undefined) {
    const memberEntries = serializeAws_ec2ValueStringList(
      input.ServiceNames,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `ServiceName.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2DescribeVpcEndpointsRequest = (
  input: DescribeVpcEndpointsRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.MaxResults !== undefined) {
    entries["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    entries["NextToken"] = input.NextToken;
  }
  if (input.VpcEndpointIds !== undefined) {
    const memberEntries = serializeAws_ec2ValueStringList(
      input.VpcEndpointIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `VpcEndpointId.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2DescribeVpcPeeringConnectionsRequest = (
  input: DescribeVpcPeeringConnectionsRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.MaxResults !== undefined) {
    entries["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    entries["NextToken"] = input.NextToken;
  }
  if (input.VpcPeeringConnectionIds !== undefined) {
    const memberEntries = serializeAws_ec2ValueStringList(
      input.VpcPeeringConnectionIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `VpcPeeringConnectionId.${key.substring(
        key.indexOf(".") + 1
      )}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2DescribeVpcsRequest = (
  input: DescribeVpcsRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.MaxResults !== undefined) {
    entries["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    entries["NextToken"] = input.NextToken;
  }
  if (input.VpcIds !== undefined) {
    const memberEntries = serializeAws_ec2VpcIdStringList(
      input.VpcIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `VpcId.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2DescribeVpnConnectionsRequest = (
  input: DescribeVpnConnectionsRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.VpnConnectionIds !== undefined) {
    const memberEntries = serializeAws_ec2VpnConnectionIdStringList(
      input.VpnConnectionIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `VpnConnectionId.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2DescribeVpnGatewaysRequest = (
  input: DescribeVpnGatewaysRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.VpnGatewayIds !== undefined) {
    const memberEntries = serializeAws_ec2VpnGatewayIdStringList(
      input.VpnGatewayIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `VpnGatewayId.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2DetachClassicLinkVpcRequest = (
  input: DetachClassicLinkVpcRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.InstanceId !== undefined) {
    entries["InstanceId"] = input.InstanceId;
  }
  if (input.VpcId !== undefined) {
    entries["VpcId"] = input.VpcId;
  }
  return entries;
};

const serializeAws_ec2DetachInternetGatewayRequest = (
  input: DetachInternetGatewayRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.InternetGatewayId !== undefined) {
    entries["InternetGatewayId"] = input.InternetGatewayId;
  }
  if (input.VpcId !== undefined) {
    entries["VpcId"] = input.VpcId;
  }
  return entries;
};

const serializeAws_ec2DetachNetworkInterfaceRequest = (
  input: DetachNetworkInterfaceRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.AttachmentId !== undefined) {
    entries["AttachmentId"] = input.AttachmentId;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Force !== undefined) {
    entries["Force"] = input.Force;
  }
  return entries;
};

const serializeAws_ec2DetachVolumeRequest = (
  input: DetachVolumeRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Device !== undefined) {
    entries["Device"] = input.Device;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Force !== undefined) {
    entries["Force"] = input.Force;
  }
  if (input.InstanceId !== undefined) {
    entries["InstanceId"] = input.InstanceId;
  }
  if (input.VolumeId !== undefined) {
    entries["VolumeId"] = input.VolumeId;
  }
  return entries;
};

const serializeAws_ec2DetachVpnGatewayRequest = (
  input: DetachVpnGatewayRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.VpcId !== undefined) {
    entries["VpcId"] = input.VpcId;
  }
  if (input.VpnGatewayId !== undefined) {
    entries["VpnGatewayId"] = input.VpnGatewayId;
  }
  return entries;
};

const serializeAws_ec2DhcpOptionsIdStringList = (
  input: string[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    entries[`DhcpOptionsId.${counter}`] = entry;
    counter++;
  }
  return entries;
};

const serializeAws_ec2DirectoryServiceAuthenticationRequest = (
  input: DirectoryServiceAuthenticationRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DirectoryId !== undefined) {
    entries["DirectoryId"] = input.DirectoryId;
  }
  return entries;
};

const serializeAws_ec2DisableEbsEncryptionByDefaultRequest = (
  input: DisableEbsEncryptionByDefaultRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  return entries;
};

const serializeAws_ec2DisableFastSnapshotRestoresRequest = (
  input: DisableFastSnapshotRestoresRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.AvailabilityZones !== undefined) {
    const memberEntries = serializeAws_ec2AvailabilityZoneStringList(
      input.AvailabilityZones,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `AvailabilityZone.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.SourceSnapshotIds !== undefined) {
    const memberEntries = serializeAws_ec2SnapshotIdStringList(
      input.SourceSnapshotIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `SourceSnapshotId.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2DisableTransitGatewayRouteTablePropagationRequest = (
  input: DisableTransitGatewayRouteTablePropagationRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.TransitGatewayAttachmentId !== undefined) {
    entries["TransitGatewayAttachmentId"] = input.TransitGatewayAttachmentId;
  }
  if (input.TransitGatewayRouteTableId !== undefined) {
    entries["TransitGatewayRouteTableId"] = input.TransitGatewayRouteTableId;
  }
  return entries;
};

const serializeAws_ec2DisableVgwRoutePropagationRequest = (
  input: DisableVgwRoutePropagationRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.GatewayId !== undefined) {
    entries["GatewayId"] = input.GatewayId;
  }
  if (input.RouteTableId !== undefined) {
    entries["RouteTableId"] = input.RouteTableId;
  }
  return entries;
};

const serializeAws_ec2DisableVpcClassicLinkDnsSupportRequest = (
  input: DisableVpcClassicLinkDnsSupportRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.VpcId !== undefined) {
    entries["VpcId"] = input.VpcId;
  }
  return entries;
};

const serializeAws_ec2DisableVpcClassicLinkRequest = (
  input: DisableVpcClassicLinkRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.VpcId !== undefined) {
    entries["VpcId"] = input.VpcId;
  }
  return entries;
};

const serializeAws_ec2DisassociateAddressRequest = (
  input: DisassociateAddressRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.AssociationId !== undefined) {
    entries["AssociationId"] = input.AssociationId;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.PublicIp !== undefined) {
    entries["PublicIp"] = input.PublicIp;
  }
  return entries;
};

const serializeAws_ec2DisassociateClientVpnTargetNetworkRequest = (
  input: DisassociateClientVpnTargetNetworkRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.AssociationId !== undefined) {
    entries["AssociationId"] = input.AssociationId;
  }
  if (input.ClientVpnEndpointId !== undefined) {
    entries["ClientVpnEndpointId"] = input.ClientVpnEndpointId;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  return entries;
};

const serializeAws_ec2DisassociateIamInstanceProfileRequest = (
  input: DisassociateIamInstanceProfileRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.AssociationId !== undefined) {
    entries["AssociationId"] = input.AssociationId;
  }
  return entries;
};

const serializeAws_ec2DisassociateRouteTableRequest = (
  input: DisassociateRouteTableRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.AssociationId !== undefined) {
    entries["AssociationId"] = input.AssociationId;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  return entries;
};

const serializeAws_ec2DisassociateSubnetCidrBlockRequest = (
  input: DisassociateSubnetCidrBlockRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.AssociationId !== undefined) {
    entries["AssociationId"] = input.AssociationId;
  }
  return entries;
};

const serializeAws_ec2DisassociateTransitGatewayMulticastDomainRequest = (
  input: DisassociateTransitGatewayMulticastDomainRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.SubnetIds !== undefined) {
    const memberEntries = serializeAws_ec2ValueStringList(
      input.SubnetIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `SubnetIds.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.TransitGatewayAttachmentId !== undefined) {
    entries["TransitGatewayAttachmentId"] = input.TransitGatewayAttachmentId;
  }
  if (input.TransitGatewayMulticastDomainId !== undefined) {
    entries["TransitGatewayMulticastDomainId"] =
      input.TransitGatewayMulticastDomainId;
  }
  return entries;
};

const serializeAws_ec2DisassociateTransitGatewayRouteTableRequest = (
  input: DisassociateTransitGatewayRouteTableRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.TransitGatewayAttachmentId !== undefined) {
    entries["TransitGatewayAttachmentId"] = input.TransitGatewayAttachmentId;
  }
  if (input.TransitGatewayRouteTableId !== undefined) {
    entries["TransitGatewayRouteTableId"] = input.TransitGatewayRouteTableId;
  }
  return entries;
};

const serializeAws_ec2DisassociateVpcCidrBlockRequest = (
  input: DisassociateVpcCidrBlockRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.AssociationId !== undefined) {
    entries["AssociationId"] = input.AssociationId;
  }
  return entries;
};

const serializeAws_ec2DiskImage = (
  input: DiskImage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Description !== undefined) {
    entries["Description"] = input.Description;
  }
  if (input.Image !== undefined) {
    const memberEntries = serializeAws_ec2DiskImageDetail(input.Image, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Image.${key}`;
      entries[loc] = value;
    });
  }
  if (input.Volume !== undefined) {
    const memberEntries = serializeAws_ec2VolumeDetail(input.Volume, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Volume.${key}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2DiskImageDetail = (
  input: DiskImageDetail,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Bytes !== undefined) {
    entries["Bytes"] = input.Bytes;
  }
  if (input.Format !== undefined) {
    entries["Format"] = input.Format;
  }
  if (input.ImportManifestUrl !== undefined) {
    entries["ImportManifestUrl"] = input.ImportManifestUrl;
  }
  return entries;
};

const serializeAws_ec2DiskImageList = (
  input: DiskImage[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    const memberEntries = serializeAws_ec2DiskImage(entry, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      entries[`Member.${counter}.${key}`] = value;
    });
    counter++;
  }
  return entries;
};

const serializeAws_ec2DnsServersOptionsModifyStructure = (
  input: DnsServersOptionsModifyStructure,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.CustomDnsServers !== undefined) {
    const memberEntries = serializeAws_ec2ValueStringList(
      input.CustomDnsServers,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `CustomDnsServers.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.Enabled !== undefined) {
    entries["Enabled"] = input.Enabled;
  }
  return entries;
};

const serializeAws_ec2EbsBlockDevice = (
  input: EbsBlockDevice,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DeleteOnTermination !== undefined) {
    entries["DeleteOnTermination"] = input.DeleteOnTermination;
  }
  if (input.Encrypted !== undefined) {
    entries["Encrypted"] = input.Encrypted;
  }
  if (input.Iops !== undefined) {
    entries["Iops"] = input.Iops;
  }
  if (input.KmsKeyId !== undefined) {
    entries["KmsKeyId"] = input.KmsKeyId;
  }
  if (input.SnapshotId !== undefined) {
    entries["SnapshotId"] = input.SnapshotId;
  }
  if (input.VolumeSize !== undefined) {
    entries["VolumeSize"] = input.VolumeSize;
  }
  if (input.VolumeType !== undefined) {
    entries["VolumeType"] = input.VolumeType;
  }
  return entries;
};

const serializeAws_ec2EbsInstanceBlockDeviceSpecification = (
  input: EbsInstanceBlockDeviceSpecification,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DeleteOnTermination !== undefined) {
    entries["DeleteOnTermination"] = input.DeleteOnTermination;
  }
  if (input.VolumeId !== undefined) {
    entries["VolumeId"] = input.VolumeId;
  }
  return entries;
};

const serializeAws_ec2EgressOnlyInternetGatewayIdList = (
  input: string[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    entries[`Item.${counter}`] = entry;
    counter++;
  }
  return entries;
};

const serializeAws_ec2ElasticGpuIdSet = (
  input: string[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    entries[`Item.${counter}`] = entry;
    counter++;
  }
  return entries;
};

const serializeAws_ec2ElasticGpuSpecification = (
  input: ElasticGpuSpecification,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Type !== undefined) {
    entries["Type"] = input.Type;
  }
  return entries;
};

const serializeAws_ec2ElasticGpuSpecificationList = (
  input: ElasticGpuSpecification[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    const memberEntries = serializeAws_ec2ElasticGpuSpecification(
      entry,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      entries[`ElasticGpuSpecification.${counter}.${key}`] = value;
    });
    counter++;
  }
  return entries;
};

const serializeAws_ec2ElasticGpuSpecifications = (
  input: ElasticGpuSpecification[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    const memberEntries = serializeAws_ec2ElasticGpuSpecification(
      entry,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      entries[`Item.${counter}.${key}`] = value;
    });
    counter++;
  }
  return entries;
};

const serializeAws_ec2ElasticInferenceAccelerator = (
  input: ElasticInferenceAccelerator,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Count !== undefined) {
    entries["Count"] = input.Count;
  }
  if (input.Type !== undefined) {
    entries["Type"] = input.Type;
  }
  return entries;
};

const serializeAws_ec2ElasticInferenceAccelerators = (
  input: ElasticInferenceAccelerator[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    const memberEntries = serializeAws_ec2ElasticInferenceAccelerator(
      entry,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      entries[`Item.${counter}.${key}`] = value;
    });
    counter++;
  }
  return entries;
};

const serializeAws_ec2EnableEbsEncryptionByDefaultRequest = (
  input: EnableEbsEncryptionByDefaultRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  return entries;
};

const serializeAws_ec2EnableFastSnapshotRestoresRequest = (
  input: EnableFastSnapshotRestoresRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.AvailabilityZones !== undefined) {
    const memberEntries = serializeAws_ec2AvailabilityZoneStringList(
      input.AvailabilityZones,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `AvailabilityZone.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.SourceSnapshotIds !== undefined) {
    const memberEntries = serializeAws_ec2SnapshotIdStringList(
      input.SourceSnapshotIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `SourceSnapshotId.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2EnableTransitGatewayRouteTablePropagationRequest = (
  input: EnableTransitGatewayRouteTablePropagationRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.TransitGatewayAttachmentId !== undefined) {
    entries["TransitGatewayAttachmentId"] = input.TransitGatewayAttachmentId;
  }
  if (input.TransitGatewayRouteTableId !== undefined) {
    entries["TransitGatewayRouteTableId"] = input.TransitGatewayRouteTableId;
  }
  return entries;
};

const serializeAws_ec2EnableVgwRoutePropagationRequest = (
  input: EnableVgwRoutePropagationRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.GatewayId !== undefined) {
    entries["GatewayId"] = input.GatewayId;
  }
  if (input.RouteTableId !== undefined) {
    entries["RouteTableId"] = input.RouteTableId;
  }
  return entries;
};

const serializeAws_ec2EnableVolumeIORequest = (
  input: EnableVolumeIORequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.VolumeId !== undefined) {
    entries["VolumeId"] = input.VolumeId;
  }
  return entries;
};

const serializeAws_ec2EnableVpcClassicLinkDnsSupportRequest = (
  input: EnableVpcClassicLinkDnsSupportRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.VpcId !== undefined) {
    entries["VpcId"] = input.VpcId;
  }
  return entries;
};

const serializeAws_ec2EnableVpcClassicLinkRequest = (
  input: EnableVpcClassicLinkRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.VpcId !== undefined) {
    entries["VpcId"] = input.VpcId;
  }
  return entries;
};

const serializeAws_ec2ExecutableByStringList = (
  input: string[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    entries[`ExecutableBy.${counter}`] = entry;
    counter++;
  }
  return entries;
};

const serializeAws_ec2ExportClientVpnClientCertificateRevocationListRequest = (
  input: ExportClientVpnClientCertificateRevocationListRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.ClientVpnEndpointId !== undefined) {
    entries["ClientVpnEndpointId"] = input.ClientVpnEndpointId;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  return entries;
};

const serializeAws_ec2ExportClientVpnClientConfigurationRequest = (
  input: ExportClientVpnClientConfigurationRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.ClientVpnEndpointId !== undefined) {
    entries["ClientVpnEndpointId"] = input.ClientVpnEndpointId;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  return entries;
};

const serializeAws_ec2ExportImageRequest = (
  input: ExportImageRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.ClientToken === undefined) {
    input.ClientToken = generateIdempotencyToken();
  }
  if (input.ClientToken !== undefined) {
    entries["ClientToken"] = input.ClientToken;
  }
  if (input.Description !== undefined) {
    entries["Description"] = input.Description;
  }
  if (input.DiskImageFormat !== undefined) {
    entries["DiskImageFormat"] = input.DiskImageFormat;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.ImageId !== undefined) {
    entries["ImageId"] = input.ImageId;
  }
  if (input.RoleName !== undefined) {
    entries["RoleName"] = input.RoleName;
  }
  if (input.S3ExportLocation !== undefined) {
    const memberEntries = serializeAws_ec2ExportTaskS3LocationRequest(
      input.S3ExportLocation,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `S3ExportLocation.${key}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2ExportImageTaskIdList = (
  input: string[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    entries[`ExportImageTaskId.${counter}`] = entry;
    counter++;
  }
  return entries;
};

const serializeAws_ec2ExportTaskIdStringList = (
  input: string[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    entries[`ExportTaskId.${counter}`] = entry;
    counter++;
  }
  return entries;
};

const serializeAws_ec2ExportTaskS3LocationRequest = (
  input: ExportTaskS3LocationRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.S3Bucket !== undefined) {
    entries["S3Bucket"] = input.S3Bucket;
  }
  if (input.S3Prefix !== undefined) {
    entries["S3Prefix"] = input.S3Prefix;
  }
  return entries;
};

const serializeAws_ec2ExportToS3TaskSpecification = (
  input: ExportToS3TaskSpecification,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.ContainerFormat !== undefined) {
    entries["ContainerFormat"] = input.ContainerFormat;
  }
  if (input.DiskImageFormat !== undefined) {
    entries["DiskImageFormat"] = input.DiskImageFormat;
  }
  if (input.S3Bucket !== undefined) {
    entries["S3Bucket"] = input.S3Bucket;
  }
  if (input.S3Prefix !== undefined) {
    entries["S3Prefix"] = input.S3Prefix;
  }
  return entries;
};

const serializeAws_ec2ExportTransitGatewayRoutesRequest = (
  input: ExportTransitGatewayRoutesRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.S3Bucket !== undefined) {
    entries["S3Bucket"] = input.S3Bucket;
  }
  if (input.TransitGatewayRouteTableId !== undefined) {
    entries["TransitGatewayRouteTableId"] = input.TransitGatewayRouteTableId;
  }
  return entries;
};

const serializeAws_ec2Filter = (
  input: Filter,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Name !== undefined) {
    entries["Name"] = input.Name;
  }
  if (input.Values !== undefined) {
    const memberEntries = serializeAws_ec2ValueStringList(
      input.Values,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Value.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2FilterList = (
  input: Filter[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    const memberEntries = serializeAws_ec2Filter(entry, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      entries[`Filter.${counter}.${key}`] = value;
    });
    counter++;
  }
  return entries;
};

const serializeAws_ec2FleetIdSet = (
  input: string[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    entries[`Member.${counter}`] = entry;
    counter++;
  }
  return entries;
};

const serializeAws_ec2FleetLaunchTemplateConfigListRequest = (
  input: FleetLaunchTemplateConfigRequest[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    const memberEntries = serializeAws_ec2FleetLaunchTemplateConfigRequest(
      entry,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      entries[`Item.${counter}.${key}`] = value;
    });
    counter++;
  }
  return entries;
};

const serializeAws_ec2FleetLaunchTemplateConfigRequest = (
  input: FleetLaunchTemplateConfigRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.LaunchTemplateSpecification !== undefined) {
    const memberEntries = serializeAws_ec2FleetLaunchTemplateSpecificationRequest(
      input.LaunchTemplateSpecification,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `LaunchTemplateSpecification.${key}`;
      entries[loc] = value;
    });
  }
  if (input.Overrides !== undefined) {
    const memberEntries = serializeAws_ec2FleetLaunchTemplateOverridesListRequest(
      input.Overrides,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Overrides.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2FleetLaunchTemplateOverridesListRequest = (
  input: FleetLaunchTemplateOverridesRequest[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    const memberEntries = serializeAws_ec2FleetLaunchTemplateOverridesRequest(
      entry,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      entries[`Item.${counter}.${key}`] = value;
    });
    counter++;
  }
  return entries;
};

const serializeAws_ec2FleetLaunchTemplateOverridesRequest = (
  input: FleetLaunchTemplateOverridesRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.AvailabilityZone !== undefined) {
    entries["AvailabilityZone"] = input.AvailabilityZone;
  }
  if (input.InstanceType !== undefined) {
    entries["InstanceType"] = input.InstanceType;
  }
  if (input.MaxPrice !== undefined) {
    entries["MaxPrice"] = input.MaxPrice;
  }
  if (input.Placement !== undefined) {
    const memberEntries = serializeAws_ec2Placement(input.Placement, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Placement.${key}`;
      entries[loc] = value;
    });
  }
  if (input.Priority !== undefined) {
    entries["Priority"] = input.Priority;
  }
  if (input.SubnetId !== undefined) {
    entries["SubnetId"] = input.SubnetId;
  }
  if (input.WeightedCapacity !== undefined) {
    entries["WeightedCapacity"] = input.WeightedCapacity;
  }
  return entries;
};

const serializeAws_ec2FleetLaunchTemplateSpecification = (
  input: FleetLaunchTemplateSpecification,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.LaunchTemplateId !== undefined) {
    entries["LaunchTemplateId"] = input.LaunchTemplateId;
  }
  if (input.LaunchTemplateName !== undefined) {
    entries["LaunchTemplateName"] = input.LaunchTemplateName;
  }
  if (input.Version !== undefined) {
    entries["Version"] = input.Version;
  }
  return entries;
};

const serializeAws_ec2FleetLaunchTemplateSpecificationRequest = (
  input: FleetLaunchTemplateSpecificationRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.LaunchTemplateId !== undefined) {
    entries["LaunchTemplateId"] = input.LaunchTemplateId;
  }
  if (input.LaunchTemplateName !== undefined) {
    entries["LaunchTemplateName"] = input.LaunchTemplateName;
  }
  if (input.Version !== undefined) {
    entries["Version"] = input.Version;
  }
  return entries;
};

const serializeAws_ec2FpgaImageIdList = (
  input: string[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    entries[`Item.${counter}`] = entry;
    counter++;
  }
  return entries;
};

const serializeAws_ec2GetAssociatedIpv6PoolCidrsRequest = (
  input: GetAssociatedIpv6PoolCidrsRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.MaxResults !== undefined) {
    entries["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    entries["NextToken"] = input.NextToken;
  }
  if (input.PoolId !== undefined) {
    entries["PoolId"] = input.PoolId;
  }
  return entries;
};

const serializeAws_ec2GetCapacityReservationUsageRequest = (
  input: GetCapacityReservationUsageRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.CapacityReservationId !== undefined) {
    entries["CapacityReservationId"] = input.CapacityReservationId;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.MaxResults !== undefined) {
    entries["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    entries["NextToken"] = input.NextToken;
  }
  return entries;
};

const serializeAws_ec2GetCoipPoolUsageRequest = (
  input: GetCoipPoolUsageRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.MaxResults !== undefined) {
    entries["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    entries["NextToken"] = input.NextToken;
  }
  if (input.PoolId !== undefined) {
    entries["PoolId"] = input.PoolId;
  }
  return entries;
};

const serializeAws_ec2GetConsoleOutputRequest = (
  input: GetConsoleOutputRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.InstanceId !== undefined) {
    entries["InstanceId"] = input.InstanceId;
  }
  if (input.Latest !== undefined) {
    entries["Latest"] = input.Latest;
  }
  return entries;
};

const serializeAws_ec2GetConsoleScreenshotRequest = (
  input: GetConsoleScreenshotRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.InstanceId !== undefined) {
    entries["InstanceId"] = input.InstanceId;
  }
  if (input.WakeUp !== undefined) {
    entries["WakeUp"] = input.WakeUp;
  }
  return entries;
};

const serializeAws_ec2GetDefaultCreditSpecificationRequest = (
  input: GetDefaultCreditSpecificationRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.InstanceFamily !== undefined) {
    entries["InstanceFamily"] = input.InstanceFamily;
  }
  return entries;
};

const serializeAws_ec2GetEbsDefaultKmsKeyIdRequest = (
  input: GetEbsDefaultKmsKeyIdRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  return entries;
};

const serializeAws_ec2GetEbsEncryptionByDefaultRequest = (
  input: GetEbsEncryptionByDefaultRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  return entries;
};

const serializeAws_ec2GetHostReservationPurchasePreviewRequest = (
  input: GetHostReservationPurchasePreviewRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.HostIdSet !== undefined) {
    const memberEntries = serializeAws_ec2RequestHostIdSet(
      input.HostIdSet,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `HostIdSet.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.OfferingId !== undefined) {
    entries["OfferingId"] = input.OfferingId;
  }
  return entries;
};

const serializeAws_ec2GetLaunchTemplateDataRequest = (
  input: GetLaunchTemplateDataRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.InstanceId !== undefined) {
    entries["InstanceId"] = input.InstanceId;
  }
  return entries;
};

const serializeAws_ec2GetPasswordDataRequest = (
  input: GetPasswordDataRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.InstanceId !== undefined) {
    entries["InstanceId"] = input.InstanceId;
  }
  return entries;
};

const serializeAws_ec2GetReservedInstancesExchangeQuoteRequest = (
  input: GetReservedInstancesExchangeQuoteRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.ReservedInstanceIds !== undefined) {
    const memberEntries = serializeAws_ec2ReservedInstanceIdSet(
      input.ReservedInstanceIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `ReservedInstanceId.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.TargetConfigurations !== undefined) {
    const memberEntries = serializeAws_ec2TargetConfigurationRequestSet(
      input.TargetConfigurations,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `TargetConfiguration.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2GetTransitGatewayAttachmentPropagationsRequest = (
  input: GetTransitGatewayAttachmentPropagationsRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.MaxResults !== undefined) {
    entries["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    entries["NextToken"] = input.NextToken;
  }
  if (input.TransitGatewayAttachmentId !== undefined) {
    entries["TransitGatewayAttachmentId"] = input.TransitGatewayAttachmentId;
  }
  return entries;
};

const serializeAws_ec2GetTransitGatewayMulticastDomainAssociationsRequest = (
  input: GetTransitGatewayMulticastDomainAssociationsRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.MaxResults !== undefined) {
    entries["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    entries["NextToken"] = input.NextToken;
  }
  if (input.TransitGatewayMulticastDomainId !== undefined) {
    entries["TransitGatewayMulticastDomainId"] =
      input.TransitGatewayMulticastDomainId;
  }
  return entries;
};

const serializeAws_ec2GetTransitGatewayRouteTableAssociationsRequest = (
  input: GetTransitGatewayRouteTableAssociationsRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.MaxResults !== undefined) {
    entries["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    entries["NextToken"] = input.NextToken;
  }
  if (input.TransitGatewayRouteTableId !== undefined) {
    entries["TransitGatewayRouteTableId"] = input.TransitGatewayRouteTableId;
  }
  return entries;
};

const serializeAws_ec2GetTransitGatewayRouteTablePropagationsRequest = (
  input: GetTransitGatewayRouteTablePropagationsRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.MaxResults !== undefined) {
    entries["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    entries["NextToken"] = input.NextToken;
  }
  if (input.TransitGatewayRouteTableId !== undefined) {
    entries["TransitGatewayRouteTableId"] = input.TransitGatewayRouteTableId;
  }
  return entries;
};

const serializeAws_ec2GroupIdentifier = (
  input: GroupIdentifier,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.GroupId !== undefined) {
    entries["GroupId"] = input.GroupId;
  }
  if (input.GroupName !== undefined) {
    entries["GroupName"] = input.GroupName;
  }
  return entries;
};

const serializeAws_ec2GroupIdentifierList = (
  input: GroupIdentifier[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    const memberEntries = serializeAws_ec2GroupIdentifier(entry, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      entries[`Item.${counter}.${key}`] = value;
    });
    counter++;
  }
  return entries;
};

const serializeAws_ec2GroupIds = (
  input: string[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    entries[`Item.${counter}`] = entry;
    counter++;
  }
  return entries;
};

const serializeAws_ec2GroupIdStringList = (
  input: string[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    entries[`GroupId.${counter}`] = entry;
    counter++;
  }
  return entries;
};

const serializeAws_ec2GroupNameStringList = (
  input: string[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    entries[`GroupName.${counter}`] = entry;
    counter++;
  }
  return entries;
};

const serializeAws_ec2HibernationOptionsRequest = (
  input: HibernationOptionsRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Configured !== undefined) {
    entries["Configured"] = input.Configured;
  }
  return entries;
};

const serializeAws_ec2HostReservationIdSet = (
  input: string[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    entries[`Item.${counter}`] = entry;
    counter++;
  }
  return entries;
};

const serializeAws_ec2IamInstanceProfileSpecification = (
  input: IamInstanceProfileSpecification,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Arn !== undefined) {
    entries["Arn"] = input.Arn;
  }
  if (input.Name !== undefined) {
    entries["Name"] = input.Name;
  }
  return entries;
};

const serializeAws_ec2IcmpTypeCode = (
  input: IcmpTypeCode,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Code !== undefined) {
    entries["Code"] = input.Code;
  }
  if (input.Type !== undefined) {
    entries["Type"] = input.Type;
  }
  return entries;
};

const serializeAws_ec2IKEVersionsRequestList = (
  input: IKEVersionsRequestListValue[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    const memberEntries = serializeAws_ec2IKEVersionsRequestListValue(
      entry,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      entries[`Item.${counter}.${key}`] = value;
    });
    counter++;
  }
  return entries;
};

const serializeAws_ec2IKEVersionsRequestListValue = (
  input: IKEVersionsRequestListValue,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Value !== undefined) {
    entries["Value"] = input.Value;
  }
  return entries;
};

const serializeAws_ec2ImageDiskContainer = (
  input: ImageDiskContainer,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Description !== undefined) {
    entries["Description"] = input.Description;
  }
  if (input.DeviceName !== undefined) {
    entries["DeviceName"] = input.DeviceName;
  }
  if (input.Format !== undefined) {
    entries["Format"] = input.Format;
  }
  if (input.SnapshotId !== undefined) {
    entries["SnapshotId"] = input.SnapshotId;
  }
  if (input.Url !== undefined) {
    entries["Url"] = input.Url;
  }
  if (input.UserBucket !== undefined) {
    const memberEntries = serializeAws_ec2UserBucket(input.UserBucket, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `UserBucket.${key}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2ImageDiskContainerList = (
  input: ImageDiskContainer[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    const memberEntries = serializeAws_ec2ImageDiskContainer(entry, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      entries[`Item.${counter}.${key}`] = value;
    });
    counter++;
  }
  return entries;
};

const serializeAws_ec2ImageIdStringList = (
  input: string[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    entries[`ImageId.${counter}`] = entry;
    counter++;
  }
  return entries;
};

const serializeAws_ec2ImportClientVpnClientCertificateRevocationListRequest = (
  input: ImportClientVpnClientCertificateRevocationListRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.CertificateRevocationList !== undefined) {
    entries["CertificateRevocationList"] = input.CertificateRevocationList;
  }
  if (input.ClientVpnEndpointId !== undefined) {
    entries["ClientVpnEndpointId"] = input.ClientVpnEndpointId;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  return entries;
};

const serializeAws_ec2ImportImageLicenseConfigurationRequest = (
  input: ImportImageLicenseConfigurationRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.LicenseConfigurationArn !== undefined) {
    entries["LicenseConfigurationArn"] = input.LicenseConfigurationArn;
  }
  return entries;
};

const serializeAws_ec2ImportImageLicenseSpecificationListRequest = (
  input: ImportImageLicenseConfigurationRequest[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    const memberEntries = serializeAws_ec2ImportImageLicenseConfigurationRequest(
      entry,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      entries[`Item.${counter}.${key}`] = value;
    });
    counter++;
  }
  return entries;
};

const serializeAws_ec2ImportImageRequest = (
  input: ImportImageRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Architecture !== undefined) {
    entries["Architecture"] = input.Architecture;
  }
  if (input.ClientData !== undefined) {
    const memberEntries = serializeAws_ec2ClientData(input.ClientData, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `ClientData.${key}`;
      entries[loc] = value;
    });
  }
  if (input.ClientToken !== undefined) {
    entries["ClientToken"] = input.ClientToken;
  }
  if (input.Description !== undefined) {
    entries["Description"] = input.Description;
  }
  if (input.DiskContainers !== undefined) {
    const memberEntries = serializeAws_ec2ImageDiskContainerList(
      input.DiskContainers,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `DiskContainer.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Encrypted !== undefined) {
    entries["Encrypted"] = input.Encrypted;
  }
  if (input.Hypervisor !== undefined) {
    entries["Hypervisor"] = input.Hypervisor;
  }
  if (input.KmsKeyId !== undefined) {
    entries["KmsKeyId"] = input.KmsKeyId;
  }
  if (input.LicenseSpecifications !== undefined) {
    const memberEntries = serializeAws_ec2ImportImageLicenseSpecificationListRequest(
      input.LicenseSpecifications,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `LicenseSpecifications.${key.substring(
        key.indexOf(".") + 1
      )}`;
      entries[loc] = value;
    });
  }
  if (input.LicenseType !== undefined) {
    entries["LicenseType"] = input.LicenseType;
  }
  if (input.Platform !== undefined) {
    entries["Platform"] = input.Platform;
  }
  if (input.RoleName !== undefined) {
    entries["RoleName"] = input.RoleName;
  }
  return entries;
};

const serializeAws_ec2ImportInstanceLaunchSpecification = (
  input: ImportInstanceLaunchSpecification,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.AdditionalInfo !== undefined) {
    entries["AdditionalInfo"] = input.AdditionalInfo;
  }
  if (input.Architecture !== undefined) {
    entries["Architecture"] = input.Architecture;
  }
  if (input.GroupIds !== undefined) {
    const memberEntries = serializeAws_ec2SecurityGroupIdStringList(
      input.GroupIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `GroupId.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.GroupNames !== undefined) {
    const memberEntries = serializeAws_ec2SecurityGroupStringList(
      input.GroupNames,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `GroupName.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.InstanceInitiatedShutdownBehavior !== undefined) {
    entries["InstanceInitiatedShutdownBehavior"] =
      input.InstanceInitiatedShutdownBehavior;
  }
  if (input.InstanceType !== undefined) {
    entries["InstanceType"] = input.InstanceType;
  }
  if (input.Monitoring !== undefined) {
    entries["Monitoring"] = input.Monitoring;
  }
  if (input.Placement !== undefined) {
    const memberEntries = serializeAws_ec2Placement(input.Placement, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Placement.${key}`;
      entries[loc] = value;
    });
  }
  if (input.PrivateIpAddress !== undefined) {
    entries["PrivateIpAddress"] = input.PrivateIpAddress;
  }
  if (input.SubnetId !== undefined) {
    entries["SubnetId"] = input.SubnetId;
  }
  if (input.UserData !== undefined) {
    const memberEntries = serializeAws_ec2UserData(input.UserData, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `UserData.${key}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2ImportInstanceRequest = (
  input: ImportInstanceRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Description !== undefined) {
    entries["Description"] = input.Description;
  }
  if (input.DiskImages !== undefined) {
    const memberEntries = serializeAws_ec2DiskImageList(
      input.DiskImages,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `DiskImage.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.LaunchSpecification !== undefined) {
    const memberEntries = serializeAws_ec2ImportInstanceLaunchSpecification(
      input.LaunchSpecification,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `LaunchSpecification.${key}`;
      entries[loc] = value;
    });
  }
  if (input.Platform !== undefined) {
    entries["Platform"] = input.Platform;
  }
  return entries;
};

const serializeAws_ec2ImportKeyPairRequest = (
  input: ImportKeyPairRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.KeyName !== undefined) {
    entries["KeyName"] = input.KeyName;
  }
  if (input.PublicKeyMaterial !== undefined) {
    entries["PublicKeyMaterial"] = context.base64Encoder(
      input.PublicKeyMaterial
    );
  }
  return entries;
};

const serializeAws_ec2ImportSnapshotRequest = (
  input: ImportSnapshotRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.ClientData !== undefined) {
    const memberEntries = serializeAws_ec2ClientData(input.ClientData, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `ClientData.${key}`;
      entries[loc] = value;
    });
  }
  if (input.ClientToken !== undefined) {
    entries["ClientToken"] = input.ClientToken;
  }
  if (input.Description !== undefined) {
    entries["Description"] = input.Description;
  }
  if (input.DiskContainer !== undefined) {
    const memberEntries = serializeAws_ec2SnapshotDiskContainer(
      input.DiskContainer,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `DiskContainer.${key}`;
      entries[loc] = value;
    });
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Encrypted !== undefined) {
    entries["Encrypted"] = input.Encrypted;
  }
  if (input.KmsKeyId !== undefined) {
    entries["KmsKeyId"] = input.KmsKeyId;
  }
  if (input.RoleName !== undefined) {
    entries["RoleName"] = input.RoleName;
  }
  return entries;
};

const serializeAws_ec2ImportTaskIdList = (
  input: string[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    entries[`ImportTaskId.${counter}`] = entry;
    counter++;
  }
  return entries;
};

const serializeAws_ec2ImportVolumeRequest = (
  input: ImportVolumeRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.AvailabilityZone !== undefined) {
    entries["AvailabilityZone"] = input.AvailabilityZone;
  }
  if (input.Description !== undefined) {
    entries["Description"] = input.Description;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Image !== undefined) {
    const memberEntries = serializeAws_ec2DiskImageDetail(input.Image, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Image.${key}`;
      entries[loc] = value;
    });
  }
  if (input.Volume !== undefined) {
    const memberEntries = serializeAws_ec2VolumeDetail(input.Volume, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Volume.${key}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2InstanceBlockDeviceMappingSpecification = (
  input: InstanceBlockDeviceMappingSpecification,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DeviceName !== undefined) {
    entries["DeviceName"] = input.DeviceName;
  }
  if (input.Ebs !== undefined) {
    const memberEntries = serializeAws_ec2EbsInstanceBlockDeviceSpecification(
      input.Ebs,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Ebs.${key}`;
      entries[loc] = value;
    });
  }
  if (input.NoDevice !== undefined) {
    entries["NoDevice"] = input.NoDevice;
  }
  if (input.VirtualName !== undefined) {
    entries["VirtualName"] = input.VirtualName;
  }
  return entries;
};

const serializeAws_ec2InstanceBlockDeviceMappingSpecificationList = (
  input: InstanceBlockDeviceMappingSpecification[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    const memberEntries = serializeAws_ec2InstanceBlockDeviceMappingSpecification(
      entry,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      entries[`Item.${counter}.${key}`] = value;
    });
    counter++;
  }
  return entries;
};

const serializeAws_ec2InstanceCreditSpecificationListRequest = (
  input: InstanceCreditSpecificationRequest[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    const memberEntries = serializeAws_ec2InstanceCreditSpecificationRequest(
      entry,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      entries[`Item.${counter}.${key}`] = value;
    });
    counter++;
  }
  return entries;
};

const serializeAws_ec2InstanceCreditSpecificationRequest = (
  input: InstanceCreditSpecificationRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.CpuCredits !== undefined) {
    entries["CpuCredits"] = input.CpuCredits;
  }
  if (input.InstanceId !== undefined) {
    entries["InstanceId"] = input.InstanceId;
  }
  return entries;
};

const serializeAws_ec2InstanceIdStringList = (
  input: string[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    entries[`InstanceId.${counter}`] = entry;
    counter++;
  }
  return entries;
};

const serializeAws_ec2InstanceIpv6Address = (
  input: InstanceIpv6Address,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Ipv6Address !== undefined) {
    entries["Ipv6Address"] = input.Ipv6Address;
  }
  return entries;
};

const serializeAws_ec2InstanceIpv6AddressList = (
  input: InstanceIpv6Address[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    const memberEntries = serializeAws_ec2InstanceIpv6Address(entry, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      entries[`Item.${counter}.${key}`] = value;
    });
    counter++;
  }
  return entries;
};

const serializeAws_ec2InstanceIpv6AddressListRequest = (
  input: InstanceIpv6AddressRequest[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    const memberEntries = serializeAws_ec2InstanceIpv6AddressRequest(
      entry,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      entries[`InstanceIpv6Address.${counter}.${key}`] = value;
    });
    counter++;
  }
  return entries;
};

const serializeAws_ec2InstanceIpv6AddressRequest = (
  input: InstanceIpv6AddressRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Ipv6Address !== undefined) {
    entries["Ipv6Address"] = input.Ipv6Address;
  }
  return entries;
};

const serializeAws_ec2InstanceMarketOptionsRequest = (
  input: InstanceMarketOptionsRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.MarketType !== undefined) {
    entries["MarketType"] = input.MarketType;
  }
  if (input.SpotOptions !== undefined) {
    const memberEntries = serializeAws_ec2SpotMarketOptions(
      input.SpotOptions,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `SpotOptions.${key}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2InstanceMetadataOptionsRequest = (
  input: InstanceMetadataOptionsRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.HttpEndpoint !== undefined) {
    entries["HttpEndpoint"] = input.HttpEndpoint;
  }
  if (input.HttpPutResponseHopLimit !== undefined) {
    entries["HttpPutResponseHopLimit"] = input.HttpPutResponseHopLimit;
  }
  if (input.HttpTokens !== undefined) {
    entries["HttpTokens"] = input.HttpTokens;
  }
  return entries;
};

const serializeAws_ec2InstanceNetworkInterfaceSpecification = (
  input: InstanceNetworkInterfaceSpecification,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.AssociatePublicIpAddress !== undefined) {
    entries["AssociatePublicIpAddress"] = input.AssociatePublicIpAddress;
  }
  if (input.DeleteOnTermination !== undefined) {
    entries["DeleteOnTermination"] = input.DeleteOnTermination;
  }
  if (input.Description !== undefined) {
    entries["Description"] = input.Description;
  }
  if (input.DeviceIndex !== undefined) {
    entries["DeviceIndex"] = input.DeviceIndex;
  }
  if (input.Groups !== undefined) {
    const memberEntries = serializeAws_ec2SecurityGroupIdStringList(
      input.Groups,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `SecurityGroupId.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.InterfaceType !== undefined) {
    entries["InterfaceType"] = input.InterfaceType;
  }
  if (input.Ipv6AddressCount !== undefined) {
    entries["Ipv6AddressCount"] = input.Ipv6AddressCount;
  }
  if (input.Ipv6Addresses !== undefined) {
    const memberEntries = serializeAws_ec2InstanceIpv6AddressList(
      input.Ipv6Addresses,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Ipv6Addresses.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.NetworkInterfaceId !== undefined) {
    entries["NetworkInterfaceId"] = input.NetworkInterfaceId;
  }
  if (input.PrivateIpAddress !== undefined) {
    entries["PrivateIpAddress"] = input.PrivateIpAddress;
  }
  if (input.PrivateIpAddresses !== undefined) {
    const memberEntries = serializeAws_ec2PrivateIpAddressSpecificationList(
      input.PrivateIpAddresses,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `PrivateIpAddresses.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.SecondaryPrivateIpAddressCount !== undefined) {
    entries["SecondaryPrivateIpAddressCount"] =
      input.SecondaryPrivateIpAddressCount;
  }
  if (input.SubnetId !== undefined) {
    entries["SubnetId"] = input.SubnetId;
  }
  return entries;
};

const serializeAws_ec2InstanceNetworkInterfaceSpecificationList = (
  input: InstanceNetworkInterfaceSpecification[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    const memberEntries = serializeAws_ec2InstanceNetworkInterfaceSpecification(
      entry,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      entries[`Item.${counter}.${key}`] = value;
    });
    counter++;
  }
  return entries;
};

const serializeAws_ec2InstanceSpecification = (
  input: InstanceSpecification,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.ExcludeBootVolume !== undefined) {
    entries["ExcludeBootVolume"] = input.ExcludeBootVolume;
  }
  if (input.InstanceId !== undefined) {
    entries["InstanceId"] = input.InstanceId;
  }
  return entries;
};

const serializeAws_ec2InstanceTypeList = (
  input: (_InstanceType | string)[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    entries[`Member.${counter}`] = entry;
    counter++;
  }
  return entries;
};

const serializeAws_ec2IpPermission = (
  input: IpPermission,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.FromPort !== undefined) {
    entries["FromPort"] = input.FromPort;
  }
  if (input.IpProtocol !== undefined) {
    entries["IpProtocol"] = input.IpProtocol;
  }
  if (input.IpRanges !== undefined) {
    const memberEntries = serializeAws_ec2IpRangeList(input.IpRanges, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `IpRanges.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.Ipv6Ranges !== undefined) {
    const memberEntries = serializeAws_ec2Ipv6RangeList(
      input.Ipv6Ranges,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Ipv6Ranges.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.PrefixListIds !== undefined) {
    const memberEntries = serializeAws_ec2PrefixListIdList(
      input.PrefixListIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `PrefixListIds.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.ToPort !== undefined) {
    entries["ToPort"] = input.ToPort;
  }
  if (input.UserIdGroupPairs !== undefined) {
    const memberEntries = serializeAws_ec2UserIdGroupPairList(
      input.UserIdGroupPairs,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Groups.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2IpPermissionList = (
  input: IpPermission[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    const memberEntries = serializeAws_ec2IpPermission(entry, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      entries[`Item.${counter}.${key}`] = value;
    });
    counter++;
  }
  return entries;
};

const serializeAws_ec2IpRange = (
  input: IpRange,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.CidrIp !== undefined) {
    entries["CidrIp"] = input.CidrIp;
  }
  if (input.Description !== undefined) {
    entries["Description"] = input.Description;
  }
  return entries;
};

const serializeAws_ec2IpRangeList = (
  input: IpRange[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    const memberEntries = serializeAws_ec2IpRange(entry, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      entries[`Item.${counter}.${key}`] = value;
    });
    counter++;
  }
  return entries;
};

const serializeAws_ec2Ipv6AddressList = (
  input: string[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    entries[`Item.${counter}`] = entry;
    counter++;
  }
  return entries;
};

const serializeAws_ec2Ipv6Range = (
  input: Ipv6Range,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.CidrIpv6 !== undefined) {
    entries["CidrIpv6"] = input.CidrIpv6;
  }
  if (input.Description !== undefined) {
    entries["Description"] = input.Description;
  }
  return entries;
};

const serializeAws_ec2Ipv6RangeList = (
  input: Ipv6Range[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    const memberEntries = serializeAws_ec2Ipv6Range(entry, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      entries[`Item.${counter}.${key}`] = value;
    });
    counter++;
  }
  return entries;
};

const serializeAws_ec2KeyNameStringList = (
  input: string[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    entries[`KeyName.${counter}`] = entry;
    counter++;
  }
  return entries;
};

const serializeAws_ec2KeyPairIdStringList = (
  input: string[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    entries[`KeyPairId.${counter}`] = entry;
    counter++;
  }
  return entries;
};

const serializeAws_ec2LaunchPermission = (
  input: LaunchPermission,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Group !== undefined) {
    entries["Group"] = input.Group;
  }
  if (input.UserId !== undefined) {
    entries["UserId"] = input.UserId;
  }
  return entries;
};

const serializeAws_ec2LaunchPermissionList = (
  input: LaunchPermission[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    const memberEntries = serializeAws_ec2LaunchPermission(entry, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      entries[`Item.${counter}.${key}`] = value;
    });
    counter++;
  }
  return entries;
};

const serializeAws_ec2LaunchPermissionModifications = (
  input: LaunchPermissionModifications,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Add !== undefined) {
    const memberEntries = serializeAws_ec2LaunchPermissionList(
      input.Add,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Add.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.Remove !== undefined) {
    const memberEntries = serializeAws_ec2LaunchPermissionList(
      input.Remove,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Remove.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2LaunchSpecsList = (
  input: SpotFleetLaunchSpecification[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    const memberEntries = serializeAws_ec2SpotFleetLaunchSpecification(
      entry,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      entries[`Item.${counter}.${key}`] = value;
    });
    counter++;
  }
  return entries;
};

const serializeAws_ec2LaunchTemplateBlockDeviceMappingRequest = (
  input: LaunchTemplateBlockDeviceMappingRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DeviceName !== undefined) {
    entries["DeviceName"] = input.DeviceName;
  }
  if (input.Ebs !== undefined) {
    const memberEntries = serializeAws_ec2LaunchTemplateEbsBlockDeviceRequest(
      input.Ebs,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Ebs.${key}`;
      entries[loc] = value;
    });
  }
  if (input.NoDevice !== undefined) {
    entries["NoDevice"] = input.NoDevice;
  }
  if (input.VirtualName !== undefined) {
    entries["VirtualName"] = input.VirtualName;
  }
  return entries;
};

const serializeAws_ec2LaunchTemplateBlockDeviceMappingRequestList = (
  input: LaunchTemplateBlockDeviceMappingRequest[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    const memberEntries = serializeAws_ec2LaunchTemplateBlockDeviceMappingRequest(
      entry,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      entries[`BlockDeviceMapping.${counter}.${key}`] = value;
    });
    counter++;
  }
  return entries;
};

const serializeAws_ec2LaunchTemplateCapacityReservationSpecificationRequest = (
  input: LaunchTemplateCapacityReservationSpecificationRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.CapacityReservationPreference !== undefined) {
    entries["CapacityReservationPreference"] =
      input.CapacityReservationPreference;
  }
  if (input.CapacityReservationTarget !== undefined) {
    const memberEntries = serializeAws_ec2CapacityReservationTarget(
      input.CapacityReservationTarget,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `CapacityReservationTarget.${key}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2LaunchTemplateConfig = (
  input: LaunchTemplateConfig,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.LaunchTemplateSpecification !== undefined) {
    const memberEntries = serializeAws_ec2FleetLaunchTemplateSpecification(
      input.LaunchTemplateSpecification,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `LaunchTemplateSpecification.${key}`;
      entries[loc] = value;
    });
  }
  if (input.Overrides !== undefined) {
    const memberEntries = serializeAws_ec2LaunchTemplateOverridesList(
      input.Overrides,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Overrides.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2LaunchTemplateConfigList = (
  input: LaunchTemplateConfig[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    const memberEntries = serializeAws_ec2LaunchTemplateConfig(entry, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      entries[`Item.${counter}.${key}`] = value;
    });
    counter++;
  }
  return entries;
};

const serializeAws_ec2LaunchTemplateCpuOptionsRequest = (
  input: LaunchTemplateCpuOptionsRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.CoreCount !== undefined) {
    entries["CoreCount"] = input.CoreCount;
  }
  if (input.ThreadsPerCore !== undefined) {
    entries["ThreadsPerCore"] = input.ThreadsPerCore;
  }
  return entries;
};

const serializeAws_ec2LaunchTemplateEbsBlockDeviceRequest = (
  input: LaunchTemplateEbsBlockDeviceRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DeleteOnTermination !== undefined) {
    entries["DeleteOnTermination"] = input.DeleteOnTermination;
  }
  if (input.Encrypted !== undefined) {
    entries["Encrypted"] = input.Encrypted;
  }
  if (input.Iops !== undefined) {
    entries["Iops"] = input.Iops;
  }
  if (input.KmsKeyId !== undefined) {
    entries["KmsKeyId"] = input.KmsKeyId;
  }
  if (input.SnapshotId !== undefined) {
    entries["SnapshotId"] = input.SnapshotId;
  }
  if (input.VolumeSize !== undefined) {
    entries["VolumeSize"] = input.VolumeSize;
  }
  if (input.VolumeType !== undefined) {
    entries["VolumeType"] = input.VolumeType;
  }
  return entries;
};

const serializeAws_ec2LaunchTemplateElasticInferenceAccelerator = (
  input: LaunchTemplateElasticInferenceAccelerator,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Count !== undefined) {
    entries["Count"] = input.Count;
  }
  if (input.Type !== undefined) {
    entries["Type"] = input.Type;
  }
  return entries;
};

const serializeAws_ec2LaunchTemplateElasticInferenceAcceleratorList = (
  input: LaunchTemplateElasticInferenceAccelerator[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    const memberEntries = serializeAws_ec2LaunchTemplateElasticInferenceAccelerator(
      entry,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      entries[`Item.${counter}.${key}`] = value;
    });
    counter++;
  }
  return entries;
};

const serializeAws_ec2LaunchTemplateHibernationOptionsRequest = (
  input: LaunchTemplateHibernationOptionsRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Configured !== undefined) {
    entries["Configured"] = input.Configured;
  }
  return entries;
};

const serializeAws_ec2LaunchTemplateIamInstanceProfileSpecificationRequest = (
  input: LaunchTemplateIamInstanceProfileSpecificationRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Arn !== undefined) {
    entries["Arn"] = input.Arn;
  }
  if (input.Name !== undefined) {
    entries["Name"] = input.Name;
  }
  return entries;
};

const serializeAws_ec2LaunchTemplateInstanceMarketOptionsRequest = (
  input: LaunchTemplateInstanceMarketOptionsRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.MarketType !== undefined) {
    entries["MarketType"] = input.MarketType;
  }
  if (input.SpotOptions !== undefined) {
    const memberEntries = serializeAws_ec2LaunchTemplateSpotMarketOptionsRequest(
      input.SpotOptions,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `SpotOptions.${key}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2LaunchTemplateInstanceMetadataOptionsRequest = (
  input: LaunchTemplateInstanceMetadataOptionsRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.HttpEndpoint !== undefined) {
    entries["HttpEndpoint"] = input.HttpEndpoint;
  }
  if (input.HttpPutResponseHopLimit !== undefined) {
    entries["HttpPutResponseHopLimit"] = input.HttpPutResponseHopLimit;
  }
  if (input.HttpTokens !== undefined) {
    entries["HttpTokens"] = input.HttpTokens;
  }
  return entries;
};

const serializeAws_ec2LaunchTemplateInstanceNetworkInterfaceSpecificationRequest = (
  input: LaunchTemplateInstanceNetworkInterfaceSpecificationRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.AssociatePublicIpAddress !== undefined) {
    entries["AssociatePublicIpAddress"] = input.AssociatePublicIpAddress;
  }
  if (input.DeleteOnTermination !== undefined) {
    entries["DeleteOnTermination"] = input.DeleteOnTermination;
  }
  if (input.Description !== undefined) {
    entries["Description"] = input.Description;
  }
  if (input.DeviceIndex !== undefined) {
    entries["DeviceIndex"] = input.DeviceIndex;
  }
  if (input.Groups !== undefined) {
    const memberEntries = serializeAws_ec2SecurityGroupIdStringList(
      input.Groups,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `SecurityGroupId.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.InterfaceType !== undefined) {
    entries["InterfaceType"] = input.InterfaceType;
  }
  if (input.Ipv6AddressCount !== undefined) {
    entries["Ipv6AddressCount"] = input.Ipv6AddressCount;
  }
  if (input.Ipv6Addresses !== undefined) {
    const memberEntries = serializeAws_ec2InstanceIpv6AddressListRequest(
      input.Ipv6Addresses,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Ipv6Addresses.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.NetworkInterfaceId !== undefined) {
    entries["NetworkInterfaceId"] = input.NetworkInterfaceId;
  }
  if (input.PrivateIpAddress !== undefined) {
    entries["PrivateIpAddress"] = input.PrivateIpAddress;
  }
  if (input.PrivateIpAddresses !== undefined) {
    const memberEntries = serializeAws_ec2PrivateIpAddressSpecificationList(
      input.PrivateIpAddresses,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `PrivateIpAddresses.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.SecondaryPrivateIpAddressCount !== undefined) {
    entries["SecondaryPrivateIpAddressCount"] =
      input.SecondaryPrivateIpAddressCount;
  }
  if (input.SubnetId !== undefined) {
    entries["SubnetId"] = input.SubnetId;
  }
  return entries;
};

const serializeAws_ec2LaunchTemplateInstanceNetworkInterfaceSpecificationRequestList = (
  input: LaunchTemplateInstanceNetworkInterfaceSpecificationRequest[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    const memberEntries = serializeAws_ec2LaunchTemplateInstanceNetworkInterfaceSpecificationRequest(
      entry,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      entries[
        `InstanceNetworkInterfaceSpecification.${counter}.${key}`
      ] = value;
    });
    counter++;
  }
  return entries;
};

const serializeAws_ec2LaunchTemplateLicenseConfigurationRequest = (
  input: LaunchTemplateLicenseConfigurationRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.LicenseConfigurationArn !== undefined) {
    entries["LicenseConfigurationArn"] = input.LicenseConfigurationArn;
  }
  return entries;
};

const serializeAws_ec2LaunchTemplateLicenseSpecificationListRequest = (
  input: LaunchTemplateLicenseConfigurationRequest[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    const memberEntries = serializeAws_ec2LaunchTemplateLicenseConfigurationRequest(
      entry,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      entries[`Item.${counter}.${key}`] = value;
    });
    counter++;
  }
  return entries;
};

const serializeAws_ec2LaunchTemplateNameStringList = (
  input: string[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    entries[`Item.${counter}`] = entry;
    counter++;
  }
  return entries;
};

const serializeAws_ec2LaunchTemplateOverrides = (
  input: LaunchTemplateOverrides,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.AvailabilityZone !== undefined) {
    entries["AvailabilityZone"] = input.AvailabilityZone;
  }
  if (input.InstanceType !== undefined) {
    entries["InstanceType"] = input.InstanceType;
  }
  if (input.Priority !== undefined) {
    entries["Priority"] = input.Priority;
  }
  if (input.SpotPrice !== undefined) {
    entries["SpotPrice"] = input.SpotPrice;
  }
  if (input.SubnetId !== undefined) {
    entries["SubnetId"] = input.SubnetId;
  }
  if (input.WeightedCapacity !== undefined) {
    entries["WeightedCapacity"] = input.WeightedCapacity;
  }
  return entries;
};

const serializeAws_ec2LaunchTemplateOverridesList = (
  input: LaunchTemplateOverrides[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    const memberEntries = serializeAws_ec2LaunchTemplateOverrides(
      entry,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      entries[`Item.${counter}.${key}`] = value;
    });
    counter++;
  }
  return entries;
};

const serializeAws_ec2LaunchTemplatePlacementRequest = (
  input: LaunchTemplatePlacementRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Affinity !== undefined) {
    entries["Affinity"] = input.Affinity;
  }
  if (input.AvailabilityZone !== undefined) {
    entries["AvailabilityZone"] = input.AvailabilityZone;
  }
  if (input.GroupName !== undefined) {
    entries["GroupName"] = input.GroupName;
  }
  if (input.HostId !== undefined) {
    entries["HostId"] = input.HostId;
  }
  if (input.HostResourceGroupArn !== undefined) {
    entries["HostResourceGroupArn"] = input.HostResourceGroupArn;
  }
  if (input.PartitionNumber !== undefined) {
    entries["PartitionNumber"] = input.PartitionNumber;
  }
  if (input.SpreadDomain !== undefined) {
    entries["SpreadDomain"] = input.SpreadDomain;
  }
  if (input.Tenancy !== undefined) {
    entries["Tenancy"] = input.Tenancy;
  }
  return entries;
};

const serializeAws_ec2LaunchTemplatesMonitoringRequest = (
  input: LaunchTemplatesMonitoringRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Enabled !== undefined) {
    entries["Enabled"] = input.Enabled;
  }
  return entries;
};

const serializeAws_ec2LaunchTemplateSpecification = (
  input: LaunchTemplateSpecification,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.LaunchTemplateId !== undefined) {
    entries["LaunchTemplateId"] = input.LaunchTemplateId;
  }
  if (input.LaunchTemplateName !== undefined) {
    entries["LaunchTemplateName"] = input.LaunchTemplateName;
  }
  if (input.Version !== undefined) {
    entries["Version"] = input.Version;
  }
  return entries;
};

const serializeAws_ec2LaunchTemplateSpotMarketOptionsRequest = (
  input: LaunchTemplateSpotMarketOptionsRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.BlockDurationMinutes !== undefined) {
    entries["BlockDurationMinutes"] = input.BlockDurationMinutes;
  }
  if (input.InstanceInterruptionBehavior !== undefined) {
    entries["InstanceInterruptionBehavior"] =
      input.InstanceInterruptionBehavior;
  }
  if (input.MaxPrice !== undefined) {
    entries["MaxPrice"] = input.MaxPrice;
  }
  if (input.SpotInstanceType !== undefined) {
    entries["SpotInstanceType"] = input.SpotInstanceType;
  }
  if (input.ValidUntil !== undefined) {
    entries["ValidUntil"] = input.ValidUntil.toISOString().split(".")[0] + "Z";
  }
  return entries;
};

const serializeAws_ec2LaunchTemplateTagSpecificationRequest = (
  input: LaunchTemplateTagSpecificationRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.ResourceType !== undefined) {
    entries["ResourceType"] = input.ResourceType;
  }
  if (input.Tags !== undefined) {
    const memberEntries = serializeAws_ec2TagList(input.Tags, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Tag.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2LaunchTemplateTagSpecificationRequestList = (
  input: LaunchTemplateTagSpecificationRequest[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    const memberEntries = serializeAws_ec2LaunchTemplateTagSpecificationRequest(
      entry,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      entries[
        `LaunchTemplateTagSpecificationRequest.${counter}.${key}`
      ] = value;
    });
    counter++;
  }
  return entries;
};

const serializeAws_ec2LicenseConfigurationRequest = (
  input: LicenseConfigurationRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.LicenseConfigurationArn !== undefined) {
    entries["LicenseConfigurationArn"] = input.LicenseConfigurationArn;
  }
  return entries;
};

const serializeAws_ec2LicenseSpecificationListRequest = (
  input: LicenseConfigurationRequest[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    const memberEntries = serializeAws_ec2LicenseConfigurationRequest(
      entry,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      entries[`Item.${counter}.${key}`] = value;
    });
    counter++;
  }
  return entries;
};

const serializeAws_ec2LoadBalancersConfig = (
  input: LoadBalancersConfig,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.ClassicLoadBalancersConfig !== undefined) {
    const memberEntries = serializeAws_ec2ClassicLoadBalancersConfig(
      input.ClassicLoadBalancersConfig,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `ClassicLoadBalancersConfig.${key}`;
      entries[loc] = value;
    });
  }
  if (input.TargetGroupsConfig !== undefined) {
    const memberEntries = serializeAws_ec2TargetGroupsConfig(
      input.TargetGroupsConfig,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `TargetGroupsConfig.${key}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2LoadPermissionListRequest = (
  input: LoadPermissionRequest[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    const memberEntries = serializeAws_ec2LoadPermissionRequest(entry, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      entries[`Item.${counter}.${key}`] = value;
    });
    counter++;
  }
  return entries;
};

const serializeAws_ec2LoadPermissionModifications = (
  input: LoadPermissionModifications,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Add !== undefined) {
    const memberEntries = serializeAws_ec2LoadPermissionListRequest(
      input.Add,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Add.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.Remove !== undefined) {
    const memberEntries = serializeAws_ec2LoadPermissionListRequest(
      input.Remove,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Remove.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2LoadPermissionRequest = (
  input: LoadPermissionRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Group !== undefined) {
    entries["Group"] = input.Group;
  }
  if (input.UserId !== undefined) {
    entries["UserId"] = input.UserId;
  }
  return entries;
};

const serializeAws_ec2LocalGatewayIdSet = (
  input: string[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    entries[`Item.${counter}`] = entry;
    counter++;
  }
  return entries;
};

const serializeAws_ec2LocalGatewayRouteTableIdSet = (
  input: string[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    entries[`Item.${counter}`] = entry;
    counter++;
  }
  return entries;
};

const serializeAws_ec2LocalGatewayRouteTableVirtualInterfaceGroupAssociationIdSet = (
  input: string[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    entries[`Item.${counter}`] = entry;
    counter++;
  }
  return entries;
};

const serializeAws_ec2LocalGatewayRouteTableVpcAssociationIdSet = (
  input: string[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    entries[`Item.${counter}`] = entry;
    counter++;
  }
  return entries;
};

const serializeAws_ec2LocalGatewayVirtualInterfaceGroupIdSet = (
  input: string[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    entries[`Item.${counter}`] = entry;
    counter++;
  }
  return entries;
};

const serializeAws_ec2LocalGatewayVirtualInterfaceIdSet = (
  input: string[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    entries[`Item.${counter}`] = entry;
    counter++;
  }
  return entries;
};

const serializeAws_ec2ModifyCapacityReservationRequest = (
  input: ModifyCapacityReservationRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.CapacityReservationId !== undefined) {
    entries["CapacityReservationId"] = input.CapacityReservationId;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.EndDate !== undefined) {
    entries["EndDate"] = input.EndDate.toISOString().split(".")[0] + "Z";
  }
  if (input.EndDateType !== undefined) {
    entries["EndDateType"] = input.EndDateType;
  }
  if (input.InstanceCount !== undefined) {
    entries["InstanceCount"] = input.InstanceCount;
  }
  return entries;
};

const serializeAws_ec2ModifyClientVpnEndpointRequest = (
  input: ModifyClientVpnEndpointRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.ClientVpnEndpointId !== undefined) {
    entries["ClientVpnEndpointId"] = input.ClientVpnEndpointId;
  }
  if (input.ConnectionLogOptions !== undefined) {
    const memberEntries = serializeAws_ec2ConnectionLogOptions(
      input.ConnectionLogOptions,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `ConnectionLogOptions.${key}`;
      entries[loc] = value;
    });
  }
  if (input.Description !== undefined) {
    entries["Description"] = input.Description;
  }
  if (input.DnsServers !== undefined) {
    const memberEntries = serializeAws_ec2DnsServersOptionsModifyStructure(
      input.DnsServers,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `DnsServers.${key}`;
      entries[loc] = value;
    });
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.ServerCertificateArn !== undefined) {
    entries["ServerCertificateArn"] = input.ServerCertificateArn;
  }
  if (input.SplitTunnel !== undefined) {
    entries["SplitTunnel"] = input.SplitTunnel;
  }
  if (input.VpnPort !== undefined) {
    entries["VpnPort"] = input.VpnPort;
  }
  return entries;
};

const serializeAws_ec2ModifyDefaultCreditSpecificationRequest = (
  input: ModifyDefaultCreditSpecificationRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.CpuCredits !== undefined) {
    entries["CpuCredits"] = input.CpuCredits;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.InstanceFamily !== undefined) {
    entries["InstanceFamily"] = input.InstanceFamily;
  }
  return entries;
};

const serializeAws_ec2ModifyEbsDefaultKmsKeyIdRequest = (
  input: ModifyEbsDefaultKmsKeyIdRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.KmsKeyId !== undefined) {
    entries["KmsKeyId"] = input.KmsKeyId;
  }
  return entries;
};

const serializeAws_ec2ModifyFleetRequest = (
  input: ModifyFleetRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.ExcessCapacityTerminationPolicy !== undefined) {
    entries["ExcessCapacityTerminationPolicy"] =
      input.ExcessCapacityTerminationPolicy;
  }
  if (input.FleetId !== undefined) {
    entries["FleetId"] = input.FleetId;
  }
  if (input.TargetCapacitySpecification !== undefined) {
    const memberEntries = serializeAws_ec2TargetCapacitySpecificationRequest(
      input.TargetCapacitySpecification,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `TargetCapacitySpecification.${key}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2ModifyFpgaImageAttributeRequest = (
  input: ModifyFpgaImageAttributeRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Attribute !== undefined) {
    entries["Attribute"] = input.Attribute;
  }
  if (input.Description !== undefined) {
    entries["Description"] = input.Description;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.FpgaImageId !== undefined) {
    entries["FpgaImageId"] = input.FpgaImageId;
  }
  if (input.LoadPermission !== undefined) {
    const memberEntries = serializeAws_ec2LoadPermissionModifications(
      input.LoadPermission,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `LoadPermission.${key}`;
      entries[loc] = value;
    });
  }
  if (input.Name !== undefined) {
    entries["Name"] = input.Name;
  }
  if (input.OperationType !== undefined) {
    entries["OperationType"] = input.OperationType;
  }
  if (input.ProductCodes !== undefined) {
    const memberEntries = serializeAws_ec2ProductCodeStringList(
      input.ProductCodes,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `ProductCode.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.UserGroups !== undefined) {
    const memberEntries = serializeAws_ec2UserGroupStringList(
      input.UserGroups,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `UserGroup.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.UserIds !== undefined) {
    const memberEntries = serializeAws_ec2UserIdStringList(
      input.UserIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `UserId.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2ModifyHostsRequest = (
  input: ModifyHostsRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.AutoPlacement !== undefined) {
    entries["AutoPlacement"] = input.AutoPlacement;
  }
  if (input.HostIds !== undefined) {
    const memberEntries = serializeAws_ec2RequestHostIdList(
      input.HostIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `HostId.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.HostRecovery !== undefined) {
    entries["HostRecovery"] = input.HostRecovery;
  }
  if (input.InstanceFamily !== undefined) {
    entries["InstanceFamily"] = input.InstanceFamily;
  }
  if (input.InstanceType !== undefined) {
    entries["InstanceType"] = input.InstanceType;
  }
  return entries;
};

const serializeAws_ec2ModifyIdentityIdFormatRequest = (
  input: ModifyIdentityIdFormatRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.PrincipalArn !== undefined) {
    entries["PrincipalArn"] = input.PrincipalArn;
  }
  if (input.Resource !== undefined) {
    entries["Resource"] = input.Resource;
  }
  if (input.UseLongIds !== undefined) {
    entries["UseLongIds"] = input.UseLongIds;
  }
  return entries;
};

const serializeAws_ec2ModifyIdFormatRequest = (
  input: ModifyIdFormatRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Resource !== undefined) {
    entries["Resource"] = input.Resource;
  }
  if (input.UseLongIds !== undefined) {
    entries["UseLongIds"] = input.UseLongIds;
  }
  return entries;
};

const serializeAws_ec2ModifyImageAttributeRequest = (
  input: ModifyImageAttributeRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Attribute !== undefined) {
    entries["Attribute"] = input.Attribute;
  }
  if (input.Description !== undefined) {
    const memberEntries = serializeAws_ec2AttributeValue(
      input.Description,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Description.${key}`;
      entries[loc] = value;
    });
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.ImageId !== undefined) {
    entries["ImageId"] = input.ImageId;
  }
  if (input.LaunchPermission !== undefined) {
    const memberEntries = serializeAws_ec2LaunchPermissionModifications(
      input.LaunchPermission,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `LaunchPermission.${key}`;
      entries[loc] = value;
    });
  }
  if (input.OperationType !== undefined) {
    entries["OperationType"] = input.OperationType;
  }
  if (input.ProductCodes !== undefined) {
    const memberEntries = serializeAws_ec2ProductCodeStringList(
      input.ProductCodes,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `ProductCode.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.UserGroups !== undefined) {
    const memberEntries = serializeAws_ec2UserGroupStringList(
      input.UserGroups,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `UserGroup.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.UserIds !== undefined) {
    const memberEntries = serializeAws_ec2UserIdStringList(
      input.UserIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `UserId.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.Value !== undefined) {
    entries["Value"] = input.Value;
  }
  return entries;
};

const serializeAws_ec2ModifyInstanceAttributeRequest = (
  input: ModifyInstanceAttributeRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Attribute !== undefined) {
    entries["Attribute"] = input.Attribute;
  }
  if (input.BlockDeviceMappings !== undefined) {
    const memberEntries = serializeAws_ec2InstanceBlockDeviceMappingSpecificationList(
      input.BlockDeviceMappings,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `BlockDeviceMapping.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.DisableApiTermination !== undefined) {
    const memberEntries = serializeAws_ec2AttributeBooleanValue(
      input.DisableApiTermination,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `DisableApiTermination.${key}`;
      entries[loc] = value;
    });
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.EbsOptimized !== undefined) {
    const memberEntries = serializeAws_ec2AttributeBooleanValue(
      input.EbsOptimized,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `EbsOptimized.${key}`;
      entries[loc] = value;
    });
  }
  if (input.EnaSupport !== undefined) {
    const memberEntries = serializeAws_ec2AttributeBooleanValue(
      input.EnaSupport,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `EnaSupport.${key}`;
      entries[loc] = value;
    });
  }
  if (input.Groups !== undefined) {
    const memberEntries = serializeAws_ec2GroupIdStringList(
      input.Groups,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `GroupId.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.InstanceId !== undefined) {
    entries["InstanceId"] = input.InstanceId;
  }
  if (input.InstanceInitiatedShutdownBehavior !== undefined) {
    const memberEntries = serializeAws_ec2AttributeValue(
      input.InstanceInitiatedShutdownBehavior,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `InstanceInitiatedShutdownBehavior.${key}`;
      entries[loc] = value;
    });
  }
  if (input.InstanceType !== undefined) {
    const memberEntries = serializeAws_ec2AttributeValue(
      input.InstanceType,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `InstanceType.${key}`;
      entries[loc] = value;
    });
  }
  if (input.Kernel !== undefined) {
    const memberEntries = serializeAws_ec2AttributeValue(input.Kernel, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Kernel.${key}`;
      entries[loc] = value;
    });
  }
  if (input.Ramdisk !== undefined) {
    const memberEntries = serializeAws_ec2AttributeValue(
      input.Ramdisk,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Ramdisk.${key}`;
      entries[loc] = value;
    });
  }
  if (input.SourceDestCheck !== undefined) {
    const memberEntries = serializeAws_ec2AttributeBooleanValue(
      input.SourceDestCheck,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `SourceDestCheck.${key}`;
      entries[loc] = value;
    });
  }
  if (input.SriovNetSupport !== undefined) {
    const memberEntries = serializeAws_ec2AttributeValue(
      input.SriovNetSupport,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `SriovNetSupport.${key}`;
      entries[loc] = value;
    });
  }
  if (input.UserData !== undefined) {
    const memberEntries = serializeAws_ec2BlobAttributeValue(
      input.UserData,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `UserData.${key}`;
      entries[loc] = value;
    });
  }
  if (input.Value !== undefined) {
    entries["Value"] = input.Value;
  }
  return entries;
};

const serializeAws_ec2ModifyInstanceCapacityReservationAttributesRequest = (
  input: ModifyInstanceCapacityReservationAttributesRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.CapacityReservationSpecification !== undefined) {
    const memberEntries = serializeAws_ec2CapacityReservationSpecification(
      input.CapacityReservationSpecification,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `CapacityReservationSpecification.${key}`;
      entries[loc] = value;
    });
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.InstanceId !== undefined) {
    entries["InstanceId"] = input.InstanceId;
  }
  return entries;
};

const serializeAws_ec2ModifyInstanceCreditSpecificationRequest = (
  input: ModifyInstanceCreditSpecificationRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.ClientToken !== undefined) {
    entries["ClientToken"] = input.ClientToken;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.InstanceCreditSpecifications !== undefined) {
    const memberEntries = serializeAws_ec2InstanceCreditSpecificationListRequest(
      input.InstanceCreditSpecifications,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `InstanceCreditSpecification.${key.substring(
        key.indexOf(".") + 1
      )}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2ModifyInstanceEventStartTimeRequest = (
  input: ModifyInstanceEventStartTimeRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.InstanceEventId !== undefined) {
    entries["InstanceEventId"] = input.InstanceEventId;
  }
  if (input.InstanceId !== undefined) {
    entries["InstanceId"] = input.InstanceId;
  }
  if (input.NotBefore !== undefined) {
    entries["NotBefore"] = input.NotBefore.toISOString().split(".")[0] + "Z";
  }
  return entries;
};

const serializeAws_ec2ModifyInstanceMetadataOptionsRequest = (
  input: ModifyInstanceMetadataOptionsRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.HttpEndpoint !== undefined) {
    entries["HttpEndpoint"] = input.HttpEndpoint;
  }
  if (input.HttpPutResponseHopLimit !== undefined) {
    entries["HttpPutResponseHopLimit"] = input.HttpPutResponseHopLimit;
  }
  if (input.HttpTokens !== undefined) {
    entries["HttpTokens"] = input.HttpTokens;
  }
  if (input.InstanceId !== undefined) {
    entries["InstanceId"] = input.InstanceId;
  }
  return entries;
};

const serializeAws_ec2ModifyInstancePlacementRequest = (
  input: ModifyInstancePlacementRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Affinity !== undefined) {
    entries["Affinity"] = input.Affinity;
  }
  if (input.GroupName !== undefined) {
    entries["GroupName"] = input.GroupName;
  }
  if (input.HostId !== undefined) {
    entries["HostId"] = input.HostId;
  }
  if (input.HostResourceGroupArn !== undefined) {
    entries["HostResourceGroupArn"] = input.HostResourceGroupArn;
  }
  if (input.InstanceId !== undefined) {
    entries["InstanceId"] = input.InstanceId;
  }
  if (input.PartitionNumber !== undefined) {
    entries["PartitionNumber"] = input.PartitionNumber;
  }
  if (input.Tenancy !== undefined) {
    entries["Tenancy"] = input.Tenancy;
  }
  return entries;
};

const serializeAws_ec2ModifyLaunchTemplateRequest = (
  input: ModifyLaunchTemplateRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.ClientToken !== undefined) {
    entries["ClientToken"] = input.ClientToken;
  }
  if (input.DefaultVersion !== undefined) {
    entries["SetDefaultVersion"] = input.DefaultVersion;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.LaunchTemplateId !== undefined) {
    entries["LaunchTemplateId"] = input.LaunchTemplateId;
  }
  if (input.LaunchTemplateName !== undefined) {
    entries["LaunchTemplateName"] = input.LaunchTemplateName;
  }
  return entries;
};

const serializeAws_ec2ModifyNetworkInterfaceAttributeRequest = (
  input: ModifyNetworkInterfaceAttributeRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Attachment !== undefined) {
    const memberEntries = serializeAws_ec2NetworkInterfaceAttachmentChanges(
      input.Attachment,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Attachment.${key}`;
      entries[loc] = value;
    });
  }
  if (input.Description !== undefined) {
    const memberEntries = serializeAws_ec2AttributeValue(
      input.Description,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Description.${key}`;
      entries[loc] = value;
    });
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Groups !== undefined) {
    const memberEntries = serializeAws_ec2SecurityGroupIdStringList(
      input.Groups,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `SecurityGroupId.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.NetworkInterfaceId !== undefined) {
    entries["NetworkInterfaceId"] = input.NetworkInterfaceId;
  }
  if (input.SourceDestCheck !== undefined) {
    const memberEntries = serializeAws_ec2AttributeBooleanValue(
      input.SourceDestCheck,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `SourceDestCheck.${key}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2ModifyReservedInstancesRequest = (
  input: ModifyReservedInstancesRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.ClientToken !== undefined) {
    entries["ClientToken"] = input.ClientToken;
  }
  if (input.ReservedInstancesIds !== undefined) {
    const memberEntries = serializeAws_ec2ReservedInstancesIdStringList(
      input.ReservedInstancesIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `ReservedInstancesId.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.TargetConfigurations !== undefined) {
    const memberEntries = serializeAws_ec2ReservedInstancesConfigurationList(
      input.TargetConfigurations,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `ReservedInstancesConfigurationSetItemType.${key.substring(
        key.indexOf(".") + 1
      )}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2ModifySnapshotAttributeRequest = (
  input: ModifySnapshotAttributeRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Attribute !== undefined) {
    entries["Attribute"] = input.Attribute;
  }
  if (input.CreateVolumePermission !== undefined) {
    const memberEntries = serializeAws_ec2CreateVolumePermissionModifications(
      input.CreateVolumePermission,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `CreateVolumePermission.${key}`;
      entries[loc] = value;
    });
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.GroupNames !== undefined) {
    const memberEntries = serializeAws_ec2GroupNameStringList(
      input.GroupNames,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `UserGroup.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.OperationType !== undefined) {
    entries["OperationType"] = input.OperationType;
  }
  if (input.SnapshotId !== undefined) {
    entries["SnapshotId"] = input.SnapshotId;
  }
  if (input.UserIds !== undefined) {
    const memberEntries = serializeAws_ec2UserIdStringList(
      input.UserIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `UserId.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2ModifySpotFleetRequestRequest = (
  input: ModifySpotFleetRequestRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.ExcessCapacityTerminationPolicy !== undefined) {
    entries["ExcessCapacityTerminationPolicy"] =
      input.ExcessCapacityTerminationPolicy;
  }
  if (input.OnDemandTargetCapacity !== undefined) {
    entries["OnDemandTargetCapacity"] = input.OnDemandTargetCapacity;
  }
  if (input.SpotFleetRequestId !== undefined) {
    entries["SpotFleetRequestId"] = input.SpotFleetRequestId;
  }
  if (input.TargetCapacity !== undefined) {
    entries["TargetCapacity"] = input.TargetCapacity;
  }
  return entries;
};

const serializeAws_ec2ModifySubnetAttributeRequest = (
  input: ModifySubnetAttributeRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.AssignIpv6AddressOnCreation !== undefined) {
    const memberEntries = serializeAws_ec2AttributeBooleanValue(
      input.AssignIpv6AddressOnCreation,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `AssignIpv6AddressOnCreation.${key}`;
      entries[loc] = value;
    });
  }
  if (input.MapPublicIpOnLaunch !== undefined) {
    const memberEntries = serializeAws_ec2AttributeBooleanValue(
      input.MapPublicIpOnLaunch,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `MapPublicIpOnLaunch.${key}`;
      entries[loc] = value;
    });
  }
  if (input.SubnetId !== undefined) {
    entries["SubnetId"] = input.SubnetId;
  }
  return entries;
};

const serializeAws_ec2ModifyTrafficMirrorFilterNetworkServicesRequest = (
  input: ModifyTrafficMirrorFilterNetworkServicesRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.AddNetworkServices !== undefined) {
    const memberEntries = serializeAws_ec2TrafficMirrorNetworkServiceList(
      input.AddNetworkServices,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `AddNetworkService.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.RemoveNetworkServices !== undefined) {
    const memberEntries = serializeAws_ec2TrafficMirrorNetworkServiceList(
      input.RemoveNetworkServices,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `RemoveNetworkService.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.TrafficMirrorFilterId !== undefined) {
    entries["TrafficMirrorFilterId"] = input.TrafficMirrorFilterId;
  }
  return entries;
};

const serializeAws_ec2ModifyTrafficMirrorFilterRuleRequest = (
  input: ModifyTrafficMirrorFilterRuleRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Description !== undefined) {
    entries["Description"] = input.Description;
  }
  if (input.DestinationCidrBlock !== undefined) {
    entries["DestinationCidrBlock"] = input.DestinationCidrBlock;
  }
  if (input.DestinationPortRange !== undefined) {
    const memberEntries = serializeAws_ec2TrafficMirrorPortRangeRequest(
      input.DestinationPortRange,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `DestinationPortRange.${key}`;
      entries[loc] = value;
    });
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Protocol !== undefined) {
    entries["Protocol"] = input.Protocol;
  }
  if (input.RemoveFields !== undefined) {
    const memberEntries = serializeAws_ec2TrafficMirrorFilterRuleFieldList(
      input.RemoveFields,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `RemoveField.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.RuleAction !== undefined) {
    entries["RuleAction"] = input.RuleAction;
  }
  if (input.RuleNumber !== undefined) {
    entries["RuleNumber"] = input.RuleNumber;
  }
  if (input.SourceCidrBlock !== undefined) {
    entries["SourceCidrBlock"] = input.SourceCidrBlock;
  }
  if (input.SourcePortRange !== undefined) {
    const memberEntries = serializeAws_ec2TrafficMirrorPortRangeRequest(
      input.SourcePortRange,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `SourcePortRange.${key}`;
      entries[loc] = value;
    });
  }
  if (input.TrafficDirection !== undefined) {
    entries["TrafficDirection"] = input.TrafficDirection;
  }
  if (input.TrafficMirrorFilterRuleId !== undefined) {
    entries["TrafficMirrorFilterRuleId"] = input.TrafficMirrorFilterRuleId;
  }
  return entries;
};

const serializeAws_ec2ModifyTrafficMirrorSessionRequest = (
  input: ModifyTrafficMirrorSessionRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Description !== undefined) {
    entries["Description"] = input.Description;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.PacketLength !== undefined) {
    entries["PacketLength"] = input.PacketLength;
  }
  if (input.RemoveFields !== undefined) {
    const memberEntries = serializeAws_ec2TrafficMirrorSessionFieldList(
      input.RemoveFields,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `RemoveField.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.SessionNumber !== undefined) {
    entries["SessionNumber"] = input.SessionNumber;
  }
  if (input.TrafficMirrorFilterId !== undefined) {
    entries["TrafficMirrorFilterId"] = input.TrafficMirrorFilterId;
  }
  if (input.TrafficMirrorSessionId !== undefined) {
    entries["TrafficMirrorSessionId"] = input.TrafficMirrorSessionId;
  }
  if (input.TrafficMirrorTargetId !== undefined) {
    entries["TrafficMirrorTargetId"] = input.TrafficMirrorTargetId;
  }
  if (input.VirtualNetworkId !== undefined) {
    entries["VirtualNetworkId"] = input.VirtualNetworkId;
  }
  return entries;
};

const serializeAws_ec2ModifyTransitGatewayVpcAttachmentRequest = (
  input: ModifyTransitGatewayVpcAttachmentRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.AddSubnetIds !== undefined) {
    const memberEntries = serializeAws_ec2ValueStringList(
      input.AddSubnetIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `AddSubnetIds.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Options !== undefined) {
    const memberEntries = serializeAws_ec2ModifyTransitGatewayVpcAttachmentRequestOptions(
      input.Options,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Options.${key}`;
      entries[loc] = value;
    });
  }
  if (input.RemoveSubnetIds !== undefined) {
    const memberEntries = serializeAws_ec2ValueStringList(
      input.RemoveSubnetIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `RemoveSubnetIds.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.TransitGatewayAttachmentId !== undefined) {
    entries["TransitGatewayAttachmentId"] = input.TransitGatewayAttachmentId;
  }
  return entries;
};

const serializeAws_ec2ModifyTransitGatewayVpcAttachmentRequestOptions = (
  input: ModifyTransitGatewayVpcAttachmentRequestOptions,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DnsSupport !== undefined) {
    entries["DnsSupport"] = input.DnsSupport;
  }
  if (input.Ipv6Support !== undefined) {
    entries["Ipv6Support"] = input.Ipv6Support;
  }
  return entries;
};

const serializeAws_ec2ModifyVolumeAttributeRequest = (
  input: ModifyVolumeAttributeRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.AutoEnableIO !== undefined) {
    const memberEntries = serializeAws_ec2AttributeBooleanValue(
      input.AutoEnableIO,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `AutoEnableIO.${key}`;
      entries[loc] = value;
    });
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.VolumeId !== undefined) {
    entries["VolumeId"] = input.VolumeId;
  }
  return entries;
};

const serializeAws_ec2ModifyVolumeRequest = (
  input: ModifyVolumeRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Iops !== undefined) {
    entries["Iops"] = input.Iops;
  }
  if (input.Size !== undefined) {
    entries["Size"] = input.Size;
  }
  if (input.VolumeId !== undefined) {
    entries["VolumeId"] = input.VolumeId;
  }
  if (input.VolumeType !== undefined) {
    entries["VolumeType"] = input.VolumeType;
  }
  return entries;
};

const serializeAws_ec2ModifyVpcAttributeRequest = (
  input: ModifyVpcAttributeRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.EnableDnsHostnames !== undefined) {
    const memberEntries = serializeAws_ec2AttributeBooleanValue(
      input.EnableDnsHostnames,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `EnableDnsHostnames.${key}`;
      entries[loc] = value;
    });
  }
  if (input.EnableDnsSupport !== undefined) {
    const memberEntries = serializeAws_ec2AttributeBooleanValue(
      input.EnableDnsSupport,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `EnableDnsSupport.${key}`;
      entries[loc] = value;
    });
  }
  if (input.VpcId !== undefined) {
    entries["VpcId"] = input.VpcId;
  }
  return entries;
};

const serializeAws_ec2ModifyVpcEndpointConnectionNotificationRequest = (
  input: ModifyVpcEndpointConnectionNotificationRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.ConnectionEvents !== undefined) {
    const memberEntries = serializeAws_ec2ValueStringList(
      input.ConnectionEvents,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `ConnectionEvents.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.ConnectionNotificationArn !== undefined) {
    entries["ConnectionNotificationArn"] = input.ConnectionNotificationArn;
  }
  if (input.ConnectionNotificationId !== undefined) {
    entries["ConnectionNotificationId"] = input.ConnectionNotificationId;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  return entries;
};

const serializeAws_ec2ModifyVpcEndpointRequest = (
  input: ModifyVpcEndpointRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.AddRouteTableIds !== undefined) {
    const memberEntries = serializeAws_ec2ValueStringList(
      input.AddRouteTableIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `AddRouteTableId.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.AddSecurityGroupIds !== undefined) {
    const memberEntries = serializeAws_ec2ValueStringList(
      input.AddSecurityGroupIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `AddSecurityGroupId.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.AddSubnetIds !== undefined) {
    const memberEntries = serializeAws_ec2ValueStringList(
      input.AddSubnetIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `AddSubnetId.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.PolicyDocument !== undefined) {
    entries["PolicyDocument"] = input.PolicyDocument;
  }
  if (input.PrivateDnsEnabled !== undefined) {
    entries["PrivateDnsEnabled"] = input.PrivateDnsEnabled;
  }
  if (input.RemoveRouteTableIds !== undefined) {
    const memberEntries = serializeAws_ec2ValueStringList(
      input.RemoveRouteTableIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `RemoveRouteTableId.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.RemoveSecurityGroupIds !== undefined) {
    const memberEntries = serializeAws_ec2ValueStringList(
      input.RemoveSecurityGroupIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `RemoveSecurityGroupId.${key.substring(
        key.indexOf(".") + 1
      )}`;
      entries[loc] = value;
    });
  }
  if (input.RemoveSubnetIds !== undefined) {
    const memberEntries = serializeAws_ec2ValueStringList(
      input.RemoveSubnetIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `RemoveSubnetId.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.ResetPolicy !== undefined) {
    entries["ResetPolicy"] = input.ResetPolicy;
  }
  if (input.VpcEndpointId !== undefined) {
    entries["VpcEndpointId"] = input.VpcEndpointId;
  }
  return entries;
};

const serializeAws_ec2ModifyVpcEndpointServiceConfigurationRequest = (
  input: ModifyVpcEndpointServiceConfigurationRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.AcceptanceRequired !== undefined) {
    entries["AcceptanceRequired"] = input.AcceptanceRequired;
  }
  if (input.AddNetworkLoadBalancerArns !== undefined) {
    const memberEntries = serializeAws_ec2ValueStringList(
      input.AddNetworkLoadBalancerArns,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `AddNetworkLoadBalancerArn.${key.substring(
        key.indexOf(".") + 1
      )}`;
      entries[loc] = value;
    });
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.PrivateDnsName !== undefined) {
    entries["PrivateDnsName"] = input.PrivateDnsName;
  }
  if (input.RemoveNetworkLoadBalancerArns !== undefined) {
    const memberEntries = serializeAws_ec2ValueStringList(
      input.RemoveNetworkLoadBalancerArns,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `RemoveNetworkLoadBalancerArn.${key.substring(
        key.indexOf(".") + 1
      )}`;
      entries[loc] = value;
    });
  }
  if (input.RemovePrivateDnsName !== undefined) {
    entries["RemovePrivateDnsName"] = input.RemovePrivateDnsName;
  }
  if (input.ServiceId !== undefined) {
    entries["ServiceId"] = input.ServiceId;
  }
  return entries;
};

const serializeAws_ec2ModifyVpcEndpointServicePermissionsRequest = (
  input: ModifyVpcEndpointServicePermissionsRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.AddAllowedPrincipals !== undefined) {
    const memberEntries = serializeAws_ec2ValueStringList(
      input.AddAllowedPrincipals,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `AddAllowedPrincipals.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.RemoveAllowedPrincipals !== undefined) {
    const memberEntries = serializeAws_ec2ValueStringList(
      input.RemoveAllowedPrincipals,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `RemoveAllowedPrincipals.${key.substring(
        key.indexOf(".") + 1
      )}`;
      entries[loc] = value;
    });
  }
  if (input.ServiceId !== undefined) {
    entries["ServiceId"] = input.ServiceId;
  }
  return entries;
};

const serializeAws_ec2ModifyVpcPeeringConnectionOptionsRequest = (
  input: ModifyVpcPeeringConnectionOptionsRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.AccepterPeeringConnectionOptions !== undefined) {
    const memberEntries = serializeAws_ec2PeeringConnectionOptionsRequest(
      input.AccepterPeeringConnectionOptions,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `AccepterPeeringConnectionOptions.${key}`;
      entries[loc] = value;
    });
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.RequesterPeeringConnectionOptions !== undefined) {
    const memberEntries = serializeAws_ec2PeeringConnectionOptionsRequest(
      input.RequesterPeeringConnectionOptions,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `RequesterPeeringConnectionOptions.${key}`;
      entries[loc] = value;
    });
  }
  if (input.VpcPeeringConnectionId !== undefined) {
    entries["VpcPeeringConnectionId"] = input.VpcPeeringConnectionId;
  }
  return entries;
};

const serializeAws_ec2ModifyVpcTenancyRequest = (
  input: ModifyVpcTenancyRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.InstanceTenancy !== undefined) {
    entries["InstanceTenancy"] = input.InstanceTenancy;
  }
  if (input.VpcId !== undefined) {
    entries["VpcId"] = input.VpcId;
  }
  return entries;
};

const serializeAws_ec2ModifyVpnConnectionRequest = (
  input: ModifyVpnConnectionRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.CustomerGatewayId !== undefined) {
    entries["CustomerGatewayId"] = input.CustomerGatewayId;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.TransitGatewayId !== undefined) {
    entries["TransitGatewayId"] = input.TransitGatewayId;
  }
  if (input.VpnConnectionId !== undefined) {
    entries["VpnConnectionId"] = input.VpnConnectionId;
  }
  if (input.VpnGatewayId !== undefined) {
    entries["VpnGatewayId"] = input.VpnGatewayId;
  }
  return entries;
};

const serializeAws_ec2ModifyVpnTunnelCertificateRequest = (
  input: ModifyVpnTunnelCertificateRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.VpnConnectionId !== undefined) {
    entries["VpnConnectionId"] = input.VpnConnectionId;
  }
  if (input.VpnTunnelOutsideIpAddress !== undefined) {
    entries["VpnTunnelOutsideIpAddress"] = input.VpnTunnelOutsideIpAddress;
  }
  return entries;
};

const serializeAws_ec2ModifyVpnTunnelOptionsRequest = (
  input: ModifyVpnTunnelOptionsRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.TunnelOptions !== undefined) {
    const memberEntries = serializeAws_ec2ModifyVpnTunnelOptionsSpecification(
      input.TunnelOptions,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `TunnelOptions.${key}`;
      entries[loc] = value;
    });
  }
  if (input.VpnConnectionId !== undefined) {
    entries["VpnConnectionId"] = input.VpnConnectionId;
  }
  if (input.VpnTunnelOutsideIpAddress !== undefined) {
    entries["VpnTunnelOutsideIpAddress"] = input.VpnTunnelOutsideIpAddress;
  }
  return entries;
};

const serializeAws_ec2ModifyVpnTunnelOptionsSpecification = (
  input: ModifyVpnTunnelOptionsSpecification,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DPDTimeoutSeconds !== undefined) {
    entries["DPDTimeoutSeconds"] = input.DPDTimeoutSeconds;
  }
  if (input.IKEVersions !== undefined) {
    const memberEntries = serializeAws_ec2IKEVersionsRequestList(
      input.IKEVersions,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `IKEVersion.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.Phase1DHGroupNumbers !== undefined) {
    const memberEntries = serializeAws_ec2Phase1DHGroupNumbersRequestList(
      input.Phase1DHGroupNumbers,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Phase1DHGroupNumber.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.Phase1EncryptionAlgorithms !== undefined) {
    const memberEntries = serializeAws_ec2Phase1EncryptionAlgorithmsRequestList(
      input.Phase1EncryptionAlgorithms,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Phase1EncryptionAlgorithm.${key.substring(
        key.indexOf(".") + 1
      )}`;
      entries[loc] = value;
    });
  }
  if (input.Phase1IntegrityAlgorithms !== undefined) {
    const memberEntries = serializeAws_ec2Phase1IntegrityAlgorithmsRequestList(
      input.Phase1IntegrityAlgorithms,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Phase1IntegrityAlgorithm.${key.substring(
        key.indexOf(".") + 1
      )}`;
      entries[loc] = value;
    });
  }
  if (input.Phase1LifetimeSeconds !== undefined) {
    entries["Phase1LifetimeSeconds"] = input.Phase1LifetimeSeconds;
  }
  if (input.Phase2DHGroupNumbers !== undefined) {
    const memberEntries = serializeAws_ec2Phase2DHGroupNumbersRequestList(
      input.Phase2DHGroupNumbers,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Phase2DHGroupNumber.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.Phase2EncryptionAlgorithms !== undefined) {
    const memberEntries = serializeAws_ec2Phase2EncryptionAlgorithmsRequestList(
      input.Phase2EncryptionAlgorithms,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Phase2EncryptionAlgorithm.${key.substring(
        key.indexOf(".") + 1
      )}`;
      entries[loc] = value;
    });
  }
  if (input.Phase2IntegrityAlgorithms !== undefined) {
    const memberEntries = serializeAws_ec2Phase2IntegrityAlgorithmsRequestList(
      input.Phase2IntegrityAlgorithms,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Phase2IntegrityAlgorithm.${key.substring(
        key.indexOf(".") + 1
      )}`;
      entries[loc] = value;
    });
  }
  if (input.Phase2LifetimeSeconds !== undefined) {
    entries["Phase2LifetimeSeconds"] = input.Phase2LifetimeSeconds;
  }
  if (input.PreSharedKey !== undefined) {
    entries["PreSharedKey"] = input.PreSharedKey;
  }
  if (input.RekeyFuzzPercentage !== undefined) {
    entries["RekeyFuzzPercentage"] = input.RekeyFuzzPercentage;
  }
  if (input.RekeyMarginTimeSeconds !== undefined) {
    entries["RekeyMarginTimeSeconds"] = input.RekeyMarginTimeSeconds;
  }
  if (input.ReplayWindowSize !== undefined) {
    entries["ReplayWindowSize"] = input.ReplayWindowSize;
  }
  if (input.TunnelInsideCidr !== undefined) {
    entries["TunnelInsideCidr"] = input.TunnelInsideCidr;
  }
  return entries;
};

const serializeAws_ec2MonitorInstancesRequest = (
  input: MonitorInstancesRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.InstanceIds !== undefined) {
    const memberEntries = serializeAws_ec2InstanceIdStringList(
      input.InstanceIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `InstanceId.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2MoveAddressToVpcRequest = (
  input: MoveAddressToVpcRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.PublicIp !== undefined) {
    entries["PublicIp"] = input.PublicIp;
  }
  return entries;
};

const serializeAws_ec2NetworkInterfaceAttachmentChanges = (
  input: NetworkInterfaceAttachmentChanges,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.AttachmentId !== undefined) {
    entries["AttachmentId"] = input.AttachmentId;
  }
  if (input.DeleteOnTermination !== undefined) {
    entries["DeleteOnTermination"] = input.DeleteOnTermination;
  }
  return entries;
};

const serializeAws_ec2NetworkInterfaceIdList = (
  input: string[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    entries[`Item.${counter}`] = entry;
    counter++;
  }
  return entries;
};

const serializeAws_ec2NetworkInterfacePermissionIdList = (
  input: string[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    entries[`Member.${counter}`] = entry;
    counter++;
  }
  return entries;
};

const serializeAws_ec2NewDhcpConfiguration = (
  input: NewDhcpConfiguration,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Key !== undefined) {
    entries["Key"] = input.Key;
  }
  if (input.Values !== undefined) {
    const memberEntries = serializeAws_ec2ValueStringList(
      input.Values,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Value.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2NewDhcpConfigurationList = (
  input: NewDhcpConfiguration[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    const memberEntries = serializeAws_ec2NewDhcpConfiguration(entry, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      entries[`Item.${counter}.${key}`] = value;
    });
    counter++;
  }
  return entries;
};

const serializeAws_ec2OccurrenceDayRequestSet = (
  input: number[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    entries[`OccurenceDay.${counter}`] = entry;
    counter++;
  }
  return entries;
};

const serializeAws_ec2OnDemandOptionsRequest = (
  input: OnDemandOptionsRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.AllocationStrategy !== undefined) {
    entries["AllocationStrategy"] = input.AllocationStrategy;
  }
  if (input.CapacityReservationOptions !== undefined) {
    const memberEntries = serializeAws_ec2CapacityReservationOptionsRequest(
      input.CapacityReservationOptions,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `CapacityReservationOptions.${key}`;
      entries[loc] = value;
    });
  }
  if (input.MaxTotalPrice !== undefined) {
    entries["MaxTotalPrice"] = input.MaxTotalPrice;
  }
  if (input.MinTargetCapacity !== undefined) {
    entries["MinTargetCapacity"] = input.MinTargetCapacity;
  }
  if (input.SingleAvailabilityZone !== undefined) {
    entries["SingleAvailabilityZone"] = input.SingleAvailabilityZone;
  }
  if (input.SingleInstanceType !== undefined) {
    entries["SingleInstanceType"] = input.SingleInstanceType;
  }
  return entries;
};

const serializeAws_ec2OwnerStringList = (
  input: string[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    entries[`Owner.${counter}`] = entry;
    counter++;
  }
  return entries;
};

const serializeAws_ec2PeeringConnectionOptionsRequest = (
  input: PeeringConnectionOptionsRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.AllowDnsResolutionFromRemoteVpc !== undefined) {
    entries["AllowDnsResolutionFromRemoteVpc"] =
      input.AllowDnsResolutionFromRemoteVpc;
  }
  if (input.AllowEgressFromLocalClassicLinkToRemoteVpc !== undefined) {
    entries["AllowEgressFromLocalClassicLinkToRemoteVpc"] =
      input.AllowEgressFromLocalClassicLinkToRemoteVpc;
  }
  if (input.AllowEgressFromLocalVpcToRemoteClassicLink !== undefined) {
    entries["AllowEgressFromLocalVpcToRemoteClassicLink"] =
      input.AllowEgressFromLocalVpcToRemoteClassicLink;
  }
  return entries;
};

const serializeAws_ec2Phase1DHGroupNumbersRequestList = (
  input: Phase1DHGroupNumbersRequestListValue[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    const memberEntries = serializeAws_ec2Phase1DHGroupNumbersRequestListValue(
      entry,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      entries[`Item.${counter}.${key}`] = value;
    });
    counter++;
  }
  return entries;
};

const serializeAws_ec2Phase1DHGroupNumbersRequestListValue = (
  input: Phase1DHGroupNumbersRequestListValue,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Value !== undefined) {
    entries["Value"] = input.Value;
  }
  return entries;
};

const serializeAws_ec2Phase1EncryptionAlgorithmsRequestList = (
  input: Phase1EncryptionAlgorithmsRequestListValue[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    const memberEntries = serializeAws_ec2Phase1EncryptionAlgorithmsRequestListValue(
      entry,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      entries[`Item.${counter}.${key}`] = value;
    });
    counter++;
  }
  return entries;
};

const serializeAws_ec2Phase1EncryptionAlgorithmsRequestListValue = (
  input: Phase1EncryptionAlgorithmsRequestListValue,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Value !== undefined) {
    entries["Value"] = input.Value;
  }
  return entries;
};

const serializeAws_ec2Phase1IntegrityAlgorithmsRequestList = (
  input: Phase1IntegrityAlgorithmsRequestListValue[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    const memberEntries = serializeAws_ec2Phase1IntegrityAlgorithmsRequestListValue(
      entry,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      entries[`Item.${counter}.${key}`] = value;
    });
    counter++;
  }
  return entries;
};

const serializeAws_ec2Phase1IntegrityAlgorithmsRequestListValue = (
  input: Phase1IntegrityAlgorithmsRequestListValue,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Value !== undefined) {
    entries["Value"] = input.Value;
  }
  return entries;
};

const serializeAws_ec2Phase2DHGroupNumbersRequestList = (
  input: Phase2DHGroupNumbersRequestListValue[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    const memberEntries = serializeAws_ec2Phase2DHGroupNumbersRequestListValue(
      entry,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      entries[`Item.${counter}.${key}`] = value;
    });
    counter++;
  }
  return entries;
};

const serializeAws_ec2Phase2DHGroupNumbersRequestListValue = (
  input: Phase2DHGroupNumbersRequestListValue,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Value !== undefined) {
    entries["Value"] = input.Value;
  }
  return entries;
};

const serializeAws_ec2Phase2EncryptionAlgorithmsRequestList = (
  input: Phase2EncryptionAlgorithmsRequestListValue[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    const memberEntries = serializeAws_ec2Phase2EncryptionAlgorithmsRequestListValue(
      entry,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      entries[`Item.${counter}.${key}`] = value;
    });
    counter++;
  }
  return entries;
};

const serializeAws_ec2Phase2EncryptionAlgorithmsRequestListValue = (
  input: Phase2EncryptionAlgorithmsRequestListValue,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Value !== undefined) {
    entries["Value"] = input.Value;
  }
  return entries;
};

const serializeAws_ec2Phase2IntegrityAlgorithmsRequestList = (
  input: Phase2IntegrityAlgorithmsRequestListValue[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    const memberEntries = serializeAws_ec2Phase2IntegrityAlgorithmsRequestListValue(
      entry,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      entries[`Item.${counter}.${key}`] = value;
    });
    counter++;
  }
  return entries;
};

const serializeAws_ec2Phase2IntegrityAlgorithmsRequestListValue = (
  input: Phase2IntegrityAlgorithmsRequestListValue,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Value !== undefined) {
    entries["Value"] = input.Value;
  }
  return entries;
};

const serializeAws_ec2Placement = (
  input: Placement,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Affinity !== undefined) {
    entries["Affinity"] = input.Affinity;
  }
  if (input.AvailabilityZone !== undefined) {
    entries["AvailabilityZone"] = input.AvailabilityZone;
  }
  if (input.GroupName !== undefined) {
    entries["GroupName"] = input.GroupName;
  }
  if (input.HostId !== undefined) {
    entries["HostId"] = input.HostId;
  }
  if (input.HostResourceGroupArn !== undefined) {
    entries["HostResourceGroupArn"] = input.HostResourceGroupArn;
  }
  if (input.PartitionNumber !== undefined) {
    entries["PartitionNumber"] = input.PartitionNumber;
  }
  if (input.SpreadDomain !== undefined) {
    entries["SpreadDomain"] = input.SpreadDomain;
  }
  if (input.Tenancy !== undefined) {
    entries["Tenancy"] = input.Tenancy;
  }
  return entries;
};

const serializeAws_ec2PlacementGroupIdStringList = (
  input: string[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    entries[`GroupId.${counter}`] = entry;
    counter++;
  }
  return entries;
};

const serializeAws_ec2PlacementGroupStringList = (
  input: string[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    entries[`Member.${counter}`] = entry;
    counter++;
  }
  return entries;
};

const serializeAws_ec2PortRange = (
  input: PortRange,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.From !== undefined) {
    entries["From"] = input.From;
  }
  if (input.To !== undefined) {
    entries["To"] = input.To;
  }
  return entries;
};

const serializeAws_ec2PrefixListId = (
  input: PrefixListId,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Description !== undefined) {
    entries["Description"] = input.Description;
  }
  if (input.PrefixListId !== undefined) {
    entries["PrefixListId"] = input.PrefixListId;
  }
  return entries;
};

const serializeAws_ec2PrefixListIdList = (
  input: PrefixListId[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    const memberEntries = serializeAws_ec2PrefixListId(entry, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      entries[`Item.${counter}.${key}`] = value;
    });
    counter++;
  }
  return entries;
};

const serializeAws_ec2PriceScheduleSpecification = (
  input: PriceScheduleSpecification,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.CurrencyCode !== undefined) {
    entries["CurrencyCode"] = input.CurrencyCode;
  }
  if (input.Price !== undefined) {
    entries["Price"] = input.Price;
  }
  if (input.Term !== undefined) {
    entries["Term"] = input.Term;
  }
  return entries;
};

const serializeAws_ec2PriceScheduleSpecificationList = (
  input: PriceScheduleSpecification[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    const memberEntries = serializeAws_ec2PriceScheduleSpecification(
      entry,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      entries[`Item.${counter}.${key}`] = value;
    });
    counter++;
  }
  return entries;
};

const serializeAws_ec2PrivateIpAddressConfigSet = (
  input: ScheduledInstancesPrivateIpAddressConfig[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    const memberEntries = serializeAws_ec2ScheduledInstancesPrivateIpAddressConfig(
      entry,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      entries[`PrivateIpAddressConfigSet.${counter}.${key}`] = value;
    });
    counter++;
  }
  return entries;
};

const serializeAws_ec2PrivateIpAddressSpecification = (
  input: PrivateIpAddressSpecification,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Primary !== undefined) {
    entries["Primary"] = input.Primary;
  }
  if (input.PrivateIpAddress !== undefined) {
    entries["PrivateIpAddress"] = input.PrivateIpAddress;
  }
  return entries;
};

const serializeAws_ec2PrivateIpAddressSpecificationList = (
  input: PrivateIpAddressSpecification[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    const memberEntries = serializeAws_ec2PrivateIpAddressSpecification(
      entry,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      entries[`Item.${counter}.${key}`] = value;
    });
    counter++;
  }
  return entries;
};

const serializeAws_ec2PrivateIpAddressStringList = (
  input: string[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    entries[`PrivateIpAddress.${counter}`] = entry;
    counter++;
  }
  return entries;
};

const serializeAws_ec2ProductCodeStringList = (
  input: string[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    entries[`ProductCode.${counter}`] = entry;
    counter++;
  }
  return entries;
};

const serializeAws_ec2ProductDescriptionList = (
  input: string[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    entries[`Member.${counter}`] = entry;
    counter++;
  }
  return entries;
};

const serializeAws_ec2ProvisionByoipCidrRequest = (
  input: ProvisionByoipCidrRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Cidr !== undefined) {
    entries["Cidr"] = input.Cidr;
  }
  if (input.CidrAuthorizationContext !== undefined) {
    const memberEntries = serializeAws_ec2CidrAuthorizationContext(
      input.CidrAuthorizationContext,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `CidrAuthorizationContext.${key}`;
      entries[loc] = value;
    });
  }
  if (input.Description !== undefined) {
    entries["Description"] = input.Description;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.PubliclyAdvertisable !== undefined) {
    entries["PubliclyAdvertisable"] = input.PubliclyAdvertisable;
  }
  return entries;
};

const serializeAws_ec2PublicIpStringList = (
  input: string[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    entries[`PublicIp.${counter}`] = entry;
    counter++;
  }
  return entries;
};

const serializeAws_ec2PurchaseHostReservationRequest = (
  input: PurchaseHostReservationRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.ClientToken !== undefined) {
    entries["ClientToken"] = input.ClientToken;
  }
  if (input.CurrencyCode !== undefined) {
    entries["CurrencyCode"] = input.CurrencyCode;
  }
  if (input.HostIdSet !== undefined) {
    const memberEntries = serializeAws_ec2RequestHostIdSet(
      input.HostIdSet,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `HostIdSet.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.LimitPrice !== undefined) {
    entries["LimitPrice"] = input.LimitPrice;
  }
  if (input.OfferingId !== undefined) {
    entries["OfferingId"] = input.OfferingId;
  }
  return entries;
};

const serializeAws_ec2PurchaseRequest = (
  input: PurchaseRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.InstanceCount !== undefined) {
    entries["InstanceCount"] = input.InstanceCount;
  }
  if (input.PurchaseToken !== undefined) {
    entries["PurchaseToken"] = input.PurchaseToken;
  }
  return entries;
};

const serializeAws_ec2PurchaseRequestSet = (
  input: PurchaseRequest[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    const memberEntries = serializeAws_ec2PurchaseRequest(entry, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      entries[`PurchaseRequest.${counter}.${key}`] = value;
    });
    counter++;
  }
  return entries;
};

const serializeAws_ec2PurchaseReservedInstancesOfferingRequest = (
  input: PurchaseReservedInstancesOfferingRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.InstanceCount !== undefined) {
    entries["InstanceCount"] = input.InstanceCount;
  }
  if (input.LimitPrice !== undefined) {
    const memberEntries = serializeAws_ec2ReservedInstanceLimitPrice(
      input.LimitPrice,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `LimitPrice.${key}`;
      entries[loc] = value;
    });
  }
  if (input.PurchaseTime !== undefined) {
    entries["PurchaseTime"] =
      input.PurchaseTime.toISOString().split(".")[0] + "Z";
  }
  if (input.ReservedInstancesOfferingId !== undefined) {
    entries["ReservedInstancesOfferingId"] = input.ReservedInstancesOfferingId;
  }
  return entries;
};

const serializeAws_ec2PurchaseScheduledInstancesRequest = (
  input: PurchaseScheduledInstancesRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.ClientToken === undefined) {
    input.ClientToken = generateIdempotencyToken();
  }
  if (input.ClientToken !== undefined) {
    entries["ClientToken"] = input.ClientToken;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.PurchaseRequests !== undefined) {
    const memberEntries = serializeAws_ec2PurchaseRequestSet(
      input.PurchaseRequests,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `PurchaseRequest.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2ReasonCodesList = (
  input: (ReportInstanceReasonCodes | string)[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    entries[`Item.${counter}`] = entry;
    counter++;
  }
  return entries;
};

const serializeAws_ec2RebootInstancesRequest = (
  input: RebootInstancesRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.InstanceIds !== undefined) {
    const memberEntries = serializeAws_ec2InstanceIdStringList(
      input.InstanceIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `InstanceId.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2RegionNameStringList = (
  input: string[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    entries[`RegionName.${counter}`] = entry;
    counter++;
  }
  return entries;
};

const serializeAws_ec2RegisterImageRequest = (
  input: RegisterImageRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Architecture !== undefined) {
    entries["Architecture"] = input.Architecture;
  }
  if (input.BillingProducts !== undefined) {
    const memberEntries = serializeAws_ec2BillingProductList(
      input.BillingProducts,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `BillingProduct.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.BlockDeviceMappings !== undefined) {
    const memberEntries = serializeAws_ec2BlockDeviceMappingRequestList(
      input.BlockDeviceMappings,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `BlockDeviceMapping.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.Description !== undefined) {
    entries["Description"] = input.Description;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.EnaSupport !== undefined) {
    entries["EnaSupport"] = input.EnaSupport;
  }
  if (input.ImageLocation !== undefined) {
    entries["ImageLocation"] = input.ImageLocation;
  }
  if (input.KernelId !== undefined) {
    entries["KernelId"] = input.KernelId;
  }
  if (input.Name !== undefined) {
    entries["Name"] = input.Name;
  }
  if (input.RamdiskId !== undefined) {
    entries["RamdiskId"] = input.RamdiskId;
  }
  if (input.RootDeviceName !== undefined) {
    entries["RootDeviceName"] = input.RootDeviceName;
  }
  if (input.SriovNetSupport !== undefined) {
    entries["SriovNetSupport"] = input.SriovNetSupport;
  }
  if (input.VirtualizationType !== undefined) {
    entries["VirtualizationType"] = input.VirtualizationType;
  }
  return entries;
};

const serializeAws_ec2RegisterTransitGatewayMulticastGroupMembersRequest = (
  input: RegisterTransitGatewayMulticastGroupMembersRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.GroupIpAddress !== undefined) {
    entries["GroupIpAddress"] = input.GroupIpAddress;
  }
  if (input.NetworkInterfaceIds !== undefined) {
    const memberEntries = serializeAws_ec2ValueStringList(
      input.NetworkInterfaceIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `NetworkInterfaceIds.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.TransitGatewayMulticastDomainId !== undefined) {
    entries["TransitGatewayMulticastDomainId"] =
      input.TransitGatewayMulticastDomainId;
  }
  return entries;
};

const serializeAws_ec2RegisterTransitGatewayMulticastGroupSourcesRequest = (
  input: RegisterTransitGatewayMulticastGroupSourcesRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.GroupIpAddress !== undefined) {
    entries["GroupIpAddress"] = input.GroupIpAddress;
  }
  if (input.NetworkInterfaceIds !== undefined) {
    const memberEntries = serializeAws_ec2ValueStringList(
      input.NetworkInterfaceIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `NetworkInterfaceIds.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.TransitGatewayMulticastDomainId !== undefined) {
    entries["TransitGatewayMulticastDomainId"] =
      input.TransitGatewayMulticastDomainId;
  }
  return entries;
};

const serializeAws_ec2RejectTransitGatewayPeeringAttachmentRequest = (
  input: RejectTransitGatewayPeeringAttachmentRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.TransitGatewayAttachmentId !== undefined) {
    entries["TransitGatewayAttachmentId"] = input.TransitGatewayAttachmentId;
  }
  return entries;
};

const serializeAws_ec2RejectTransitGatewayVpcAttachmentRequest = (
  input: RejectTransitGatewayVpcAttachmentRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.TransitGatewayAttachmentId !== undefined) {
    entries["TransitGatewayAttachmentId"] = input.TransitGatewayAttachmentId;
  }
  return entries;
};

const serializeAws_ec2RejectVpcEndpointConnectionsRequest = (
  input: RejectVpcEndpointConnectionsRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.ServiceId !== undefined) {
    entries["ServiceId"] = input.ServiceId;
  }
  if (input.VpcEndpointIds !== undefined) {
    const memberEntries = serializeAws_ec2ValueStringList(
      input.VpcEndpointIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `VpcEndpointId.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2RejectVpcPeeringConnectionRequest = (
  input: RejectVpcPeeringConnectionRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.VpcPeeringConnectionId !== undefined) {
    entries["VpcPeeringConnectionId"] = input.VpcPeeringConnectionId;
  }
  return entries;
};

const serializeAws_ec2ReleaseAddressRequest = (
  input: ReleaseAddressRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.AllocationId !== undefined) {
    entries["AllocationId"] = input.AllocationId;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.NetworkBorderGroup !== undefined) {
    entries["NetworkBorderGroup"] = input.NetworkBorderGroup;
  }
  if (input.PublicIp !== undefined) {
    entries["PublicIp"] = input.PublicIp;
  }
  return entries;
};

const serializeAws_ec2ReleaseHostsRequest = (
  input: ReleaseHostsRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.HostIds !== undefined) {
    const memberEntries = serializeAws_ec2RequestHostIdList(
      input.HostIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `HostId.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2ReplaceIamInstanceProfileAssociationRequest = (
  input: ReplaceIamInstanceProfileAssociationRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.AssociationId !== undefined) {
    entries["AssociationId"] = input.AssociationId;
  }
  if (input.IamInstanceProfile !== undefined) {
    const memberEntries = serializeAws_ec2IamInstanceProfileSpecification(
      input.IamInstanceProfile,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `IamInstanceProfile.${key}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2ReplaceNetworkAclAssociationRequest = (
  input: ReplaceNetworkAclAssociationRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.AssociationId !== undefined) {
    entries["AssociationId"] = input.AssociationId;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.NetworkAclId !== undefined) {
    entries["NetworkAclId"] = input.NetworkAclId;
  }
  return entries;
};

const serializeAws_ec2ReplaceNetworkAclEntryRequest = (
  input: ReplaceNetworkAclEntryRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.CidrBlock !== undefined) {
    entries["CidrBlock"] = input.CidrBlock;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Egress !== undefined) {
    entries["Egress"] = input.Egress;
  }
  if (input.IcmpTypeCode !== undefined) {
    const memberEntries = serializeAws_ec2IcmpTypeCode(
      input.IcmpTypeCode,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Icmp.${key}`;
      entries[loc] = value;
    });
  }
  if (input.Ipv6CidrBlock !== undefined) {
    entries["Ipv6CidrBlock"] = input.Ipv6CidrBlock;
  }
  if (input.NetworkAclId !== undefined) {
    entries["NetworkAclId"] = input.NetworkAclId;
  }
  if (input.PortRange !== undefined) {
    const memberEntries = serializeAws_ec2PortRange(input.PortRange, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `PortRange.${key}`;
      entries[loc] = value;
    });
  }
  if (input.Protocol !== undefined) {
    entries["Protocol"] = input.Protocol;
  }
  if (input.RuleAction !== undefined) {
    entries["RuleAction"] = input.RuleAction;
  }
  if (input.RuleNumber !== undefined) {
    entries["RuleNumber"] = input.RuleNumber;
  }
  return entries;
};

const serializeAws_ec2ReplaceRouteRequest = (
  input: ReplaceRouteRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DestinationCidrBlock !== undefined) {
    entries["DestinationCidrBlock"] = input.DestinationCidrBlock;
  }
  if (input.DestinationIpv6CidrBlock !== undefined) {
    entries["DestinationIpv6CidrBlock"] = input.DestinationIpv6CidrBlock;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.EgressOnlyInternetGatewayId !== undefined) {
    entries["EgressOnlyInternetGatewayId"] = input.EgressOnlyInternetGatewayId;
  }
  if (input.GatewayId !== undefined) {
    entries["GatewayId"] = input.GatewayId;
  }
  if (input.InstanceId !== undefined) {
    entries["InstanceId"] = input.InstanceId;
  }
  if (input.LocalGatewayId !== undefined) {
    entries["LocalGatewayId"] = input.LocalGatewayId;
  }
  if (input.LocalTarget !== undefined) {
    entries["LocalTarget"] = input.LocalTarget;
  }
  if (input.NatGatewayId !== undefined) {
    entries["NatGatewayId"] = input.NatGatewayId;
  }
  if (input.NetworkInterfaceId !== undefined) {
    entries["NetworkInterfaceId"] = input.NetworkInterfaceId;
  }
  if (input.RouteTableId !== undefined) {
    entries["RouteTableId"] = input.RouteTableId;
  }
  if (input.TransitGatewayId !== undefined) {
    entries["TransitGatewayId"] = input.TransitGatewayId;
  }
  if (input.VpcPeeringConnectionId !== undefined) {
    entries["VpcPeeringConnectionId"] = input.VpcPeeringConnectionId;
  }
  return entries;
};

const serializeAws_ec2ReplaceRouteTableAssociationRequest = (
  input: ReplaceRouteTableAssociationRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.AssociationId !== undefined) {
    entries["AssociationId"] = input.AssociationId;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.RouteTableId !== undefined) {
    entries["RouteTableId"] = input.RouteTableId;
  }
  return entries;
};

const serializeAws_ec2ReplaceTransitGatewayRouteRequest = (
  input: ReplaceTransitGatewayRouteRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Blackhole !== undefined) {
    entries["Blackhole"] = input.Blackhole;
  }
  if (input.DestinationCidrBlock !== undefined) {
    entries["DestinationCidrBlock"] = input.DestinationCidrBlock;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.TransitGatewayAttachmentId !== undefined) {
    entries["TransitGatewayAttachmentId"] = input.TransitGatewayAttachmentId;
  }
  if (input.TransitGatewayRouteTableId !== undefined) {
    entries["TransitGatewayRouteTableId"] = input.TransitGatewayRouteTableId;
  }
  return entries;
};

const serializeAws_ec2ReportInstanceStatusRequest = (
  input: ReportInstanceStatusRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Description !== undefined) {
    entries["Description"] = input.Description;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.EndTime !== undefined) {
    entries["EndTime"] = input.EndTime.toISOString().split(".")[0] + "Z";
  }
  if (input.Instances !== undefined) {
    const memberEntries = serializeAws_ec2InstanceIdStringList(
      input.Instances,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `InstanceId.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.ReasonCodes !== undefined) {
    const memberEntries = serializeAws_ec2ReasonCodesList(
      input.ReasonCodes,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `ReasonCode.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.StartTime !== undefined) {
    entries["StartTime"] = input.StartTime.toISOString().split(".")[0] + "Z";
  }
  if (input.Status !== undefined) {
    entries["Status"] = input.Status;
  }
  return entries;
};

const serializeAws_ec2RequestHostIdList = (
  input: string[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    entries[`Item.${counter}`] = entry;
    counter++;
  }
  return entries;
};

const serializeAws_ec2RequestHostIdSet = (
  input: string[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    entries[`Item.${counter}`] = entry;
    counter++;
  }
  return entries;
};

const serializeAws_ec2RequestInstanceTypeList = (
  input: (_InstanceType | string)[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    entries[`Member.${counter}`] = entry;
    counter++;
  }
  return entries;
};

const serializeAws_ec2RequestLaunchTemplateData = (
  input: RequestLaunchTemplateData,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.BlockDeviceMappings !== undefined) {
    const memberEntries = serializeAws_ec2LaunchTemplateBlockDeviceMappingRequestList(
      input.BlockDeviceMappings,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `BlockDeviceMapping.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.CapacityReservationSpecification !== undefined) {
    const memberEntries = serializeAws_ec2LaunchTemplateCapacityReservationSpecificationRequest(
      input.CapacityReservationSpecification,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `CapacityReservationSpecification.${key}`;
      entries[loc] = value;
    });
  }
  if (input.CpuOptions !== undefined) {
    const memberEntries = serializeAws_ec2LaunchTemplateCpuOptionsRequest(
      input.CpuOptions,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `CpuOptions.${key}`;
      entries[loc] = value;
    });
  }
  if (input.CreditSpecification !== undefined) {
    const memberEntries = serializeAws_ec2CreditSpecificationRequest(
      input.CreditSpecification,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `CreditSpecification.${key}`;
      entries[loc] = value;
    });
  }
  if (input.DisableApiTermination !== undefined) {
    entries["DisableApiTermination"] = input.DisableApiTermination;
  }
  if (input.EbsOptimized !== undefined) {
    entries["EbsOptimized"] = input.EbsOptimized;
  }
  if (input.ElasticGpuSpecifications !== undefined) {
    const memberEntries = serializeAws_ec2ElasticGpuSpecificationList(
      input.ElasticGpuSpecifications,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `ElasticGpuSpecification.${key.substring(
        key.indexOf(".") + 1
      )}`;
      entries[loc] = value;
    });
  }
  if (input.ElasticInferenceAccelerators !== undefined) {
    const memberEntries = serializeAws_ec2LaunchTemplateElasticInferenceAcceleratorList(
      input.ElasticInferenceAccelerators,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `ElasticInferenceAccelerator.${key.substring(
        key.indexOf(".") + 1
      )}`;
      entries[loc] = value;
    });
  }
  if (input.HibernationOptions !== undefined) {
    const memberEntries = serializeAws_ec2LaunchTemplateHibernationOptionsRequest(
      input.HibernationOptions,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `HibernationOptions.${key}`;
      entries[loc] = value;
    });
  }
  if (input.IamInstanceProfile !== undefined) {
    const memberEntries = serializeAws_ec2LaunchTemplateIamInstanceProfileSpecificationRequest(
      input.IamInstanceProfile,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `IamInstanceProfile.${key}`;
      entries[loc] = value;
    });
  }
  if (input.ImageId !== undefined) {
    entries["ImageId"] = input.ImageId;
  }
  if (input.InstanceInitiatedShutdownBehavior !== undefined) {
    entries["InstanceInitiatedShutdownBehavior"] =
      input.InstanceInitiatedShutdownBehavior;
  }
  if (input.InstanceMarketOptions !== undefined) {
    const memberEntries = serializeAws_ec2LaunchTemplateInstanceMarketOptionsRequest(
      input.InstanceMarketOptions,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `InstanceMarketOptions.${key}`;
      entries[loc] = value;
    });
  }
  if (input.InstanceType !== undefined) {
    entries["InstanceType"] = input.InstanceType;
  }
  if (input.KernelId !== undefined) {
    entries["KernelId"] = input.KernelId;
  }
  if (input.KeyName !== undefined) {
    entries["KeyName"] = input.KeyName;
  }
  if (input.LicenseSpecifications !== undefined) {
    const memberEntries = serializeAws_ec2LaunchTemplateLicenseSpecificationListRequest(
      input.LicenseSpecifications,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `LicenseSpecification.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.MetadataOptions !== undefined) {
    const memberEntries = serializeAws_ec2LaunchTemplateInstanceMetadataOptionsRequest(
      input.MetadataOptions,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `MetadataOptions.${key}`;
      entries[loc] = value;
    });
  }
  if (input.Monitoring !== undefined) {
    const memberEntries = serializeAws_ec2LaunchTemplatesMonitoringRequest(
      input.Monitoring,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Monitoring.${key}`;
      entries[loc] = value;
    });
  }
  if (input.NetworkInterfaces !== undefined) {
    const memberEntries = serializeAws_ec2LaunchTemplateInstanceNetworkInterfaceSpecificationRequestList(
      input.NetworkInterfaces,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `NetworkInterface.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.Placement !== undefined) {
    const memberEntries = serializeAws_ec2LaunchTemplatePlacementRequest(
      input.Placement,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Placement.${key}`;
      entries[loc] = value;
    });
  }
  if (input.RamDiskId !== undefined) {
    entries["RamDiskId"] = input.RamDiskId;
  }
  if (input.SecurityGroupIds !== undefined) {
    const memberEntries = serializeAws_ec2SecurityGroupIdStringList(
      input.SecurityGroupIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `SecurityGroupId.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.SecurityGroups !== undefined) {
    const memberEntries = serializeAws_ec2SecurityGroupStringList(
      input.SecurityGroups,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `SecurityGroup.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.TagSpecifications !== undefined) {
    const memberEntries = serializeAws_ec2LaunchTemplateTagSpecificationRequestList(
      input.TagSpecifications,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.UserData !== undefined) {
    entries["UserData"] = input.UserData;
  }
  return entries;
};

const serializeAws_ec2RequestSpotFleetRequest = (
  input: RequestSpotFleetRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.SpotFleetRequestConfig !== undefined) {
    const memberEntries = serializeAws_ec2SpotFleetRequestConfigData(
      input.SpotFleetRequestConfig,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `SpotFleetRequestConfig.${key}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2RequestSpotInstancesRequest = (
  input: RequestSpotInstancesRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.AvailabilityZoneGroup !== undefined) {
    entries["AvailabilityZoneGroup"] = input.AvailabilityZoneGroup;
  }
  if (input.BlockDurationMinutes !== undefined) {
    entries["BlockDurationMinutes"] = input.BlockDurationMinutes;
  }
  if (input.ClientToken !== undefined) {
    entries["ClientToken"] = input.ClientToken;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.InstanceCount !== undefined) {
    entries["InstanceCount"] = input.InstanceCount;
  }
  if (input.InstanceInterruptionBehavior !== undefined) {
    entries["InstanceInterruptionBehavior"] =
      input.InstanceInterruptionBehavior;
  }
  if (input.LaunchGroup !== undefined) {
    entries["LaunchGroup"] = input.LaunchGroup;
  }
  if (input.LaunchSpecification !== undefined) {
    const memberEntries = serializeAws_ec2RequestSpotLaunchSpecification(
      input.LaunchSpecification,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `LaunchSpecification.${key}`;
      entries[loc] = value;
    });
  }
  if (input.SpotPrice !== undefined) {
    entries["SpotPrice"] = input.SpotPrice;
  }
  if (input.Type !== undefined) {
    entries["Type"] = input.Type;
  }
  if (input.ValidFrom !== undefined) {
    entries["ValidFrom"] = input.ValidFrom.toISOString().split(".")[0] + "Z";
  }
  if (input.ValidUntil !== undefined) {
    entries["ValidUntil"] = input.ValidUntil.toISOString().split(".")[0] + "Z";
  }
  return entries;
};

const serializeAws_ec2RequestSpotLaunchSpecification = (
  input: RequestSpotLaunchSpecification,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.AddressingType !== undefined) {
    entries["AddressingType"] = input.AddressingType;
  }
  if (input.BlockDeviceMappings !== undefined) {
    const memberEntries = serializeAws_ec2BlockDeviceMappingList(
      input.BlockDeviceMappings,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `BlockDeviceMapping.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.EbsOptimized !== undefined) {
    entries["EbsOptimized"] = input.EbsOptimized;
  }
  if (input.IamInstanceProfile !== undefined) {
    const memberEntries = serializeAws_ec2IamInstanceProfileSpecification(
      input.IamInstanceProfile,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `IamInstanceProfile.${key}`;
      entries[loc] = value;
    });
  }
  if (input.ImageId !== undefined) {
    entries["ImageId"] = input.ImageId;
  }
  if (input.InstanceType !== undefined) {
    entries["InstanceType"] = input.InstanceType;
  }
  if (input.KernelId !== undefined) {
    entries["KernelId"] = input.KernelId;
  }
  if (input.KeyName !== undefined) {
    entries["KeyName"] = input.KeyName;
  }
  if (input.Monitoring !== undefined) {
    const memberEntries = serializeAws_ec2RunInstancesMonitoringEnabled(
      input.Monitoring,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Monitoring.${key}`;
      entries[loc] = value;
    });
  }
  if (input.NetworkInterfaces !== undefined) {
    const memberEntries = serializeAws_ec2InstanceNetworkInterfaceSpecificationList(
      input.NetworkInterfaces,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `NetworkInterface.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.Placement !== undefined) {
    const memberEntries = serializeAws_ec2SpotPlacement(
      input.Placement,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Placement.${key}`;
      entries[loc] = value;
    });
  }
  if (input.RamdiskId !== undefined) {
    entries["RamdiskId"] = input.RamdiskId;
  }
  if (input.SecurityGroupIds !== undefined) {
    const memberEntries = serializeAws_ec2ValueStringList(
      input.SecurityGroupIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `SecurityGroupId.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.SecurityGroups !== undefined) {
    const memberEntries = serializeAws_ec2ValueStringList(
      input.SecurityGroups,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `SecurityGroup.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.SubnetId !== undefined) {
    entries["SubnetId"] = input.SubnetId;
  }
  if (input.UserData !== undefined) {
    entries["UserData"] = input.UserData;
  }
  return entries;
};

const serializeAws_ec2ReservedInstanceIdSet = (
  input: string[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    entries[`ReservedInstanceId.${counter}`] = entry;
    counter++;
  }
  return entries;
};

const serializeAws_ec2ReservedInstanceLimitPrice = (
  input: ReservedInstanceLimitPrice,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Amount !== undefined) {
    entries["Amount"] = input.Amount;
  }
  if (input.CurrencyCode !== undefined) {
    entries["CurrencyCode"] = input.CurrencyCode;
  }
  return entries;
};

const serializeAws_ec2ReservedInstancesConfiguration = (
  input: ReservedInstancesConfiguration,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.AvailabilityZone !== undefined) {
    entries["AvailabilityZone"] = input.AvailabilityZone;
  }
  if (input.InstanceCount !== undefined) {
    entries["InstanceCount"] = input.InstanceCount;
  }
  if (input.InstanceType !== undefined) {
    entries["InstanceType"] = input.InstanceType;
  }
  if (input.Platform !== undefined) {
    entries["Platform"] = input.Platform;
  }
  if (input.Scope !== undefined) {
    entries["Scope"] = input.Scope;
  }
  return entries;
};

const serializeAws_ec2ReservedInstancesConfigurationList = (
  input: ReservedInstancesConfiguration[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    const memberEntries = serializeAws_ec2ReservedInstancesConfiguration(
      entry,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      entries[`Item.${counter}.${key}`] = value;
    });
    counter++;
  }
  return entries;
};

const serializeAws_ec2ReservedInstancesIdStringList = (
  input: string[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    entries[`ReservedInstancesId.${counter}`] = entry;
    counter++;
  }
  return entries;
};

const serializeAws_ec2ReservedInstancesModificationIdStringList = (
  input: string[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    entries[`ReservedInstancesModificationId.${counter}`] = entry;
    counter++;
  }
  return entries;
};

const serializeAws_ec2ReservedInstancesOfferingIdStringList = (
  input: string[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    entries[`Member.${counter}`] = entry;
    counter++;
  }
  return entries;
};

const serializeAws_ec2ResetEbsDefaultKmsKeyIdRequest = (
  input: ResetEbsDefaultKmsKeyIdRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  return entries;
};

const serializeAws_ec2ResetFpgaImageAttributeRequest = (
  input: ResetFpgaImageAttributeRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Attribute !== undefined) {
    entries["Attribute"] = input.Attribute;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.FpgaImageId !== undefined) {
    entries["FpgaImageId"] = input.FpgaImageId;
  }
  return entries;
};

const serializeAws_ec2ResetImageAttributeRequest = (
  input: ResetImageAttributeRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Attribute !== undefined) {
    entries["Attribute"] = input.Attribute;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.ImageId !== undefined) {
    entries["ImageId"] = input.ImageId;
  }
  return entries;
};

const serializeAws_ec2ResetInstanceAttributeRequest = (
  input: ResetInstanceAttributeRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Attribute !== undefined) {
    entries["Attribute"] = input.Attribute;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.InstanceId !== undefined) {
    entries["InstanceId"] = input.InstanceId;
  }
  return entries;
};

const serializeAws_ec2ResetNetworkInterfaceAttributeRequest = (
  input: ResetNetworkInterfaceAttributeRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.NetworkInterfaceId !== undefined) {
    entries["NetworkInterfaceId"] = input.NetworkInterfaceId;
  }
  if (input.SourceDestCheck !== undefined) {
    entries["SourceDestCheck"] = input.SourceDestCheck;
  }
  return entries;
};

const serializeAws_ec2ResetSnapshotAttributeRequest = (
  input: ResetSnapshotAttributeRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Attribute !== undefined) {
    entries["Attribute"] = input.Attribute;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.SnapshotId !== undefined) {
    entries["SnapshotId"] = input.SnapshotId;
  }
  return entries;
};

const serializeAws_ec2ResourceIdList = (
  input: string[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    entries[`Member.${counter}`] = entry;
    counter++;
  }
  return entries;
};

const serializeAws_ec2ResourceList = (
  input: string[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    entries[`Item.${counter}`] = entry;
    counter++;
  }
  return entries;
};

const serializeAws_ec2RestorableByStringList = (
  input: string[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    entries[`Member.${counter}`] = entry;
    counter++;
  }
  return entries;
};

const serializeAws_ec2RestoreAddressToClassicRequest = (
  input: RestoreAddressToClassicRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.PublicIp !== undefined) {
    entries["PublicIp"] = input.PublicIp;
  }
  return entries;
};

const serializeAws_ec2RevokeClientVpnIngressRequest = (
  input: RevokeClientVpnIngressRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.AccessGroupId !== undefined) {
    entries["AccessGroupId"] = input.AccessGroupId;
  }
  if (input.ClientVpnEndpointId !== undefined) {
    entries["ClientVpnEndpointId"] = input.ClientVpnEndpointId;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.RevokeAllGroups !== undefined) {
    entries["RevokeAllGroups"] = input.RevokeAllGroups;
  }
  if (input.TargetNetworkCidr !== undefined) {
    entries["TargetNetworkCidr"] = input.TargetNetworkCidr;
  }
  return entries;
};

const serializeAws_ec2RevokeSecurityGroupEgressRequest = (
  input: RevokeSecurityGroupEgressRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.CidrIp !== undefined) {
    entries["CidrIp"] = input.CidrIp;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.FromPort !== undefined) {
    entries["FromPort"] = input.FromPort;
  }
  if (input.GroupId !== undefined) {
    entries["GroupId"] = input.GroupId;
  }
  if (input.IpPermissions !== undefined) {
    const memberEntries = serializeAws_ec2IpPermissionList(
      input.IpPermissions,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `IpPermissions.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.IpProtocol !== undefined) {
    entries["IpProtocol"] = input.IpProtocol;
  }
  if (input.SourceSecurityGroupName !== undefined) {
    entries["SourceSecurityGroupName"] = input.SourceSecurityGroupName;
  }
  if (input.SourceSecurityGroupOwnerId !== undefined) {
    entries["SourceSecurityGroupOwnerId"] = input.SourceSecurityGroupOwnerId;
  }
  if (input.ToPort !== undefined) {
    entries["ToPort"] = input.ToPort;
  }
  return entries;
};

const serializeAws_ec2RevokeSecurityGroupIngressRequest = (
  input: RevokeSecurityGroupIngressRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.CidrIp !== undefined) {
    entries["CidrIp"] = input.CidrIp;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.FromPort !== undefined) {
    entries["FromPort"] = input.FromPort;
  }
  if (input.GroupId !== undefined) {
    entries["GroupId"] = input.GroupId;
  }
  if (input.GroupName !== undefined) {
    entries["GroupName"] = input.GroupName;
  }
  if (input.IpPermissions !== undefined) {
    const memberEntries = serializeAws_ec2IpPermissionList(
      input.IpPermissions,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `IpPermissions.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.IpProtocol !== undefined) {
    entries["IpProtocol"] = input.IpProtocol;
  }
  if (input.SourceSecurityGroupName !== undefined) {
    entries["SourceSecurityGroupName"] = input.SourceSecurityGroupName;
  }
  if (input.SourceSecurityGroupOwnerId !== undefined) {
    entries["SourceSecurityGroupOwnerId"] = input.SourceSecurityGroupOwnerId;
  }
  if (input.ToPort !== undefined) {
    entries["ToPort"] = input.ToPort;
  }
  return entries;
};

const serializeAws_ec2RunInstancesMonitoringEnabled = (
  input: RunInstancesMonitoringEnabled,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Enabled !== undefined) {
    entries["Enabled"] = input.Enabled;
  }
  return entries;
};

const serializeAws_ec2RunInstancesRequest = (
  input: RunInstancesRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.AdditionalInfo !== undefined) {
    entries["AdditionalInfo"] = input.AdditionalInfo;
  }
  if (input.BlockDeviceMappings !== undefined) {
    const memberEntries = serializeAws_ec2BlockDeviceMappingRequestList(
      input.BlockDeviceMappings,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `BlockDeviceMapping.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.CapacityReservationSpecification !== undefined) {
    const memberEntries = serializeAws_ec2CapacityReservationSpecification(
      input.CapacityReservationSpecification,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `CapacityReservationSpecification.${key}`;
      entries[loc] = value;
    });
  }
  if (input.ClientToken !== undefined) {
    entries["ClientToken"] = input.ClientToken;
  }
  if (input.CpuOptions !== undefined) {
    const memberEntries = serializeAws_ec2CpuOptionsRequest(
      input.CpuOptions,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `CpuOptions.${key}`;
      entries[loc] = value;
    });
  }
  if (input.CreditSpecification !== undefined) {
    const memberEntries = serializeAws_ec2CreditSpecificationRequest(
      input.CreditSpecification,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `CreditSpecification.${key}`;
      entries[loc] = value;
    });
  }
  if (input.DisableApiTermination !== undefined) {
    entries["DisableApiTermination"] = input.DisableApiTermination;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.EbsOptimized !== undefined) {
    entries["EbsOptimized"] = input.EbsOptimized;
  }
  if (input.ElasticGpuSpecification !== undefined) {
    const memberEntries = serializeAws_ec2ElasticGpuSpecifications(
      input.ElasticGpuSpecification,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `ElasticGpuSpecification.${key.substring(
        key.indexOf(".") + 1
      )}`;
      entries[loc] = value;
    });
  }
  if (input.ElasticInferenceAccelerators !== undefined) {
    const memberEntries = serializeAws_ec2ElasticInferenceAccelerators(
      input.ElasticInferenceAccelerators,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `ElasticInferenceAccelerator.${key.substring(
        key.indexOf(".") + 1
      )}`;
      entries[loc] = value;
    });
  }
  if (input.HibernationOptions !== undefined) {
    const memberEntries = serializeAws_ec2HibernationOptionsRequest(
      input.HibernationOptions,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `HibernationOptions.${key}`;
      entries[loc] = value;
    });
  }
  if (input.IamInstanceProfile !== undefined) {
    const memberEntries = serializeAws_ec2IamInstanceProfileSpecification(
      input.IamInstanceProfile,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `IamInstanceProfile.${key}`;
      entries[loc] = value;
    });
  }
  if (input.ImageId !== undefined) {
    entries["ImageId"] = input.ImageId;
  }
  if (input.InstanceInitiatedShutdownBehavior !== undefined) {
    entries["InstanceInitiatedShutdownBehavior"] =
      input.InstanceInitiatedShutdownBehavior;
  }
  if (input.InstanceMarketOptions !== undefined) {
    const memberEntries = serializeAws_ec2InstanceMarketOptionsRequest(
      input.InstanceMarketOptions,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `InstanceMarketOptions.${key}`;
      entries[loc] = value;
    });
  }
  if (input.InstanceType !== undefined) {
    entries["InstanceType"] = input.InstanceType;
  }
  if (input.Ipv6AddressCount !== undefined) {
    entries["Ipv6AddressCount"] = input.Ipv6AddressCount;
  }
  if (input.Ipv6Addresses !== undefined) {
    const memberEntries = serializeAws_ec2InstanceIpv6AddressList(
      input.Ipv6Addresses,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Ipv6Address.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.KernelId !== undefined) {
    entries["KernelId"] = input.KernelId;
  }
  if (input.KeyName !== undefined) {
    entries["KeyName"] = input.KeyName;
  }
  if (input.LaunchTemplate !== undefined) {
    const memberEntries = serializeAws_ec2LaunchTemplateSpecification(
      input.LaunchTemplate,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `LaunchTemplate.${key}`;
      entries[loc] = value;
    });
  }
  if (input.LicenseSpecifications !== undefined) {
    const memberEntries = serializeAws_ec2LicenseSpecificationListRequest(
      input.LicenseSpecifications,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `LicenseSpecification.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.MaxCount !== undefined) {
    entries["MaxCount"] = input.MaxCount;
  }
  if (input.MetadataOptions !== undefined) {
    const memberEntries = serializeAws_ec2InstanceMetadataOptionsRequest(
      input.MetadataOptions,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `MetadataOptions.${key}`;
      entries[loc] = value;
    });
  }
  if (input.MinCount !== undefined) {
    entries["MinCount"] = input.MinCount;
  }
  if (input.Monitoring !== undefined) {
    const memberEntries = serializeAws_ec2RunInstancesMonitoringEnabled(
      input.Monitoring,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Monitoring.${key}`;
      entries[loc] = value;
    });
  }
  if (input.NetworkInterfaces !== undefined) {
    const memberEntries = serializeAws_ec2InstanceNetworkInterfaceSpecificationList(
      input.NetworkInterfaces,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `NetworkInterface.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.Placement !== undefined) {
    const memberEntries = serializeAws_ec2Placement(input.Placement, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Placement.${key}`;
      entries[loc] = value;
    });
  }
  if (input.PrivateIpAddress !== undefined) {
    entries["PrivateIpAddress"] = input.PrivateIpAddress;
  }
  if (input.RamdiskId !== undefined) {
    entries["RamdiskId"] = input.RamdiskId;
  }
  if (input.SecurityGroupIds !== undefined) {
    const memberEntries = serializeAws_ec2SecurityGroupIdStringList(
      input.SecurityGroupIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `SecurityGroupId.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.SecurityGroups !== undefined) {
    const memberEntries = serializeAws_ec2SecurityGroupStringList(
      input.SecurityGroups,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `SecurityGroup.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.SubnetId !== undefined) {
    entries["SubnetId"] = input.SubnetId;
  }
  if (input.TagSpecifications !== undefined) {
    const memberEntries = serializeAws_ec2TagSpecificationList(
      input.TagSpecifications,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.UserData !== undefined) {
    entries["UserData"] = input.UserData;
  }
  return entries;
};

const serializeAws_ec2RunScheduledInstancesRequest = (
  input: RunScheduledInstancesRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.ClientToken === undefined) {
    input.ClientToken = generateIdempotencyToken();
  }
  if (input.ClientToken !== undefined) {
    entries["ClientToken"] = input.ClientToken;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.InstanceCount !== undefined) {
    entries["InstanceCount"] = input.InstanceCount;
  }
  if (input.LaunchSpecification !== undefined) {
    const memberEntries = serializeAws_ec2ScheduledInstancesLaunchSpecification(
      input.LaunchSpecification,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `LaunchSpecification.${key}`;
      entries[loc] = value;
    });
  }
  if (input.ScheduledInstanceId !== undefined) {
    entries["ScheduledInstanceId"] = input.ScheduledInstanceId;
  }
  return entries;
};

const serializeAws_ec2S3Storage = (
  input: S3Storage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.AWSAccessKeyId !== undefined) {
    entries["AWSAccessKeyId"] = input.AWSAccessKeyId;
  }
  if (input.Bucket !== undefined) {
    entries["Bucket"] = input.Bucket;
  }
  if (input.Prefix !== undefined) {
    entries["Prefix"] = input.Prefix;
  }
  if (input.UploadPolicy !== undefined) {
    entries["UploadPolicy"] = context.base64Encoder(input.UploadPolicy);
  }
  if (input.UploadPolicySignature !== undefined) {
    entries["UploadPolicySignature"] = input.UploadPolicySignature;
  }
  return entries;
};

const serializeAws_ec2ScheduledInstanceIdRequestSet = (
  input: string[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    entries[`ScheduledInstanceId.${counter}`] = entry;
    counter++;
  }
  return entries;
};

const serializeAws_ec2ScheduledInstanceRecurrenceRequest = (
  input: ScheduledInstanceRecurrenceRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Frequency !== undefined) {
    entries["Frequency"] = input.Frequency;
  }
  if (input.Interval !== undefined) {
    entries["Interval"] = input.Interval;
  }
  if (input.OccurrenceDays !== undefined) {
    const memberEntries = serializeAws_ec2OccurrenceDayRequestSet(
      input.OccurrenceDays,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `OccurrenceDay.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.OccurrenceRelativeToEnd !== undefined) {
    entries["OccurrenceRelativeToEnd"] = input.OccurrenceRelativeToEnd;
  }
  if (input.OccurrenceUnit !== undefined) {
    entries["OccurrenceUnit"] = input.OccurrenceUnit;
  }
  return entries;
};

const serializeAws_ec2ScheduledInstancesBlockDeviceMapping = (
  input: ScheduledInstancesBlockDeviceMapping,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DeviceName !== undefined) {
    entries["DeviceName"] = input.DeviceName;
  }
  if (input.Ebs !== undefined) {
    const memberEntries = serializeAws_ec2ScheduledInstancesEbs(
      input.Ebs,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Ebs.${key}`;
      entries[loc] = value;
    });
  }
  if (input.NoDevice !== undefined) {
    entries["NoDevice"] = input.NoDevice;
  }
  if (input.VirtualName !== undefined) {
    entries["VirtualName"] = input.VirtualName;
  }
  return entries;
};

const serializeAws_ec2ScheduledInstancesBlockDeviceMappingSet = (
  input: ScheduledInstancesBlockDeviceMapping[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    const memberEntries = serializeAws_ec2ScheduledInstancesBlockDeviceMapping(
      entry,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      entries[`BlockDeviceMapping.${counter}.${key}`] = value;
    });
    counter++;
  }
  return entries;
};

const serializeAws_ec2ScheduledInstancesEbs = (
  input: ScheduledInstancesEbs,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DeleteOnTermination !== undefined) {
    entries["DeleteOnTermination"] = input.DeleteOnTermination;
  }
  if (input.Encrypted !== undefined) {
    entries["Encrypted"] = input.Encrypted;
  }
  if (input.Iops !== undefined) {
    entries["Iops"] = input.Iops;
  }
  if (input.SnapshotId !== undefined) {
    entries["SnapshotId"] = input.SnapshotId;
  }
  if (input.VolumeSize !== undefined) {
    entries["VolumeSize"] = input.VolumeSize;
  }
  if (input.VolumeType !== undefined) {
    entries["VolumeType"] = input.VolumeType;
  }
  return entries;
};

const serializeAws_ec2ScheduledInstancesIamInstanceProfile = (
  input: ScheduledInstancesIamInstanceProfile,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Arn !== undefined) {
    entries["Arn"] = input.Arn;
  }
  if (input.Name !== undefined) {
    entries["Name"] = input.Name;
  }
  return entries;
};

const serializeAws_ec2ScheduledInstancesIpv6Address = (
  input: ScheduledInstancesIpv6Address,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Ipv6Address !== undefined) {
    entries["Ipv6Address"] = input.Ipv6Address;
  }
  return entries;
};

const serializeAws_ec2ScheduledInstancesIpv6AddressList = (
  input: ScheduledInstancesIpv6Address[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    const memberEntries = serializeAws_ec2ScheduledInstancesIpv6Address(
      entry,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      entries[`Ipv6Address.${counter}.${key}`] = value;
    });
    counter++;
  }
  return entries;
};

const serializeAws_ec2ScheduledInstancesLaunchSpecification = (
  input: ScheduledInstancesLaunchSpecification,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.BlockDeviceMappings !== undefined) {
    const memberEntries = serializeAws_ec2ScheduledInstancesBlockDeviceMappingSet(
      input.BlockDeviceMappings,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `BlockDeviceMapping.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.EbsOptimized !== undefined) {
    entries["EbsOptimized"] = input.EbsOptimized;
  }
  if (input.IamInstanceProfile !== undefined) {
    const memberEntries = serializeAws_ec2ScheduledInstancesIamInstanceProfile(
      input.IamInstanceProfile,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `IamInstanceProfile.${key}`;
      entries[loc] = value;
    });
  }
  if (input.ImageId !== undefined) {
    entries["ImageId"] = input.ImageId;
  }
  if (input.InstanceType !== undefined) {
    entries["InstanceType"] = input.InstanceType;
  }
  if (input.KernelId !== undefined) {
    entries["KernelId"] = input.KernelId;
  }
  if (input.KeyName !== undefined) {
    entries["KeyName"] = input.KeyName;
  }
  if (input.Monitoring !== undefined) {
    const memberEntries = serializeAws_ec2ScheduledInstancesMonitoring(
      input.Monitoring,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Monitoring.${key}`;
      entries[loc] = value;
    });
  }
  if (input.NetworkInterfaces !== undefined) {
    const memberEntries = serializeAws_ec2ScheduledInstancesNetworkInterfaceSet(
      input.NetworkInterfaces,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `NetworkInterface.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.Placement !== undefined) {
    const memberEntries = serializeAws_ec2ScheduledInstancesPlacement(
      input.Placement,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Placement.${key}`;
      entries[loc] = value;
    });
  }
  if (input.RamdiskId !== undefined) {
    entries["RamdiskId"] = input.RamdiskId;
  }
  if (input.SecurityGroupIds !== undefined) {
    const memberEntries = serializeAws_ec2ScheduledInstancesSecurityGroupIdSet(
      input.SecurityGroupIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `SecurityGroupId.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.SubnetId !== undefined) {
    entries["SubnetId"] = input.SubnetId;
  }
  if (input.UserData !== undefined) {
    entries["UserData"] = input.UserData;
  }
  return entries;
};

const serializeAws_ec2ScheduledInstancesMonitoring = (
  input: ScheduledInstancesMonitoring,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Enabled !== undefined) {
    entries["Enabled"] = input.Enabled;
  }
  return entries;
};

const serializeAws_ec2ScheduledInstancesNetworkInterface = (
  input: ScheduledInstancesNetworkInterface,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.AssociatePublicIpAddress !== undefined) {
    entries["AssociatePublicIpAddress"] = input.AssociatePublicIpAddress;
  }
  if (input.DeleteOnTermination !== undefined) {
    entries["DeleteOnTermination"] = input.DeleteOnTermination;
  }
  if (input.Description !== undefined) {
    entries["Description"] = input.Description;
  }
  if (input.DeviceIndex !== undefined) {
    entries["DeviceIndex"] = input.DeviceIndex;
  }
  if (input.Groups !== undefined) {
    const memberEntries = serializeAws_ec2ScheduledInstancesSecurityGroupIdSet(
      input.Groups,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Group.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.Ipv6AddressCount !== undefined) {
    entries["Ipv6AddressCount"] = input.Ipv6AddressCount;
  }
  if (input.Ipv6Addresses !== undefined) {
    const memberEntries = serializeAws_ec2ScheduledInstancesIpv6AddressList(
      input.Ipv6Addresses,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Ipv6Address.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.NetworkInterfaceId !== undefined) {
    entries["NetworkInterfaceId"] = input.NetworkInterfaceId;
  }
  if (input.PrivateIpAddress !== undefined) {
    entries["PrivateIpAddress"] = input.PrivateIpAddress;
  }
  if (input.PrivateIpAddressConfigs !== undefined) {
    const memberEntries = serializeAws_ec2PrivateIpAddressConfigSet(
      input.PrivateIpAddressConfigs,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `PrivateIpAddressConfig.${key.substring(
        key.indexOf(".") + 1
      )}`;
      entries[loc] = value;
    });
  }
  if (input.SecondaryPrivateIpAddressCount !== undefined) {
    entries["SecondaryPrivateIpAddressCount"] =
      input.SecondaryPrivateIpAddressCount;
  }
  if (input.SubnetId !== undefined) {
    entries["SubnetId"] = input.SubnetId;
  }
  return entries;
};

const serializeAws_ec2ScheduledInstancesNetworkInterfaceSet = (
  input: ScheduledInstancesNetworkInterface[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    const memberEntries = serializeAws_ec2ScheduledInstancesNetworkInterface(
      entry,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      entries[`NetworkInterface.${counter}.${key}`] = value;
    });
    counter++;
  }
  return entries;
};

const serializeAws_ec2ScheduledInstancesPlacement = (
  input: ScheduledInstancesPlacement,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.AvailabilityZone !== undefined) {
    entries["AvailabilityZone"] = input.AvailabilityZone;
  }
  if (input.GroupName !== undefined) {
    entries["GroupName"] = input.GroupName;
  }
  return entries;
};

const serializeAws_ec2ScheduledInstancesPrivateIpAddressConfig = (
  input: ScheduledInstancesPrivateIpAddressConfig,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Primary !== undefined) {
    entries["Primary"] = input.Primary;
  }
  if (input.PrivateIpAddress !== undefined) {
    entries["PrivateIpAddress"] = input.PrivateIpAddress;
  }
  return entries;
};

const serializeAws_ec2ScheduledInstancesSecurityGroupIdSet = (
  input: string[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    entries[`SecurityGroupId.${counter}`] = entry;
    counter++;
  }
  return entries;
};

const serializeAws_ec2SearchLocalGatewayRoutesRequest = (
  input: SearchLocalGatewayRoutesRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.LocalGatewayRouteTableId !== undefined) {
    entries["LocalGatewayRouteTableId"] = input.LocalGatewayRouteTableId;
  }
  if (input.MaxResults !== undefined) {
    entries["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    entries["NextToken"] = input.NextToken;
  }
  return entries;
};

const serializeAws_ec2SearchTransitGatewayMulticastGroupsRequest = (
  input: SearchTransitGatewayMulticastGroupsRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.MaxResults !== undefined) {
    entries["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    entries["NextToken"] = input.NextToken;
  }
  if (input.TransitGatewayMulticastDomainId !== undefined) {
    entries["TransitGatewayMulticastDomainId"] =
      input.TransitGatewayMulticastDomainId;
  }
  return entries;
};

const serializeAws_ec2SearchTransitGatewayRoutesRequest = (
  input: SearchTransitGatewayRoutesRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.MaxResults !== undefined) {
    entries["MaxResults"] = input.MaxResults;
  }
  if (input.TransitGatewayRouteTableId !== undefined) {
    entries["TransitGatewayRouteTableId"] = input.TransitGatewayRouteTableId;
  }
  return entries;
};

const serializeAws_ec2SecurityGroupIdStringList = (
  input: string[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    entries[`SecurityGroupId.${counter}`] = entry;
    counter++;
  }
  return entries;
};

const serializeAws_ec2SecurityGroupStringList = (
  input: string[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    entries[`SecurityGroup.${counter}`] = entry;
    counter++;
  }
  return entries;
};

const serializeAws_ec2SendDiagnosticInterruptRequest = (
  input: SendDiagnosticInterruptRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.InstanceId !== undefined) {
    entries["InstanceId"] = input.InstanceId;
  }
  return entries;
};

const serializeAws_ec2SlotDateTimeRangeRequest = (
  input: SlotDateTimeRangeRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.EarliestTime !== undefined) {
    entries["EarliestTime"] =
      input.EarliestTime.toISOString().split(".")[0] + "Z";
  }
  if (input.LatestTime !== undefined) {
    entries["LatestTime"] = input.LatestTime.toISOString().split(".")[0] + "Z";
  }
  return entries;
};

const serializeAws_ec2SlotStartTimeRangeRequest = (
  input: SlotStartTimeRangeRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.EarliestTime !== undefined) {
    entries["EarliestTime"] =
      input.EarliestTime.toISOString().split(".")[0] + "Z";
  }
  if (input.LatestTime !== undefined) {
    entries["LatestTime"] = input.LatestTime.toISOString().split(".")[0] + "Z";
  }
  return entries;
};

const serializeAws_ec2SnapshotDiskContainer = (
  input: SnapshotDiskContainer,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Description !== undefined) {
    entries["Description"] = input.Description;
  }
  if (input.Format !== undefined) {
    entries["Format"] = input.Format;
  }
  if (input.Url !== undefined) {
    entries["Url"] = input.Url;
  }
  if (input.UserBucket !== undefined) {
    const memberEntries = serializeAws_ec2UserBucket(input.UserBucket, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `UserBucket.${key}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2SnapshotIdStringList = (
  input: string[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    entries[`SnapshotId.${counter}`] = entry;
    counter++;
  }
  return entries;
};

const serializeAws_ec2SpotFleetLaunchSpecification = (
  input: SpotFleetLaunchSpecification,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.AddressingType !== undefined) {
    entries["AddressingType"] = input.AddressingType;
  }
  if (input.BlockDeviceMappings !== undefined) {
    const memberEntries = serializeAws_ec2BlockDeviceMappingList(
      input.BlockDeviceMappings,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `BlockDeviceMapping.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.EbsOptimized !== undefined) {
    entries["EbsOptimized"] = input.EbsOptimized;
  }
  if (input.IamInstanceProfile !== undefined) {
    const memberEntries = serializeAws_ec2IamInstanceProfileSpecification(
      input.IamInstanceProfile,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `IamInstanceProfile.${key}`;
      entries[loc] = value;
    });
  }
  if (input.ImageId !== undefined) {
    entries["ImageId"] = input.ImageId;
  }
  if (input.InstanceType !== undefined) {
    entries["InstanceType"] = input.InstanceType;
  }
  if (input.KernelId !== undefined) {
    entries["KernelId"] = input.KernelId;
  }
  if (input.KeyName !== undefined) {
    entries["KeyName"] = input.KeyName;
  }
  if (input.Monitoring !== undefined) {
    const memberEntries = serializeAws_ec2SpotFleetMonitoring(
      input.Monitoring,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Monitoring.${key}`;
      entries[loc] = value;
    });
  }
  if (input.NetworkInterfaces !== undefined) {
    const memberEntries = serializeAws_ec2InstanceNetworkInterfaceSpecificationList(
      input.NetworkInterfaces,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `NetworkInterfaceSet.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.Placement !== undefined) {
    const memberEntries = serializeAws_ec2SpotPlacement(
      input.Placement,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Placement.${key}`;
      entries[loc] = value;
    });
  }
  if (input.RamdiskId !== undefined) {
    entries["RamdiskId"] = input.RamdiskId;
  }
  if (input.SecurityGroups !== undefined) {
    const memberEntries = serializeAws_ec2GroupIdentifierList(
      input.SecurityGroups,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `GroupSet.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.SpotPrice !== undefined) {
    entries["SpotPrice"] = input.SpotPrice;
  }
  if (input.SubnetId !== undefined) {
    entries["SubnetId"] = input.SubnetId;
  }
  if (input.TagSpecifications !== undefined) {
    const memberEntries = serializeAws_ec2SpotFleetTagSpecificationList(
      input.TagSpecifications,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `TagSpecificationSet.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.UserData !== undefined) {
    entries["UserData"] = input.UserData;
  }
  if (input.WeightedCapacity !== undefined) {
    entries["WeightedCapacity"] = input.WeightedCapacity;
  }
  return entries;
};

const serializeAws_ec2SpotFleetMonitoring = (
  input: SpotFleetMonitoring,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Enabled !== undefined) {
    entries["Enabled"] = input.Enabled;
  }
  return entries;
};

const serializeAws_ec2SpotFleetRequestConfigData = (
  input: SpotFleetRequestConfigData,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.AllocationStrategy !== undefined) {
    entries["AllocationStrategy"] = input.AllocationStrategy;
  }
  if (input.ClientToken !== undefined) {
    entries["ClientToken"] = input.ClientToken;
  }
  if (input.ExcessCapacityTerminationPolicy !== undefined) {
    entries["ExcessCapacityTerminationPolicy"] =
      input.ExcessCapacityTerminationPolicy;
  }
  if (input.FulfilledCapacity !== undefined) {
    entries["FulfilledCapacity"] = input.FulfilledCapacity;
  }
  if (input.IamFleetRole !== undefined) {
    entries["IamFleetRole"] = input.IamFleetRole;
  }
  if (input.InstanceInterruptionBehavior !== undefined) {
    entries["InstanceInterruptionBehavior"] =
      input.InstanceInterruptionBehavior;
  }
  if (input.InstancePoolsToUseCount !== undefined) {
    entries["InstancePoolsToUseCount"] = input.InstancePoolsToUseCount;
  }
  if (input.LaunchSpecifications !== undefined) {
    const memberEntries = serializeAws_ec2LaunchSpecsList(
      input.LaunchSpecifications,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `LaunchSpecifications.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.LaunchTemplateConfigs !== undefined) {
    const memberEntries = serializeAws_ec2LaunchTemplateConfigList(
      input.LaunchTemplateConfigs,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `LaunchTemplateConfigs.${key.substring(
        key.indexOf(".") + 1
      )}`;
      entries[loc] = value;
    });
  }
  if (input.LoadBalancersConfig !== undefined) {
    const memberEntries = serializeAws_ec2LoadBalancersConfig(
      input.LoadBalancersConfig,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `LoadBalancersConfig.${key}`;
      entries[loc] = value;
    });
  }
  if (input.OnDemandAllocationStrategy !== undefined) {
    entries["OnDemandAllocationStrategy"] = input.OnDemandAllocationStrategy;
  }
  if (input.OnDemandFulfilledCapacity !== undefined) {
    entries["OnDemandFulfilledCapacity"] = input.OnDemandFulfilledCapacity;
  }
  if (input.OnDemandMaxTotalPrice !== undefined) {
    entries["OnDemandMaxTotalPrice"] = input.OnDemandMaxTotalPrice;
  }
  if (input.OnDemandTargetCapacity !== undefined) {
    entries["OnDemandTargetCapacity"] = input.OnDemandTargetCapacity;
  }
  if (input.ReplaceUnhealthyInstances !== undefined) {
    entries["ReplaceUnhealthyInstances"] = input.ReplaceUnhealthyInstances;
  }
  if (input.SpotMaxTotalPrice !== undefined) {
    entries["SpotMaxTotalPrice"] = input.SpotMaxTotalPrice;
  }
  if (input.SpotPrice !== undefined) {
    entries["SpotPrice"] = input.SpotPrice;
  }
  if (input.TargetCapacity !== undefined) {
    entries["TargetCapacity"] = input.TargetCapacity;
  }
  if (input.TerminateInstancesWithExpiration !== undefined) {
    entries["TerminateInstancesWithExpiration"] =
      input.TerminateInstancesWithExpiration;
  }
  if (input.Type !== undefined) {
    entries["Type"] = input.Type;
  }
  if (input.ValidFrom !== undefined) {
    entries["ValidFrom"] = input.ValidFrom.toISOString().split(".")[0] + "Z";
  }
  if (input.ValidUntil !== undefined) {
    entries["ValidUntil"] = input.ValidUntil.toISOString().split(".")[0] + "Z";
  }
  return entries;
};

const serializeAws_ec2SpotFleetTagSpecification = (
  input: SpotFleetTagSpecification,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.ResourceType !== undefined) {
    entries["ResourceType"] = input.ResourceType;
  }
  if (input.Tags !== undefined) {
    const memberEntries = serializeAws_ec2TagList(input.Tags, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Tag.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2SpotFleetTagSpecificationList = (
  input: SpotFleetTagSpecification[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    const memberEntries = serializeAws_ec2SpotFleetTagSpecification(
      entry,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      entries[`Item.${counter}.${key}`] = value;
    });
    counter++;
  }
  return entries;
};

const serializeAws_ec2SpotInstanceRequestIdList = (
  input: string[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    entries[`SpotInstanceRequestId.${counter}`] = entry;
    counter++;
  }
  return entries;
};

const serializeAws_ec2SpotMarketOptions = (
  input: SpotMarketOptions,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.BlockDurationMinutes !== undefined) {
    entries["BlockDurationMinutes"] = input.BlockDurationMinutes;
  }
  if (input.InstanceInterruptionBehavior !== undefined) {
    entries["InstanceInterruptionBehavior"] =
      input.InstanceInterruptionBehavior;
  }
  if (input.MaxPrice !== undefined) {
    entries["MaxPrice"] = input.MaxPrice;
  }
  if (input.SpotInstanceType !== undefined) {
    entries["SpotInstanceType"] = input.SpotInstanceType;
  }
  if (input.ValidUntil !== undefined) {
    entries["ValidUntil"] = input.ValidUntil.toISOString().split(".")[0] + "Z";
  }
  return entries;
};

const serializeAws_ec2SpotOptionsRequest = (
  input: SpotOptionsRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.AllocationStrategy !== undefined) {
    entries["AllocationStrategy"] = input.AllocationStrategy;
  }
  if (input.InstanceInterruptionBehavior !== undefined) {
    entries["InstanceInterruptionBehavior"] =
      input.InstanceInterruptionBehavior;
  }
  if (input.InstancePoolsToUseCount !== undefined) {
    entries["InstancePoolsToUseCount"] = input.InstancePoolsToUseCount;
  }
  if (input.MaxTotalPrice !== undefined) {
    entries["MaxTotalPrice"] = input.MaxTotalPrice;
  }
  if (input.MinTargetCapacity !== undefined) {
    entries["MinTargetCapacity"] = input.MinTargetCapacity;
  }
  if (input.SingleAvailabilityZone !== undefined) {
    entries["SingleAvailabilityZone"] = input.SingleAvailabilityZone;
  }
  if (input.SingleInstanceType !== undefined) {
    entries["SingleInstanceType"] = input.SingleInstanceType;
  }
  return entries;
};

const serializeAws_ec2SpotPlacement = (
  input: SpotPlacement,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.AvailabilityZone !== undefined) {
    entries["AvailabilityZone"] = input.AvailabilityZone;
  }
  if (input.GroupName !== undefined) {
    entries["GroupName"] = input.GroupName;
  }
  if (input.Tenancy !== undefined) {
    entries["Tenancy"] = input.Tenancy;
  }
  return entries;
};

const serializeAws_ec2StartInstancesRequest = (
  input: StartInstancesRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.AdditionalInfo !== undefined) {
    entries["AdditionalInfo"] = input.AdditionalInfo;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.InstanceIds !== undefined) {
    const memberEntries = serializeAws_ec2InstanceIdStringList(
      input.InstanceIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `InstanceId.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2StartVpcEndpointServicePrivateDnsVerificationRequest = (
  input: StartVpcEndpointServicePrivateDnsVerificationRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.ServiceId !== undefined) {
    entries["ServiceId"] = input.ServiceId;
  }
  return entries;
};

const serializeAws_ec2StopInstancesRequest = (
  input: StopInstancesRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Force !== undefined) {
    entries["Force"] = input.Force;
  }
  if (input.Hibernate !== undefined) {
    entries["Hibernate"] = input.Hibernate;
  }
  if (input.InstanceIds !== undefined) {
    const memberEntries = serializeAws_ec2InstanceIdStringList(
      input.InstanceIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `InstanceId.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2Storage = (
  input: Storage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.S3 !== undefined) {
    const memberEntries = serializeAws_ec2S3Storage(input.S3, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `S3.${key}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2StorageLocation = (
  input: StorageLocation,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Bucket !== undefined) {
    entries["Bucket"] = input.Bucket;
  }
  if (input.Key !== undefined) {
    entries["Key"] = input.Key;
  }
  return entries;
};

const serializeAws_ec2SubnetIdStringList = (
  input: string[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    entries[`SubnetId.${counter}`] = entry;
    counter++;
  }
  return entries;
};

const serializeAws_ec2Tag = (input: Tag, context: __SerdeContext): any => {
  const entries: any = {};
  if (input.Key !== undefined) {
    entries["Key"] = input.Key;
  }
  if (input.Value !== undefined) {
    entries["Value"] = input.Value;
  }
  return entries;
};

const serializeAws_ec2TagList = (
  input: Tag[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    const memberEntries = serializeAws_ec2Tag(entry, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      entries[`Item.${counter}.${key}`] = value;
    });
    counter++;
  }
  return entries;
};

const serializeAws_ec2TagSpecification = (
  input: TagSpecification,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.ResourceType !== undefined) {
    entries["ResourceType"] = input.ResourceType;
  }
  if (input.Tags !== undefined) {
    const memberEntries = serializeAws_ec2TagList(input.Tags, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Tag.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2TagSpecificationList = (
  input: TagSpecification[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    const memberEntries = serializeAws_ec2TagSpecification(entry, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      entries[`Item.${counter}.${key}`] = value;
    });
    counter++;
  }
  return entries;
};

const serializeAws_ec2TargetCapacitySpecificationRequest = (
  input: TargetCapacitySpecificationRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DefaultTargetCapacityType !== undefined) {
    entries["DefaultTargetCapacityType"] = input.DefaultTargetCapacityType;
  }
  if (input.OnDemandTargetCapacity !== undefined) {
    entries["OnDemandTargetCapacity"] = input.OnDemandTargetCapacity;
  }
  if (input.SpotTargetCapacity !== undefined) {
    entries["SpotTargetCapacity"] = input.SpotTargetCapacity;
  }
  if (input.TotalTargetCapacity !== undefined) {
    entries["TotalTargetCapacity"] = input.TotalTargetCapacity;
  }
  return entries;
};

const serializeAws_ec2TargetConfigurationRequest = (
  input: TargetConfigurationRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.InstanceCount !== undefined) {
    entries["InstanceCount"] = input.InstanceCount;
  }
  if (input.OfferingId !== undefined) {
    entries["OfferingId"] = input.OfferingId;
  }
  return entries;
};

const serializeAws_ec2TargetConfigurationRequestSet = (
  input: TargetConfigurationRequest[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    const memberEntries = serializeAws_ec2TargetConfigurationRequest(
      entry,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      entries[`TargetConfigurationRequest.${counter}.${key}`] = value;
    });
    counter++;
  }
  return entries;
};

const serializeAws_ec2TargetGroup = (
  input: TargetGroup,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Arn !== undefined) {
    entries["Arn"] = input.Arn;
  }
  return entries;
};

const serializeAws_ec2TargetGroups = (
  input: TargetGroup[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    const memberEntries = serializeAws_ec2TargetGroup(entry, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      entries[`Item.${counter}.${key}`] = value;
    });
    counter++;
  }
  return entries;
};

const serializeAws_ec2TargetGroupsConfig = (
  input: TargetGroupsConfig,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.TargetGroups !== undefined) {
    const memberEntries = serializeAws_ec2TargetGroups(
      input.TargetGroups,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `TargetGroups.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2TerminateClientVpnConnectionsRequest = (
  input: TerminateClientVpnConnectionsRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.ClientVpnEndpointId !== undefined) {
    entries["ClientVpnEndpointId"] = input.ClientVpnEndpointId;
  }
  if (input.ConnectionId !== undefined) {
    entries["ConnectionId"] = input.ConnectionId;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.Username !== undefined) {
    entries["Username"] = input.Username;
  }
  return entries;
};

const serializeAws_ec2TerminateInstancesRequest = (
  input: TerminateInstancesRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.InstanceIds !== undefined) {
    const memberEntries = serializeAws_ec2InstanceIdStringList(
      input.InstanceIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `InstanceId.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2TrafficMirrorFilterRuleFieldList = (
  input: (TrafficMirrorFilterRuleField | string)[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    entries[`Member.${counter}`] = entry;
    counter++;
  }
  return entries;
};

const serializeAws_ec2TrafficMirrorNetworkServiceList = (
  input: (TrafficMirrorNetworkService | string)[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    entries[`Item.${counter}`] = entry;
    counter++;
  }
  return entries;
};

const serializeAws_ec2TrafficMirrorPortRangeRequest = (
  input: TrafficMirrorPortRangeRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.FromPort !== undefined) {
    entries["FromPort"] = input.FromPort;
  }
  if (input.ToPort !== undefined) {
    entries["ToPort"] = input.ToPort;
  }
  return entries;
};

const serializeAws_ec2TrafficMirrorSessionFieldList = (
  input: (TrafficMirrorSessionField | string)[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    entries[`Member.${counter}`] = entry;
    counter++;
  }
  return entries;
};

const serializeAws_ec2TransitGatewayAttachmentIdStringList = (
  input: string[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    entries[`Member.${counter}`] = entry;
    counter++;
  }
  return entries;
};

const serializeAws_ec2TransitGatewayIdStringList = (
  input: string[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    entries[`Item.${counter}`] = entry;
    counter++;
  }
  return entries;
};

const serializeAws_ec2TransitGatewayMulticastDomainIdStringList = (
  input: string[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    entries[`Item.${counter}`] = entry;
    counter++;
  }
  return entries;
};

const serializeAws_ec2TransitGatewayRequestOptions = (
  input: TransitGatewayRequestOptions,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.AmazonSideAsn !== undefined) {
    entries["AmazonSideAsn"] = input.AmazonSideAsn;
  }
  if (input.AutoAcceptSharedAttachments !== undefined) {
    entries["AutoAcceptSharedAttachments"] = input.AutoAcceptSharedAttachments;
  }
  if (input.DefaultRouteTableAssociation !== undefined) {
    entries["DefaultRouteTableAssociation"] =
      input.DefaultRouteTableAssociation;
  }
  if (input.DefaultRouteTablePropagation !== undefined) {
    entries["DefaultRouteTablePropagation"] =
      input.DefaultRouteTablePropagation;
  }
  if (input.DnsSupport !== undefined) {
    entries["DnsSupport"] = input.DnsSupport;
  }
  if (input.MulticastSupport !== undefined) {
    entries["MulticastSupport"] = input.MulticastSupport;
  }
  if (input.VpnEcmpSupport !== undefined) {
    entries["VpnEcmpSupport"] = input.VpnEcmpSupport;
  }
  return entries;
};

const serializeAws_ec2TransitGatewayRouteTableIdStringList = (
  input: string[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    entries[`Item.${counter}`] = entry;
    counter++;
  }
  return entries;
};

const serializeAws_ec2UnassignIpv6AddressesRequest = (
  input: UnassignIpv6AddressesRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Ipv6Addresses !== undefined) {
    const memberEntries = serializeAws_ec2Ipv6AddressList(
      input.Ipv6Addresses,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Ipv6Addresses.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.NetworkInterfaceId !== undefined) {
    entries["NetworkInterfaceId"] = input.NetworkInterfaceId;
  }
  return entries;
};

const serializeAws_ec2UnassignPrivateIpAddressesRequest = (
  input: UnassignPrivateIpAddressesRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.NetworkInterfaceId !== undefined) {
    entries["NetworkInterfaceId"] = input.NetworkInterfaceId;
  }
  if (input.PrivateIpAddresses !== undefined) {
    const memberEntries = serializeAws_ec2PrivateIpAddressStringList(
      input.PrivateIpAddresses,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `PrivateIpAddress.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2UnmonitorInstancesRequest = (
  input: UnmonitorInstancesRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.InstanceIds !== undefined) {
    const memberEntries = serializeAws_ec2InstanceIdStringList(
      input.InstanceIds,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `InstanceId.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2UpdateSecurityGroupRuleDescriptionsEgressRequest = (
  input: UpdateSecurityGroupRuleDescriptionsEgressRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.GroupId !== undefined) {
    entries["GroupId"] = input.GroupId;
  }
  if (input.GroupName !== undefined) {
    entries["GroupName"] = input.GroupName;
  }
  if (input.IpPermissions !== undefined) {
    const memberEntries = serializeAws_ec2IpPermissionList(
      input.IpPermissions,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `IpPermissions.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2UpdateSecurityGroupRuleDescriptionsIngressRequest = (
  input: UpdateSecurityGroupRuleDescriptionsIngressRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.GroupId !== undefined) {
    entries["GroupId"] = input.GroupId;
  }
  if (input.GroupName !== undefined) {
    entries["GroupName"] = input.GroupName;
  }
  if (input.IpPermissions !== undefined) {
    const memberEntries = serializeAws_ec2IpPermissionList(
      input.IpPermissions,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `IpPermissions.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2UserBucket = (
  input: UserBucket,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.S3Bucket !== undefined) {
    entries["S3Bucket"] = input.S3Bucket;
  }
  if (input.S3Key !== undefined) {
    entries["S3Key"] = input.S3Key;
  }
  return entries;
};

const serializeAws_ec2UserData = (
  input: UserData,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Data !== undefined) {
    entries["Data"] = input.Data;
  }
  return entries;
};

const serializeAws_ec2UserGroupStringList = (
  input: string[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    entries[`UserGroup.${counter}`] = entry;
    counter++;
  }
  return entries;
};

const serializeAws_ec2UserIdGroupPair = (
  input: UserIdGroupPair,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Description !== undefined) {
    entries["Description"] = input.Description;
  }
  if (input.GroupId !== undefined) {
    entries["GroupId"] = input.GroupId;
  }
  if (input.GroupName !== undefined) {
    entries["GroupName"] = input.GroupName;
  }
  if (input.PeeringStatus !== undefined) {
    entries["PeeringStatus"] = input.PeeringStatus;
  }
  if (input.UserId !== undefined) {
    entries["UserId"] = input.UserId;
  }
  if (input.VpcId !== undefined) {
    entries["VpcId"] = input.VpcId;
  }
  if (input.VpcPeeringConnectionId !== undefined) {
    entries["VpcPeeringConnectionId"] = input.VpcPeeringConnectionId;
  }
  return entries;
};

const serializeAws_ec2UserIdGroupPairList = (
  input: UserIdGroupPair[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    const memberEntries = serializeAws_ec2UserIdGroupPair(entry, context);
    Object.entries(memberEntries).forEach(([key, value]) => {
      entries[`Item.${counter}.${key}`] = value;
    });
    counter++;
  }
  return entries;
};

const serializeAws_ec2UserIdStringList = (
  input: string[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    entries[`UserId.${counter}`] = entry;
    counter++;
  }
  return entries;
};

const serializeAws_ec2ValueStringList = (
  input: string[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    entries[`Item.${counter}`] = entry;
    counter++;
  }
  return entries;
};

const serializeAws_ec2VersionStringList = (
  input: string[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    entries[`Item.${counter}`] = entry;
    counter++;
  }
  return entries;
};

const serializeAws_ec2VolumeDetail = (
  input: VolumeDetail,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Size !== undefined) {
    entries["Size"] = input.Size;
  }
  return entries;
};

const serializeAws_ec2VolumeIdStringList = (
  input: string[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    entries[`VolumeId.${counter}`] = entry;
    counter++;
  }
  return entries;
};

const serializeAws_ec2VpcClassicLinkIdList = (
  input: string[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    entries[`VpcId.${counter}`] = entry;
    counter++;
  }
  return entries;
};

const serializeAws_ec2VpcIdStringList = (
  input: string[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    entries[`VpcId.${counter}`] = entry;
    counter++;
  }
  return entries;
};

const serializeAws_ec2VpnConnectionIdStringList = (
  input: string[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    entries[`VpnConnectionId.${counter}`] = entry;
    counter++;
  }
  return entries;
};

const serializeAws_ec2VpnConnectionOptionsSpecification = (
  input: VpnConnectionOptionsSpecification,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.EnableAcceleration !== undefined) {
    entries["EnableAcceleration"] = input.EnableAcceleration;
  }
  if (input.StaticRoutesOnly !== undefined) {
    entries["StaticRoutesOnly"] = input.StaticRoutesOnly;
  }
  if (input.TunnelOptions !== undefined) {
    const memberEntries = serializeAws_ec2VpnTunnelOptionsSpecificationsList(
      input.TunnelOptions,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `TunnelOptions.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  return entries;
};

const serializeAws_ec2VpnGatewayIdStringList = (
  input: string[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    entries[`VpnGatewayId.${counter}`] = entry;
    counter++;
  }
  return entries;
};

const serializeAws_ec2VpnTunnelOptionsSpecification = (
  input: VpnTunnelOptionsSpecification,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DPDTimeoutSeconds !== undefined) {
    entries["DPDTimeoutSeconds"] = input.DPDTimeoutSeconds;
  }
  if (input.IKEVersions !== undefined) {
    const memberEntries = serializeAws_ec2IKEVersionsRequestList(
      input.IKEVersions,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `IKEVersion.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.Phase1DHGroupNumbers !== undefined) {
    const memberEntries = serializeAws_ec2Phase1DHGroupNumbersRequestList(
      input.Phase1DHGroupNumbers,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Phase1DHGroupNumber.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.Phase1EncryptionAlgorithms !== undefined) {
    const memberEntries = serializeAws_ec2Phase1EncryptionAlgorithmsRequestList(
      input.Phase1EncryptionAlgorithms,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Phase1EncryptionAlgorithm.${key.substring(
        key.indexOf(".") + 1
      )}`;
      entries[loc] = value;
    });
  }
  if (input.Phase1IntegrityAlgorithms !== undefined) {
    const memberEntries = serializeAws_ec2Phase1IntegrityAlgorithmsRequestList(
      input.Phase1IntegrityAlgorithms,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Phase1IntegrityAlgorithm.${key.substring(
        key.indexOf(".") + 1
      )}`;
      entries[loc] = value;
    });
  }
  if (input.Phase1LifetimeSeconds !== undefined) {
    entries["Phase1LifetimeSeconds"] = input.Phase1LifetimeSeconds;
  }
  if (input.Phase2DHGroupNumbers !== undefined) {
    const memberEntries = serializeAws_ec2Phase2DHGroupNumbersRequestList(
      input.Phase2DHGroupNumbers,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Phase2DHGroupNumber.${key.substring(key.indexOf(".") + 1)}`;
      entries[loc] = value;
    });
  }
  if (input.Phase2EncryptionAlgorithms !== undefined) {
    const memberEntries = serializeAws_ec2Phase2EncryptionAlgorithmsRequestList(
      input.Phase2EncryptionAlgorithms,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Phase2EncryptionAlgorithm.${key.substring(
        key.indexOf(".") + 1
      )}`;
      entries[loc] = value;
    });
  }
  if (input.Phase2IntegrityAlgorithms !== undefined) {
    const memberEntries = serializeAws_ec2Phase2IntegrityAlgorithmsRequestList(
      input.Phase2IntegrityAlgorithms,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      const loc = `Phase2IntegrityAlgorithm.${key.substring(
        key.indexOf(".") + 1
      )}`;
      entries[loc] = value;
    });
  }
  if (input.Phase2LifetimeSeconds !== undefined) {
    entries["Phase2LifetimeSeconds"] = input.Phase2LifetimeSeconds;
  }
  if (input.PreSharedKey !== undefined) {
    entries["PreSharedKey"] = input.PreSharedKey;
  }
  if (input.RekeyFuzzPercentage !== undefined) {
    entries["RekeyFuzzPercentage"] = input.RekeyFuzzPercentage;
  }
  if (input.RekeyMarginTimeSeconds !== undefined) {
    entries["RekeyMarginTimeSeconds"] = input.RekeyMarginTimeSeconds;
  }
  if (input.ReplayWindowSize !== undefined) {
    entries["ReplayWindowSize"] = input.ReplayWindowSize;
  }
  if (input.TunnelInsideCidr !== undefined) {
    entries["TunnelInsideCidr"] = input.TunnelInsideCidr;
  }
  return entries;
};

const serializeAws_ec2VpnTunnelOptionsSpecificationsList = (
  input: VpnTunnelOptionsSpecification[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    const memberEntries = serializeAws_ec2VpnTunnelOptionsSpecification(
      entry,
      context
    );
    Object.entries(memberEntries).forEach(([key, value]) => {
      entries[`Member.${counter}.${key}`] = value;
    });
    counter++;
  }
  return entries;
};

const serializeAws_ec2WithdrawByoipCidrRequest = (
  input: WithdrawByoipCidrRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Cidr !== undefined) {
    entries["Cidr"] = input.Cidr;
  }
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  return entries;
};

const serializeAws_ec2ZoneIdStringList = (
  input: string[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    entries[`ZoneId.${counter}`] = entry;
    counter++;
  }
  return entries;
};

const serializeAws_ec2ZoneNameStringList = (
  input: string[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    entries[`ZoneName.${counter}`] = entry;
    counter++;
  }
  return entries;
};

const deserializeAws_ec2AcceptReservedInstancesExchangeQuoteResult = (
  output: any,
  context: __SerdeContext
): AcceptReservedInstancesExchangeQuoteResult => {
  let contents: any = {
    __type: "AcceptReservedInstancesExchangeQuoteResult",
    ExchangeId: undefined
  };
  if (output["exchangeId"] !== undefined) {
    contents.ExchangeId = output["exchangeId"];
  }
  return contents;
};

const deserializeAws_ec2AcceptTransitGatewayPeeringAttachmentResult = (
  output: any,
  context: __SerdeContext
): AcceptTransitGatewayPeeringAttachmentResult => {
  let contents: any = {
    __type: "AcceptTransitGatewayPeeringAttachmentResult",
    TransitGatewayPeeringAttachment: undefined
  };
  if (output["transitGatewayPeeringAttachment"] !== undefined) {
    contents.TransitGatewayPeeringAttachment = deserializeAws_ec2TransitGatewayPeeringAttachment(
      output["transitGatewayPeeringAttachment"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2AcceptTransitGatewayVpcAttachmentResult = (
  output: any,
  context: __SerdeContext
): AcceptTransitGatewayVpcAttachmentResult => {
  let contents: any = {
    __type: "AcceptTransitGatewayVpcAttachmentResult",
    TransitGatewayVpcAttachment: undefined
  };
  if (output["transitGatewayVpcAttachment"] !== undefined) {
    contents.TransitGatewayVpcAttachment = deserializeAws_ec2TransitGatewayVpcAttachment(
      output["transitGatewayVpcAttachment"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2AcceptVpcEndpointConnectionsResult = (
  output: any,
  context: __SerdeContext
): AcceptVpcEndpointConnectionsResult => {
  let contents: any = {
    __type: "AcceptVpcEndpointConnectionsResult",
    Unsuccessful: undefined
  };
  if (output.unsuccessful === "") {
    contents.Unsuccessful = [];
  }
  if (
    output["unsuccessful"] !== undefined &&
    output["unsuccessful"]["item"] !== undefined
  ) {
    contents.Unsuccessful = deserializeAws_ec2UnsuccessfulItemSet(
      __getArrayIfSingleItem(output["unsuccessful"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2AcceptVpcPeeringConnectionResult = (
  output: any,
  context: __SerdeContext
): AcceptVpcPeeringConnectionResult => {
  let contents: any = {
    __type: "AcceptVpcPeeringConnectionResult",
    VpcPeeringConnection: undefined
  };
  if (output["vpcPeeringConnection"] !== undefined) {
    contents.VpcPeeringConnection = deserializeAws_ec2VpcPeeringConnection(
      output["vpcPeeringConnection"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2AccountAttribute = (
  output: any,
  context: __SerdeContext
): AccountAttribute => {
  let contents: any = {
    __type: "AccountAttribute",
    AttributeName: undefined,
    AttributeValues: undefined
  };
  if (output["attributeName"] !== undefined) {
    contents.AttributeName = output["attributeName"];
  }
  if (output.attributeValueSet === "") {
    contents.AttributeValues = [];
  }
  if (
    output["attributeValueSet"] !== undefined &&
    output["attributeValueSet"]["item"] !== undefined
  ) {
    contents.AttributeValues = deserializeAws_ec2AccountAttributeValueList(
      __getArrayIfSingleItem(output["attributeValueSet"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2AccountAttributeList = (
  output: any,
  context: __SerdeContext
): AccountAttribute[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2AccountAttribute(entry, context)
  );
};

const deserializeAws_ec2AccountAttributeValue = (
  output: any,
  context: __SerdeContext
): AccountAttributeValue => {
  let contents: any = {
    __type: "AccountAttributeValue",
    AttributeValue: undefined
  };
  if (output["attributeValue"] !== undefined) {
    contents.AttributeValue = output["attributeValue"];
  }
  return contents;
};

const deserializeAws_ec2AccountAttributeValueList = (
  output: any,
  context: __SerdeContext
): AccountAttributeValue[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2AccountAttributeValue(entry, context)
  );
};

const deserializeAws_ec2ActiveInstance = (
  output: any,
  context: __SerdeContext
): ActiveInstance => {
  let contents: any = {
    __type: "ActiveInstance",
    InstanceHealth: undefined,
    InstanceId: undefined,
    InstanceType: undefined,
    SpotInstanceRequestId: undefined
  };
  if (output["instanceHealth"] !== undefined) {
    contents.InstanceHealth = output["instanceHealth"];
  }
  if (output["instanceId"] !== undefined) {
    contents.InstanceId = output["instanceId"];
  }
  if (output["instanceType"] !== undefined) {
    contents.InstanceType = output["instanceType"];
  }
  if (output["spotInstanceRequestId"] !== undefined) {
    contents.SpotInstanceRequestId = output["spotInstanceRequestId"];
  }
  return contents;
};

const deserializeAws_ec2ActiveInstanceSet = (
  output: any,
  context: __SerdeContext
): ActiveInstance[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2ActiveInstance(entry, context)
  );
};

const deserializeAws_ec2Address = (
  output: any,
  context: __SerdeContext
): Address => {
  let contents: any = {
    __type: "Address",
    AllocationId: undefined,
    AssociationId: undefined,
    CustomerOwnedIp: undefined,
    CustomerOwnedIpv4Pool: undefined,
    Domain: undefined,
    InstanceId: undefined,
    NetworkBorderGroup: undefined,
    NetworkInterfaceId: undefined,
    NetworkInterfaceOwnerId: undefined,
    PrivateIpAddress: undefined,
    PublicIp: undefined,
    PublicIpv4Pool: undefined,
    Tags: undefined
  };
  if (output["allocationId"] !== undefined) {
    contents.AllocationId = output["allocationId"];
  }
  if (output["associationId"] !== undefined) {
    contents.AssociationId = output["associationId"];
  }
  if (output["customerOwnedIp"] !== undefined) {
    contents.CustomerOwnedIp = output["customerOwnedIp"];
  }
  if (output["customerOwnedIpv4Pool"] !== undefined) {
    contents.CustomerOwnedIpv4Pool = output["customerOwnedIpv4Pool"];
  }
  if (output["domain"] !== undefined) {
    contents.Domain = output["domain"];
  }
  if (output["instanceId"] !== undefined) {
    contents.InstanceId = output["instanceId"];
  }
  if (output["networkBorderGroup"] !== undefined) {
    contents.NetworkBorderGroup = output["networkBorderGroup"];
  }
  if (output["networkInterfaceId"] !== undefined) {
    contents.NetworkInterfaceId = output["networkInterfaceId"];
  }
  if (output["networkInterfaceOwnerId"] !== undefined) {
    contents.NetworkInterfaceOwnerId = output["networkInterfaceOwnerId"];
  }
  if (output["privateIpAddress"] !== undefined) {
    contents.PrivateIpAddress = output["privateIpAddress"];
  }
  if (output["publicIp"] !== undefined) {
    contents.PublicIp = output["publicIp"];
  }
  if (output["publicIpv4Pool"] !== undefined) {
    contents.PublicIpv4Pool = output["publicIpv4Pool"];
  }
  if (output.tagSet === "") {
    contents.Tags = [];
  }
  if (
    output["tagSet"] !== undefined &&
    output["tagSet"]["item"] !== undefined
  ) {
    contents.Tags = deserializeAws_ec2TagList(
      __getArrayIfSingleItem(output["tagSet"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2AddressList = (
  output: any,
  context: __SerdeContext
): Address[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2Address(entry, context)
  );
};

const deserializeAws_ec2AdvertiseByoipCidrResult = (
  output: any,
  context: __SerdeContext
): AdvertiseByoipCidrResult => {
  let contents: any = {
    __type: "AdvertiseByoipCidrResult",
    ByoipCidr: undefined
  };
  if (output["byoipCidr"] !== undefined) {
    contents.ByoipCidr = deserializeAws_ec2ByoipCidr(
      output["byoipCidr"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2AllocateAddressResult = (
  output: any,
  context: __SerdeContext
): AllocateAddressResult => {
  let contents: any = {
    __type: "AllocateAddressResult",
    AllocationId: undefined,
    CustomerOwnedIp: undefined,
    CustomerOwnedIpv4Pool: undefined,
    Domain: undefined,
    NetworkBorderGroup: undefined,
    PublicIp: undefined,
    PublicIpv4Pool: undefined
  };
  if (output["allocationId"] !== undefined) {
    contents.AllocationId = output["allocationId"];
  }
  if (output["customerOwnedIp"] !== undefined) {
    contents.CustomerOwnedIp = output["customerOwnedIp"];
  }
  if (output["customerOwnedIpv4Pool"] !== undefined) {
    contents.CustomerOwnedIpv4Pool = output["customerOwnedIpv4Pool"];
  }
  if (output["domain"] !== undefined) {
    contents.Domain = output["domain"];
  }
  if (output["networkBorderGroup"] !== undefined) {
    contents.NetworkBorderGroup = output["networkBorderGroup"];
  }
  if (output["publicIp"] !== undefined) {
    contents.PublicIp = output["publicIp"];
  }
  if (output["publicIpv4Pool"] !== undefined) {
    contents.PublicIpv4Pool = output["publicIpv4Pool"];
  }
  return contents;
};

const deserializeAws_ec2AllocateHostsResult = (
  output: any,
  context: __SerdeContext
): AllocateHostsResult => {
  let contents: any = {
    __type: "AllocateHostsResult",
    HostIds: undefined
  };
  if (output.hostIdSet === "") {
    contents.HostIds = [];
  }
  if (
    output["hostIdSet"] !== undefined &&
    output["hostIdSet"]["item"] !== undefined
  ) {
    contents.HostIds = deserializeAws_ec2ResponseHostIdList(
      __getArrayIfSingleItem(output["hostIdSet"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2AllowedPrincipal = (
  output: any,
  context: __SerdeContext
): AllowedPrincipal => {
  let contents: any = {
    __type: "AllowedPrincipal",
    Principal: undefined,
    PrincipalType: undefined
  };
  if (output["principal"] !== undefined) {
    contents.Principal = output["principal"];
  }
  if (output["principalType"] !== undefined) {
    contents.PrincipalType = output["principalType"];
  }
  return contents;
};

const deserializeAws_ec2AllowedPrincipalSet = (
  output: any,
  context: __SerdeContext
): AllowedPrincipal[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2AllowedPrincipal(entry, context)
  );
};

const deserializeAws_ec2ApplySecurityGroupsToClientVpnTargetNetworkResult = (
  output: any,
  context: __SerdeContext
): ApplySecurityGroupsToClientVpnTargetNetworkResult => {
  let contents: any = {
    __type: "ApplySecurityGroupsToClientVpnTargetNetworkResult",
    SecurityGroupIds: undefined
  };
  if (output.securityGroupIds === "") {
    contents.SecurityGroupIds = [];
  }
  if (
    output["securityGroupIds"] !== undefined &&
    output["securityGroupIds"]["item"] !== undefined
  ) {
    contents.SecurityGroupIds = deserializeAws_ec2ClientVpnSecurityGroupIdSet(
      __getArrayIfSingleItem(output["securityGroupIds"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2ArchitectureTypeList = (
  output: any,
  context: __SerdeContext
): (ArchitectureType | string)[] => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_ec2AssignedPrivateIpAddress = (
  output: any,
  context: __SerdeContext
): AssignedPrivateIpAddress => {
  let contents: any = {
    __type: "AssignedPrivateIpAddress",
    PrivateIpAddress: undefined
  };
  if (output["privateIpAddress"] !== undefined) {
    contents.PrivateIpAddress = output["privateIpAddress"];
  }
  return contents;
};

const deserializeAws_ec2AssignedPrivateIpAddressList = (
  output: any,
  context: __SerdeContext
): AssignedPrivateIpAddress[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2AssignedPrivateIpAddress(entry, context)
  );
};

const deserializeAws_ec2AssignIpv6AddressesResult = (
  output: any,
  context: __SerdeContext
): AssignIpv6AddressesResult => {
  let contents: any = {
    __type: "AssignIpv6AddressesResult",
    AssignedIpv6Addresses: undefined,
    NetworkInterfaceId: undefined
  };
  if (output.assignedIpv6Addresses === "") {
    contents.AssignedIpv6Addresses = [];
  }
  if (
    output["assignedIpv6Addresses"] !== undefined &&
    output["assignedIpv6Addresses"]["item"] !== undefined
  ) {
    contents.AssignedIpv6Addresses = deserializeAws_ec2Ipv6AddressList(
      __getArrayIfSingleItem(output["assignedIpv6Addresses"]["item"]),
      context
    );
  }
  if (output["networkInterfaceId"] !== undefined) {
    contents.NetworkInterfaceId = output["networkInterfaceId"];
  }
  return contents;
};

const deserializeAws_ec2AssignPrivateIpAddressesResult = (
  output: any,
  context: __SerdeContext
): AssignPrivateIpAddressesResult => {
  let contents: any = {
    __type: "AssignPrivateIpAddressesResult",
    AssignedPrivateIpAddresses: undefined,
    NetworkInterfaceId: undefined
  };
  if (output.assignedPrivateIpAddressesSet === "") {
    contents.AssignedPrivateIpAddresses = [];
  }
  if (
    output["assignedPrivateIpAddressesSet"] !== undefined &&
    output["assignedPrivateIpAddressesSet"]["item"] !== undefined
  ) {
    contents.AssignedPrivateIpAddresses = deserializeAws_ec2AssignedPrivateIpAddressList(
      __getArrayIfSingleItem(output["assignedPrivateIpAddressesSet"]["item"]),
      context
    );
  }
  if (output["networkInterfaceId"] !== undefined) {
    contents.NetworkInterfaceId = output["networkInterfaceId"];
  }
  return contents;
};

const deserializeAws_ec2AssociateAddressResult = (
  output: any,
  context: __SerdeContext
): AssociateAddressResult => {
  let contents: any = {
    __type: "AssociateAddressResult",
    AssociationId: undefined
  };
  if (output["associationId"] !== undefined) {
    contents.AssociationId = output["associationId"];
  }
  return contents;
};

const deserializeAws_ec2AssociateClientVpnTargetNetworkResult = (
  output: any,
  context: __SerdeContext
): AssociateClientVpnTargetNetworkResult => {
  let contents: any = {
    __type: "AssociateClientVpnTargetNetworkResult",
    AssociationId: undefined,
    Status: undefined
  };
  if (output["associationId"] !== undefined) {
    contents.AssociationId = output["associationId"];
  }
  if (output["status"] !== undefined) {
    contents.Status = deserializeAws_ec2AssociationStatus(
      output["status"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2AssociatedTargetNetwork = (
  output: any,
  context: __SerdeContext
): AssociatedTargetNetwork => {
  let contents: any = {
    __type: "AssociatedTargetNetwork",
    NetworkId: undefined,
    NetworkType: undefined
  };
  if (output["networkId"] !== undefined) {
    contents.NetworkId = output["networkId"];
  }
  if (output["networkType"] !== undefined) {
    contents.NetworkType = output["networkType"];
  }
  return contents;
};

const deserializeAws_ec2AssociatedTargetNetworkSet = (
  output: any,
  context: __SerdeContext
): AssociatedTargetNetwork[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2AssociatedTargetNetwork(entry, context)
  );
};

const deserializeAws_ec2AssociateIamInstanceProfileResult = (
  output: any,
  context: __SerdeContext
): AssociateIamInstanceProfileResult => {
  let contents: any = {
    __type: "AssociateIamInstanceProfileResult",
    IamInstanceProfileAssociation: undefined
  };
  if (output["iamInstanceProfileAssociation"] !== undefined) {
    contents.IamInstanceProfileAssociation = deserializeAws_ec2IamInstanceProfileAssociation(
      output["iamInstanceProfileAssociation"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2AssociateRouteTableResult = (
  output: any,
  context: __SerdeContext
): AssociateRouteTableResult => {
  let contents: any = {
    __type: "AssociateRouteTableResult",
    AssociationId: undefined,
    AssociationState: undefined
  };
  if (output["associationId"] !== undefined) {
    contents.AssociationId = output["associationId"];
  }
  if (output["associationState"] !== undefined) {
    contents.AssociationState = deserializeAws_ec2RouteTableAssociationState(
      output["associationState"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2AssociateSubnetCidrBlockResult = (
  output: any,
  context: __SerdeContext
): AssociateSubnetCidrBlockResult => {
  let contents: any = {
    __type: "AssociateSubnetCidrBlockResult",
    Ipv6CidrBlockAssociation: undefined,
    SubnetId: undefined
  };
  if (output["ipv6CidrBlockAssociation"] !== undefined) {
    contents.Ipv6CidrBlockAssociation = deserializeAws_ec2SubnetIpv6CidrBlockAssociation(
      output["ipv6CidrBlockAssociation"],
      context
    );
  }
  if (output["subnetId"] !== undefined) {
    contents.SubnetId = output["subnetId"];
  }
  return contents;
};

const deserializeAws_ec2AssociateTransitGatewayMulticastDomainResult = (
  output: any,
  context: __SerdeContext
): AssociateTransitGatewayMulticastDomainResult => {
  let contents: any = {
    __type: "AssociateTransitGatewayMulticastDomainResult",
    Associations: undefined
  };
  if (output["associations"] !== undefined) {
    contents.Associations = deserializeAws_ec2TransitGatewayMulticastDomainAssociations(
      output["associations"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2AssociateTransitGatewayRouteTableResult = (
  output: any,
  context: __SerdeContext
): AssociateTransitGatewayRouteTableResult => {
  let contents: any = {
    __type: "AssociateTransitGatewayRouteTableResult",
    Association: undefined
  };
  if (output["association"] !== undefined) {
    contents.Association = deserializeAws_ec2TransitGatewayAssociation(
      output["association"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2AssociateVpcCidrBlockResult = (
  output: any,
  context: __SerdeContext
): AssociateVpcCidrBlockResult => {
  let contents: any = {
    __type: "AssociateVpcCidrBlockResult",
    CidrBlockAssociation: undefined,
    Ipv6CidrBlockAssociation: undefined,
    VpcId: undefined
  };
  if (output["cidrBlockAssociation"] !== undefined) {
    contents.CidrBlockAssociation = deserializeAws_ec2VpcCidrBlockAssociation(
      output["cidrBlockAssociation"],
      context
    );
  }
  if (output["ipv6CidrBlockAssociation"] !== undefined) {
    contents.Ipv6CidrBlockAssociation = deserializeAws_ec2VpcIpv6CidrBlockAssociation(
      output["ipv6CidrBlockAssociation"],
      context
    );
  }
  if (output["vpcId"] !== undefined) {
    contents.VpcId = output["vpcId"];
  }
  return contents;
};

const deserializeAws_ec2AssociationStatus = (
  output: any,
  context: __SerdeContext
): AssociationStatus => {
  let contents: any = {
    __type: "AssociationStatus",
    Code: undefined,
    Message: undefined
  };
  if (output["code"] !== undefined) {
    contents.Code = output["code"];
  }
  if (output["message"] !== undefined) {
    contents.Message = output["message"];
  }
  return contents;
};

const deserializeAws_ec2AttachClassicLinkVpcResult = (
  output: any,
  context: __SerdeContext
): AttachClassicLinkVpcResult => {
  let contents: any = {
    __type: "AttachClassicLinkVpcResult",
    Return: undefined
  };
  if (output["return"] !== undefined) {
    contents.Return = output["return"] == "true";
  }
  return contents;
};

const deserializeAws_ec2AttachNetworkInterfaceResult = (
  output: any,
  context: __SerdeContext
): AttachNetworkInterfaceResult => {
  let contents: any = {
    __type: "AttachNetworkInterfaceResult",
    AttachmentId: undefined
  };
  if (output["attachmentId"] !== undefined) {
    contents.AttachmentId = output["attachmentId"];
  }
  return contents;
};

const deserializeAws_ec2AttachVpnGatewayResult = (
  output: any,
  context: __SerdeContext
): AttachVpnGatewayResult => {
  let contents: any = {
    __type: "AttachVpnGatewayResult",
    VpcAttachment: undefined
  };
  if (output["attachment"] !== undefined) {
    contents.VpcAttachment = deserializeAws_ec2VpcAttachment(
      output["attachment"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2AttributeBooleanValue = (
  output: any,
  context: __SerdeContext
): AttributeBooleanValue => {
  let contents: any = {
    __type: "AttributeBooleanValue",
    Value: undefined
  };
  if (output["value"] !== undefined) {
    contents.Value = output["value"] == "true";
  }
  return contents;
};

const deserializeAws_ec2AttributeValue = (
  output: any,
  context: __SerdeContext
): AttributeValue => {
  let contents: any = {
    __type: "AttributeValue",
    Value: undefined
  };
  if (output["value"] !== undefined) {
    contents.Value = output["value"];
  }
  return contents;
};

const deserializeAws_ec2AuthorizationRule = (
  output: any,
  context: __SerdeContext
): AuthorizationRule => {
  let contents: any = {
    __type: "AuthorizationRule",
    AccessAll: undefined,
    ClientVpnEndpointId: undefined,
    Description: undefined,
    DestinationCidr: undefined,
    GroupId: undefined,
    Status: undefined
  };
  if (output["accessAll"] !== undefined) {
    contents.AccessAll = output["accessAll"] == "true";
  }
  if (output["clientVpnEndpointId"] !== undefined) {
    contents.ClientVpnEndpointId = output["clientVpnEndpointId"];
  }
  if (output["description"] !== undefined) {
    contents.Description = output["description"];
  }
  if (output["destinationCidr"] !== undefined) {
    contents.DestinationCidr = output["destinationCidr"];
  }
  if (output["groupId"] !== undefined) {
    contents.GroupId = output["groupId"];
  }
  if (output["status"] !== undefined) {
    contents.Status = deserializeAws_ec2ClientVpnAuthorizationRuleStatus(
      output["status"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2AuthorizationRuleSet = (
  output: any,
  context: __SerdeContext
): AuthorizationRule[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2AuthorizationRule(entry, context)
  );
};

const deserializeAws_ec2AuthorizeClientVpnIngressResult = (
  output: any,
  context: __SerdeContext
): AuthorizeClientVpnIngressResult => {
  let contents: any = {
    __type: "AuthorizeClientVpnIngressResult",
    Status: undefined
  };
  if (output["status"] !== undefined) {
    contents.Status = deserializeAws_ec2ClientVpnAuthorizationRuleStatus(
      output["status"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2AvailabilityZone = (
  output: any,
  context: __SerdeContext
): AvailabilityZone => {
  let contents: any = {
    __type: "AvailabilityZone",
    GroupName: undefined,
    Messages: undefined,
    NetworkBorderGroup: undefined,
    OptInStatus: undefined,
    RegionName: undefined,
    State: undefined,
    ZoneId: undefined,
    ZoneName: undefined
  };
  if (output["groupName"] !== undefined) {
    contents.GroupName = output["groupName"];
  }
  if (output.messageSet === "") {
    contents.Messages = [];
  }
  if (
    output["messageSet"] !== undefined &&
    output["messageSet"]["item"] !== undefined
  ) {
    contents.Messages = deserializeAws_ec2AvailabilityZoneMessageList(
      __getArrayIfSingleItem(output["messageSet"]["item"]),
      context
    );
  }
  if (output["networkBorderGroup"] !== undefined) {
    contents.NetworkBorderGroup = output["networkBorderGroup"];
  }
  if (output["optInStatus"] !== undefined) {
    contents.OptInStatus = output["optInStatus"];
  }
  if (output["regionName"] !== undefined) {
    contents.RegionName = output["regionName"];
  }
  if (output["zoneState"] !== undefined) {
    contents.State = output["zoneState"];
  }
  if (output["zoneId"] !== undefined) {
    contents.ZoneId = output["zoneId"];
  }
  if (output["zoneName"] !== undefined) {
    contents.ZoneName = output["zoneName"];
  }
  return contents;
};

const deserializeAws_ec2AvailabilityZoneList = (
  output: any,
  context: __SerdeContext
): AvailabilityZone[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2AvailabilityZone(entry, context)
  );
};

const deserializeAws_ec2AvailabilityZoneMessage = (
  output: any,
  context: __SerdeContext
): AvailabilityZoneMessage => {
  let contents: any = {
    __type: "AvailabilityZoneMessage",
    Message: undefined
  };
  if (output["message"] !== undefined) {
    contents.Message = output["message"];
  }
  return contents;
};

const deserializeAws_ec2AvailabilityZoneMessageList = (
  output: any,
  context: __SerdeContext
): AvailabilityZoneMessage[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2AvailabilityZoneMessage(entry, context)
  );
};

const deserializeAws_ec2AvailableCapacity = (
  output: any,
  context: __SerdeContext
): AvailableCapacity => {
  let contents: any = {
    __type: "AvailableCapacity",
    AvailableInstanceCapacity: undefined,
    AvailableVCpus: undefined
  };
  if (output.availableInstanceCapacity === "") {
    contents.AvailableInstanceCapacity = [];
  }
  if (
    output["availableInstanceCapacity"] !== undefined &&
    output["availableInstanceCapacity"]["item"] !== undefined
  ) {
    contents.AvailableInstanceCapacity = deserializeAws_ec2AvailableInstanceCapacityList(
      __getArrayIfSingleItem(output["availableInstanceCapacity"]["item"]),
      context
    );
  }
  if (output["availableVCpus"] !== undefined) {
    contents.AvailableVCpus = parseInt(output["availableVCpus"]);
  }
  return contents;
};

const deserializeAws_ec2AvailableInstanceCapacityList = (
  output: any,
  context: __SerdeContext
): InstanceCapacity[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2InstanceCapacity(entry, context)
  );
};

const deserializeAws_ec2BlockDeviceMapping = (
  output: any,
  context: __SerdeContext
): BlockDeviceMapping => {
  let contents: any = {
    __type: "BlockDeviceMapping",
    DeviceName: undefined,
    Ebs: undefined,
    NoDevice: undefined,
    VirtualName: undefined
  };
  if (output["deviceName"] !== undefined) {
    contents.DeviceName = output["deviceName"];
  }
  if (output["ebs"] !== undefined) {
    contents.Ebs = deserializeAws_ec2EbsBlockDevice(output["ebs"], context);
  }
  if (output["noDevice"] !== undefined) {
    contents.NoDevice = output["noDevice"];
  }
  if (output["virtualName"] !== undefined) {
    contents.VirtualName = output["virtualName"];
  }
  return contents;
};

const deserializeAws_ec2BlockDeviceMappingList = (
  output: any,
  context: __SerdeContext
): BlockDeviceMapping[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2BlockDeviceMapping(entry, context)
  );
};

const deserializeAws_ec2BundleInstanceResult = (
  output: any,
  context: __SerdeContext
): BundleInstanceResult => {
  let contents: any = {
    __type: "BundleInstanceResult",
    BundleTask: undefined
  };
  if (output["bundleInstanceTask"] !== undefined) {
    contents.BundleTask = deserializeAws_ec2BundleTask(
      output["bundleInstanceTask"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2BundleTask = (
  output: any,
  context: __SerdeContext
): BundleTask => {
  let contents: any = {
    __type: "BundleTask",
    BundleId: undefined,
    BundleTaskError: undefined,
    InstanceId: undefined,
    Progress: undefined,
    StartTime: undefined,
    State: undefined,
    Storage: undefined,
    UpdateTime: undefined
  };
  if (output["bundleId"] !== undefined) {
    contents.BundleId = output["bundleId"];
  }
  if (output["error"] !== undefined) {
    contents.BundleTaskError = deserializeAws_ec2BundleTaskError(
      output["error"],
      context
    );
  }
  if (output["instanceId"] !== undefined) {
    contents.InstanceId = output["instanceId"];
  }
  if (output["progress"] !== undefined) {
    contents.Progress = output["progress"];
  }
  if (output["startTime"] !== undefined) {
    contents.StartTime = new Date(output["startTime"]);
  }
  if (output["state"] !== undefined) {
    contents.State = output["state"];
  }
  if (output["storage"] !== undefined) {
    contents.Storage = deserializeAws_ec2Storage(output["storage"], context);
  }
  if (output["updateTime"] !== undefined) {
    contents.UpdateTime = new Date(output["updateTime"]);
  }
  return contents;
};

const deserializeAws_ec2BundleTaskError = (
  output: any,
  context: __SerdeContext
): BundleTaskError => {
  let contents: any = {
    __type: "BundleTaskError",
    Code: undefined,
    Message: undefined
  };
  if (output["code"] !== undefined) {
    contents.Code = output["code"];
  }
  if (output["message"] !== undefined) {
    contents.Message = output["message"];
  }
  return contents;
};

const deserializeAws_ec2BundleTaskList = (
  output: any,
  context: __SerdeContext
): BundleTask[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2BundleTask(entry, context)
  );
};

const deserializeAws_ec2ByoipCidr = (
  output: any,
  context: __SerdeContext
): ByoipCidr => {
  let contents: any = {
    __type: "ByoipCidr",
    Cidr: undefined,
    Description: undefined,
    State: undefined,
    StatusMessage: undefined
  };
  if (output["cidr"] !== undefined) {
    contents.Cidr = output["cidr"];
  }
  if (output["description"] !== undefined) {
    contents.Description = output["description"];
  }
  if (output["state"] !== undefined) {
    contents.State = output["state"];
  }
  if (output["statusMessage"] !== undefined) {
    contents.StatusMessage = output["statusMessage"];
  }
  return contents;
};

const deserializeAws_ec2ByoipCidrSet = (
  output: any,
  context: __SerdeContext
): ByoipCidr[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2ByoipCidr(entry, context)
  );
};

const deserializeAws_ec2CancelBundleTaskResult = (
  output: any,
  context: __SerdeContext
): CancelBundleTaskResult => {
  let contents: any = {
    __type: "CancelBundleTaskResult",
    BundleTask: undefined
  };
  if (output["bundleInstanceTask"] !== undefined) {
    contents.BundleTask = deserializeAws_ec2BundleTask(
      output["bundleInstanceTask"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2CancelCapacityReservationResult = (
  output: any,
  context: __SerdeContext
): CancelCapacityReservationResult => {
  let contents: any = {
    __type: "CancelCapacityReservationResult",
    Return: undefined
  };
  if (output["return"] !== undefined) {
    contents.Return = output["return"] == "true";
  }
  return contents;
};

const deserializeAws_ec2CancelImportTaskResult = (
  output: any,
  context: __SerdeContext
): CancelImportTaskResult => {
  let contents: any = {
    __type: "CancelImportTaskResult",
    ImportTaskId: undefined,
    PreviousState: undefined,
    State: undefined
  };
  if (output["importTaskId"] !== undefined) {
    contents.ImportTaskId = output["importTaskId"];
  }
  if (output["previousState"] !== undefined) {
    contents.PreviousState = output["previousState"];
  }
  if (output["state"] !== undefined) {
    contents.State = output["state"];
  }
  return contents;
};

const deserializeAws_ec2CancelledSpotInstanceRequest = (
  output: any,
  context: __SerdeContext
): CancelledSpotInstanceRequest => {
  let contents: any = {
    __type: "CancelledSpotInstanceRequest",
    SpotInstanceRequestId: undefined,
    State: undefined
  };
  if (output["spotInstanceRequestId"] !== undefined) {
    contents.SpotInstanceRequestId = output["spotInstanceRequestId"];
  }
  if (output["state"] !== undefined) {
    contents.State = output["state"];
  }
  return contents;
};

const deserializeAws_ec2CancelledSpotInstanceRequestList = (
  output: any,
  context: __SerdeContext
): CancelledSpotInstanceRequest[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2CancelledSpotInstanceRequest(entry, context)
  );
};

const deserializeAws_ec2CancelReservedInstancesListingResult = (
  output: any,
  context: __SerdeContext
): CancelReservedInstancesListingResult => {
  let contents: any = {
    __type: "CancelReservedInstancesListingResult",
    ReservedInstancesListings: undefined
  };
  if (output.reservedInstancesListingsSet === "") {
    contents.ReservedInstancesListings = [];
  }
  if (
    output["reservedInstancesListingsSet"] !== undefined &&
    output["reservedInstancesListingsSet"]["item"] !== undefined
  ) {
    contents.ReservedInstancesListings = deserializeAws_ec2ReservedInstancesListingList(
      __getArrayIfSingleItem(output["reservedInstancesListingsSet"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2CancelSpotFleetRequestsError = (
  output: any,
  context: __SerdeContext
): CancelSpotFleetRequestsError => {
  let contents: any = {
    __type: "CancelSpotFleetRequestsError",
    Code: undefined,
    Message: undefined
  };
  if (output["code"] !== undefined) {
    contents.Code = output["code"];
  }
  if (output["message"] !== undefined) {
    contents.Message = output["message"];
  }
  return contents;
};

const deserializeAws_ec2CancelSpotFleetRequestsErrorItem = (
  output: any,
  context: __SerdeContext
): CancelSpotFleetRequestsErrorItem => {
  let contents: any = {
    __type: "CancelSpotFleetRequestsErrorItem",
    Error: undefined,
    SpotFleetRequestId: undefined
  };
  if (output["error"] !== undefined) {
    contents.Error = deserializeAws_ec2CancelSpotFleetRequestsError(
      output["error"],
      context
    );
  }
  if (output["spotFleetRequestId"] !== undefined) {
    contents.SpotFleetRequestId = output["spotFleetRequestId"];
  }
  return contents;
};

const deserializeAws_ec2CancelSpotFleetRequestsErrorSet = (
  output: any,
  context: __SerdeContext
): CancelSpotFleetRequestsErrorItem[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2CancelSpotFleetRequestsErrorItem(entry, context)
  );
};

const deserializeAws_ec2CancelSpotFleetRequestsResponse = (
  output: any,
  context: __SerdeContext
): CancelSpotFleetRequestsResponse => {
  let contents: any = {
    __type: "CancelSpotFleetRequestsResponse",
    SuccessfulFleetRequests: undefined,
    UnsuccessfulFleetRequests: undefined
  };
  if (output.successfulFleetRequestSet === "") {
    contents.SuccessfulFleetRequests = [];
  }
  if (
    output["successfulFleetRequestSet"] !== undefined &&
    output["successfulFleetRequestSet"]["item"] !== undefined
  ) {
    contents.SuccessfulFleetRequests = deserializeAws_ec2CancelSpotFleetRequestsSuccessSet(
      __getArrayIfSingleItem(output["successfulFleetRequestSet"]["item"]),
      context
    );
  }
  if (output.unsuccessfulFleetRequestSet === "") {
    contents.UnsuccessfulFleetRequests = [];
  }
  if (
    output["unsuccessfulFleetRequestSet"] !== undefined &&
    output["unsuccessfulFleetRequestSet"]["item"] !== undefined
  ) {
    contents.UnsuccessfulFleetRequests = deserializeAws_ec2CancelSpotFleetRequestsErrorSet(
      __getArrayIfSingleItem(output["unsuccessfulFleetRequestSet"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2CancelSpotFleetRequestsSuccessItem = (
  output: any,
  context: __SerdeContext
): CancelSpotFleetRequestsSuccessItem => {
  let contents: any = {
    __type: "CancelSpotFleetRequestsSuccessItem",
    CurrentSpotFleetRequestState: undefined,
    PreviousSpotFleetRequestState: undefined,
    SpotFleetRequestId: undefined
  };
  if (output["currentSpotFleetRequestState"] !== undefined) {
    contents.CurrentSpotFleetRequestState =
      output["currentSpotFleetRequestState"];
  }
  if (output["previousSpotFleetRequestState"] !== undefined) {
    contents.PreviousSpotFleetRequestState =
      output["previousSpotFleetRequestState"];
  }
  if (output["spotFleetRequestId"] !== undefined) {
    contents.SpotFleetRequestId = output["spotFleetRequestId"];
  }
  return contents;
};

const deserializeAws_ec2CancelSpotFleetRequestsSuccessSet = (
  output: any,
  context: __SerdeContext
): CancelSpotFleetRequestsSuccessItem[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2CancelSpotFleetRequestsSuccessItem(entry, context)
  );
};

const deserializeAws_ec2CancelSpotInstanceRequestsResult = (
  output: any,
  context: __SerdeContext
): CancelSpotInstanceRequestsResult => {
  let contents: any = {
    __type: "CancelSpotInstanceRequestsResult",
    CancelledSpotInstanceRequests: undefined
  };
  if (output.spotInstanceRequestSet === "") {
    contents.CancelledSpotInstanceRequests = [];
  }
  if (
    output["spotInstanceRequestSet"] !== undefined &&
    output["spotInstanceRequestSet"]["item"] !== undefined
  ) {
    contents.CancelledSpotInstanceRequests = deserializeAws_ec2CancelledSpotInstanceRequestList(
      __getArrayIfSingleItem(output["spotInstanceRequestSet"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2CapacityReservation = (
  output: any,
  context: __SerdeContext
): CapacityReservation => {
  let contents: any = {
    __type: "CapacityReservation",
    AvailabilityZone: undefined,
    AvailabilityZoneId: undefined,
    AvailableInstanceCount: undefined,
    CapacityReservationArn: undefined,
    CapacityReservationId: undefined,
    CreateDate: undefined,
    EbsOptimized: undefined,
    EndDate: undefined,
    EndDateType: undefined,
    EphemeralStorage: undefined,
    InstanceMatchCriteria: undefined,
    InstancePlatform: undefined,
    InstanceType: undefined,
    OwnerId: undefined,
    State: undefined,
    Tags: undefined,
    Tenancy: undefined,
    TotalInstanceCount: undefined
  };
  if (output["availabilityZone"] !== undefined) {
    contents.AvailabilityZone = output["availabilityZone"];
  }
  if (output["availabilityZoneId"] !== undefined) {
    contents.AvailabilityZoneId = output["availabilityZoneId"];
  }
  if (output["availableInstanceCount"] !== undefined) {
    contents.AvailableInstanceCount = parseInt(
      output["availableInstanceCount"]
    );
  }
  if (output["capacityReservationArn"] !== undefined) {
    contents.CapacityReservationArn = output["capacityReservationArn"];
  }
  if (output["capacityReservationId"] !== undefined) {
    contents.CapacityReservationId = output["capacityReservationId"];
  }
  if (output["createDate"] !== undefined) {
    contents.CreateDate = new Date(output["createDate"]);
  }
  if (output["ebsOptimized"] !== undefined) {
    contents.EbsOptimized = output["ebsOptimized"] == "true";
  }
  if (output["endDate"] !== undefined) {
    contents.EndDate = new Date(output["endDate"]);
  }
  if (output["endDateType"] !== undefined) {
    contents.EndDateType = output["endDateType"];
  }
  if (output["ephemeralStorage"] !== undefined) {
    contents.EphemeralStorage = output["ephemeralStorage"] == "true";
  }
  if (output["instanceMatchCriteria"] !== undefined) {
    contents.InstanceMatchCriteria = output["instanceMatchCriteria"];
  }
  if (output["instancePlatform"] !== undefined) {
    contents.InstancePlatform = output["instancePlatform"];
  }
  if (output["instanceType"] !== undefined) {
    contents.InstanceType = output["instanceType"];
  }
  if (output["ownerId"] !== undefined) {
    contents.OwnerId = output["ownerId"];
  }
  if (output["state"] !== undefined) {
    contents.State = output["state"];
  }
  if (output.tagSet === "") {
    contents.Tags = [];
  }
  if (
    output["tagSet"] !== undefined &&
    output["tagSet"]["item"] !== undefined
  ) {
    contents.Tags = deserializeAws_ec2TagList(
      __getArrayIfSingleItem(output["tagSet"]["item"]),
      context
    );
  }
  if (output["tenancy"] !== undefined) {
    contents.Tenancy = output["tenancy"];
  }
  if (output["totalInstanceCount"] !== undefined) {
    contents.TotalInstanceCount = parseInt(output["totalInstanceCount"]);
  }
  return contents;
};

const deserializeAws_ec2CapacityReservationOptions = (
  output: any,
  context: __SerdeContext
): CapacityReservationOptions => {
  let contents: any = {
    __type: "CapacityReservationOptions",
    UsageStrategy: undefined
  };
  if (output["usageStrategy"] !== undefined) {
    contents.UsageStrategy = output["usageStrategy"];
  }
  return contents;
};

const deserializeAws_ec2CapacityReservationSet = (
  output: any,
  context: __SerdeContext
): CapacityReservation[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2CapacityReservation(entry, context)
  );
};

const deserializeAws_ec2CapacityReservationSpecificationResponse = (
  output: any,
  context: __SerdeContext
): CapacityReservationSpecificationResponse => {
  let contents: any = {
    __type: "CapacityReservationSpecificationResponse",
    CapacityReservationPreference: undefined,
    CapacityReservationTarget: undefined
  };
  if (output["capacityReservationPreference"] !== undefined) {
    contents.CapacityReservationPreference =
      output["capacityReservationPreference"];
  }
  if (output["capacityReservationTarget"] !== undefined) {
    contents.CapacityReservationTarget = deserializeAws_ec2CapacityReservationTargetResponse(
      output["capacityReservationTarget"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2CapacityReservationTargetResponse = (
  output: any,
  context: __SerdeContext
): CapacityReservationTargetResponse => {
  let contents: any = {
    __type: "CapacityReservationTargetResponse",
    CapacityReservationId: undefined
  };
  if (output["capacityReservationId"] !== undefined) {
    contents.CapacityReservationId = output["capacityReservationId"];
  }
  return contents;
};

const deserializeAws_ec2CertificateAuthentication = (
  output: any,
  context: __SerdeContext
): CertificateAuthentication => {
  let contents: any = {
    __type: "CertificateAuthentication",
    ClientRootCertificateChain: undefined
  };
  if (output["clientRootCertificateChain"] !== undefined) {
    contents.ClientRootCertificateChain = output["clientRootCertificateChain"];
  }
  return contents;
};

const deserializeAws_ec2CidrBlock = (
  output: any,
  context: __SerdeContext
): CidrBlock => {
  let contents: any = {
    __type: "CidrBlock",
    CidrBlock: undefined
  };
  if (output["cidrBlock"] !== undefined) {
    contents.CidrBlock = output["cidrBlock"];
  }
  return contents;
};

const deserializeAws_ec2CidrBlockSet = (
  output: any,
  context: __SerdeContext
): CidrBlock[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2CidrBlock(entry, context)
  );
};

const deserializeAws_ec2ClassicLinkDnsSupport = (
  output: any,
  context: __SerdeContext
): ClassicLinkDnsSupport => {
  let contents: any = {
    __type: "ClassicLinkDnsSupport",
    ClassicLinkDnsSupported: undefined,
    VpcId: undefined
  };
  if (output["classicLinkDnsSupported"] !== undefined) {
    contents.ClassicLinkDnsSupported =
      output["classicLinkDnsSupported"] == "true";
  }
  if (output["vpcId"] !== undefined) {
    contents.VpcId = output["vpcId"];
  }
  return contents;
};

const deserializeAws_ec2ClassicLinkDnsSupportList = (
  output: any,
  context: __SerdeContext
): ClassicLinkDnsSupport[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2ClassicLinkDnsSupport(entry, context)
  );
};

const deserializeAws_ec2ClassicLinkInstance = (
  output: any,
  context: __SerdeContext
): ClassicLinkInstance => {
  let contents: any = {
    __type: "ClassicLinkInstance",
    Groups: undefined,
    InstanceId: undefined,
    Tags: undefined,
    VpcId: undefined
  };
  if (output.groupSet === "") {
    contents.Groups = [];
  }
  if (
    output["groupSet"] !== undefined &&
    output["groupSet"]["item"] !== undefined
  ) {
    contents.Groups = deserializeAws_ec2GroupIdentifierList(
      __getArrayIfSingleItem(output["groupSet"]["item"]),
      context
    );
  }
  if (output["instanceId"] !== undefined) {
    contents.InstanceId = output["instanceId"];
  }
  if (output.tagSet === "") {
    contents.Tags = [];
  }
  if (
    output["tagSet"] !== undefined &&
    output["tagSet"]["item"] !== undefined
  ) {
    contents.Tags = deserializeAws_ec2TagList(
      __getArrayIfSingleItem(output["tagSet"]["item"]),
      context
    );
  }
  if (output["vpcId"] !== undefined) {
    contents.VpcId = output["vpcId"];
  }
  return contents;
};

const deserializeAws_ec2ClassicLinkInstanceList = (
  output: any,
  context: __SerdeContext
): ClassicLinkInstance[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2ClassicLinkInstance(entry, context)
  );
};

const deserializeAws_ec2ClassicLoadBalancer = (
  output: any,
  context: __SerdeContext
): ClassicLoadBalancer => {
  let contents: any = {
    __type: "ClassicLoadBalancer",
    Name: undefined
  };
  if (output["name"] !== undefined) {
    contents.Name = output["name"];
  }
  return contents;
};

const deserializeAws_ec2ClassicLoadBalancers = (
  output: any,
  context: __SerdeContext
): ClassicLoadBalancer[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2ClassicLoadBalancer(entry, context)
  );
};

const deserializeAws_ec2ClassicLoadBalancersConfig = (
  output: any,
  context: __SerdeContext
): ClassicLoadBalancersConfig => {
  let contents: any = {
    __type: "ClassicLoadBalancersConfig",
    ClassicLoadBalancers: undefined
  };
  if (output.classicLoadBalancers === "") {
    contents.ClassicLoadBalancers = [];
  }
  if (
    output["classicLoadBalancers"] !== undefined &&
    output["classicLoadBalancers"]["item"] !== undefined
  ) {
    contents.ClassicLoadBalancers = deserializeAws_ec2ClassicLoadBalancers(
      __getArrayIfSingleItem(output["classicLoadBalancers"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2ClientCertificateRevocationListStatus = (
  output: any,
  context: __SerdeContext
): ClientCertificateRevocationListStatus => {
  let contents: any = {
    __type: "ClientCertificateRevocationListStatus",
    Code: undefined,
    Message: undefined
  };
  if (output["code"] !== undefined) {
    contents.Code = output["code"];
  }
  if (output["message"] !== undefined) {
    contents.Message = output["message"];
  }
  return contents;
};

const deserializeAws_ec2ClientVpnAuthentication = (
  output: any,
  context: __SerdeContext
): ClientVpnAuthentication => {
  let contents: any = {
    __type: "ClientVpnAuthentication",
    ActiveDirectory: undefined,
    MutualAuthentication: undefined,
    Type: undefined
  };
  if (output["activeDirectory"] !== undefined) {
    contents.ActiveDirectory = deserializeAws_ec2DirectoryServiceAuthentication(
      output["activeDirectory"],
      context
    );
  }
  if (output["mutualAuthentication"] !== undefined) {
    contents.MutualAuthentication = deserializeAws_ec2CertificateAuthentication(
      output["mutualAuthentication"],
      context
    );
  }
  if (output["type"] !== undefined) {
    contents.Type = output["type"];
  }
  return contents;
};

const deserializeAws_ec2ClientVpnAuthenticationList = (
  output: any,
  context: __SerdeContext
): ClientVpnAuthentication[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2ClientVpnAuthentication(entry, context)
  );
};

const deserializeAws_ec2ClientVpnAuthorizationRuleStatus = (
  output: any,
  context: __SerdeContext
): ClientVpnAuthorizationRuleStatus => {
  let contents: any = {
    __type: "ClientVpnAuthorizationRuleStatus",
    Code: undefined,
    Message: undefined
  };
  if (output["code"] !== undefined) {
    contents.Code = output["code"];
  }
  if (output["message"] !== undefined) {
    contents.Message = output["message"];
  }
  return contents;
};

const deserializeAws_ec2ClientVpnConnection = (
  output: any,
  context: __SerdeContext
): ClientVpnConnection => {
  let contents: any = {
    __type: "ClientVpnConnection",
    ClientIp: undefined,
    ClientVpnEndpointId: undefined,
    CommonName: undefined,
    ConnectionEndTime: undefined,
    ConnectionEstablishedTime: undefined,
    ConnectionId: undefined,
    EgressBytes: undefined,
    EgressPackets: undefined,
    IngressBytes: undefined,
    IngressPackets: undefined,
    Status: undefined,
    Timestamp: undefined,
    Username: undefined
  };
  if (output["clientIp"] !== undefined) {
    contents.ClientIp = output["clientIp"];
  }
  if (output["clientVpnEndpointId"] !== undefined) {
    contents.ClientVpnEndpointId = output["clientVpnEndpointId"];
  }
  if (output["commonName"] !== undefined) {
    contents.CommonName = output["commonName"];
  }
  if (output["connectionEndTime"] !== undefined) {
    contents.ConnectionEndTime = output["connectionEndTime"];
  }
  if (output["connectionEstablishedTime"] !== undefined) {
    contents.ConnectionEstablishedTime = output["connectionEstablishedTime"];
  }
  if (output["connectionId"] !== undefined) {
    contents.ConnectionId = output["connectionId"];
  }
  if (output["egressBytes"] !== undefined) {
    contents.EgressBytes = output["egressBytes"];
  }
  if (output["egressPackets"] !== undefined) {
    contents.EgressPackets = output["egressPackets"];
  }
  if (output["ingressBytes"] !== undefined) {
    contents.IngressBytes = output["ingressBytes"];
  }
  if (output["ingressPackets"] !== undefined) {
    contents.IngressPackets = output["ingressPackets"];
  }
  if (output["status"] !== undefined) {
    contents.Status = deserializeAws_ec2ClientVpnConnectionStatus(
      output["status"],
      context
    );
  }
  if (output["timestamp"] !== undefined) {
    contents.Timestamp = output["timestamp"];
  }
  if (output["username"] !== undefined) {
    contents.Username = output["username"];
  }
  return contents;
};

const deserializeAws_ec2ClientVpnConnectionSet = (
  output: any,
  context: __SerdeContext
): ClientVpnConnection[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2ClientVpnConnection(entry, context)
  );
};

const deserializeAws_ec2ClientVpnConnectionStatus = (
  output: any,
  context: __SerdeContext
): ClientVpnConnectionStatus => {
  let contents: any = {
    __type: "ClientVpnConnectionStatus",
    Code: undefined,
    Message: undefined
  };
  if (output["code"] !== undefined) {
    contents.Code = output["code"];
  }
  if (output["message"] !== undefined) {
    contents.Message = output["message"];
  }
  return contents;
};

const deserializeAws_ec2ClientVpnEndpoint = (
  output: any,
  context: __SerdeContext
): ClientVpnEndpoint => {
  let contents: any = {
    __type: "ClientVpnEndpoint",
    AssociatedTargetNetworks: undefined,
    AuthenticationOptions: undefined,
    ClientCidrBlock: undefined,
    ClientVpnEndpointId: undefined,
    ConnectionLogOptions: undefined,
    CreationTime: undefined,
    DeletionTime: undefined,
    Description: undefined,
    DnsName: undefined,
    DnsServers: undefined,
    ServerCertificateArn: undefined,
    SplitTunnel: undefined,
    Status: undefined,
    Tags: undefined,
    TransportProtocol: undefined,
    VpnPort: undefined,
    VpnProtocol: undefined
  };
  if (output.associatedTargetNetwork === "") {
    contents.AssociatedTargetNetworks = [];
  }
  if (
    output["associatedTargetNetwork"] !== undefined &&
    output["associatedTargetNetwork"]["item"] !== undefined
  ) {
    contents.AssociatedTargetNetworks = deserializeAws_ec2AssociatedTargetNetworkSet(
      __getArrayIfSingleItem(output["associatedTargetNetwork"]["item"]),
      context
    );
  }
  if (output.authenticationOptions === "") {
    contents.AuthenticationOptions = [];
  }
  if (
    output["authenticationOptions"] !== undefined &&
    output["authenticationOptions"]["item"] !== undefined
  ) {
    contents.AuthenticationOptions = deserializeAws_ec2ClientVpnAuthenticationList(
      __getArrayIfSingleItem(output["authenticationOptions"]["item"]),
      context
    );
  }
  if (output["clientCidrBlock"] !== undefined) {
    contents.ClientCidrBlock = output["clientCidrBlock"];
  }
  if (output["clientVpnEndpointId"] !== undefined) {
    contents.ClientVpnEndpointId = output["clientVpnEndpointId"];
  }
  if (output["connectionLogOptions"] !== undefined) {
    contents.ConnectionLogOptions = deserializeAws_ec2ConnectionLogResponseOptions(
      output["connectionLogOptions"],
      context
    );
  }
  if (output["creationTime"] !== undefined) {
    contents.CreationTime = output["creationTime"];
  }
  if (output["deletionTime"] !== undefined) {
    contents.DeletionTime = output["deletionTime"];
  }
  if (output["description"] !== undefined) {
    contents.Description = output["description"];
  }
  if (output["dnsName"] !== undefined) {
    contents.DnsName = output["dnsName"];
  }
  if (output.dnsServer === "") {
    contents.DnsServers = [];
  }
  if (
    output["dnsServer"] !== undefined &&
    output["dnsServer"]["item"] !== undefined
  ) {
    contents.DnsServers = deserializeAws_ec2ValueStringList(
      __getArrayIfSingleItem(output["dnsServer"]["item"]),
      context
    );
  }
  if (output["serverCertificateArn"] !== undefined) {
    contents.ServerCertificateArn = output["serverCertificateArn"];
  }
  if (output["splitTunnel"] !== undefined) {
    contents.SplitTunnel = output["splitTunnel"] == "true";
  }
  if (output["status"] !== undefined) {
    contents.Status = deserializeAws_ec2ClientVpnEndpointStatus(
      output["status"],
      context
    );
  }
  if (output.tagSet === "") {
    contents.Tags = [];
  }
  if (
    output["tagSet"] !== undefined &&
    output["tagSet"]["item"] !== undefined
  ) {
    contents.Tags = deserializeAws_ec2TagList(
      __getArrayIfSingleItem(output["tagSet"]["item"]),
      context
    );
  }
  if (output["transportProtocol"] !== undefined) {
    contents.TransportProtocol = output["transportProtocol"];
  }
  if (output["vpnPort"] !== undefined) {
    contents.VpnPort = parseInt(output["vpnPort"]);
  }
  if (output["vpnProtocol"] !== undefined) {
    contents.VpnProtocol = output["vpnProtocol"];
  }
  return contents;
};

const deserializeAws_ec2ClientVpnEndpointStatus = (
  output: any,
  context: __SerdeContext
): ClientVpnEndpointStatus => {
  let contents: any = {
    __type: "ClientVpnEndpointStatus",
    Code: undefined,
    Message: undefined
  };
  if (output["code"] !== undefined) {
    contents.Code = output["code"];
  }
  if (output["message"] !== undefined) {
    contents.Message = output["message"];
  }
  return contents;
};

const deserializeAws_ec2ClientVpnRoute = (
  output: any,
  context: __SerdeContext
): ClientVpnRoute => {
  let contents: any = {
    __type: "ClientVpnRoute",
    ClientVpnEndpointId: undefined,
    Description: undefined,
    DestinationCidr: undefined,
    Origin: undefined,
    Status: undefined,
    TargetSubnet: undefined,
    Type: undefined
  };
  if (output["clientVpnEndpointId"] !== undefined) {
    contents.ClientVpnEndpointId = output["clientVpnEndpointId"];
  }
  if (output["description"] !== undefined) {
    contents.Description = output["description"];
  }
  if (output["destinationCidr"] !== undefined) {
    contents.DestinationCidr = output["destinationCidr"];
  }
  if (output["origin"] !== undefined) {
    contents.Origin = output["origin"];
  }
  if (output["status"] !== undefined) {
    contents.Status = deserializeAws_ec2ClientVpnRouteStatus(
      output["status"],
      context
    );
  }
  if (output["targetSubnet"] !== undefined) {
    contents.TargetSubnet = output["targetSubnet"];
  }
  if (output["type"] !== undefined) {
    contents.Type = output["type"];
  }
  return contents;
};

const deserializeAws_ec2ClientVpnRouteSet = (
  output: any,
  context: __SerdeContext
): ClientVpnRoute[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2ClientVpnRoute(entry, context)
  );
};

const deserializeAws_ec2ClientVpnRouteStatus = (
  output: any,
  context: __SerdeContext
): ClientVpnRouteStatus => {
  let contents: any = {
    __type: "ClientVpnRouteStatus",
    Code: undefined,
    Message: undefined
  };
  if (output["code"] !== undefined) {
    contents.Code = output["code"];
  }
  if (output["message"] !== undefined) {
    contents.Message = output["message"];
  }
  return contents;
};

const deserializeAws_ec2ClientVpnSecurityGroupIdSet = (
  output: any,
  context: __SerdeContext
): string[] => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_ec2CoipAddressUsage = (
  output: any,
  context: __SerdeContext
): CoipAddressUsage => {
  let contents: any = {
    __type: "CoipAddressUsage",
    AllocationId: undefined,
    AwsAccountId: undefined,
    AwsService: undefined,
    CoIp: undefined
  };
  if (output["allocationId"] !== undefined) {
    contents.AllocationId = output["allocationId"];
  }
  if (output["awsAccountId"] !== undefined) {
    contents.AwsAccountId = output["awsAccountId"];
  }
  if (output["awsService"] !== undefined) {
    contents.AwsService = output["awsService"];
  }
  if (output["coIp"] !== undefined) {
    contents.CoIp = output["coIp"];
  }
  return contents;
};

const deserializeAws_ec2CoipAddressUsageSet = (
  output: any,
  context: __SerdeContext
): CoipAddressUsage[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2CoipAddressUsage(entry, context)
  );
};

const deserializeAws_ec2CoipPool = (
  output: any,
  context: __SerdeContext
): CoipPool => {
  let contents: any = {
    __type: "CoipPool",
    LocalGatewayRouteTableId: undefined,
    PoolCidrs: undefined,
    PoolId: undefined,
    Tags: undefined
  };
  if (output["localGatewayRouteTableId"] !== undefined) {
    contents.LocalGatewayRouteTableId = output["localGatewayRouteTableId"];
  }
  if (output.poolCidrSet === "") {
    contents.PoolCidrs = [];
  }
  if (
    output["poolCidrSet"] !== undefined &&
    output["poolCidrSet"]["item"] !== undefined
  ) {
    contents.PoolCidrs = deserializeAws_ec2ValueStringList(
      __getArrayIfSingleItem(output["poolCidrSet"]["item"]),
      context
    );
  }
  if (output["poolId"] !== undefined) {
    contents.PoolId = output["poolId"];
  }
  if (output.tagSet === "") {
    contents.Tags = [];
  }
  if (
    output["tagSet"] !== undefined &&
    output["tagSet"]["item"] !== undefined
  ) {
    contents.Tags = deserializeAws_ec2TagList(
      __getArrayIfSingleItem(output["tagSet"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2CoipPoolSet = (
  output: any,
  context: __SerdeContext
): CoipPool[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2CoipPool(entry, context)
  );
};

const deserializeAws_ec2ConfirmProductInstanceResult = (
  output: any,
  context: __SerdeContext
): ConfirmProductInstanceResult => {
  let contents: any = {
    __type: "ConfirmProductInstanceResult",
    OwnerId: undefined,
    Return: undefined
  };
  if (output["ownerId"] !== undefined) {
    contents.OwnerId = output["ownerId"];
  }
  if (output["return"] !== undefined) {
    contents.Return = output["return"] == "true";
  }
  return contents;
};

const deserializeAws_ec2ConnectionLogResponseOptions = (
  output: any,
  context: __SerdeContext
): ConnectionLogResponseOptions => {
  let contents: any = {
    __type: "ConnectionLogResponseOptions",
    CloudwatchLogGroup: undefined,
    CloudwatchLogStream: undefined,
    Enabled: undefined
  };
  if (output["CloudwatchLogGroup"] !== undefined) {
    contents.CloudwatchLogGroup = output["CloudwatchLogGroup"];
  }
  if (output["CloudwatchLogStream"] !== undefined) {
    contents.CloudwatchLogStream = output["CloudwatchLogStream"];
  }
  if (output["Enabled"] !== undefined) {
    contents.Enabled = output["Enabled"] == "true";
  }
  return contents;
};

const deserializeAws_ec2ConnectionNotification = (
  output: any,
  context: __SerdeContext
): ConnectionNotification => {
  let contents: any = {
    __type: "ConnectionNotification",
    ConnectionEvents: undefined,
    ConnectionNotificationArn: undefined,
    ConnectionNotificationId: undefined,
    ConnectionNotificationState: undefined,
    ConnectionNotificationType: undefined,
    ServiceId: undefined,
    VpcEndpointId: undefined
  };
  if (output.connectionEvents === "") {
    contents.ConnectionEvents = [];
  }
  if (
    output["connectionEvents"] !== undefined &&
    output["connectionEvents"]["item"] !== undefined
  ) {
    contents.ConnectionEvents = deserializeAws_ec2ValueStringList(
      __getArrayIfSingleItem(output["connectionEvents"]["item"]),
      context
    );
  }
  if (output["connectionNotificationArn"] !== undefined) {
    contents.ConnectionNotificationArn = output["connectionNotificationArn"];
  }
  if (output["connectionNotificationId"] !== undefined) {
    contents.ConnectionNotificationId = output["connectionNotificationId"];
  }
  if (output["connectionNotificationState"] !== undefined) {
    contents.ConnectionNotificationState =
      output["connectionNotificationState"];
  }
  if (output["connectionNotificationType"] !== undefined) {
    contents.ConnectionNotificationType = output["connectionNotificationType"];
  }
  if (output["serviceId"] !== undefined) {
    contents.ServiceId = output["serviceId"];
  }
  if (output["vpcEndpointId"] !== undefined) {
    contents.VpcEndpointId = output["vpcEndpointId"];
  }
  return contents;
};

const deserializeAws_ec2ConnectionNotificationSet = (
  output: any,
  context: __SerdeContext
): ConnectionNotification[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2ConnectionNotification(entry, context)
  );
};

const deserializeAws_ec2ConversionTask = (
  output: any,
  context: __SerdeContext
): ConversionTask => {
  let contents: any = {
    __type: "ConversionTask",
    ConversionTaskId: undefined,
    ExpirationTime: undefined,
    ImportInstance: undefined,
    ImportVolume: undefined,
    State: undefined,
    StatusMessage: undefined,
    Tags: undefined
  };
  if (output["conversionTaskId"] !== undefined) {
    contents.ConversionTaskId = output["conversionTaskId"];
  }
  if (output["expirationTime"] !== undefined) {
    contents.ExpirationTime = output["expirationTime"];
  }
  if (output["importInstance"] !== undefined) {
    contents.ImportInstance = deserializeAws_ec2ImportInstanceTaskDetails(
      output["importInstance"],
      context
    );
  }
  if (output["importVolume"] !== undefined) {
    contents.ImportVolume = deserializeAws_ec2ImportVolumeTaskDetails(
      output["importVolume"],
      context
    );
  }
  if (output["state"] !== undefined) {
    contents.State = output["state"];
  }
  if (output["statusMessage"] !== undefined) {
    contents.StatusMessage = output["statusMessage"];
  }
  if (output.tagSet === "") {
    contents.Tags = [];
  }
  if (
    output["tagSet"] !== undefined &&
    output["tagSet"]["item"] !== undefined
  ) {
    contents.Tags = deserializeAws_ec2TagList(
      __getArrayIfSingleItem(output["tagSet"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2CopyFpgaImageResult = (
  output: any,
  context: __SerdeContext
): CopyFpgaImageResult => {
  let contents: any = {
    __type: "CopyFpgaImageResult",
    FpgaImageId: undefined
  };
  if (output["fpgaImageId"] !== undefined) {
    contents.FpgaImageId = output["fpgaImageId"];
  }
  return contents;
};

const deserializeAws_ec2CopyImageResult = (
  output: any,
  context: __SerdeContext
): CopyImageResult => {
  let contents: any = {
    __type: "CopyImageResult",
    ImageId: undefined
  };
  if (output["imageId"] !== undefined) {
    contents.ImageId = output["imageId"];
  }
  return contents;
};

const deserializeAws_ec2CopySnapshotResult = (
  output: any,
  context: __SerdeContext
): CopySnapshotResult => {
  let contents: any = {
    __type: "CopySnapshotResult",
    SnapshotId: undefined,
    Tags: undefined
  };
  if (output["snapshotId"] !== undefined) {
    contents.SnapshotId = output["snapshotId"];
  }
  if (output.tagSet === "") {
    contents.Tags = [];
  }
  if (
    output["tagSet"] !== undefined &&
    output["tagSet"]["item"] !== undefined
  ) {
    contents.Tags = deserializeAws_ec2TagList(
      __getArrayIfSingleItem(output["tagSet"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2CoreCountList = (
  output: any,
  context: __SerdeContext
): number[] => {
  return (output || []).map((entry: any) => parseInt(entry));
};

const deserializeAws_ec2CpuOptions = (
  output: any,
  context: __SerdeContext
): CpuOptions => {
  let contents: any = {
    __type: "CpuOptions",
    CoreCount: undefined,
    ThreadsPerCore: undefined
  };
  if (output["coreCount"] !== undefined) {
    contents.CoreCount = parseInt(output["coreCount"]);
  }
  if (output["threadsPerCore"] !== undefined) {
    contents.ThreadsPerCore = parseInt(output["threadsPerCore"]);
  }
  return contents;
};

const deserializeAws_ec2CreateCapacityReservationResult = (
  output: any,
  context: __SerdeContext
): CreateCapacityReservationResult => {
  let contents: any = {
    __type: "CreateCapacityReservationResult",
    CapacityReservation: undefined
  };
  if (output["capacityReservation"] !== undefined) {
    contents.CapacityReservation = deserializeAws_ec2CapacityReservation(
      output["capacityReservation"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2CreateClientVpnEndpointResult = (
  output: any,
  context: __SerdeContext
): CreateClientVpnEndpointResult => {
  let contents: any = {
    __type: "CreateClientVpnEndpointResult",
    ClientVpnEndpointId: undefined,
    DnsName: undefined,
    Status: undefined
  };
  if (output["clientVpnEndpointId"] !== undefined) {
    contents.ClientVpnEndpointId = output["clientVpnEndpointId"];
  }
  if (output["dnsName"] !== undefined) {
    contents.DnsName = output["dnsName"];
  }
  if (output["status"] !== undefined) {
    contents.Status = deserializeAws_ec2ClientVpnEndpointStatus(
      output["status"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2CreateClientVpnRouteResult = (
  output: any,
  context: __SerdeContext
): CreateClientVpnRouteResult => {
  let contents: any = {
    __type: "CreateClientVpnRouteResult",
    Status: undefined
  };
  if (output["status"] !== undefined) {
    contents.Status = deserializeAws_ec2ClientVpnRouteStatus(
      output["status"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2CreateCustomerGatewayResult = (
  output: any,
  context: __SerdeContext
): CreateCustomerGatewayResult => {
  let contents: any = {
    __type: "CreateCustomerGatewayResult",
    CustomerGateway: undefined
  };
  if (output["customerGateway"] !== undefined) {
    contents.CustomerGateway = deserializeAws_ec2CustomerGateway(
      output["customerGateway"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2CreateDefaultSubnetResult = (
  output: any,
  context: __SerdeContext
): CreateDefaultSubnetResult => {
  let contents: any = {
    __type: "CreateDefaultSubnetResult",
    Subnet: undefined
  };
  if (output["subnet"] !== undefined) {
    contents.Subnet = deserializeAws_ec2Subnet(output["subnet"], context);
  }
  return contents;
};

const deserializeAws_ec2CreateDefaultVpcResult = (
  output: any,
  context: __SerdeContext
): CreateDefaultVpcResult => {
  let contents: any = {
    __type: "CreateDefaultVpcResult",
    Vpc: undefined
  };
  if (output["vpc"] !== undefined) {
    contents.Vpc = deserializeAws_ec2Vpc(output["vpc"], context);
  }
  return contents;
};

const deserializeAws_ec2CreateDhcpOptionsResult = (
  output: any,
  context: __SerdeContext
): CreateDhcpOptionsResult => {
  let contents: any = {
    __type: "CreateDhcpOptionsResult",
    DhcpOptions: undefined
  };
  if (output["dhcpOptions"] !== undefined) {
    contents.DhcpOptions = deserializeAws_ec2DhcpOptions(
      output["dhcpOptions"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2CreateEgressOnlyInternetGatewayResult = (
  output: any,
  context: __SerdeContext
): CreateEgressOnlyInternetGatewayResult => {
  let contents: any = {
    __type: "CreateEgressOnlyInternetGatewayResult",
    ClientToken: undefined,
    EgressOnlyInternetGateway: undefined
  };
  if (output["clientToken"] !== undefined) {
    contents.ClientToken = output["clientToken"];
  }
  if (output["egressOnlyInternetGateway"] !== undefined) {
    contents.EgressOnlyInternetGateway = deserializeAws_ec2EgressOnlyInternetGateway(
      output["egressOnlyInternetGateway"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2CreateFleetError = (
  output: any,
  context: __SerdeContext
): CreateFleetError => {
  let contents: any = {
    __type: "CreateFleetError",
    ErrorCode: undefined,
    ErrorMessage: undefined,
    LaunchTemplateAndOverrides: undefined,
    Lifecycle: undefined
  };
  if (output["errorCode"] !== undefined) {
    contents.ErrorCode = output["errorCode"];
  }
  if (output["errorMessage"] !== undefined) {
    contents.ErrorMessage = output["errorMessage"];
  }
  if (output["launchTemplateAndOverrides"] !== undefined) {
    contents.LaunchTemplateAndOverrides = deserializeAws_ec2LaunchTemplateAndOverridesResponse(
      output["launchTemplateAndOverrides"],
      context
    );
  }
  if (output["lifecycle"] !== undefined) {
    contents.Lifecycle = output["lifecycle"];
  }
  return contents;
};

const deserializeAws_ec2CreateFleetErrorsSet = (
  output: any,
  context: __SerdeContext
): CreateFleetError[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2CreateFleetError(entry, context)
  );
};

const deserializeAws_ec2CreateFleetInstance = (
  output: any,
  context: __SerdeContext
): CreateFleetInstance => {
  let contents: any = {
    __type: "CreateFleetInstance",
    InstanceIds: undefined,
    InstanceType: undefined,
    LaunchTemplateAndOverrides: undefined,
    Lifecycle: undefined,
    Platform: undefined
  };
  if (output.instanceIds === "") {
    contents.InstanceIds = [];
  }
  if (
    output["instanceIds"] !== undefined &&
    output["instanceIds"]["item"] !== undefined
  ) {
    contents.InstanceIds = deserializeAws_ec2InstanceIdsSet(
      __getArrayIfSingleItem(output["instanceIds"]["item"]),
      context
    );
  }
  if (output["instanceType"] !== undefined) {
    contents.InstanceType = output["instanceType"];
  }
  if (output["launchTemplateAndOverrides"] !== undefined) {
    contents.LaunchTemplateAndOverrides = deserializeAws_ec2LaunchTemplateAndOverridesResponse(
      output["launchTemplateAndOverrides"],
      context
    );
  }
  if (output["lifecycle"] !== undefined) {
    contents.Lifecycle = output["lifecycle"];
  }
  if (output["platform"] !== undefined) {
    contents.Platform = output["platform"];
  }
  return contents;
};

const deserializeAws_ec2CreateFleetInstancesSet = (
  output: any,
  context: __SerdeContext
): CreateFleetInstance[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2CreateFleetInstance(entry, context)
  );
};

const deserializeAws_ec2CreateFleetResult = (
  output: any,
  context: __SerdeContext
): CreateFleetResult => {
  let contents: any = {
    __type: "CreateFleetResult",
    Errors: undefined,
    FleetId: undefined,
    Instances: undefined
  };
  if (output.errorSet === "") {
    contents.Errors = [];
  }
  if (
    output["errorSet"] !== undefined &&
    output["errorSet"]["item"] !== undefined
  ) {
    contents.Errors = deserializeAws_ec2CreateFleetErrorsSet(
      __getArrayIfSingleItem(output["errorSet"]["item"]),
      context
    );
  }
  if (output["fleetId"] !== undefined) {
    contents.FleetId = output["fleetId"];
  }
  if (output.fleetInstanceSet === "") {
    contents.Instances = [];
  }
  if (
    output["fleetInstanceSet"] !== undefined &&
    output["fleetInstanceSet"]["item"] !== undefined
  ) {
    contents.Instances = deserializeAws_ec2CreateFleetInstancesSet(
      __getArrayIfSingleItem(output["fleetInstanceSet"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2CreateFlowLogsResult = (
  output: any,
  context: __SerdeContext
): CreateFlowLogsResult => {
  let contents: any = {
    __type: "CreateFlowLogsResult",
    ClientToken: undefined,
    FlowLogIds: undefined,
    Unsuccessful: undefined
  };
  if (output["clientToken"] !== undefined) {
    contents.ClientToken = output["clientToken"];
  }
  if (output.flowLogIdSet === "") {
    contents.FlowLogIds = [];
  }
  if (
    output["flowLogIdSet"] !== undefined &&
    output["flowLogIdSet"]["item"] !== undefined
  ) {
    contents.FlowLogIds = deserializeAws_ec2ValueStringList(
      __getArrayIfSingleItem(output["flowLogIdSet"]["item"]),
      context
    );
  }
  if (output.unsuccessful === "") {
    contents.Unsuccessful = [];
  }
  if (
    output["unsuccessful"] !== undefined &&
    output["unsuccessful"]["item"] !== undefined
  ) {
    contents.Unsuccessful = deserializeAws_ec2UnsuccessfulItemSet(
      __getArrayIfSingleItem(output["unsuccessful"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2CreateFpgaImageResult = (
  output: any,
  context: __SerdeContext
): CreateFpgaImageResult => {
  let contents: any = {
    __type: "CreateFpgaImageResult",
    FpgaImageGlobalId: undefined,
    FpgaImageId: undefined
  };
  if (output["fpgaImageGlobalId"] !== undefined) {
    contents.FpgaImageGlobalId = output["fpgaImageGlobalId"];
  }
  if (output["fpgaImageId"] !== undefined) {
    contents.FpgaImageId = output["fpgaImageId"];
  }
  return contents;
};

const deserializeAws_ec2CreateImageResult = (
  output: any,
  context: __SerdeContext
): CreateImageResult => {
  let contents: any = {
    __type: "CreateImageResult",
    ImageId: undefined
  };
  if (output["imageId"] !== undefined) {
    contents.ImageId = output["imageId"];
  }
  return contents;
};

const deserializeAws_ec2CreateInstanceExportTaskResult = (
  output: any,
  context: __SerdeContext
): CreateInstanceExportTaskResult => {
  let contents: any = {
    __type: "CreateInstanceExportTaskResult",
    ExportTask: undefined
  };
  if (output["exportTask"] !== undefined) {
    contents.ExportTask = deserializeAws_ec2ExportTask(
      output["exportTask"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2CreateInternetGatewayResult = (
  output: any,
  context: __SerdeContext
): CreateInternetGatewayResult => {
  let contents: any = {
    __type: "CreateInternetGatewayResult",
    InternetGateway: undefined
  };
  if (output["internetGateway"] !== undefined) {
    contents.InternetGateway = deserializeAws_ec2InternetGateway(
      output["internetGateway"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2CreateLaunchTemplateResult = (
  output: any,
  context: __SerdeContext
): CreateLaunchTemplateResult => {
  let contents: any = {
    __type: "CreateLaunchTemplateResult",
    LaunchTemplate: undefined
  };
  if (output["launchTemplate"] !== undefined) {
    contents.LaunchTemplate = deserializeAws_ec2LaunchTemplate(
      output["launchTemplate"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2CreateLaunchTemplateVersionResult = (
  output: any,
  context: __SerdeContext
): CreateLaunchTemplateVersionResult => {
  let contents: any = {
    __type: "CreateLaunchTemplateVersionResult",
    LaunchTemplateVersion: undefined
  };
  if (output["launchTemplateVersion"] !== undefined) {
    contents.LaunchTemplateVersion = deserializeAws_ec2LaunchTemplateVersion(
      output["launchTemplateVersion"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2CreateLocalGatewayRouteResult = (
  output: any,
  context: __SerdeContext
): CreateLocalGatewayRouteResult => {
  let contents: any = {
    __type: "CreateLocalGatewayRouteResult",
    Route: undefined
  };
  if (output["route"] !== undefined) {
    contents.Route = deserializeAws_ec2LocalGatewayRoute(
      output["route"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2CreateLocalGatewayRouteTableVpcAssociationResult = (
  output: any,
  context: __SerdeContext
): CreateLocalGatewayRouteTableVpcAssociationResult => {
  let contents: any = {
    __type: "CreateLocalGatewayRouteTableVpcAssociationResult",
    LocalGatewayRouteTableVpcAssociation: undefined
  };
  if (output["localGatewayRouteTableVpcAssociation"] !== undefined) {
    contents.LocalGatewayRouteTableVpcAssociation = deserializeAws_ec2LocalGatewayRouteTableVpcAssociation(
      output["localGatewayRouteTableVpcAssociation"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2CreateNatGatewayResult = (
  output: any,
  context: __SerdeContext
): CreateNatGatewayResult => {
  let contents: any = {
    __type: "CreateNatGatewayResult",
    ClientToken: undefined,
    NatGateway: undefined
  };
  if (output["clientToken"] !== undefined) {
    contents.ClientToken = output["clientToken"];
  }
  if (output["natGateway"] !== undefined) {
    contents.NatGateway = deserializeAws_ec2NatGateway(
      output["natGateway"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2CreateNetworkAclResult = (
  output: any,
  context: __SerdeContext
): CreateNetworkAclResult => {
  let contents: any = {
    __type: "CreateNetworkAclResult",
    NetworkAcl: undefined
  };
  if (output["networkAcl"] !== undefined) {
    contents.NetworkAcl = deserializeAws_ec2NetworkAcl(
      output["networkAcl"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2CreateNetworkInterfacePermissionResult = (
  output: any,
  context: __SerdeContext
): CreateNetworkInterfacePermissionResult => {
  let contents: any = {
    __type: "CreateNetworkInterfacePermissionResult",
    InterfacePermission: undefined
  };
  if (output["interfacePermission"] !== undefined) {
    contents.InterfacePermission = deserializeAws_ec2NetworkInterfacePermission(
      output["interfacePermission"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2CreateNetworkInterfaceResult = (
  output: any,
  context: __SerdeContext
): CreateNetworkInterfaceResult => {
  let contents: any = {
    __type: "CreateNetworkInterfaceResult",
    NetworkInterface: undefined
  };
  if (output["networkInterface"] !== undefined) {
    contents.NetworkInterface = deserializeAws_ec2NetworkInterface(
      output["networkInterface"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2CreateReservedInstancesListingResult = (
  output: any,
  context: __SerdeContext
): CreateReservedInstancesListingResult => {
  let contents: any = {
    __type: "CreateReservedInstancesListingResult",
    ReservedInstancesListings: undefined
  };
  if (output.reservedInstancesListingsSet === "") {
    contents.ReservedInstancesListings = [];
  }
  if (
    output["reservedInstancesListingsSet"] !== undefined &&
    output["reservedInstancesListingsSet"]["item"] !== undefined
  ) {
    contents.ReservedInstancesListings = deserializeAws_ec2ReservedInstancesListingList(
      __getArrayIfSingleItem(output["reservedInstancesListingsSet"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2CreateRouteResult = (
  output: any,
  context: __SerdeContext
): CreateRouteResult => {
  let contents: any = {
    __type: "CreateRouteResult",
    Return: undefined
  };
  if (output["return"] !== undefined) {
    contents.Return = output["return"] == "true";
  }
  return contents;
};

const deserializeAws_ec2CreateRouteTableResult = (
  output: any,
  context: __SerdeContext
): CreateRouteTableResult => {
  let contents: any = {
    __type: "CreateRouteTableResult",
    RouteTable: undefined
  };
  if (output["routeTable"] !== undefined) {
    contents.RouteTable = deserializeAws_ec2RouteTable(
      output["routeTable"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2CreateSecurityGroupResult = (
  output: any,
  context: __SerdeContext
): CreateSecurityGroupResult => {
  let contents: any = {
    __type: "CreateSecurityGroupResult",
    GroupId: undefined
  };
  if (output["groupId"] !== undefined) {
    contents.GroupId = output["groupId"];
  }
  return contents;
};

const deserializeAws_ec2CreateSnapshotsResult = (
  output: any,
  context: __SerdeContext
): CreateSnapshotsResult => {
  let contents: any = {
    __type: "CreateSnapshotsResult",
    Snapshots: undefined
  };
  if (output.snapshotSet === "") {
    contents.Snapshots = [];
  }
  if (
    output["snapshotSet"] !== undefined &&
    output["snapshotSet"]["item"] !== undefined
  ) {
    contents.Snapshots = deserializeAws_ec2SnapshotSet(
      __getArrayIfSingleItem(output["snapshotSet"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2CreateSpotDatafeedSubscriptionResult = (
  output: any,
  context: __SerdeContext
): CreateSpotDatafeedSubscriptionResult => {
  let contents: any = {
    __type: "CreateSpotDatafeedSubscriptionResult",
    SpotDatafeedSubscription: undefined
  };
  if (output["spotDatafeedSubscription"] !== undefined) {
    contents.SpotDatafeedSubscription = deserializeAws_ec2SpotDatafeedSubscription(
      output["spotDatafeedSubscription"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2CreateSubnetResult = (
  output: any,
  context: __SerdeContext
): CreateSubnetResult => {
  let contents: any = {
    __type: "CreateSubnetResult",
    Subnet: undefined
  };
  if (output["subnet"] !== undefined) {
    contents.Subnet = deserializeAws_ec2Subnet(output["subnet"], context);
  }
  return contents;
};

const deserializeAws_ec2CreateTrafficMirrorFilterResult = (
  output: any,
  context: __SerdeContext
): CreateTrafficMirrorFilterResult => {
  let contents: any = {
    __type: "CreateTrafficMirrorFilterResult",
    ClientToken: undefined,
    TrafficMirrorFilter: undefined
  };
  if (output["clientToken"] !== undefined) {
    contents.ClientToken = output["clientToken"];
  }
  if (output["trafficMirrorFilter"] !== undefined) {
    contents.TrafficMirrorFilter = deserializeAws_ec2TrafficMirrorFilter(
      output["trafficMirrorFilter"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2CreateTrafficMirrorFilterRuleResult = (
  output: any,
  context: __SerdeContext
): CreateTrafficMirrorFilterRuleResult => {
  let contents: any = {
    __type: "CreateTrafficMirrorFilterRuleResult",
    ClientToken: undefined,
    TrafficMirrorFilterRule: undefined
  };
  if (output["clientToken"] !== undefined) {
    contents.ClientToken = output["clientToken"];
  }
  if (output["trafficMirrorFilterRule"] !== undefined) {
    contents.TrafficMirrorFilterRule = deserializeAws_ec2TrafficMirrorFilterRule(
      output["trafficMirrorFilterRule"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2CreateTrafficMirrorSessionResult = (
  output: any,
  context: __SerdeContext
): CreateTrafficMirrorSessionResult => {
  let contents: any = {
    __type: "CreateTrafficMirrorSessionResult",
    ClientToken: undefined,
    TrafficMirrorSession: undefined
  };
  if (output["clientToken"] !== undefined) {
    contents.ClientToken = output["clientToken"];
  }
  if (output["trafficMirrorSession"] !== undefined) {
    contents.TrafficMirrorSession = deserializeAws_ec2TrafficMirrorSession(
      output["trafficMirrorSession"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2CreateTrafficMirrorTargetResult = (
  output: any,
  context: __SerdeContext
): CreateTrafficMirrorTargetResult => {
  let contents: any = {
    __type: "CreateTrafficMirrorTargetResult",
    ClientToken: undefined,
    TrafficMirrorTarget: undefined
  };
  if (output["clientToken"] !== undefined) {
    contents.ClientToken = output["clientToken"];
  }
  if (output["trafficMirrorTarget"] !== undefined) {
    contents.TrafficMirrorTarget = deserializeAws_ec2TrafficMirrorTarget(
      output["trafficMirrorTarget"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2CreateTransitGatewayMulticastDomainResult = (
  output: any,
  context: __SerdeContext
): CreateTransitGatewayMulticastDomainResult => {
  let contents: any = {
    __type: "CreateTransitGatewayMulticastDomainResult",
    TransitGatewayMulticastDomain: undefined
  };
  if (output["transitGatewayMulticastDomain"] !== undefined) {
    contents.TransitGatewayMulticastDomain = deserializeAws_ec2TransitGatewayMulticastDomain(
      output["transitGatewayMulticastDomain"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2CreateTransitGatewayPeeringAttachmentResult = (
  output: any,
  context: __SerdeContext
): CreateTransitGatewayPeeringAttachmentResult => {
  let contents: any = {
    __type: "CreateTransitGatewayPeeringAttachmentResult",
    TransitGatewayPeeringAttachment: undefined
  };
  if (output["transitGatewayPeeringAttachment"] !== undefined) {
    contents.TransitGatewayPeeringAttachment = deserializeAws_ec2TransitGatewayPeeringAttachment(
      output["transitGatewayPeeringAttachment"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2CreateTransitGatewayResult = (
  output: any,
  context: __SerdeContext
): CreateTransitGatewayResult => {
  let contents: any = {
    __type: "CreateTransitGatewayResult",
    TransitGateway: undefined
  };
  if (output["transitGateway"] !== undefined) {
    contents.TransitGateway = deserializeAws_ec2TransitGateway(
      output["transitGateway"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2CreateTransitGatewayRouteResult = (
  output: any,
  context: __SerdeContext
): CreateTransitGatewayRouteResult => {
  let contents: any = {
    __type: "CreateTransitGatewayRouteResult",
    Route: undefined
  };
  if (output["route"] !== undefined) {
    contents.Route = deserializeAws_ec2TransitGatewayRoute(
      output["route"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2CreateTransitGatewayRouteTableResult = (
  output: any,
  context: __SerdeContext
): CreateTransitGatewayRouteTableResult => {
  let contents: any = {
    __type: "CreateTransitGatewayRouteTableResult",
    TransitGatewayRouteTable: undefined
  };
  if (output["transitGatewayRouteTable"] !== undefined) {
    contents.TransitGatewayRouteTable = deserializeAws_ec2TransitGatewayRouteTable(
      output["transitGatewayRouteTable"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2CreateTransitGatewayVpcAttachmentResult = (
  output: any,
  context: __SerdeContext
): CreateTransitGatewayVpcAttachmentResult => {
  let contents: any = {
    __type: "CreateTransitGatewayVpcAttachmentResult",
    TransitGatewayVpcAttachment: undefined
  };
  if (output["transitGatewayVpcAttachment"] !== undefined) {
    contents.TransitGatewayVpcAttachment = deserializeAws_ec2TransitGatewayVpcAttachment(
      output["transitGatewayVpcAttachment"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2CreateVolumePermission = (
  output: any,
  context: __SerdeContext
): CreateVolumePermission => {
  let contents: any = {
    __type: "CreateVolumePermission",
    Group: undefined,
    UserId: undefined
  };
  if (output["group"] !== undefined) {
    contents.Group = output["group"];
  }
  if (output["userId"] !== undefined) {
    contents.UserId = output["userId"];
  }
  return contents;
};

const deserializeAws_ec2CreateVolumePermissionList = (
  output: any,
  context: __SerdeContext
): CreateVolumePermission[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2CreateVolumePermission(entry, context)
  );
};

const deserializeAws_ec2CreateVpcEndpointConnectionNotificationResult = (
  output: any,
  context: __SerdeContext
): CreateVpcEndpointConnectionNotificationResult => {
  let contents: any = {
    __type: "CreateVpcEndpointConnectionNotificationResult",
    ClientToken: undefined,
    ConnectionNotification: undefined
  };
  if (output["clientToken"] !== undefined) {
    contents.ClientToken = output["clientToken"];
  }
  if (output["connectionNotification"] !== undefined) {
    contents.ConnectionNotification = deserializeAws_ec2ConnectionNotification(
      output["connectionNotification"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2CreateVpcEndpointResult = (
  output: any,
  context: __SerdeContext
): CreateVpcEndpointResult => {
  let contents: any = {
    __type: "CreateVpcEndpointResult",
    ClientToken: undefined,
    VpcEndpoint: undefined
  };
  if (output["clientToken"] !== undefined) {
    contents.ClientToken = output["clientToken"];
  }
  if (output["vpcEndpoint"] !== undefined) {
    contents.VpcEndpoint = deserializeAws_ec2VpcEndpoint(
      output["vpcEndpoint"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2CreateVpcEndpointServiceConfigurationResult = (
  output: any,
  context: __SerdeContext
): CreateVpcEndpointServiceConfigurationResult => {
  let contents: any = {
    __type: "CreateVpcEndpointServiceConfigurationResult",
    ClientToken: undefined,
    ServiceConfiguration: undefined
  };
  if (output["clientToken"] !== undefined) {
    contents.ClientToken = output["clientToken"];
  }
  if (output["serviceConfiguration"] !== undefined) {
    contents.ServiceConfiguration = deserializeAws_ec2ServiceConfiguration(
      output["serviceConfiguration"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2CreateVpcPeeringConnectionResult = (
  output: any,
  context: __SerdeContext
): CreateVpcPeeringConnectionResult => {
  let contents: any = {
    __type: "CreateVpcPeeringConnectionResult",
    VpcPeeringConnection: undefined
  };
  if (output["vpcPeeringConnection"] !== undefined) {
    contents.VpcPeeringConnection = deserializeAws_ec2VpcPeeringConnection(
      output["vpcPeeringConnection"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2CreateVpcResult = (
  output: any,
  context: __SerdeContext
): CreateVpcResult => {
  let contents: any = {
    __type: "CreateVpcResult",
    Vpc: undefined
  };
  if (output["vpc"] !== undefined) {
    contents.Vpc = deserializeAws_ec2Vpc(output["vpc"], context);
  }
  return contents;
};

const deserializeAws_ec2CreateVpnConnectionResult = (
  output: any,
  context: __SerdeContext
): CreateVpnConnectionResult => {
  let contents: any = {
    __type: "CreateVpnConnectionResult",
    VpnConnection: undefined
  };
  if (output["vpnConnection"] !== undefined) {
    contents.VpnConnection = deserializeAws_ec2VpnConnection(
      output["vpnConnection"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2CreateVpnGatewayResult = (
  output: any,
  context: __SerdeContext
): CreateVpnGatewayResult => {
  let contents: any = {
    __type: "CreateVpnGatewayResult",
    VpnGateway: undefined
  };
  if (output["vpnGateway"] !== undefined) {
    contents.VpnGateway = deserializeAws_ec2VpnGateway(
      output["vpnGateway"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2CreditSpecification = (
  output: any,
  context: __SerdeContext
): CreditSpecification => {
  let contents: any = {
    __type: "CreditSpecification",
    CpuCredits: undefined
  };
  if (output["cpuCredits"] !== undefined) {
    contents.CpuCredits = output["cpuCredits"];
  }
  return contents;
};

const deserializeAws_ec2CustomerGateway = (
  output: any,
  context: __SerdeContext
): CustomerGateway => {
  let contents: any = {
    __type: "CustomerGateway",
    BgpAsn: undefined,
    CertificateArn: undefined,
    CustomerGatewayId: undefined,
    DeviceName: undefined,
    IpAddress: undefined,
    State: undefined,
    Tags: undefined,
    Type: undefined
  };
  if (output["bgpAsn"] !== undefined) {
    contents.BgpAsn = output["bgpAsn"];
  }
  if (output["certificateArn"] !== undefined) {
    contents.CertificateArn = output["certificateArn"];
  }
  if (output["customerGatewayId"] !== undefined) {
    contents.CustomerGatewayId = output["customerGatewayId"];
  }
  if (output["deviceName"] !== undefined) {
    contents.DeviceName = output["deviceName"];
  }
  if (output["ipAddress"] !== undefined) {
    contents.IpAddress = output["ipAddress"];
  }
  if (output["state"] !== undefined) {
    contents.State = output["state"];
  }
  if (output.tagSet === "") {
    contents.Tags = [];
  }
  if (
    output["tagSet"] !== undefined &&
    output["tagSet"]["item"] !== undefined
  ) {
    contents.Tags = deserializeAws_ec2TagList(
      __getArrayIfSingleItem(output["tagSet"]["item"]),
      context
    );
  }
  if (output["type"] !== undefined) {
    contents.Type = output["type"];
  }
  return contents;
};

const deserializeAws_ec2CustomerGatewayList = (
  output: any,
  context: __SerdeContext
): CustomerGateway[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2CustomerGateway(entry, context)
  );
};

const deserializeAws_ec2DeleteClientVpnEndpointResult = (
  output: any,
  context: __SerdeContext
): DeleteClientVpnEndpointResult => {
  let contents: any = {
    __type: "DeleteClientVpnEndpointResult",
    Status: undefined
  };
  if (output["status"] !== undefined) {
    contents.Status = deserializeAws_ec2ClientVpnEndpointStatus(
      output["status"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2DeleteClientVpnRouteResult = (
  output: any,
  context: __SerdeContext
): DeleteClientVpnRouteResult => {
  let contents: any = {
    __type: "DeleteClientVpnRouteResult",
    Status: undefined
  };
  if (output["status"] !== undefined) {
    contents.Status = deserializeAws_ec2ClientVpnRouteStatus(
      output["status"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2DeleteEgressOnlyInternetGatewayResult = (
  output: any,
  context: __SerdeContext
): DeleteEgressOnlyInternetGatewayResult => {
  let contents: any = {
    __type: "DeleteEgressOnlyInternetGatewayResult",
    ReturnCode: undefined
  };
  if (output["returnCode"] !== undefined) {
    contents.ReturnCode = output["returnCode"] == "true";
  }
  return contents;
};

const deserializeAws_ec2DeleteFleetError = (
  output: any,
  context: __SerdeContext
): DeleteFleetError => {
  let contents: any = {
    __type: "DeleteFleetError",
    Code: undefined,
    Message: undefined
  };
  if (output["code"] !== undefined) {
    contents.Code = output["code"];
  }
  if (output["message"] !== undefined) {
    contents.Message = output["message"];
  }
  return contents;
};

const deserializeAws_ec2DeleteFleetErrorItem = (
  output: any,
  context: __SerdeContext
): DeleteFleetErrorItem => {
  let contents: any = {
    __type: "DeleteFleetErrorItem",
    Error: undefined,
    FleetId: undefined
  };
  if (output["error"] !== undefined) {
    contents.Error = deserializeAws_ec2DeleteFleetError(
      output["error"],
      context
    );
  }
  if (output["fleetId"] !== undefined) {
    contents.FleetId = output["fleetId"];
  }
  return contents;
};

const deserializeAws_ec2DeleteFleetErrorSet = (
  output: any,
  context: __SerdeContext
): DeleteFleetErrorItem[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2DeleteFleetErrorItem(entry, context)
  );
};

const deserializeAws_ec2DeleteFleetsResult = (
  output: any,
  context: __SerdeContext
): DeleteFleetsResult => {
  let contents: any = {
    __type: "DeleteFleetsResult",
    SuccessfulFleetDeletions: undefined,
    UnsuccessfulFleetDeletions: undefined
  };
  if (output.successfulFleetDeletionSet === "") {
    contents.SuccessfulFleetDeletions = [];
  }
  if (
    output["successfulFleetDeletionSet"] !== undefined &&
    output["successfulFleetDeletionSet"]["item"] !== undefined
  ) {
    contents.SuccessfulFleetDeletions = deserializeAws_ec2DeleteFleetSuccessSet(
      __getArrayIfSingleItem(output["successfulFleetDeletionSet"]["item"]),
      context
    );
  }
  if (output.unsuccessfulFleetDeletionSet === "") {
    contents.UnsuccessfulFleetDeletions = [];
  }
  if (
    output["unsuccessfulFleetDeletionSet"] !== undefined &&
    output["unsuccessfulFleetDeletionSet"]["item"] !== undefined
  ) {
    contents.UnsuccessfulFleetDeletions = deserializeAws_ec2DeleteFleetErrorSet(
      __getArrayIfSingleItem(output["unsuccessfulFleetDeletionSet"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2DeleteFleetSuccessItem = (
  output: any,
  context: __SerdeContext
): DeleteFleetSuccessItem => {
  let contents: any = {
    __type: "DeleteFleetSuccessItem",
    CurrentFleetState: undefined,
    FleetId: undefined,
    PreviousFleetState: undefined
  };
  if (output["currentFleetState"] !== undefined) {
    contents.CurrentFleetState = output["currentFleetState"];
  }
  if (output["fleetId"] !== undefined) {
    contents.FleetId = output["fleetId"];
  }
  if (output["previousFleetState"] !== undefined) {
    contents.PreviousFleetState = output["previousFleetState"];
  }
  return contents;
};

const deserializeAws_ec2DeleteFleetSuccessSet = (
  output: any,
  context: __SerdeContext
): DeleteFleetSuccessItem[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2DeleteFleetSuccessItem(entry, context)
  );
};

const deserializeAws_ec2DeleteFlowLogsResult = (
  output: any,
  context: __SerdeContext
): DeleteFlowLogsResult => {
  let contents: any = {
    __type: "DeleteFlowLogsResult",
    Unsuccessful: undefined
  };
  if (output.unsuccessful === "") {
    contents.Unsuccessful = [];
  }
  if (
    output["unsuccessful"] !== undefined &&
    output["unsuccessful"]["item"] !== undefined
  ) {
    contents.Unsuccessful = deserializeAws_ec2UnsuccessfulItemSet(
      __getArrayIfSingleItem(output["unsuccessful"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2DeleteFpgaImageResult = (
  output: any,
  context: __SerdeContext
): DeleteFpgaImageResult => {
  let contents: any = {
    __type: "DeleteFpgaImageResult",
    Return: undefined
  };
  if (output["return"] !== undefined) {
    contents.Return = output["return"] == "true";
  }
  return contents;
};

const deserializeAws_ec2DeleteLaunchTemplateResult = (
  output: any,
  context: __SerdeContext
): DeleteLaunchTemplateResult => {
  let contents: any = {
    __type: "DeleteLaunchTemplateResult",
    LaunchTemplate: undefined
  };
  if (output["launchTemplate"] !== undefined) {
    contents.LaunchTemplate = deserializeAws_ec2LaunchTemplate(
      output["launchTemplate"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2DeleteLaunchTemplateVersionsResponseErrorItem = (
  output: any,
  context: __SerdeContext
): DeleteLaunchTemplateVersionsResponseErrorItem => {
  let contents: any = {
    __type: "DeleteLaunchTemplateVersionsResponseErrorItem",
    LaunchTemplateId: undefined,
    LaunchTemplateName: undefined,
    ResponseError: undefined,
    VersionNumber: undefined
  };
  if (output["launchTemplateId"] !== undefined) {
    contents.LaunchTemplateId = output["launchTemplateId"];
  }
  if (output["launchTemplateName"] !== undefined) {
    contents.LaunchTemplateName = output["launchTemplateName"];
  }
  if (output["responseError"] !== undefined) {
    contents.ResponseError = deserializeAws_ec2ResponseError(
      output["responseError"],
      context
    );
  }
  if (output["versionNumber"] !== undefined) {
    contents.VersionNumber = parseInt(output["versionNumber"]);
  }
  return contents;
};

const deserializeAws_ec2DeleteLaunchTemplateVersionsResponseErrorSet = (
  output: any,
  context: __SerdeContext
): DeleteLaunchTemplateVersionsResponseErrorItem[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2DeleteLaunchTemplateVersionsResponseErrorItem(
      entry,
      context
    )
  );
};

const deserializeAws_ec2DeleteLaunchTemplateVersionsResponseSuccessItem = (
  output: any,
  context: __SerdeContext
): DeleteLaunchTemplateVersionsResponseSuccessItem => {
  let contents: any = {
    __type: "DeleteLaunchTemplateVersionsResponseSuccessItem",
    LaunchTemplateId: undefined,
    LaunchTemplateName: undefined,
    VersionNumber: undefined
  };
  if (output["launchTemplateId"] !== undefined) {
    contents.LaunchTemplateId = output["launchTemplateId"];
  }
  if (output["launchTemplateName"] !== undefined) {
    contents.LaunchTemplateName = output["launchTemplateName"];
  }
  if (output["versionNumber"] !== undefined) {
    contents.VersionNumber = parseInt(output["versionNumber"]);
  }
  return contents;
};

const deserializeAws_ec2DeleteLaunchTemplateVersionsResponseSuccessSet = (
  output: any,
  context: __SerdeContext
): DeleteLaunchTemplateVersionsResponseSuccessItem[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2DeleteLaunchTemplateVersionsResponseSuccessItem(
      entry,
      context
    )
  );
};

const deserializeAws_ec2DeleteLaunchTemplateVersionsResult = (
  output: any,
  context: __SerdeContext
): DeleteLaunchTemplateVersionsResult => {
  let contents: any = {
    __type: "DeleteLaunchTemplateVersionsResult",
    SuccessfullyDeletedLaunchTemplateVersions: undefined,
    UnsuccessfullyDeletedLaunchTemplateVersions: undefined
  };
  if (output.successfullyDeletedLaunchTemplateVersionSet === "") {
    contents.SuccessfullyDeletedLaunchTemplateVersions = [];
  }
  if (
    output["successfullyDeletedLaunchTemplateVersionSet"] !== undefined &&
    output["successfullyDeletedLaunchTemplateVersionSet"]["item"] !== undefined
  ) {
    contents.SuccessfullyDeletedLaunchTemplateVersions = deserializeAws_ec2DeleteLaunchTemplateVersionsResponseSuccessSet(
      __getArrayIfSingleItem(
        output["successfullyDeletedLaunchTemplateVersionSet"]["item"]
      ),
      context
    );
  }
  if (output.unsuccessfullyDeletedLaunchTemplateVersionSet === "") {
    contents.UnsuccessfullyDeletedLaunchTemplateVersions = [];
  }
  if (
    output["unsuccessfullyDeletedLaunchTemplateVersionSet"] !== undefined &&
    output["unsuccessfullyDeletedLaunchTemplateVersionSet"]["item"] !==
      undefined
  ) {
    contents.UnsuccessfullyDeletedLaunchTemplateVersions = deserializeAws_ec2DeleteLaunchTemplateVersionsResponseErrorSet(
      __getArrayIfSingleItem(
        output["unsuccessfullyDeletedLaunchTemplateVersionSet"]["item"]
      ),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2DeleteLocalGatewayRouteResult = (
  output: any,
  context: __SerdeContext
): DeleteLocalGatewayRouteResult => {
  let contents: any = {
    __type: "DeleteLocalGatewayRouteResult",
    Route: undefined
  };
  if (output["route"] !== undefined) {
    contents.Route = deserializeAws_ec2LocalGatewayRoute(
      output["route"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2DeleteLocalGatewayRouteTableVpcAssociationResult = (
  output: any,
  context: __SerdeContext
): DeleteLocalGatewayRouteTableVpcAssociationResult => {
  let contents: any = {
    __type: "DeleteLocalGatewayRouteTableVpcAssociationResult",
    LocalGatewayRouteTableVpcAssociation: undefined
  };
  if (output["localGatewayRouteTableVpcAssociation"] !== undefined) {
    contents.LocalGatewayRouteTableVpcAssociation = deserializeAws_ec2LocalGatewayRouteTableVpcAssociation(
      output["localGatewayRouteTableVpcAssociation"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2DeleteNatGatewayResult = (
  output: any,
  context: __SerdeContext
): DeleteNatGatewayResult => {
  let contents: any = {
    __type: "DeleteNatGatewayResult",
    NatGatewayId: undefined
  };
  if (output["natGatewayId"] !== undefined) {
    contents.NatGatewayId = output["natGatewayId"];
  }
  return contents;
};

const deserializeAws_ec2DeleteNetworkInterfacePermissionResult = (
  output: any,
  context: __SerdeContext
): DeleteNetworkInterfacePermissionResult => {
  let contents: any = {
    __type: "DeleteNetworkInterfacePermissionResult",
    Return: undefined
  };
  if (output["return"] !== undefined) {
    contents.Return = output["return"] == "true";
  }
  return contents;
};

const deserializeAws_ec2DeleteQueuedReservedInstancesError = (
  output: any,
  context: __SerdeContext
): DeleteQueuedReservedInstancesError => {
  let contents: any = {
    __type: "DeleteQueuedReservedInstancesError",
    Code: undefined,
    Message: undefined
  };
  if (output["code"] !== undefined) {
    contents.Code = output["code"];
  }
  if (output["message"] !== undefined) {
    contents.Message = output["message"];
  }
  return contents;
};

const deserializeAws_ec2DeleteQueuedReservedInstancesResult = (
  output: any,
  context: __SerdeContext
): DeleteQueuedReservedInstancesResult => {
  let contents: any = {
    __type: "DeleteQueuedReservedInstancesResult",
    FailedQueuedPurchaseDeletions: undefined,
    SuccessfulQueuedPurchaseDeletions: undefined
  };
  if (output.failedQueuedPurchaseDeletionSet === "") {
    contents.FailedQueuedPurchaseDeletions = [];
  }
  if (
    output["failedQueuedPurchaseDeletionSet"] !== undefined &&
    output["failedQueuedPurchaseDeletionSet"]["item"] !== undefined
  ) {
    contents.FailedQueuedPurchaseDeletions = deserializeAws_ec2FailedQueuedPurchaseDeletionSet(
      __getArrayIfSingleItem(output["failedQueuedPurchaseDeletionSet"]["item"]),
      context
    );
  }
  if (output.successfulQueuedPurchaseDeletionSet === "") {
    contents.SuccessfulQueuedPurchaseDeletions = [];
  }
  if (
    output["successfulQueuedPurchaseDeletionSet"] !== undefined &&
    output["successfulQueuedPurchaseDeletionSet"]["item"] !== undefined
  ) {
    contents.SuccessfulQueuedPurchaseDeletions = deserializeAws_ec2SuccessfulQueuedPurchaseDeletionSet(
      __getArrayIfSingleItem(
        output["successfulQueuedPurchaseDeletionSet"]["item"]
      ),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2DeleteTrafficMirrorFilterResult = (
  output: any,
  context: __SerdeContext
): DeleteTrafficMirrorFilterResult => {
  let contents: any = {
    __type: "DeleteTrafficMirrorFilterResult",
    TrafficMirrorFilterId: undefined
  };
  if (output["trafficMirrorFilterId"] !== undefined) {
    contents.TrafficMirrorFilterId = output["trafficMirrorFilterId"];
  }
  return contents;
};

const deserializeAws_ec2DeleteTrafficMirrorFilterRuleResult = (
  output: any,
  context: __SerdeContext
): DeleteTrafficMirrorFilterRuleResult => {
  let contents: any = {
    __type: "DeleteTrafficMirrorFilterRuleResult",
    TrafficMirrorFilterRuleId: undefined
  };
  if (output["trafficMirrorFilterRuleId"] !== undefined) {
    contents.TrafficMirrorFilterRuleId = output["trafficMirrorFilterRuleId"];
  }
  return contents;
};

const deserializeAws_ec2DeleteTrafficMirrorSessionResult = (
  output: any,
  context: __SerdeContext
): DeleteTrafficMirrorSessionResult => {
  let contents: any = {
    __type: "DeleteTrafficMirrorSessionResult",
    TrafficMirrorSessionId: undefined
  };
  if (output["trafficMirrorSessionId"] !== undefined) {
    contents.TrafficMirrorSessionId = output["trafficMirrorSessionId"];
  }
  return contents;
};

const deserializeAws_ec2DeleteTrafficMirrorTargetResult = (
  output: any,
  context: __SerdeContext
): DeleteTrafficMirrorTargetResult => {
  let contents: any = {
    __type: "DeleteTrafficMirrorTargetResult",
    TrafficMirrorTargetId: undefined
  };
  if (output["trafficMirrorTargetId"] !== undefined) {
    contents.TrafficMirrorTargetId = output["trafficMirrorTargetId"];
  }
  return contents;
};

const deserializeAws_ec2DeleteTransitGatewayMulticastDomainResult = (
  output: any,
  context: __SerdeContext
): DeleteTransitGatewayMulticastDomainResult => {
  let contents: any = {
    __type: "DeleteTransitGatewayMulticastDomainResult",
    TransitGatewayMulticastDomain: undefined
  };
  if (output["transitGatewayMulticastDomain"] !== undefined) {
    contents.TransitGatewayMulticastDomain = deserializeAws_ec2TransitGatewayMulticastDomain(
      output["transitGatewayMulticastDomain"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2DeleteTransitGatewayPeeringAttachmentResult = (
  output: any,
  context: __SerdeContext
): DeleteTransitGatewayPeeringAttachmentResult => {
  let contents: any = {
    __type: "DeleteTransitGatewayPeeringAttachmentResult",
    TransitGatewayPeeringAttachment: undefined
  };
  if (output["transitGatewayPeeringAttachment"] !== undefined) {
    contents.TransitGatewayPeeringAttachment = deserializeAws_ec2TransitGatewayPeeringAttachment(
      output["transitGatewayPeeringAttachment"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2DeleteTransitGatewayResult = (
  output: any,
  context: __SerdeContext
): DeleteTransitGatewayResult => {
  let contents: any = {
    __type: "DeleteTransitGatewayResult",
    TransitGateway: undefined
  };
  if (output["transitGateway"] !== undefined) {
    contents.TransitGateway = deserializeAws_ec2TransitGateway(
      output["transitGateway"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2DeleteTransitGatewayRouteResult = (
  output: any,
  context: __SerdeContext
): DeleteTransitGatewayRouteResult => {
  let contents: any = {
    __type: "DeleteTransitGatewayRouteResult",
    Route: undefined
  };
  if (output["route"] !== undefined) {
    contents.Route = deserializeAws_ec2TransitGatewayRoute(
      output["route"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2DeleteTransitGatewayRouteTableResult = (
  output: any,
  context: __SerdeContext
): DeleteTransitGatewayRouteTableResult => {
  let contents: any = {
    __type: "DeleteTransitGatewayRouteTableResult",
    TransitGatewayRouteTable: undefined
  };
  if (output["transitGatewayRouteTable"] !== undefined) {
    contents.TransitGatewayRouteTable = deserializeAws_ec2TransitGatewayRouteTable(
      output["transitGatewayRouteTable"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2DeleteTransitGatewayVpcAttachmentResult = (
  output: any,
  context: __SerdeContext
): DeleteTransitGatewayVpcAttachmentResult => {
  let contents: any = {
    __type: "DeleteTransitGatewayVpcAttachmentResult",
    TransitGatewayVpcAttachment: undefined
  };
  if (output["transitGatewayVpcAttachment"] !== undefined) {
    contents.TransitGatewayVpcAttachment = deserializeAws_ec2TransitGatewayVpcAttachment(
      output["transitGatewayVpcAttachment"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2DeleteVpcEndpointConnectionNotificationsResult = (
  output: any,
  context: __SerdeContext
): DeleteVpcEndpointConnectionNotificationsResult => {
  let contents: any = {
    __type: "DeleteVpcEndpointConnectionNotificationsResult",
    Unsuccessful: undefined
  };
  if (output.unsuccessful === "") {
    contents.Unsuccessful = [];
  }
  if (
    output["unsuccessful"] !== undefined &&
    output["unsuccessful"]["item"] !== undefined
  ) {
    contents.Unsuccessful = deserializeAws_ec2UnsuccessfulItemSet(
      __getArrayIfSingleItem(output["unsuccessful"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2DeleteVpcEndpointServiceConfigurationsResult = (
  output: any,
  context: __SerdeContext
): DeleteVpcEndpointServiceConfigurationsResult => {
  let contents: any = {
    __type: "DeleteVpcEndpointServiceConfigurationsResult",
    Unsuccessful: undefined
  };
  if (output.unsuccessful === "") {
    contents.Unsuccessful = [];
  }
  if (
    output["unsuccessful"] !== undefined &&
    output["unsuccessful"]["item"] !== undefined
  ) {
    contents.Unsuccessful = deserializeAws_ec2UnsuccessfulItemSet(
      __getArrayIfSingleItem(output["unsuccessful"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2DeleteVpcEndpointsResult = (
  output: any,
  context: __SerdeContext
): DeleteVpcEndpointsResult => {
  let contents: any = {
    __type: "DeleteVpcEndpointsResult",
    Unsuccessful: undefined
  };
  if (output.unsuccessful === "") {
    contents.Unsuccessful = [];
  }
  if (
    output["unsuccessful"] !== undefined &&
    output["unsuccessful"]["item"] !== undefined
  ) {
    contents.Unsuccessful = deserializeAws_ec2UnsuccessfulItemSet(
      __getArrayIfSingleItem(output["unsuccessful"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2DeleteVpcPeeringConnectionResult = (
  output: any,
  context: __SerdeContext
): DeleteVpcPeeringConnectionResult => {
  let contents: any = {
    __type: "DeleteVpcPeeringConnectionResult",
    Return: undefined
  };
  if (output["return"] !== undefined) {
    contents.Return = output["return"] == "true";
  }
  return contents;
};

const deserializeAws_ec2DeprovisionByoipCidrResult = (
  output: any,
  context: __SerdeContext
): DeprovisionByoipCidrResult => {
  let contents: any = {
    __type: "DeprovisionByoipCidrResult",
    ByoipCidr: undefined
  };
  if (output["byoipCidr"] !== undefined) {
    contents.ByoipCidr = deserializeAws_ec2ByoipCidr(
      output["byoipCidr"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2DeregisterTransitGatewayMulticastGroupMembersResult = (
  output: any,
  context: __SerdeContext
): DeregisterTransitGatewayMulticastGroupMembersResult => {
  let contents: any = {
    __type: "DeregisterTransitGatewayMulticastGroupMembersResult",
    DeregisteredMulticastGroupMembers: undefined
  };
  if (output["deregisteredMulticastGroupMembers"] !== undefined) {
    contents.DeregisteredMulticastGroupMembers = deserializeAws_ec2TransitGatewayMulticastDeregisteredGroupMembers(
      output["deregisteredMulticastGroupMembers"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2DeregisterTransitGatewayMulticastGroupSourcesResult = (
  output: any,
  context: __SerdeContext
): DeregisterTransitGatewayMulticastGroupSourcesResult => {
  let contents: any = {
    __type: "DeregisterTransitGatewayMulticastGroupSourcesResult",
    DeregisteredMulticastGroupSources: undefined
  };
  if (output["deregisteredMulticastGroupSources"] !== undefined) {
    contents.DeregisteredMulticastGroupSources = deserializeAws_ec2TransitGatewayMulticastDeregisteredGroupSources(
      output["deregisteredMulticastGroupSources"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2DescribeAccountAttributesResult = (
  output: any,
  context: __SerdeContext
): DescribeAccountAttributesResult => {
  let contents: any = {
    __type: "DescribeAccountAttributesResult",
    AccountAttributes: undefined
  };
  if (output.accountAttributeSet === "") {
    contents.AccountAttributes = [];
  }
  if (
    output["accountAttributeSet"] !== undefined &&
    output["accountAttributeSet"]["item"] !== undefined
  ) {
    contents.AccountAttributes = deserializeAws_ec2AccountAttributeList(
      __getArrayIfSingleItem(output["accountAttributeSet"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2DescribeAddressesResult = (
  output: any,
  context: __SerdeContext
): DescribeAddressesResult => {
  let contents: any = {
    __type: "DescribeAddressesResult",
    Addresses: undefined
  };
  if (output.addressesSet === "") {
    contents.Addresses = [];
  }
  if (
    output["addressesSet"] !== undefined &&
    output["addressesSet"]["item"] !== undefined
  ) {
    contents.Addresses = deserializeAws_ec2AddressList(
      __getArrayIfSingleItem(output["addressesSet"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2DescribeAggregateIdFormatResult = (
  output: any,
  context: __SerdeContext
): DescribeAggregateIdFormatResult => {
  let contents: any = {
    __type: "DescribeAggregateIdFormatResult",
    Statuses: undefined,
    UseLongIdsAggregated: undefined
  };
  if (output.statusSet === "") {
    contents.Statuses = [];
  }
  if (
    output["statusSet"] !== undefined &&
    output["statusSet"]["item"] !== undefined
  ) {
    contents.Statuses = deserializeAws_ec2IdFormatList(
      __getArrayIfSingleItem(output["statusSet"]["item"]),
      context
    );
  }
  if (output["useLongIdsAggregated"] !== undefined) {
    contents.UseLongIdsAggregated = output["useLongIdsAggregated"] == "true";
  }
  return contents;
};

const deserializeAws_ec2DescribeAvailabilityZonesResult = (
  output: any,
  context: __SerdeContext
): DescribeAvailabilityZonesResult => {
  let contents: any = {
    __type: "DescribeAvailabilityZonesResult",
    AvailabilityZones: undefined
  };
  if (output.availabilityZoneInfo === "") {
    contents.AvailabilityZones = [];
  }
  if (
    output["availabilityZoneInfo"] !== undefined &&
    output["availabilityZoneInfo"]["item"] !== undefined
  ) {
    contents.AvailabilityZones = deserializeAws_ec2AvailabilityZoneList(
      __getArrayIfSingleItem(output["availabilityZoneInfo"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2DescribeBundleTasksResult = (
  output: any,
  context: __SerdeContext
): DescribeBundleTasksResult => {
  let contents: any = {
    __type: "DescribeBundleTasksResult",
    BundleTasks: undefined
  };
  if (output.bundleInstanceTasksSet === "") {
    contents.BundleTasks = [];
  }
  if (
    output["bundleInstanceTasksSet"] !== undefined &&
    output["bundleInstanceTasksSet"]["item"] !== undefined
  ) {
    contents.BundleTasks = deserializeAws_ec2BundleTaskList(
      __getArrayIfSingleItem(output["bundleInstanceTasksSet"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2DescribeByoipCidrsResult = (
  output: any,
  context: __SerdeContext
): DescribeByoipCidrsResult => {
  let contents: any = {
    __type: "DescribeByoipCidrsResult",
    ByoipCidrs: undefined,
    NextToken: undefined
  };
  if (output.byoipCidrSet === "") {
    contents.ByoipCidrs = [];
  }
  if (
    output["byoipCidrSet"] !== undefined &&
    output["byoipCidrSet"]["item"] !== undefined
  ) {
    contents.ByoipCidrs = deserializeAws_ec2ByoipCidrSet(
      __getArrayIfSingleItem(output["byoipCidrSet"]["item"]),
      context
    );
  }
  if (output["nextToken"] !== undefined) {
    contents.NextToken = output["nextToken"];
  }
  return contents;
};

const deserializeAws_ec2DescribeCapacityReservationsResult = (
  output: any,
  context: __SerdeContext
): DescribeCapacityReservationsResult => {
  let contents: any = {
    __type: "DescribeCapacityReservationsResult",
    CapacityReservations: undefined,
    NextToken: undefined
  };
  if (output.capacityReservationSet === "") {
    contents.CapacityReservations = [];
  }
  if (
    output["capacityReservationSet"] !== undefined &&
    output["capacityReservationSet"]["item"] !== undefined
  ) {
    contents.CapacityReservations = deserializeAws_ec2CapacityReservationSet(
      __getArrayIfSingleItem(output["capacityReservationSet"]["item"]),
      context
    );
  }
  if (output["nextToken"] !== undefined) {
    contents.NextToken = output["nextToken"];
  }
  return contents;
};

const deserializeAws_ec2DescribeClassicLinkInstancesResult = (
  output: any,
  context: __SerdeContext
): DescribeClassicLinkInstancesResult => {
  let contents: any = {
    __type: "DescribeClassicLinkInstancesResult",
    Instances: undefined,
    NextToken: undefined
  };
  if (output.instancesSet === "") {
    contents.Instances = [];
  }
  if (
    output["instancesSet"] !== undefined &&
    output["instancesSet"]["item"] !== undefined
  ) {
    contents.Instances = deserializeAws_ec2ClassicLinkInstanceList(
      __getArrayIfSingleItem(output["instancesSet"]["item"]),
      context
    );
  }
  if (output["nextToken"] !== undefined) {
    contents.NextToken = output["nextToken"];
  }
  return contents;
};

const deserializeAws_ec2DescribeClientVpnAuthorizationRulesResult = (
  output: any,
  context: __SerdeContext
): DescribeClientVpnAuthorizationRulesResult => {
  let contents: any = {
    __type: "DescribeClientVpnAuthorizationRulesResult",
    AuthorizationRules: undefined,
    NextToken: undefined
  };
  if (output.authorizationRule === "") {
    contents.AuthorizationRules = [];
  }
  if (
    output["authorizationRule"] !== undefined &&
    output["authorizationRule"]["item"] !== undefined
  ) {
    contents.AuthorizationRules = deserializeAws_ec2AuthorizationRuleSet(
      __getArrayIfSingleItem(output["authorizationRule"]["item"]),
      context
    );
  }
  if (output["nextToken"] !== undefined) {
    contents.NextToken = output["nextToken"];
  }
  return contents;
};

const deserializeAws_ec2DescribeClientVpnConnectionsResult = (
  output: any,
  context: __SerdeContext
): DescribeClientVpnConnectionsResult => {
  let contents: any = {
    __type: "DescribeClientVpnConnectionsResult",
    Connections: undefined,
    NextToken: undefined
  };
  if (output.connections === "") {
    contents.Connections = [];
  }
  if (
    output["connections"] !== undefined &&
    output["connections"]["item"] !== undefined
  ) {
    contents.Connections = deserializeAws_ec2ClientVpnConnectionSet(
      __getArrayIfSingleItem(output["connections"]["item"]),
      context
    );
  }
  if (output["nextToken"] !== undefined) {
    contents.NextToken = output["nextToken"];
  }
  return contents;
};

const deserializeAws_ec2DescribeClientVpnEndpointsResult = (
  output: any,
  context: __SerdeContext
): DescribeClientVpnEndpointsResult => {
  let contents: any = {
    __type: "DescribeClientVpnEndpointsResult",
    ClientVpnEndpoints: undefined,
    NextToken: undefined
  };
  if (output.clientVpnEndpoint === "") {
    contents.ClientVpnEndpoints = [];
  }
  if (
    output["clientVpnEndpoint"] !== undefined &&
    output["clientVpnEndpoint"]["item"] !== undefined
  ) {
    contents.ClientVpnEndpoints = deserializeAws_ec2EndpointSet(
      __getArrayIfSingleItem(output["clientVpnEndpoint"]["item"]),
      context
    );
  }
  if (output["nextToken"] !== undefined) {
    contents.NextToken = output["nextToken"];
  }
  return contents;
};

const deserializeAws_ec2DescribeClientVpnRoutesResult = (
  output: any,
  context: __SerdeContext
): DescribeClientVpnRoutesResult => {
  let contents: any = {
    __type: "DescribeClientVpnRoutesResult",
    NextToken: undefined,
    Routes: undefined
  };
  if (output["nextToken"] !== undefined) {
    contents.NextToken = output["nextToken"];
  }
  if (output.routes === "") {
    contents.Routes = [];
  }
  if (
    output["routes"] !== undefined &&
    output["routes"]["item"] !== undefined
  ) {
    contents.Routes = deserializeAws_ec2ClientVpnRouteSet(
      __getArrayIfSingleItem(output["routes"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2DescribeClientVpnTargetNetworksResult = (
  output: any,
  context: __SerdeContext
): DescribeClientVpnTargetNetworksResult => {
  let contents: any = {
    __type: "DescribeClientVpnTargetNetworksResult",
    ClientVpnTargetNetworks: undefined,
    NextToken: undefined
  };
  if (output.clientVpnTargetNetworks === "") {
    contents.ClientVpnTargetNetworks = [];
  }
  if (
    output["clientVpnTargetNetworks"] !== undefined &&
    output["clientVpnTargetNetworks"]["item"] !== undefined
  ) {
    contents.ClientVpnTargetNetworks = deserializeAws_ec2TargetNetworkSet(
      __getArrayIfSingleItem(output["clientVpnTargetNetworks"]["item"]),
      context
    );
  }
  if (output["nextToken"] !== undefined) {
    contents.NextToken = output["nextToken"];
  }
  return contents;
};

const deserializeAws_ec2DescribeCoipPoolsResult = (
  output: any,
  context: __SerdeContext
): DescribeCoipPoolsResult => {
  let contents: any = {
    __type: "DescribeCoipPoolsResult",
    CoipPools: undefined,
    NextToken: undefined
  };
  if (output.coipPoolSet === "") {
    contents.CoipPools = [];
  }
  if (
    output["coipPoolSet"] !== undefined &&
    output["coipPoolSet"]["item"] !== undefined
  ) {
    contents.CoipPools = deserializeAws_ec2CoipPoolSet(
      __getArrayIfSingleItem(output["coipPoolSet"]["item"]),
      context
    );
  }
  if (output["nextToken"] !== undefined) {
    contents.NextToken = output["nextToken"];
  }
  return contents;
};

const deserializeAws_ec2DescribeConversionTaskList = (
  output: any,
  context: __SerdeContext
): ConversionTask[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2ConversionTask(entry, context)
  );
};

const deserializeAws_ec2DescribeConversionTasksResult = (
  output: any,
  context: __SerdeContext
): DescribeConversionTasksResult => {
  let contents: any = {
    __type: "DescribeConversionTasksResult",
    ConversionTasks: undefined
  };
  if (output.conversionTasks === "") {
    contents.ConversionTasks = [];
  }
  if (
    output["conversionTasks"] !== undefined &&
    output["conversionTasks"]["item"] !== undefined
  ) {
    contents.ConversionTasks = deserializeAws_ec2DescribeConversionTaskList(
      __getArrayIfSingleItem(output["conversionTasks"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2DescribeCustomerGatewaysResult = (
  output: any,
  context: __SerdeContext
): DescribeCustomerGatewaysResult => {
  let contents: any = {
    __type: "DescribeCustomerGatewaysResult",
    CustomerGateways: undefined
  };
  if (output.customerGatewaySet === "") {
    contents.CustomerGateways = [];
  }
  if (
    output["customerGatewaySet"] !== undefined &&
    output["customerGatewaySet"]["item"] !== undefined
  ) {
    contents.CustomerGateways = deserializeAws_ec2CustomerGatewayList(
      __getArrayIfSingleItem(output["customerGatewaySet"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2DescribeDhcpOptionsResult = (
  output: any,
  context: __SerdeContext
): DescribeDhcpOptionsResult => {
  let contents: any = {
    __type: "DescribeDhcpOptionsResult",
    DhcpOptions: undefined,
    NextToken: undefined
  };
  if (output.dhcpOptionsSet === "") {
    contents.DhcpOptions = [];
  }
  if (
    output["dhcpOptionsSet"] !== undefined &&
    output["dhcpOptionsSet"]["item"] !== undefined
  ) {
    contents.DhcpOptions = deserializeAws_ec2DhcpOptionsList(
      __getArrayIfSingleItem(output["dhcpOptionsSet"]["item"]),
      context
    );
  }
  if (output["nextToken"] !== undefined) {
    contents.NextToken = output["nextToken"];
  }
  return contents;
};

const deserializeAws_ec2DescribeEgressOnlyInternetGatewaysResult = (
  output: any,
  context: __SerdeContext
): DescribeEgressOnlyInternetGatewaysResult => {
  let contents: any = {
    __type: "DescribeEgressOnlyInternetGatewaysResult",
    EgressOnlyInternetGateways: undefined,
    NextToken: undefined
  };
  if (output.egressOnlyInternetGatewaySet === "") {
    contents.EgressOnlyInternetGateways = [];
  }
  if (
    output["egressOnlyInternetGatewaySet"] !== undefined &&
    output["egressOnlyInternetGatewaySet"]["item"] !== undefined
  ) {
    contents.EgressOnlyInternetGateways = deserializeAws_ec2EgressOnlyInternetGatewayList(
      __getArrayIfSingleItem(output["egressOnlyInternetGatewaySet"]["item"]),
      context
    );
  }
  if (output["nextToken"] !== undefined) {
    contents.NextToken = output["nextToken"];
  }
  return contents;
};

const deserializeAws_ec2DescribeElasticGpusResult = (
  output: any,
  context: __SerdeContext
): DescribeElasticGpusResult => {
  let contents: any = {
    __type: "DescribeElasticGpusResult",
    ElasticGpuSet: undefined,
    MaxResults: undefined,
    NextToken: undefined
  };
  if (output.elasticGpuSet === "") {
    contents.ElasticGpuSet = [];
  }
  if (
    output["elasticGpuSet"] !== undefined &&
    output["elasticGpuSet"]["item"] !== undefined
  ) {
    contents.ElasticGpuSet = deserializeAws_ec2ElasticGpuSet(
      __getArrayIfSingleItem(output["elasticGpuSet"]["item"]),
      context
    );
  }
  if (output["maxResults"] !== undefined) {
    contents.MaxResults = parseInt(output["maxResults"]);
  }
  if (output["nextToken"] !== undefined) {
    contents.NextToken = output["nextToken"];
  }
  return contents;
};

const deserializeAws_ec2DescribeExportImageTasksResult = (
  output: any,
  context: __SerdeContext
): DescribeExportImageTasksResult => {
  let contents: any = {
    __type: "DescribeExportImageTasksResult",
    ExportImageTasks: undefined,
    NextToken: undefined
  };
  if (output.exportImageTaskSet === "") {
    contents.ExportImageTasks = [];
  }
  if (
    output["exportImageTaskSet"] !== undefined &&
    output["exportImageTaskSet"]["item"] !== undefined
  ) {
    contents.ExportImageTasks = deserializeAws_ec2ExportImageTaskList(
      __getArrayIfSingleItem(output["exportImageTaskSet"]["item"]),
      context
    );
  }
  if (output["nextToken"] !== undefined) {
    contents.NextToken = output["nextToken"];
  }
  return contents;
};

const deserializeAws_ec2DescribeExportTasksResult = (
  output: any,
  context: __SerdeContext
): DescribeExportTasksResult => {
  let contents: any = {
    __type: "DescribeExportTasksResult",
    ExportTasks: undefined
  };
  if (output.exportTaskSet === "") {
    contents.ExportTasks = [];
  }
  if (
    output["exportTaskSet"] !== undefined &&
    output["exportTaskSet"]["item"] !== undefined
  ) {
    contents.ExportTasks = deserializeAws_ec2ExportTaskList(
      __getArrayIfSingleItem(output["exportTaskSet"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2DescribeFastSnapshotRestoresResult = (
  output: any,
  context: __SerdeContext
): DescribeFastSnapshotRestoresResult => {
  let contents: any = {
    __type: "DescribeFastSnapshotRestoresResult",
    FastSnapshotRestores: undefined,
    NextToken: undefined
  };
  if (output.fastSnapshotRestoreSet === "") {
    contents.FastSnapshotRestores = [];
  }
  if (
    output["fastSnapshotRestoreSet"] !== undefined &&
    output["fastSnapshotRestoreSet"]["item"] !== undefined
  ) {
    contents.FastSnapshotRestores = deserializeAws_ec2DescribeFastSnapshotRestoreSuccessSet(
      __getArrayIfSingleItem(output["fastSnapshotRestoreSet"]["item"]),
      context
    );
  }
  if (output["nextToken"] !== undefined) {
    contents.NextToken = output["nextToken"];
  }
  return contents;
};

const deserializeAws_ec2DescribeFastSnapshotRestoreSuccessItem = (
  output: any,
  context: __SerdeContext
): DescribeFastSnapshotRestoreSuccessItem => {
  let contents: any = {
    __type: "DescribeFastSnapshotRestoreSuccessItem",
    AvailabilityZone: undefined,
    DisabledTime: undefined,
    DisablingTime: undefined,
    EnabledTime: undefined,
    EnablingTime: undefined,
    OptimizingTime: undefined,
    OwnerAlias: undefined,
    OwnerId: undefined,
    SnapshotId: undefined,
    State: undefined,
    StateTransitionReason: undefined
  };
  if (output["availabilityZone"] !== undefined) {
    contents.AvailabilityZone = output["availabilityZone"];
  }
  if (output["disabledTime"] !== undefined) {
    contents.DisabledTime = new Date(output["disabledTime"]);
  }
  if (output["disablingTime"] !== undefined) {
    contents.DisablingTime = new Date(output["disablingTime"]);
  }
  if (output["enabledTime"] !== undefined) {
    contents.EnabledTime = new Date(output["enabledTime"]);
  }
  if (output["enablingTime"] !== undefined) {
    contents.EnablingTime = new Date(output["enablingTime"]);
  }
  if (output["optimizingTime"] !== undefined) {
    contents.OptimizingTime = new Date(output["optimizingTime"]);
  }
  if (output["ownerAlias"] !== undefined) {
    contents.OwnerAlias = output["ownerAlias"];
  }
  if (output["ownerId"] !== undefined) {
    contents.OwnerId = output["ownerId"];
  }
  if (output["snapshotId"] !== undefined) {
    contents.SnapshotId = output["snapshotId"];
  }
  if (output["state"] !== undefined) {
    contents.State = output["state"];
  }
  if (output["stateTransitionReason"] !== undefined) {
    contents.StateTransitionReason = output["stateTransitionReason"];
  }
  return contents;
};

const deserializeAws_ec2DescribeFastSnapshotRestoreSuccessSet = (
  output: any,
  context: __SerdeContext
): DescribeFastSnapshotRestoreSuccessItem[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2DescribeFastSnapshotRestoreSuccessItem(entry, context)
  );
};

const deserializeAws_ec2DescribeFleetError = (
  output: any,
  context: __SerdeContext
): DescribeFleetError => {
  let contents: any = {
    __type: "DescribeFleetError",
    ErrorCode: undefined,
    ErrorMessage: undefined,
    LaunchTemplateAndOverrides: undefined,
    Lifecycle: undefined
  };
  if (output["errorCode"] !== undefined) {
    contents.ErrorCode = output["errorCode"];
  }
  if (output["errorMessage"] !== undefined) {
    contents.ErrorMessage = output["errorMessage"];
  }
  if (output["launchTemplateAndOverrides"] !== undefined) {
    contents.LaunchTemplateAndOverrides = deserializeAws_ec2LaunchTemplateAndOverridesResponse(
      output["launchTemplateAndOverrides"],
      context
    );
  }
  if (output["lifecycle"] !== undefined) {
    contents.Lifecycle = output["lifecycle"];
  }
  return contents;
};

const deserializeAws_ec2DescribeFleetHistoryResult = (
  output: any,
  context: __SerdeContext
): DescribeFleetHistoryResult => {
  let contents: any = {
    __type: "DescribeFleetHistoryResult",
    FleetId: undefined,
    HistoryRecords: undefined,
    LastEvaluatedTime: undefined,
    NextToken: undefined,
    StartTime: undefined
  };
  if (output["fleetId"] !== undefined) {
    contents.FleetId = output["fleetId"];
  }
  if (output.historyRecordSet === "") {
    contents.HistoryRecords = [];
  }
  if (
    output["historyRecordSet"] !== undefined &&
    output["historyRecordSet"]["item"] !== undefined
  ) {
    contents.HistoryRecords = deserializeAws_ec2HistoryRecordSet(
      __getArrayIfSingleItem(output["historyRecordSet"]["item"]),
      context
    );
  }
  if (output["lastEvaluatedTime"] !== undefined) {
    contents.LastEvaluatedTime = new Date(output["lastEvaluatedTime"]);
  }
  if (output["nextToken"] !== undefined) {
    contents.NextToken = output["nextToken"];
  }
  if (output["startTime"] !== undefined) {
    contents.StartTime = new Date(output["startTime"]);
  }
  return contents;
};

const deserializeAws_ec2DescribeFleetInstancesResult = (
  output: any,
  context: __SerdeContext
): DescribeFleetInstancesResult => {
  let contents: any = {
    __type: "DescribeFleetInstancesResult",
    ActiveInstances: undefined,
    FleetId: undefined,
    NextToken: undefined
  };
  if (output.activeInstanceSet === "") {
    contents.ActiveInstances = [];
  }
  if (
    output["activeInstanceSet"] !== undefined &&
    output["activeInstanceSet"]["item"] !== undefined
  ) {
    contents.ActiveInstances = deserializeAws_ec2ActiveInstanceSet(
      __getArrayIfSingleItem(output["activeInstanceSet"]["item"]),
      context
    );
  }
  if (output["fleetId"] !== undefined) {
    contents.FleetId = output["fleetId"];
  }
  if (output["nextToken"] !== undefined) {
    contents.NextToken = output["nextToken"];
  }
  return contents;
};

const deserializeAws_ec2DescribeFleetsErrorSet = (
  output: any,
  context: __SerdeContext
): DescribeFleetError[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2DescribeFleetError(entry, context)
  );
};

const deserializeAws_ec2DescribeFleetsInstances = (
  output: any,
  context: __SerdeContext
): DescribeFleetsInstances => {
  let contents: any = {
    __type: "DescribeFleetsInstances",
    InstanceIds: undefined,
    InstanceType: undefined,
    LaunchTemplateAndOverrides: undefined,
    Lifecycle: undefined,
    Platform: undefined
  };
  if (output.instanceIds === "") {
    contents.InstanceIds = [];
  }
  if (
    output["instanceIds"] !== undefined &&
    output["instanceIds"]["item"] !== undefined
  ) {
    contents.InstanceIds = deserializeAws_ec2InstanceIdsSet(
      __getArrayIfSingleItem(output["instanceIds"]["item"]),
      context
    );
  }
  if (output["instanceType"] !== undefined) {
    contents.InstanceType = output["instanceType"];
  }
  if (output["launchTemplateAndOverrides"] !== undefined) {
    contents.LaunchTemplateAndOverrides = deserializeAws_ec2LaunchTemplateAndOverridesResponse(
      output["launchTemplateAndOverrides"],
      context
    );
  }
  if (output["lifecycle"] !== undefined) {
    contents.Lifecycle = output["lifecycle"];
  }
  if (output["platform"] !== undefined) {
    contents.Platform = output["platform"];
  }
  return contents;
};

const deserializeAws_ec2DescribeFleetsInstancesSet = (
  output: any,
  context: __SerdeContext
): DescribeFleetsInstances[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2DescribeFleetsInstances(entry, context)
  );
};

const deserializeAws_ec2DescribeFleetsResult = (
  output: any,
  context: __SerdeContext
): DescribeFleetsResult => {
  let contents: any = {
    __type: "DescribeFleetsResult",
    Fleets: undefined,
    NextToken: undefined
  };
  if (output.fleetSet === "") {
    contents.Fleets = [];
  }
  if (
    output["fleetSet"] !== undefined &&
    output["fleetSet"]["item"] !== undefined
  ) {
    contents.Fleets = deserializeAws_ec2FleetSet(
      __getArrayIfSingleItem(output["fleetSet"]["item"]),
      context
    );
  }
  if (output["nextToken"] !== undefined) {
    contents.NextToken = output["nextToken"];
  }
  return contents;
};

const deserializeAws_ec2DescribeFlowLogsResult = (
  output: any,
  context: __SerdeContext
): DescribeFlowLogsResult => {
  let contents: any = {
    __type: "DescribeFlowLogsResult",
    FlowLogs: undefined,
    NextToken: undefined
  };
  if (output.flowLogSet === "") {
    contents.FlowLogs = [];
  }
  if (
    output["flowLogSet"] !== undefined &&
    output["flowLogSet"]["item"] !== undefined
  ) {
    contents.FlowLogs = deserializeAws_ec2FlowLogSet(
      __getArrayIfSingleItem(output["flowLogSet"]["item"]),
      context
    );
  }
  if (output["nextToken"] !== undefined) {
    contents.NextToken = output["nextToken"];
  }
  return contents;
};

const deserializeAws_ec2DescribeFpgaImageAttributeResult = (
  output: any,
  context: __SerdeContext
): DescribeFpgaImageAttributeResult => {
  let contents: any = {
    __type: "DescribeFpgaImageAttributeResult",
    FpgaImageAttribute: undefined
  };
  if (output["fpgaImageAttribute"] !== undefined) {
    contents.FpgaImageAttribute = deserializeAws_ec2FpgaImageAttribute(
      output["fpgaImageAttribute"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2DescribeFpgaImagesResult = (
  output: any,
  context: __SerdeContext
): DescribeFpgaImagesResult => {
  let contents: any = {
    __type: "DescribeFpgaImagesResult",
    FpgaImages: undefined,
    NextToken: undefined
  };
  if (output.fpgaImageSet === "") {
    contents.FpgaImages = [];
  }
  if (
    output["fpgaImageSet"] !== undefined &&
    output["fpgaImageSet"]["item"] !== undefined
  ) {
    contents.FpgaImages = deserializeAws_ec2FpgaImageList(
      __getArrayIfSingleItem(output["fpgaImageSet"]["item"]),
      context
    );
  }
  if (output["nextToken"] !== undefined) {
    contents.NextToken = output["nextToken"];
  }
  return contents;
};

const deserializeAws_ec2DescribeHostReservationOfferingsResult = (
  output: any,
  context: __SerdeContext
): DescribeHostReservationOfferingsResult => {
  let contents: any = {
    __type: "DescribeHostReservationOfferingsResult",
    NextToken: undefined,
    OfferingSet: undefined
  };
  if (output["nextToken"] !== undefined) {
    contents.NextToken = output["nextToken"];
  }
  if (output.offeringSet === "") {
    contents.OfferingSet = [];
  }
  if (
    output["offeringSet"] !== undefined &&
    output["offeringSet"]["item"] !== undefined
  ) {
    contents.OfferingSet = deserializeAws_ec2HostOfferingSet(
      __getArrayIfSingleItem(output["offeringSet"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2DescribeHostReservationsResult = (
  output: any,
  context: __SerdeContext
): DescribeHostReservationsResult => {
  let contents: any = {
    __type: "DescribeHostReservationsResult",
    HostReservationSet: undefined,
    NextToken: undefined
  };
  if (output.hostReservationSet === "") {
    contents.HostReservationSet = [];
  }
  if (
    output["hostReservationSet"] !== undefined &&
    output["hostReservationSet"]["item"] !== undefined
  ) {
    contents.HostReservationSet = deserializeAws_ec2HostReservationSet(
      __getArrayIfSingleItem(output["hostReservationSet"]["item"]),
      context
    );
  }
  if (output["nextToken"] !== undefined) {
    contents.NextToken = output["nextToken"];
  }
  return contents;
};

const deserializeAws_ec2DescribeHostsResult = (
  output: any,
  context: __SerdeContext
): DescribeHostsResult => {
  let contents: any = {
    __type: "DescribeHostsResult",
    Hosts: undefined,
    NextToken: undefined
  };
  if (output.hostSet === "") {
    contents.Hosts = [];
  }
  if (
    output["hostSet"] !== undefined &&
    output["hostSet"]["item"] !== undefined
  ) {
    contents.Hosts = deserializeAws_ec2HostList(
      __getArrayIfSingleItem(output["hostSet"]["item"]),
      context
    );
  }
  if (output["nextToken"] !== undefined) {
    contents.NextToken = output["nextToken"];
  }
  return contents;
};

const deserializeAws_ec2DescribeIamInstanceProfileAssociationsResult = (
  output: any,
  context: __SerdeContext
): DescribeIamInstanceProfileAssociationsResult => {
  let contents: any = {
    __type: "DescribeIamInstanceProfileAssociationsResult",
    IamInstanceProfileAssociations: undefined,
    NextToken: undefined
  };
  if (output.iamInstanceProfileAssociationSet === "") {
    contents.IamInstanceProfileAssociations = [];
  }
  if (
    output["iamInstanceProfileAssociationSet"] !== undefined &&
    output["iamInstanceProfileAssociationSet"]["item"] !== undefined
  ) {
    contents.IamInstanceProfileAssociations = deserializeAws_ec2IamInstanceProfileAssociationSet(
      __getArrayIfSingleItem(
        output["iamInstanceProfileAssociationSet"]["item"]
      ),
      context
    );
  }
  if (output["nextToken"] !== undefined) {
    contents.NextToken = output["nextToken"];
  }
  return contents;
};

const deserializeAws_ec2DescribeIdentityIdFormatResult = (
  output: any,
  context: __SerdeContext
): DescribeIdentityIdFormatResult => {
  let contents: any = {
    __type: "DescribeIdentityIdFormatResult",
    Statuses: undefined
  };
  if (output.statusSet === "") {
    contents.Statuses = [];
  }
  if (
    output["statusSet"] !== undefined &&
    output["statusSet"]["item"] !== undefined
  ) {
    contents.Statuses = deserializeAws_ec2IdFormatList(
      __getArrayIfSingleItem(output["statusSet"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2DescribeIdFormatResult = (
  output: any,
  context: __SerdeContext
): DescribeIdFormatResult => {
  let contents: any = {
    __type: "DescribeIdFormatResult",
    Statuses: undefined
  };
  if (output.statusSet === "") {
    contents.Statuses = [];
  }
  if (
    output["statusSet"] !== undefined &&
    output["statusSet"]["item"] !== undefined
  ) {
    contents.Statuses = deserializeAws_ec2IdFormatList(
      __getArrayIfSingleItem(output["statusSet"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2DescribeImagesResult = (
  output: any,
  context: __SerdeContext
): DescribeImagesResult => {
  let contents: any = {
    __type: "DescribeImagesResult",
    Images: undefined
  };
  if (output.imagesSet === "") {
    contents.Images = [];
  }
  if (
    output["imagesSet"] !== undefined &&
    output["imagesSet"]["item"] !== undefined
  ) {
    contents.Images = deserializeAws_ec2ImageList(
      __getArrayIfSingleItem(output["imagesSet"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2DescribeImportImageTasksResult = (
  output: any,
  context: __SerdeContext
): DescribeImportImageTasksResult => {
  let contents: any = {
    __type: "DescribeImportImageTasksResult",
    ImportImageTasks: undefined,
    NextToken: undefined
  };
  if (output.importImageTaskSet === "") {
    contents.ImportImageTasks = [];
  }
  if (
    output["importImageTaskSet"] !== undefined &&
    output["importImageTaskSet"]["item"] !== undefined
  ) {
    contents.ImportImageTasks = deserializeAws_ec2ImportImageTaskList(
      __getArrayIfSingleItem(output["importImageTaskSet"]["item"]),
      context
    );
  }
  if (output["nextToken"] !== undefined) {
    contents.NextToken = output["nextToken"];
  }
  return contents;
};

const deserializeAws_ec2DescribeImportSnapshotTasksResult = (
  output: any,
  context: __SerdeContext
): DescribeImportSnapshotTasksResult => {
  let contents: any = {
    __type: "DescribeImportSnapshotTasksResult",
    ImportSnapshotTasks: undefined,
    NextToken: undefined
  };
  if (output.importSnapshotTaskSet === "") {
    contents.ImportSnapshotTasks = [];
  }
  if (
    output["importSnapshotTaskSet"] !== undefined &&
    output["importSnapshotTaskSet"]["item"] !== undefined
  ) {
    contents.ImportSnapshotTasks = deserializeAws_ec2ImportSnapshotTaskList(
      __getArrayIfSingleItem(output["importSnapshotTaskSet"]["item"]),
      context
    );
  }
  if (output["nextToken"] !== undefined) {
    contents.NextToken = output["nextToken"];
  }
  return contents;
};

const deserializeAws_ec2DescribeInstanceCreditSpecificationsResult = (
  output: any,
  context: __SerdeContext
): DescribeInstanceCreditSpecificationsResult => {
  let contents: any = {
    __type: "DescribeInstanceCreditSpecificationsResult",
    InstanceCreditSpecifications: undefined,
    NextToken: undefined
  };
  if (output.instanceCreditSpecificationSet === "") {
    contents.InstanceCreditSpecifications = [];
  }
  if (
    output["instanceCreditSpecificationSet"] !== undefined &&
    output["instanceCreditSpecificationSet"]["item"] !== undefined
  ) {
    contents.InstanceCreditSpecifications = deserializeAws_ec2InstanceCreditSpecificationList(
      __getArrayIfSingleItem(output["instanceCreditSpecificationSet"]["item"]),
      context
    );
  }
  if (output["nextToken"] !== undefined) {
    contents.NextToken = output["nextToken"];
  }
  return contents;
};

const deserializeAws_ec2DescribeInstancesResult = (
  output: any,
  context: __SerdeContext
): DescribeInstancesResult => {
  let contents: any = {
    __type: "DescribeInstancesResult",
    NextToken: undefined,
    Reservations: undefined
  };
  if (output["nextToken"] !== undefined) {
    contents.NextToken = output["nextToken"];
  }
  if (output.reservationSet === "") {
    contents.Reservations = [];
  }
  if (
    output["reservationSet"] !== undefined &&
    output["reservationSet"]["item"] !== undefined
  ) {
    contents.Reservations = deserializeAws_ec2ReservationList(
      __getArrayIfSingleItem(output["reservationSet"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2DescribeInstanceStatusResult = (
  output: any,
  context: __SerdeContext
): DescribeInstanceStatusResult => {
  let contents: any = {
    __type: "DescribeInstanceStatusResult",
    InstanceStatuses: undefined,
    NextToken: undefined
  };
  if (output.instanceStatusSet === "") {
    contents.InstanceStatuses = [];
  }
  if (
    output["instanceStatusSet"] !== undefined &&
    output["instanceStatusSet"]["item"] !== undefined
  ) {
    contents.InstanceStatuses = deserializeAws_ec2InstanceStatusList(
      __getArrayIfSingleItem(output["instanceStatusSet"]["item"]),
      context
    );
  }
  if (output["nextToken"] !== undefined) {
    contents.NextToken = output["nextToken"];
  }
  return contents;
};

const deserializeAws_ec2DescribeInstanceTypeOfferingsResult = (
  output: any,
  context: __SerdeContext
): DescribeInstanceTypeOfferingsResult => {
  let contents: any = {
    __type: "DescribeInstanceTypeOfferingsResult",
    InstanceTypeOfferings: undefined,
    NextToken: undefined
  };
  if (output.instanceTypeOfferingSet === "") {
    contents.InstanceTypeOfferings = [];
  }
  if (
    output["instanceTypeOfferingSet"] !== undefined &&
    output["instanceTypeOfferingSet"]["item"] !== undefined
  ) {
    contents.InstanceTypeOfferings = deserializeAws_ec2InstanceTypeOfferingsList(
      __getArrayIfSingleItem(output["instanceTypeOfferingSet"]["item"]),
      context
    );
  }
  if (output["nextToken"] !== undefined) {
    contents.NextToken = output["nextToken"];
  }
  return contents;
};

const deserializeAws_ec2DescribeInstanceTypesResult = (
  output: any,
  context: __SerdeContext
): DescribeInstanceTypesResult => {
  let contents: any = {
    __type: "DescribeInstanceTypesResult",
    InstanceTypes: undefined,
    NextToken: undefined
  };
  if (output.instanceTypeSet === "") {
    contents.InstanceTypes = [];
  }
  if (
    output["instanceTypeSet"] !== undefined &&
    output["instanceTypeSet"]["item"] !== undefined
  ) {
    contents.InstanceTypes = deserializeAws_ec2InstanceTypeInfoList(
      __getArrayIfSingleItem(output["instanceTypeSet"]["item"]),
      context
    );
  }
  if (output["nextToken"] !== undefined) {
    contents.NextToken = output["nextToken"];
  }
  return contents;
};

const deserializeAws_ec2DescribeInternetGatewaysResult = (
  output: any,
  context: __SerdeContext
): DescribeInternetGatewaysResult => {
  let contents: any = {
    __type: "DescribeInternetGatewaysResult",
    InternetGateways: undefined,
    NextToken: undefined
  };
  if (output.internetGatewaySet === "") {
    contents.InternetGateways = [];
  }
  if (
    output["internetGatewaySet"] !== undefined &&
    output["internetGatewaySet"]["item"] !== undefined
  ) {
    contents.InternetGateways = deserializeAws_ec2InternetGatewayList(
      __getArrayIfSingleItem(output["internetGatewaySet"]["item"]),
      context
    );
  }
  if (output["nextToken"] !== undefined) {
    contents.NextToken = output["nextToken"];
  }
  return contents;
};

const deserializeAws_ec2DescribeIpv6PoolsResult = (
  output: any,
  context: __SerdeContext
): DescribeIpv6PoolsResult => {
  let contents: any = {
    __type: "DescribeIpv6PoolsResult",
    Ipv6Pools: undefined,
    NextToken: undefined
  };
  if (output.ipv6PoolSet === "") {
    contents.Ipv6Pools = [];
  }
  if (
    output["ipv6PoolSet"] !== undefined &&
    output["ipv6PoolSet"]["item"] !== undefined
  ) {
    contents.Ipv6Pools = deserializeAws_ec2Ipv6PoolSet(
      __getArrayIfSingleItem(output["ipv6PoolSet"]["item"]),
      context
    );
  }
  if (output["nextToken"] !== undefined) {
    contents.NextToken = output["nextToken"];
  }
  return contents;
};

const deserializeAws_ec2DescribeKeyPairsResult = (
  output: any,
  context: __SerdeContext
): DescribeKeyPairsResult => {
  let contents: any = {
    __type: "DescribeKeyPairsResult",
    KeyPairs: undefined
  };
  if (output.keySet === "") {
    contents.KeyPairs = [];
  }
  if (
    output["keySet"] !== undefined &&
    output["keySet"]["item"] !== undefined
  ) {
    contents.KeyPairs = deserializeAws_ec2KeyPairList(
      __getArrayIfSingleItem(output["keySet"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2DescribeLaunchTemplatesResult = (
  output: any,
  context: __SerdeContext
): DescribeLaunchTemplatesResult => {
  let contents: any = {
    __type: "DescribeLaunchTemplatesResult",
    LaunchTemplates: undefined,
    NextToken: undefined
  };
  if (output.launchTemplates === "") {
    contents.LaunchTemplates = [];
  }
  if (
    output["launchTemplates"] !== undefined &&
    output["launchTemplates"]["item"] !== undefined
  ) {
    contents.LaunchTemplates = deserializeAws_ec2LaunchTemplateSet(
      __getArrayIfSingleItem(output["launchTemplates"]["item"]),
      context
    );
  }
  if (output["nextToken"] !== undefined) {
    contents.NextToken = output["nextToken"];
  }
  return contents;
};

const deserializeAws_ec2DescribeLaunchTemplateVersionsResult = (
  output: any,
  context: __SerdeContext
): DescribeLaunchTemplateVersionsResult => {
  let contents: any = {
    __type: "DescribeLaunchTemplateVersionsResult",
    LaunchTemplateVersions: undefined,
    NextToken: undefined
  };
  if (output.launchTemplateVersionSet === "") {
    contents.LaunchTemplateVersions = [];
  }
  if (
    output["launchTemplateVersionSet"] !== undefined &&
    output["launchTemplateVersionSet"]["item"] !== undefined
  ) {
    contents.LaunchTemplateVersions = deserializeAws_ec2LaunchTemplateVersionSet(
      __getArrayIfSingleItem(output["launchTemplateVersionSet"]["item"]),
      context
    );
  }
  if (output["nextToken"] !== undefined) {
    contents.NextToken = output["nextToken"];
  }
  return contents;
};

const deserializeAws_ec2DescribeLocalGatewayRouteTablesResult = (
  output: any,
  context: __SerdeContext
): DescribeLocalGatewayRouteTablesResult => {
  let contents: any = {
    __type: "DescribeLocalGatewayRouteTablesResult",
    LocalGatewayRouteTables: undefined,
    NextToken: undefined
  };
  if (output.localGatewayRouteTableSet === "") {
    contents.LocalGatewayRouteTables = [];
  }
  if (
    output["localGatewayRouteTableSet"] !== undefined &&
    output["localGatewayRouteTableSet"]["item"] !== undefined
  ) {
    contents.LocalGatewayRouteTables = deserializeAws_ec2LocalGatewayRouteTableSet(
      __getArrayIfSingleItem(output["localGatewayRouteTableSet"]["item"]),
      context
    );
  }
  if (output["nextToken"] !== undefined) {
    contents.NextToken = output["nextToken"];
  }
  return contents;
};

const deserializeAws_ec2DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsResult = (
  output: any,
  context: __SerdeContext
): DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsResult => {
  let contents: any = {
    __type:
      "DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsResult",
    LocalGatewayRouteTableVirtualInterfaceGroupAssociations: undefined,
    NextToken: undefined
  };
  if (output.localGatewayRouteTableVirtualInterfaceGroupAssociationSet === "") {
    contents.LocalGatewayRouteTableVirtualInterfaceGroupAssociations = [];
  }
  if (
    output["localGatewayRouteTableVirtualInterfaceGroupAssociationSet"] !==
      undefined &&
    output["localGatewayRouteTableVirtualInterfaceGroupAssociationSet"][
      "item"
    ] !== undefined
  ) {
    contents.LocalGatewayRouteTableVirtualInterfaceGroupAssociations = deserializeAws_ec2LocalGatewayRouteTableVirtualInterfaceGroupAssociationSet(
      __getArrayIfSingleItem(
        output["localGatewayRouteTableVirtualInterfaceGroupAssociationSet"][
          "item"
        ]
      ),
      context
    );
  }
  if (output["nextToken"] !== undefined) {
    contents.NextToken = output["nextToken"];
  }
  return contents;
};

const deserializeAws_ec2DescribeLocalGatewayRouteTableVpcAssociationsResult = (
  output: any,
  context: __SerdeContext
): DescribeLocalGatewayRouteTableVpcAssociationsResult => {
  let contents: any = {
    __type: "DescribeLocalGatewayRouteTableVpcAssociationsResult",
    LocalGatewayRouteTableVpcAssociations: undefined,
    NextToken: undefined
  };
  if (output.localGatewayRouteTableVpcAssociationSet === "") {
    contents.LocalGatewayRouteTableVpcAssociations = [];
  }
  if (
    output["localGatewayRouteTableVpcAssociationSet"] !== undefined &&
    output["localGatewayRouteTableVpcAssociationSet"]["item"] !== undefined
  ) {
    contents.LocalGatewayRouteTableVpcAssociations = deserializeAws_ec2LocalGatewayRouteTableVpcAssociationSet(
      __getArrayIfSingleItem(
        output["localGatewayRouteTableVpcAssociationSet"]["item"]
      ),
      context
    );
  }
  if (output["nextToken"] !== undefined) {
    contents.NextToken = output["nextToken"];
  }
  return contents;
};

const deserializeAws_ec2DescribeLocalGatewaysResult = (
  output: any,
  context: __SerdeContext
): DescribeLocalGatewaysResult => {
  let contents: any = {
    __type: "DescribeLocalGatewaysResult",
    LocalGateways: undefined,
    NextToken: undefined
  };
  if (output.localGatewaySet === "") {
    contents.LocalGateways = [];
  }
  if (
    output["localGatewaySet"] !== undefined &&
    output["localGatewaySet"]["item"] !== undefined
  ) {
    contents.LocalGateways = deserializeAws_ec2LocalGatewaySet(
      __getArrayIfSingleItem(output["localGatewaySet"]["item"]),
      context
    );
  }
  if (output["nextToken"] !== undefined) {
    contents.NextToken = output["nextToken"];
  }
  return contents;
};

const deserializeAws_ec2DescribeLocalGatewayVirtualInterfaceGroupsResult = (
  output: any,
  context: __SerdeContext
): DescribeLocalGatewayVirtualInterfaceGroupsResult => {
  let contents: any = {
    __type: "DescribeLocalGatewayVirtualInterfaceGroupsResult",
    LocalGatewayVirtualInterfaceGroups: undefined,
    NextToken: undefined
  };
  if (output.localGatewayVirtualInterfaceGroupSet === "") {
    contents.LocalGatewayVirtualInterfaceGroups = [];
  }
  if (
    output["localGatewayVirtualInterfaceGroupSet"] !== undefined &&
    output["localGatewayVirtualInterfaceGroupSet"]["item"] !== undefined
  ) {
    contents.LocalGatewayVirtualInterfaceGroups = deserializeAws_ec2LocalGatewayVirtualInterfaceGroupSet(
      __getArrayIfSingleItem(
        output["localGatewayVirtualInterfaceGroupSet"]["item"]
      ),
      context
    );
  }
  if (output["nextToken"] !== undefined) {
    contents.NextToken = output["nextToken"];
  }
  return contents;
};

const deserializeAws_ec2DescribeLocalGatewayVirtualInterfacesResult = (
  output: any,
  context: __SerdeContext
): DescribeLocalGatewayVirtualInterfacesResult => {
  let contents: any = {
    __type: "DescribeLocalGatewayVirtualInterfacesResult",
    LocalGatewayVirtualInterfaces: undefined,
    NextToken: undefined
  };
  if (output.localGatewayVirtualInterfaceSet === "") {
    contents.LocalGatewayVirtualInterfaces = [];
  }
  if (
    output["localGatewayVirtualInterfaceSet"] !== undefined &&
    output["localGatewayVirtualInterfaceSet"]["item"] !== undefined
  ) {
    contents.LocalGatewayVirtualInterfaces = deserializeAws_ec2LocalGatewayVirtualInterfaceSet(
      __getArrayIfSingleItem(output["localGatewayVirtualInterfaceSet"]["item"]),
      context
    );
  }
  if (output["nextToken"] !== undefined) {
    contents.NextToken = output["nextToken"];
  }
  return contents;
};

const deserializeAws_ec2DescribeMovingAddressesResult = (
  output: any,
  context: __SerdeContext
): DescribeMovingAddressesResult => {
  let contents: any = {
    __type: "DescribeMovingAddressesResult",
    MovingAddressStatuses: undefined,
    NextToken: undefined
  };
  if (output.movingAddressStatusSet === "") {
    contents.MovingAddressStatuses = [];
  }
  if (
    output["movingAddressStatusSet"] !== undefined &&
    output["movingAddressStatusSet"]["item"] !== undefined
  ) {
    contents.MovingAddressStatuses = deserializeAws_ec2MovingAddressStatusSet(
      __getArrayIfSingleItem(output["movingAddressStatusSet"]["item"]),
      context
    );
  }
  if (output["nextToken"] !== undefined) {
    contents.NextToken = output["nextToken"];
  }
  return contents;
};

const deserializeAws_ec2DescribeNatGatewaysResult = (
  output: any,
  context: __SerdeContext
): DescribeNatGatewaysResult => {
  let contents: any = {
    __type: "DescribeNatGatewaysResult",
    NatGateways: undefined,
    NextToken: undefined
  };
  if (output.natGatewaySet === "") {
    contents.NatGateways = [];
  }
  if (
    output["natGatewaySet"] !== undefined &&
    output["natGatewaySet"]["item"] !== undefined
  ) {
    contents.NatGateways = deserializeAws_ec2NatGatewayList(
      __getArrayIfSingleItem(output["natGatewaySet"]["item"]),
      context
    );
  }
  if (output["nextToken"] !== undefined) {
    contents.NextToken = output["nextToken"];
  }
  return contents;
};

const deserializeAws_ec2DescribeNetworkAclsResult = (
  output: any,
  context: __SerdeContext
): DescribeNetworkAclsResult => {
  let contents: any = {
    __type: "DescribeNetworkAclsResult",
    NetworkAcls: undefined,
    NextToken: undefined
  };
  if (output.networkAclSet === "") {
    contents.NetworkAcls = [];
  }
  if (
    output["networkAclSet"] !== undefined &&
    output["networkAclSet"]["item"] !== undefined
  ) {
    contents.NetworkAcls = deserializeAws_ec2NetworkAclList(
      __getArrayIfSingleItem(output["networkAclSet"]["item"]),
      context
    );
  }
  if (output["nextToken"] !== undefined) {
    contents.NextToken = output["nextToken"];
  }
  return contents;
};

const deserializeAws_ec2DescribeNetworkInterfaceAttributeResult = (
  output: any,
  context: __SerdeContext
): DescribeNetworkInterfaceAttributeResult => {
  let contents: any = {
    __type: "DescribeNetworkInterfaceAttributeResult",
    Attachment: undefined,
    Description: undefined,
    Groups: undefined,
    NetworkInterfaceId: undefined,
    SourceDestCheck: undefined
  };
  if (output["attachment"] !== undefined) {
    contents.Attachment = deserializeAws_ec2NetworkInterfaceAttachment(
      output["attachment"],
      context
    );
  }
  if (output["description"] !== undefined) {
    contents.Description = deserializeAws_ec2AttributeValue(
      output["description"],
      context
    );
  }
  if (output.groupSet === "") {
    contents.Groups = [];
  }
  if (
    output["groupSet"] !== undefined &&
    output["groupSet"]["item"] !== undefined
  ) {
    contents.Groups = deserializeAws_ec2GroupIdentifierList(
      __getArrayIfSingleItem(output["groupSet"]["item"]),
      context
    );
  }
  if (output["networkInterfaceId"] !== undefined) {
    contents.NetworkInterfaceId = output["networkInterfaceId"];
  }
  if (output["sourceDestCheck"] !== undefined) {
    contents.SourceDestCheck = deserializeAws_ec2AttributeBooleanValue(
      output["sourceDestCheck"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2DescribeNetworkInterfacePermissionsResult = (
  output: any,
  context: __SerdeContext
): DescribeNetworkInterfacePermissionsResult => {
  let contents: any = {
    __type: "DescribeNetworkInterfacePermissionsResult",
    NetworkInterfacePermissions: undefined,
    NextToken: undefined
  };
  if (output.networkInterfacePermissions === "") {
    contents.NetworkInterfacePermissions = [];
  }
  if (
    output["networkInterfacePermissions"] !== undefined &&
    output["networkInterfacePermissions"]["item"] !== undefined
  ) {
    contents.NetworkInterfacePermissions = deserializeAws_ec2NetworkInterfacePermissionList(
      __getArrayIfSingleItem(output["networkInterfacePermissions"]["item"]),
      context
    );
  }
  if (output["nextToken"] !== undefined) {
    contents.NextToken = output["nextToken"];
  }
  return contents;
};

const deserializeAws_ec2DescribeNetworkInterfacesResult = (
  output: any,
  context: __SerdeContext
): DescribeNetworkInterfacesResult => {
  let contents: any = {
    __type: "DescribeNetworkInterfacesResult",
    NetworkInterfaces: undefined,
    NextToken: undefined
  };
  if (output.networkInterfaceSet === "") {
    contents.NetworkInterfaces = [];
  }
  if (
    output["networkInterfaceSet"] !== undefined &&
    output["networkInterfaceSet"]["item"] !== undefined
  ) {
    contents.NetworkInterfaces = deserializeAws_ec2NetworkInterfaceList(
      __getArrayIfSingleItem(output["networkInterfaceSet"]["item"]),
      context
    );
  }
  if (output["nextToken"] !== undefined) {
    contents.NextToken = output["nextToken"];
  }
  return contents;
};

const deserializeAws_ec2DescribePlacementGroupsResult = (
  output: any,
  context: __SerdeContext
): DescribePlacementGroupsResult => {
  let contents: any = {
    __type: "DescribePlacementGroupsResult",
    PlacementGroups: undefined
  };
  if (output.placementGroupSet === "") {
    contents.PlacementGroups = [];
  }
  if (
    output["placementGroupSet"] !== undefined &&
    output["placementGroupSet"]["item"] !== undefined
  ) {
    contents.PlacementGroups = deserializeAws_ec2PlacementGroupList(
      __getArrayIfSingleItem(output["placementGroupSet"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2DescribePrefixListsResult = (
  output: any,
  context: __SerdeContext
): DescribePrefixListsResult => {
  let contents: any = {
    __type: "DescribePrefixListsResult",
    NextToken: undefined,
    PrefixLists: undefined
  };
  if (output["nextToken"] !== undefined) {
    contents.NextToken = output["nextToken"];
  }
  if (output.prefixListSet === "") {
    contents.PrefixLists = [];
  }
  if (
    output["prefixListSet"] !== undefined &&
    output["prefixListSet"]["item"] !== undefined
  ) {
    contents.PrefixLists = deserializeAws_ec2PrefixListSet(
      __getArrayIfSingleItem(output["prefixListSet"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2DescribePrincipalIdFormatResult = (
  output: any,
  context: __SerdeContext
): DescribePrincipalIdFormatResult => {
  let contents: any = {
    __type: "DescribePrincipalIdFormatResult",
    NextToken: undefined,
    Principals: undefined
  };
  if (output["nextToken"] !== undefined) {
    contents.NextToken = output["nextToken"];
  }
  if (output.principalSet === "") {
    contents.Principals = [];
  }
  if (
    output["principalSet"] !== undefined &&
    output["principalSet"]["item"] !== undefined
  ) {
    contents.Principals = deserializeAws_ec2PrincipalIdFormatList(
      __getArrayIfSingleItem(output["principalSet"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2DescribePublicIpv4PoolsResult = (
  output: any,
  context: __SerdeContext
): DescribePublicIpv4PoolsResult => {
  let contents: any = {
    __type: "DescribePublicIpv4PoolsResult",
    NextToken: undefined,
    PublicIpv4Pools: undefined
  };
  if (output["nextToken"] !== undefined) {
    contents.NextToken = output["nextToken"];
  }
  if (output.publicIpv4PoolSet === "") {
    contents.PublicIpv4Pools = [];
  }
  if (
    output["publicIpv4PoolSet"] !== undefined &&
    output["publicIpv4PoolSet"]["item"] !== undefined
  ) {
    contents.PublicIpv4Pools = deserializeAws_ec2PublicIpv4PoolSet(
      __getArrayIfSingleItem(output["publicIpv4PoolSet"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2DescribeRegionsResult = (
  output: any,
  context: __SerdeContext
): DescribeRegionsResult => {
  let contents: any = {
    __type: "DescribeRegionsResult",
    Regions: undefined
  };
  if (output.regionInfo === "") {
    contents.Regions = [];
  }
  if (
    output["regionInfo"] !== undefined &&
    output["regionInfo"]["item"] !== undefined
  ) {
    contents.Regions = deserializeAws_ec2RegionList(
      __getArrayIfSingleItem(output["regionInfo"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2DescribeReservedInstancesListingsResult = (
  output: any,
  context: __SerdeContext
): DescribeReservedInstancesListingsResult => {
  let contents: any = {
    __type: "DescribeReservedInstancesListingsResult",
    ReservedInstancesListings: undefined
  };
  if (output.reservedInstancesListingsSet === "") {
    contents.ReservedInstancesListings = [];
  }
  if (
    output["reservedInstancesListingsSet"] !== undefined &&
    output["reservedInstancesListingsSet"]["item"] !== undefined
  ) {
    contents.ReservedInstancesListings = deserializeAws_ec2ReservedInstancesListingList(
      __getArrayIfSingleItem(output["reservedInstancesListingsSet"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2DescribeReservedInstancesModificationsResult = (
  output: any,
  context: __SerdeContext
): DescribeReservedInstancesModificationsResult => {
  let contents: any = {
    __type: "DescribeReservedInstancesModificationsResult",
    NextToken: undefined,
    ReservedInstancesModifications: undefined
  };
  if (output["nextToken"] !== undefined) {
    contents.NextToken = output["nextToken"];
  }
  if (output.reservedInstancesModificationsSet === "") {
    contents.ReservedInstancesModifications = [];
  }
  if (
    output["reservedInstancesModificationsSet"] !== undefined &&
    output["reservedInstancesModificationsSet"]["item"] !== undefined
  ) {
    contents.ReservedInstancesModifications = deserializeAws_ec2ReservedInstancesModificationList(
      __getArrayIfSingleItem(
        output["reservedInstancesModificationsSet"]["item"]
      ),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2DescribeReservedInstancesOfferingsResult = (
  output: any,
  context: __SerdeContext
): DescribeReservedInstancesOfferingsResult => {
  let contents: any = {
    __type: "DescribeReservedInstancesOfferingsResult",
    NextToken: undefined,
    ReservedInstancesOfferings: undefined
  };
  if (output["nextToken"] !== undefined) {
    contents.NextToken = output["nextToken"];
  }
  if (output.reservedInstancesOfferingsSet === "") {
    contents.ReservedInstancesOfferings = [];
  }
  if (
    output["reservedInstancesOfferingsSet"] !== undefined &&
    output["reservedInstancesOfferingsSet"]["item"] !== undefined
  ) {
    contents.ReservedInstancesOfferings = deserializeAws_ec2ReservedInstancesOfferingList(
      __getArrayIfSingleItem(output["reservedInstancesOfferingsSet"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2DescribeReservedInstancesResult = (
  output: any,
  context: __SerdeContext
): DescribeReservedInstancesResult => {
  let contents: any = {
    __type: "DescribeReservedInstancesResult",
    ReservedInstances: undefined
  };
  if (output.reservedInstancesSet === "") {
    contents.ReservedInstances = [];
  }
  if (
    output["reservedInstancesSet"] !== undefined &&
    output["reservedInstancesSet"]["item"] !== undefined
  ) {
    contents.ReservedInstances = deserializeAws_ec2ReservedInstancesList(
      __getArrayIfSingleItem(output["reservedInstancesSet"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2DescribeRouteTablesResult = (
  output: any,
  context: __SerdeContext
): DescribeRouteTablesResult => {
  let contents: any = {
    __type: "DescribeRouteTablesResult",
    NextToken: undefined,
    RouteTables: undefined
  };
  if (output["nextToken"] !== undefined) {
    contents.NextToken = output["nextToken"];
  }
  if (output.routeTableSet === "") {
    contents.RouteTables = [];
  }
  if (
    output["routeTableSet"] !== undefined &&
    output["routeTableSet"]["item"] !== undefined
  ) {
    contents.RouteTables = deserializeAws_ec2RouteTableList(
      __getArrayIfSingleItem(output["routeTableSet"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2DescribeScheduledInstanceAvailabilityResult = (
  output: any,
  context: __SerdeContext
): DescribeScheduledInstanceAvailabilityResult => {
  let contents: any = {
    __type: "DescribeScheduledInstanceAvailabilityResult",
    NextToken: undefined,
    ScheduledInstanceAvailabilitySet: undefined
  };
  if (output["nextToken"] !== undefined) {
    contents.NextToken = output["nextToken"];
  }
  if (output.scheduledInstanceAvailabilitySet === "") {
    contents.ScheduledInstanceAvailabilitySet = [];
  }
  if (
    output["scheduledInstanceAvailabilitySet"] !== undefined &&
    output["scheduledInstanceAvailabilitySet"]["item"] !== undefined
  ) {
    contents.ScheduledInstanceAvailabilitySet = deserializeAws_ec2ScheduledInstanceAvailabilitySet(
      __getArrayIfSingleItem(
        output["scheduledInstanceAvailabilitySet"]["item"]
      ),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2DescribeScheduledInstancesResult = (
  output: any,
  context: __SerdeContext
): DescribeScheduledInstancesResult => {
  let contents: any = {
    __type: "DescribeScheduledInstancesResult",
    NextToken: undefined,
    ScheduledInstanceSet: undefined
  };
  if (output["nextToken"] !== undefined) {
    contents.NextToken = output["nextToken"];
  }
  if (output.scheduledInstanceSet === "") {
    contents.ScheduledInstanceSet = [];
  }
  if (
    output["scheduledInstanceSet"] !== undefined &&
    output["scheduledInstanceSet"]["item"] !== undefined
  ) {
    contents.ScheduledInstanceSet = deserializeAws_ec2ScheduledInstanceSet(
      __getArrayIfSingleItem(output["scheduledInstanceSet"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2DescribeSecurityGroupReferencesResult = (
  output: any,
  context: __SerdeContext
): DescribeSecurityGroupReferencesResult => {
  let contents: any = {
    __type: "DescribeSecurityGroupReferencesResult",
    SecurityGroupReferenceSet: undefined
  };
  if (output.securityGroupReferenceSet === "") {
    contents.SecurityGroupReferenceSet = [];
  }
  if (
    output["securityGroupReferenceSet"] !== undefined &&
    output["securityGroupReferenceSet"]["item"] !== undefined
  ) {
    contents.SecurityGroupReferenceSet = deserializeAws_ec2SecurityGroupReferences(
      __getArrayIfSingleItem(output["securityGroupReferenceSet"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2DescribeSecurityGroupsResult = (
  output: any,
  context: __SerdeContext
): DescribeSecurityGroupsResult => {
  let contents: any = {
    __type: "DescribeSecurityGroupsResult",
    NextToken: undefined,
    SecurityGroups: undefined
  };
  if (output["nextToken"] !== undefined) {
    contents.NextToken = output["nextToken"];
  }
  if (output.securityGroupInfo === "") {
    contents.SecurityGroups = [];
  }
  if (
    output["securityGroupInfo"] !== undefined &&
    output["securityGroupInfo"]["item"] !== undefined
  ) {
    contents.SecurityGroups = deserializeAws_ec2SecurityGroupList(
      __getArrayIfSingleItem(output["securityGroupInfo"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2DescribeSnapshotAttributeResult = (
  output: any,
  context: __SerdeContext
): DescribeSnapshotAttributeResult => {
  let contents: any = {
    __type: "DescribeSnapshotAttributeResult",
    CreateVolumePermissions: undefined,
    ProductCodes: undefined,
    SnapshotId: undefined
  };
  if (output.createVolumePermission === "") {
    contents.CreateVolumePermissions = [];
  }
  if (
    output["createVolumePermission"] !== undefined &&
    output["createVolumePermission"]["item"] !== undefined
  ) {
    contents.CreateVolumePermissions = deserializeAws_ec2CreateVolumePermissionList(
      __getArrayIfSingleItem(output["createVolumePermission"]["item"]),
      context
    );
  }
  if (output.productCodes === "") {
    contents.ProductCodes = [];
  }
  if (
    output["productCodes"] !== undefined &&
    output["productCodes"]["item"] !== undefined
  ) {
    contents.ProductCodes = deserializeAws_ec2ProductCodeList(
      __getArrayIfSingleItem(output["productCodes"]["item"]),
      context
    );
  }
  if (output["snapshotId"] !== undefined) {
    contents.SnapshotId = output["snapshotId"];
  }
  return contents;
};

const deserializeAws_ec2DescribeSnapshotsResult = (
  output: any,
  context: __SerdeContext
): DescribeSnapshotsResult => {
  let contents: any = {
    __type: "DescribeSnapshotsResult",
    NextToken: undefined,
    Snapshots: undefined
  };
  if (output["nextToken"] !== undefined) {
    contents.NextToken = output["nextToken"];
  }
  if (output.snapshotSet === "") {
    contents.Snapshots = [];
  }
  if (
    output["snapshotSet"] !== undefined &&
    output["snapshotSet"]["item"] !== undefined
  ) {
    contents.Snapshots = deserializeAws_ec2SnapshotList(
      __getArrayIfSingleItem(output["snapshotSet"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2DescribeSpotDatafeedSubscriptionResult = (
  output: any,
  context: __SerdeContext
): DescribeSpotDatafeedSubscriptionResult => {
  let contents: any = {
    __type: "DescribeSpotDatafeedSubscriptionResult",
    SpotDatafeedSubscription: undefined
  };
  if (output["spotDatafeedSubscription"] !== undefined) {
    contents.SpotDatafeedSubscription = deserializeAws_ec2SpotDatafeedSubscription(
      output["spotDatafeedSubscription"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2DescribeSpotFleetInstancesResponse = (
  output: any,
  context: __SerdeContext
): DescribeSpotFleetInstancesResponse => {
  let contents: any = {
    __type: "DescribeSpotFleetInstancesResponse",
    ActiveInstances: undefined,
    NextToken: undefined,
    SpotFleetRequestId: undefined
  };
  if (output.activeInstanceSet === "") {
    contents.ActiveInstances = [];
  }
  if (
    output["activeInstanceSet"] !== undefined &&
    output["activeInstanceSet"]["item"] !== undefined
  ) {
    contents.ActiveInstances = deserializeAws_ec2ActiveInstanceSet(
      __getArrayIfSingleItem(output["activeInstanceSet"]["item"]),
      context
    );
  }
  if (output["nextToken"] !== undefined) {
    contents.NextToken = output["nextToken"];
  }
  if (output["spotFleetRequestId"] !== undefined) {
    contents.SpotFleetRequestId = output["spotFleetRequestId"];
  }
  return contents;
};

const deserializeAws_ec2DescribeSpotFleetRequestHistoryResponse = (
  output: any,
  context: __SerdeContext
): DescribeSpotFleetRequestHistoryResponse => {
  let contents: any = {
    __type: "DescribeSpotFleetRequestHistoryResponse",
    HistoryRecords: undefined,
    LastEvaluatedTime: undefined,
    NextToken: undefined,
    SpotFleetRequestId: undefined,
    StartTime: undefined
  };
  if (output.historyRecordSet === "") {
    contents.HistoryRecords = [];
  }
  if (
    output["historyRecordSet"] !== undefined &&
    output["historyRecordSet"]["item"] !== undefined
  ) {
    contents.HistoryRecords = deserializeAws_ec2HistoryRecords(
      __getArrayIfSingleItem(output["historyRecordSet"]["item"]),
      context
    );
  }
  if (output["lastEvaluatedTime"] !== undefined) {
    contents.LastEvaluatedTime = new Date(output["lastEvaluatedTime"]);
  }
  if (output["nextToken"] !== undefined) {
    contents.NextToken = output["nextToken"];
  }
  if (output["spotFleetRequestId"] !== undefined) {
    contents.SpotFleetRequestId = output["spotFleetRequestId"];
  }
  if (output["startTime"] !== undefined) {
    contents.StartTime = new Date(output["startTime"]);
  }
  return contents;
};

const deserializeAws_ec2DescribeSpotFleetRequestsResponse = (
  output: any,
  context: __SerdeContext
): DescribeSpotFleetRequestsResponse => {
  let contents: any = {
    __type: "DescribeSpotFleetRequestsResponse",
    NextToken: undefined,
    SpotFleetRequestConfigs: undefined
  };
  if (output["nextToken"] !== undefined) {
    contents.NextToken = output["nextToken"];
  }
  if (output.spotFleetRequestConfigSet === "") {
    contents.SpotFleetRequestConfigs = [];
  }
  if (
    output["spotFleetRequestConfigSet"] !== undefined &&
    output["spotFleetRequestConfigSet"]["item"] !== undefined
  ) {
    contents.SpotFleetRequestConfigs = deserializeAws_ec2SpotFleetRequestConfigSet(
      __getArrayIfSingleItem(output["spotFleetRequestConfigSet"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2DescribeSpotInstanceRequestsResult = (
  output: any,
  context: __SerdeContext
): DescribeSpotInstanceRequestsResult => {
  let contents: any = {
    __type: "DescribeSpotInstanceRequestsResult",
    NextToken: undefined,
    SpotInstanceRequests: undefined
  };
  if (output["nextToken"] !== undefined) {
    contents.NextToken = output["nextToken"];
  }
  if (output.spotInstanceRequestSet === "") {
    contents.SpotInstanceRequests = [];
  }
  if (
    output["spotInstanceRequestSet"] !== undefined &&
    output["spotInstanceRequestSet"]["item"] !== undefined
  ) {
    contents.SpotInstanceRequests = deserializeAws_ec2SpotInstanceRequestList(
      __getArrayIfSingleItem(output["spotInstanceRequestSet"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2DescribeSpotPriceHistoryResult = (
  output: any,
  context: __SerdeContext
): DescribeSpotPriceHistoryResult => {
  let contents: any = {
    __type: "DescribeSpotPriceHistoryResult",
    NextToken: undefined,
    SpotPriceHistory: undefined
  };
  if (output["nextToken"] !== undefined) {
    contents.NextToken = output["nextToken"];
  }
  if (output.spotPriceHistorySet === "") {
    contents.SpotPriceHistory = [];
  }
  if (
    output["spotPriceHistorySet"] !== undefined &&
    output["spotPriceHistorySet"]["item"] !== undefined
  ) {
    contents.SpotPriceHistory = deserializeAws_ec2SpotPriceHistoryList(
      __getArrayIfSingleItem(output["spotPriceHistorySet"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2DescribeStaleSecurityGroupsResult = (
  output: any,
  context: __SerdeContext
): DescribeStaleSecurityGroupsResult => {
  let contents: any = {
    __type: "DescribeStaleSecurityGroupsResult",
    NextToken: undefined,
    StaleSecurityGroupSet: undefined
  };
  if (output["nextToken"] !== undefined) {
    contents.NextToken = output["nextToken"];
  }
  if (output.staleSecurityGroupSet === "") {
    contents.StaleSecurityGroupSet = [];
  }
  if (
    output["staleSecurityGroupSet"] !== undefined &&
    output["staleSecurityGroupSet"]["item"] !== undefined
  ) {
    contents.StaleSecurityGroupSet = deserializeAws_ec2StaleSecurityGroupSet(
      __getArrayIfSingleItem(output["staleSecurityGroupSet"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2DescribeSubnetsResult = (
  output: any,
  context: __SerdeContext
): DescribeSubnetsResult => {
  let contents: any = {
    __type: "DescribeSubnetsResult",
    NextToken: undefined,
    Subnets: undefined
  };
  if (output["nextToken"] !== undefined) {
    contents.NextToken = output["nextToken"];
  }
  if (output.subnetSet === "") {
    contents.Subnets = [];
  }
  if (
    output["subnetSet"] !== undefined &&
    output["subnetSet"]["item"] !== undefined
  ) {
    contents.Subnets = deserializeAws_ec2SubnetList(
      __getArrayIfSingleItem(output["subnetSet"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2DescribeTagsResult = (
  output: any,
  context: __SerdeContext
): DescribeTagsResult => {
  let contents: any = {
    __type: "DescribeTagsResult",
    NextToken: undefined,
    Tags: undefined
  };
  if (output["nextToken"] !== undefined) {
    contents.NextToken = output["nextToken"];
  }
  if (output.tagSet === "") {
    contents.Tags = [];
  }
  if (
    output["tagSet"] !== undefined &&
    output["tagSet"]["item"] !== undefined
  ) {
    contents.Tags = deserializeAws_ec2TagDescriptionList(
      __getArrayIfSingleItem(output["tagSet"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2DescribeTrafficMirrorFiltersResult = (
  output: any,
  context: __SerdeContext
): DescribeTrafficMirrorFiltersResult => {
  let contents: any = {
    __type: "DescribeTrafficMirrorFiltersResult",
    NextToken: undefined,
    TrafficMirrorFilters: undefined
  };
  if (output["nextToken"] !== undefined) {
    contents.NextToken = output["nextToken"];
  }
  if (output.trafficMirrorFilterSet === "") {
    contents.TrafficMirrorFilters = [];
  }
  if (
    output["trafficMirrorFilterSet"] !== undefined &&
    output["trafficMirrorFilterSet"]["item"] !== undefined
  ) {
    contents.TrafficMirrorFilters = deserializeAws_ec2TrafficMirrorFilterSet(
      __getArrayIfSingleItem(output["trafficMirrorFilterSet"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2DescribeTrafficMirrorSessionsResult = (
  output: any,
  context: __SerdeContext
): DescribeTrafficMirrorSessionsResult => {
  let contents: any = {
    __type: "DescribeTrafficMirrorSessionsResult",
    NextToken: undefined,
    TrafficMirrorSessions: undefined
  };
  if (output["nextToken"] !== undefined) {
    contents.NextToken = output["nextToken"];
  }
  if (output.trafficMirrorSessionSet === "") {
    contents.TrafficMirrorSessions = [];
  }
  if (
    output["trafficMirrorSessionSet"] !== undefined &&
    output["trafficMirrorSessionSet"]["item"] !== undefined
  ) {
    contents.TrafficMirrorSessions = deserializeAws_ec2TrafficMirrorSessionSet(
      __getArrayIfSingleItem(output["trafficMirrorSessionSet"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2DescribeTrafficMirrorTargetsResult = (
  output: any,
  context: __SerdeContext
): DescribeTrafficMirrorTargetsResult => {
  let contents: any = {
    __type: "DescribeTrafficMirrorTargetsResult",
    NextToken: undefined,
    TrafficMirrorTargets: undefined
  };
  if (output["nextToken"] !== undefined) {
    contents.NextToken = output["nextToken"];
  }
  if (output.trafficMirrorTargetSet === "") {
    contents.TrafficMirrorTargets = [];
  }
  if (
    output["trafficMirrorTargetSet"] !== undefined &&
    output["trafficMirrorTargetSet"]["item"] !== undefined
  ) {
    contents.TrafficMirrorTargets = deserializeAws_ec2TrafficMirrorTargetSet(
      __getArrayIfSingleItem(output["trafficMirrorTargetSet"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2DescribeTransitGatewayAttachmentsResult = (
  output: any,
  context: __SerdeContext
): DescribeTransitGatewayAttachmentsResult => {
  let contents: any = {
    __type: "DescribeTransitGatewayAttachmentsResult",
    NextToken: undefined,
    TransitGatewayAttachments: undefined
  };
  if (output["nextToken"] !== undefined) {
    contents.NextToken = output["nextToken"];
  }
  if (output.transitGatewayAttachments === "") {
    contents.TransitGatewayAttachments = [];
  }
  if (
    output["transitGatewayAttachments"] !== undefined &&
    output["transitGatewayAttachments"]["item"] !== undefined
  ) {
    contents.TransitGatewayAttachments = deserializeAws_ec2TransitGatewayAttachmentList(
      __getArrayIfSingleItem(output["transitGatewayAttachments"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2DescribeTransitGatewayMulticastDomainsResult = (
  output: any,
  context: __SerdeContext
): DescribeTransitGatewayMulticastDomainsResult => {
  let contents: any = {
    __type: "DescribeTransitGatewayMulticastDomainsResult",
    NextToken: undefined,
    TransitGatewayMulticastDomains: undefined
  };
  if (output["nextToken"] !== undefined) {
    contents.NextToken = output["nextToken"];
  }
  if (output.transitGatewayMulticastDomains === "") {
    contents.TransitGatewayMulticastDomains = [];
  }
  if (
    output["transitGatewayMulticastDomains"] !== undefined &&
    output["transitGatewayMulticastDomains"]["item"] !== undefined
  ) {
    contents.TransitGatewayMulticastDomains = deserializeAws_ec2TransitGatewayMulticastDomainList(
      __getArrayIfSingleItem(output["transitGatewayMulticastDomains"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2DescribeTransitGatewayPeeringAttachmentsResult = (
  output: any,
  context: __SerdeContext
): DescribeTransitGatewayPeeringAttachmentsResult => {
  let contents: any = {
    __type: "DescribeTransitGatewayPeeringAttachmentsResult",
    NextToken: undefined,
    TransitGatewayPeeringAttachments: undefined
  };
  if (output["nextToken"] !== undefined) {
    contents.NextToken = output["nextToken"];
  }
  if (output.transitGatewayPeeringAttachments === "") {
    contents.TransitGatewayPeeringAttachments = [];
  }
  if (
    output["transitGatewayPeeringAttachments"] !== undefined &&
    output["transitGatewayPeeringAttachments"]["item"] !== undefined
  ) {
    contents.TransitGatewayPeeringAttachments = deserializeAws_ec2TransitGatewayPeeringAttachmentList(
      __getArrayIfSingleItem(
        output["transitGatewayPeeringAttachments"]["item"]
      ),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2DescribeTransitGatewayRouteTablesResult = (
  output: any,
  context: __SerdeContext
): DescribeTransitGatewayRouteTablesResult => {
  let contents: any = {
    __type: "DescribeTransitGatewayRouteTablesResult",
    NextToken: undefined,
    TransitGatewayRouteTables: undefined
  };
  if (output["nextToken"] !== undefined) {
    contents.NextToken = output["nextToken"];
  }
  if (output.transitGatewayRouteTables === "") {
    contents.TransitGatewayRouteTables = [];
  }
  if (
    output["transitGatewayRouteTables"] !== undefined &&
    output["transitGatewayRouteTables"]["item"] !== undefined
  ) {
    contents.TransitGatewayRouteTables = deserializeAws_ec2TransitGatewayRouteTableList(
      __getArrayIfSingleItem(output["transitGatewayRouteTables"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2DescribeTransitGatewaysResult = (
  output: any,
  context: __SerdeContext
): DescribeTransitGatewaysResult => {
  let contents: any = {
    __type: "DescribeTransitGatewaysResult",
    NextToken: undefined,
    TransitGateways: undefined
  };
  if (output["nextToken"] !== undefined) {
    contents.NextToken = output["nextToken"];
  }
  if (output.transitGatewaySet === "") {
    contents.TransitGateways = [];
  }
  if (
    output["transitGatewaySet"] !== undefined &&
    output["transitGatewaySet"]["item"] !== undefined
  ) {
    contents.TransitGateways = deserializeAws_ec2TransitGatewayList(
      __getArrayIfSingleItem(output["transitGatewaySet"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2DescribeTransitGatewayVpcAttachmentsResult = (
  output: any,
  context: __SerdeContext
): DescribeTransitGatewayVpcAttachmentsResult => {
  let contents: any = {
    __type: "DescribeTransitGatewayVpcAttachmentsResult",
    NextToken: undefined,
    TransitGatewayVpcAttachments: undefined
  };
  if (output["nextToken"] !== undefined) {
    contents.NextToken = output["nextToken"];
  }
  if (output.transitGatewayVpcAttachments === "") {
    contents.TransitGatewayVpcAttachments = [];
  }
  if (
    output["transitGatewayVpcAttachments"] !== undefined &&
    output["transitGatewayVpcAttachments"]["item"] !== undefined
  ) {
    contents.TransitGatewayVpcAttachments = deserializeAws_ec2TransitGatewayVpcAttachmentList(
      __getArrayIfSingleItem(output["transitGatewayVpcAttachments"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2DescribeVolumeAttributeResult = (
  output: any,
  context: __SerdeContext
): DescribeVolumeAttributeResult => {
  let contents: any = {
    __type: "DescribeVolumeAttributeResult",
    AutoEnableIO: undefined,
    ProductCodes: undefined,
    VolumeId: undefined
  };
  if (output["autoEnableIO"] !== undefined) {
    contents.AutoEnableIO = deserializeAws_ec2AttributeBooleanValue(
      output["autoEnableIO"],
      context
    );
  }
  if (output.productCodes === "") {
    contents.ProductCodes = [];
  }
  if (
    output["productCodes"] !== undefined &&
    output["productCodes"]["item"] !== undefined
  ) {
    contents.ProductCodes = deserializeAws_ec2ProductCodeList(
      __getArrayIfSingleItem(output["productCodes"]["item"]),
      context
    );
  }
  if (output["volumeId"] !== undefined) {
    contents.VolumeId = output["volumeId"];
  }
  return contents;
};

const deserializeAws_ec2DescribeVolumesModificationsResult = (
  output: any,
  context: __SerdeContext
): DescribeVolumesModificationsResult => {
  let contents: any = {
    __type: "DescribeVolumesModificationsResult",
    NextToken: undefined,
    VolumesModifications: undefined
  };
  if (output["nextToken"] !== undefined) {
    contents.NextToken = output["nextToken"];
  }
  if (output.volumeModificationSet === "") {
    contents.VolumesModifications = [];
  }
  if (
    output["volumeModificationSet"] !== undefined &&
    output["volumeModificationSet"]["item"] !== undefined
  ) {
    contents.VolumesModifications = deserializeAws_ec2VolumeModificationList(
      __getArrayIfSingleItem(output["volumeModificationSet"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2DescribeVolumesResult = (
  output: any,
  context: __SerdeContext
): DescribeVolumesResult => {
  let contents: any = {
    __type: "DescribeVolumesResult",
    NextToken: undefined,
    Volumes: undefined
  };
  if (output["nextToken"] !== undefined) {
    contents.NextToken = output["nextToken"];
  }
  if (output.volumeSet === "") {
    contents.Volumes = [];
  }
  if (
    output["volumeSet"] !== undefined &&
    output["volumeSet"]["item"] !== undefined
  ) {
    contents.Volumes = deserializeAws_ec2VolumeList(
      __getArrayIfSingleItem(output["volumeSet"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2DescribeVolumeStatusResult = (
  output: any,
  context: __SerdeContext
): DescribeVolumeStatusResult => {
  let contents: any = {
    __type: "DescribeVolumeStatusResult",
    NextToken: undefined,
    VolumeStatuses: undefined
  };
  if (output["nextToken"] !== undefined) {
    contents.NextToken = output["nextToken"];
  }
  if (output.volumeStatusSet === "") {
    contents.VolumeStatuses = [];
  }
  if (
    output["volumeStatusSet"] !== undefined &&
    output["volumeStatusSet"]["item"] !== undefined
  ) {
    contents.VolumeStatuses = deserializeAws_ec2VolumeStatusList(
      __getArrayIfSingleItem(output["volumeStatusSet"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2DescribeVpcAttributeResult = (
  output: any,
  context: __SerdeContext
): DescribeVpcAttributeResult => {
  let contents: any = {
    __type: "DescribeVpcAttributeResult",
    EnableDnsHostnames: undefined,
    EnableDnsSupport: undefined,
    VpcId: undefined
  };
  if (output["enableDnsHostnames"] !== undefined) {
    contents.EnableDnsHostnames = deserializeAws_ec2AttributeBooleanValue(
      output["enableDnsHostnames"],
      context
    );
  }
  if (output["enableDnsSupport"] !== undefined) {
    contents.EnableDnsSupport = deserializeAws_ec2AttributeBooleanValue(
      output["enableDnsSupport"],
      context
    );
  }
  if (output["vpcId"] !== undefined) {
    contents.VpcId = output["vpcId"];
  }
  return contents;
};

const deserializeAws_ec2DescribeVpcClassicLinkDnsSupportResult = (
  output: any,
  context: __SerdeContext
): DescribeVpcClassicLinkDnsSupportResult => {
  let contents: any = {
    __type: "DescribeVpcClassicLinkDnsSupportResult",
    NextToken: undefined,
    Vpcs: undefined
  };
  if (output["nextToken"] !== undefined) {
    contents.NextToken = output["nextToken"];
  }
  if (output.vpcs === "") {
    contents.Vpcs = [];
  }
  if (output["vpcs"] !== undefined && output["vpcs"]["item"] !== undefined) {
    contents.Vpcs = deserializeAws_ec2ClassicLinkDnsSupportList(
      __getArrayIfSingleItem(output["vpcs"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2DescribeVpcClassicLinkResult = (
  output: any,
  context: __SerdeContext
): DescribeVpcClassicLinkResult => {
  let contents: any = {
    __type: "DescribeVpcClassicLinkResult",
    Vpcs: undefined
  };
  if (output.vpcSet === "") {
    contents.Vpcs = [];
  }
  if (
    output["vpcSet"] !== undefined &&
    output["vpcSet"]["item"] !== undefined
  ) {
    contents.Vpcs = deserializeAws_ec2VpcClassicLinkList(
      __getArrayIfSingleItem(output["vpcSet"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2DescribeVpcEndpointConnectionNotificationsResult = (
  output: any,
  context: __SerdeContext
): DescribeVpcEndpointConnectionNotificationsResult => {
  let contents: any = {
    __type: "DescribeVpcEndpointConnectionNotificationsResult",
    ConnectionNotificationSet: undefined,
    NextToken: undefined
  };
  if (output.connectionNotificationSet === "") {
    contents.ConnectionNotificationSet = [];
  }
  if (
    output["connectionNotificationSet"] !== undefined &&
    output["connectionNotificationSet"]["item"] !== undefined
  ) {
    contents.ConnectionNotificationSet = deserializeAws_ec2ConnectionNotificationSet(
      __getArrayIfSingleItem(output["connectionNotificationSet"]["item"]),
      context
    );
  }
  if (output["nextToken"] !== undefined) {
    contents.NextToken = output["nextToken"];
  }
  return contents;
};

const deserializeAws_ec2DescribeVpcEndpointConnectionsResult = (
  output: any,
  context: __SerdeContext
): DescribeVpcEndpointConnectionsResult => {
  let contents: any = {
    __type: "DescribeVpcEndpointConnectionsResult",
    NextToken: undefined,
    VpcEndpointConnections: undefined
  };
  if (output["nextToken"] !== undefined) {
    contents.NextToken = output["nextToken"];
  }
  if (output.vpcEndpointConnectionSet === "") {
    contents.VpcEndpointConnections = [];
  }
  if (
    output["vpcEndpointConnectionSet"] !== undefined &&
    output["vpcEndpointConnectionSet"]["item"] !== undefined
  ) {
    contents.VpcEndpointConnections = deserializeAws_ec2VpcEndpointConnectionSet(
      __getArrayIfSingleItem(output["vpcEndpointConnectionSet"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2DescribeVpcEndpointServiceConfigurationsResult = (
  output: any,
  context: __SerdeContext
): DescribeVpcEndpointServiceConfigurationsResult => {
  let contents: any = {
    __type: "DescribeVpcEndpointServiceConfigurationsResult",
    NextToken: undefined,
    ServiceConfigurations: undefined
  };
  if (output["nextToken"] !== undefined) {
    contents.NextToken = output["nextToken"];
  }
  if (output.serviceConfigurationSet === "") {
    contents.ServiceConfigurations = [];
  }
  if (
    output["serviceConfigurationSet"] !== undefined &&
    output["serviceConfigurationSet"]["item"] !== undefined
  ) {
    contents.ServiceConfigurations = deserializeAws_ec2ServiceConfigurationSet(
      __getArrayIfSingleItem(output["serviceConfigurationSet"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2DescribeVpcEndpointServicePermissionsResult = (
  output: any,
  context: __SerdeContext
): DescribeVpcEndpointServicePermissionsResult => {
  let contents: any = {
    __type: "DescribeVpcEndpointServicePermissionsResult",
    AllowedPrincipals: undefined,
    NextToken: undefined
  };
  if (output.allowedPrincipals === "") {
    contents.AllowedPrincipals = [];
  }
  if (
    output["allowedPrincipals"] !== undefined &&
    output["allowedPrincipals"]["item"] !== undefined
  ) {
    contents.AllowedPrincipals = deserializeAws_ec2AllowedPrincipalSet(
      __getArrayIfSingleItem(output["allowedPrincipals"]["item"]),
      context
    );
  }
  if (output["nextToken"] !== undefined) {
    contents.NextToken = output["nextToken"];
  }
  return contents;
};

const deserializeAws_ec2DescribeVpcEndpointServicesResult = (
  output: any,
  context: __SerdeContext
): DescribeVpcEndpointServicesResult => {
  let contents: any = {
    __type: "DescribeVpcEndpointServicesResult",
    NextToken: undefined,
    ServiceDetails: undefined,
    ServiceNames: undefined
  };
  if (output["nextToken"] !== undefined) {
    contents.NextToken = output["nextToken"];
  }
  if (output.serviceDetailSet === "") {
    contents.ServiceDetails = [];
  }
  if (
    output["serviceDetailSet"] !== undefined &&
    output["serviceDetailSet"]["item"] !== undefined
  ) {
    contents.ServiceDetails = deserializeAws_ec2ServiceDetailSet(
      __getArrayIfSingleItem(output["serviceDetailSet"]["item"]),
      context
    );
  }
  if (output.serviceNameSet === "") {
    contents.ServiceNames = [];
  }
  if (
    output["serviceNameSet"] !== undefined &&
    output["serviceNameSet"]["item"] !== undefined
  ) {
    contents.ServiceNames = deserializeAws_ec2ValueStringList(
      __getArrayIfSingleItem(output["serviceNameSet"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2DescribeVpcEndpointsResult = (
  output: any,
  context: __SerdeContext
): DescribeVpcEndpointsResult => {
  let contents: any = {
    __type: "DescribeVpcEndpointsResult",
    NextToken: undefined,
    VpcEndpoints: undefined
  };
  if (output["nextToken"] !== undefined) {
    contents.NextToken = output["nextToken"];
  }
  if (output.vpcEndpointSet === "") {
    contents.VpcEndpoints = [];
  }
  if (
    output["vpcEndpointSet"] !== undefined &&
    output["vpcEndpointSet"]["item"] !== undefined
  ) {
    contents.VpcEndpoints = deserializeAws_ec2VpcEndpointSet(
      __getArrayIfSingleItem(output["vpcEndpointSet"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2DescribeVpcPeeringConnectionsResult = (
  output: any,
  context: __SerdeContext
): DescribeVpcPeeringConnectionsResult => {
  let contents: any = {
    __type: "DescribeVpcPeeringConnectionsResult",
    NextToken: undefined,
    VpcPeeringConnections: undefined
  };
  if (output["nextToken"] !== undefined) {
    contents.NextToken = output["nextToken"];
  }
  if (output.vpcPeeringConnectionSet === "") {
    contents.VpcPeeringConnections = [];
  }
  if (
    output["vpcPeeringConnectionSet"] !== undefined &&
    output["vpcPeeringConnectionSet"]["item"] !== undefined
  ) {
    contents.VpcPeeringConnections = deserializeAws_ec2VpcPeeringConnectionList(
      __getArrayIfSingleItem(output["vpcPeeringConnectionSet"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2DescribeVpcsResult = (
  output: any,
  context: __SerdeContext
): DescribeVpcsResult => {
  let contents: any = {
    __type: "DescribeVpcsResult",
    NextToken: undefined,
    Vpcs: undefined
  };
  if (output["nextToken"] !== undefined) {
    contents.NextToken = output["nextToken"];
  }
  if (output.vpcSet === "") {
    contents.Vpcs = [];
  }
  if (
    output["vpcSet"] !== undefined &&
    output["vpcSet"]["item"] !== undefined
  ) {
    contents.Vpcs = deserializeAws_ec2VpcList(
      __getArrayIfSingleItem(output["vpcSet"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2DescribeVpnConnectionsResult = (
  output: any,
  context: __SerdeContext
): DescribeVpnConnectionsResult => {
  let contents: any = {
    __type: "DescribeVpnConnectionsResult",
    VpnConnections: undefined
  };
  if (output.vpnConnectionSet === "") {
    contents.VpnConnections = [];
  }
  if (
    output["vpnConnectionSet"] !== undefined &&
    output["vpnConnectionSet"]["item"] !== undefined
  ) {
    contents.VpnConnections = deserializeAws_ec2VpnConnectionList(
      __getArrayIfSingleItem(output["vpnConnectionSet"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2DescribeVpnGatewaysResult = (
  output: any,
  context: __SerdeContext
): DescribeVpnGatewaysResult => {
  let contents: any = {
    __type: "DescribeVpnGatewaysResult",
    VpnGateways: undefined
  };
  if (output.vpnGatewaySet === "") {
    contents.VpnGateways = [];
  }
  if (
    output["vpnGatewaySet"] !== undefined &&
    output["vpnGatewaySet"]["item"] !== undefined
  ) {
    contents.VpnGateways = deserializeAws_ec2VpnGatewayList(
      __getArrayIfSingleItem(output["vpnGatewaySet"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2DetachClassicLinkVpcResult = (
  output: any,
  context: __SerdeContext
): DetachClassicLinkVpcResult => {
  let contents: any = {
    __type: "DetachClassicLinkVpcResult",
    Return: undefined
  };
  if (output["return"] !== undefined) {
    contents.Return = output["return"] == "true";
  }
  return contents;
};

const deserializeAws_ec2DhcpConfiguration = (
  output: any,
  context: __SerdeContext
): DhcpConfiguration => {
  let contents: any = {
    __type: "DhcpConfiguration",
    Key: undefined,
    Values: undefined
  };
  if (output["key"] !== undefined) {
    contents.Key = output["key"];
  }
  if (output.valueSet === "") {
    contents.Values = [];
  }
  if (
    output["valueSet"] !== undefined &&
    output["valueSet"]["item"] !== undefined
  ) {
    contents.Values = deserializeAws_ec2DhcpConfigurationValueList(
      __getArrayIfSingleItem(output["valueSet"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2DhcpConfigurationList = (
  output: any,
  context: __SerdeContext
): DhcpConfiguration[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2DhcpConfiguration(entry, context)
  );
};

const deserializeAws_ec2DhcpConfigurationValueList = (
  output: any,
  context: __SerdeContext
): AttributeValue[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2AttributeValue(entry, context)
  );
};

const deserializeAws_ec2DhcpOptions = (
  output: any,
  context: __SerdeContext
): DhcpOptions => {
  let contents: any = {
    __type: "DhcpOptions",
    DhcpConfigurations: undefined,
    DhcpOptionsId: undefined,
    OwnerId: undefined,
    Tags: undefined
  };
  if (output.dhcpConfigurationSet === "") {
    contents.DhcpConfigurations = [];
  }
  if (
    output["dhcpConfigurationSet"] !== undefined &&
    output["dhcpConfigurationSet"]["item"] !== undefined
  ) {
    contents.DhcpConfigurations = deserializeAws_ec2DhcpConfigurationList(
      __getArrayIfSingleItem(output["dhcpConfigurationSet"]["item"]),
      context
    );
  }
  if (output["dhcpOptionsId"] !== undefined) {
    contents.DhcpOptionsId = output["dhcpOptionsId"];
  }
  if (output["ownerId"] !== undefined) {
    contents.OwnerId = output["ownerId"];
  }
  if (output.tagSet === "") {
    contents.Tags = [];
  }
  if (
    output["tagSet"] !== undefined &&
    output["tagSet"]["item"] !== undefined
  ) {
    contents.Tags = deserializeAws_ec2TagList(
      __getArrayIfSingleItem(output["tagSet"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2DhcpOptionsList = (
  output: any,
  context: __SerdeContext
): DhcpOptions[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2DhcpOptions(entry, context)
  );
};

const deserializeAws_ec2DirectoryServiceAuthentication = (
  output: any,
  context: __SerdeContext
): DirectoryServiceAuthentication => {
  let contents: any = {
    __type: "DirectoryServiceAuthentication",
    DirectoryId: undefined
  };
  if (output["directoryId"] !== undefined) {
    contents.DirectoryId = output["directoryId"];
  }
  return contents;
};

const deserializeAws_ec2DisableEbsEncryptionByDefaultResult = (
  output: any,
  context: __SerdeContext
): DisableEbsEncryptionByDefaultResult => {
  let contents: any = {
    __type: "DisableEbsEncryptionByDefaultResult",
    EbsEncryptionByDefault: undefined
  };
  if (output["ebsEncryptionByDefault"] !== undefined) {
    contents.EbsEncryptionByDefault =
      output["ebsEncryptionByDefault"] == "true";
  }
  return contents;
};

const deserializeAws_ec2DisableFastSnapshotRestoreErrorItem = (
  output: any,
  context: __SerdeContext
): DisableFastSnapshotRestoreErrorItem => {
  let contents: any = {
    __type: "DisableFastSnapshotRestoreErrorItem",
    FastSnapshotRestoreStateErrors: undefined,
    SnapshotId: undefined
  };
  if (output.fastSnapshotRestoreStateErrorSet === "") {
    contents.FastSnapshotRestoreStateErrors = [];
  }
  if (
    output["fastSnapshotRestoreStateErrorSet"] !== undefined &&
    output["fastSnapshotRestoreStateErrorSet"]["item"] !== undefined
  ) {
    contents.FastSnapshotRestoreStateErrors = deserializeAws_ec2DisableFastSnapshotRestoreStateErrorSet(
      __getArrayIfSingleItem(
        output["fastSnapshotRestoreStateErrorSet"]["item"]
      ),
      context
    );
  }
  if (output["snapshotId"] !== undefined) {
    contents.SnapshotId = output["snapshotId"];
  }
  return contents;
};

const deserializeAws_ec2DisableFastSnapshotRestoreErrorSet = (
  output: any,
  context: __SerdeContext
): DisableFastSnapshotRestoreErrorItem[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2DisableFastSnapshotRestoreErrorItem(entry, context)
  );
};

const deserializeAws_ec2DisableFastSnapshotRestoresResult = (
  output: any,
  context: __SerdeContext
): DisableFastSnapshotRestoresResult => {
  let contents: any = {
    __type: "DisableFastSnapshotRestoresResult",
    Successful: undefined,
    Unsuccessful: undefined
  };
  if (output.successful === "") {
    contents.Successful = [];
  }
  if (
    output["successful"] !== undefined &&
    output["successful"]["item"] !== undefined
  ) {
    contents.Successful = deserializeAws_ec2DisableFastSnapshotRestoreSuccessSet(
      __getArrayIfSingleItem(output["successful"]["item"]),
      context
    );
  }
  if (output.unsuccessful === "") {
    contents.Unsuccessful = [];
  }
  if (
    output["unsuccessful"] !== undefined &&
    output["unsuccessful"]["item"] !== undefined
  ) {
    contents.Unsuccessful = deserializeAws_ec2DisableFastSnapshotRestoreErrorSet(
      __getArrayIfSingleItem(output["unsuccessful"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2DisableFastSnapshotRestoreStateError = (
  output: any,
  context: __SerdeContext
): DisableFastSnapshotRestoreStateError => {
  let contents: any = {
    __type: "DisableFastSnapshotRestoreStateError",
    Code: undefined,
    Message: undefined
  };
  if (output["code"] !== undefined) {
    contents.Code = output["code"];
  }
  if (output["message"] !== undefined) {
    contents.Message = output["message"];
  }
  return contents;
};

const deserializeAws_ec2DisableFastSnapshotRestoreStateErrorItem = (
  output: any,
  context: __SerdeContext
): DisableFastSnapshotRestoreStateErrorItem => {
  let contents: any = {
    __type: "DisableFastSnapshotRestoreStateErrorItem",
    AvailabilityZone: undefined,
    Error: undefined
  };
  if (output["availabilityZone"] !== undefined) {
    contents.AvailabilityZone = output["availabilityZone"];
  }
  if (output["error"] !== undefined) {
    contents.Error = deserializeAws_ec2DisableFastSnapshotRestoreStateError(
      output["error"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2DisableFastSnapshotRestoreStateErrorSet = (
  output: any,
  context: __SerdeContext
): DisableFastSnapshotRestoreStateErrorItem[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2DisableFastSnapshotRestoreStateErrorItem(entry, context)
  );
};

const deserializeAws_ec2DisableFastSnapshotRestoreSuccessItem = (
  output: any,
  context: __SerdeContext
): DisableFastSnapshotRestoreSuccessItem => {
  let contents: any = {
    __type: "DisableFastSnapshotRestoreSuccessItem",
    AvailabilityZone: undefined,
    DisabledTime: undefined,
    DisablingTime: undefined,
    EnabledTime: undefined,
    EnablingTime: undefined,
    OptimizingTime: undefined,
    OwnerAlias: undefined,
    OwnerId: undefined,
    SnapshotId: undefined,
    State: undefined,
    StateTransitionReason: undefined
  };
  if (output["availabilityZone"] !== undefined) {
    contents.AvailabilityZone = output["availabilityZone"];
  }
  if (output["disabledTime"] !== undefined) {
    contents.DisabledTime = new Date(output["disabledTime"]);
  }
  if (output["disablingTime"] !== undefined) {
    contents.DisablingTime = new Date(output["disablingTime"]);
  }
  if (output["enabledTime"] !== undefined) {
    contents.EnabledTime = new Date(output["enabledTime"]);
  }
  if (output["enablingTime"] !== undefined) {
    contents.EnablingTime = new Date(output["enablingTime"]);
  }
  if (output["optimizingTime"] !== undefined) {
    contents.OptimizingTime = new Date(output["optimizingTime"]);
  }
  if (output["ownerAlias"] !== undefined) {
    contents.OwnerAlias = output["ownerAlias"];
  }
  if (output["ownerId"] !== undefined) {
    contents.OwnerId = output["ownerId"];
  }
  if (output["snapshotId"] !== undefined) {
    contents.SnapshotId = output["snapshotId"];
  }
  if (output["state"] !== undefined) {
    contents.State = output["state"];
  }
  if (output["stateTransitionReason"] !== undefined) {
    contents.StateTransitionReason = output["stateTransitionReason"];
  }
  return contents;
};

const deserializeAws_ec2DisableFastSnapshotRestoreSuccessSet = (
  output: any,
  context: __SerdeContext
): DisableFastSnapshotRestoreSuccessItem[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2DisableFastSnapshotRestoreSuccessItem(entry, context)
  );
};

const deserializeAws_ec2DisableTransitGatewayRouteTablePropagationResult = (
  output: any,
  context: __SerdeContext
): DisableTransitGatewayRouteTablePropagationResult => {
  let contents: any = {
    __type: "DisableTransitGatewayRouteTablePropagationResult",
    Propagation: undefined
  };
  if (output["propagation"] !== undefined) {
    contents.Propagation = deserializeAws_ec2TransitGatewayPropagation(
      output["propagation"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2DisableVpcClassicLinkDnsSupportResult = (
  output: any,
  context: __SerdeContext
): DisableVpcClassicLinkDnsSupportResult => {
  let contents: any = {
    __type: "DisableVpcClassicLinkDnsSupportResult",
    Return: undefined
  };
  if (output["return"] !== undefined) {
    contents.Return = output["return"] == "true";
  }
  return contents;
};

const deserializeAws_ec2DisableVpcClassicLinkResult = (
  output: any,
  context: __SerdeContext
): DisableVpcClassicLinkResult => {
  let contents: any = {
    __type: "DisableVpcClassicLinkResult",
    Return: undefined
  };
  if (output["return"] !== undefined) {
    contents.Return = output["return"] == "true";
  }
  return contents;
};

const deserializeAws_ec2DisassociateClientVpnTargetNetworkResult = (
  output: any,
  context: __SerdeContext
): DisassociateClientVpnTargetNetworkResult => {
  let contents: any = {
    __type: "DisassociateClientVpnTargetNetworkResult",
    AssociationId: undefined,
    Status: undefined
  };
  if (output["associationId"] !== undefined) {
    contents.AssociationId = output["associationId"];
  }
  if (output["status"] !== undefined) {
    contents.Status = deserializeAws_ec2AssociationStatus(
      output["status"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2DisassociateIamInstanceProfileResult = (
  output: any,
  context: __SerdeContext
): DisassociateIamInstanceProfileResult => {
  let contents: any = {
    __type: "DisassociateIamInstanceProfileResult",
    IamInstanceProfileAssociation: undefined
  };
  if (output["iamInstanceProfileAssociation"] !== undefined) {
    contents.IamInstanceProfileAssociation = deserializeAws_ec2IamInstanceProfileAssociation(
      output["iamInstanceProfileAssociation"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2DisassociateSubnetCidrBlockResult = (
  output: any,
  context: __SerdeContext
): DisassociateSubnetCidrBlockResult => {
  let contents: any = {
    __type: "DisassociateSubnetCidrBlockResult",
    Ipv6CidrBlockAssociation: undefined,
    SubnetId: undefined
  };
  if (output["ipv6CidrBlockAssociation"] !== undefined) {
    contents.Ipv6CidrBlockAssociation = deserializeAws_ec2SubnetIpv6CidrBlockAssociation(
      output["ipv6CidrBlockAssociation"],
      context
    );
  }
  if (output["subnetId"] !== undefined) {
    contents.SubnetId = output["subnetId"];
  }
  return contents;
};

const deserializeAws_ec2DisassociateTransitGatewayMulticastDomainResult = (
  output: any,
  context: __SerdeContext
): DisassociateTransitGatewayMulticastDomainResult => {
  let contents: any = {
    __type: "DisassociateTransitGatewayMulticastDomainResult",
    Associations: undefined
  };
  if (output["associations"] !== undefined) {
    contents.Associations = deserializeAws_ec2TransitGatewayMulticastDomainAssociations(
      output["associations"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2DisassociateTransitGatewayRouteTableResult = (
  output: any,
  context: __SerdeContext
): DisassociateTransitGatewayRouteTableResult => {
  let contents: any = {
    __type: "DisassociateTransitGatewayRouteTableResult",
    Association: undefined
  };
  if (output["association"] !== undefined) {
    contents.Association = deserializeAws_ec2TransitGatewayAssociation(
      output["association"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2DisassociateVpcCidrBlockResult = (
  output: any,
  context: __SerdeContext
): DisassociateVpcCidrBlockResult => {
  let contents: any = {
    __type: "DisassociateVpcCidrBlockResult",
    CidrBlockAssociation: undefined,
    Ipv6CidrBlockAssociation: undefined,
    VpcId: undefined
  };
  if (output["cidrBlockAssociation"] !== undefined) {
    contents.CidrBlockAssociation = deserializeAws_ec2VpcCidrBlockAssociation(
      output["cidrBlockAssociation"],
      context
    );
  }
  if (output["ipv6CidrBlockAssociation"] !== undefined) {
    contents.Ipv6CidrBlockAssociation = deserializeAws_ec2VpcIpv6CidrBlockAssociation(
      output["ipv6CidrBlockAssociation"],
      context
    );
  }
  if (output["vpcId"] !== undefined) {
    contents.VpcId = output["vpcId"];
  }
  return contents;
};

const deserializeAws_ec2DiskImageDescription = (
  output: any,
  context: __SerdeContext
): DiskImageDescription => {
  let contents: any = {
    __type: "DiskImageDescription",
    Checksum: undefined,
    Format: undefined,
    ImportManifestUrl: undefined,
    Size: undefined
  };
  if (output["checksum"] !== undefined) {
    contents.Checksum = output["checksum"];
  }
  if (output["format"] !== undefined) {
    contents.Format = output["format"];
  }
  if (output["importManifestUrl"] !== undefined) {
    contents.ImportManifestUrl = output["importManifestUrl"];
  }
  if (output["size"] !== undefined) {
    contents.Size = parseInt(output["size"]);
  }
  return contents;
};

const deserializeAws_ec2DiskImageVolumeDescription = (
  output: any,
  context: __SerdeContext
): DiskImageVolumeDescription => {
  let contents: any = {
    __type: "DiskImageVolumeDescription",
    Id: undefined,
    Size: undefined
  };
  if (output["id"] !== undefined) {
    contents.Id = output["id"];
  }
  if (output["size"] !== undefined) {
    contents.Size = parseInt(output["size"]);
  }
  return contents;
};

const deserializeAws_ec2DiskInfo = (
  output: any,
  context: __SerdeContext
): DiskInfo => {
  let contents: any = {
    __type: "DiskInfo",
    Count: undefined,
    SizeInGB: undefined,
    Type: undefined
  };
  if (output["count"] !== undefined) {
    contents.Count = parseInt(output["count"]);
  }
  if (output["sizeInGB"] !== undefined) {
    contents.SizeInGB = parseInt(output["sizeInGB"]);
  }
  if (output["type"] !== undefined) {
    contents.Type = output["type"];
  }
  return contents;
};

const deserializeAws_ec2DiskInfoList = (
  output: any,
  context: __SerdeContext
): DiskInfo[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2DiskInfo(entry, context)
  );
};

const deserializeAws_ec2DnsEntry = (
  output: any,
  context: __SerdeContext
): DnsEntry => {
  let contents: any = {
    __type: "DnsEntry",
    DnsName: undefined,
    HostedZoneId: undefined
  };
  if (output["dnsName"] !== undefined) {
    contents.DnsName = output["dnsName"];
  }
  if (output["hostedZoneId"] !== undefined) {
    contents.HostedZoneId = output["hostedZoneId"];
  }
  return contents;
};

const deserializeAws_ec2DnsEntrySet = (
  output: any,
  context: __SerdeContext
): DnsEntry[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2DnsEntry(entry, context)
  );
};

const deserializeAws_ec2EbsBlockDevice = (
  output: any,
  context: __SerdeContext
): EbsBlockDevice => {
  let contents: any = {
    __type: "EbsBlockDevice",
    DeleteOnTermination: undefined,
    Encrypted: undefined,
    Iops: undefined,
    KmsKeyId: undefined,
    SnapshotId: undefined,
    VolumeSize: undefined,
    VolumeType: undefined
  };
  if (output["deleteOnTermination"] !== undefined) {
    contents.DeleteOnTermination = output["deleteOnTermination"] == "true";
  }
  if (output["encrypted"] !== undefined) {
    contents.Encrypted = output["encrypted"] == "true";
  }
  if (output["iops"] !== undefined) {
    contents.Iops = parseInt(output["iops"]);
  }
  if (output["KmsKeyId"] !== undefined) {
    contents.KmsKeyId = output["KmsKeyId"];
  }
  if (output["snapshotId"] !== undefined) {
    contents.SnapshotId = output["snapshotId"];
  }
  if (output["volumeSize"] !== undefined) {
    contents.VolumeSize = parseInt(output["volumeSize"]);
  }
  if (output["volumeType"] !== undefined) {
    contents.VolumeType = output["volumeType"];
  }
  return contents;
};

const deserializeAws_ec2EbsInfo = (
  output: any,
  context: __SerdeContext
): EbsInfo => {
  let contents: any = {
    __type: "EbsInfo",
    EbsOptimizedSupport: undefined,
    EncryptionSupport: undefined
  };
  if (output["ebsOptimizedSupport"] !== undefined) {
    contents.EbsOptimizedSupport = output["ebsOptimizedSupport"];
  }
  if (output["encryptionSupport"] !== undefined) {
    contents.EncryptionSupport = output["encryptionSupport"];
  }
  return contents;
};

const deserializeAws_ec2EbsInstanceBlockDevice = (
  output: any,
  context: __SerdeContext
): EbsInstanceBlockDevice => {
  let contents: any = {
    __type: "EbsInstanceBlockDevice",
    AttachTime: undefined,
    DeleteOnTermination: undefined,
    Status: undefined,
    VolumeId: undefined
  };
  if (output["attachTime"] !== undefined) {
    contents.AttachTime = new Date(output["attachTime"]);
  }
  if (output["deleteOnTermination"] !== undefined) {
    contents.DeleteOnTermination = output["deleteOnTermination"] == "true";
  }
  if (output["status"] !== undefined) {
    contents.Status = output["status"];
  }
  if (output["volumeId"] !== undefined) {
    contents.VolumeId = output["volumeId"];
  }
  return contents;
};

const deserializeAws_ec2EgressOnlyInternetGateway = (
  output: any,
  context: __SerdeContext
): EgressOnlyInternetGateway => {
  let contents: any = {
    __type: "EgressOnlyInternetGateway",
    Attachments: undefined,
    EgressOnlyInternetGatewayId: undefined,
    Tags: undefined
  };
  if (output.attachmentSet === "") {
    contents.Attachments = [];
  }
  if (
    output["attachmentSet"] !== undefined &&
    output["attachmentSet"]["item"] !== undefined
  ) {
    contents.Attachments = deserializeAws_ec2InternetGatewayAttachmentList(
      __getArrayIfSingleItem(output["attachmentSet"]["item"]),
      context
    );
  }
  if (output["egressOnlyInternetGatewayId"] !== undefined) {
    contents.EgressOnlyInternetGatewayId =
      output["egressOnlyInternetGatewayId"];
  }
  if (output.tagSet === "") {
    contents.Tags = [];
  }
  if (
    output["tagSet"] !== undefined &&
    output["tagSet"]["item"] !== undefined
  ) {
    contents.Tags = deserializeAws_ec2TagList(
      __getArrayIfSingleItem(output["tagSet"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2EgressOnlyInternetGatewayList = (
  output: any,
  context: __SerdeContext
): EgressOnlyInternetGateway[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2EgressOnlyInternetGateway(entry, context)
  );
};

const deserializeAws_ec2ElasticGpuAssociation = (
  output: any,
  context: __SerdeContext
): ElasticGpuAssociation => {
  let contents: any = {
    __type: "ElasticGpuAssociation",
    ElasticGpuAssociationId: undefined,
    ElasticGpuAssociationState: undefined,
    ElasticGpuAssociationTime: undefined,
    ElasticGpuId: undefined
  };
  if (output["elasticGpuAssociationId"] !== undefined) {
    contents.ElasticGpuAssociationId = output["elasticGpuAssociationId"];
  }
  if (output["elasticGpuAssociationState"] !== undefined) {
    contents.ElasticGpuAssociationState = output["elasticGpuAssociationState"];
  }
  if (output["elasticGpuAssociationTime"] !== undefined) {
    contents.ElasticGpuAssociationTime = output["elasticGpuAssociationTime"];
  }
  if (output["elasticGpuId"] !== undefined) {
    contents.ElasticGpuId = output["elasticGpuId"];
  }
  return contents;
};

const deserializeAws_ec2ElasticGpuAssociationList = (
  output: any,
  context: __SerdeContext
): ElasticGpuAssociation[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2ElasticGpuAssociation(entry, context)
  );
};

const deserializeAws_ec2ElasticGpuHealth = (
  output: any,
  context: __SerdeContext
): ElasticGpuHealth => {
  let contents: any = {
    __type: "ElasticGpuHealth",
    Status: undefined
  };
  if (output["status"] !== undefined) {
    contents.Status = output["status"];
  }
  return contents;
};

const deserializeAws_ec2ElasticGpus = (
  output: any,
  context: __SerdeContext
): ElasticGpus => {
  let contents: any = {
    __type: "ElasticGpus",
    AvailabilityZone: undefined,
    ElasticGpuHealth: undefined,
    ElasticGpuId: undefined,
    ElasticGpuState: undefined,
    ElasticGpuType: undefined,
    InstanceId: undefined,
    Tags: undefined
  };
  if (output["availabilityZone"] !== undefined) {
    contents.AvailabilityZone = output["availabilityZone"];
  }
  if (output["elasticGpuHealth"] !== undefined) {
    contents.ElasticGpuHealth = deserializeAws_ec2ElasticGpuHealth(
      output["elasticGpuHealth"],
      context
    );
  }
  if (output["elasticGpuId"] !== undefined) {
    contents.ElasticGpuId = output["elasticGpuId"];
  }
  if (output["elasticGpuState"] !== undefined) {
    contents.ElasticGpuState = output["elasticGpuState"];
  }
  if (output["elasticGpuType"] !== undefined) {
    contents.ElasticGpuType = output["elasticGpuType"];
  }
  if (output["instanceId"] !== undefined) {
    contents.InstanceId = output["instanceId"];
  }
  if (output.tagSet === "") {
    contents.Tags = [];
  }
  if (
    output["tagSet"] !== undefined &&
    output["tagSet"]["item"] !== undefined
  ) {
    contents.Tags = deserializeAws_ec2TagList(
      __getArrayIfSingleItem(output["tagSet"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2ElasticGpuSet = (
  output: any,
  context: __SerdeContext
): ElasticGpus[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2ElasticGpus(entry, context)
  );
};

const deserializeAws_ec2ElasticGpuSpecificationResponse = (
  output: any,
  context: __SerdeContext
): ElasticGpuSpecificationResponse => {
  let contents: any = {
    __type: "ElasticGpuSpecificationResponse",
    Type: undefined
  };
  if (output["type"] !== undefined) {
    contents.Type = output["type"];
  }
  return contents;
};

const deserializeAws_ec2ElasticGpuSpecificationResponseList = (
  output: any,
  context: __SerdeContext
): ElasticGpuSpecificationResponse[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2ElasticGpuSpecificationResponse(entry, context)
  );
};

const deserializeAws_ec2ElasticInferenceAcceleratorAssociation = (
  output: any,
  context: __SerdeContext
): ElasticInferenceAcceleratorAssociation => {
  let contents: any = {
    __type: "ElasticInferenceAcceleratorAssociation",
    ElasticInferenceAcceleratorArn: undefined,
    ElasticInferenceAcceleratorAssociationId: undefined,
    ElasticInferenceAcceleratorAssociationState: undefined,
    ElasticInferenceAcceleratorAssociationTime: undefined
  };
  if (output["elasticInferenceAcceleratorArn"] !== undefined) {
    contents.ElasticInferenceAcceleratorArn =
      output["elasticInferenceAcceleratorArn"];
  }
  if (output["elasticInferenceAcceleratorAssociationId"] !== undefined) {
    contents.ElasticInferenceAcceleratorAssociationId =
      output["elasticInferenceAcceleratorAssociationId"];
  }
  if (output["elasticInferenceAcceleratorAssociationState"] !== undefined) {
    contents.ElasticInferenceAcceleratorAssociationState =
      output["elasticInferenceAcceleratorAssociationState"];
  }
  if (output["elasticInferenceAcceleratorAssociationTime"] !== undefined) {
    contents.ElasticInferenceAcceleratorAssociationTime = new Date(
      output["elasticInferenceAcceleratorAssociationTime"]
    );
  }
  return contents;
};

const deserializeAws_ec2ElasticInferenceAcceleratorAssociationList = (
  output: any,
  context: __SerdeContext
): ElasticInferenceAcceleratorAssociation[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2ElasticInferenceAcceleratorAssociation(entry, context)
  );
};

const deserializeAws_ec2EnableEbsEncryptionByDefaultResult = (
  output: any,
  context: __SerdeContext
): EnableEbsEncryptionByDefaultResult => {
  let contents: any = {
    __type: "EnableEbsEncryptionByDefaultResult",
    EbsEncryptionByDefault: undefined
  };
  if (output["ebsEncryptionByDefault"] !== undefined) {
    contents.EbsEncryptionByDefault =
      output["ebsEncryptionByDefault"] == "true";
  }
  return contents;
};

const deserializeAws_ec2EnableFastSnapshotRestoreErrorItem = (
  output: any,
  context: __SerdeContext
): EnableFastSnapshotRestoreErrorItem => {
  let contents: any = {
    __type: "EnableFastSnapshotRestoreErrorItem",
    FastSnapshotRestoreStateErrors: undefined,
    SnapshotId: undefined
  };
  if (output.fastSnapshotRestoreStateErrorSet === "") {
    contents.FastSnapshotRestoreStateErrors = [];
  }
  if (
    output["fastSnapshotRestoreStateErrorSet"] !== undefined &&
    output["fastSnapshotRestoreStateErrorSet"]["item"] !== undefined
  ) {
    contents.FastSnapshotRestoreStateErrors = deserializeAws_ec2EnableFastSnapshotRestoreStateErrorSet(
      __getArrayIfSingleItem(
        output["fastSnapshotRestoreStateErrorSet"]["item"]
      ),
      context
    );
  }
  if (output["snapshotId"] !== undefined) {
    contents.SnapshotId = output["snapshotId"];
  }
  return contents;
};

const deserializeAws_ec2EnableFastSnapshotRestoreErrorSet = (
  output: any,
  context: __SerdeContext
): EnableFastSnapshotRestoreErrorItem[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2EnableFastSnapshotRestoreErrorItem(entry, context)
  );
};

const deserializeAws_ec2EnableFastSnapshotRestoresResult = (
  output: any,
  context: __SerdeContext
): EnableFastSnapshotRestoresResult => {
  let contents: any = {
    __type: "EnableFastSnapshotRestoresResult",
    Successful: undefined,
    Unsuccessful: undefined
  };
  if (output.successful === "") {
    contents.Successful = [];
  }
  if (
    output["successful"] !== undefined &&
    output["successful"]["item"] !== undefined
  ) {
    contents.Successful = deserializeAws_ec2EnableFastSnapshotRestoreSuccessSet(
      __getArrayIfSingleItem(output["successful"]["item"]),
      context
    );
  }
  if (output.unsuccessful === "") {
    contents.Unsuccessful = [];
  }
  if (
    output["unsuccessful"] !== undefined &&
    output["unsuccessful"]["item"] !== undefined
  ) {
    contents.Unsuccessful = deserializeAws_ec2EnableFastSnapshotRestoreErrorSet(
      __getArrayIfSingleItem(output["unsuccessful"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2EnableFastSnapshotRestoreStateError = (
  output: any,
  context: __SerdeContext
): EnableFastSnapshotRestoreStateError => {
  let contents: any = {
    __type: "EnableFastSnapshotRestoreStateError",
    Code: undefined,
    Message: undefined
  };
  if (output["code"] !== undefined) {
    contents.Code = output["code"];
  }
  if (output["message"] !== undefined) {
    contents.Message = output["message"];
  }
  return contents;
};

const deserializeAws_ec2EnableFastSnapshotRestoreStateErrorItem = (
  output: any,
  context: __SerdeContext
): EnableFastSnapshotRestoreStateErrorItem => {
  let contents: any = {
    __type: "EnableFastSnapshotRestoreStateErrorItem",
    AvailabilityZone: undefined,
    Error: undefined
  };
  if (output["availabilityZone"] !== undefined) {
    contents.AvailabilityZone = output["availabilityZone"];
  }
  if (output["error"] !== undefined) {
    contents.Error = deserializeAws_ec2EnableFastSnapshotRestoreStateError(
      output["error"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2EnableFastSnapshotRestoreStateErrorSet = (
  output: any,
  context: __SerdeContext
): EnableFastSnapshotRestoreStateErrorItem[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2EnableFastSnapshotRestoreStateErrorItem(entry, context)
  );
};

const deserializeAws_ec2EnableFastSnapshotRestoreSuccessItem = (
  output: any,
  context: __SerdeContext
): EnableFastSnapshotRestoreSuccessItem => {
  let contents: any = {
    __type: "EnableFastSnapshotRestoreSuccessItem",
    AvailabilityZone: undefined,
    DisabledTime: undefined,
    DisablingTime: undefined,
    EnabledTime: undefined,
    EnablingTime: undefined,
    OptimizingTime: undefined,
    OwnerAlias: undefined,
    OwnerId: undefined,
    SnapshotId: undefined,
    State: undefined,
    StateTransitionReason: undefined
  };
  if (output["availabilityZone"] !== undefined) {
    contents.AvailabilityZone = output["availabilityZone"];
  }
  if (output["disabledTime"] !== undefined) {
    contents.DisabledTime = new Date(output["disabledTime"]);
  }
  if (output["disablingTime"] !== undefined) {
    contents.DisablingTime = new Date(output["disablingTime"]);
  }
  if (output["enabledTime"] !== undefined) {
    contents.EnabledTime = new Date(output["enabledTime"]);
  }
  if (output["enablingTime"] !== undefined) {
    contents.EnablingTime = new Date(output["enablingTime"]);
  }
  if (output["optimizingTime"] !== undefined) {
    contents.OptimizingTime = new Date(output["optimizingTime"]);
  }
  if (output["ownerAlias"] !== undefined) {
    contents.OwnerAlias = output["ownerAlias"];
  }
  if (output["ownerId"] !== undefined) {
    contents.OwnerId = output["ownerId"];
  }
  if (output["snapshotId"] !== undefined) {
    contents.SnapshotId = output["snapshotId"];
  }
  if (output["state"] !== undefined) {
    contents.State = output["state"];
  }
  if (output["stateTransitionReason"] !== undefined) {
    contents.StateTransitionReason = output["stateTransitionReason"];
  }
  return contents;
};

const deserializeAws_ec2EnableFastSnapshotRestoreSuccessSet = (
  output: any,
  context: __SerdeContext
): EnableFastSnapshotRestoreSuccessItem[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2EnableFastSnapshotRestoreSuccessItem(entry, context)
  );
};

const deserializeAws_ec2EnableTransitGatewayRouteTablePropagationResult = (
  output: any,
  context: __SerdeContext
): EnableTransitGatewayRouteTablePropagationResult => {
  let contents: any = {
    __type: "EnableTransitGatewayRouteTablePropagationResult",
    Propagation: undefined
  };
  if (output["propagation"] !== undefined) {
    contents.Propagation = deserializeAws_ec2TransitGatewayPropagation(
      output["propagation"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2EnableVpcClassicLinkDnsSupportResult = (
  output: any,
  context: __SerdeContext
): EnableVpcClassicLinkDnsSupportResult => {
  let contents: any = {
    __type: "EnableVpcClassicLinkDnsSupportResult",
    Return: undefined
  };
  if (output["return"] !== undefined) {
    contents.Return = output["return"] == "true";
  }
  return contents;
};

const deserializeAws_ec2EnableVpcClassicLinkResult = (
  output: any,
  context: __SerdeContext
): EnableVpcClassicLinkResult => {
  let contents: any = {
    __type: "EnableVpcClassicLinkResult",
    Return: undefined
  };
  if (output["return"] !== undefined) {
    contents.Return = output["return"] == "true";
  }
  return contents;
};

const deserializeAws_ec2EndpointSet = (
  output: any,
  context: __SerdeContext
): ClientVpnEndpoint[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2ClientVpnEndpoint(entry, context)
  );
};

const deserializeAws_ec2EventInformation = (
  output: any,
  context: __SerdeContext
): EventInformation => {
  let contents: any = {
    __type: "EventInformation",
    EventDescription: undefined,
    EventSubType: undefined,
    InstanceId: undefined
  };
  if (output["eventDescription"] !== undefined) {
    contents.EventDescription = output["eventDescription"];
  }
  if (output["eventSubType"] !== undefined) {
    contents.EventSubType = output["eventSubType"];
  }
  if (output["instanceId"] !== undefined) {
    contents.InstanceId = output["instanceId"];
  }
  return contents;
};

const deserializeAws_ec2ExportClientVpnClientCertificateRevocationListResult = (
  output: any,
  context: __SerdeContext
): ExportClientVpnClientCertificateRevocationListResult => {
  let contents: any = {
    __type: "ExportClientVpnClientCertificateRevocationListResult",
    CertificateRevocationList: undefined,
    Status: undefined
  };
  if (output["certificateRevocationList"] !== undefined) {
    contents.CertificateRevocationList = output["certificateRevocationList"];
  }
  if (output["status"] !== undefined) {
    contents.Status = deserializeAws_ec2ClientCertificateRevocationListStatus(
      output["status"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2ExportClientVpnClientConfigurationResult = (
  output: any,
  context: __SerdeContext
): ExportClientVpnClientConfigurationResult => {
  let contents: any = {
    __type: "ExportClientVpnClientConfigurationResult",
    ClientConfiguration: undefined
  };
  if (output["clientConfiguration"] !== undefined) {
    contents.ClientConfiguration = output["clientConfiguration"];
  }
  return contents;
};

const deserializeAws_ec2ExportImageResult = (
  output: any,
  context: __SerdeContext
): ExportImageResult => {
  let contents: any = {
    __type: "ExportImageResult",
    Description: undefined,
    DiskImageFormat: undefined,
    ExportImageTaskId: undefined,
    ImageId: undefined,
    Progress: undefined,
    RoleName: undefined,
    S3ExportLocation: undefined,
    Status: undefined,
    StatusMessage: undefined
  };
  if (output["description"] !== undefined) {
    contents.Description = output["description"];
  }
  if (output["diskImageFormat"] !== undefined) {
    contents.DiskImageFormat = output["diskImageFormat"];
  }
  if (output["exportImageTaskId"] !== undefined) {
    contents.ExportImageTaskId = output["exportImageTaskId"];
  }
  if (output["imageId"] !== undefined) {
    contents.ImageId = output["imageId"];
  }
  if (output["progress"] !== undefined) {
    contents.Progress = output["progress"];
  }
  if (output["roleName"] !== undefined) {
    contents.RoleName = output["roleName"];
  }
  if (output["s3ExportLocation"] !== undefined) {
    contents.S3ExportLocation = deserializeAws_ec2ExportTaskS3Location(
      output["s3ExportLocation"],
      context
    );
  }
  if (output["status"] !== undefined) {
    contents.Status = output["status"];
  }
  if (output["statusMessage"] !== undefined) {
    contents.StatusMessage = output["statusMessage"];
  }
  return contents;
};

const deserializeAws_ec2ExportImageTask = (
  output: any,
  context: __SerdeContext
): ExportImageTask => {
  let contents: any = {
    __type: "ExportImageTask",
    Description: undefined,
    ExportImageTaskId: undefined,
    ImageId: undefined,
    Progress: undefined,
    S3ExportLocation: undefined,
    Status: undefined,
    StatusMessage: undefined
  };
  if (output["description"] !== undefined) {
    contents.Description = output["description"];
  }
  if (output["exportImageTaskId"] !== undefined) {
    contents.ExportImageTaskId = output["exportImageTaskId"];
  }
  if (output["imageId"] !== undefined) {
    contents.ImageId = output["imageId"];
  }
  if (output["progress"] !== undefined) {
    contents.Progress = output["progress"];
  }
  if (output["s3ExportLocation"] !== undefined) {
    contents.S3ExportLocation = deserializeAws_ec2ExportTaskS3Location(
      output["s3ExportLocation"],
      context
    );
  }
  if (output["status"] !== undefined) {
    contents.Status = output["status"];
  }
  if (output["statusMessage"] !== undefined) {
    contents.StatusMessage = output["statusMessage"];
  }
  return contents;
};

const deserializeAws_ec2ExportImageTaskList = (
  output: any,
  context: __SerdeContext
): ExportImageTask[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2ExportImageTask(entry, context)
  );
};

const deserializeAws_ec2ExportTask = (
  output: any,
  context: __SerdeContext
): ExportTask => {
  let contents: any = {
    __type: "ExportTask",
    Description: undefined,
    ExportTaskId: undefined,
    ExportToS3Task: undefined,
    InstanceExportDetails: undefined,
    State: undefined,
    StatusMessage: undefined,
    Tags: undefined
  };
  if (output["description"] !== undefined) {
    contents.Description = output["description"];
  }
  if (output["exportTaskId"] !== undefined) {
    contents.ExportTaskId = output["exportTaskId"];
  }
  if (output["exportToS3"] !== undefined) {
    contents.ExportToS3Task = deserializeAws_ec2ExportToS3Task(
      output["exportToS3"],
      context
    );
  }
  if (output["instanceExport"] !== undefined) {
    contents.InstanceExportDetails = deserializeAws_ec2InstanceExportDetails(
      output["instanceExport"],
      context
    );
  }
  if (output["state"] !== undefined) {
    contents.State = output["state"];
  }
  if (output["statusMessage"] !== undefined) {
    contents.StatusMessage = output["statusMessage"];
  }
  if (output.tagSet === "") {
    contents.Tags = [];
  }
  if (
    output["tagSet"] !== undefined &&
    output["tagSet"]["item"] !== undefined
  ) {
    contents.Tags = deserializeAws_ec2TagList(
      __getArrayIfSingleItem(output["tagSet"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2ExportTaskList = (
  output: any,
  context: __SerdeContext
): ExportTask[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2ExportTask(entry, context)
  );
};

const deserializeAws_ec2ExportTaskS3Location = (
  output: any,
  context: __SerdeContext
): ExportTaskS3Location => {
  let contents: any = {
    __type: "ExportTaskS3Location",
    S3Bucket: undefined,
    S3Prefix: undefined
  };
  if (output["s3Bucket"] !== undefined) {
    contents.S3Bucket = output["s3Bucket"];
  }
  if (output["s3Prefix"] !== undefined) {
    contents.S3Prefix = output["s3Prefix"];
  }
  return contents;
};

const deserializeAws_ec2ExportToS3Task = (
  output: any,
  context: __SerdeContext
): ExportToS3Task => {
  let contents: any = {
    __type: "ExportToS3Task",
    ContainerFormat: undefined,
    DiskImageFormat: undefined,
    S3Bucket: undefined,
    S3Key: undefined
  };
  if (output["containerFormat"] !== undefined) {
    contents.ContainerFormat = output["containerFormat"];
  }
  if (output["diskImageFormat"] !== undefined) {
    contents.DiskImageFormat = output["diskImageFormat"];
  }
  if (output["s3Bucket"] !== undefined) {
    contents.S3Bucket = output["s3Bucket"];
  }
  if (output["s3Key"] !== undefined) {
    contents.S3Key = output["s3Key"];
  }
  return contents;
};

const deserializeAws_ec2ExportTransitGatewayRoutesResult = (
  output: any,
  context: __SerdeContext
): ExportTransitGatewayRoutesResult => {
  let contents: any = {
    __type: "ExportTransitGatewayRoutesResult",
    S3Location: undefined
  };
  if (output["s3Location"] !== undefined) {
    contents.S3Location = output["s3Location"];
  }
  return contents;
};

const deserializeAws_ec2FailedQueuedPurchaseDeletion = (
  output: any,
  context: __SerdeContext
): FailedQueuedPurchaseDeletion => {
  let contents: any = {
    __type: "FailedQueuedPurchaseDeletion",
    Error: undefined,
    ReservedInstancesId: undefined
  };
  if (output["error"] !== undefined) {
    contents.Error = deserializeAws_ec2DeleteQueuedReservedInstancesError(
      output["error"],
      context
    );
  }
  if (output["reservedInstancesId"] !== undefined) {
    contents.ReservedInstancesId = output["reservedInstancesId"];
  }
  return contents;
};

const deserializeAws_ec2FailedQueuedPurchaseDeletionSet = (
  output: any,
  context: __SerdeContext
): FailedQueuedPurchaseDeletion[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2FailedQueuedPurchaseDeletion(entry, context)
  );
};

const deserializeAws_ec2FleetData = (
  output: any,
  context: __SerdeContext
): FleetData => {
  let contents: any = {
    __type: "FleetData",
    ActivityStatus: undefined,
    ClientToken: undefined,
    CreateTime: undefined,
    Errors: undefined,
    ExcessCapacityTerminationPolicy: undefined,
    FleetId: undefined,
    FleetState: undefined,
    FulfilledCapacity: undefined,
    FulfilledOnDemandCapacity: undefined,
    Instances: undefined,
    LaunchTemplateConfigs: undefined,
    OnDemandOptions: undefined,
    ReplaceUnhealthyInstances: undefined,
    SpotOptions: undefined,
    Tags: undefined,
    TargetCapacitySpecification: undefined,
    TerminateInstancesWithExpiration: undefined,
    Type: undefined,
    ValidFrom: undefined,
    ValidUntil: undefined
  };
  if (output["activityStatus"] !== undefined) {
    contents.ActivityStatus = output["activityStatus"];
  }
  if (output["clientToken"] !== undefined) {
    contents.ClientToken = output["clientToken"];
  }
  if (output["createTime"] !== undefined) {
    contents.CreateTime = new Date(output["createTime"]);
  }
  if (output.errorSet === "") {
    contents.Errors = [];
  }
  if (
    output["errorSet"] !== undefined &&
    output["errorSet"]["item"] !== undefined
  ) {
    contents.Errors = deserializeAws_ec2DescribeFleetsErrorSet(
      __getArrayIfSingleItem(output["errorSet"]["item"]),
      context
    );
  }
  if (output["excessCapacityTerminationPolicy"] !== undefined) {
    contents.ExcessCapacityTerminationPolicy =
      output["excessCapacityTerminationPolicy"];
  }
  if (output["fleetId"] !== undefined) {
    contents.FleetId = output["fleetId"];
  }
  if (output["fleetState"] !== undefined) {
    contents.FleetState = output["fleetState"];
  }
  if (output["fulfilledCapacity"] !== undefined) {
    contents.FulfilledCapacity = parseFloat(output["fulfilledCapacity"]);
  }
  if (output["fulfilledOnDemandCapacity"] !== undefined) {
    contents.FulfilledOnDemandCapacity = parseFloat(
      output["fulfilledOnDemandCapacity"]
    );
  }
  if (output.fleetInstanceSet === "") {
    contents.Instances = [];
  }
  if (
    output["fleetInstanceSet"] !== undefined &&
    output["fleetInstanceSet"]["item"] !== undefined
  ) {
    contents.Instances = deserializeAws_ec2DescribeFleetsInstancesSet(
      __getArrayIfSingleItem(output["fleetInstanceSet"]["item"]),
      context
    );
  }
  if (output.launchTemplateConfigs === "") {
    contents.LaunchTemplateConfigs = [];
  }
  if (
    output["launchTemplateConfigs"] !== undefined &&
    output["launchTemplateConfigs"]["item"] !== undefined
  ) {
    contents.LaunchTemplateConfigs = deserializeAws_ec2FleetLaunchTemplateConfigList(
      __getArrayIfSingleItem(output["launchTemplateConfigs"]["item"]),
      context
    );
  }
  if (output["onDemandOptions"] !== undefined) {
    contents.OnDemandOptions = deserializeAws_ec2OnDemandOptions(
      output["onDemandOptions"],
      context
    );
  }
  if (output["replaceUnhealthyInstances"] !== undefined) {
    contents.ReplaceUnhealthyInstances =
      output["replaceUnhealthyInstances"] == "true";
  }
  if (output["spotOptions"] !== undefined) {
    contents.SpotOptions = deserializeAws_ec2SpotOptions(
      output["spotOptions"],
      context
    );
  }
  if (output.tagSet === "") {
    contents.Tags = [];
  }
  if (
    output["tagSet"] !== undefined &&
    output["tagSet"]["item"] !== undefined
  ) {
    contents.Tags = deserializeAws_ec2TagList(
      __getArrayIfSingleItem(output["tagSet"]["item"]),
      context
    );
  }
  if (output["targetCapacitySpecification"] !== undefined) {
    contents.TargetCapacitySpecification = deserializeAws_ec2TargetCapacitySpecification(
      output["targetCapacitySpecification"],
      context
    );
  }
  if (output["terminateInstancesWithExpiration"] !== undefined) {
    contents.TerminateInstancesWithExpiration =
      output["terminateInstancesWithExpiration"] == "true";
  }
  if (output["type"] !== undefined) {
    contents.Type = output["type"];
  }
  if (output["validFrom"] !== undefined) {
    contents.ValidFrom = new Date(output["validFrom"]);
  }
  if (output["validUntil"] !== undefined) {
    contents.ValidUntil = new Date(output["validUntil"]);
  }
  return contents;
};

const deserializeAws_ec2FleetLaunchTemplateConfig = (
  output: any,
  context: __SerdeContext
): FleetLaunchTemplateConfig => {
  let contents: any = {
    __type: "FleetLaunchTemplateConfig",
    LaunchTemplateSpecification: undefined,
    Overrides: undefined
  };
  if (output["launchTemplateSpecification"] !== undefined) {
    contents.LaunchTemplateSpecification = deserializeAws_ec2FleetLaunchTemplateSpecification(
      output["launchTemplateSpecification"],
      context
    );
  }
  if (output.overrides === "") {
    contents.Overrides = [];
  }
  if (
    output["overrides"] !== undefined &&
    output["overrides"]["item"] !== undefined
  ) {
    contents.Overrides = deserializeAws_ec2FleetLaunchTemplateOverridesList(
      __getArrayIfSingleItem(output["overrides"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2FleetLaunchTemplateConfigList = (
  output: any,
  context: __SerdeContext
): FleetLaunchTemplateConfig[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2FleetLaunchTemplateConfig(entry, context)
  );
};

const deserializeAws_ec2FleetLaunchTemplateOverrides = (
  output: any,
  context: __SerdeContext
): FleetLaunchTemplateOverrides => {
  let contents: any = {
    __type: "FleetLaunchTemplateOverrides",
    AvailabilityZone: undefined,
    InstanceType: undefined,
    MaxPrice: undefined,
    Placement: undefined,
    Priority: undefined,
    SubnetId: undefined,
    WeightedCapacity: undefined
  };
  if (output["availabilityZone"] !== undefined) {
    contents.AvailabilityZone = output["availabilityZone"];
  }
  if (output["instanceType"] !== undefined) {
    contents.InstanceType = output["instanceType"];
  }
  if (output["maxPrice"] !== undefined) {
    contents.MaxPrice = output["maxPrice"];
  }
  if (output["placement"] !== undefined) {
    contents.Placement = deserializeAws_ec2PlacementResponse(
      output["placement"],
      context
    );
  }
  if (output["priority"] !== undefined) {
    contents.Priority = parseFloat(output["priority"]);
  }
  if (output["subnetId"] !== undefined) {
    contents.SubnetId = output["subnetId"];
  }
  if (output["weightedCapacity"] !== undefined) {
    contents.WeightedCapacity = parseFloat(output["weightedCapacity"]);
  }
  return contents;
};

const deserializeAws_ec2FleetLaunchTemplateOverridesList = (
  output: any,
  context: __SerdeContext
): FleetLaunchTemplateOverrides[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2FleetLaunchTemplateOverrides(entry, context)
  );
};

const deserializeAws_ec2FleetLaunchTemplateSpecification = (
  output: any,
  context: __SerdeContext
): FleetLaunchTemplateSpecification => {
  let contents: any = {
    __type: "FleetLaunchTemplateSpecification",
    LaunchTemplateId: undefined,
    LaunchTemplateName: undefined,
    Version: undefined
  };
  if (output["launchTemplateId"] !== undefined) {
    contents.LaunchTemplateId = output["launchTemplateId"];
  }
  if (output["launchTemplateName"] !== undefined) {
    contents.LaunchTemplateName = output["launchTemplateName"];
  }
  if (output["version"] !== undefined) {
    contents.Version = output["version"];
  }
  return contents;
};

const deserializeAws_ec2FleetSet = (
  output: any,
  context: __SerdeContext
): FleetData[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2FleetData(entry, context)
  );
};

const deserializeAws_ec2FlowLog = (
  output: any,
  context: __SerdeContext
): FlowLog => {
  let contents: any = {
    __type: "FlowLog",
    CreationTime: undefined,
    DeliverLogsErrorMessage: undefined,
    DeliverLogsPermissionArn: undefined,
    DeliverLogsStatus: undefined,
    FlowLogId: undefined,
    FlowLogStatus: undefined,
    LogDestination: undefined,
    LogDestinationType: undefined,
    LogFormat: undefined,
    LogGroupName: undefined,
    ResourceId: undefined,
    TrafficType: undefined
  };
  if (output["creationTime"] !== undefined) {
    contents.CreationTime = new Date(output["creationTime"]);
  }
  if (output["deliverLogsErrorMessage"] !== undefined) {
    contents.DeliverLogsErrorMessage = output["deliverLogsErrorMessage"];
  }
  if (output["deliverLogsPermissionArn"] !== undefined) {
    contents.DeliverLogsPermissionArn = output["deliverLogsPermissionArn"];
  }
  if (output["deliverLogsStatus"] !== undefined) {
    contents.DeliverLogsStatus = output["deliverLogsStatus"];
  }
  if (output["flowLogId"] !== undefined) {
    contents.FlowLogId = output["flowLogId"];
  }
  if (output["flowLogStatus"] !== undefined) {
    contents.FlowLogStatus = output["flowLogStatus"];
  }
  if (output["logDestination"] !== undefined) {
    contents.LogDestination = output["logDestination"];
  }
  if (output["logDestinationType"] !== undefined) {
    contents.LogDestinationType = output["logDestinationType"];
  }
  if (output["logFormat"] !== undefined) {
    contents.LogFormat = output["logFormat"];
  }
  if (output["logGroupName"] !== undefined) {
    contents.LogGroupName = output["logGroupName"];
  }
  if (output["resourceId"] !== undefined) {
    contents.ResourceId = output["resourceId"];
  }
  if (output["trafficType"] !== undefined) {
    contents.TrafficType = output["trafficType"];
  }
  return contents;
};

const deserializeAws_ec2FlowLogSet = (
  output: any,
  context: __SerdeContext
): FlowLog[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2FlowLog(entry, context)
  );
};

const deserializeAws_ec2FpgaDeviceInfo = (
  output: any,
  context: __SerdeContext
): FpgaDeviceInfo => {
  let contents: any = {
    __type: "FpgaDeviceInfo",
    Count: undefined,
    Manufacturer: undefined,
    MemoryInfo: undefined,
    Name: undefined
  };
  if (output["count"] !== undefined) {
    contents.Count = parseInt(output["count"]);
  }
  if (output["manufacturer"] !== undefined) {
    contents.Manufacturer = output["manufacturer"];
  }
  if (output["memoryInfo"] !== undefined) {
    contents.MemoryInfo = deserializeAws_ec2FpgaDeviceMemoryInfo(
      output["memoryInfo"],
      context
    );
  }
  if (output["name"] !== undefined) {
    contents.Name = output["name"];
  }
  return contents;
};

const deserializeAws_ec2FpgaDeviceInfoList = (
  output: any,
  context: __SerdeContext
): FpgaDeviceInfo[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2FpgaDeviceInfo(entry, context)
  );
};

const deserializeAws_ec2FpgaDeviceMemoryInfo = (
  output: any,
  context: __SerdeContext
): FpgaDeviceMemoryInfo => {
  let contents: any = {
    __type: "FpgaDeviceMemoryInfo",
    SizeInMiB: undefined
  };
  if (output["sizeInMiB"] !== undefined) {
    contents.SizeInMiB = parseInt(output["sizeInMiB"]);
  }
  return contents;
};

const deserializeAws_ec2FpgaImage = (
  output: any,
  context: __SerdeContext
): FpgaImage => {
  let contents: any = {
    __type: "FpgaImage",
    CreateTime: undefined,
    DataRetentionSupport: undefined,
    Description: undefined,
    FpgaImageGlobalId: undefined,
    FpgaImageId: undefined,
    Name: undefined,
    OwnerAlias: undefined,
    OwnerId: undefined,
    PciId: undefined,
    ProductCodes: undefined,
    Public: undefined,
    ShellVersion: undefined,
    State: undefined,
    Tags: undefined,
    UpdateTime: undefined
  };
  if (output["createTime"] !== undefined) {
    contents.CreateTime = new Date(output["createTime"]);
  }
  if (output["dataRetentionSupport"] !== undefined) {
    contents.DataRetentionSupport = output["dataRetentionSupport"] == "true";
  }
  if (output["description"] !== undefined) {
    contents.Description = output["description"];
  }
  if (output["fpgaImageGlobalId"] !== undefined) {
    contents.FpgaImageGlobalId = output["fpgaImageGlobalId"];
  }
  if (output["fpgaImageId"] !== undefined) {
    contents.FpgaImageId = output["fpgaImageId"];
  }
  if (output["name"] !== undefined) {
    contents.Name = output["name"];
  }
  if (output["ownerAlias"] !== undefined) {
    contents.OwnerAlias = output["ownerAlias"];
  }
  if (output["ownerId"] !== undefined) {
    contents.OwnerId = output["ownerId"];
  }
  if (output["pciId"] !== undefined) {
    contents.PciId = deserializeAws_ec2PciId(output["pciId"], context);
  }
  if (output.productCodes === "") {
    contents.ProductCodes = [];
  }
  if (
    output["productCodes"] !== undefined &&
    output["productCodes"]["item"] !== undefined
  ) {
    contents.ProductCodes = deserializeAws_ec2ProductCodeList(
      __getArrayIfSingleItem(output["productCodes"]["item"]),
      context
    );
  }
  if (output["public"] !== undefined) {
    contents.Public = output["public"] == "true";
  }
  if (output["shellVersion"] !== undefined) {
    contents.ShellVersion = output["shellVersion"];
  }
  if (output["state"] !== undefined) {
    contents.State = deserializeAws_ec2FpgaImageState(output["state"], context);
  }
  if (output.tags === "") {
    contents.Tags = [];
  }
  if (output["tags"] !== undefined && output["tags"]["item"] !== undefined) {
    contents.Tags = deserializeAws_ec2TagList(
      __getArrayIfSingleItem(output["tags"]["item"]),
      context
    );
  }
  if (output["updateTime"] !== undefined) {
    contents.UpdateTime = new Date(output["updateTime"]);
  }
  return contents;
};

const deserializeAws_ec2FpgaImageAttribute = (
  output: any,
  context: __SerdeContext
): FpgaImageAttribute => {
  let contents: any = {
    __type: "FpgaImageAttribute",
    Description: undefined,
    FpgaImageId: undefined,
    LoadPermissions: undefined,
    Name: undefined,
    ProductCodes: undefined
  };
  if (output["description"] !== undefined) {
    contents.Description = output["description"];
  }
  if (output["fpgaImageId"] !== undefined) {
    contents.FpgaImageId = output["fpgaImageId"];
  }
  if (output.loadPermissions === "") {
    contents.LoadPermissions = [];
  }
  if (
    output["loadPermissions"] !== undefined &&
    output["loadPermissions"]["item"] !== undefined
  ) {
    contents.LoadPermissions = deserializeAws_ec2LoadPermissionList(
      __getArrayIfSingleItem(output["loadPermissions"]["item"]),
      context
    );
  }
  if (output["name"] !== undefined) {
    contents.Name = output["name"];
  }
  if (output.productCodes === "") {
    contents.ProductCodes = [];
  }
  if (
    output["productCodes"] !== undefined &&
    output["productCodes"]["item"] !== undefined
  ) {
    contents.ProductCodes = deserializeAws_ec2ProductCodeList(
      __getArrayIfSingleItem(output["productCodes"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2FpgaImageList = (
  output: any,
  context: __SerdeContext
): FpgaImage[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2FpgaImage(entry, context)
  );
};

const deserializeAws_ec2FpgaImageState = (
  output: any,
  context: __SerdeContext
): FpgaImageState => {
  let contents: any = {
    __type: "FpgaImageState",
    Code: undefined,
    Message: undefined
  };
  if (output["code"] !== undefined) {
    contents.Code = output["code"];
  }
  if (output["message"] !== undefined) {
    contents.Message = output["message"];
  }
  return contents;
};

const deserializeAws_ec2FpgaInfo = (
  output: any,
  context: __SerdeContext
): FpgaInfo => {
  let contents: any = {
    __type: "FpgaInfo",
    Fpgas: undefined,
    TotalFpgaMemoryInMiB: undefined
  };
  if (output.fpgas === "") {
    contents.Fpgas = [];
  }
  if (output["fpgas"] !== undefined && output["fpgas"]["item"] !== undefined) {
    contents.Fpgas = deserializeAws_ec2FpgaDeviceInfoList(
      __getArrayIfSingleItem(output["fpgas"]["item"]),
      context
    );
  }
  if (output["totalFpgaMemoryInMiB"] !== undefined) {
    contents.TotalFpgaMemoryInMiB = parseInt(output["totalFpgaMemoryInMiB"]);
  }
  return contents;
};

const deserializeAws_ec2GetAssociatedIpv6PoolCidrsResult = (
  output: any,
  context: __SerdeContext
): GetAssociatedIpv6PoolCidrsResult => {
  let contents: any = {
    __type: "GetAssociatedIpv6PoolCidrsResult",
    Ipv6CidrAssociations: undefined,
    NextToken: undefined
  };
  if (output.ipv6CidrAssociationSet === "") {
    contents.Ipv6CidrAssociations = [];
  }
  if (
    output["ipv6CidrAssociationSet"] !== undefined &&
    output["ipv6CidrAssociationSet"]["item"] !== undefined
  ) {
    contents.Ipv6CidrAssociations = deserializeAws_ec2Ipv6CidrAssociationSet(
      __getArrayIfSingleItem(output["ipv6CidrAssociationSet"]["item"]),
      context
    );
  }
  if (output["nextToken"] !== undefined) {
    contents.NextToken = output["nextToken"];
  }
  return contents;
};

const deserializeAws_ec2GetCapacityReservationUsageResult = (
  output: any,
  context: __SerdeContext
): GetCapacityReservationUsageResult => {
  let contents: any = {
    __type: "GetCapacityReservationUsageResult",
    AvailableInstanceCount: undefined,
    CapacityReservationId: undefined,
    InstanceType: undefined,
    InstanceUsages: undefined,
    NextToken: undefined,
    State: undefined,
    TotalInstanceCount: undefined
  };
  if (output["availableInstanceCount"] !== undefined) {
    contents.AvailableInstanceCount = parseInt(
      output["availableInstanceCount"]
    );
  }
  if (output["capacityReservationId"] !== undefined) {
    contents.CapacityReservationId = output["capacityReservationId"];
  }
  if (output["instanceType"] !== undefined) {
    contents.InstanceType = output["instanceType"];
  }
  if (output.instanceUsageSet === "") {
    contents.InstanceUsages = [];
  }
  if (
    output["instanceUsageSet"] !== undefined &&
    output["instanceUsageSet"]["item"] !== undefined
  ) {
    contents.InstanceUsages = deserializeAws_ec2InstanceUsageSet(
      __getArrayIfSingleItem(output["instanceUsageSet"]["item"]),
      context
    );
  }
  if (output["nextToken"] !== undefined) {
    contents.NextToken = output["nextToken"];
  }
  if (output["state"] !== undefined) {
    contents.State = output["state"];
  }
  if (output["totalInstanceCount"] !== undefined) {
    contents.TotalInstanceCount = parseInt(output["totalInstanceCount"]);
  }
  return contents;
};

const deserializeAws_ec2GetCoipPoolUsageResult = (
  output: any,
  context: __SerdeContext
): GetCoipPoolUsageResult => {
  let contents: any = {
    __type: "GetCoipPoolUsageResult",
    CoipAddressUsages: undefined,
    CoipPoolId: undefined,
    LocalGatewayRouteTableId: undefined
  };
  if (output.coipAddressUsageSet === "") {
    contents.CoipAddressUsages = [];
  }
  if (
    output["coipAddressUsageSet"] !== undefined &&
    output["coipAddressUsageSet"]["item"] !== undefined
  ) {
    contents.CoipAddressUsages = deserializeAws_ec2CoipAddressUsageSet(
      __getArrayIfSingleItem(output["coipAddressUsageSet"]["item"]),
      context
    );
  }
  if (output["coipPoolId"] !== undefined) {
    contents.CoipPoolId = output["coipPoolId"];
  }
  if (output["localGatewayRouteTableId"] !== undefined) {
    contents.LocalGatewayRouteTableId = output["localGatewayRouteTableId"];
  }
  return contents;
};

const deserializeAws_ec2GetConsoleOutputResult = (
  output: any,
  context: __SerdeContext
): GetConsoleOutputResult => {
  let contents: any = {
    __type: "GetConsoleOutputResult",
    InstanceId: undefined,
    Output: undefined,
    Timestamp: undefined
  };
  if (output["instanceId"] !== undefined) {
    contents.InstanceId = output["instanceId"];
  }
  if (output["output"] !== undefined) {
    contents.Output = output["output"];
  }
  if (output["timestamp"] !== undefined) {
    contents.Timestamp = new Date(output["timestamp"]);
  }
  return contents;
};

const deserializeAws_ec2GetConsoleScreenshotResult = (
  output: any,
  context: __SerdeContext
): GetConsoleScreenshotResult => {
  let contents: any = {
    __type: "GetConsoleScreenshotResult",
    ImageData: undefined,
    InstanceId: undefined
  };
  if (output["imageData"] !== undefined) {
    contents.ImageData = output["imageData"];
  }
  if (output["instanceId"] !== undefined) {
    contents.InstanceId = output["instanceId"];
  }
  return contents;
};

const deserializeAws_ec2GetDefaultCreditSpecificationResult = (
  output: any,
  context: __SerdeContext
): GetDefaultCreditSpecificationResult => {
  let contents: any = {
    __type: "GetDefaultCreditSpecificationResult",
    InstanceFamilyCreditSpecification: undefined
  };
  if (output["instanceFamilyCreditSpecification"] !== undefined) {
    contents.InstanceFamilyCreditSpecification = deserializeAws_ec2InstanceFamilyCreditSpecification(
      output["instanceFamilyCreditSpecification"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2GetEbsDefaultKmsKeyIdResult = (
  output: any,
  context: __SerdeContext
): GetEbsDefaultKmsKeyIdResult => {
  let contents: any = {
    __type: "GetEbsDefaultKmsKeyIdResult",
    KmsKeyId: undefined
  };
  if (output["kmsKeyId"] !== undefined) {
    contents.KmsKeyId = output["kmsKeyId"];
  }
  return contents;
};

const deserializeAws_ec2GetEbsEncryptionByDefaultResult = (
  output: any,
  context: __SerdeContext
): GetEbsEncryptionByDefaultResult => {
  let contents: any = {
    __type: "GetEbsEncryptionByDefaultResult",
    EbsEncryptionByDefault: undefined
  };
  if (output["ebsEncryptionByDefault"] !== undefined) {
    contents.EbsEncryptionByDefault =
      output["ebsEncryptionByDefault"] == "true";
  }
  return contents;
};

const deserializeAws_ec2GetHostReservationPurchasePreviewResult = (
  output: any,
  context: __SerdeContext
): GetHostReservationPurchasePreviewResult => {
  let contents: any = {
    __type: "GetHostReservationPurchasePreviewResult",
    CurrencyCode: undefined,
    Purchase: undefined,
    TotalHourlyPrice: undefined,
    TotalUpfrontPrice: undefined
  };
  if (output["currencyCode"] !== undefined) {
    contents.CurrencyCode = output["currencyCode"];
  }
  if (output.purchase === "") {
    contents.Purchase = [];
  }
  if (
    output["purchase"] !== undefined &&
    output["purchase"]["item"] !== undefined
  ) {
    contents.Purchase = deserializeAws_ec2PurchaseSet(
      __getArrayIfSingleItem(output["purchase"]["item"]),
      context
    );
  }
  if (output["totalHourlyPrice"] !== undefined) {
    contents.TotalHourlyPrice = output["totalHourlyPrice"];
  }
  if (output["totalUpfrontPrice"] !== undefined) {
    contents.TotalUpfrontPrice = output["totalUpfrontPrice"];
  }
  return contents;
};

const deserializeAws_ec2GetLaunchTemplateDataResult = (
  output: any,
  context: __SerdeContext
): GetLaunchTemplateDataResult => {
  let contents: any = {
    __type: "GetLaunchTemplateDataResult",
    LaunchTemplateData: undefined
  };
  if (output["launchTemplateData"] !== undefined) {
    contents.LaunchTemplateData = deserializeAws_ec2ResponseLaunchTemplateData(
      output["launchTemplateData"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2GetPasswordDataResult = (
  output: any,
  context: __SerdeContext
): GetPasswordDataResult => {
  let contents: any = {
    __type: "GetPasswordDataResult",
    InstanceId: undefined,
    PasswordData: undefined,
    Timestamp: undefined
  };
  if (output["instanceId"] !== undefined) {
    contents.InstanceId = output["instanceId"];
  }
  if (output["passwordData"] !== undefined) {
    contents.PasswordData = output["passwordData"];
  }
  if (output["timestamp"] !== undefined) {
    contents.Timestamp = new Date(output["timestamp"]);
  }
  return contents;
};

const deserializeAws_ec2GetReservedInstancesExchangeQuoteResult = (
  output: any,
  context: __SerdeContext
): GetReservedInstancesExchangeQuoteResult => {
  let contents: any = {
    __type: "GetReservedInstancesExchangeQuoteResult",
    CurrencyCode: undefined,
    IsValidExchange: undefined,
    OutputReservedInstancesWillExpireAt: undefined,
    PaymentDue: undefined,
    ReservedInstanceValueRollup: undefined,
    ReservedInstanceValueSet: undefined,
    TargetConfigurationValueRollup: undefined,
    TargetConfigurationValueSet: undefined,
    ValidationFailureReason: undefined
  };
  if (output["currencyCode"] !== undefined) {
    contents.CurrencyCode = output["currencyCode"];
  }
  if (output["isValidExchange"] !== undefined) {
    contents.IsValidExchange = output["isValidExchange"] == "true";
  }
  if (output["outputReservedInstancesWillExpireAt"] !== undefined) {
    contents.OutputReservedInstancesWillExpireAt = new Date(
      output["outputReservedInstancesWillExpireAt"]
    );
  }
  if (output["paymentDue"] !== undefined) {
    contents.PaymentDue = output["paymentDue"];
  }
  if (output["reservedInstanceValueRollup"] !== undefined) {
    contents.ReservedInstanceValueRollup = deserializeAws_ec2ReservationValue(
      output["reservedInstanceValueRollup"],
      context
    );
  }
  if (output.reservedInstanceValueSet === "") {
    contents.ReservedInstanceValueSet = [];
  }
  if (
    output["reservedInstanceValueSet"] !== undefined &&
    output["reservedInstanceValueSet"]["item"] !== undefined
  ) {
    contents.ReservedInstanceValueSet = deserializeAws_ec2ReservedInstanceReservationValueSet(
      __getArrayIfSingleItem(output["reservedInstanceValueSet"]["item"]),
      context
    );
  }
  if (output["targetConfigurationValueRollup"] !== undefined) {
    contents.TargetConfigurationValueRollup = deserializeAws_ec2ReservationValue(
      output["targetConfigurationValueRollup"],
      context
    );
  }
  if (output.targetConfigurationValueSet === "") {
    contents.TargetConfigurationValueSet = [];
  }
  if (
    output["targetConfigurationValueSet"] !== undefined &&
    output["targetConfigurationValueSet"]["item"] !== undefined
  ) {
    contents.TargetConfigurationValueSet = deserializeAws_ec2TargetReservationValueSet(
      __getArrayIfSingleItem(output["targetConfigurationValueSet"]["item"]),
      context
    );
  }
  if (output["validationFailureReason"] !== undefined) {
    contents.ValidationFailureReason = output["validationFailureReason"];
  }
  return contents;
};

const deserializeAws_ec2GetTransitGatewayAttachmentPropagationsResult = (
  output: any,
  context: __SerdeContext
): GetTransitGatewayAttachmentPropagationsResult => {
  let contents: any = {
    __type: "GetTransitGatewayAttachmentPropagationsResult",
    NextToken: undefined,
    TransitGatewayAttachmentPropagations: undefined
  };
  if (output["nextToken"] !== undefined) {
    contents.NextToken = output["nextToken"];
  }
  if (output.transitGatewayAttachmentPropagations === "") {
    contents.TransitGatewayAttachmentPropagations = [];
  }
  if (
    output["transitGatewayAttachmentPropagations"] !== undefined &&
    output["transitGatewayAttachmentPropagations"]["item"] !== undefined
  ) {
    contents.TransitGatewayAttachmentPropagations = deserializeAws_ec2TransitGatewayAttachmentPropagationList(
      __getArrayIfSingleItem(
        output["transitGatewayAttachmentPropagations"]["item"]
      ),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2GetTransitGatewayMulticastDomainAssociationsResult = (
  output: any,
  context: __SerdeContext
): GetTransitGatewayMulticastDomainAssociationsResult => {
  let contents: any = {
    __type: "GetTransitGatewayMulticastDomainAssociationsResult",
    MulticastDomainAssociations: undefined,
    NextToken: undefined
  };
  if (output.multicastDomainAssociations === "") {
    contents.MulticastDomainAssociations = [];
  }
  if (
    output["multicastDomainAssociations"] !== undefined &&
    output["multicastDomainAssociations"]["item"] !== undefined
  ) {
    contents.MulticastDomainAssociations = deserializeAws_ec2TransitGatewayMulticastDomainAssociationList(
      __getArrayIfSingleItem(output["multicastDomainAssociations"]["item"]),
      context
    );
  }
  if (output["nextToken"] !== undefined) {
    contents.NextToken = output["nextToken"];
  }
  return contents;
};

const deserializeAws_ec2GetTransitGatewayRouteTableAssociationsResult = (
  output: any,
  context: __SerdeContext
): GetTransitGatewayRouteTableAssociationsResult => {
  let contents: any = {
    __type: "GetTransitGatewayRouteTableAssociationsResult",
    Associations: undefined,
    NextToken: undefined
  };
  if (output.associations === "") {
    contents.Associations = [];
  }
  if (
    output["associations"] !== undefined &&
    output["associations"]["item"] !== undefined
  ) {
    contents.Associations = deserializeAws_ec2TransitGatewayRouteTableAssociationList(
      __getArrayIfSingleItem(output["associations"]["item"]),
      context
    );
  }
  if (output["nextToken"] !== undefined) {
    contents.NextToken = output["nextToken"];
  }
  return contents;
};

const deserializeAws_ec2GetTransitGatewayRouteTablePropagationsResult = (
  output: any,
  context: __SerdeContext
): GetTransitGatewayRouteTablePropagationsResult => {
  let contents: any = {
    __type: "GetTransitGatewayRouteTablePropagationsResult",
    NextToken: undefined,
    TransitGatewayRouteTablePropagations: undefined
  };
  if (output["nextToken"] !== undefined) {
    contents.NextToken = output["nextToken"];
  }
  if (output.transitGatewayRouteTablePropagations === "") {
    contents.TransitGatewayRouteTablePropagations = [];
  }
  if (
    output["transitGatewayRouteTablePropagations"] !== undefined &&
    output["transitGatewayRouteTablePropagations"]["item"] !== undefined
  ) {
    contents.TransitGatewayRouteTablePropagations = deserializeAws_ec2TransitGatewayRouteTablePropagationList(
      __getArrayIfSingleItem(
        output["transitGatewayRouteTablePropagations"]["item"]
      ),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2GpuDeviceInfo = (
  output: any,
  context: __SerdeContext
): GpuDeviceInfo => {
  let contents: any = {
    __type: "GpuDeviceInfo",
    Count: undefined,
    Manufacturer: undefined,
    MemoryInfo: undefined,
    Name: undefined
  };
  if (output["count"] !== undefined) {
    contents.Count = parseInt(output["count"]);
  }
  if (output["manufacturer"] !== undefined) {
    contents.Manufacturer = output["manufacturer"];
  }
  if (output["memoryInfo"] !== undefined) {
    contents.MemoryInfo = deserializeAws_ec2GpuDeviceMemoryInfo(
      output["memoryInfo"],
      context
    );
  }
  if (output["name"] !== undefined) {
    contents.Name = output["name"];
  }
  return contents;
};

const deserializeAws_ec2GpuDeviceInfoList = (
  output: any,
  context: __SerdeContext
): GpuDeviceInfo[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2GpuDeviceInfo(entry, context)
  );
};

const deserializeAws_ec2GpuDeviceMemoryInfo = (
  output: any,
  context: __SerdeContext
): GpuDeviceMemoryInfo => {
  let contents: any = {
    __type: "GpuDeviceMemoryInfo",
    SizeInMiB: undefined
  };
  if (output["sizeInMiB"] !== undefined) {
    contents.SizeInMiB = parseInt(output["sizeInMiB"]);
  }
  return contents;
};

const deserializeAws_ec2GpuInfo = (
  output: any,
  context: __SerdeContext
): GpuInfo => {
  let contents: any = {
    __type: "GpuInfo",
    Gpus: undefined,
    TotalGpuMemoryInMiB: undefined
  };
  if (output.gpus === "") {
    contents.Gpus = [];
  }
  if (output["gpus"] !== undefined && output["gpus"]["item"] !== undefined) {
    contents.Gpus = deserializeAws_ec2GpuDeviceInfoList(
      __getArrayIfSingleItem(output["gpus"]["item"]),
      context
    );
  }
  if (output["totalGpuMemoryInMiB"] !== undefined) {
    contents.TotalGpuMemoryInMiB = parseInt(output["totalGpuMemoryInMiB"]);
  }
  return contents;
};

const deserializeAws_ec2GroupIdentifier = (
  output: any,
  context: __SerdeContext
): GroupIdentifier => {
  let contents: any = {
    __type: "GroupIdentifier",
    GroupId: undefined,
    GroupName: undefined
  };
  if (output["groupId"] !== undefined) {
    contents.GroupId = output["groupId"];
  }
  if (output["groupName"] !== undefined) {
    contents.GroupName = output["groupName"];
  }
  return contents;
};

const deserializeAws_ec2GroupIdentifierList = (
  output: any,
  context: __SerdeContext
): GroupIdentifier[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2GroupIdentifier(entry, context)
  );
};

const deserializeAws_ec2GroupIdentifierSet = (
  output: any,
  context: __SerdeContext
): SecurityGroupIdentifier[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2SecurityGroupIdentifier(entry, context)
  );
};

const deserializeAws_ec2GroupIdStringList = (
  output: any,
  context: __SerdeContext
): string[] => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_ec2HibernationOptions = (
  output: any,
  context: __SerdeContext
): HibernationOptions => {
  let contents: any = {
    __type: "HibernationOptions",
    Configured: undefined
  };
  if (output["configured"] !== undefined) {
    contents.Configured = output["configured"] == "true";
  }
  return contents;
};

const deserializeAws_ec2HistoryRecord = (
  output: any,
  context: __SerdeContext
): HistoryRecord => {
  let contents: any = {
    __type: "HistoryRecord",
    EventInformation: undefined,
    EventType: undefined,
    Timestamp: undefined
  };
  if (output["eventInformation"] !== undefined) {
    contents.EventInformation = deserializeAws_ec2EventInformation(
      output["eventInformation"],
      context
    );
  }
  if (output["eventType"] !== undefined) {
    contents.EventType = output["eventType"];
  }
  if (output["timestamp"] !== undefined) {
    contents.Timestamp = new Date(output["timestamp"]);
  }
  return contents;
};

const deserializeAws_ec2HistoryRecordEntry = (
  output: any,
  context: __SerdeContext
): HistoryRecordEntry => {
  let contents: any = {
    __type: "HistoryRecordEntry",
    EventInformation: undefined,
    EventType: undefined,
    Timestamp: undefined
  };
  if (output["eventInformation"] !== undefined) {
    contents.EventInformation = deserializeAws_ec2EventInformation(
      output["eventInformation"],
      context
    );
  }
  if (output["eventType"] !== undefined) {
    contents.EventType = output["eventType"];
  }
  if (output["timestamp"] !== undefined) {
    contents.Timestamp = new Date(output["timestamp"]);
  }
  return contents;
};

const deserializeAws_ec2HistoryRecords = (
  output: any,
  context: __SerdeContext
): HistoryRecord[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2HistoryRecord(entry, context)
  );
};

const deserializeAws_ec2HistoryRecordSet = (
  output: any,
  context: __SerdeContext
): HistoryRecordEntry[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2HistoryRecordEntry(entry, context)
  );
};

const deserializeAws_ec2Host = (output: any, context: __SerdeContext): Host => {
  let contents: any = {
    __type: "Host",
    AllocationTime: undefined,
    AllowsMultipleInstanceTypes: undefined,
    AutoPlacement: undefined,
    AvailabilityZone: undefined,
    AvailabilityZoneId: undefined,
    AvailableCapacity: undefined,
    ClientToken: undefined,
    HostId: undefined,
    HostProperties: undefined,
    HostRecovery: undefined,
    HostReservationId: undefined,
    Instances: undefined,
    MemberOfServiceLinkedResourceGroup: undefined,
    OwnerId: undefined,
    ReleaseTime: undefined,
    State: undefined,
    Tags: undefined
  };
  if (output["allocationTime"] !== undefined) {
    contents.AllocationTime = new Date(output["allocationTime"]);
  }
  if (output["allowsMultipleInstanceTypes"] !== undefined) {
    contents.AllowsMultipleInstanceTypes =
      output["allowsMultipleInstanceTypes"];
  }
  if (output["autoPlacement"] !== undefined) {
    contents.AutoPlacement = output["autoPlacement"];
  }
  if (output["availabilityZone"] !== undefined) {
    contents.AvailabilityZone = output["availabilityZone"];
  }
  if (output["availabilityZoneId"] !== undefined) {
    contents.AvailabilityZoneId = output["availabilityZoneId"];
  }
  if (output["availableCapacity"] !== undefined) {
    contents.AvailableCapacity = deserializeAws_ec2AvailableCapacity(
      output["availableCapacity"],
      context
    );
  }
  if (output["clientToken"] !== undefined) {
    contents.ClientToken = output["clientToken"];
  }
  if (output["hostId"] !== undefined) {
    contents.HostId = output["hostId"];
  }
  if (output["hostProperties"] !== undefined) {
    contents.HostProperties = deserializeAws_ec2HostProperties(
      output["hostProperties"],
      context
    );
  }
  if (output["hostRecovery"] !== undefined) {
    contents.HostRecovery = output["hostRecovery"];
  }
  if (output["hostReservationId"] !== undefined) {
    contents.HostReservationId = output["hostReservationId"];
  }
  if (output.instances === "") {
    contents.Instances = [];
  }
  if (
    output["instances"] !== undefined &&
    output["instances"]["item"] !== undefined
  ) {
    contents.Instances = deserializeAws_ec2HostInstanceList(
      __getArrayIfSingleItem(output["instances"]["item"]),
      context
    );
  }
  if (output["memberOfServiceLinkedResourceGroup"] !== undefined) {
    contents.MemberOfServiceLinkedResourceGroup =
      output["memberOfServiceLinkedResourceGroup"] == "true";
  }
  if (output["ownerId"] !== undefined) {
    contents.OwnerId = output["ownerId"];
  }
  if (output["releaseTime"] !== undefined) {
    contents.ReleaseTime = new Date(output["releaseTime"]);
  }
  if (output["state"] !== undefined) {
    contents.State = output["state"];
  }
  if (output.tagSet === "") {
    contents.Tags = [];
  }
  if (
    output["tagSet"] !== undefined &&
    output["tagSet"]["item"] !== undefined
  ) {
    contents.Tags = deserializeAws_ec2TagList(
      __getArrayIfSingleItem(output["tagSet"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2HostInstance = (
  output: any,
  context: __SerdeContext
): HostInstance => {
  let contents: any = {
    __type: "HostInstance",
    InstanceId: undefined,
    InstanceType: undefined,
    OwnerId: undefined
  };
  if (output["instanceId"] !== undefined) {
    contents.InstanceId = output["instanceId"];
  }
  if (output["instanceType"] !== undefined) {
    contents.InstanceType = output["instanceType"];
  }
  if (output["ownerId"] !== undefined) {
    contents.OwnerId = output["ownerId"];
  }
  return contents;
};

const deserializeAws_ec2HostInstanceList = (
  output: any,
  context: __SerdeContext
): HostInstance[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2HostInstance(entry, context)
  );
};

const deserializeAws_ec2HostList = (
  output: any,
  context: __SerdeContext
): Host[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2Host(entry, context)
  );
};

const deserializeAws_ec2HostOffering = (
  output: any,
  context: __SerdeContext
): HostOffering => {
  let contents: any = {
    __type: "HostOffering",
    CurrencyCode: undefined,
    Duration: undefined,
    HourlyPrice: undefined,
    InstanceFamily: undefined,
    OfferingId: undefined,
    PaymentOption: undefined,
    UpfrontPrice: undefined
  };
  if (output["currencyCode"] !== undefined) {
    contents.CurrencyCode = output["currencyCode"];
  }
  if (output["duration"] !== undefined) {
    contents.Duration = parseInt(output["duration"]);
  }
  if (output["hourlyPrice"] !== undefined) {
    contents.HourlyPrice = output["hourlyPrice"];
  }
  if (output["instanceFamily"] !== undefined) {
    contents.InstanceFamily = output["instanceFamily"];
  }
  if (output["offeringId"] !== undefined) {
    contents.OfferingId = output["offeringId"];
  }
  if (output["paymentOption"] !== undefined) {
    contents.PaymentOption = output["paymentOption"];
  }
  if (output["upfrontPrice"] !== undefined) {
    contents.UpfrontPrice = output["upfrontPrice"];
  }
  return contents;
};

const deserializeAws_ec2HostOfferingSet = (
  output: any,
  context: __SerdeContext
): HostOffering[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2HostOffering(entry, context)
  );
};

const deserializeAws_ec2HostProperties = (
  output: any,
  context: __SerdeContext
): HostProperties => {
  let contents: any = {
    __type: "HostProperties",
    Cores: undefined,
    InstanceFamily: undefined,
    InstanceType: undefined,
    Sockets: undefined,
    TotalVCpus: undefined
  };
  if (output["cores"] !== undefined) {
    contents.Cores = parseInt(output["cores"]);
  }
  if (output["instanceFamily"] !== undefined) {
    contents.InstanceFamily = output["instanceFamily"];
  }
  if (output["instanceType"] !== undefined) {
    contents.InstanceType = output["instanceType"];
  }
  if (output["sockets"] !== undefined) {
    contents.Sockets = parseInt(output["sockets"]);
  }
  if (output["totalVCpus"] !== undefined) {
    contents.TotalVCpus = parseInt(output["totalVCpus"]);
  }
  return contents;
};

const deserializeAws_ec2HostReservation = (
  output: any,
  context: __SerdeContext
): HostReservation => {
  let contents: any = {
    __type: "HostReservation",
    Count: undefined,
    CurrencyCode: undefined,
    Duration: undefined,
    End: undefined,
    HostIdSet: undefined,
    HostReservationId: undefined,
    HourlyPrice: undefined,
    InstanceFamily: undefined,
    OfferingId: undefined,
    PaymentOption: undefined,
    Start: undefined,
    State: undefined,
    Tags: undefined,
    UpfrontPrice: undefined
  };
  if (output["count"] !== undefined) {
    contents.Count = parseInt(output["count"]);
  }
  if (output["currencyCode"] !== undefined) {
    contents.CurrencyCode = output["currencyCode"];
  }
  if (output["duration"] !== undefined) {
    contents.Duration = parseInt(output["duration"]);
  }
  if (output["end"] !== undefined) {
    contents.End = new Date(output["end"]);
  }
  if (output.hostIdSet === "") {
    contents.HostIdSet = [];
  }
  if (
    output["hostIdSet"] !== undefined &&
    output["hostIdSet"]["item"] !== undefined
  ) {
    contents.HostIdSet = deserializeAws_ec2ResponseHostIdSet(
      __getArrayIfSingleItem(output["hostIdSet"]["item"]),
      context
    );
  }
  if (output["hostReservationId"] !== undefined) {
    contents.HostReservationId = output["hostReservationId"];
  }
  if (output["hourlyPrice"] !== undefined) {
    contents.HourlyPrice = output["hourlyPrice"];
  }
  if (output["instanceFamily"] !== undefined) {
    contents.InstanceFamily = output["instanceFamily"];
  }
  if (output["offeringId"] !== undefined) {
    contents.OfferingId = output["offeringId"];
  }
  if (output["paymentOption"] !== undefined) {
    contents.PaymentOption = output["paymentOption"];
  }
  if (output["start"] !== undefined) {
    contents.Start = new Date(output["start"]);
  }
  if (output["state"] !== undefined) {
    contents.State = output["state"];
  }
  if (output.tagSet === "") {
    contents.Tags = [];
  }
  if (
    output["tagSet"] !== undefined &&
    output["tagSet"]["item"] !== undefined
  ) {
    contents.Tags = deserializeAws_ec2TagList(
      __getArrayIfSingleItem(output["tagSet"]["item"]),
      context
    );
  }
  if (output["upfrontPrice"] !== undefined) {
    contents.UpfrontPrice = output["upfrontPrice"];
  }
  return contents;
};

const deserializeAws_ec2HostReservationSet = (
  output: any,
  context: __SerdeContext
): HostReservation[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2HostReservation(entry, context)
  );
};

const deserializeAws_ec2IamInstanceProfile = (
  output: any,
  context: __SerdeContext
): IamInstanceProfile => {
  let contents: any = {
    __type: "IamInstanceProfile",
    Arn: undefined,
    Id: undefined
  };
  if (output["arn"] !== undefined) {
    contents.Arn = output["arn"];
  }
  if (output["id"] !== undefined) {
    contents.Id = output["id"];
  }
  return contents;
};

const deserializeAws_ec2IamInstanceProfileAssociation = (
  output: any,
  context: __SerdeContext
): IamInstanceProfileAssociation => {
  let contents: any = {
    __type: "IamInstanceProfileAssociation",
    AssociationId: undefined,
    IamInstanceProfile: undefined,
    InstanceId: undefined,
    State: undefined,
    Timestamp: undefined
  };
  if (output["associationId"] !== undefined) {
    contents.AssociationId = output["associationId"];
  }
  if (output["iamInstanceProfile"] !== undefined) {
    contents.IamInstanceProfile = deserializeAws_ec2IamInstanceProfile(
      output["iamInstanceProfile"],
      context
    );
  }
  if (output["instanceId"] !== undefined) {
    contents.InstanceId = output["instanceId"];
  }
  if (output["state"] !== undefined) {
    contents.State = output["state"];
  }
  if (output["timestamp"] !== undefined) {
    contents.Timestamp = new Date(output["timestamp"]);
  }
  return contents;
};

const deserializeAws_ec2IamInstanceProfileAssociationSet = (
  output: any,
  context: __SerdeContext
): IamInstanceProfileAssociation[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2IamInstanceProfileAssociation(entry, context)
  );
};

const deserializeAws_ec2IamInstanceProfileSpecification = (
  output: any,
  context: __SerdeContext
): IamInstanceProfileSpecification => {
  let contents: any = {
    __type: "IamInstanceProfileSpecification",
    Arn: undefined,
    Name: undefined
  };
  if (output["arn"] !== undefined) {
    contents.Arn = output["arn"];
  }
  if (output["name"] !== undefined) {
    contents.Name = output["name"];
  }
  return contents;
};

const deserializeAws_ec2IcmpTypeCode = (
  output: any,
  context: __SerdeContext
): IcmpTypeCode => {
  let contents: any = {
    __type: "IcmpTypeCode",
    Code: undefined,
    Type: undefined
  };
  if (output["code"] !== undefined) {
    contents.Code = parseInt(output["code"]);
  }
  if (output["type"] !== undefined) {
    contents.Type = parseInt(output["type"]);
  }
  return contents;
};

const deserializeAws_ec2IdFormat = (
  output: any,
  context: __SerdeContext
): IdFormat => {
  let contents: any = {
    __type: "IdFormat",
    Deadline: undefined,
    Resource: undefined,
    UseLongIds: undefined
  };
  if (output["deadline"] !== undefined) {
    contents.Deadline = new Date(output["deadline"]);
  }
  if (output["resource"] !== undefined) {
    contents.Resource = output["resource"];
  }
  if (output["useLongIds"] !== undefined) {
    contents.UseLongIds = output["useLongIds"] == "true";
  }
  return contents;
};

const deserializeAws_ec2IdFormatList = (
  output: any,
  context: __SerdeContext
): IdFormat[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2IdFormat(entry, context)
  );
};

const deserializeAws_ec2IKEVersionsList = (
  output: any,
  context: __SerdeContext
): IKEVersionsListValue[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2IKEVersionsListValue(entry, context)
  );
};

const deserializeAws_ec2IKEVersionsListValue = (
  output: any,
  context: __SerdeContext
): IKEVersionsListValue => {
  let contents: any = {
    __type: "IKEVersionsListValue",
    Value: undefined
  };
  if (output["value"] !== undefined) {
    contents.Value = output["value"];
  }
  return contents;
};

const deserializeAws_ec2Image = (
  output: any,
  context: __SerdeContext
): Image => {
  let contents: any = {
    __type: "Image",
    Architecture: undefined,
    BlockDeviceMappings: undefined,
    CreationDate: undefined,
    Description: undefined,
    EnaSupport: undefined,
    Hypervisor: undefined,
    ImageId: undefined,
    ImageLocation: undefined,
    ImageOwnerAlias: undefined,
    ImageType: undefined,
    KernelId: undefined,
    Name: undefined,
    OwnerId: undefined,
    Platform: undefined,
    ProductCodes: undefined,
    Public: undefined,
    RamdiskId: undefined,
    RootDeviceName: undefined,
    RootDeviceType: undefined,
    SriovNetSupport: undefined,
    State: undefined,
    StateReason: undefined,
    Tags: undefined,
    VirtualizationType: undefined
  };
  if (output["architecture"] !== undefined) {
    contents.Architecture = output["architecture"];
  }
  if (output.blockDeviceMapping === "") {
    contents.BlockDeviceMappings = [];
  }
  if (
    output["blockDeviceMapping"] !== undefined &&
    output["blockDeviceMapping"]["item"] !== undefined
  ) {
    contents.BlockDeviceMappings = deserializeAws_ec2BlockDeviceMappingList(
      __getArrayIfSingleItem(output["blockDeviceMapping"]["item"]),
      context
    );
  }
  if (output["creationDate"] !== undefined) {
    contents.CreationDate = output["creationDate"];
  }
  if (output["description"] !== undefined) {
    contents.Description = output["description"];
  }
  if (output["enaSupport"] !== undefined) {
    contents.EnaSupport = output["enaSupport"] == "true";
  }
  if (output["hypervisor"] !== undefined) {
    contents.Hypervisor = output["hypervisor"];
  }
  if (output["imageId"] !== undefined) {
    contents.ImageId = output["imageId"];
  }
  if (output["imageLocation"] !== undefined) {
    contents.ImageLocation = output["imageLocation"];
  }
  if (output["imageOwnerAlias"] !== undefined) {
    contents.ImageOwnerAlias = output["imageOwnerAlias"];
  }
  if (output["imageType"] !== undefined) {
    contents.ImageType = output["imageType"];
  }
  if (output["kernelId"] !== undefined) {
    contents.KernelId = output["kernelId"];
  }
  if (output["name"] !== undefined) {
    contents.Name = output["name"];
  }
  if (output["imageOwnerId"] !== undefined) {
    contents.OwnerId = output["imageOwnerId"];
  }
  if (output["platform"] !== undefined) {
    contents.Platform = output["platform"];
  }
  if (output.productCodes === "") {
    contents.ProductCodes = [];
  }
  if (
    output["productCodes"] !== undefined &&
    output["productCodes"]["item"] !== undefined
  ) {
    contents.ProductCodes = deserializeAws_ec2ProductCodeList(
      __getArrayIfSingleItem(output["productCodes"]["item"]),
      context
    );
  }
  if (output["isPublic"] !== undefined) {
    contents.Public = output["isPublic"] == "true";
  }
  if (output["ramdiskId"] !== undefined) {
    contents.RamdiskId = output["ramdiskId"];
  }
  if (output["rootDeviceName"] !== undefined) {
    contents.RootDeviceName = output["rootDeviceName"];
  }
  if (output["rootDeviceType"] !== undefined) {
    contents.RootDeviceType = output["rootDeviceType"];
  }
  if (output["sriovNetSupport"] !== undefined) {
    contents.SriovNetSupport = output["sriovNetSupport"];
  }
  if (output["imageState"] !== undefined) {
    contents.State = output["imageState"];
  }
  if (output["stateReason"] !== undefined) {
    contents.StateReason = deserializeAws_ec2StateReason(
      output["stateReason"],
      context
    );
  }
  if (output.tagSet === "") {
    contents.Tags = [];
  }
  if (
    output["tagSet"] !== undefined &&
    output["tagSet"]["item"] !== undefined
  ) {
    contents.Tags = deserializeAws_ec2TagList(
      __getArrayIfSingleItem(output["tagSet"]["item"]),
      context
    );
  }
  if (output["virtualizationType"] !== undefined) {
    contents.VirtualizationType = output["virtualizationType"];
  }
  return contents;
};

const deserializeAws_ec2ImageAttribute = (
  output: any,
  context: __SerdeContext
): ImageAttribute => {
  let contents: any = {
    __type: "ImageAttribute",
    BlockDeviceMappings: undefined,
    Description: undefined,
    ImageId: undefined,
    KernelId: undefined,
    LaunchPermissions: undefined,
    ProductCodes: undefined,
    RamdiskId: undefined,
    SriovNetSupport: undefined
  };
  if (output.blockDeviceMapping === "") {
    contents.BlockDeviceMappings = [];
  }
  if (
    output["blockDeviceMapping"] !== undefined &&
    output["blockDeviceMapping"]["item"] !== undefined
  ) {
    contents.BlockDeviceMappings = deserializeAws_ec2BlockDeviceMappingList(
      __getArrayIfSingleItem(output["blockDeviceMapping"]["item"]),
      context
    );
  }
  if (output["description"] !== undefined) {
    contents.Description = deserializeAws_ec2AttributeValue(
      output["description"],
      context
    );
  }
  if (output["imageId"] !== undefined) {
    contents.ImageId = output["imageId"];
  }
  if (output["kernel"] !== undefined) {
    contents.KernelId = deserializeAws_ec2AttributeValue(
      output["kernel"],
      context
    );
  }
  if (output.launchPermission === "") {
    contents.LaunchPermissions = [];
  }
  if (
    output["launchPermission"] !== undefined &&
    output["launchPermission"]["item"] !== undefined
  ) {
    contents.LaunchPermissions = deserializeAws_ec2LaunchPermissionList(
      __getArrayIfSingleItem(output["launchPermission"]["item"]),
      context
    );
  }
  if (output.productCodes === "") {
    contents.ProductCodes = [];
  }
  if (
    output["productCodes"] !== undefined &&
    output["productCodes"]["item"] !== undefined
  ) {
    contents.ProductCodes = deserializeAws_ec2ProductCodeList(
      __getArrayIfSingleItem(output["productCodes"]["item"]),
      context
    );
  }
  if (output["ramdisk"] !== undefined) {
    contents.RamdiskId = deserializeAws_ec2AttributeValue(
      output["ramdisk"],
      context
    );
  }
  if (output["sriovNetSupport"] !== undefined) {
    contents.SriovNetSupport = deserializeAws_ec2AttributeValue(
      output["sriovNetSupport"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2ImageList = (
  output: any,
  context: __SerdeContext
): Image[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2Image(entry, context)
  );
};

const deserializeAws_ec2ImportClientVpnClientCertificateRevocationListResult = (
  output: any,
  context: __SerdeContext
): ImportClientVpnClientCertificateRevocationListResult => {
  let contents: any = {
    __type: "ImportClientVpnClientCertificateRevocationListResult",
    Return: undefined
  };
  if (output["return"] !== undefined) {
    contents.Return = output["return"] == "true";
  }
  return contents;
};

const deserializeAws_ec2ImportImageLicenseConfigurationResponse = (
  output: any,
  context: __SerdeContext
): ImportImageLicenseConfigurationResponse => {
  let contents: any = {
    __type: "ImportImageLicenseConfigurationResponse",
    LicenseConfigurationArn: undefined
  };
  if (output["licenseConfigurationArn"] !== undefined) {
    contents.LicenseConfigurationArn = output["licenseConfigurationArn"];
  }
  return contents;
};

const deserializeAws_ec2ImportImageLicenseSpecificationListResponse = (
  output: any,
  context: __SerdeContext
): ImportImageLicenseConfigurationResponse[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2ImportImageLicenseConfigurationResponse(entry, context)
  );
};

const deserializeAws_ec2ImportImageResult = (
  output: any,
  context: __SerdeContext
): ImportImageResult => {
  let contents: any = {
    __type: "ImportImageResult",
    Architecture: undefined,
    Description: undefined,
    Encrypted: undefined,
    Hypervisor: undefined,
    ImageId: undefined,
    ImportTaskId: undefined,
    KmsKeyId: undefined,
    LicenseSpecifications: undefined,
    LicenseType: undefined,
    Platform: undefined,
    Progress: undefined,
    SnapshotDetails: undefined,
    Status: undefined,
    StatusMessage: undefined
  };
  if (output["architecture"] !== undefined) {
    contents.Architecture = output["architecture"];
  }
  if (output["description"] !== undefined) {
    contents.Description = output["description"];
  }
  if (output["encrypted"] !== undefined) {
    contents.Encrypted = output["encrypted"] == "true";
  }
  if (output["hypervisor"] !== undefined) {
    contents.Hypervisor = output["hypervisor"];
  }
  if (output["imageId"] !== undefined) {
    contents.ImageId = output["imageId"];
  }
  if (output["importTaskId"] !== undefined) {
    contents.ImportTaskId = output["importTaskId"];
  }
  if (output["kmsKeyId"] !== undefined) {
    contents.KmsKeyId = output["kmsKeyId"];
  }
  if (output.licenseSpecifications === "") {
    contents.LicenseSpecifications = [];
  }
  if (
    output["licenseSpecifications"] !== undefined &&
    output["licenseSpecifications"]["item"] !== undefined
  ) {
    contents.LicenseSpecifications = deserializeAws_ec2ImportImageLicenseSpecificationListResponse(
      __getArrayIfSingleItem(output["licenseSpecifications"]["item"]),
      context
    );
  }
  if (output["licenseType"] !== undefined) {
    contents.LicenseType = output["licenseType"];
  }
  if (output["platform"] !== undefined) {
    contents.Platform = output["platform"];
  }
  if (output["progress"] !== undefined) {
    contents.Progress = output["progress"];
  }
  if (output.snapshotDetailSet === "") {
    contents.SnapshotDetails = [];
  }
  if (
    output["snapshotDetailSet"] !== undefined &&
    output["snapshotDetailSet"]["item"] !== undefined
  ) {
    contents.SnapshotDetails = deserializeAws_ec2SnapshotDetailList(
      __getArrayIfSingleItem(output["snapshotDetailSet"]["item"]),
      context
    );
  }
  if (output["status"] !== undefined) {
    contents.Status = output["status"];
  }
  if (output["statusMessage"] !== undefined) {
    contents.StatusMessage = output["statusMessage"];
  }
  return contents;
};

const deserializeAws_ec2ImportImageTask = (
  output: any,
  context: __SerdeContext
): ImportImageTask => {
  let contents: any = {
    __type: "ImportImageTask",
    Architecture: undefined,
    Description: undefined,
    Encrypted: undefined,
    Hypervisor: undefined,
    ImageId: undefined,
    ImportTaskId: undefined,
    KmsKeyId: undefined,
    LicenseSpecifications: undefined,
    LicenseType: undefined,
    Platform: undefined,
    Progress: undefined,
    SnapshotDetails: undefined,
    Status: undefined,
    StatusMessage: undefined,
    Tags: undefined
  };
  if (output["architecture"] !== undefined) {
    contents.Architecture = output["architecture"];
  }
  if (output["description"] !== undefined) {
    contents.Description = output["description"];
  }
  if (output["encrypted"] !== undefined) {
    contents.Encrypted = output["encrypted"] == "true";
  }
  if (output["hypervisor"] !== undefined) {
    contents.Hypervisor = output["hypervisor"];
  }
  if (output["imageId"] !== undefined) {
    contents.ImageId = output["imageId"];
  }
  if (output["importTaskId"] !== undefined) {
    contents.ImportTaskId = output["importTaskId"];
  }
  if (output["kmsKeyId"] !== undefined) {
    contents.KmsKeyId = output["kmsKeyId"];
  }
  if (output.licenseSpecifications === "") {
    contents.LicenseSpecifications = [];
  }
  if (
    output["licenseSpecifications"] !== undefined &&
    output["licenseSpecifications"]["item"] !== undefined
  ) {
    contents.LicenseSpecifications = deserializeAws_ec2ImportImageLicenseSpecificationListResponse(
      __getArrayIfSingleItem(output["licenseSpecifications"]["item"]),
      context
    );
  }
  if (output["licenseType"] !== undefined) {
    contents.LicenseType = output["licenseType"];
  }
  if (output["platform"] !== undefined) {
    contents.Platform = output["platform"];
  }
  if (output["progress"] !== undefined) {
    contents.Progress = output["progress"];
  }
  if (output.snapshotDetailSet === "") {
    contents.SnapshotDetails = [];
  }
  if (
    output["snapshotDetailSet"] !== undefined &&
    output["snapshotDetailSet"]["item"] !== undefined
  ) {
    contents.SnapshotDetails = deserializeAws_ec2SnapshotDetailList(
      __getArrayIfSingleItem(output["snapshotDetailSet"]["item"]),
      context
    );
  }
  if (output["status"] !== undefined) {
    contents.Status = output["status"];
  }
  if (output["statusMessage"] !== undefined) {
    contents.StatusMessage = output["statusMessage"];
  }
  if (output.tagSet === "") {
    contents.Tags = [];
  }
  if (
    output["tagSet"] !== undefined &&
    output["tagSet"]["item"] !== undefined
  ) {
    contents.Tags = deserializeAws_ec2TagList(
      __getArrayIfSingleItem(output["tagSet"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2ImportImageTaskList = (
  output: any,
  context: __SerdeContext
): ImportImageTask[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2ImportImageTask(entry, context)
  );
};

const deserializeAws_ec2ImportInstanceResult = (
  output: any,
  context: __SerdeContext
): ImportInstanceResult => {
  let contents: any = {
    __type: "ImportInstanceResult",
    ConversionTask: undefined
  };
  if (output["conversionTask"] !== undefined) {
    contents.ConversionTask = deserializeAws_ec2ConversionTask(
      output["conversionTask"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2ImportInstanceTaskDetails = (
  output: any,
  context: __SerdeContext
): ImportInstanceTaskDetails => {
  let contents: any = {
    __type: "ImportInstanceTaskDetails",
    Description: undefined,
    InstanceId: undefined,
    Platform: undefined,
    Volumes: undefined
  };
  if (output["description"] !== undefined) {
    contents.Description = output["description"];
  }
  if (output["instanceId"] !== undefined) {
    contents.InstanceId = output["instanceId"];
  }
  if (output["platform"] !== undefined) {
    contents.Platform = output["platform"];
  }
  if (output.volumes === "") {
    contents.Volumes = [];
  }
  if (
    output["volumes"] !== undefined &&
    output["volumes"]["item"] !== undefined
  ) {
    contents.Volumes = deserializeAws_ec2ImportInstanceVolumeDetailSet(
      __getArrayIfSingleItem(output["volumes"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2ImportInstanceVolumeDetailItem = (
  output: any,
  context: __SerdeContext
): ImportInstanceVolumeDetailItem => {
  let contents: any = {
    __type: "ImportInstanceVolumeDetailItem",
    AvailabilityZone: undefined,
    BytesConverted: undefined,
    Description: undefined,
    Image: undefined,
    Status: undefined,
    StatusMessage: undefined,
    Volume: undefined
  };
  if (output["availabilityZone"] !== undefined) {
    contents.AvailabilityZone = output["availabilityZone"];
  }
  if (output["bytesConverted"] !== undefined) {
    contents.BytesConverted = parseInt(output["bytesConverted"]);
  }
  if (output["description"] !== undefined) {
    contents.Description = output["description"];
  }
  if (output["image"] !== undefined) {
    contents.Image = deserializeAws_ec2DiskImageDescription(
      output["image"],
      context
    );
  }
  if (output["status"] !== undefined) {
    contents.Status = output["status"];
  }
  if (output["statusMessage"] !== undefined) {
    contents.StatusMessage = output["statusMessage"];
  }
  if (output["volume"] !== undefined) {
    contents.Volume = deserializeAws_ec2DiskImageVolumeDescription(
      output["volume"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2ImportInstanceVolumeDetailSet = (
  output: any,
  context: __SerdeContext
): ImportInstanceVolumeDetailItem[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2ImportInstanceVolumeDetailItem(entry, context)
  );
};

const deserializeAws_ec2ImportKeyPairResult = (
  output: any,
  context: __SerdeContext
): ImportKeyPairResult => {
  let contents: any = {
    __type: "ImportKeyPairResult",
    KeyFingerprint: undefined,
    KeyName: undefined
  };
  if (output["keyFingerprint"] !== undefined) {
    contents.KeyFingerprint = output["keyFingerprint"];
  }
  if (output["keyName"] !== undefined) {
    contents.KeyName = output["keyName"];
  }
  return contents;
};

const deserializeAws_ec2ImportSnapshotResult = (
  output: any,
  context: __SerdeContext
): ImportSnapshotResult => {
  let contents: any = {
    __type: "ImportSnapshotResult",
    Description: undefined,
    ImportTaskId: undefined,
    SnapshotTaskDetail: undefined
  };
  if (output["description"] !== undefined) {
    contents.Description = output["description"];
  }
  if (output["importTaskId"] !== undefined) {
    contents.ImportTaskId = output["importTaskId"];
  }
  if (output["snapshotTaskDetail"] !== undefined) {
    contents.SnapshotTaskDetail = deserializeAws_ec2SnapshotTaskDetail(
      output["snapshotTaskDetail"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2ImportSnapshotTask = (
  output: any,
  context: __SerdeContext
): ImportSnapshotTask => {
  let contents: any = {
    __type: "ImportSnapshotTask",
    Description: undefined,
    ImportTaskId: undefined,
    SnapshotTaskDetail: undefined,
    Tags: undefined
  };
  if (output["description"] !== undefined) {
    contents.Description = output["description"];
  }
  if (output["importTaskId"] !== undefined) {
    contents.ImportTaskId = output["importTaskId"];
  }
  if (output["snapshotTaskDetail"] !== undefined) {
    contents.SnapshotTaskDetail = deserializeAws_ec2SnapshotTaskDetail(
      output["snapshotTaskDetail"],
      context
    );
  }
  if (output.tagSet === "") {
    contents.Tags = [];
  }
  if (
    output["tagSet"] !== undefined &&
    output["tagSet"]["item"] !== undefined
  ) {
    contents.Tags = deserializeAws_ec2TagList(
      __getArrayIfSingleItem(output["tagSet"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2ImportSnapshotTaskList = (
  output: any,
  context: __SerdeContext
): ImportSnapshotTask[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2ImportSnapshotTask(entry, context)
  );
};

const deserializeAws_ec2ImportVolumeResult = (
  output: any,
  context: __SerdeContext
): ImportVolumeResult => {
  let contents: any = {
    __type: "ImportVolumeResult",
    ConversionTask: undefined
  };
  if (output["conversionTask"] !== undefined) {
    contents.ConversionTask = deserializeAws_ec2ConversionTask(
      output["conversionTask"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2ImportVolumeTaskDetails = (
  output: any,
  context: __SerdeContext
): ImportVolumeTaskDetails => {
  let contents: any = {
    __type: "ImportVolumeTaskDetails",
    AvailabilityZone: undefined,
    BytesConverted: undefined,
    Description: undefined,
    Image: undefined,
    Volume: undefined
  };
  if (output["availabilityZone"] !== undefined) {
    contents.AvailabilityZone = output["availabilityZone"];
  }
  if (output["bytesConverted"] !== undefined) {
    contents.BytesConverted = parseInt(output["bytesConverted"]);
  }
  if (output["description"] !== undefined) {
    contents.Description = output["description"];
  }
  if (output["image"] !== undefined) {
    contents.Image = deserializeAws_ec2DiskImageDescription(
      output["image"],
      context
    );
  }
  if (output["volume"] !== undefined) {
    contents.Volume = deserializeAws_ec2DiskImageVolumeDescription(
      output["volume"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2InferenceAcceleratorInfo = (
  output: any,
  context: __SerdeContext
): InferenceAcceleratorInfo => {
  let contents: any = {
    __type: "InferenceAcceleratorInfo",
    Accelerators: undefined
  };
  if (output.accelerators === "") {
    contents.Accelerators = [];
  }
  if (
    output["accelerators"] !== undefined &&
    output["accelerators"]["member"] !== undefined
  ) {
    contents.Accelerators = deserializeAws_ec2InferenceDeviceInfoList(
      __getArrayIfSingleItem(output["accelerators"]["member"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2InferenceDeviceInfo = (
  output: any,
  context: __SerdeContext
): InferenceDeviceInfo => {
  let contents: any = {
    __type: "InferenceDeviceInfo",
    Count: undefined,
    Manufacturer: undefined,
    Name: undefined
  };
  if (output["count"] !== undefined) {
    contents.Count = parseInt(output["count"]);
  }
  if (output["manufacturer"] !== undefined) {
    contents.Manufacturer = output["manufacturer"];
  }
  if (output["name"] !== undefined) {
    contents.Name = output["name"];
  }
  return contents;
};

const deserializeAws_ec2InferenceDeviceInfoList = (
  output: any,
  context: __SerdeContext
): InferenceDeviceInfo[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2InferenceDeviceInfo(entry, context)
  );
};

const deserializeAws_ec2Instance = (
  output: any,
  context: __SerdeContext
): Instance => {
  let contents: any = {
    __type: "Instance",
    AmiLaunchIndex: undefined,
    Architecture: undefined,
    BlockDeviceMappings: undefined,
    CapacityReservationId: undefined,
    CapacityReservationSpecification: undefined,
    ClientToken: undefined,
    CpuOptions: undefined,
    EbsOptimized: undefined,
    ElasticGpuAssociations: undefined,
    ElasticInferenceAcceleratorAssociations: undefined,
    EnaSupport: undefined,
    HibernationOptions: undefined,
    Hypervisor: undefined,
    IamInstanceProfile: undefined,
    ImageId: undefined,
    InstanceId: undefined,
    InstanceLifecycle: undefined,
    InstanceType: undefined,
    KernelId: undefined,
    KeyName: undefined,
    LaunchTime: undefined,
    Licenses: undefined,
    MetadataOptions: undefined,
    Monitoring: undefined,
    NetworkInterfaces: undefined,
    OutpostArn: undefined,
    Placement: undefined,
    Platform: undefined,
    PrivateDnsName: undefined,
    PrivateIpAddress: undefined,
    ProductCodes: undefined,
    PublicDnsName: undefined,
    PublicIpAddress: undefined,
    RamdiskId: undefined,
    RootDeviceName: undefined,
    RootDeviceType: undefined,
    SecurityGroups: undefined,
    SourceDestCheck: undefined,
    SpotInstanceRequestId: undefined,
    SriovNetSupport: undefined,
    State: undefined,
    StateReason: undefined,
    StateTransitionReason: undefined,
    SubnetId: undefined,
    Tags: undefined,
    VirtualizationType: undefined,
    VpcId: undefined
  };
  if (output["amiLaunchIndex"] !== undefined) {
    contents.AmiLaunchIndex = parseInt(output["amiLaunchIndex"]);
  }
  if (output["architecture"] !== undefined) {
    contents.Architecture = output["architecture"];
  }
  if (output.blockDeviceMapping === "") {
    contents.BlockDeviceMappings = [];
  }
  if (
    output["blockDeviceMapping"] !== undefined &&
    output["blockDeviceMapping"]["item"] !== undefined
  ) {
    contents.BlockDeviceMappings = deserializeAws_ec2InstanceBlockDeviceMappingList(
      __getArrayIfSingleItem(output["blockDeviceMapping"]["item"]),
      context
    );
  }
  if (output["capacityReservationId"] !== undefined) {
    contents.CapacityReservationId = output["capacityReservationId"];
  }
  if (output["capacityReservationSpecification"] !== undefined) {
    contents.CapacityReservationSpecification = deserializeAws_ec2CapacityReservationSpecificationResponse(
      output["capacityReservationSpecification"],
      context
    );
  }
  if (output["clientToken"] !== undefined) {
    contents.ClientToken = output["clientToken"];
  }
  if (output["cpuOptions"] !== undefined) {
    contents.CpuOptions = deserializeAws_ec2CpuOptions(
      output["cpuOptions"],
      context
    );
  }
  if (output["ebsOptimized"] !== undefined) {
    contents.EbsOptimized = output["ebsOptimized"] == "true";
  }
  if (output.elasticGpuAssociationSet === "") {
    contents.ElasticGpuAssociations = [];
  }
  if (
    output["elasticGpuAssociationSet"] !== undefined &&
    output["elasticGpuAssociationSet"]["item"] !== undefined
  ) {
    contents.ElasticGpuAssociations = deserializeAws_ec2ElasticGpuAssociationList(
      __getArrayIfSingleItem(output["elasticGpuAssociationSet"]["item"]),
      context
    );
  }
  if (output.elasticInferenceAcceleratorAssociationSet === "") {
    contents.ElasticInferenceAcceleratorAssociations = [];
  }
  if (
    output["elasticInferenceAcceleratorAssociationSet"] !== undefined &&
    output["elasticInferenceAcceleratorAssociationSet"]["item"] !== undefined
  ) {
    contents.ElasticInferenceAcceleratorAssociations = deserializeAws_ec2ElasticInferenceAcceleratorAssociationList(
      __getArrayIfSingleItem(
        output["elasticInferenceAcceleratorAssociationSet"]["item"]
      ),
      context
    );
  }
  if (output["enaSupport"] !== undefined) {
    contents.EnaSupport = output["enaSupport"] == "true";
  }
  if (output["hibernationOptions"] !== undefined) {
    contents.HibernationOptions = deserializeAws_ec2HibernationOptions(
      output["hibernationOptions"],
      context
    );
  }
  if (output["hypervisor"] !== undefined) {
    contents.Hypervisor = output["hypervisor"];
  }
  if (output["iamInstanceProfile"] !== undefined) {
    contents.IamInstanceProfile = deserializeAws_ec2IamInstanceProfile(
      output["iamInstanceProfile"],
      context
    );
  }
  if (output["imageId"] !== undefined) {
    contents.ImageId = output["imageId"];
  }
  if (output["instanceId"] !== undefined) {
    contents.InstanceId = output["instanceId"];
  }
  if (output["instanceLifecycle"] !== undefined) {
    contents.InstanceLifecycle = output["instanceLifecycle"];
  }
  if (output["instanceType"] !== undefined) {
    contents.InstanceType = output["instanceType"];
  }
  if (output["kernelId"] !== undefined) {
    contents.KernelId = output["kernelId"];
  }
  if (output["keyName"] !== undefined) {
    contents.KeyName = output["keyName"];
  }
  if (output["launchTime"] !== undefined) {
    contents.LaunchTime = new Date(output["launchTime"]);
  }
  if (output.licenseSet === "") {
    contents.Licenses = [];
  }
  if (
    output["licenseSet"] !== undefined &&
    output["licenseSet"]["item"] !== undefined
  ) {
    contents.Licenses = deserializeAws_ec2LicenseList(
      __getArrayIfSingleItem(output["licenseSet"]["item"]),
      context
    );
  }
  if (output["metadataOptions"] !== undefined) {
    contents.MetadataOptions = deserializeAws_ec2InstanceMetadataOptionsResponse(
      output["metadataOptions"],
      context
    );
  }
  if (output["monitoring"] !== undefined) {
    contents.Monitoring = deserializeAws_ec2Monitoring(
      output["monitoring"],
      context
    );
  }
  if (output.networkInterfaceSet === "") {
    contents.NetworkInterfaces = [];
  }
  if (
    output["networkInterfaceSet"] !== undefined &&
    output["networkInterfaceSet"]["item"] !== undefined
  ) {
    contents.NetworkInterfaces = deserializeAws_ec2InstanceNetworkInterfaceList(
      __getArrayIfSingleItem(output["networkInterfaceSet"]["item"]),
      context
    );
  }
  if (output["outpostArn"] !== undefined) {
    contents.OutpostArn = output["outpostArn"];
  }
  if (output["placement"] !== undefined) {
    contents.Placement = deserializeAws_ec2Placement(
      output["placement"],
      context
    );
  }
  if (output["platform"] !== undefined) {
    contents.Platform = output["platform"];
  }
  if (output["privateDnsName"] !== undefined) {
    contents.PrivateDnsName = output["privateDnsName"];
  }
  if (output["privateIpAddress"] !== undefined) {
    contents.PrivateIpAddress = output["privateIpAddress"];
  }
  if (output.productCodes === "") {
    contents.ProductCodes = [];
  }
  if (
    output["productCodes"] !== undefined &&
    output["productCodes"]["item"] !== undefined
  ) {
    contents.ProductCodes = deserializeAws_ec2ProductCodeList(
      __getArrayIfSingleItem(output["productCodes"]["item"]),
      context
    );
  }
  if (output["dnsName"] !== undefined) {
    contents.PublicDnsName = output["dnsName"];
  }
  if (output["ipAddress"] !== undefined) {
    contents.PublicIpAddress = output["ipAddress"];
  }
  if (output["ramdiskId"] !== undefined) {
    contents.RamdiskId = output["ramdiskId"];
  }
  if (output["rootDeviceName"] !== undefined) {
    contents.RootDeviceName = output["rootDeviceName"];
  }
  if (output["rootDeviceType"] !== undefined) {
    contents.RootDeviceType = output["rootDeviceType"];
  }
  if (output.groupSet === "") {
    contents.SecurityGroups = [];
  }
  if (
    output["groupSet"] !== undefined &&
    output["groupSet"]["item"] !== undefined
  ) {
    contents.SecurityGroups = deserializeAws_ec2GroupIdentifierList(
      __getArrayIfSingleItem(output["groupSet"]["item"]),
      context
    );
  }
  if (output["sourceDestCheck"] !== undefined) {
    contents.SourceDestCheck = output["sourceDestCheck"] == "true";
  }
  if (output["spotInstanceRequestId"] !== undefined) {
    contents.SpotInstanceRequestId = output["spotInstanceRequestId"];
  }
  if (output["sriovNetSupport"] !== undefined) {
    contents.SriovNetSupport = output["sriovNetSupport"];
  }
  if (output["instanceState"] !== undefined) {
    contents.State = deserializeAws_ec2InstanceState(
      output["instanceState"],
      context
    );
  }
  if (output["stateReason"] !== undefined) {
    contents.StateReason = deserializeAws_ec2StateReason(
      output["stateReason"],
      context
    );
  }
  if (output["reason"] !== undefined) {
    contents.StateTransitionReason = output["reason"];
  }
  if (output["subnetId"] !== undefined) {
    contents.SubnetId = output["subnetId"];
  }
  if (output.tagSet === "") {
    contents.Tags = [];
  }
  if (
    output["tagSet"] !== undefined &&
    output["tagSet"]["item"] !== undefined
  ) {
    contents.Tags = deserializeAws_ec2TagList(
      __getArrayIfSingleItem(output["tagSet"]["item"]),
      context
    );
  }
  if (output["virtualizationType"] !== undefined) {
    contents.VirtualizationType = output["virtualizationType"];
  }
  if (output["vpcId"] !== undefined) {
    contents.VpcId = output["vpcId"];
  }
  return contents;
};

const deserializeAws_ec2InstanceAttribute = (
  output: any,
  context: __SerdeContext
): InstanceAttribute => {
  let contents: any = {
    __type: "InstanceAttribute",
    BlockDeviceMappings: undefined,
    DisableApiTermination: undefined,
    EbsOptimized: undefined,
    EnaSupport: undefined,
    Groups: undefined,
    InstanceId: undefined,
    InstanceInitiatedShutdownBehavior: undefined,
    InstanceType: undefined,
    KernelId: undefined,
    ProductCodes: undefined,
    RamdiskId: undefined,
    RootDeviceName: undefined,
    SourceDestCheck: undefined,
    SriovNetSupport: undefined,
    UserData: undefined
  };
  if (output.blockDeviceMapping === "") {
    contents.BlockDeviceMappings = [];
  }
  if (
    output["blockDeviceMapping"] !== undefined &&
    output["blockDeviceMapping"]["item"] !== undefined
  ) {
    contents.BlockDeviceMappings = deserializeAws_ec2InstanceBlockDeviceMappingList(
      __getArrayIfSingleItem(output["blockDeviceMapping"]["item"]),
      context
    );
  }
  if (output["disableApiTermination"] !== undefined) {
    contents.DisableApiTermination = deserializeAws_ec2AttributeBooleanValue(
      output["disableApiTermination"],
      context
    );
  }
  if (output["ebsOptimized"] !== undefined) {
    contents.EbsOptimized = deserializeAws_ec2AttributeBooleanValue(
      output["ebsOptimized"],
      context
    );
  }
  if (output["enaSupport"] !== undefined) {
    contents.EnaSupport = deserializeAws_ec2AttributeBooleanValue(
      output["enaSupport"],
      context
    );
  }
  if (output.groupSet === "") {
    contents.Groups = [];
  }
  if (
    output["groupSet"] !== undefined &&
    output["groupSet"]["item"] !== undefined
  ) {
    contents.Groups = deserializeAws_ec2GroupIdentifierList(
      __getArrayIfSingleItem(output["groupSet"]["item"]),
      context
    );
  }
  if (output["instanceId"] !== undefined) {
    contents.InstanceId = output["instanceId"];
  }
  if (output["instanceInitiatedShutdownBehavior"] !== undefined) {
    contents.InstanceInitiatedShutdownBehavior = deserializeAws_ec2AttributeValue(
      output["instanceInitiatedShutdownBehavior"],
      context
    );
  }
  if (output["instanceType"] !== undefined) {
    contents.InstanceType = deserializeAws_ec2AttributeValue(
      output["instanceType"],
      context
    );
  }
  if (output["kernel"] !== undefined) {
    contents.KernelId = deserializeAws_ec2AttributeValue(
      output["kernel"],
      context
    );
  }
  if (output.productCodes === "") {
    contents.ProductCodes = [];
  }
  if (
    output["productCodes"] !== undefined &&
    output["productCodes"]["item"] !== undefined
  ) {
    contents.ProductCodes = deserializeAws_ec2ProductCodeList(
      __getArrayIfSingleItem(output["productCodes"]["item"]),
      context
    );
  }
  if (output["ramdisk"] !== undefined) {
    contents.RamdiskId = deserializeAws_ec2AttributeValue(
      output["ramdisk"],
      context
    );
  }
  if (output["rootDeviceName"] !== undefined) {
    contents.RootDeviceName = deserializeAws_ec2AttributeValue(
      output["rootDeviceName"],
      context
    );
  }
  if (output["sourceDestCheck"] !== undefined) {
    contents.SourceDestCheck = deserializeAws_ec2AttributeBooleanValue(
      output["sourceDestCheck"],
      context
    );
  }
  if (output["sriovNetSupport"] !== undefined) {
    contents.SriovNetSupport = deserializeAws_ec2AttributeValue(
      output["sriovNetSupport"],
      context
    );
  }
  if (output["userData"] !== undefined) {
    contents.UserData = deserializeAws_ec2AttributeValue(
      output["userData"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2InstanceBlockDeviceMapping = (
  output: any,
  context: __SerdeContext
): InstanceBlockDeviceMapping => {
  let contents: any = {
    __type: "InstanceBlockDeviceMapping",
    DeviceName: undefined,
    Ebs: undefined
  };
  if (output["deviceName"] !== undefined) {
    contents.DeviceName = output["deviceName"];
  }
  if (output["ebs"] !== undefined) {
    contents.Ebs = deserializeAws_ec2EbsInstanceBlockDevice(
      output["ebs"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2InstanceBlockDeviceMappingList = (
  output: any,
  context: __SerdeContext
): InstanceBlockDeviceMapping[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2InstanceBlockDeviceMapping(entry, context)
  );
};

const deserializeAws_ec2InstanceCapacity = (
  output: any,
  context: __SerdeContext
): InstanceCapacity => {
  let contents: any = {
    __type: "InstanceCapacity",
    AvailableCapacity: undefined,
    InstanceType: undefined,
    TotalCapacity: undefined
  };
  if (output["availableCapacity"] !== undefined) {
    contents.AvailableCapacity = parseInt(output["availableCapacity"]);
  }
  if (output["instanceType"] !== undefined) {
    contents.InstanceType = output["instanceType"];
  }
  if (output["totalCapacity"] !== undefined) {
    contents.TotalCapacity = parseInt(output["totalCapacity"]);
  }
  return contents;
};

const deserializeAws_ec2InstanceCount = (
  output: any,
  context: __SerdeContext
): InstanceCount => {
  let contents: any = {
    __type: "InstanceCount",
    InstanceCount: undefined,
    State: undefined
  };
  if (output["instanceCount"] !== undefined) {
    contents.InstanceCount = parseInt(output["instanceCount"]);
  }
  if (output["state"] !== undefined) {
    contents.State = output["state"];
  }
  return contents;
};

const deserializeAws_ec2InstanceCountList = (
  output: any,
  context: __SerdeContext
): InstanceCount[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2InstanceCount(entry, context)
  );
};

const deserializeAws_ec2InstanceCreditSpecification = (
  output: any,
  context: __SerdeContext
): InstanceCreditSpecification => {
  let contents: any = {
    __type: "InstanceCreditSpecification",
    CpuCredits: undefined,
    InstanceId: undefined
  };
  if (output["cpuCredits"] !== undefined) {
    contents.CpuCredits = output["cpuCredits"];
  }
  if (output["instanceId"] !== undefined) {
    contents.InstanceId = output["instanceId"];
  }
  return contents;
};

const deserializeAws_ec2InstanceCreditSpecificationList = (
  output: any,
  context: __SerdeContext
): InstanceCreditSpecification[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2InstanceCreditSpecification(entry, context)
  );
};

const deserializeAws_ec2InstanceExportDetails = (
  output: any,
  context: __SerdeContext
): InstanceExportDetails => {
  let contents: any = {
    __type: "InstanceExportDetails",
    InstanceId: undefined,
    TargetEnvironment: undefined
  };
  if (output["instanceId"] !== undefined) {
    contents.InstanceId = output["instanceId"];
  }
  if (output["targetEnvironment"] !== undefined) {
    contents.TargetEnvironment = output["targetEnvironment"];
  }
  return contents;
};

const deserializeAws_ec2InstanceFamilyCreditSpecification = (
  output: any,
  context: __SerdeContext
): InstanceFamilyCreditSpecification => {
  let contents: any = {
    __type: "InstanceFamilyCreditSpecification",
    CpuCredits: undefined,
    InstanceFamily: undefined
  };
  if (output["cpuCredits"] !== undefined) {
    contents.CpuCredits = output["cpuCredits"];
  }
  if (output["instanceFamily"] !== undefined) {
    contents.InstanceFamily = output["instanceFamily"];
  }
  return contents;
};

const deserializeAws_ec2InstanceIdSet = (
  output: any,
  context: __SerdeContext
): string[] => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_ec2InstanceIdsSet = (
  output: any,
  context: __SerdeContext
): string[] => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_ec2InstanceIpv6Address = (
  output: any,
  context: __SerdeContext
): InstanceIpv6Address => {
  let contents: any = {
    __type: "InstanceIpv6Address",
    Ipv6Address: undefined
  };
  if (output["ipv6Address"] !== undefined) {
    contents.Ipv6Address = output["ipv6Address"];
  }
  return contents;
};

const deserializeAws_ec2InstanceIpv6AddressList = (
  output: any,
  context: __SerdeContext
): InstanceIpv6Address[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2InstanceIpv6Address(entry, context)
  );
};

const deserializeAws_ec2InstanceList = (
  output: any,
  context: __SerdeContext
): Instance[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2Instance(entry, context)
  );
};

const deserializeAws_ec2InstanceMetadataOptionsResponse = (
  output: any,
  context: __SerdeContext
): InstanceMetadataOptionsResponse => {
  let contents: any = {
    __type: "InstanceMetadataOptionsResponse",
    HttpEndpoint: undefined,
    HttpPutResponseHopLimit: undefined,
    HttpTokens: undefined,
    State: undefined
  };
  if (output["httpEndpoint"] !== undefined) {
    contents.HttpEndpoint = output["httpEndpoint"];
  }
  if (output["httpPutResponseHopLimit"] !== undefined) {
    contents.HttpPutResponseHopLimit = parseInt(
      output["httpPutResponseHopLimit"]
    );
  }
  if (output["httpTokens"] !== undefined) {
    contents.HttpTokens = output["httpTokens"];
  }
  if (output["state"] !== undefined) {
    contents.State = output["state"];
  }
  return contents;
};

const deserializeAws_ec2InstanceMonitoring = (
  output: any,
  context: __SerdeContext
): InstanceMonitoring => {
  let contents: any = {
    __type: "InstanceMonitoring",
    InstanceId: undefined,
    Monitoring: undefined
  };
  if (output["instanceId"] !== undefined) {
    contents.InstanceId = output["instanceId"];
  }
  if (output["monitoring"] !== undefined) {
    contents.Monitoring = deserializeAws_ec2Monitoring(
      output["monitoring"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2InstanceMonitoringList = (
  output: any,
  context: __SerdeContext
): InstanceMonitoring[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2InstanceMonitoring(entry, context)
  );
};

const deserializeAws_ec2InstanceNetworkInterface = (
  output: any,
  context: __SerdeContext
): InstanceNetworkInterface => {
  let contents: any = {
    __type: "InstanceNetworkInterface",
    Association: undefined,
    Attachment: undefined,
    Description: undefined,
    Groups: undefined,
    InterfaceType: undefined,
    Ipv6Addresses: undefined,
    MacAddress: undefined,
    NetworkInterfaceId: undefined,
    OwnerId: undefined,
    PrivateDnsName: undefined,
    PrivateIpAddress: undefined,
    PrivateIpAddresses: undefined,
    SourceDestCheck: undefined,
    Status: undefined,
    SubnetId: undefined,
    VpcId: undefined
  };
  if (output["association"] !== undefined) {
    contents.Association = deserializeAws_ec2InstanceNetworkInterfaceAssociation(
      output["association"],
      context
    );
  }
  if (output["attachment"] !== undefined) {
    contents.Attachment = deserializeAws_ec2InstanceNetworkInterfaceAttachment(
      output["attachment"],
      context
    );
  }
  if (output["description"] !== undefined) {
    contents.Description = output["description"];
  }
  if (output.groupSet === "") {
    contents.Groups = [];
  }
  if (
    output["groupSet"] !== undefined &&
    output["groupSet"]["item"] !== undefined
  ) {
    contents.Groups = deserializeAws_ec2GroupIdentifierList(
      __getArrayIfSingleItem(output["groupSet"]["item"]),
      context
    );
  }
  if (output["interfaceType"] !== undefined) {
    contents.InterfaceType = output["interfaceType"];
  }
  if (output.ipv6AddressesSet === "") {
    contents.Ipv6Addresses = [];
  }
  if (
    output["ipv6AddressesSet"] !== undefined &&
    output["ipv6AddressesSet"]["item"] !== undefined
  ) {
    contents.Ipv6Addresses = deserializeAws_ec2InstanceIpv6AddressList(
      __getArrayIfSingleItem(output["ipv6AddressesSet"]["item"]),
      context
    );
  }
  if (output["macAddress"] !== undefined) {
    contents.MacAddress = output["macAddress"];
  }
  if (output["networkInterfaceId"] !== undefined) {
    contents.NetworkInterfaceId = output["networkInterfaceId"];
  }
  if (output["ownerId"] !== undefined) {
    contents.OwnerId = output["ownerId"];
  }
  if (output["privateDnsName"] !== undefined) {
    contents.PrivateDnsName = output["privateDnsName"];
  }
  if (output["privateIpAddress"] !== undefined) {
    contents.PrivateIpAddress = output["privateIpAddress"];
  }
  if (output.privateIpAddressesSet === "") {
    contents.PrivateIpAddresses = [];
  }
  if (
    output["privateIpAddressesSet"] !== undefined &&
    output["privateIpAddressesSet"]["item"] !== undefined
  ) {
    contents.PrivateIpAddresses = deserializeAws_ec2InstancePrivateIpAddressList(
      __getArrayIfSingleItem(output["privateIpAddressesSet"]["item"]),
      context
    );
  }
  if (output["sourceDestCheck"] !== undefined) {
    contents.SourceDestCheck = output["sourceDestCheck"] == "true";
  }
  if (output["status"] !== undefined) {
    contents.Status = output["status"];
  }
  if (output["subnetId"] !== undefined) {
    contents.SubnetId = output["subnetId"];
  }
  if (output["vpcId"] !== undefined) {
    contents.VpcId = output["vpcId"];
  }
  return contents;
};

const deserializeAws_ec2InstanceNetworkInterfaceAssociation = (
  output: any,
  context: __SerdeContext
): InstanceNetworkInterfaceAssociation => {
  let contents: any = {
    __type: "InstanceNetworkInterfaceAssociation",
    IpOwnerId: undefined,
    PublicDnsName: undefined,
    PublicIp: undefined
  };
  if (output["ipOwnerId"] !== undefined) {
    contents.IpOwnerId = output["ipOwnerId"];
  }
  if (output["publicDnsName"] !== undefined) {
    contents.PublicDnsName = output["publicDnsName"];
  }
  if (output["publicIp"] !== undefined) {
    contents.PublicIp = output["publicIp"];
  }
  return contents;
};

const deserializeAws_ec2InstanceNetworkInterfaceAttachment = (
  output: any,
  context: __SerdeContext
): InstanceNetworkInterfaceAttachment => {
  let contents: any = {
    __type: "InstanceNetworkInterfaceAttachment",
    AttachTime: undefined,
    AttachmentId: undefined,
    DeleteOnTermination: undefined,
    DeviceIndex: undefined,
    Status: undefined
  };
  if (output["attachTime"] !== undefined) {
    contents.AttachTime = new Date(output["attachTime"]);
  }
  if (output["attachmentId"] !== undefined) {
    contents.AttachmentId = output["attachmentId"];
  }
  if (output["deleteOnTermination"] !== undefined) {
    contents.DeleteOnTermination = output["deleteOnTermination"] == "true";
  }
  if (output["deviceIndex"] !== undefined) {
    contents.DeviceIndex = parseInt(output["deviceIndex"]);
  }
  if (output["status"] !== undefined) {
    contents.Status = output["status"];
  }
  return contents;
};

const deserializeAws_ec2InstanceNetworkInterfaceList = (
  output: any,
  context: __SerdeContext
): InstanceNetworkInterface[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2InstanceNetworkInterface(entry, context)
  );
};

const deserializeAws_ec2InstanceNetworkInterfaceSpecification = (
  output: any,
  context: __SerdeContext
): InstanceNetworkInterfaceSpecification => {
  let contents: any = {
    __type: "InstanceNetworkInterfaceSpecification",
    AssociatePublicIpAddress: undefined,
    DeleteOnTermination: undefined,
    Description: undefined,
    DeviceIndex: undefined,
    Groups: undefined,
    InterfaceType: undefined,
    Ipv6AddressCount: undefined,
    Ipv6Addresses: undefined,
    NetworkInterfaceId: undefined,
    PrivateIpAddress: undefined,
    PrivateIpAddresses: undefined,
    SecondaryPrivateIpAddressCount: undefined,
    SubnetId: undefined
  };
  if (output["associatePublicIpAddress"] !== undefined) {
    contents.AssociatePublicIpAddress =
      output["associatePublicIpAddress"] == "true";
  }
  if (output["deleteOnTermination"] !== undefined) {
    contents.DeleteOnTermination = output["deleteOnTermination"] == "true";
  }
  if (output["description"] !== undefined) {
    contents.Description = output["description"];
  }
  if (output["deviceIndex"] !== undefined) {
    contents.DeviceIndex = parseInt(output["deviceIndex"]);
  }
  if (output.SecurityGroupId === "") {
    contents.Groups = [];
  }
  if (
    output["SecurityGroupId"] !== undefined &&
    output["SecurityGroupId"]["SecurityGroupId"] !== undefined
  ) {
    contents.Groups = deserializeAws_ec2SecurityGroupIdStringList(
      __getArrayIfSingleItem(output["SecurityGroupId"]["SecurityGroupId"]),
      context
    );
  }
  if (output["InterfaceType"] !== undefined) {
    contents.InterfaceType = output["InterfaceType"];
  }
  if (output["ipv6AddressCount"] !== undefined) {
    contents.Ipv6AddressCount = parseInt(output["ipv6AddressCount"]);
  }
  if (output.ipv6AddressesSet === "") {
    contents.Ipv6Addresses = [];
  }
  if (
    output["ipv6AddressesSet"] !== undefined &&
    output["ipv6AddressesSet"]["item"] !== undefined
  ) {
    contents.Ipv6Addresses = deserializeAws_ec2InstanceIpv6AddressList(
      __getArrayIfSingleItem(output["ipv6AddressesSet"]["item"]),
      context
    );
  }
  if (output["networkInterfaceId"] !== undefined) {
    contents.NetworkInterfaceId = output["networkInterfaceId"];
  }
  if (output["privateIpAddress"] !== undefined) {
    contents.PrivateIpAddress = output["privateIpAddress"];
  }
  if (output.privateIpAddressesSet === "") {
    contents.PrivateIpAddresses = [];
  }
  if (
    output["privateIpAddressesSet"] !== undefined &&
    output["privateIpAddressesSet"]["item"] !== undefined
  ) {
    contents.PrivateIpAddresses = deserializeAws_ec2PrivateIpAddressSpecificationList(
      __getArrayIfSingleItem(output["privateIpAddressesSet"]["item"]),
      context
    );
  }
  if (output["secondaryPrivateIpAddressCount"] !== undefined) {
    contents.SecondaryPrivateIpAddressCount = parseInt(
      output["secondaryPrivateIpAddressCount"]
    );
  }
  if (output["subnetId"] !== undefined) {
    contents.SubnetId = output["subnetId"];
  }
  return contents;
};

const deserializeAws_ec2InstanceNetworkInterfaceSpecificationList = (
  output: any,
  context: __SerdeContext
): InstanceNetworkInterfaceSpecification[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2InstanceNetworkInterfaceSpecification(entry, context)
  );
};

const deserializeAws_ec2InstancePrivateIpAddress = (
  output: any,
  context: __SerdeContext
): InstancePrivateIpAddress => {
  let contents: any = {
    __type: "InstancePrivateIpAddress",
    Association: undefined,
    Primary: undefined,
    PrivateDnsName: undefined,
    PrivateIpAddress: undefined
  };
  if (output["association"] !== undefined) {
    contents.Association = deserializeAws_ec2InstanceNetworkInterfaceAssociation(
      output["association"],
      context
    );
  }
  if (output["primary"] !== undefined) {
    contents.Primary = output["primary"] == "true";
  }
  if (output["privateDnsName"] !== undefined) {
    contents.PrivateDnsName = output["privateDnsName"];
  }
  if (output["privateIpAddress"] !== undefined) {
    contents.PrivateIpAddress = output["privateIpAddress"];
  }
  return contents;
};

const deserializeAws_ec2InstancePrivateIpAddressList = (
  output: any,
  context: __SerdeContext
): InstancePrivateIpAddress[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2InstancePrivateIpAddress(entry, context)
  );
};

const deserializeAws_ec2InstanceState = (
  output: any,
  context: __SerdeContext
): InstanceState => {
  let contents: any = {
    __type: "InstanceState",
    Code: undefined,
    Name: undefined
  };
  if (output["code"] !== undefined) {
    contents.Code = parseInt(output["code"]);
  }
  if (output["name"] !== undefined) {
    contents.Name = output["name"];
  }
  return contents;
};

const deserializeAws_ec2InstanceStateChange = (
  output: any,
  context: __SerdeContext
): InstanceStateChange => {
  let contents: any = {
    __type: "InstanceStateChange",
    CurrentState: undefined,
    InstanceId: undefined,
    PreviousState: undefined
  };
  if (output["currentState"] !== undefined) {
    contents.CurrentState = deserializeAws_ec2InstanceState(
      output["currentState"],
      context
    );
  }
  if (output["instanceId"] !== undefined) {
    contents.InstanceId = output["instanceId"];
  }
  if (output["previousState"] !== undefined) {
    contents.PreviousState = deserializeAws_ec2InstanceState(
      output["previousState"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2InstanceStateChangeList = (
  output: any,
  context: __SerdeContext
): InstanceStateChange[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2InstanceStateChange(entry, context)
  );
};

const deserializeAws_ec2InstanceStatus = (
  output: any,
  context: __SerdeContext
): InstanceStatus => {
  let contents: any = {
    __type: "InstanceStatus",
    AvailabilityZone: undefined,
    Events: undefined,
    InstanceId: undefined,
    InstanceState: undefined,
    InstanceStatus: undefined,
    OutpostArn: undefined,
    SystemStatus: undefined
  };
  if (output["availabilityZone"] !== undefined) {
    contents.AvailabilityZone = output["availabilityZone"];
  }
  if (output.eventsSet === "") {
    contents.Events = [];
  }
  if (
    output["eventsSet"] !== undefined &&
    output["eventsSet"]["item"] !== undefined
  ) {
    contents.Events = deserializeAws_ec2InstanceStatusEventList(
      __getArrayIfSingleItem(output["eventsSet"]["item"]),
      context
    );
  }
  if (output["instanceId"] !== undefined) {
    contents.InstanceId = output["instanceId"];
  }
  if (output["instanceState"] !== undefined) {
    contents.InstanceState = deserializeAws_ec2InstanceState(
      output["instanceState"],
      context
    );
  }
  if (output["instanceStatus"] !== undefined) {
    contents.InstanceStatus = deserializeAws_ec2InstanceStatusSummary(
      output["instanceStatus"],
      context
    );
  }
  if (output["outpostArn"] !== undefined) {
    contents.OutpostArn = output["outpostArn"];
  }
  if (output["systemStatus"] !== undefined) {
    contents.SystemStatus = deserializeAws_ec2InstanceStatusSummary(
      output["systemStatus"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2InstanceStatusDetails = (
  output: any,
  context: __SerdeContext
): InstanceStatusDetails => {
  let contents: any = {
    __type: "InstanceStatusDetails",
    ImpairedSince: undefined,
    Name: undefined,
    Status: undefined
  };
  if (output["impairedSince"] !== undefined) {
    contents.ImpairedSince = new Date(output["impairedSince"]);
  }
  if (output["name"] !== undefined) {
    contents.Name = output["name"];
  }
  if (output["status"] !== undefined) {
    contents.Status = output["status"];
  }
  return contents;
};

const deserializeAws_ec2InstanceStatusDetailsList = (
  output: any,
  context: __SerdeContext
): InstanceStatusDetails[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2InstanceStatusDetails(entry, context)
  );
};

const deserializeAws_ec2InstanceStatusEvent = (
  output: any,
  context: __SerdeContext
): InstanceStatusEvent => {
  let contents: any = {
    __type: "InstanceStatusEvent",
    Code: undefined,
    Description: undefined,
    InstanceEventId: undefined,
    NotAfter: undefined,
    NotBefore: undefined,
    NotBeforeDeadline: undefined
  };
  if (output["code"] !== undefined) {
    contents.Code = output["code"];
  }
  if (output["description"] !== undefined) {
    contents.Description = output["description"];
  }
  if (output["instanceEventId"] !== undefined) {
    contents.InstanceEventId = output["instanceEventId"];
  }
  if (output["notAfter"] !== undefined) {
    contents.NotAfter = new Date(output["notAfter"]);
  }
  if (output["notBefore"] !== undefined) {
    contents.NotBefore = new Date(output["notBefore"]);
  }
  if (output["notBeforeDeadline"] !== undefined) {
    contents.NotBeforeDeadline = new Date(output["notBeforeDeadline"]);
  }
  return contents;
};

const deserializeAws_ec2InstanceStatusEventList = (
  output: any,
  context: __SerdeContext
): InstanceStatusEvent[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2InstanceStatusEvent(entry, context)
  );
};

const deserializeAws_ec2InstanceStatusList = (
  output: any,
  context: __SerdeContext
): InstanceStatus[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2InstanceStatus(entry, context)
  );
};

const deserializeAws_ec2InstanceStatusSummary = (
  output: any,
  context: __SerdeContext
): InstanceStatusSummary => {
  let contents: any = {
    __type: "InstanceStatusSummary",
    Details: undefined,
    Status: undefined
  };
  if (output.details === "") {
    contents.Details = [];
  }
  if (
    output["details"] !== undefined &&
    output["details"]["item"] !== undefined
  ) {
    contents.Details = deserializeAws_ec2InstanceStatusDetailsList(
      __getArrayIfSingleItem(output["details"]["item"]),
      context
    );
  }
  if (output["status"] !== undefined) {
    contents.Status = output["status"];
  }
  return contents;
};

const deserializeAws_ec2InstanceStorageInfo = (
  output: any,
  context: __SerdeContext
): InstanceStorageInfo => {
  let contents: any = {
    __type: "InstanceStorageInfo",
    Disks: undefined,
    TotalSizeInGB: undefined
  };
  if (output.disks === "") {
    contents.Disks = [];
  }
  if (output["disks"] !== undefined && output["disks"]["item"] !== undefined) {
    contents.Disks = deserializeAws_ec2DiskInfoList(
      __getArrayIfSingleItem(output["disks"]["item"]),
      context
    );
  }
  if (output["totalSizeInGB"] !== undefined) {
    contents.TotalSizeInGB = parseInt(output["totalSizeInGB"]);
  }
  return contents;
};

const deserializeAws_ec2InstanceTypeInfo = (
  output: any,
  context: __SerdeContext
): InstanceTypeInfo => {
  let contents: any = {
    __type: "InstanceTypeInfo",
    AutoRecoverySupported: undefined,
    BareMetal: undefined,
    BurstablePerformanceSupported: undefined,
    CurrentGeneration: undefined,
    DedicatedHostsSupported: undefined,
    EbsInfo: undefined,
    FpgaInfo: undefined,
    FreeTierEligible: undefined,
    GpuInfo: undefined,
    HibernationSupported: undefined,
    Hypervisor: undefined,
    InferenceAcceleratorInfo: undefined,
    InstanceStorageInfo: undefined,
    InstanceStorageSupported: undefined,
    InstanceType: undefined,
    MemoryInfo: undefined,
    NetworkInfo: undefined,
    PlacementGroupInfo: undefined,
    ProcessorInfo: undefined,
    SupportedRootDeviceTypes: undefined,
    SupportedUsageClasses: undefined,
    VCpuInfo: undefined
  };
  if (output["autoRecoverySupported"] !== undefined) {
    contents.AutoRecoverySupported = output["autoRecoverySupported"] == "true";
  }
  if (output["bareMetal"] !== undefined) {
    contents.BareMetal = output["bareMetal"] == "true";
  }
  if (output["burstablePerformanceSupported"] !== undefined) {
    contents.BurstablePerformanceSupported =
      output["burstablePerformanceSupported"] == "true";
  }
  if (output["currentGeneration"] !== undefined) {
    contents.CurrentGeneration = output["currentGeneration"] == "true";
  }
  if (output["dedicatedHostsSupported"] !== undefined) {
    contents.DedicatedHostsSupported =
      output["dedicatedHostsSupported"] == "true";
  }
  if (output["ebsInfo"] !== undefined) {
    contents.EbsInfo = deserializeAws_ec2EbsInfo(output["ebsInfo"], context);
  }
  if (output["fpgaInfo"] !== undefined) {
    contents.FpgaInfo = deserializeAws_ec2FpgaInfo(output["fpgaInfo"], context);
  }
  if (output["freeTierEligible"] !== undefined) {
    contents.FreeTierEligible = output["freeTierEligible"] == "true";
  }
  if (output["gpuInfo"] !== undefined) {
    contents.GpuInfo = deserializeAws_ec2GpuInfo(output["gpuInfo"], context);
  }
  if (output["hibernationSupported"] !== undefined) {
    contents.HibernationSupported = output["hibernationSupported"] == "true";
  }
  if (output["hypervisor"] !== undefined) {
    contents.Hypervisor = output["hypervisor"];
  }
  if (output["inferenceAcceleratorInfo"] !== undefined) {
    contents.InferenceAcceleratorInfo = deserializeAws_ec2InferenceAcceleratorInfo(
      output["inferenceAcceleratorInfo"],
      context
    );
  }
  if (output["instanceStorageInfo"] !== undefined) {
    contents.InstanceStorageInfo = deserializeAws_ec2InstanceStorageInfo(
      output["instanceStorageInfo"],
      context
    );
  }
  if (output["instanceStorageSupported"] !== undefined) {
    contents.InstanceStorageSupported =
      output["instanceStorageSupported"] == "true";
  }
  if (output["instanceType"] !== undefined) {
    contents.InstanceType = output["instanceType"];
  }
  if (output["memoryInfo"] !== undefined) {
    contents.MemoryInfo = deserializeAws_ec2MemoryInfo(
      output["memoryInfo"],
      context
    );
  }
  if (output["networkInfo"] !== undefined) {
    contents.NetworkInfo = deserializeAws_ec2NetworkInfo(
      output["networkInfo"],
      context
    );
  }
  if (output["placementGroupInfo"] !== undefined) {
    contents.PlacementGroupInfo = deserializeAws_ec2PlacementGroupInfo(
      output["placementGroupInfo"],
      context
    );
  }
  if (output["processorInfo"] !== undefined) {
    contents.ProcessorInfo = deserializeAws_ec2ProcessorInfo(
      output["processorInfo"],
      context
    );
  }
  if (output.supportedRootDeviceTypes === "") {
    contents.SupportedRootDeviceTypes = [];
  }
  if (
    output["supportedRootDeviceTypes"] !== undefined &&
    output["supportedRootDeviceTypes"]["item"] !== undefined
  ) {
    contents.SupportedRootDeviceTypes = deserializeAws_ec2RootDeviceTypeList(
      __getArrayIfSingleItem(output["supportedRootDeviceTypes"]["item"]),
      context
    );
  }
  if (output.supportedUsageClasses === "") {
    contents.SupportedUsageClasses = [];
  }
  if (
    output["supportedUsageClasses"] !== undefined &&
    output["supportedUsageClasses"]["item"] !== undefined
  ) {
    contents.SupportedUsageClasses = deserializeAws_ec2UsageClassTypeList(
      __getArrayIfSingleItem(output["supportedUsageClasses"]["item"]),
      context
    );
  }
  if (output["vCpuInfo"] !== undefined) {
    contents.VCpuInfo = deserializeAws_ec2VCpuInfo(output["vCpuInfo"], context);
  }
  return contents;
};

const deserializeAws_ec2InstanceTypeInfoList = (
  output: any,
  context: __SerdeContext
): InstanceTypeInfo[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2InstanceTypeInfo(entry, context)
  );
};

const deserializeAws_ec2InstanceTypeOffering = (
  output: any,
  context: __SerdeContext
): InstanceTypeOffering => {
  let contents: any = {
    __type: "InstanceTypeOffering",
    InstanceType: undefined,
    Location: undefined,
    LocationType: undefined
  };
  if (output["instanceType"] !== undefined) {
    contents.InstanceType = output["instanceType"];
  }
  if (output["location"] !== undefined) {
    contents.Location = output["location"];
  }
  if (output["locationType"] !== undefined) {
    contents.LocationType = output["locationType"];
  }
  return contents;
};

const deserializeAws_ec2InstanceTypeOfferingsList = (
  output: any,
  context: __SerdeContext
): InstanceTypeOffering[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2InstanceTypeOffering(entry, context)
  );
};

const deserializeAws_ec2InstanceUsage = (
  output: any,
  context: __SerdeContext
): InstanceUsage => {
  let contents: any = {
    __type: "InstanceUsage",
    AccountId: undefined,
    UsedInstanceCount: undefined
  };
  if (output["accountId"] !== undefined) {
    contents.AccountId = output["accountId"];
  }
  if (output["usedInstanceCount"] !== undefined) {
    contents.UsedInstanceCount = parseInt(output["usedInstanceCount"]);
  }
  return contents;
};

const deserializeAws_ec2InstanceUsageSet = (
  output: any,
  context: __SerdeContext
): InstanceUsage[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2InstanceUsage(entry, context)
  );
};

const deserializeAws_ec2InternetGateway = (
  output: any,
  context: __SerdeContext
): InternetGateway => {
  let contents: any = {
    __type: "InternetGateway",
    Attachments: undefined,
    InternetGatewayId: undefined,
    OwnerId: undefined,
    Tags: undefined
  };
  if (output.attachmentSet === "") {
    contents.Attachments = [];
  }
  if (
    output["attachmentSet"] !== undefined &&
    output["attachmentSet"]["item"] !== undefined
  ) {
    contents.Attachments = deserializeAws_ec2InternetGatewayAttachmentList(
      __getArrayIfSingleItem(output["attachmentSet"]["item"]),
      context
    );
  }
  if (output["internetGatewayId"] !== undefined) {
    contents.InternetGatewayId = output["internetGatewayId"];
  }
  if (output["ownerId"] !== undefined) {
    contents.OwnerId = output["ownerId"];
  }
  if (output.tagSet === "") {
    contents.Tags = [];
  }
  if (
    output["tagSet"] !== undefined &&
    output["tagSet"]["item"] !== undefined
  ) {
    contents.Tags = deserializeAws_ec2TagList(
      __getArrayIfSingleItem(output["tagSet"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2InternetGatewayAttachment = (
  output: any,
  context: __SerdeContext
): InternetGatewayAttachment => {
  let contents: any = {
    __type: "InternetGatewayAttachment",
    State: undefined,
    VpcId: undefined
  };
  if (output["state"] !== undefined) {
    contents.State = output["state"];
  }
  if (output["vpcId"] !== undefined) {
    contents.VpcId = output["vpcId"];
  }
  return contents;
};

const deserializeAws_ec2InternetGatewayAttachmentList = (
  output: any,
  context: __SerdeContext
): InternetGatewayAttachment[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2InternetGatewayAttachment(entry, context)
  );
};

const deserializeAws_ec2InternetGatewayList = (
  output: any,
  context: __SerdeContext
): InternetGateway[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2InternetGateway(entry, context)
  );
};

const deserializeAws_ec2IpPermission = (
  output: any,
  context: __SerdeContext
): IpPermission => {
  let contents: any = {
    __type: "IpPermission",
    FromPort: undefined,
    IpProtocol: undefined,
    IpRanges: undefined,
    Ipv6Ranges: undefined,
    PrefixListIds: undefined,
    ToPort: undefined,
    UserIdGroupPairs: undefined
  };
  if (output["fromPort"] !== undefined) {
    contents.FromPort = parseInt(output["fromPort"]);
  }
  if (output["ipProtocol"] !== undefined) {
    contents.IpProtocol = output["ipProtocol"];
  }
  if (output.ipRanges === "") {
    contents.IpRanges = [];
  }
  if (
    output["ipRanges"] !== undefined &&
    output["ipRanges"]["item"] !== undefined
  ) {
    contents.IpRanges = deserializeAws_ec2IpRangeList(
      __getArrayIfSingleItem(output["ipRanges"]["item"]),
      context
    );
  }
  if (output.ipv6Ranges === "") {
    contents.Ipv6Ranges = [];
  }
  if (
    output["ipv6Ranges"] !== undefined &&
    output["ipv6Ranges"]["item"] !== undefined
  ) {
    contents.Ipv6Ranges = deserializeAws_ec2Ipv6RangeList(
      __getArrayIfSingleItem(output["ipv6Ranges"]["item"]),
      context
    );
  }
  if (output.prefixListIds === "") {
    contents.PrefixListIds = [];
  }
  if (
    output["prefixListIds"] !== undefined &&
    output["prefixListIds"]["item"] !== undefined
  ) {
    contents.PrefixListIds = deserializeAws_ec2PrefixListIdList(
      __getArrayIfSingleItem(output["prefixListIds"]["item"]),
      context
    );
  }
  if (output["toPort"] !== undefined) {
    contents.ToPort = parseInt(output["toPort"]);
  }
  if (output.groups === "") {
    contents.UserIdGroupPairs = [];
  }
  if (
    output["groups"] !== undefined &&
    output["groups"]["item"] !== undefined
  ) {
    contents.UserIdGroupPairs = deserializeAws_ec2UserIdGroupPairList(
      __getArrayIfSingleItem(output["groups"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2IpPermissionList = (
  output: any,
  context: __SerdeContext
): IpPermission[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2IpPermission(entry, context)
  );
};

const deserializeAws_ec2IpRange = (
  output: any,
  context: __SerdeContext
): IpRange => {
  let contents: any = {
    __type: "IpRange",
    CidrIp: undefined,
    Description: undefined
  };
  if (output["cidrIp"] !== undefined) {
    contents.CidrIp = output["cidrIp"];
  }
  if (output["description"] !== undefined) {
    contents.Description = output["description"];
  }
  return contents;
};

const deserializeAws_ec2IpRangeList = (
  output: any,
  context: __SerdeContext
): IpRange[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2IpRange(entry, context)
  );
};

const deserializeAws_ec2IpRanges = (
  output: any,
  context: __SerdeContext
): string[] => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_ec2Ipv6AddressList = (
  output: any,
  context: __SerdeContext
): string[] => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_ec2Ipv6CidrAssociation = (
  output: any,
  context: __SerdeContext
): Ipv6CidrAssociation => {
  let contents: any = {
    __type: "Ipv6CidrAssociation",
    AssociatedResource: undefined,
    Ipv6Cidr: undefined
  };
  if (output["associatedResource"] !== undefined) {
    contents.AssociatedResource = output["associatedResource"];
  }
  if (output["ipv6Cidr"] !== undefined) {
    contents.Ipv6Cidr = output["ipv6Cidr"];
  }
  return contents;
};

const deserializeAws_ec2Ipv6CidrAssociationSet = (
  output: any,
  context: __SerdeContext
): Ipv6CidrAssociation[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2Ipv6CidrAssociation(entry, context)
  );
};

const deserializeAws_ec2Ipv6CidrBlock = (
  output: any,
  context: __SerdeContext
): Ipv6CidrBlock => {
  let contents: any = {
    __type: "Ipv6CidrBlock",
    Ipv6CidrBlock: undefined
  };
  if (output["ipv6CidrBlock"] !== undefined) {
    contents.Ipv6CidrBlock = output["ipv6CidrBlock"];
  }
  return contents;
};

const deserializeAws_ec2Ipv6CidrBlockSet = (
  output: any,
  context: __SerdeContext
): Ipv6CidrBlock[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2Ipv6CidrBlock(entry, context)
  );
};

const deserializeAws_ec2Ipv6Pool = (
  output: any,
  context: __SerdeContext
): Ipv6Pool => {
  let contents: any = {
    __type: "Ipv6Pool",
    Description: undefined,
    PoolCidrBlocks: undefined,
    PoolId: undefined,
    Tags: undefined
  };
  if (output["description"] !== undefined) {
    contents.Description = output["description"];
  }
  if (output.poolCidrBlockSet === "") {
    contents.PoolCidrBlocks = [];
  }
  if (
    output["poolCidrBlockSet"] !== undefined &&
    output["poolCidrBlockSet"]["item"] !== undefined
  ) {
    contents.PoolCidrBlocks = deserializeAws_ec2PoolCidrBlocksSet(
      __getArrayIfSingleItem(output["poolCidrBlockSet"]["item"]),
      context
    );
  }
  if (output["poolId"] !== undefined) {
    contents.PoolId = output["poolId"];
  }
  if (output.tagSet === "") {
    contents.Tags = [];
  }
  if (
    output["tagSet"] !== undefined &&
    output["tagSet"]["item"] !== undefined
  ) {
    contents.Tags = deserializeAws_ec2TagList(
      __getArrayIfSingleItem(output["tagSet"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2Ipv6PoolSet = (
  output: any,
  context: __SerdeContext
): Ipv6Pool[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2Ipv6Pool(entry, context)
  );
};

const deserializeAws_ec2Ipv6Range = (
  output: any,
  context: __SerdeContext
): Ipv6Range => {
  let contents: any = {
    __type: "Ipv6Range",
    CidrIpv6: undefined,
    Description: undefined
  };
  if (output["cidrIpv6"] !== undefined) {
    contents.CidrIpv6 = output["cidrIpv6"];
  }
  if (output["description"] !== undefined) {
    contents.Description = output["description"];
  }
  return contents;
};

const deserializeAws_ec2Ipv6RangeList = (
  output: any,
  context: __SerdeContext
): Ipv6Range[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2Ipv6Range(entry, context)
  );
};

const deserializeAws_ec2KeyPair = (
  output: any,
  context: __SerdeContext
): KeyPair => {
  let contents: any = {
    __type: "KeyPair",
    KeyFingerprint: undefined,
    KeyMaterial: undefined,
    KeyName: undefined,
    KeyPairId: undefined
  };
  if (output["keyFingerprint"] !== undefined) {
    contents.KeyFingerprint = output["keyFingerprint"];
  }
  if (output["keyMaterial"] !== undefined) {
    contents.KeyMaterial = output["keyMaterial"];
  }
  if (output["keyName"] !== undefined) {
    contents.KeyName = output["keyName"];
  }
  if (output["keyPairId"] !== undefined) {
    contents.KeyPairId = output["keyPairId"];
  }
  return contents;
};

const deserializeAws_ec2KeyPairInfo = (
  output: any,
  context: __SerdeContext
): KeyPairInfo => {
  let contents: any = {
    __type: "KeyPairInfo",
    KeyFingerprint: undefined,
    KeyName: undefined,
    KeyPairId: undefined,
    Tags: undefined
  };
  if (output["keyFingerprint"] !== undefined) {
    contents.KeyFingerprint = output["keyFingerprint"];
  }
  if (output["keyName"] !== undefined) {
    contents.KeyName = output["keyName"];
  }
  if (output["keyPairId"] !== undefined) {
    contents.KeyPairId = output["keyPairId"];
  }
  if (output.tagSet === "") {
    contents.Tags = [];
  }
  if (
    output["tagSet"] !== undefined &&
    output["tagSet"]["item"] !== undefined
  ) {
    contents.Tags = deserializeAws_ec2TagList(
      __getArrayIfSingleItem(output["tagSet"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2KeyPairList = (
  output: any,
  context: __SerdeContext
): KeyPairInfo[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2KeyPairInfo(entry, context)
  );
};

const deserializeAws_ec2LastError = (
  output: any,
  context: __SerdeContext
): LastError => {
  let contents: any = {
    __type: "LastError",
    Code: undefined,
    Message: undefined
  };
  if (output["code"] !== undefined) {
    contents.Code = output["code"];
  }
  if (output["message"] !== undefined) {
    contents.Message = output["message"];
  }
  return contents;
};

const deserializeAws_ec2LaunchPermission = (
  output: any,
  context: __SerdeContext
): LaunchPermission => {
  let contents: any = {
    __type: "LaunchPermission",
    Group: undefined,
    UserId: undefined
  };
  if (output["group"] !== undefined) {
    contents.Group = output["group"];
  }
  if (output["userId"] !== undefined) {
    contents.UserId = output["userId"];
  }
  return contents;
};

const deserializeAws_ec2LaunchPermissionList = (
  output: any,
  context: __SerdeContext
): LaunchPermission[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2LaunchPermission(entry, context)
  );
};

const deserializeAws_ec2LaunchSpecification = (
  output: any,
  context: __SerdeContext
): LaunchSpecification => {
  let contents: any = {
    __type: "LaunchSpecification",
    AddressingType: undefined,
    BlockDeviceMappings: undefined,
    EbsOptimized: undefined,
    IamInstanceProfile: undefined,
    ImageId: undefined,
    InstanceType: undefined,
    KernelId: undefined,
    KeyName: undefined,
    Monitoring: undefined,
    NetworkInterfaces: undefined,
    Placement: undefined,
    RamdiskId: undefined,
    SecurityGroups: undefined,
    SubnetId: undefined,
    UserData: undefined
  };
  if (output["addressingType"] !== undefined) {
    contents.AddressingType = output["addressingType"];
  }
  if (output.blockDeviceMapping === "") {
    contents.BlockDeviceMappings = [];
  }
  if (
    output["blockDeviceMapping"] !== undefined &&
    output["blockDeviceMapping"]["item"] !== undefined
  ) {
    contents.BlockDeviceMappings = deserializeAws_ec2BlockDeviceMappingList(
      __getArrayIfSingleItem(output["blockDeviceMapping"]["item"]),
      context
    );
  }
  if (output["ebsOptimized"] !== undefined) {
    contents.EbsOptimized = output["ebsOptimized"] == "true";
  }
  if (output["iamInstanceProfile"] !== undefined) {
    contents.IamInstanceProfile = deserializeAws_ec2IamInstanceProfileSpecification(
      output["iamInstanceProfile"],
      context
    );
  }
  if (output["imageId"] !== undefined) {
    contents.ImageId = output["imageId"];
  }
  if (output["instanceType"] !== undefined) {
    contents.InstanceType = output["instanceType"];
  }
  if (output["kernelId"] !== undefined) {
    contents.KernelId = output["kernelId"];
  }
  if (output["keyName"] !== undefined) {
    contents.KeyName = output["keyName"];
  }
  if (output["monitoring"] !== undefined) {
    contents.Monitoring = deserializeAws_ec2RunInstancesMonitoringEnabled(
      output["monitoring"],
      context
    );
  }
  if (output.networkInterfaceSet === "") {
    contents.NetworkInterfaces = [];
  }
  if (
    output["networkInterfaceSet"] !== undefined &&
    output["networkInterfaceSet"]["item"] !== undefined
  ) {
    contents.NetworkInterfaces = deserializeAws_ec2InstanceNetworkInterfaceSpecificationList(
      __getArrayIfSingleItem(output["networkInterfaceSet"]["item"]),
      context
    );
  }
  if (output["placement"] !== undefined) {
    contents.Placement = deserializeAws_ec2SpotPlacement(
      output["placement"],
      context
    );
  }
  if (output["ramdiskId"] !== undefined) {
    contents.RamdiskId = output["ramdiskId"];
  }
  if (output.groupSet === "") {
    contents.SecurityGroups = [];
  }
  if (
    output["groupSet"] !== undefined &&
    output["groupSet"]["item"] !== undefined
  ) {
    contents.SecurityGroups = deserializeAws_ec2GroupIdentifierList(
      __getArrayIfSingleItem(output["groupSet"]["item"]),
      context
    );
  }
  if (output["subnetId"] !== undefined) {
    contents.SubnetId = output["subnetId"];
  }
  if (output["userData"] !== undefined) {
    contents.UserData = output["userData"];
  }
  return contents;
};

const deserializeAws_ec2LaunchSpecsList = (
  output: any,
  context: __SerdeContext
): SpotFleetLaunchSpecification[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2SpotFleetLaunchSpecification(entry, context)
  );
};

const deserializeAws_ec2LaunchTemplate = (
  output: any,
  context: __SerdeContext
): LaunchTemplate => {
  let contents: any = {
    __type: "LaunchTemplate",
    CreateTime: undefined,
    CreatedBy: undefined,
    DefaultVersionNumber: undefined,
    LatestVersionNumber: undefined,
    LaunchTemplateId: undefined,
    LaunchTemplateName: undefined,
    Tags: undefined
  };
  if (output["createTime"] !== undefined) {
    contents.CreateTime = new Date(output["createTime"]);
  }
  if (output["createdBy"] !== undefined) {
    contents.CreatedBy = output["createdBy"];
  }
  if (output["defaultVersionNumber"] !== undefined) {
    contents.DefaultVersionNumber = parseInt(output["defaultVersionNumber"]);
  }
  if (output["latestVersionNumber"] !== undefined) {
    contents.LatestVersionNumber = parseInt(output["latestVersionNumber"]);
  }
  if (output["launchTemplateId"] !== undefined) {
    contents.LaunchTemplateId = output["launchTemplateId"];
  }
  if (output["launchTemplateName"] !== undefined) {
    contents.LaunchTemplateName = output["launchTemplateName"];
  }
  if (output.tagSet === "") {
    contents.Tags = [];
  }
  if (
    output["tagSet"] !== undefined &&
    output["tagSet"]["item"] !== undefined
  ) {
    contents.Tags = deserializeAws_ec2TagList(
      __getArrayIfSingleItem(output["tagSet"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2LaunchTemplateAndOverridesResponse = (
  output: any,
  context: __SerdeContext
): LaunchTemplateAndOverridesResponse => {
  let contents: any = {
    __type: "LaunchTemplateAndOverridesResponse",
    LaunchTemplateSpecification: undefined,
    Overrides: undefined
  };
  if (output["launchTemplateSpecification"] !== undefined) {
    contents.LaunchTemplateSpecification = deserializeAws_ec2FleetLaunchTemplateSpecification(
      output["launchTemplateSpecification"],
      context
    );
  }
  if (output["overrides"] !== undefined) {
    contents.Overrides = deserializeAws_ec2FleetLaunchTemplateOverrides(
      output["overrides"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2LaunchTemplateBlockDeviceMapping = (
  output: any,
  context: __SerdeContext
): LaunchTemplateBlockDeviceMapping => {
  let contents: any = {
    __type: "LaunchTemplateBlockDeviceMapping",
    DeviceName: undefined,
    Ebs: undefined,
    NoDevice: undefined,
    VirtualName: undefined
  };
  if (output["deviceName"] !== undefined) {
    contents.DeviceName = output["deviceName"];
  }
  if (output["ebs"] !== undefined) {
    contents.Ebs = deserializeAws_ec2LaunchTemplateEbsBlockDevice(
      output["ebs"],
      context
    );
  }
  if (output["noDevice"] !== undefined) {
    contents.NoDevice = output["noDevice"];
  }
  if (output["virtualName"] !== undefined) {
    contents.VirtualName = output["virtualName"];
  }
  return contents;
};

const deserializeAws_ec2LaunchTemplateBlockDeviceMappingList = (
  output: any,
  context: __SerdeContext
): LaunchTemplateBlockDeviceMapping[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2LaunchTemplateBlockDeviceMapping(entry, context)
  );
};

const deserializeAws_ec2LaunchTemplateCapacityReservationSpecificationResponse = (
  output: any,
  context: __SerdeContext
): LaunchTemplateCapacityReservationSpecificationResponse => {
  let contents: any = {
    __type: "LaunchTemplateCapacityReservationSpecificationResponse",
    CapacityReservationPreference: undefined,
    CapacityReservationTarget: undefined
  };
  if (output["capacityReservationPreference"] !== undefined) {
    contents.CapacityReservationPreference =
      output["capacityReservationPreference"];
  }
  if (output["capacityReservationTarget"] !== undefined) {
    contents.CapacityReservationTarget = deserializeAws_ec2CapacityReservationTargetResponse(
      output["capacityReservationTarget"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2LaunchTemplateConfig = (
  output: any,
  context: __SerdeContext
): LaunchTemplateConfig => {
  let contents: any = {
    __type: "LaunchTemplateConfig",
    LaunchTemplateSpecification: undefined,
    Overrides: undefined
  };
  if (output["launchTemplateSpecification"] !== undefined) {
    contents.LaunchTemplateSpecification = deserializeAws_ec2FleetLaunchTemplateSpecification(
      output["launchTemplateSpecification"],
      context
    );
  }
  if (output.overrides === "") {
    contents.Overrides = [];
  }
  if (
    output["overrides"] !== undefined &&
    output["overrides"]["item"] !== undefined
  ) {
    contents.Overrides = deserializeAws_ec2LaunchTemplateOverridesList(
      __getArrayIfSingleItem(output["overrides"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2LaunchTemplateConfigList = (
  output: any,
  context: __SerdeContext
): LaunchTemplateConfig[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2LaunchTemplateConfig(entry, context)
  );
};

const deserializeAws_ec2LaunchTemplateCpuOptions = (
  output: any,
  context: __SerdeContext
): LaunchTemplateCpuOptions => {
  let contents: any = {
    __type: "LaunchTemplateCpuOptions",
    CoreCount: undefined,
    ThreadsPerCore: undefined
  };
  if (output["coreCount"] !== undefined) {
    contents.CoreCount = parseInt(output["coreCount"]);
  }
  if (output["threadsPerCore"] !== undefined) {
    contents.ThreadsPerCore = parseInt(output["threadsPerCore"]);
  }
  return contents;
};

const deserializeAws_ec2LaunchTemplateEbsBlockDevice = (
  output: any,
  context: __SerdeContext
): LaunchTemplateEbsBlockDevice => {
  let contents: any = {
    __type: "LaunchTemplateEbsBlockDevice",
    DeleteOnTermination: undefined,
    Encrypted: undefined,
    Iops: undefined,
    KmsKeyId: undefined,
    SnapshotId: undefined,
    VolumeSize: undefined,
    VolumeType: undefined
  };
  if (output["deleteOnTermination"] !== undefined) {
    contents.DeleteOnTermination = output["deleteOnTermination"] == "true";
  }
  if (output["encrypted"] !== undefined) {
    contents.Encrypted = output["encrypted"] == "true";
  }
  if (output["iops"] !== undefined) {
    contents.Iops = parseInt(output["iops"]);
  }
  if (output["kmsKeyId"] !== undefined) {
    contents.KmsKeyId = output["kmsKeyId"];
  }
  if (output["snapshotId"] !== undefined) {
    contents.SnapshotId = output["snapshotId"];
  }
  if (output["volumeSize"] !== undefined) {
    contents.VolumeSize = parseInt(output["volumeSize"]);
  }
  if (output["volumeType"] !== undefined) {
    contents.VolumeType = output["volumeType"];
  }
  return contents;
};

const deserializeAws_ec2LaunchTemplateElasticInferenceAcceleratorResponse = (
  output: any,
  context: __SerdeContext
): LaunchTemplateElasticInferenceAcceleratorResponse => {
  let contents: any = {
    __type: "LaunchTemplateElasticInferenceAcceleratorResponse",
    Count: undefined,
    Type: undefined
  };
  if (output["count"] !== undefined) {
    contents.Count = parseInt(output["count"]);
  }
  if (output["type"] !== undefined) {
    contents.Type = output["type"];
  }
  return contents;
};

const deserializeAws_ec2LaunchTemplateElasticInferenceAcceleratorResponseList = (
  output: any,
  context: __SerdeContext
): LaunchTemplateElasticInferenceAcceleratorResponse[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2LaunchTemplateElasticInferenceAcceleratorResponse(
      entry,
      context
    )
  );
};

const deserializeAws_ec2LaunchTemplateHibernationOptions = (
  output: any,
  context: __SerdeContext
): LaunchTemplateHibernationOptions => {
  let contents: any = {
    __type: "LaunchTemplateHibernationOptions",
    Configured: undefined
  };
  if (output["configured"] !== undefined) {
    contents.Configured = output["configured"] == "true";
  }
  return contents;
};

const deserializeAws_ec2LaunchTemplateIamInstanceProfileSpecification = (
  output: any,
  context: __SerdeContext
): LaunchTemplateIamInstanceProfileSpecification => {
  let contents: any = {
    __type: "LaunchTemplateIamInstanceProfileSpecification",
    Arn: undefined,
    Name: undefined
  };
  if (output["arn"] !== undefined) {
    contents.Arn = output["arn"];
  }
  if (output["name"] !== undefined) {
    contents.Name = output["name"];
  }
  return contents;
};

const deserializeAws_ec2LaunchTemplateInstanceMarketOptions = (
  output: any,
  context: __SerdeContext
): LaunchTemplateInstanceMarketOptions => {
  let contents: any = {
    __type: "LaunchTemplateInstanceMarketOptions",
    MarketType: undefined,
    SpotOptions: undefined
  };
  if (output["marketType"] !== undefined) {
    contents.MarketType = output["marketType"];
  }
  if (output["spotOptions"] !== undefined) {
    contents.SpotOptions = deserializeAws_ec2LaunchTemplateSpotMarketOptions(
      output["spotOptions"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2LaunchTemplateInstanceMetadataOptions = (
  output: any,
  context: __SerdeContext
): LaunchTemplateInstanceMetadataOptions => {
  let contents: any = {
    __type: "LaunchTemplateInstanceMetadataOptions",
    HttpEndpoint: undefined,
    HttpPutResponseHopLimit: undefined,
    HttpTokens: undefined,
    State: undefined
  };
  if (output["httpEndpoint"] !== undefined) {
    contents.HttpEndpoint = output["httpEndpoint"];
  }
  if (output["httpPutResponseHopLimit"] !== undefined) {
    contents.HttpPutResponseHopLimit = parseInt(
      output["httpPutResponseHopLimit"]
    );
  }
  if (output["httpTokens"] !== undefined) {
    contents.HttpTokens = output["httpTokens"];
  }
  if (output["state"] !== undefined) {
    contents.State = output["state"];
  }
  return contents;
};

const deserializeAws_ec2LaunchTemplateInstanceNetworkInterfaceSpecification = (
  output: any,
  context: __SerdeContext
): LaunchTemplateInstanceNetworkInterfaceSpecification => {
  let contents: any = {
    __type: "LaunchTemplateInstanceNetworkInterfaceSpecification",
    AssociatePublicIpAddress: undefined,
    DeleteOnTermination: undefined,
    Description: undefined,
    DeviceIndex: undefined,
    Groups: undefined,
    InterfaceType: undefined,
    Ipv6AddressCount: undefined,
    Ipv6Addresses: undefined,
    NetworkInterfaceId: undefined,
    PrivateIpAddress: undefined,
    PrivateIpAddresses: undefined,
    SecondaryPrivateIpAddressCount: undefined,
    SubnetId: undefined
  };
  if (output["associatePublicIpAddress"] !== undefined) {
    contents.AssociatePublicIpAddress =
      output["associatePublicIpAddress"] == "true";
  }
  if (output["deleteOnTermination"] !== undefined) {
    contents.DeleteOnTermination = output["deleteOnTermination"] == "true";
  }
  if (output["description"] !== undefined) {
    contents.Description = output["description"];
  }
  if (output["deviceIndex"] !== undefined) {
    contents.DeviceIndex = parseInt(output["deviceIndex"]);
  }
  if (output.groupSet === "") {
    contents.Groups = [];
  }
  if (
    output["groupSet"] !== undefined &&
    output["groupSet"]["groupId"] !== undefined
  ) {
    contents.Groups = deserializeAws_ec2GroupIdStringList(
      __getArrayIfSingleItem(output["groupSet"]["groupId"]),
      context
    );
  }
  if (output["interfaceType"] !== undefined) {
    contents.InterfaceType = output["interfaceType"];
  }
  if (output["ipv6AddressCount"] !== undefined) {
    contents.Ipv6AddressCount = parseInt(output["ipv6AddressCount"]);
  }
  if (output.ipv6AddressesSet === "") {
    contents.Ipv6Addresses = [];
  }
  if (
    output["ipv6AddressesSet"] !== undefined &&
    output["ipv6AddressesSet"]["item"] !== undefined
  ) {
    contents.Ipv6Addresses = deserializeAws_ec2InstanceIpv6AddressList(
      __getArrayIfSingleItem(output["ipv6AddressesSet"]["item"]),
      context
    );
  }
  if (output["networkInterfaceId"] !== undefined) {
    contents.NetworkInterfaceId = output["networkInterfaceId"];
  }
  if (output["privateIpAddress"] !== undefined) {
    contents.PrivateIpAddress = output["privateIpAddress"];
  }
  if (output.privateIpAddressesSet === "") {
    contents.PrivateIpAddresses = [];
  }
  if (
    output["privateIpAddressesSet"] !== undefined &&
    output["privateIpAddressesSet"]["item"] !== undefined
  ) {
    contents.PrivateIpAddresses = deserializeAws_ec2PrivateIpAddressSpecificationList(
      __getArrayIfSingleItem(output["privateIpAddressesSet"]["item"]),
      context
    );
  }
  if (output["secondaryPrivateIpAddressCount"] !== undefined) {
    contents.SecondaryPrivateIpAddressCount = parseInt(
      output["secondaryPrivateIpAddressCount"]
    );
  }
  if (output["subnetId"] !== undefined) {
    contents.SubnetId = output["subnetId"];
  }
  return contents;
};

const deserializeAws_ec2LaunchTemplateInstanceNetworkInterfaceSpecificationList = (
  output: any,
  context: __SerdeContext
): LaunchTemplateInstanceNetworkInterfaceSpecification[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2LaunchTemplateInstanceNetworkInterfaceSpecification(
      entry,
      context
    )
  );
};

const deserializeAws_ec2LaunchTemplateLicenseConfiguration = (
  output: any,
  context: __SerdeContext
): LaunchTemplateLicenseConfiguration => {
  let contents: any = {
    __type: "LaunchTemplateLicenseConfiguration",
    LicenseConfigurationArn: undefined
  };
  if (output["licenseConfigurationArn"] !== undefined) {
    contents.LicenseConfigurationArn = output["licenseConfigurationArn"];
  }
  return contents;
};

const deserializeAws_ec2LaunchTemplateLicenseList = (
  output: any,
  context: __SerdeContext
): LaunchTemplateLicenseConfiguration[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2LaunchTemplateLicenseConfiguration(entry, context)
  );
};

const deserializeAws_ec2LaunchTemplateOverrides = (
  output: any,
  context: __SerdeContext
): LaunchTemplateOverrides => {
  let contents: any = {
    __type: "LaunchTemplateOverrides",
    AvailabilityZone: undefined,
    InstanceType: undefined,
    Priority: undefined,
    SpotPrice: undefined,
    SubnetId: undefined,
    WeightedCapacity: undefined
  };
  if (output["availabilityZone"] !== undefined) {
    contents.AvailabilityZone = output["availabilityZone"];
  }
  if (output["instanceType"] !== undefined) {
    contents.InstanceType = output["instanceType"];
  }
  if (output["priority"] !== undefined) {
    contents.Priority = parseFloat(output["priority"]);
  }
  if (output["spotPrice"] !== undefined) {
    contents.SpotPrice = output["spotPrice"];
  }
  if (output["subnetId"] !== undefined) {
    contents.SubnetId = output["subnetId"];
  }
  if (output["weightedCapacity"] !== undefined) {
    contents.WeightedCapacity = parseFloat(output["weightedCapacity"]);
  }
  return contents;
};

const deserializeAws_ec2LaunchTemplateOverridesList = (
  output: any,
  context: __SerdeContext
): LaunchTemplateOverrides[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2LaunchTemplateOverrides(entry, context)
  );
};

const deserializeAws_ec2LaunchTemplatePlacement = (
  output: any,
  context: __SerdeContext
): LaunchTemplatePlacement => {
  let contents: any = {
    __type: "LaunchTemplatePlacement",
    Affinity: undefined,
    AvailabilityZone: undefined,
    GroupName: undefined,
    HostId: undefined,
    HostResourceGroupArn: undefined,
    PartitionNumber: undefined,
    SpreadDomain: undefined,
    Tenancy: undefined
  };
  if (output["affinity"] !== undefined) {
    contents.Affinity = output["affinity"];
  }
  if (output["availabilityZone"] !== undefined) {
    contents.AvailabilityZone = output["availabilityZone"];
  }
  if (output["groupName"] !== undefined) {
    contents.GroupName = output["groupName"];
  }
  if (output["hostId"] !== undefined) {
    contents.HostId = output["hostId"];
  }
  if (output["hostResourceGroupArn"] !== undefined) {
    contents.HostResourceGroupArn = output["hostResourceGroupArn"];
  }
  if (output["partitionNumber"] !== undefined) {
    contents.PartitionNumber = parseInt(output["partitionNumber"]);
  }
  if (output["spreadDomain"] !== undefined) {
    contents.SpreadDomain = output["spreadDomain"];
  }
  if (output["tenancy"] !== undefined) {
    contents.Tenancy = output["tenancy"];
  }
  return contents;
};

const deserializeAws_ec2LaunchTemplateSet = (
  output: any,
  context: __SerdeContext
): LaunchTemplate[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2LaunchTemplate(entry, context)
  );
};

const deserializeAws_ec2LaunchTemplatesMonitoring = (
  output: any,
  context: __SerdeContext
): LaunchTemplatesMonitoring => {
  let contents: any = {
    __type: "LaunchTemplatesMonitoring",
    Enabled: undefined
  };
  if (output["enabled"] !== undefined) {
    contents.Enabled = output["enabled"] == "true";
  }
  return contents;
};

const deserializeAws_ec2LaunchTemplateSpotMarketOptions = (
  output: any,
  context: __SerdeContext
): LaunchTemplateSpotMarketOptions => {
  let contents: any = {
    __type: "LaunchTemplateSpotMarketOptions",
    BlockDurationMinutes: undefined,
    InstanceInterruptionBehavior: undefined,
    MaxPrice: undefined,
    SpotInstanceType: undefined,
    ValidUntil: undefined
  };
  if (output["blockDurationMinutes"] !== undefined) {
    contents.BlockDurationMinutes = parseInt(output["blockDurationMinutes"]);
  }
  if (output["instanceInterruptionBehavior"] !== undefined) {
    contents.InstanceInterruptionBehavior =
      output["instanceInterruptionBehavior"];
  }
  if (output["maxPrice"] !== undefined) {
    contents.MaxPrice = output["maxPrice"];
  }
  if (output["spotInstanceType"] !== undefined) {
    contents.SpotInstanceType = output["spotInstanceType"];
  }
  if (output["validUntil"] !== undefined) {
    contents.ValidUntil = new Date(output["validUntil"]);
  }
  return contents;
};

const deserializeAws_ec2LaunchTemplateTagSpecification = (
  output: any,
  context: __SerdeContext
): LaunchTemplateTagSpecification => {
  let contents: any = {
    __type: "LaunchTemplateTagSpecification",
    ResourceType: undefined,
    Tags: undefined
  };
  if (output["resourceType"] !== undefined) {
    contents.ResourceType = output["resourceType"];
  }
  if (output.tagSet === "") {
    contents.Tags = [];
  }
  if (
    output["tagSet"] !== undefined &&
    output["tagSet"]["item"] !== undefined
  ) {
    contents.Tags = deserializeAws_ec2TagList(
      __getArrayIfSingleItem(output["tagSet"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2LaunchTemplateTagSpecificationList = (
  output: any,
  context: __SerdeContext
): LaunchTemplateTagSpecification[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2LaunchTemplateTagSpecification(entry, context)
  );
};

const deserializeAws_ec2LaunchTemplateVersion = (
  output: any,
  context: __SerdeContext
): LaunchTemplateVersion => {
  let contents: any = {
    __type: "LaunchTemplateVersion",
    CreateTime: undefined,
    CreatedBy: undefined,
    DefaultVersion: undefined,
    LaunchTemplateData: undefined,
    LaunchTemplateId: undefined,
    LaunchTemplateName: undefined,
    VersionDescription: undefined,
    VersionNumber: undefined
  };
  if (output["createTime"] !== undefined) {
    contents.CreateTime = new Date(output["createTime"]);
  }
  if (output["createdBy"] !== undefined) {
    contents.CreatedBy = output["createdBy"];
  }
  if (output["defaultVersion"] !== undefined) {
    contents.DefaultVersion = output["defaultVersion"] == "true";
  }
  if (output["launchTemplateData"] !== undefined) {
    contents.LaunchTemplateData = deserializeAws_ec2ResponseLaunchTemplateData(
      output["launchTemplateData"],
      context
    );
  }
  if (output["launchTemplateId"] !== undefined) {
    contents.LaunchTemplateId = output["launchTemplateId"];
  }
  if (output["launchTemplateName"] !== undefined) {
    contents.LaunchTemplateName = output["launchTemplateName"];
  }
  if (output["versionDescription"] !== undefined) {
    contents.VersionDescription = output["versionDescription"];
  }
  if (output["versionNumber"] !== undefined) {
    contents.VersionNumber = parseInt(output["versionNumber"]);
  }
  return contents;
};

const deserializeAws_ec2LaunchTemplateVersionSet = (
  output: any,
  context: __SerdeContext
): LaunchTemplateVersion[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2LaunchTemplateVersion(entry, context)
  );
};

const deserializeAws_ec2LicenseConfiguration = (
  output: any,
  context: __SerdeContext
): LicenseConfiguration => {
  let contents: any = {
    __type: "LicenseConfiguration",
    LicenseConfigurationArn: undefined
  };
  if (output["licenseConfigurationArn"] !== undefined) {
    contents.LicenseConfigurationArn = output["licenseConfigurationArn"];
  }
  return contents;
};

const deserializeAws_ec2LicenseList = (
  output: any,
  context: __SerdeContext
): LicenseConfiguration[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2LicenseConfiguration(entry, context)
  );
};

const deserializeAws_ec2LoadBalancersConfig = (
  output: any,
  context: __SerdeContext
): LoadBalancersConfig => {
  let contents: any = {
    __type: "LoadBalancersConfig",
    ClassicLoadBalancersConfig: undefined,
    TargetGroupsConfig: undefined
  };
  if (output["classicLoadBalancersConfig"] !== undefined) {
    contents.ClassicLoadBalancersConfig = deserializeAws_ec2ClassicLoadBalancersConfig(
      output["classicLoadBalancersConfig"],
      context
    );
  }
  if (output["targetGroupsConfig"] !== undefined) {
    contents.TargetGroupsConfig = deserializeAws_ec2TargetGroupsConfig(
      output["targetGroupsConfig"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2LoadPermission = (
  output: any,
  context: __SerdeContext
): LoadPermission => {
  let contents: any = {
    __type: "LoadPermission",
    Group: undefined,
    UserId: undefined
  };
  if (output["group"] !== undefined) {
    contents.Group = output["group"];
  }
  if (output["userId"] !== undefined) {
    contents.UserId = output["userId"];
  }
  return contents;
};

const deserializeAws_ec2LoadPermissionList = (
  output: any,
  context: __SerdeContext
): LoadPermission[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2LoadPermission(entry, context)
  );
};

const deserializeAws_ec2LocalGateway = (
  output: any,
  context: __SerdeContext
): LocalGateway => {
  let contents: any = {
    __type: "LocalGateway",
    LocalGatewayId: undefined,
    OutpostArn: undefined,
    OwnerId: undefined,
    State: undefined,
    Tags: undefined
  };
  if (output["localGatewayId"] !== undefined) {
    contents.LocalGatewayId = output["localGatewayId"];
  }
  if (output["outpostArn"] !== undefined) {
    contents.OutpostArn = output["outpostArn"];
  }
  if (output["ownerId"] !== undefined) {
    contents.OwnerId = output["ownerId"];
  }
  if (output["state"] !== undefined) {
    contents.State = output["state"];
  }
  if (output.tagSet === "") {
    contents.Tags = [];
  }
  if (
    output["tagSet"] !== undefined &&
    output["tagSet"]["item"] !== undefined
  ) {
    contents.Tags = deserializeAws_ec2TagList(
      __getArrayIfSingleItem(output["tagSet"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2LocalGatewayRoute = (
  output: any,
  context: __SerdeContext
): LocalGatewayRoute => {
  let contents: any = {
    __type: "LocalGatewayRoute",
    DestinationCidrBlock: undefined,
    LocalGatewayRouteTableId: undefined,
    LocalGatewayVirtualInterfaceGroupId: undefined,
    State: undefined,
    Type: undefined
  };
  if (output["destinationCidrBlock"] !== undefined) {
    contents.DestinationCidrBlock = output["destinationCidrBlock"];
  }
  if (output["localGatewayRouteTableId"] !== undefined) {
    contents.LocalGatewayRouteTableId = output["localGatewayRouteTableId"];
  }
  if (output["localGatewayVirtualInterfaceGroupId"] !== undefined) {
    contents.LocalGatewayVirtualInterfaceGroupId =
      output["localGatewayVirtualInterfaceGroupId"];
  }
  if (output["state"] !== undefined) {
    contents.State = output["state"];
  }
  if (output["type"] !== undefined) {
    contents.Type = output["type"];
  }
  return contents;
};

const deserializeAws_ec2LocalGatewayRouteList = (
  output: any,
  context: __SerdeContext
): LocalGatewayRoute[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2LocalGatewayRoute(entry, context)
  );
};

const deserializeAws_ec2LocalGatewayRouteTable = (
  output: any,
  context: __SerdeContext
): LocalGatewayRouteTable => {
  let contents: any = {
    __type: "LocalGatewayRouteTable",
    LocalGatewayId: undefined,
    LocalGatewayRouteTableId: undefined,
    OutpostArn: undefined,
    State: undefined,
    Tags: undefined
  };
  if (output["localGatewayId"] !== undefined) {
    contents.LocalGatewayId = output["localGatewayId"];
  }
  if (output["localGatewayRouteTableId"] !== undefined) {
    contents.LocalGatewayRouteTableId = output["localGatewayRouteTableId"];
  }
  if (output["outpostArn"] !== undefined) {
    contents.OutpostArn = output["outpostArn"];
  }
  if (output["state"] !== undefined) {
    contents.State = output["state"];
  }
  if (output.tagSet === "") {
    contents.Tags = [];
  }
  if (
    output["tagSet"] !== undefined &&
    output["tagSet"]["item"] !== undefined
  ) {
    contents.Tags = deserializeAws_ec2TagList(
      __getArrayIfSingleItem(output["tagSet"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2LocalGatewayRouteTableSet = (
  output: any,
  context: __SerdeContext
): LocalGatewayRouteTable[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2LocalGatewayRouteTable(entry, context)
  );
};

const deserializeAws_ec2LocalGatewayRouteTableVirtualInterfaceGroupAssociation = (
  output: any,
  context: __SerdeContext
): LocalGatewayRouteTableVirtualInterfaceGroupAssociation => {
  let contents: any = {
    __type: "LocalGatewayRouteTableVirtualInterfaceGroupAssociation",
    LocalGatewayId: undefined,
    LocalGatewayRouteTableId: undefined,
    LocalGatewayRouteTableVirtualInterfaceGroupAssociationId: undefined,
    LocalGatewayVirtualInterfaceGroupId: undefined,
    State: undefined,
    Tags: undefined
  };
  if (output["localGatewayId"] !== undefined) {
    contents.LocalGatewayId = output["localGatewayId"];
  }
  if (output["localGatewayRouteTableId"] !== undefined) {
    contents.LocalGatewayRouteTableId = output["localGatewayRouteTableId"];
  }
  if (
    output["localGatewayRouteTableVirtualInterfaceGroupAssociationId"] !==
    undefined
  ) {
    contents.LocalGatewayRouteTableVirtualInterfaceGroupAssociationId =
      output["localGatewayRouteTableVirtualInterfaceGroupAssociationId"];
  }
  if (output["localGatewayVirtualInterfaceGroupId"] !== undefined) {
    contents.LocalGatewayVirtualInterfaceGroupId =
      output["localGatewayVirtualInterfaceGroupId"];
  }
  if (output["state"] !== undefined) {
    contents.State = output["state"];
  }
  if (output.tagSet === "") {
    contents.Tags = [];
  }
  if (
    output["tagSet"] !== undefined &&
    output["tagSet"]["item"] !== undefined
  ) {
    contents.Tags = deserializeAws_ec2TagList(
      __getArrayIfSingleItem(output["tagSet"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2LocalGatewayRouteTableVirtualInterfaceGroupAssociationSet = (
  output: any,
  context: __SerdeContext
): LocalGatewayRouteTableVirtualInterfaceGroupAssociation[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2LocalGatewayRouteTableVirtualInterfaceGroupAssociation(
      entry,
      context
    )
  );
};

const deserializeAws_ec2LocalGatewayRouteTableVpcAssociation = (
  output: any,
  context: __SerdeContext
): LocalGatewayRouteTableVpcAssociation => {
  let contents: any = {
    __type: "LocalGatewayRouteTableVpcAssociation",
    LocalGatewayId: undefined,
    LocalGatewayRouteTableId: undefined,
    LocalGatewayRouteTableVpcAssociationId: undefined,
    State: undefined,
    Tags: undefined,
    VpcId: undefined
  };
  if (output["localGatewayId"] !== undefined) {
    contents.LocalGatewayId = output["localGatewayId"];
  }
  if (output["localGatewayRouteTableId"] !== undefined) {
    contents.LocalGatewayRouteTableId = output["localGatewayRouteTableId"];
  }
  if (output["localGatewayRouteTableVpcAssociationId"] !== undefined) {
    contents.LocalGatewayRouteTableVpcAssociationId =
      output["localGatewayRouteTableVpcAssociationId"];
  }
  if (output["state"] !== undefined) {
    contents.State = output["state"];
  }
  if (output.tagSet === "") {
    contents.Tags = [];
  }
  if (
    output["tagSet"] !== undefined &&
    output["tagSet"]["item"] !== undefined
  ) {
    contents.Tags = deserializeAws_ec2TagList(
      __getArrayIfSingleItem(output["tagSet"]["item"]),
      context
    );
  }
  if (output["vpcId"] !== undefined) {
    contents.VpcId = output["vpcId"];
  }
  return contents;
};

const deserializeAws_ec2LocalGatewayRouteTableVpcAssociationSet = (
  output: any,
  context: __SerdeContext
): LocalGatewayRouteTableVpcAssociation[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2LocalGatewayRouteTableVpcAssociation(entry, context)
  );
};

const deserializeAws_ec2LocalGatewaySet = (
  output: any,
  context: __SerdeContext
): LocalGateway[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2LocalGateway(entry, context)
  );
};

const deserializeAws_ec2LocalGatewayVirtualInterface = (
  output: any,
  context: __SerdeContext
): LocalGatewayVirtualInterface => {
  let contents: any = {
    __type: "LocalGatewayVirtualInterface",
    LocalAddress: undefined,
    LocalBgpAsn: undefined,
    LocalGatewayId: undefined,
    LocalGatewayVirtualInterfaceId: undefined,
    PeerAddress: undefined,
    PeerBgpAsn: undefined,
    Tags: undefined,
    Vlan: undefined
  };
  if (output["localAddress"] !== undefined) {
    contents.LocalAddress = output["localAddress"];
  }
  if (output["localBgpAsn"] !== undefined) {
    contents.LocalBgpAsn = parseInt(output["localBgpAsn"]);
  }
  if (output["localGatewayId"] !== undefined) {
    contents.LocalGatewayId = output["localGatewayId"];
  }
  if (output["localGatewayVirtualInterfaceId"] !== undefined) {
    contents.LocalGatewayVirtualInterfaceId =
      output["localGatewayVirtualInterfaceId"];
  }
  if (output["peerAddress"] !== undefined) {
    contents.PeerAddress = output["peerAddress"];
  }
  if (output["peerBgpAsn"] !== undefined) {
    contents.PeerBgpAsn = parseInt(output["peerBgpAsn"]);
  }
  if (output.tagSet === "") {
    contents.Tags = [];
  }
  if (
    output["tagSet"] !== undefined &&
    output["tagSet"]["item"] !== undefined
  ) {
    contents.Tags = deserializeAws_ec2TagList(
      __getArrayIfSingleItem(output["tagSet"]["item"]),
      context
    );
  }
  if (output["vlan"] !== undefined) {
    contents.Vlan = parseInt(output["vlan"]);
  }
  return contents;
};

const deserializeAws_ec2LocalGatewayVirtualInterfaceGroup = (
  output: any,
  context: __SerdeContext
): LocalGatewayVirtualInterfaceGroup => {
  let contents: any = {
    __type: "LocalGatewayVirtualInterfaceGroup",
    LocalGatewayId: undefined,
    LocalGatewayVirtualInterfaceGroupId: undefined,
    LocalGatewayVirtualInterfaceIds: undefined,
    Tags: undefined
  };
  if (output["localGatewayId"] !== undefined) {
    contents.LocalGatewayId = output["localGatewayId"];
  }
  if (output["localGatewayVirtualInterfaceGroupId"] !== undefined) {
    contents.LocalGatewayVirtualInterfaceGroupId =
      output["localGatewayVirtualInterfaceGroupId"];
  }
  if (output.localGatewayVirtualInterfaceIdSet === "") {
    contents.LocalGatewayVirtualInterfaceIds = [];
  }
  if (
    output["localGatewayVirtualInterfaceIdSet"] !== undefined &&
    output["localGatewayVirtualInterfaceIdSet"]["item"] !== undefined
  ) {
    contents.LocalGatewayVirtualInterfaceIds = deserializeAws_ec2LocalGatewayVirtualInterfaceIdSet(
      __getArrayIfSingleItem(
        output["localGatewayVirtualInterfaceIdSet"]["item"]
      ),
      context
    );
  }
  if (output.tagSet === "") {
    contents.Tags = [];
  }
  if (
    output["tagSet"] !== undefined &&
    output["tagSet"]["item"] !== undefined
  ) {
    contents.Tags = deserializeAws_ec2TagList(
      __getArrayIfSingleItem(output["tagSet"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2LocalGatewayVirtualInterfaceGroupSet = (
  output: any,
  context: __SerdeContext
): LocalGatewayVirtualInterfaceGroup[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2LocalGatewayVirtualInterfaceGroup(entry, context)
  );
};

const deserializeAws_ec2LocalGatewayVirtualInterfaceIdSet = (
  output: any,
  context: __SerdeContext
): string[] => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_ec2LocalGatewayVirtualInterfaceSet = (
  output: any,
  context: __SerdeContext
): LocalGatewayVirtualInterface[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2LocalGatewayVirtualInterface(entry, context)
  );
};

const deserializeAws_ec2MemoryInfo = (
  output: any,
  context: __SerdeContext
): MemoryInfo => {
  let contents: any = {
    __type: "MemoryInfo",
    SizeInMiB: undefined
  };
  if (output["sizeInMiB"] !== undefined) {
    contents.SizeInMiB = parseInt(output["sizeInMiB"]);
  }
  return contents;
};

const deserializeAws_ec2ModifyCapacityReservationResult = (
  output: any,
  context: __SerdeContext
): ModifyCapacityReservationResult => {
  let contents: any = {
    __type: "ModifyCapacityReservationResult",
    Return: undefined
  };
  if (output["return"] !== undefined) {
    contents.Return = output["return"] == "true";
  }
  return contents;
};

const deserializeAws_ec2ModifyClientVpnEndpointResult = (
  output: any,
  context: __SerdeContext
): ModifyClientVpnEndpointResult => {
  let contents: any = {
    __type: "ModifyClientVpnEndpointResult",
    Return: undefined
  };
  if (output["return"] !== undefined) {
    contents.Return = output["return"] == "true";
  }
  return contents;
};

const deserializeAws_ec2ModifyDefaultCreditSpecificationResult = (
  output: any,
  context: __SerdeContext
): ModifyDefaultCreditSpecificationResult => {
  let contents: any = {
    __type: "ModifyDefaultCreditSpecificationResult",
    InstanceFamilyCreditSpecification: undefined
  };
  if (output["instanceFamilyCreditSpecification"] !== undefined) {
    contents.InstanceFamilyCreditSpecification = deserializeAws_ec2InstanceFamilyCreditSpecification(
      output["instanceFamilyCreditSpecification"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2ModifyEbsDefaultKmsKeyIdResult = (
  output: any,
  context: __SerdeContext
): ModifyEbsDefaultKmsKeyIdResult => {
  let contents: any = {
    __type: "ModifyEbsDefaultKmsKeyIdResult",
    KmsKeyId: undefined
  };
  if (output["kmsKeyId"] !== undefined) {
    contents.KmsKeyId = output["kmsKeyId"];
  }
  return contents;
};

const deserializeAws_ec2ModifyFleetResult = (
  output: any,
  context: __SerdeContext
): ModifyFleetResult => {
  let contents: any = {
    __type: "ModifyFleetResult",
    Return: undefined
  };
  if (output["return"] !== undefined) {
    contents.Return = output["return"] == "true";
  }
  return contents;
};

const deserializeAws_ec2ModifyFpgaImageAttributeResult = (
  output: any,
  context: __SerdeContext
): ModifyFpgaImageAttributeResult => {
  let contents: any = {
    __type: "ModifyFpgaImageAttributeResult",
    FpgaImageAttribute: undefined
  };
  if (output["fpgaImageAttribute"] !== undefined) {
    contents.FpgaImageAttribute = deserializeAws_ec2FpgaImageAttribute(
      output["fpgaImageAttribute"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2ModifyHostsResult = (
  output: any,
  context: __SerdeContext
): ModifyHostsResult => {
  let contents: any = {
    __type: "ModifyHostsResult",
    Successful: undefined,
    Unsuccessful: undefined
  };
  if (output.successful === "") {
    contents.Successful = [];
  }
  if (
    output["successful"] !== undefined &&
    output["successful"]["item"] !== undefined
  ) {
    contents.Successful = deserializeAws_ec2ResponseHostIdList(
      __getArrayIfSingleItem(output["successful"]["item"]),
      context
    );
  }
  if (output.unsuccessful === "") {
    contents.Unsuccessful = [];
  }
  if (
    output["unsuccessful"] !== undefined &&
    output["unsuccessful"]["item"] !== undefined
  ) {
    contents.Unsuccessful = deserializeAws_ec2UnsuccessfulItemList(
      __getArrayIfSingleItem(output["unsuccessful"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2ModifyInstanceCapacityReservationAttributesResult = (
  output: any,
  context: __SerdeContext
): ModifyInstanceCapacityReservationAttributesResult => {
  let contents: any = {
    __type: "ModifyInstanceCapacityReservationAttributesResult",
    Return: undefined
  };
  if (output["return"] !== undefined) {
    contents.Return = output["return"] == "true";
  }
  return contents;
};

const deserializeAws_ec2ModifyInstanceCreditSpecificationResult = (
  output: any,
  context: __SerdeContext
): ModifyInstanceCreditSpecificationResult => {
  let contents: any = {
    __type: "ModifyInstanceCreditSpecificationResult",
    SuccessfulInstanceCreditSpecifications: undefined,
    UnsuccessfulInstanceCreditSpecifications: undefined
  };
  if (output.successfulInstanceCreditSpecificationSet === "") {
    contents.SuccessfulInstanceCreditSpecifications = [];
  }
  if (
    output["successfulInstanceCreditSpecificationSet"] !== undefined &&
    output["successfulInstanceCreditSpecificationSet"]["item"] !== undefined
  ) {
    contents.SuccessfulInstanceCreditSpecifications = deserializeAws_ec2SuccessfulInstanceCreditSpecificationSet(
      __getArrayIfSingleItem(
        output["successfulInstanceCreditSpecificationSet"]["item"]
      ),
      context
    );
  }
  if (output.unsuccessfulInstanceCreditSpecificationSet === "") {
    contents.UnsuccessfulInstanceCreditSpecifications = [];
  }
  if (
    output["unsuccessfulInstanceCreditSpecificationSet"] !== undefined &&
    output["unsuccessfulInstanceCreditSpecificationSet"]["item"] !== undefined
  ) {
    contents.UnsuccessfulInstanceCreditSpecifications = deserializeAws_ec2UnsuccessfulInstanceCreditSpecificationSet(
      __getArrayIfSingleItem(
        output["unsuccessfulInstanceCreditSpecificationSet"]["item"]
      ),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2ModifyInstanceEventStartTimeResult = (
  output: any,
  context: __SerdeContext
): ModifyInstanceEventStartTimeResult => {
  let contents: any = {
    __type: "ModifyInstanceEventStartTimeResult",
    Event: undefined
  };
  if (output["event"] !== undefined) {
    contents.Event = deserializeAws_ec2InstanceStatusEvent(
      output["event"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2ModifyInstanceMetadataOptionsResult = (
  output: any,
  context: __SerdeContext
): ModifyInstanceMetadataOptionsResult => {
  let contents: any = {
    __type: "ModifyInstanceMetadataOptionsResult",
    InstanceId: undefined,
    InstanceMetadataOptions: undefined
  };
  if (output["instanceId"] !== undefined) {
    contents.InstanceId = output["instanceId"];
  }
  if (output["instanceMetadataOptions"] !== undefined) {
    contents.InstanceMetadataOptions = deserializeAws_ec2InstanceMetadataOptionsResponse(
      output["instanceMetadataOptions"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2ModifyInstancePlacementResult = (
  output: any,
  context: __SerdeContext
): ModifyInstancePlacementResult => {
  let contents: any = {
    __type: "ModifyInstancePlacementResult",
    Return: undefined
  };
  if (output["return"] !== undefined) {
    contents.Return = output["return"] == "true";
  }
  return contents;
};

const deserializeAws_ec2ModifyLaunchTemplateResult = (
  output: any,
  context: __SerdeContext
): ModifyLaunchTemplateResult => {
  let contents: any = {
    __type: "ModifyLaunchTemplateResult",
    LaunchTemplate: undefined
  };
  if (output["launchTemplate"] !== undefined) {
    contents.LaunchTemplate = deserializeAws_ec2LaunchTemplate(
      output["launchTemplate"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2ModifyReservedInstancesResult = (
  output: any,
  context: __SerdeContext
): ModifyReservedInstancesResult => {
  let contents: any = {
    __type: "ModifyReservedInstancesResult",
    ReservedInstancesModificationId: undefined
  };
  if (output["reservedInstancesModificationId"] !== undefined) {
    contents.ReservedInstancesModificationId =
      output["reservedInstancesModificationId"];
  }
  return contents;
};

const deserializeAws_ec2ModifySpotFleetRequestResponse = (
  output: any,
  context: __SerdeContext
): ModifySpotFleetRequestResponse => {
  let contents: any = {
    __type: "ModifySpotFleetRequestResponse",
    Return: undefined
  };
  if (output["return"] !== undefined) {
    contents.Return = output["return"] == "true";
  }
  return contents;
};

const deserializeAws_ec2ModifyTrafficMirrorFilterNetworkServicesResult = (
  output: any,
  context: __SerdeContext
): ModifyTrafficMirrorFilterNetworkServicesResult => {
  let contents: any = {
    __type: "ModifyTrafficMirrorFilterNetworkServicesResult",
    TrafficMirrorFilter: undefined
  };
  if (output["trafficMirrorFilter"] !== undefined) {
    contents.TrafficMirrorFilter = deserializeAws_ec2TrafficMirrorFilter(
      output["trafficMirrorFilter"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2ModifyTrafficMirrorFilterRuleResult = (
  output: any,
  context: __SerdeContext
): ModifyTrafficMirrorFilterRuleResult => {
  let contents: any = {
    __type: "ModifyTrafficMirrorFilterRuleResult",
    TrafficMirrorFilterRule: undefined
  };
  if (output["trafficMirrorFilterRule"] !== undefined) {
    contents.TrafficMirrorFilterRule = deserializeAws_ec2TrafficMirrorFilterRule(
      output["trafficMirrorFilterRule"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2ModifyTrafficMirrorSessionResult = (
  output: any,
  context: __SerdeContext
): ModifyTrafficMirrorSessionResult => {
  let contents: any = {
    __type: "ModifyTrafficMirrorSessionResult",
    TrafficMirrorSession: undefined
  };
  if (output["trafficMirrorSession"] !== undefined) {
    contents.TrafficMirrorSession = deserializeAws_ec2TrafficMirrorSession(
      output["trafficMirrorSession"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2ModifyTransitGatewayVpcAttachmentResult = (
  output: any,
  context: __SerdeContext
): ModifyTransitGatewayVpcAttachmentResult => {
  let contents: any = {
    __type: "ModifyTransitGatewayVpcAttachmentResult",
    TransitGatewayVpcAttachment: undefined
  };
  if (output["transitGatewayVpcAttachment"] !== undefined) {
    contents.TransitGatewayVpcAttachment = deserializeAws_ec2TransitGatewayVpcAttachment(
      output["transitGatewayVpcAttachment"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2ModifyVolumeResult = (
  output: any,
  context: __SerdeContext
): ModifyVolumeResult => {
  let contents: any = {
    __type: "ModifyVolumeResult",
    VolumeModification: undefined
  };
  if (output["volumeModification"] !== undefined) {
    contents.VolumeModification = deserializeAws_ec2VolumeModification(
      output["volumeModification"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2ModifyVpcEndpointConnectionNotificationResult = (
  output: any,
  context: __SerdeContext
): ModifyVpcEndpointConnectionNotificationResult => {
  let contents: any = {
    __type: "ModifyVpcEndpointConnectionNotificationResult",
    ReturnValue: undefined
  };
  if (output["return"] !== undefined) {
    contents.ReturnValue = output["return"] == "true";
  }
  return contents;
};

const deserializeAws_ec2ModifyVpcEndpointResult = (
  output: any,
  context: __SerdeContext
): ModifyVpcEndpointResult => {
  let contents: any = {
    __type: "ModifyVpcEndpointResult",
    Return: undefined
  };
  if (output["return"] !== undefined) {
    contents.Return = output["return"] == "true";
  }
  return contents;
};

const deserializeAws_ec2ModifyVpcEndpointServiceConfigurationResult = (
  output: any,
  context: __SerdeContext
): ModifyVpcEndpointServiceConfigurationResult => {
  let contents: any = {
    __type: "ModifyVpcEndpointServiceConfigurationResult",
    Return: undefined
  };
  if (output["return"] !== undefined) {
    contents.Return = output["return"] == "true";
  }
  return contents;
};

const deserializeAws_ec2ModifyVpcEndpointServicePermissionsResult = (
  output: any,
  context: __SerdeContext
): ModifyVpcEndpointServicePermissionsResult => {
  let contents: any = {
    __type: "ModifyVpcEndpointServicePermissionsResult",
    ReturnValue: undefined
  };
  if (output["return"] !== undefined) {
    contents.ReturnValue = output["return"] == "true";
  }
  return contents;
};

const deserializeAws_ec2ModifyVpcPeeringConnectionOptionsResult = (
  output: any,
  context: __SerdeContext
): ModifyVpcPeeringConnectionOptionsResult => {
  let contents: any = {
    __type: "ModifyVpcPeeringConnectionOptionsResult",
    AccepterPeeringConnectionOptions: undefined,
    RequesterPeeringConnectionOptions: undefined
  };
  if (output["accepterPeeringConnectionOptions"] !== undefined) {
    contents.AccepterPeeringConnectionOptions = deserializeAws_ec2PeeringConnectionOptions(
      output["accepterPeeringConnectionOptions"],
      context
    );
  }
  if (output["requesterPeeringConnectionOptions"] !== undefined) {
    contents.RequesterPeeringConnectionOptions = deserializeAws_ec2PeeringConnectionOptions(
      output["requesterPeeringConnectionOptions"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2ModifyVpcTenancyResult = (
  output: any,
  context: __SerdeContext
): ModifyVpcTenancyResult => {
  let contents: any = {
    __type: "ModifyVpcTenancyResult",
    ReturnValue: undefined
  };
  if (output["return"] !== undefined) {
    contents.ReturnValue = output["return"] == "true";
  }
  return contents;
};

const deserializeAws_ec2ModifyVpnConnectionResult = (
  output: any,
  context: __SerdeContext
): ModifyVpnConnectionResult => {
  let contents: any = {
    __type: "ModifyVpnConnectionResult",
    VpnConnection: undefined
  };
  if (output["vpnConnection"] !== undefined) {
    contents.VpnConnection = deserializeAws_ec2VpnConnection(
      output["vpnConnection"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2ModifyVpnTunnelCertificateResult = (
  output: any,
  context: __SerdeContext
): ModifyVpnTunnelCertificateResult => {
  let contents: any = {
    __type: "ModifyVpnTunnelCertificateResult",
    VpnConnection: undefined
  };
  if (output["vpnConnection"] !== undefined) {
    contents.VpnConnection = deserializeAws_ec2VpnConnection(
      output["vpnConnection"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2ModifyVpnTunnelOptionsResult = (
  output: any,
  context: __SerdeContext
): ModifyVpnTunnelOptionsResult => {
  let contents: any = {
    __type: "ModifyVpnTunnelOptionsResult",
    VpnConnection: undefined
  };
  if (output["vpnConnection"] !== undefined) {
    contents.VpnConnection = deserializeAws_ec2VpnConnection(
      output["vpnConnection"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2Monitoring = (
  output: any,
  context: __SerdeContext
): Monitoring => {
  let contents: any = {
    __type: "Monitoring",
    State: undefined
  };
  if (output["state"] !== undefined) {
    contents.State = output["state"];
  }
  return contents;
};

const deserializeAws_ec2MonitorInstancesResult = (
  output: any,
  context: __SerdeContext
): MonitorInstancesResult => {
  let contents: any = {
    __type: "MonitorInstancesResult",
    InstanceMonitorings: undefined
  };
  if (output.instancesSet === "") {
    contents.InstanceMonitorings = [];
  }
  if (
    output["instancesSet"] !== undefined &&
    output["instancesSet"]["item"] !== undefined
  ) {
    contents.InstanceMonitorings = deserializeAws_ec2InstanceMonitoringList(
      __getArrayIfSingleItem(output["instancesSet"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2MoveAddressToVpcResult = (
  output: any,
  context: __SerdeContext
): MoveAddressToVpcResult => {
  let contents: any = {
    __type: "MoveAddressToVpcResult",
    AllocationId: undefined,
    Status: undefined
  };
  if (output["allocationId"] !== undefined) {
    contents.AllocationId = output["allocationId"];
  }
  if (output["status"] !== undefined) {
    contents.Status = output["status"];
  }
  return contents;
};

const deserializeAws_ec2MovingAddressStatus = (
  output: any,
  context: __SerdeContext
): MovingAddressStatus => {
  let contents: any = {
    __type: "MovingAddressStatus",
    MoveStatus: undefined,
    PublicIp: undefined
  };
  if (output["moveStatus"] !== undefined) {
    contents.MoveStatus = output["moveStatus"];
  }
  if (output["publicIp"] !== undefined) {
    contents.PublicIp = output["publicIp"];
  }
  return contents;
};

const deserializeAws_ec2MovingAddressStatusSet = (
  output: any,
  context: __SerdeContext
): MovingAddressStatus[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2MovingAddressStatus(entry, context)
  );
};

const deserializeAws_ec2NatGateway = (
  output: any,
  context: __SerdeContext
): NatGateway => {
  let contents: any = {
    __type: "NatGateway",
    CreateTime: undefined,
    DeleteTime: undefined,
    FailureCode: undefined,
    FailureMessage: undefined,
    NatGatewayAddresses: undefined,
    NatGatewayId: undefined,
    ProvisionedBandwidth: undefined,
    State: undefined,
    SubnetId: undefined,
    Tags: undefined,
    VpcId: undefined
  };
  if (output["createTime"] !== undefined) {
    contents.CreateTime = new Date(output["createTime"]);
  }
  if (output["deleteTime"] !== undefined) {
    contents.DeleteTime = new Date(output["deleteTime"]);
  }
  if (output["failureCode"] !== undefined) {
    contents.FailureCode = output["failureCode"];
  }
  if (output["failureMessage"] !== undefined) {
    contents.FailureMessage = output["failureMessage"];
  }
  if (output.natGatewayAddressSet === "") {
    contents.NatGatewayAddresses = [];
  }
  if (
    output["natGatewayAddressSet"] !== undefined &&
    output["natGatewayAddressSet"]["item"] !== undefined
  ) {
    contents.NatGatewayAddresses = deserializeAws_ec2NatGatewayAddressList(
      __getArrayIfSingleItem(output["natGatewayAddressSet"]["item"]),
      context
    );
  }
  if (output["natGatewayId"] !== undefined) {
    contents.NatGatewayId = output["natGatewayId"];
  }
  if (output["provisionedBandwidth"] !== undefined) {
    contents.ProvisionedBandwidth = deserializeAws_ec2ProvisionedBandwidth(
      output["provisionedBandwidth"],
      context
    );
  }
  if (output["state"] !== undefined) {
    contents.State = output["state"];
  }
  if (output["subnetId"] !== undefined) {
    contents.SubnetId = output["subnetId"];
  }
  if (output.tagSet === "") {
    contents.Tags = [];
  }
  if (
    output["tagSet"] !== undefined &&
    output["tagSet"]["item"] !== undefined
  ) {
    contents.Tags = deserializeAws_ec2TagList(
      __getArrayIfSingleItem(output["tagSet"]["item"]),
      context
    );
  }
  if (output["vpcId"] !== undefined) {
    contents.VpcId = output["vpcId"];
  }
  return contents;
};

const deserializeAws_ec2NatGatewayAddress = (
  output: any,
  context: __SerdeContext
): NatGatewayAddress => {
  let contents: any = {
    __type: "NatGatewayAddress",
    AllocationId: undefined,
    NetworkInterfaceId: undefined,
    PrivateIp: undefined,
    PublicIp: undefined
  };
  if (output["allocationId"] !== undefined) {
    contents.AllocationId = output["allocationId"];
  }
  if (output["networkInterfaceId"] !== undefined) {
    contents.NetworkInterfaceId = output["networkInterfaceId"];
  }
  if (output["privateIp"] !== undefined) {
    contents.PrivateIp = output["privateIp"];
  }
  if (output["publicIp"] !== undefined) {
    contents.PublicIp = output["publicIp"];
  }
  return contents;
};

const deserializeAws_ec2NatGatewayAddressList = (
  output: any,
  context: __SerdeContext
): NatGatewayAddress[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2NatGatewayAddress(entry, context)
  );
};

const deserializeAws_ec2NatGatewayList = (
  output: any,
  context: __SerdeContext
): NatGateway[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2NatGateway(entry, context)
  );
};

const deserializeAws_ec2NetworkAcl = (
  output: any,
  context: __SerdeContext
): NetworkAcl => {
  let contents: any = {
    __type: "NetworkAcl",
    Associations: undefined,
    Entries: undefined,
    IsDefault: undefined,
    NetworkAclId: undefined,
    OwnerId: undefined,
    Tags: undefined,
    VpcId: undefined
  };
  if (output.associationSet === "") {
    contents.Associations = [];
  }
  if (
    output["associationSet"] !== undefined &&
    output["associationSet"]["item"] !== undefined
  ) {
    contents.Associations = deserializeAws_ec2NetworkAclAssociationList(
      __getArrayIfSingleItem(output["associationSet"]["item"]),
      context
    );
  }
  if (output.entrySet === "") {
    contents.Entries = [];
  }
  if (
    output["entrySet"] !== undefined &&
    output["entrySet"]["item"] !== undefined
  ) {
    contents.Entries = deserializeAws_ec2NetworkAclEntryList(
      __getArrayIfSingleItem(output["entrySet"]["item"]),
      context
    );
  }
  if (output["default"] !== undefined) {
    contents.IsDefault = output["default"] == "true";
  }
  if (output["networkAclId"] !== undefined) {
    contents.NetworkAclId = output["networkAclId"];
  }
  if (output["ownerId"] !== undefined) {
    contents.OwnerId = output["ownerId"];
  }
  if (output.tagSet === "") {
    contents.Tags = [];
  }
  if (
    output["tagSet"] !== undefined &&
    output["tagSet"]["item"] !== undefined
  ) {
    contents.Tags = deserializeAws_ec2TagList(
      __getArrayIfSingleItem(output["tagSet"]["item"]),
      context
    );
  }
  if (output["vpcId"] !== undefined) {
    contents.VpcId = output["vpcId"];
  }
  return contents;
};

const deserializeAws_ec2NetworkAclAssociation = (
  output: any,
  context: __SerdeContext
): NetworkAclAssociation => {
  let contents: any = {
    __type: "NetworkAclAssociation",
    NetworkAclAssociationId: undefined,
    NetworkAclId: undefined,
    SubnetId: undefined
  };
  if (output["networkAclAssociationId"] !== undefined) {
    contents.NetworkAclAssociationId = output["networkAclAssociationId"];
  }
  if (output["networkAclId"] !== undefined) {
    contents.NetworkAclId = output["networkAclId"];
  }
  if (output["subnetId"] !== undefined) {
    contents.SubnetId = output["subnetId"];
  }
  return contents;
};

const deserializeAws_ec2NetworkAclAssociationList = (
  output: any,
  context: __SerdeContext
): NetworkAclAssociation[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2NetworkAclAssociation(entry, context)
  );
};

const deserializeAws_ec2NetworkAclEntry = (
  output: any,
  context: __SerdeContext
): NetworkAclEntry => {
  let contents: any = {
    __type: "NetworkAclEntry",
    CidrBlock: undefined,
    Egress: undefined,
    IcmpTypeCode: undefined,
    Ipv6CidrBlock: undefined,
    PortRange: undefined,
    Protocol: undefined,
    RuleAction: undefined,
    RuleNumber: undefined
  };
  if (output["cidrBlock"] !== undefined) {
    contents.CidrBlock = output["cidrBlock"];
  }
  if (output["egress"] !== undefined) {
    contents.Egress = output["egress"] == "true";
  }
  if (output["icmpTypeCode"] !== undefined) {
    contents.IcmpTypeCode = deserializeAws_ec2IcmpTypeCode(
      output["icmpTypeCode"],
      context
    );
  }
  if (output["ipv6CidrBlock"] !== undefined) {
    contents.Ipv6CidrBlock = output["ipv6CidrBlock"];
  }
  if (output["portRange"] !== undefined) {
    contents.PortRange = deserializeAws_ec2PortRange(
      output["portRange"],
      context
    );
  }
  if (output["protocol"] !== undefined) {
    contents.Protocol = output["protocol"];
  }
  if (output["ruleAction"] !== undefined) {
    contents.RuleAction = output["ruleAction"];
  }
  if (output["ruleNumber"] !== undefined) {
    contents.RuleNumber = parseInt(output["ruleNumber"]);
  }
  return contents;
};

const deserializeAws_ec2NetworkAclEntryList = (
  output: any,
  context: __SerdeContext
): NetworkAclEntry[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2NetworkAclEntry(entry, context)
  );
};

const deserializeAws_ec2NetworkAclList = (
  output: any,
  context: __SerdeContext
): NetworkAcl[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2NetworkAcl(entry, context)
  );
};

const deserializeAws_ec2NetworkInfo = (
  output: any,
  context: __SerdeContext
): NetworkInfo => {
  let contents: any = {
    __type: "NetworkInfo",
    EnaSupport: undefined,
    Ipv4AddressesPerInterface: undefined,
    Ipv6AddressesPerInterface: undefined,
    Ipv6Supported: undefined,
    MaximumNetworkInterfaces: undefined,
    NetworkPerformance: undefined
  };
  if (output["enaSupport"] !== undefined) {
    contents.EnaSupport = output["enaSupport"];
  }
  if (output["ipv4AddressesPerInterface"] !== undefined) {
    contents.Ipv4AddressesPerInterface = parseInt(
      output["ipv4AddressesPerInterface"]
    );
  }
  if (output["ipv6AddressesPerInterface"] !== undefined) {
    contents.Ipv6AddressesPerInterface = parseInt(
      output["ipv6AddressesPerInterface"]
    );
  }
  if (output["ipv6Supported"] !== undefined) {
    contents.Ipv6Supported = output["ipv6Supported"] == "true";
  }
  if (output["maximumNetworkInterfaces"] !== undefined) {
    contents.MaximumNetworkInterfaces = parseInt(
      output["maximumNetworkInterfaces"]
    );
  }
  if (output["networkPerformance"] !== undefined) {
    contents.NetworkPerformance = output["networkPerformance"];
  }
  return contents;
};

const deserializeAws_ec2NetworkInterface = (
  output: any,
  context: __SerdeContext
): NetworkInterface => {
  let contents: any = {
    __type: "NetworkInterface",
    Association: undefined,
    Attachment: undefined,
    AvailabilityZone: undefined,
    Description: undefined,
    Groups: undefined,
    InterfaceType: undefined,
    Ipv6Addresses: undefined,
    MacAddress: undefined,
    NetworkInterfaceId: undefined,
    OutpostArn: undefined,
    OwnerId: undefined,
    PrivateDnsName: undefined,
    PrivateIpAddress: undefined,
    PrivateIpAddresses: undefined,
    RequesterId: undefined,
    RequesterManaged: undefined,
    SourceDestCheck: undefined,
    Status: undefined,
    SubnetId: undefined,
    TagSet: undefined,
    VpcId: undefined
  };
  if (output["association"] !== undefined) {
    contents.Association = deserializeAws_ec2NetworkInterfaceAssociation(
      output["association"],
      context
    );
  }
  if (output["attachment"] !== undefined) {
    contents.Attachment = deserializeAws_ec2NetworkInterfaceAttachment(
      output["attachment"],
      context
    );
  }
  if (output["availabilityZone"] !== undefined) {
    contents.AvailabilityZone = output["availabilityZone"];
  }
  if (output["description"] !== undefined) {
    contents.Description = output["description"];
  }
  if (output.groupSet === "") {
    contents.Groups = [];
  }
  if (
    output["groupSet"] !== undefined &&
    output["groupSet"]["item"] !== undefined
  ) {
    contents.Groups = deserializeAws_ec2GroupIdentifierList(
      __getArrayIfSingleItem(output["groupSet"]["item"]),
      context
    );
  }
  if (output["interfaceType"] !== undefined) {
    contents.InterfaceType = output["interfaceType"];
  }
  if (output.ipv6AddressesSet === "") {
    contents.Ipv6Addresses = [];
  }
  if (
    output["ipv6AddressesSet"] !== undefined &&
    output["ipv6AddressesSet"]["item"] !== undefined
  ) {
    contents.Ipv6Addresses = deserializeAws_ec2NetworkInterfaceIpv6AddressesList(
      __getArrayIfSingleItem(output["ipv6AddressesSet"]["item"]),
      context
    );
  }
  if (output["macAddress"] !== undefined) {
    contents.MacAddress = output["macAddress"];
  }
  if (output["networkInterfaceId"] !== undefined) {
    contents.NetworkInterfaceId = output["networkInterfaceId"];
  }
  if (output["outpostArn"] !== undefined) {
    contents.OutpostArn = output["outpostArn"];
  }
  if (output["ownerId"] !== undefined) {
    contents.OwnerId = output["ownerId"];
  }
  if (output["privateDnsName"] !== undefined) {
    contents.PrivateDnsName = output["privateDnsName"];
  }
  if (output["privateIpAddress"] !== undefined) {
    contents.PrivateIpAddress = output["privateIpAddress"];
  }
  if (output.privateIpAddressesSet === "") {
    contents.PrivateIpAddresses = [];
  }
  if (
    output["privateIpAddressesSet"] !== undefined &&
    output["privateIpAddressesSet"]["item"] !== undefined
  ) {
    contents.PrivateIpAddresses = deserializeAws_ec2NetworkInterfacePrivateIpAddressList(
      __getArrayIfSingleItem(output["privateIpAddressesSet"]["item"]),
      context
    );
  }
  if (output["requesterId"] !== undefined) {
    contents.RequesterId = output["requesterId"];
  }
  if (output["requesterManaged"] !== undefined) {
    contents.RequesterManaged = output["requesterManaged"] == "true";
  }
  if (output["sourceDestCheck"] !== undefined) {
    contents.SourceDestCheck = output["sourceDestCheck"] == "true";
  }
  if (output["status"] !== undefined) {
    contents.Status = output["status"];
  }
  if (output["subnetId"] !== undefined) {
    contents.SubnetId = output["subnetId"];
  }
  if (output.tagSet === "") {
    contents.TagSet = [];
  }
  if (
    output["tagSet"] !== undefined &&
    output["tagSet"]["item"] !== undefined
  ) {
    contents.TagSet = deserializeAws_ec2TagList(
      __getArrayIfSingleItem(output["tagSet"]["item"]),
      context
    );
  }
  if (output["vpcId"] !== undefined) {
    contents.VpcId = output["vpcId"];
  }
  return contents;
};

const deserializeAws_ec2NetworkInterfaceAssociation = (
  output: any,
  context: __SerdeContext
): NetworkInterfaceAssociation => {
  let contents: any = {
    __type: "NetworkInterfaceAssociation",
    AllocationId: undefined,
    AssociationId: undefined,
    IpOwnerId: undefined,
    PublicDnsName: undefined,
    PublicIp: undefined
  };
  if (output["allocationId"] !== undefined) {
    contents.AllocationId = output["allocationId"];
  }
  if (output["associationId"] !== undefined) {
    contents.AssociationId = output["associationId"];
  }
  if (output["ipOwnerId"] !== undefined) {
    contents.IpOwnerId = output["ipOwnerId"];
  }
  if (output["publicDnsName"] !== undefined) {
    contents.PublicDnsName = output["publicDnsName"];
  }
  if (output["publicIp"] !== undefined) {
    contents.PublicIp = output["publicIp"];
  }
  return contents;
};

const deserializeAws_ec2NetworkInterfaceAttachment = (
  output: any,
  context: __SerdeContext
): NetworkInterfaceAttachment => {
  let contents: any = {
    __type: "NetworkInterfaceAttachment",
    AttachTime: undefined,
    AttachmentId: undefined,
    DeleteOnTermination: undefined,
    DeviceIndex: undefined,
    InstanceId: undefined,
    InstanceOwnerId: undefined,
    Status: undefined
  };
  if (output["attachTime"] !== undefined) {
    contents.AttachTime = new Date(output["attachTime"]);
  }
  if (output["attachmentId"] !== undefined) {
    contents.AttachmentId = output["attachmentId"];
  }
  if (output["deleteOnTermination"] !== undefined) {
    contents.DeleteOnTermination = output["deleteOnTermination"] == "true";
  }
  if (output["deviceIndex"] !== undefined) {
    contents.DeviceIndex = parseInt(output["deviceIndex"]);
  }
  if (output["instanceId"] !== undefined) {
    contents.InstanceId = output["instanceId"];
  }
  if (output["instanceOwnerId"] !== undefined) {
    contents.InstanceOwnerId = output["instanceOwnerId"];
  }
  if (output["status"] !== undefined) {
    contents.Status = output["status"];
  }
  return contents;
};

const deserializeAws_ec2NetworkInterfaceIpv6Address = (
  output: any,
  context: __SerdeContext
): NetworkInterfaceIpv6Address => {
  let contents: any = {
    __type: "NetworkInterfaceIpv6Address",
    Ipv6Address: undefined
  };
  if (output["ipv6Address"] !== undefined) {
    contents.Ipv6Address = output["ipv6Address"];
  }
  return contents;
};

const deserializeAws_ec2NetworkInterfaceIpv6AddressesList = (
  output: any,
  context: __SerdeContext
): NetworkInterfaceIpv6Address[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2NetworkInterfaceIpv6Address(entry, context)
  );
};

const deserializeAws_ec2NetworkInterfaceList = (
  output: any,
  context: __SerdeContext
): NetworkInterface[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2NetworkInterface(entry, context)
  );
};

const deserializeAws_ec2NetworkInterfacePermission = (
  output: any,
  context: __SerdeContext
): NetworkInterfacePermission => {
  let contents: any = {
    __type: "NetworkInterfacePermission",
    AwsAccountId: undefined,
    AwsService: undefined,
    NetworkInterfaceId: undefined,
    NetworkInterfacePermissionId: undefined,
    Permission: undefined,
    PermissionState: undefined
  };
  if (output["awsAccountId"] !== undefined) {
    contents.AwsAccountId = output["awsAccountId"];
  }
  if (output["awsService"] !== undefined) {
    contents.AwsService = output["awsService"];
  }
  if (output["networkInterfaceId"] !== undefined) {
    contents.NetworkInterfaceId = output["networkInterfaceId"];
  }
  if (output["networkInterfacePermissionId"] !== undefined) {
    contents.NetworkInterfacePermissionId =
      output["networkInterfacePermissionId"];
  }
  if (output["permission"] !== undefined) {
    contents.Permission = output["permission"];
  }
  if (output["permissionState"] !== undefined) {
    contents.PermissionState = deserializeAws_ec2NetworkInterfacePermissionState(
      output["permissionState"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2NetworkInterfacePermissionList = (
  output: any,
  context: __SerdeContext
): NetworkInterfacePermission[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2NetworkInterfacePermission(entry, context)
  );
};

const deserializeAws_ec2NetworkInterfacePermissionState = (
  output: any,
  context: __SerdeContext
): NetworkInterfacePermissionState => {
  let contents: any = {
    __type: "NetworkInterfacePermissionState",
    State: undefined,
    StatusMessage: undefined
  };
  if (output["state"] !== undefined) {
    contents.State = output["state"];
  }
  if (output["statusMessage"] !== undefined) {
    contents.StatusMessage = output["statusMessage"];
  }
  return contents;
};

const deserializeAws_ec2NetworkInterfacePrivateIpAddress = (
  output: any,
  context: __SerdeContext
): NetworkInterfacePrivateIpAddress => {
  let contents: any = {
    __type: "NetworkInterfacePrivateIpAddress",
    Association: undefined,
    Primary: undefined,
    PrivateDnsName: undefined,
    PrivateIpAddress: undefined
  };
  if (output["association"] !== undefined) {
    contents.Association = deserializeAws_ec2NetworkInterfaceAssociation(
      output["association"],
      context
    );
  }
  if (output["primary"] !== undefined) {
    contents.Primary = output["primary"] == "true";
  }
  if (output["privateDnsName"] !== undefined) {
    contents.PrivateDnsName = output["privateDnsName"];
  }
  if (output["privateIpAddress"] !== undefined) {
    contents.PrivateIpAddress = output["privateIpAddress"];
  }
  return contents;
};

const deserializeAws_ec2NetworkInterfacePrivateIpAddressList = (
  output: any,
  context: __SerdeContext
): NetworkInterfacePrivateIpAddress[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2NetworkInterfacePrivateIpAddress(entry, context)
  );
};

const deserializeAws_ec2OccurrenceDaySet = (
  output: any,
  context: __SerdeContext
): number[] => {
  return (output || []).map((entry: any) => parseInt(entry));
};

const deserializeAws_ec2OnDemandOptions = (
  output: any,
  context: __SerdeContext
): OnDemandOptions => {
  let contents: any = {
    __type: "OnDemandOptions",
    AllocationStrategy: undefined,
    CapacityReservationOptions: undefined,
    MaxTotalPrice: undefined,
    MinTargetCapacity: undefined,
    SingleAvailabilityZone: undefined,
    SingleInstanceType: undefined
  };
  if (output["allocationStrategy"] !== undefined) {
    contents.AllocationStrategy = output["allocationStrategy"];
  }
  if (output["capacityReservationOptions"] !== undefined) {
    contents.CapacityReservationOptions = deserializeAws_ec2CapacityReservationOptions(
      output["capacityReservationOptions"],
      context
    );
  }
  if (output["maxTotalPrice"] !== undefined) {
    contents.MaxTotalPrice = output["maxTotalPrice"];
  }
  if (output["minTargetCapacity"] !== undefined) {
    contents.MinTargetCapacity = parseInt(output["minTargetCapacity"]);
  }
  if (output["singleAvailabilityZone"] !== undefined) {
    contents.SingleAvailabilityZone =
      output["singleAvailabilityZone"] == "true";
  }
  if (output["singleInstanceType"] !== undefined) {
    contents.SingleInstanceType = output["singleInstanceType"] == "true";
  }
  return contents;
};

const deserializeAws_ec2PciId = (
  output: any,
  context: __SerdeContext
): PciId => {
  let contents: any = {
    __type: "PciId",
    DeviceId: undefined,
    SubsystemId: undefined,
    SubsystemVendorId: undefined,
    VendorId: undefined
  };
  if (output["DeviceId"] !== undefined) {
    contents.DeviceId = output["DeviceId"];
  }
  if (output["SubsystemId"] !== undefined) {
    contents.SubsystemId = output["SubsystemId"];
  }
  if (output["SubsystemVendorId"] !== undefined) {
    contents.SubsystemVendorId = output["SubsystemVendorId"];
  }
  if (output["VendorId"] !== undefined) {
    contents.VendorId = output["VendorId"];
  }
  return contents;
};

const deserializeAws_ec2PeeringAttachmentStatus = (
  output: any,
  context: __SerdeContext
): PeeringAttachmentStatus => {
  let contents: any = {
    __type: "PeeringAttachmentStatus",
    Code: undefined,
    Message: undefined
  };
  if (output["code"] !== undefined) {
    contents.Code = output["code"];
  }
  if (output["message"] !== undefined) {
    contents.Message = output["message"];
  }
  return contents;
};

const deserializeAws_ec2PeeringConnectionOptions = (
  output: any,
  context: __SerdeContext
): PeeringConnectionOptions => {
  let contents: any = {
    __type: "PeeringConnectionOptions",
    AllowDnsResolutionFromRemoteVpc: undefined,
    AllowEgressFromLocalClassicLinkToRemoteVpc: undefined,
    AllowEgressFromLocalVpcToRemoteClassicLink: undefined
  };
  if (output["allowDnsResolutionFromRemoteVpc"] !== undefined) {
    contents.AllowDnsResolutionFromRemoteVpc =
      output["allowDnsResolutionFromRemoteVpc"] == "true";
  }
  if (output["allowEgressFromLocalClassicLinkToRemoteVpc"] !== undefined) {
    contents.AllowEgressFromLocalClassicLinkToRemoteVpc =
      output["allowEgressFromLocalClassicLinkToRemoteVpc"] == "true";
  }
  if (output["allowEgressFromLocalVpcToRemoteClassicLink"] !== undefined) {
    contents.AllowEgressFromLocalVpcToRemoteClassicLink =
      output["allowEgressFromLocalVpcToRemoteClassicLink"] == "true";
  }
  return contents;
};

const deserializeAws_ec2PeeringTgwInfo = (
  output: any,
  context: __SerdeContext
): PeeringTgwInfo => {
  let contents: any = {
    __type: "PeeringTgwInfo",
    OwnerId: undefined,
    Region: undefined,
    TransitGatewayId: undefined
  };
  if (output["ownerId"] !== undefined) {
    contents.OwnerId = output["ownerId"];
  }
  if (output["region"] !== undefined) {
    contents.Region = output["region"];
  }
  if (output["transitGatewayId"] !== undefined) {
    contents.TransitGatewayId = output["transitGatewayId"];
  }
  return contents;
};

const deserializeAws_ec2Phase1DHGroupNumbersList = (
  output: any,
  context: __SerdeContext
): Phase1DHGroupNumbersListValue[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2Phase1DHGroupNumbersListValue(entry, context)
  );
};

const deserializeAws_ec2Phase1DHGroupNumbersListValue = (
  output: any,
  context: __SerdeContext
): Phase1DHGroupNumbersListValue => {
  let contents: any = {
    __type: "Phase1DHGroupNumbersListValue",
    Value: undefined
  };
  if (output["value"] !== undefined) {
    contents.Value = parseInt(output["value"]);
  }
  return contents;
};

const deserializeAws_ec2Phase1EncryptionAlgorithmsList = (
  output: any,
  context: __SerdeContext
): Phase1EncryptionAlgorithmsListValue[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2Phase1EncryptionAlgorithmsListValue(entry, context)
  );
};

const deserializeAws_ec2Phase1EncryptionAlgorithmsListValue = (
  output: any,
  context: __SerdeContext
): Phase1EncryptionAlgorithmsListValue => {
  let contents: any = {
    __type: "Phase1EncryptionAlgorithmsListValue",
    Value: undefined
  };
  if (output["value"] !== undefined) {
    contents.Value = output["value"];
  }
  return contents;
};

const deserializeAws_ec2Phase1IntegrityAlgorithmsList = (
  output: any,
  context: __SerdeContext
): Phase1IntegrityAlgorithmsListValue[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2Phase1IntegrityAlgorithmsListValue(entry, context)
  );
};

const deserializeAws_ec2Phase1IntegrityAlgorithmsListValue = (
  output: any,
  context: __SerdeContext
): Phase1IntegrityAlgorithmsListValue => {
  let contents: any = {
    __type: "Phase1IntegrityAlgorithmsListValue",
    Value: undefined
  };
  if (output["value"] !== undefined) {
    contents.Value = output["value"];
  }
  return contents;
};

const deserializeAws_ec2Phase2DHGroupNumbersList = (
  output: any,
  context: __SerdeContext
): Phase2DHGroupNumbersListValue[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2Phase2DHGroupNumbersListValue(entry, context)
  );
};

const deserializeAws_ec2Phase2DHGroupNumbersListValue = (
  output: any,
  context: __SerdeContext
): Phase2DHGroupNumbersListValue => {
  let contents: any = {
    __type: "Phase2DHGroupNumbersListValue",
    Value: undefined
  };
  if (output["value"] !== undefined) {
    contents.Value = parseInt(output["value"]);
  }
  return contents;
};

const deserializeAws_ec2Phase2EncryptionAlgorithmsList = (
  output: any,
  context: __SerdeContext
): Phase2EncryptionAlgorithmsListValue[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2Phase2EncryptionAlgorithmsListValue(entry, context)
  );
};

const deserializeAws_ec2Phase2EncryptionAlgorithmsListValue = (
  output: any,
  context: __SerdeContext
): Phase2EncryptionAlgorithmsListValue => {
  let contents: any = {
    __type: "Phase2EncryptionAlgorithmsListValue",
    Value: undefined
  };
  if (output["value"] !== undefined) {
    contents.Value = output["value"];
  }
  return contents;
};

const deserializeAws_ec2Phase2IntegrityAlgorithmsList = (
  output: any,
  context: __SerdeContext
): Phase2IntegrityAlgorithmsListValue[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2Phase2IntegrityAlgorithmsListValue(entry, context)
  );
};

const deserializeAws_ec2Phase2IntegrityAlgorithmsListValue = (
  output: any,
  context: __SerdeContext
): Phase2IntegrityAlgorithmsListValue => {
  let contents: any = {
    __type: "Phase2IntegrityAlgorithmsListValue",
    Value: undefined
  };
  if (output["value"] !== undefined) {
    contents.Value = output["value"];
  }
  return contents;
};

const deserializeAws_ec2Placement = (
  output: any,
  context: __SerdeContext
): Placement => {
  let contents: any = {
    __type: "Placement",
    Affinity: undefined,
    AvailabilityZone: undefined,
    GroupName: undefined,
    HostId: undefined,
    HostResourceGroupArn: undefined,
    PartitionNumber: undefined,
    SpreadDomain: undefined,
    Tenancy: undefined
  };
  if (output["affinity"] !== undefined) {
    contents.Affinity = output["affinity"];
  }
  if (output["availabilityZone"] !== undefined) {
    contents.AvailabilityZone = output["availabilityZone"];
  }
  if (output["groupName"] !== undefined) {
    contents.GroupName = output["groupName"];
  }
  if (output["hostId"] !== undefined) {
    contents.HostId = output["hostId"];
  }
  if (output["hostResourceGroupArn"] !== undefined) {
    contents.HostResourceGroupArn = output["hostResourceGroupArn"];
  }
  if (output["partitionNumber"] !== undefined) {
    contents.PartitionNumber = parseInt(output["partitionNumber"]);
  }
  if (output["spreadDomain"] !== undefined) {
    contents.SpreadDomain = output["spreadDomain"];
  }
  if (output["tenancy"] !== undefined) {
    contents.Tenancy = output["tenancy"];
  }
  return contents;
};

const deserializeAws_ec2PlacementGroup = (
  output: any,
  context: __SerdeContext
): PlacementGroup => {
  let contents: any = {
    __type: "PlacementGroup",
    GroupId: undefined,
    GroupName: undefined,
    PartitionCount: undefined,
    State: undefined,
    Strategy: undefined,
    Tags: undefined
  };
  if (output["groupId"] !== undefined) {
    contents.GroupId = output["groupId"];
  }
  if (output["groupName"] !== undefined) {
    contents.GroupName = output["groupName"];
  }
  if (output["partitionCount"] !== undefined) {
    contents.PartitionCount = parseInt(output["partitionCount"]);
  }
  if (output["state"] !== undefined) {
    contents.State = output["state"];
  }
  if (output["strategy"] !== undefined) {
    contents.Strategy = output["strategy"];
  }
  if (output.tagSet === "") {
    contents.Tags = [];
  }
  if (
    output["tagSet"] !== undefined &&
    output["tagSet"]["item"] !== undefined
  ) {
    contents.Tags = deserializeAws_ec2TagList(
      __getArrayIfSingleItem(output["tagSet"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2PlacementGroupInfo = (
  output: any,
  context: __SerdeContext
): PlacementGroupInfo => {
  let contents: any = {
    __type: "PlacementGroupInfo",
    SupportedStrategies: undefined
  };
  if (output.supportedStrategies === "") {
    contents.SupportedStrategies = [];
  }
  if (
    output["supportedStrategies"] !== undefined &&
    output["supportedStrategies"]["item"] !== undefined
  ) {
    contents.SupportedStrategies = deserializeAws_ec2PlacementGroupStrategyList(
      __getArrayIfSingleItem(output["supportedStrategies"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2PlacementGroupList = (
  output: any,
  context: __SerdeContext
): PlacementGroup[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2PlacementGroup(entry, context)
  );
};

const deserializeAws_ec2PlacementGroupStrategyList = (
  output: any,
  context: __SerdeContext
): (PlacementGroupStrategy | string)[] => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_ec2PlacementResponse = (
  output: any,
  context: __SerdeContext
): PlacementResponse => {
  let contents: any = {
    __type: "PlacementResponse",
    GroupName: undefined
  };
  if (output["groupName"] !== undefined) {
    contents.GroupName = output["groupName"];
  }
  return contents;
};

const deserializeAws_ec2PoolCidrBlock = (
  output: any,
  context: __SerdeContext
): PoolCidrBlock => {
  let contents: any = {
    __type: "PoolCidrBlock",
    Cidr: undefined
  };
  if (output["poolCidrBlock"] !== undefined) {
    contents.Cidr = output["poolCidrBlock"];
  }
  return contents;
};

const deserializeAws_ec2PoolCidrBlocksSet = (
  output: any,
  context: __SerdeContext
): PoolCidrBlock[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2PoolCidrBlock(entry, context)
  );
};

const deserializeAws_ec2PortRange = (
  output: any,
  context: __SerdeContext
): PortRange => {
  let contents: any = {
    __type: "PortRange",
    From: undefined,
    To: undefined
  };
  if (output["from"] !== undefined) {
    contents.From = parseInt(output["from"]);
  }
  if (output["to"] !== undefined) {
    contents.To = parseInt(output["to"]);
  }
  return contents;
};

const deserializeAws_ec2PrefixList = (
  output: any,
  context: __SerdeContext
): PrefixList => {
  let contents: any = {
    __type: "PrefixList",
    Cidrs: undefined,
    PrefixListId: undefined,
    PrefixListName: undefined
  };
  if (output.cidrSet === "") {
    contents.Cidrs = [];
  }
  if (
    output["cidrSet"] !== undefined &&
    output["cidrSet"]["item"] !== undefined
  ) {
    contents.Cidrs = deserializeAws_ec2ValueStringList(
      __getArrayIfSingleItem(output["cidrSet"]["item"]),
      context
    );
  }
  if (output["prefixListId"] !== undefined) {
    contents.PrefixListId = output["prefixListId"];
  }
  if (output["prefixListName"] !== undefined) {
    contents.PrefixListName = output["prefixListName"];
  }
  return contents;
};

const deserializeAws_ec2PrefixListId = (
  output: any,
  context: __SerdeContext
): PrefixListId => {
  let contents: any = {
    __type: "PrefixListId",
    Description: undefined,
    PrefixListId: undefined
  };
  if (output["description"] !== undefined) {
    contents.Description = output["description"];
  }
  if (output["prefixListId"] !== undefined) {
    contents.PrefixListId = output["prefixListId"];
  }
  return contents;
};

const deserializeAws_ec2PrefixListIdList = (
  output: any,
  context: __SerdeContext
): PrefixListId[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2PrefixListId(entry, context)
  );
};

const deserializeAws_ec2PrefixListIdSet = (
  output: any,
  context: __SerdeContext
): string[] => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_ec2PrefixListSet = (
  output: any,
  context: __SerdeContext
): PrefixList[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2PrefixList(entry, context)
  );
};

const deserializeAws_ec2PriceSchedule = (
  output: any,
  context: __SerdeContext
): PriceSchedule => {
  let contents: any = {
    __type: "PriceSchedule",
    Active: undefined,
    CurrencyCode: undefined,
    Price: undefined,
    Term: undefined
  };
  if (output["active"] !== undefined) {
    contents.Active = output["active"] == "true";
  }
  if (output["currencyCode"] !== undefined) {
    contents.CurrencyCode = output["currencyCode"];
  }
  if (output["price"] !== undefined) {
    contents.Price = parseFloat(output["price"]);
  }
  if (output["term"] !== undefined) {
    contents.Term = parseInt(output["term"]);
  }
  return contents;
};

const deserializeAws_ec2PriceScheduleList = (
  output: any,
  context: __SerdeContext
): PriceSchedule[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2PriceSchedule(entry, context)
  );
};

const deserializeAws_ec2PricingDetail = (
  output: any,
  context: __SerdeContext
): PricingDetail => {
  let contents: any = {
    __type: "PricingDetail",
    Count: undefined,
    Price: undefined
  };
  if (output["count"] !== undefined) {
    contents.Count = parseInt(output["count"]);
  }
  if (output["price"] !== undefined) {
    contents.Price = parseFloat(output["price"]);
  }
  return contents;
};

const deserializeAws_ec2PricingDetailsList = (
  output: any,
  context: __SerdeContext
): PricingDetail[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2PricingDetail(entry, context)
  );
};

const deserializeAws_ec2PrincipalIdFormat = (
  output: any,
  context: __SerdeContext
): PrincipalIdFormat => {
  let contents: any = {
    __type: "PrincipalIdFormat",
    Arn: undefined,
    Statuses: undefined
  };
  if (output["arn"] !== undefined) {
    contents.Arn = output["arn"];
  }
  if (output.statusSet === "") {
    contents.Statuses = [];
  }
  if (
    output["statusSet"] !== undefined &&
    output["statusSet"]["item"] !== undefined
  ) {
    contents.Statuses = deserializeAws_ec2IdFormatList(
      __getArrayIfSingleItem(output["statusSet"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2PrincipalIdFormatList = (
  output: any,
  context: __SerdeContext
): PrincipalIdFormat[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2PrincipalIdFormat(entry, context)
  );
};

const deserializeAws_ec2PrivateDnsNameConfiguration = (
  output: any,
  context: __SerdeContext
): PrivateDnsNameConfiguration => {
  let contents: any = {
    __type: "PrivateDnsNameConfiguration",
    Name: undefined,
    State: undefined,
    Type: undefined,
    Value: undefined
  };
  if (output["name"] !== undefined) {
    contents.Name = output["name"];
  }
  if (output["state"] !== undefined) {
    contents.State = output["state"];
  }
  if (output["type"] !== undefined) {
    contents.Type = output["type"];
  }
  if (output["value"] !== undefined) {
    contents.Value = output["value"];
  }
  return contents;
};

const deserializeAws_ec2PrivateIpAddressSpecification = (
  output: any,
  context: __SerdeContext
): PrivateIpAddressSpecification => {
  let contents: any = {
    __type: "PrivateIpAddressSpecification",
    Primary: undefined,
    PrivateIpAddress: undefined
  };
  if (output["primary"] !== undefined) {
    contents.Primary = output["primary"] == "true";
  }
  if (output["privateIpAddress"] !== undefined) {
    contents.PrivateIpAddress = output["privateIpAddress"];
  }
  return contents;
};

const deserializeAws_ec2PrivateIpAddressSpecificationList = (
  output: any,
  context: __SerdeContext
): PrivateIpAddressSpecification[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2PrivateIpAddressSpecification(entry, context)
  );
};

const deserializeAws_ec2ProcessorInfo = (
  output: any,
  context: __SerdeContext
): ProcessorInfo => {
  let contents: any = {
    __type: "ProcessorInfo",
    SupportedArchitectures: undefined,
    SustainedClockSpeedInGhz: undefined
  };
  if (output.supportedArchitectures === "") {
    contents.SupportedArchitectures = [];
  }
  if (
    output["supportedArchitectures"] !== undefined &&
    output["supportedArchitectures"]["item"] !== undefined
  ) {
    contents.SupportedArchitectures = deserializeAws_ec2ArchitectureTypeList(
      __getArrayIfSingleItem(output["supportedArchitectures"]["item"]),
      context
    );
  }
  if (output["sustainedClockSpeedInGhz"] !== undefined) {
    contents.SustainedClockSpeedInGhz = parseFloat(
      output["sustainedClockSpeedInGhz"]
    );
  }
  return contents;
};

const deserializeAws_ec2ProductCode = (
  output: any,
  context: __SerdeContext
): ProductCode => {
  let contents: any = {
    __type: "ProductCode",
    ProductCodeId: undefined,
    ProductCodeType: undefined
  };
  if (output["productCode"] !== undefined) {
    contents.ProductCodeId = output["productCode"];
  }
  if (output["type"] !== undefined) {
    contents.ProductCodeType = output["type"];
  }
  return contents;
};

const deserializeAws_ec2ProductCodeList = (
  output: any,
  context: __SerdeContext
): ProductCode[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2ProductCode(entry, context)
  );
};

const deserializeAws_ec2PropagatingVgw = (
  output: any,
  context: __SerdeContext
): PropagatingVgw => {
  let contents: any = {
    __type: "PropagatingVgw",
    GatewayId: undefined
  };
  if (output["gatewayId"] !== undefined) {
    contents.GatewayId = output["gatewayId"];
  }
  return contents;
};

const deserializeAws_ec2PropagatingVgwList = (
  output: any,
  context: __SerdeContext
): PropagatingVgw[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2PropagatingVgw(entry, context)
  );
};

const deserializeAws_ec2ProvisionByoipCidrResult = (
  output: any,
  context: __SerdeContext
): ProvisionByoipCidrResult => {
  let contents: any = {
    __type: "ProvisionByoipCidrResult",
    ByoipCidr: undefined
  };
  if (output["byoipCidr"] !== undefined) {
    contents.ByoipCidr = deserializeAws_ec2ByoipCidr(
      output["byoipCidr"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2ProvisionedBandwidth = (
  output: any,
  context: __SerdeContext
): ProvisionedBandwidth => {
  let contents: any = {
    __type: "ProvisionedBandwidth",
    ProvisionTime: undefined,
    Provisioned: undefined,
    RequestTime: undefined,
    Requested: undefined,
    Status: undefined
  };
  if (output["provisionTime"] !== undefined) {
    contents.ProvisionTime = new Date(output["provisionTime"]);
  }
  if (output["provisioned"] !== undefined) {
    contents.Provisioned = output["provisioned"];
  }
  if (output["requestTime"] !== undefined) {
    contents.RequestTime = new Date(output["requestTime"]);
  }
  if (output["requested"] !== undefined) {
    contents.Requested = output["requested"];
  }
  if (output["status"] !== undefined) {
    contents.Status = output["status"];
  }
  return contents;
};

const deserializeAws_ec2PublicIpv4Pool = (
  output: any,
  context: __SerdeContext
): PublicIpv4Pool => {
  let contents: any = {
    __type: "PublicIpv4Pool",
    Description: undefined,
    PoolAddressRanges: undefined,
    PoolId: undefined,
    TotalAddressCount: undefined,
    TotalAvailableAddressCount: undefined
  };
  if (output["description"] !== undefined) {
    contents.Description = output["description"];
  }
  if (output.poolAddressRangeSet === "") {
    contents.PoolAddressRanges = [];
  }
  if (
    output["poolAddressRangeSet"] !== undefined &&
    output["poolAddressRangeSet"]["item"] !== undefined
  ) {
    contents.PoolAddressRanges = deserializeAws_ec2PublicIpv4PoolRangeSet(
      __getArrayIfSingleItem(output["poolAddressRangeSet"]["item"]),
      context
    );
  }
  if (output["poolId"] !== undefined) {
    contents.PoolId = output["poolId"];
  }
  if (output["totalAddressCount"] !== undefined) {
    contents.TotalAddressCount = parseInt(output["totalAddressCount"]);
  }
  if (output["totalAvailableAddressCount"] !== undefined) {
    contents.TotalAvailableAddressCount = parseInt(
      output["totalAvailableAddressCount"]
    );
  }
  return contents;
};

const deserializeAws_ec2PublicIpv4PoolRange = (
  output: any,
  context: __SerdeContext
): PublicIpv4PoolRange => {
  let contents: any = {
    __type: "PublicIpv4PoolRange",
    AddressCount: undefined,
    AvailableAddressCount: undefined,
    FirstAddress: undefined,
    LastAddress: undefined
  };
  if (output["addressCount"] !== undefined) {
    contents.AddressCount = parseInt(output["addressCount"]);
  }
  if (output["availableAddressCount"] !== undefined) {
    contents.AvailableAddressCount = parseInt(output["availableAddressCount"]);
  }
  if (output["firstAddress"] !== undefined) {
    contents.FirstAddress = output["firstAddress"];
  }
  if (output["lastAddress"] !== undefined) {
    contents.LastAddress = output["lastAddress"];
  }
  return contents;
};

const deserializeAws_ec2PublicIpv4PoolRangeSet = (
  output: any,
  context: __SerdeContext
): PublicIpv4PoolRange[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2PublicIpv4PoolRange(entry, context)
  );
};

const deserializeAws_ec2PublicIpv4PoolSet = (
  output: any,
  context: __SerdeContext
): PublicIpv4Pool[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2PublicIpv4Pool(entry, context)
  );
};

const deserializeAws_ec2Purchase = (
  output: any,
  context: __SerdeContext
): Purchase => {
  let contents: any = {
    __type: "Purchase",
    CurrencyCode: undefined,
    Duration: undefined,
    HostIdSet: undefined,
    HostReservationId: undefined,
    HourlyPrice: undefined,
    InstanceFamily: undefined,
    PaymentOption: undefined,
    UpfrontPrice: undefined
  };
  if (output["currencyCode"] !== undefined) {
    contents.CurrencyCode = output["currencyCode"];
  }
  if (output["duration"] !== undefined) {
    contents.Duration = parseInt(output["duration"]);
  }
  if (output.hostIdSet === "") {
    contents.HostIdSet = [];
  }
  if (
    output["hostIdSet"] !== undefined &&
    output["hostIdSet"]["item"] !== undefined
  ) {
    contents.HostIdSet = deserializeAws_ec2ResponseHostIdSet(
      __getArrayIfSingleItem(output["hostIdSet"]["item"]),
      context
    );
  }
  if (output["hostReservationId"] !== undefined) {
    contents.HostReservationId = output["hostReservationId"];
  }
  if (output["hourlyPrice"] !== undefined) {
    contents.HourlyPrice = output["hourlyPrice"];
  }
  if (output["instanceFamily"] !== undefined) {
    contents.InstanceFamily = output["instanceFamily"];
  }
  if (output["paymentOption"] !== undefined) {
    contents.PaymentOption = output["paymentOption"];
  }
  if (output["upfrontPrice"] !== undefined) {
    contents.UpfrontPrice = output["upfrontPrice"];
  }
  return contents;
};

const deserializeAws_ec2PurchasedScheduledInstanceSet = (
  output: any,
  context: __SerdeContext
): ScheduledInstance[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2ScheduledInstance(entry, context)
  );
};

const deserializeAws_ec2PurchaseHostReservationResult = (
  output: any,
  context: __SerdeContext
): PurchaseHostReservationResult => {
  let contents: any = {
    __type: "PurchaseHostReservationResult",
    ClientToken: undefined,
    CurrencyCode: undefined,
    Purchase: undefined,
    TotalHourlyPrice: undefined,
    TotalUpfrontPrice: undefined
  };
  if (output["clientToken"] !== undefined) {
    contents.ClientToken = output["clientToken"];
  }
  if (output["currencyCode"] !== undefined) {
    contents.CurrencyCode = output["currencyCode"];
  }
  if (output.purchase === "") {
    contents.Purchase = [];
  }
  if (
    output["purchase"] !== undefined &&
    output["purchase"]["item"] !== undefined
  ) {
    contents.Purchase = deserializeAws_ec2PurchaseSet(
      __getArrayIfSingleItem(output["purchase"]["item"]),
      context
    );
  }
  if (output["totalHourlyPrice"] !== undefined) {
    contents.TotalHourlyPrice = output["totalHourlyPrice"];
  }
  if (output["totalUpfrontPrice"] !== undefined) {
    contents.TotalUpfrontPrice = output["totalUpfrontPrice"];
  }
  return contents;
};

const deserializeAws_ec2PurchaseReservedInstancesOfferingResult = (
  output: any,
  context: __SerdeContext
): PurchaseReservedInstancesOfferingResult => {
  let contents: any = {
    __type: "PurchaseReservedInstancesOfferingResult",
    ReservedInstancesId: undefined
  };
  if (output["reservedInstancesId"] !== undefined) {
    contents.ReservedInstancesId = output["reservedInstancesId"];
  }
  return contents;
};

const deserializeAws_ec2PurchaseScheduledInstancesResult = (
  output: any,
  context: __SerdeContext
): PurchaseScheduledInstancesResult => {
  let contents: any = {
    __type: "PurchaseScheduledInstancesResult",
    ScheduledInstanceSet: undefined
  };
  if (output.scheduledInstanceSet === "") {
    contents.ScheduledInstanceSet = [];
  }
  if (
    output["scheduledInstanceSet"] !== undefined &&
    output["scheduledInstanceSet"]["item"] !== undefined
  ) {
    contents.ScheduledInstanceSet = deserializeAws_ec2PurchasedScheduledInstanceSet(
      __getArrayIfSingleItem(output["scheduledInstanceSet"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2PurchaseSet = (
  output: any,
  context: __SerdeContext
): Purchase[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2Purchase(entry, context)
  );
};

const deserializeAws_ec2RecurringCharge = (
  output: any,
  context: __SerdeContext
): RecurringCharge => {
  let contents: any = {
    __type: "RecurringCharge",
    Amount: undefined,
    Frequency: undefined
  };
  if (output["amount"] !== undefined) {
    contents.Amount = parseFloat(output["amount"]);
  }
  if (output["frequency"] !== undefined) {
    contents.Frequency = output["frequency"];
  }
  return contents;
};

const deserializeAws_ec2RecurringChargesList = (
  output: any,
  context: __SerdeContext
): RecurringCharge[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2RecurringCharge(entry, context)
  );
};

const deserializeAws_ec2Region = (
  output: any,
  context: __SerdeContext
): Region => {
  let contents: any = {
    __type: "Region",
    Endpoint: undefined,
    OptInStatus: undefined,
    RegionName: undefined
  };
  if (output["regionEndpoint"] !== undefined) {
    contents.Endpoint = output["regionEndpoint"];
  }
  if (output["optInStatus"] !== undefined) {
    contents.OptInStatus = output["optInStatus"];
  }
  if (output["regionName"] !== undefined) {
    contents.RegionName = output["regionName"];
  }
  return contents;
};

const deserializeAws_ec2RegionList = (
  output: any,
  context: __SerdeContext
): Region[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2Region(entry, context)
  );
};

const deserializeAws_ec2RegisterImageResult = (
  output: any,
  context: __SerdeContext
): RegisterImageResult => {
  let contents: any = {
    __type: "RegisterImageResult",
    ImageId: undefined
  };
  if (output["imageId"] !== undefined) {
    contents.ImageId = output["imageId"];
  }
  return contents;
};

const deserializeAws_ec2RegisterTransitGatewayMulticastGroupMembersResult = (
  output: any,
  context: __SerdeContext
): RegisterTransitGatewayMulticastGroupMembersResult => {
  let contents: any = {
    __type: "RegisterTransitGatewayMulticastGroupMembersResult",
    RegisteredMulticastGroupMembers: undefined
  };
  if (output["registeredMulticastGroupMembers"] !== undefined) {
    contents.RegisteredMulticastGroupMembers = deserializeAws_ec2TransitGatewayMulticastRegisteredGroupMembers(
      output["registeredMulticastGroupMembers"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2RegisterTransitGatewayMulticastGroupSourcesResult = (
  output: any,
  context: __SerdeContext
): RegisterTransitGatewayMulticastGroupSourcesResult => {
  let contents: any = {
    __type: "RegisterTransitGatewayMulticastGroupSourcesResult",
    RegisteredMulticastGroupSources: undefined
  };
  if (output["registeredMulticastGroupSources"] !== undefined) {
    contents.RegisteredMulticastGroupSources = deserializeAws_ec2TransitGatewayMulticastRegisteredGroupSources(
      output["registeredMulticastGroupSources"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2RejectTransitGatewayPeeringAttachmentResult = (
  output: any,
  context: __SerdeContext
): RejectTransitGatewayPeeringAttachmentResult => {
  let contents: any = {
    __type: "RejectTransitGatewayPeeringAttachmentResult",
    TransitGatewayPeeringAttachment: undefined
  };
  if (output["transitGatewayPeeringAttachment"] !== undefined) {
    contents.TransitGatewayPeeringAttachment = deserializeAws_ec2TransitGatewayPeeringAttachment(
      output["transitGatewayPeeringAttachment"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2RejectTransitGatewayVpcAttachmentResult = (
  output: any,
  context: __SerdeContext
): RejectTransitGatewayVpcAttachmentResult => {
  let contents: any = {
    __type: "RejectTransitGatewayVpcAttachmentResult",
    TransitGatewayVpcAttachment: undefined
  };
  if (output["transitGatewayVpcAttachment"] !== undefined) {
    contents.TransitGatewayVpcAttachment = deserializeAws_ec2TransitGatewayVpcAttachment(
      output["transitGatewayVpcAttachment"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2RejectVpcEndpointConnectionsResult = (
  output: any,
  context: __SerdeContext
): RejectVpcEndpointConnectionsResult => {
  let contents: any = {
    __type: "RejectVpcEndpointConnectionsResult",
    Unsuccessful: undefined
  };
  if (output.unsuccessful === "") {
    contents.Unsuccessful = [];
  }
  if (
    output["unsuccessful"] !== undefined &&
    output["unsuccessful"]["item"] !== undefined
  ) {
    contents.Unsuccessful = deserializeAws_ec2UnsuccessfulItemSet(
      __getArrayIfSingleItem(output["unsuccessful"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2RejectVpcPeeringConnectionResult = (
  output: any,
  context: __SerdeContext
): RejectVpcPeeringConnectionResult => {
  let contents: any = {
    __type: "RejectVpcPeeringConnectionResult",
    Return: undefined
  };
  if (output["return"] !== undefined) {
    contents.Return = output["return"] == "true";
  }
  return contents;
};

const deserializeAws_ec2ReleaseHostsResult = (
  output: any,
  context: __SerdeContext
): ReleaseHostsResult => {
  let contents: any = {
    __type: "ReleaseHostsResult",
    Successful: undefined,
    Unsuccessful: undefined
  };
  if (output.successful === "") {
    contents.Successful = [];
  }
  if (
    output["successful"] !== undefined &&
    output["successful"]["item"] !== undefined
  ) {
    contents.Successful = deserializeAws_ec2ResponseHostIdList(
      __getArrayIfSingleItem(output["successful"]["item"]),
      context
    );
  }
  if (output.unsuccessful === "") {
    contents.Unsuccessful = [];
  }
  if (
    output["unsuccessful"] !== undefined &&
    output["unsuccessful"]["item"] !== undefined
  ) {
    contents.Unsuccessful = deserializeAws_ec2UnsuccessfulItemList(
      __getArrayIfSingleItem(output["unsuccessful"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2ReplaceIamInstanceProfileAssociationResult = (
  output: any,
  context: __SerdeContext
): ReplaceIamInstanceProfileAssociationResult => {
  let contents: any = {
    __type: "ReplaceIamInstanceProfileAssociationResult",
    IamInstanceProfileAssociation: undefined
  };
  if (output["iamInstanceProfileAssociation"] !== undefined) {
    contents.IamInstanceProfileAssociation = deserializeAws_ec2IamInstanceProfileAssociation(
      output["iamInstanceProfileAssociation"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2ReplaceNetworkAclAssociationResult = (
  output: any,
  context: __SerdeContext
): ReplaceNetworkAclAssociationResult => {
  let contents: any = {
    __type: "ReplaceNetworkAclAssociationResult",
    NewAssociationId: undefined
  };
  if (output["newAssociationId"] !== undefined) {
    contents.NewAssociationId = output["newAssociationId"];
  }
  return contents;
};

const deserializeAws_ec2ReplaceRouteTableAssociationResult = (
  output: any,
  context: __SerdeContext
): ReplaceRouteTableAssociationResult => {
  let contents: any = {
    __type: "ReplaceRouteTableAssociationResult",
    AssociationState: undefined,
    NewAssociationId: undefined
  };
  if (output["associationState"] !== undefined) {
    contents.AssociationState = deserializeAws_ec2RouteTableAssociationState(
      output["associationState"],
      context
    );
  }
  if (output["newAssociationId"] !== undefined) {
    contents.NewAssociationId = output["newAssociationId"];
  }
  return contents;
};

const deserializeAws_ec2ReplaceTransitGatewayRouteResult = (
  output: any,
  context: __SerdeContext
): ReplaceTransitGatewayRouteResult => {
  let contents: any = {
    __type: "ReplaceTransitGatewayRouteResult",
    Route: undefined
  };
  if (output["route"] !== undefined) {
    contents.Route = deserializeAws_ec2TransitGatewayRoute(
      output["route"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2RequestSpotFleetResponse = (
  output: any,
  context: __SerdeContext
): RequestSpotFleetResponse => {
  let contents: any = {
    __type: "RequestSpotFleetResponse",
    SpotFleetRequestId: undefined
  };
  if (output["spotFleetRequestId"] !== undefined) {
    contents.SpotFleetRequestId = output["spotFleetRequestId"];
  }
  return contents;
};

const deserializeAws_ec2RequestSpotInstancesResult = (
  output: any,
  context: __SerdeContext
): RequestSpotInstancesResult => {
  let contents: any = {
    __type: "RequestSpotInstancesResult",
    SpotInstanceRequests: undefined
  };
  if (output.spotInstanceRequestSet === "") {
    contents.SpotInstanceRequests = [];
  }
  if (
    output["spotInstanceRequestSet"] !== undefined &&
    output["spotInstanceRequestSet"]["item"] !== undefined
  ) {
    contents.SpotInstanceRequests = deserializeAws_ec2SpotInstanceRequestList(
      __getArrayIfSingleItem(output["spotInstanceRequestSet"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2Reservation = (
  output: any,
  context: __SerdeContext
): Reservation => {
  let contents: any = {
    __type: "Reservation",
    Groups: undefined,
    Instances: undefined,
    OwnerId: undefined,
    RequesterId: undefined,
    ReservationId: undefined
  };
  if (output.groupSet === "") {
    contents.Groups = [];
  }
  if (
    output["groupSet"] !== undefined &&
    output["groupSet"]["item"] !== undefined
  ) {
    contents.Groups = deserializeAws_ec2GroupIdentifierList(
      __getArrayIfSingleItem(output["groupSet"]["item"]),
      context
    );
  }
  if (output.instancesSet === "") {
    contents.Instances = [];
  }
  if (
    output["instancesSet"] !== undefined &&
    output["instancesSet"]["item"] !== undefined
  ) {
    contents.Instances = deserializeAws_ec2InstanceList(
      __getArrayIfSingleItem(output["instancesSet"]["item"]),
      context
    );
  }
  if (output["ownerId"] !== undefined) {
    contents.OwnerId = output["ownerId"];
  }
  if (output["requesterId"] !== undefined) {
    contents.RequesterId = output["requesterId"];
  }
  if (output["reservationId"] !== undefined) {
    contents.ReservationId = output["reservationId"];
  }
  return contents;
};

const deserializeAws_ec2ReservationList = (
  output: any,
  context: __SerdeContext
): Reservation[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2Reservation(entry, context)
  );
};

const deserializeAws_ec2ReservationValue = (
  output: any,
  context: __SerdeContext
): ReservationValue => {
  let contents: any = {
    __type: "ReservationValue",
    HourlyPrice: undefined,
    RemainingTotalValue: undefined,
    RemainingUpfrontValue: undefined
  };
  if (output["hourlyPrice"] !== undefined) {
    contents.HourlyPrice = output["hourlyPrice"];
  }
  if (output["remainingTotalValue"] !== undefined) {
    contents.RemainingTotalValue = output["remainingTotalValue"];
  }
  if (output["remainingUpfrontValue"] !== undefined) {
    contents.RemainingUpfrontValue = output["remainingUpfrontValue"];
  }
  return contents;
};

const deserializeAws_ec2ReservedInstanceReservationValue = (
  output: any,
  context: __SerdeContext
): ReservedInstanceReservationValue => {
  let contents: any = {
    __type: "ReservedInstanceReservationValue",
    ReservationValue: undefined,
    ReservedInstanceId: undefined
  };
  if (output["reservationValue"] !== undefined) {
    contents.ReservationValue = deserializeAws_ec2ReservationValue(
      output["reservationValue"],
      context
    );
  }
  if (output["reservedInstanceId"] !== undefined) {
    contents.ReservedInstanceId = output["reservedInstanceId"];
  }
  return contents;
};

const deserializeAws_ec2ReservedInstanceReservationValueSet = (
  output: any,
  context: __SerdeContext
): ReservedInstanceReservationValue[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2ReservedInstanceReservationValue(entry, context)
  );
};

const deserializeAws_ec2ReservedInstances = (
  output: any,
  context: __SerdeContext
): ReservedInstances => {
  let contents: any = {
    __type: "ReservedInstances",
    AvailabilityZone: undefined,
    CurrencyCode: undefined,
    Duration: undefined,
    End: undefined,
    FixedPrice: undefined,
    InstanceCount: undefined,
    InstanceTenancy: undefined,
    InstanceType: undefined,
    OfferingClass: undefined,
    OfferingType: undefined,
    ProductDescription: undefined,
    RecurringCharges: undefined,
    ReservedInstancesId: undefined,
    Scope: undefined,
    Start: undefined,
    State: undefined,
    Tags: undefined,
    UsagePrice: undefined
  };
  if (output["availabilityZone"] !== undefined) {
    contents.AvailabilityZone = output["availabilityZone"];
  }
  if (output["currencyCode"] !== undefined) {
    contents.CurrencyCode = output["currencyCode"];
  }
  if (output["duration"] !== undefined) {
    contents.Duration = parseInt(output["duration"]);
  }
  if (output["end"] !== undefined) {
    contents.End = new Date(output["end"]);
  }
  if (output["fixedPrice"] !== undefined) {
    contents.FixedPrice = parseFloat(output["fixedPrice"]);
  }
  if (output["instanceCount"] !== undefined) {
    contents.InstanceCount = parseInt(output["instanceCount"]);
  }
  if (output["instanceTenancy"] !== undefined) {
    contents.InstanceTenancy = output["instanceTenancy"];
  }
  if (output["instanceType"] !== undefined) {
    contents.InstanceType = output["instanceType"];
  }
  if (output["offeringClass"] !== undefined) {
    contents.OfferingClass = output["offeringClass"];
  }
  if (output["offeringType"] !== undefined) {
    contents.OfferingType = output["offeringType"];
  }
  if (output["productDescription"] !== undefined) {
    contents.ProductDescription = output["productDescription"];
  }
  if (output.recurringCharges === "") {
    contents.RecurringCharges = [];
  }
  if (
    output["recurringCharges"] !== undefined &&
    output["recurringCharges"]["item"] !== undefined
  ) {
    contents.RecurringCharges = deserializeAws_ec2RecurringChargesList(
      __getArrayIfSingleItem(output["recurringCharges"]["item"]),
      context
    );
  }
  if (output["reservedInstancesId"] !== undefined) {
    contents.ReservedInstancesId = output["reservedInstancesId"];
  }
  if (output["scope"] !== undefined) {
    contents.Scope = output["scope"];
  }
  if (output["start"] !== undefined) {
    contents.Start = new Date(output["start"]);
  }
  if (output["state"] !== undefined) {
    contents.State = output["state"];
  }
  if (output.tagSet === "") {
    contents.Tags = [];
  }
  if (
    output["tagSet"] !== undefined &&
    output["tagSet"]["item"] !== undefined
  ) {
    contents.Tags = deserializeAws_ec2TagList(
      __getArrayIfSingleItem(output["tagSet"]["item"]),
      context
    );
  }
  if (output["usagePrice"] !== undefined) {
    contents.UsagePrice = parseFloat(output["usagePrice"]);
  }
  return contents;
};

const deserializeAws_ec2ReservedInstancesConfiguration = (
  output: any,
  context: __SerdeContext
): ReservedInstancesConfiguration => {
  let contents: any = {
    __type: "ReservedInstancesConfiguration",
    AvailabilityZone: undefined,
    InstanceCount: undefined,
    InstanceType: undefined,
    Platform: undefined,
    Scope: undefined
  };
  if (output["availabilityZone"] !== undefined) {
    contents.AvailabilityZone = output["availabilityZone"];
  }
  if (output["instanceCount"] !== undefined) {
    contents.InstanceCount = parseInt(output["instanceCount"]);
  }
  if (output["instanceType"] !== undefined) {
    contents.InstanceType = output["instanceType"];
  }
  if (output["platform"] !== undefined) {
    contents.Platform = output["platform"];
  }
  if (output["scope"] !== undefined) {
    contents.Scope = output["scope"];
  }
  return contents;
};

const deserializeAws_ec2ReservedInstancesId = (
  output: any,
  context: __SerdeContext
): ReservedInstancesId => {
  let contents: any = {
    __type: "ReservedInstancesId",
    ReservedInstancesId: undefined
  };
  if (output["reservedInstancesId"] !== undefined) {
    contents.ReservedInstancesId = output["reservedInstancesId"];
  }
  return contents;
};

const deserializeAws_ec2ReservedInstancesList = (
  output: any,
  context: __SerdeContext
): ReservedInstances[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2ReservedInstances(entry, context)
  );
};

const deserializeAws_ec2ReservedInstancesListing = (
  output: any,
  context: __SerdeContext
): ReservedInstancesListing => {
  let contents: any = {
    __type: "ReservedInstancesListing",
    ClientToken: undefined,
    CreateDate: undefined,
    InstanceCounts: undefined,
    PriceSchedules: undefined,
    ReservedInstancesId: undefined,
    ReservedInstancesListingId: undefined,
    Status: undefined,
    StatusMessage: undefined,
    Tags: undefined,
    UpdateDate: undefined
  };
  if (output["clientToken"] !== undefined) {
    contents.ClientToken = output["clientToken"];
  }
  if (output["createDate"] !== undefined) {
    contents.CreateDate = new Date(output["createDate"]);
  }
  if (output.instanceCounts === "") {
    contents.InstanceCounts = [];
  }
  if (
    output["instanceCounts"] !== undefined &&
    output["instanceCounts"]["item"] !== undefined
  ) {
    contents.InstanceCounts = deserializeAws_ec2InstanceCountList(
      __getArrayIfSingleItem(output["instanceCounts"]["item"]),
      context
    );
  }
  if (output.priceSchedules === "") {
    contents.PriceSchedules = [];
  }
  if (
    output["priceSchedules"] !== undefined &&
    output["priceSchedules"]["item"] !== undefined
  ) {
    contents.PriceSchedules = deserializeAws_ec2PriceScheduleList(
      __getArrayIfSingleItem(output["priceSchedules"]["item"]),
      context
    );
  }
  if (output["reservedInstancesId"] !== undefined) {
    contents.ReservedInstancesId = output["reservedInstancesId"];
  }
  if (output["reservedInstancesListingId"] !== undefined) {
    contents.ReservedInstancesListingId = output["reservedInstancesListingId"];
  }
  if (output["status"] !== undefined) {
    contents.Status = output["status"];
  }
  if (output["statusMessage"] !== undefined) {
    contents.StatusMessage = output["statusMessage"];
  }
  if (output.tagSet === "") {
    contents.Tags = [];
  }
  if (
    output["tagSet"] !== undefined &&
    output["tagSet"]["item"] !== undefined
  ) {
    contents.Tags = deserializeAws_ec2TagList(
      __getArrayIfSingleItem(output["tagSet"]["item"]),
      context
    );
  }
  if (output["updateDate"] !== undefined) {
    contents.UpdateDate = new Date(output["updateDate"]);
  }
  return contents;
};

const deserializeAws_ec2ReservedInstancesListingList = (
  output: any,
  context: __SerdeContext
): ReservedInstancesListing[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2ReservedInstancesListing(entry, context)
  );
};

const deserializeAws_ec2ReservedInstancesModification = (
  output: any,
  context: __SerdeContext
): ReservedInstancesModification => {
  let contents: any = {
    __type: "ReservedInstancesModification",
    ClientToken: undefined,
    CreateDate: undefined,
    EffectiveDate: undefined,
    ModificationResults: undefined,
    ReservedInstancesIds: undefined,
    ReservedInstancesModificationId: undefined,
    Status: undefined,
    StatusMessage: undefined,
    UpdateDate: undefined
  };
  if (output["clientToken"] !== undefined) {
    contents.ClientToken = output["clientToken"];
  }
  if (output["createDate"] !== undefined) {
    contents.CreateDate = new Date(output["createDate"]);
  }
  if (output["effectiveDate"] !== undefined) {
    contents.EffectiveDate = new Date(output["effectiveDate"]);
  }
  if (output.modificationResultSet === "") {
    contents.ModificationResults = [];
  }
  if (
    output["modificationResultSet"] !== undefined &&
    output["modificationResultSet"]["item"] !== undefined
  ) {
    contents.ModificationResults = deserializeAws_ec2ReservedInstancesModificationResultList(
      __getArrayIfSingleItem(output["modificationResultSet"]["item"]),
      context
    );
  }
  if (output.reservedInstancesSet === "") {
    contents.ReservedInstancesIds = [];
  }
  if (
    output["reservedInstancesSet"] !== undefined &&
    output["reservedInstancesSet"]["item"] !== undefined
  ) {
    contents.ReservedInstancesIds = deserializeAws_ec2ReservedIntancesIds(
      __getArrayIfSingleItem(output["reservedInstancesSet"]["item"]),
      context
    );
  }
  if (output["reservedInstancesModificationId"] !== undefined) {
    contents.ReservedInstancesModificationId =
      output["reservedInstancesModificationId"];
  }
  if (output["status"] !== undefined) {
    contents.Status = output["status"];
  }
  if (output["statusMessage"] !== undefined) {
    contents.StatusMessage = output["statusMessage"];
  }
  if (output["updateDate"] !== undefined) {
    contents.UpdateDate = new Date(output["updateDate"]);
  }
  return contents;
};

const deserializeAws_ec2ReservedInstancesModificationList = (
  output: any,
  context: __SerdeContext
): ReservedInstancesModification[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2ReservedInstancesModification(entry, context)
  );
};

const deserializeAws_ec2ReservedInstancesModificationResult = (
  output: any,
  context: __SerdeContext
): ReservedInstancesModificationResult => {
  let contents: any = {
    __type: "ReservedInstancesModificationResult",
    ReservedInstancesId: undefined,
    TargetConfiguration: undefined
  };
  if (output["reservedInstancesId"] !== undefined) {
    contents.ReservedInstancesId = output["reservedInstancesId"];
  }
  if (output["targetConfiguration"] !== undefined) {
    contents.TargetConfiguration = deserializeAws_ec2ReservedInstancesConfiguration(
      output["targetConfiguration"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2ReservedInstancesModificationResultList = (
  output: any,
  context: __SerdeContext
): ReservedInstancesModificationResult[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2ReservedInstancesModificationResult(entry, context)
  );
};

const deserializeAws_ec2ReservedInstancesOffering = (
  output: any,
  context: __SerdeContext
): ReservedInstancesOffering => {
  let contents: any = {
    __type: "ReservedInstancesOffering",
    AvailabilityZone: undefined,
    CurrencyCode: undefined,
    Duration: undefined,
    FixedPrice: undefined,
    InstanceTenancy: undefined,
    InstanceType: undefined,
    Marketplace: undefined,
    OfferingClass: undefined,
    OfferingType: undefined,
    PricingDetails: undefined,
    ProductDescription: undefined,
    RecurringCharges: undefined,
    ReservedInstancesOfferingId: undefined,
    Scope: undefined,
    UsagePrice: undefined
  };
  if (output["availabilityZone"] !== undefined) {
    contents.AvailabilityZone = output["availabilityZone"];
  }
  if (output["currencyCode"] !== undefined) {
    contents.CurrencyCode = output["currencyCode"];
  }
  if (output["duration"] !== undefined) {
    contents.Duration = parseInt(output["duration"]);
  }
  if (output["fixedPrice"] !== undefined) {
    contents.FixedPrice = parseFloat(output["fixedPrice"]);
  }
  if (output["instanceTenancy"] !== undefined) {
    contents.InstanceTenancy = output["instanceTenancy"];
  }
  if (output["instanceType"] !== undefined) {
    contents.InstanceType = output["instanceType"];
  }
  if (output["marketplace"] !== undefined) {
    contents.Marketplace = output["marketplace"] == "true";
  }
  if (output["offeringClass"] !== undefined) {
    contents.OfferingClass = output["offeringClass"];
  }
  if (output["offeringType"] !== undefined) {
    contents.OfferingType = output["offeringType"];
  }
  if (output.pricingDetailsSet === "") {
    contents.PricingDetails = [];
  }
  if (
    output["pricingDetailsSet"] !== undefined &&
    output["pricingDetailsSet"]["item"] !== undefined
  ) {
    contents.PricingDetails = deserializeAws_ec2PricingDetailsList(
      __getArrayIfSingleItem(output["pricingDetailsSet"]["item"]),
      context
    );
  }
  if (output["productDescription"] !== undefined) {
    contents.ProductDescription = output["productDescription"];
  }
  if (output.recurringCharges === "") {
    contents.RecurringCharges = [];
  }
  if (
    output["recurringCharges"] !== undefined &&
    output["recurringCharges"]["item"] !== undefined
  ) {
    contents.RecurringCharges = deserializeAws_ec2RecurringChargesList(
      __getArrayIfSingleItem(output["recurringCharges"]["item"]),
      context
    );
  }
  if (output["reservedInstancesOfferingId"] !== undefined) {
    contents.ReservedInstancesOfferingId =
      output["reservedInstancesOfferingId"];
  }
  if (output["scope"] !== undefined) {
    contents.Scope = output["scope"];
  }
  if (output["usagePrice"] !== undefined) {
    contents.UsagePrice = parseFloat(output["usagePrice"]);
  }
  return contents;
};

const deserializeAws_ec2ReservedInstancesOfferingList = (
  output: any,
  context: __SerdeContext
): ReservedInstancesOffering[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2ReservedInstancesOffering(entry, context)
  );
};

const deserializeAws_ec2ReservedIntancesIds = (
  output: any,
  context: __SerdeContext
): ReservedInstancesId[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2ReservedInstancesId(entry, context)
  );
};

const deserializeAws_ec2ResetEbsDefaultKmsKeyIdResult = (
  output: any,
  context: __SerdeContext
): ResetEbsDefaultKmsKeyIdResult => {
  let contents: any = {
    __type: "ResetEbsDefaultKmsKeyIdResult",
    KmsKeyId: undefined
  };
  if (output["kmsKeyId"] !== undefined) {
    contents.KmsKeyId = output["kmsKeyId"];
  }
  return contents;
};

const deserializeAws_ec2ResetFpgaImageAttributeResult = (
  output: any,
  context: __SerdeContext
): ResetFpgaImageAttributeResult => {
  let contents: any = {
    __type: "ResetFpgaImageAttributeResult",
    Return: undefined
  };
  if (output["return"] !== undefined) {
    contents.Return = output["return"] == "true";
  }
  return contents;
};

const deserializeAws_ec2ResponseError = (
  output: any,
  context: __SerdeContext
): ResponseError => {
  let contents: any = {
    __type: "ResponseError",
    Code: undefined,
    Message: undefined
  };
  if (output["code"] !== undefined) {
    contents.Code = output["code"];
  }
  if (output["message"] !== undefined) {
    contents.Message = output["message"];
  }
  return contents;
};

const deserializeAws_ec2ResponseHostIdList = (
  output: any,
  context: __SerdeContext
): string[] => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_ec2ResponseHostIdSet = (
  output: any,
  context: __SerdeContext
): string[] => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_ec2ResponseLaunchTemplateData = (
  output: any,
  context: __SerdeContext
): ResponseLaunchTemplateData => {
  let contents: any = {
    __type: "ResponseLaunchTemplateData",
    BlockDeviceMappings: undefined,
    CapacityReservationSpecification: undefined,
    CpuOptions: undefined,
    CreditSpecification: undefined,
    DisableApiTermination: undefined,
    EbsOptimized: undefined,
    ElasticGpuSpecifications: undefined,
    ElasticInferenceAccelerators: undefined,
    HibernationOptions: undefined,
    IamInstanceProfile: undefined,
    ImageId: undefined,
    InstanceInitiatedShutdownBehavior: undefined,
    InstanceMarketOptions: undefined,
    InstanceType: undefined,
    KernelId: undefined,
    KeyName: undefined,
    LicenseSpecifications: undefined,
    MetadataOptions: undefined,
    Monitoring: undefined,
    NetworkInterfaces: undefined,
    Placement: undefined,
    RamDiskId: undefined,
    SecurityGroupIds: undefined,
    SecurityGroups: undefined,
    TagSpecifications: undefined,
    UserData: undefined
  };
  if (output.blockDeviceMappingSet === "") {
    contents.BlockDeviceMappings = [];
  }
  if (
    output["blockDeviceMappingSet"] !== undefined &&
    output["blockDeviceMappingSet"]["item"] !== undefined
  ) {
    contents.BlockDeviceMappings = deserializeAws_ec2LaunchTemplateBlockDeviceMappingList(
      __getArrayIfSingleItem(output["blockDeviceMappingSet"]["item"]),
      context
    );
  }
  if (output["capacityReservationSpecification"] !== undefined) {
    contents.CapacityReservationSpecification = deserializeAws_ec2LaunchTemplateCapacityReservationSpecificationResponse(
      output["capacityReservationSpecification"],
      context
    );
  }
  if (output["cpuOptions"] !== undefined) {
    contents.CpuOptions = deserializeAws_ec2LaunchTemplateCpuOptions(
      output["cpuOptions"],
      context
    );
  }
  if (output["creditSpecification"] !== undefined) {
    contents.CreditSpecification = deserializeAws_ec2CreditSpecification(
      output["creditSpecification"],
      context
    );
  }
  if (output["disableApiTermination"] !== undefined) {
    contents.DisableApiTermination = output["disableApiTermination"] == "true";
  }
  if (output["ebsOptimized"] !== undefined) {
    contents.EbsOptimized = output["ebsOptimized"] == "true";
  }
  if (output.elasticGpuSpecificationSet === "") {
    contents.ElasticGpuSpecifications = [];
  }
  if (
    output["elasticGpuSpecificationSet"] !== undefined &&
    output["elasticGpuSpecificationSet"]["item"] !== undefined
  ) {
    contents.ElasticGpuSpecifications = deserializeAws_ec2ElasticGpuSpecificationResponseList(
      __getArrayIfSingleItem(output["elasticGpuSpecificationSet"]["item"]),
      context
    );
  }
  if (output.elasticInferenceAcceleratorSet === "") {
    contents.ElasticInferenceAccelerators = [];
  }
  if (
    output["elasticInferenceAcceleratorSet"] !== undefined &&
    output["elasticInferenceAcceleratorSet"]["item"] !== undefined
  ) {
    contents.ElasticInferenceAccelerators = deserializeAws_ec2LaunchTemplateElasticInferenceAcceleratorResponseList(
      __getArrayIfSingleItem(output["elasticInferenceAcceleratorSet"]["item"]),
      context
    );
  }
  if (output["hibernationOptions"] !== undefined) {
    contents.HibernationOptions = deserializeAws_ec2LaunchTemplateHibernationOptions(
      output["hibernationOptions"],
      context
    );
  }
  if (output["iamInstanceProfile"] !== undefined) {
    contents.IamInstanceProfile = deserializeAws_ec2LaunchTemplateIamInstanceProfileSpecification(
      output["iamInstanceProfile"],
      context
    );
  }
  if (output["imageId"] !== undefined) {
    contents.ImageId = output["imageId"];
  }
  if (output["instanceInitiatedShutdownBehavior"] !== undefined) {
    contents.InstanceInitiatedShutdownBehavior =
      output["instanceInitiatedShutdownBehavior"];
  }
  if (output["instanceMarketOptions"] !== undefined) {
    contents.InstanceMarketOptions = deserializeAws_ec2LaunchTemplateInstanceMarketOptions(
      output["instanceMarketOptions"],
      context
    );
  }
  if (output["instanceType"] !== undefined) {
    contents.InstanceType = output["instanceType"];
  }
  if (output["kernelId"] !== undefined) {
    contents.KernelId = output["kernelId"];
  }
  if (output["keyName"] !== undefined) {
    contents.KeyName = output["keyName"];
  }
  if (output.licenseSet === "") {
    contents.LicenseSpecifications = [];
  }
  if (
    output["licenseSet"] !== undefined &&
    output["licenseSet"]["item"] !== undefined
  ) {
    contents.LicenseSpecifications = deserializeAws_ec2LaunchTemplateLicenseList(
      __getArrayIfSingleItem(output["licenseSet"]["item"]),
      context
    );
  }
  if (output["metadataOptions"] !== undefined) {
    contents.MetadataOptions = deserializeAws_ec2LaunchTemplateInstanceMetadataOptions(
      output["metadataOptions"],
      context
    );
  }
  if (output["monitoring"] !== undefined) {
    contents.Monitoring = deserializeAws_ec2LaunchTemplatesMonitoring(
      output["monitoring"],
      context
    );
  }
  if (output.networkInterfaceSet === "") {
    contents.NetworkInterfaces = [];
  }
  if (
    output["networkInterfaceSet"] !== undefined &&
    output["networkInterfaceSet"]["item"] !== undefined
  ) {
    contents.NetworkInterfaces = deserializeAws_ec2LaunchTemplateInstanceNetworkInterfaceSpecificationList(
      __getArrayIfSingleItem(output["networkInterfaceSet"]["item"]),
      context
    );
  }
  if (output["placement"] !== undefined) {
    contents.Placement = deserializeAws_ec2LaunchTemplatePlacement(
      output["placement"],
      context
    );
  }
  if (output["ramDiskId"] !== undefined) {
    contents.RamDiskId = output["ramDiskId"];
  }
  if (output.securityGroupIdSet === "") {
    contents.SecurityGroupIds = [];
  }
  if (
    output["securityGroupIdSet"] !== undefined &&
    output["securityGroupIdSet"]["item"] !== undefined
  ) {
    contents.SecurityGroupIds = deserializeAws_ec2ValueStringList(
      __getArrayIfSingleItem(output["securityGroupIdSet"]["item"]),
      context
    );
  }
  if (output.securityGroupSet === "") {
    contents.SecurityGroups = [];
  }
  if (
    output["securityGroupSet"] !== undefined &&
    output["securityGroupSet"]["item"] !== undefined
  ) {
    contents.SecurityGroups = deserializeAws_ec2ValueStringList(
      __getArrayIfSingleItem(output["securityGroupSet"]["item"]),
      context
    );
  }
  if (output.tagSpecificationSet === "") {
    contents.TagSpecifications = [];
  }
  if (
    output["tagSpecificationSet"] !== undefined &&
    output["tagSpecificationSet"]["item"] !== undefined
  ) {
    contents.TagSpecifications = deserializeAws_ec2LaunchTemplateTagSpecificationList(
      __getArrayIfSingleItem(output["tagSpecificationSet"]["item"]),
      context
    );
  }
  if (output["userData"] !== undefined) {
    contents.UserData = output["userData"];
  }
  return contents;
};

const deserializeAws_ec2RestoreAddressToClassicResult = (
  output: any,
  context: __SerdeContext
): RestoreAddressToClassicResult => {
  let contents: any = {
    __type: "RestoreAddressToClassicResult",
    PublicIp: undefined,
    Status: undefined
  };
  if (output["publicIp"] !== undefined) {
    contents.PublicIp = output["publicIp"];
  }
  if (output["status"] !== undefined) {
    contents.Status = output["status"];
  }
  return contents;
};

const deserializeAws_ec2RevokeClientVpnIngressResult = (
  output: any,
  context: __SerdeContext
): RevokeClientVpnIngressResult => {
  let contents: any = {
    __type: "RevokeClientVpnIngressResult",
    Status: undefined
  };
  if (output["status"] !== undefined) {
    contents.Status = deserializeAws_ec2ClientVpnAuthorizationRuleStatus(
      output["status"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2RootDeviceTypeList = (
  output: any,
  context: __SerdeContext
): (RootDeviceType | string)[] => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_ec2Route = (
  output: any,
  context: __SerdeContext
): Route => {
  let contents: any = {
    __type: "Route",
    DestinationCidrBlock: undefined,
    DestinationIpv6CidrBlock: undefined,
    DestinationPrefixListId: undefined,
    EgressOnlyInternetGatewayId: undefined,
    GatewayId: undefined,
    InstanceId: undefined,
    InstanceOwnerId: undefined,
    LocalGatewayId: undefined,
    NatGatewayId: undefined,
    NetworkInterfaceId: undefined,
    Origin: undefined,
    State: undefined,
    TransitGatewayId: undefined,
    VpcPeeringConnectionId: undefined
  };
  if (output["destinationCidrBlock"] !== undefined) {
    contents.DestinationCidrBlock = output["destinationCidrBlock"];
  }
  if (output["destinationIpv6CidrBlock"] !== undefined) {
    contents.DestinationIpv6CidrBlock = output["destinationIpv6CidrBlock"];
  }
  if (output["destinationPrefixListId"] !== undefined) {
    contents.DestinationPrefixListId = output["destinationPrefixListId"];
  }
  if (output["egressOnlyInternetGatewayId"] !== undefined) {
    contents.EgressOnlyInternetGatewayId =
      output["egressOnlyInternetGatewayId"];
  }
  if (output["gatewayId"] !== undefined) {
    contents.GatewayId = output["gatewayId"];
  }
  if (output["instanceId"] !== undefined) {
    contents.InstanceId = output["instanceId"];
  }
  if (output["instanceOwnerId"] !== undefined) {
    contents.InstanceOwnerId = output["instanceOwnerId"];
  }
  if (output["localGatewayId"] !== undefined) {
    contents.LocalGatewayId = output["localGatewayId"];
  }
  if (output["natGatewayId"] !== undefined) {
    contents.NatGatewayId = output["natGatewayId"];
  }
  if (output["networkInterfaceId"] !== undefined) {
    contents.NetworkInterfaceId = output["networkInterfaceId"];
  }
  if (output["origin"] !== undefined) {
    contents.Origin = output["origin"];
  }
  if (output["state"] !== undefined) {
    contents.State = output["state"];
  }
  if (output["transitGatewayId"] !== undefined) {
    contents.TransitGatewayId = output["transitGatewayId"];
  }
  if (output["vpcPeeringConnectionId"] !== undefined) {
    contents.VpcPeeringConnectionId = output["vpcPeeringConnectionId"];
  }
  return contents;
};

const deserializeAws_ec2RouteList = (
  output: any,
  context: __SerdeContext
): Route[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2Route(entry, context)
  );
};

const deserializeAws_ec2RouteTable = (
  output: any,
  context: __SerdeContext
): RouteTable => {
  let contents: any = {
    __type: "RouteTable",
    Associations: undefined,
    OwnerId: undefined,
    PropagatingVgws: undefined,
    RouteTableId: undefined,
    Routes: undefined,
    Tags: undefined,
    VpcId: undefined
  };
  if (output.associationSet === "") {
    contents.Associations = [];
  }
  if (
    output["associationSet"] !== undefined &&
    output["associationSet"]["item"] !== undefined
  ) {
    contents.Associations = deserializeAws_ec2RouteTableAssociationList(
      __getArrayIfSingleItem(output["associationSet"]["item"]),
      context
    );
  }
  if (output["ownerId"] !== undefined) {
    contents.OwnerId = output["ownerId"];
  }
  if (output.propagatingVgwSet === "") {
    contents.PropagatingVgws = [];
  }
  if (
    output["propagatingVgwSet"] !== undefined &&
    output["propagatingVgwSet"]["item"] !== undefined
  ) {
    contents.PropagatingVgws = deserializeAws_ec2PropagatingVgwList(
      __getArrayIfSingleItem(output["propagatingVgwSet"]["item"]),
      context
    );
  }
  if (output["routeTableId"] !== undefined) {
    contents.RouteTableId = output["routeTableId"];
  }
  if (output.routeSet === "") {
    contents.Routes = [];
  }
  if (
    output["routeSet"] !== undefined &&
    output["routeSet"]["item"] !== undefined
  ) {
    contents.Routes = deserializeAws_ec2RouteList(
      __getArrayIfSingleItem(output["routeSet"]["item"]),
      context
    );
  }
  if (output.tagSet === "") {
    contents.Tags = [];
  }
  if (
    output["tagSet"] !== undefined &&
    output["tagSet"]["item"] !== undefined
  ) {
    contents.Tags = deserializeAws_ec2TagList(
      __getArrayIfSingleItem(output["tagSet"]["item"]),
      context
    );
  }
  if (output["vpcId"] !== undefined) {
    contents.VpcId = output["vpcId"];
  }
  return contents;
};

const deserializeAws_ec2RouteTableAssociation = (
  output: any,
  context: __SerdeContext
): RouteTableAssociation => {
  let contents: any = {
    __type: "RouteTableAssociation",
    AssociationState: undefined,
    GatewayId: undefined,
    Main: undefined,
    RouteTableAssociationId: undefined,
    RouteTableId: undefined,
    SubnetId: undefined
  };
  if (output["associationState"] !== undefined) {
    contents.AssociationState = deserializeAws_ec2RouteTableAssociationState(
      output["associationState"],
      context
    );
  }
  if (output["gatewayId"] !== undefined) {
    contents.GatewayId = output["gatewayId"];
  }
  if (output["main"] !== undefined) {
    contents.Main = output["main"] == "true";
  }
  if (output["routeTableAssociationId"] !== undefined) {
    contents.RouteTableAssociationId = output["routeTableAssociationId"];
  }
  if (output["routeTableId"] !== undefined) {
    contents.RouteTableId = output["routeTableId"];
  }
  if (output["subnetId"] !== undefined) {
    contents.SubnetId = output["subnetId"];
  }
  return contents;
};

const deserializeAws_ec2RouteTableAssociationList = (
  output: any,
  context: __SerdeContext
): RouteTableAssociation[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2RouteTableAssociation(entry, context)
  );
};

const deserializeAws_ec2RouteTableAssociationState = (
  output: any,
  context: __SerdeContext
): RouteTableAssociationState => {
  let contents: any = {
    __type: "RouteTableAssociationState",
    State: undefined,
    StatusMessage: undefined
  };
  if (output["state"] !== undefined) {
    contents.State = output["state"];
  }
  if (output["statusMessage"] !== undefined) {
    contents.StatusMessage = output["statusMessage"];
  }
  return contents;
};

const deserializeAws_ec2RouteTableList = (
  output: any,
  context: __SerdeContext
): RouteTable[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2RouteTable(entry, context)
  );
};

const deserializeAws_ec2RunInstancesMonitoringEnabled = (
  output: any,
  context: __SerdeContext
): RunInstancesMonitoringEnabled => {
  let contents: any = {
    __type: "RunInstancesMonitoringEnabled",
    Enabled: undefined
  };
  if (output["enabled"] !== undefined) {
    contents.Enabled = output["enabled"] == "true";
  }
  return contents;
};

const deserializeAws_ec2RunScheduledInstancesResult = (
  output: any,
  context: __SerdeContext
): RunScheduledInstancesResult => {
  let contents: any = {
    __type: "RunScheduledInstancesResult",
    InstanceIdSet: undefined
  };
  if (output.instanceIdSet === "") {
    contents.InstanceIdSet = [];
  }
  if (
    output["instanceIdSet"] !== undefined &&
    output["instanceIdSet"]["item"] !== undefined
  ) {
    contents.InstanceIdSet = deserializeAws_ec2InstanceIdSet(
      __getArrayIfSingleItem(output["instanceIdSet"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2S3Storage = (
  output: any,
  context: __SerdeContext
): S3Storage => {
  let contents: any = {
    __type: "S3Storage",
    AWSAccessKeyId: undefined,
    Bucket: undefined,
    Prefix: undefined,
    UploadPolicy: undefined,
    UploadPolicySignature: undefined
  };
  if (output["AWSAccessKeyId"] !== undefined) {
    contents.AWSAccessKeyId = output["AWSAccessKeyId"];
  }
  if (output["bucket"] !== undefined) {
    contents.Bucket = output["bucket"];
  }
  if (output["prefix"] !== undefined) {
    contents.Prefix = output["prefix"];
  }
  if (output["uploadPolicy"] !== undefined) {
    contents.UploadPolicy = context.base64Decoder(output["uploadPolicy"]);
  }
  if (output["uploadPolicySignature"] !== undefined) {
    contents.UploadPolicySignature = output["uploadPolicySignature"];
  }
  return contents;
};

const deserializeAws_ec2ScheduledInstance = (
  output: any,
  context: __SerdeContext
): ScheduledInstance => {
  let contents: any = {
    __type: "ScheduledInstance",
    AvailabilityZone: undefined,
    CreateDate: undefined,
    HourlyPrice: undefined,
    InstanceCount: undefined,
    InstanceType: undefined,
    NetworkPlatform: undefined,
    NextSlotStartTime: undefined,
    Platform: undefined,
    PreviousSlotEndTime: undefined,
    Recurrence: undefined,
    ScheduledInstanceId: undefined,
    SlotDurationInHours: undefined,
    TermEndDate: undefined,
    TermStartDate: undefined,
    TotalScheduledInstanceHours: undefined
  };
  if (output["availabilityZone"] !== undefined) {
    contents.AvailabilityZone = output["availabilityZone"];
  }
  if (output["createDate"] !== undefined) {
    contents.CreateDate = new Date(output["createDate"]);
  }
  if (output["hourlyPrice"] !== undefined) {
    contents.HourlyPrice = output["hourlyPrice"];
  }
  if (output["instanceCount"] !== undefined) {
    contents.InstanceCount = parseInt(output["instanceCount"]);
  }
  if (output["instanceType"] !== undefined) {
    contents.InstanceType = output["instanceType"];
  }
  if (output["networkPlatform"] !== undefined) {
    contents.NetworkPlatform = output["networkPlatform"];
  }
  if (output["nextSlotStartTime"] !== undefined) {
    contents.NextSlotStartTime = new Date(output["nextSlotStartTime"]);
  }
  if (output["platform"] !== undefined) {
    contents.Platform = output["platform"];
  }
  if (output["previousSlotEndTime"] !== undefined) {
    contents.PreviousSlotEndTime = new Date(output["previousSlotEndTime"]);
  }
  if (output["recurrence"] !== undefined) {
    contents.Recurrence = deserializeAws_ec2ScheduledInstanceRecurrence(
      output["recurrence"],
      context
    );
  }
  if (output["scheduledInstanceId"] !== undefined) {
    contents.ScheduledInstanceId = output["scheduledInstanceId"];
  }
  if (output["slotDurationInHours"] !== undefined) {
    contents.SlotDurationInHours = parseInt(output["slotDurationInHours"]);
  }
  if (output["termEndDate"] !== undefined) {
    contents.TermEndDate = new Date(output["termEndDate"]);
  }
  if (output["termStartDate"] !== undefined) {
    contents.TermStartDate = new Date(output["termStartDate"]);
  }
  if (output["totalScheduledInstanceHours"] !== undefined) {
    contents.TotalScheduledInstanceHours = parseInt(
      output["totalScheduledInstanceHours"]
    );
  }
  return contents;
};

const deserializeAws_ec2ScheduledInstanceAvailability = (
  output: any,
  context: __SerdeContext
): ScheduledInstanceAvailability => {
  let contents: any = {
    __type: "ScheduledInstanceAvailability",
    AvailabilityZone: undefined,
    AvailableInstanceCount: undefined,
    FirstSlotStartTime: undefined,
    HourlyPrice: undefined,
    InstanceType: undefined,
    MaxTermDurationInDays: undefined,
    MinTermDurationInDays: undefined,
    NetworkPlatform: undefined,
    Platform: undefined,
    PurchaseToken: undefined,
    Recurrence: undefined,
    SlotDurationInHours: undefined,
    TotalScheduledInstanceHours: undefined
  };
  if (output["availabilityZone"] !== undefined) {
    contents.AvailabilityZone = output["availabilityZone"];
  }
  if (output["availableInstanceCount"] !== undefined) {
    contents.AvailableInstanceCount = parseInt(
      output["availableInstanceCount"]
    );
  }
  if (output["firstSlotStartTime"] !== undefined) {
    contents.FirstSlotStartTime = new Date(output["firstSlotStartTime"]);
  }
  if (output["hourlyPrice"] !== undefined) {
    contents.HourlyPrice = output["hourlyPrice"];
  }
  if (output["instanceType"] !== undefined) {
    contents.InstanceType = output["instanceType"];
  }
  if (output["maxTermDurationInDays"] !== undefined) {
    contents.MaxTermDurationInDays = parseInt(output["maxTermDurationInDays"]);
  }
  if (output["minTermDurationInDays"] !== undefined) {
    contents.MinTermDurationInDays = parseInt(output["minTermDurationInDays"]);
  }
  if (output["networkPlatform"] !== undefined) {
    contents.NetworkPlatform = output["networkPlatform"];
  }
  if (output["platform"] !== undefined) {
    contents.Platform = output["platform"];
  }
  if (output["purchaseToken"] !== undefined) {
    contents.PurchaseToken = output["purchaseToken"];
  }
  if (output["recurrence"] !== undefined) {
    contents.Recurrence = deserializeAws_ec2ScheduledInstanceRecurrence(
      output["recurrence"],
      context
    );
  }
  if (output["slotDurationInHours"] !== undefined) {
    contents.SlotDurationInHours = parseInt(output["slotDurationInHours"]);
  }
  if (output["totalScheduledInstanceHours"] !== undefined) {
    contents.TotalScheduledInstanceHours = parseInt(
      output["totalScheduledInstanceHours"]
    );
  }
  return contents;
};

const deserializeAws_ec2ScheduledInstanceAvailabilitySet = (
  output: any,
  context: __SerdeContext
): ScheduledInstanceAvailability[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2ScheduledInstanceAvailability(entry, context)
  );
};

const deserializeAws_ec2ScheduledInstanceRecurrence = (
  output: any,
  context: __SerdeContext
): ScheduledInstanceRecurrence => {
  let contents: any = {
    __type: "ScheduledInstanceRecurrence",
    Frequency: undefined,
    Interval: undefined,
    OccurrenceDaySet: undefined,
    OccurrenceRelativeToEnd: undefined,
    OccurrenceUnit: undefined
  };
  if (output["frequency"] !== undefined) {
    contents.Frequency = output["frequency"];
  }
  if (output["interval"] !== undefined) {
    contents.Interval = parseInt(output["interval"]);
  }
  if (output.occurrenceDaySet === "") {
    contents.OccurrenceDaySet = [];
  }
  if (
    output["occurrenceDaySet"] !== undefined &&
    output["occurrenceDaySet"]["item"] !== undefined
  ) {
    contents.OccurrenceDaySet = deserializeAws_ec2OccurrenceDaySet(
      __getArrayIfSingleItem(output["occurrenceDaySet"]["item"]),
      context
    );
  }
  if (output["occurrenceRelativeToEnd"] !== undefined) {
    contents.OccurrenceRelativeToEnd =
      output["occurrenceRelativeToEnd"] == "true";
  }
  if (output["occurrenceUnit"] !== undefined) {
    contents.OccurrenceUnit = output["occurrenceUnit"];
  }
  return contents;
};

const deserializeAws_ec2ScheduledInstanceSet = (
  output: any,
  context: __SerdeContext
): ScheduledInstance[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2ScheduledInstance(entry, context)
  );
};

const deserializeAws_ec2SearchLocalGatewayRoutesResult = (
  output: any,
  context: __SerdeContext
): SearchLocalGatewayRoutesResult => {
  let contents: any = {
    __type: "SearchLocalGatewayRoutesResult",
    NextToken: undefined,
    Routes: undefined
  };
  if (output["nextToken"] !== undefined) {
    contents.NextToken = output["nextToken"];
  }
  if (output.routeSet === "") {
    contents.Routes = [];
  }
  if (
    output["routeSet"] !== undefined &&
    output["routeSet"]["item"] !== undefined
  ) {
    contents.Routes = deserializeAws_ec2LocalGatewayRouteList(
      __getArrayIfSingleItem(output["routeSet"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2SearchTransitGatewayMulticastGroupsResult = (
  output: any,
  context: __SerdeContext
): SearchTransitGatewayMulticastGroupsResult => {
  let contents: any = {
    __type: "SearchTransitGatewayMulticastGroupsResult",
    MulticastGroups: undefined,
    NextToken: undefined
  };
  if (output.multicastGroups === "") {
    contents.MulticastGroups = [];
  }
  if (
    output["multicastGroups"] !== undefined &&
    output["multicastGroups"]["item"] !== undefined
  ) {
    contents.MulticastGroups = deserializeAws_ec2TransitGatewayMulticastGroupList(
      __getArrayIfSingleItem(output["multicastGroups"]["item"]),
      context
    );
  }
  if (output["nextToken"] !== undefined) {
    contents.NextToken = output["nextToken"];
  }
  return contents;
};

const deserializeAws_ec2SearchTransitGatewayRoutesResult = (
  output: any,
  context: __SerdeContext
): SearchTransitGatewayRoutesResult => {
  let contents: any = {
    __type: "SearchTransitGatewayRoutesResult",
    AdditionalRoutesAvailable: undefined,
    Routes: undefined
  };
  if (output["additionalRoutesAvailable"] !== undefined) {
    contents.AdditionalRoutesAvailable =
      output["additionalRoutesAvailable"] == "true";
  }
  if (output.routeSet === "") {
    contents.Routes = [];
  }
  if (
    output["routeSet"] !== undefined &&
    output["routeSet"]["item"] !== undefined
  ) {
    contents.Routes = deserializeAws_ec2TransitGatewayRouteList(
      __getArrayIfSingleItem(output["routeSet"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2SecurityGroup = (
  output: any,
  context: __SerdeContext
): SecurityGroup => {
  let contents: any = {
    __type: "SecurityGroup",
    Description: undefined,
    GroupId: undefined,
    GroupName: undefined,
    IpPermissions: undefined,
    IpPermissionsEgress: undefined,
    OwnerId: undefined,
    Tags: undefined,
    VpcId: undefined
  };
  if (output["groupDescription"] !== undefined) {
    contents.Description = output["groupDescription"];
  }
  if (output["groupId"] !== undefined) {
    contents.GroupId = output["groupId"];
  }
  if (output["groupName"] !== undefined) {
    contents.GroupName = output["groupName"];
  }
  if (output.ipPermissions === "") {
    contents.IpPermissions = [];
  }
  if (
    output["ipPermissions"] !== undefined &&
    output["ipPermissions"]["item"] !== undefined
  ) {
    contents.IpPermissions = deserializeAws_ec2IpPermissionList(
      __getArrayIfSingleItem(output["ipPermissions"]["item"]),
      context
    );
  }
  if (output.ipPermissionsEgress === "") {
    contents.IpPermissionsEgress = [];
  }
  if (
    output["ipPermissionsEgress"] !== undefined &&
    output["ipPermissionsEgress"]["item"] !== undefined
  ) {
    contents.IpPermissionsEgress = deserializeAws_ec2IpPermissionList(
      __getArrayIfSingleItem(output["ipPermissionsEgress"]["item"]),
      context
    );
  }
  if (output["ownerId"] !== undefined) {
    contents.OwnerId = output["ownerId"];
  }
  if (output.tagSet === "") {
    contents.Tags = [];
  }
  if (
    output["tagSet"] !== undefined &&
    output["tagSet"]["item"] !== undefined
  ) {
    contents.Tags = deserializeAws_ec2TagList(
      __getArrayIfSingleItem(output["tagSet"]["item"]),
      context
    );
  }
  if (output["vpcId"] !== undefined) {
    contents.VpcId = output["vpcId"];
  }
  return contents;
};

const deserializeAws_ec2SecurityGroupIdentifier = (
  output: any,
  context: __SerdeContext
): SecurityGroupIdentifier => {
  let contents: any = {
    __type: "SecurityGroupIdentifier",
    GroupId: undefined,
    GroupName: undefined
  };
  if (output["groupId"] !== undefined) {
    contents.GroupId = output["groupId"];
  }
  if (output["groupName"] !== undefined) {
    contents.GroupName = output["groupName"];
  }
  return contents;
};

const deserializeAws_ec2SecurityGroupIdStringList = (
  output: any,
  context: __SerdeContext
): string[] => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_ec2SecurityGroupList = (
  output: any,
  context: __SerdeContext
): SecurityGroup[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2SecurityGroup(entry, context)
  );
};

const deserializeAws_ec2SecurityGroupReference = (
  output: any,
  context: __SerdeContext
): SecurityGroupReference => {
  let contents: any = {
    __type: "SecurityGroupReference",
    GroupId: undefined,
    ReferencingVpcId: undefined,
    VpcPeeringConnectionId: undefined
  };
  if (output["groupId"] !== undefined) {
    contents.GroupId = output["groupId"];
  }
  if (output["referencingVpcId"] !== undefined) {
    contents.ReferencingVpcId = output["referencingVpcId"];
  }
  if (output["vpcPeeringConnectionId"] !== undefined) {
    contents.VpcPeeringConnectionId = output["vpcPeeringConnectionId"];
  }
  return contents;
};

const deserializeAws_ec2SecurityGroupReferences = (
  output: any,
  context: __SerdeContext
): SecurityGroupReference[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2SecurityGroupReference(entry, context)
  );
};

const deserializeAws_ec2ServiceConfiguration = (
  output: any,
  context: __SerdeContext
): ServiceConfiguration => {
  let contents: any = {
    __type: "ServiceConfiguration",
    AcceptanceRequired: undefined,
    AvailabilityZones: undefined,
    BaseEndpointDnsNames: undefined,
    ManagesVpcEndpoints: undefined,
    NetworkLoadBalancerArns: undefined,
    PrivateDnsName: undefined,
    PrivateDnsNameConfiguration: undefined,
    ServiceId: undefined,
    ServiceName: undefined,
    ServiceState: undefined,
    ServiceType: undefined,
    Tags: undefined
  };
  if (output["acceptanceRequired"] !== undefined) {
    contents.AcceptanceRequired = output["acceptanceRequired"] == "true";
  }
  if (output.availabilityZoneSet === "") {
    contents.AvailabilityZones = [];
  }
  if (
    output["availabilityZoneSet"] !== undefined &&
    output["availabilityZoneSet"]["item"] !== undefined
  ) {
    contents.AvailabilityZones = deserializeAws_ec2ValueStringList(
      __getArrayIfSingleItem(output["availabilityZoneSet"]["item"]),
      context
    );
  }
  if (output.baseEndpointDnsNameSet === "") {
    contents.BaseEndpointDnsNames = [];
  }
  if (
    output["baseEndpointDnsNameSet"] !== undefined &&
    output["baseEndpointDnsNameSet"]["item"] !== undefined
  ) {
    contents.BaseEndpointDnsNames = deserializeAws_ec2ValueStringList(
      __getArrayIfSingleItem(output["baseEndpointDnsNameSet"]["item"]),
      context
    );
  }
  if (output["managesVpcEndpoints"] !== undefined) {
    contents.ManagesVpcEndpoints = output["managesVpcEndpoints"] == "true";
  }
  if (output.networkLoadBalancerArnSet === "") {
    contents.NetworkLoadBalancerArns = [];
  }
  if (
    output["networkLoadBalancerArnSet"] !== undefined &&
    output["networkLoadBalancerArnSet"]["item"] !== undefined
  ) {
    contents.NetworkLoadBalancerArns = deserializeAws_ec2ValueStringList(
      __getArrayIfSingleItem(output["networkLoadBalancerArnSet"]["item"]),
      context
    );
  }
  if (output["privateDnsName"] !== undefined) {
    contents.PrivateDnsName = output["privateDnsName"];
  }
  if (output["privateDnsNameConfiguration"] !== undefined) {
    contents.PrivateDnsNameConfiguration = deserializeAws_ec2PrivateDnsNameConfiguration(
      output["privateDnsNameConfiguration"],
      context
    );
  }
  if (output["serviceId"] !== undefined) {
    contents.ServiceId = output["serviceId"];
  }
  if (output["serviceName"] !== undefined) {
    contents.ServiceName = output["serviceName"];
  }
  if (output["serviceState"] !== undefined) {
    contents.ServiceState = output["serviceState"];
  }
  if (output.serviceType === "") {
    contents.ServiceType = [];
  }
  if (
    output["serviceType"] !== undefined &&
    output["serviceType"]["item"] !== undefined
  ) {
    contents.ServiceType = deserializeAws_ec2ServiceTypeDetailSet(
      __getArrayIfSingleItem(output["serviceType"]["item"]),
      context
    );
  }
  if (output.tagSet === "") {
    contents.Tags = [];
  }
  if (
    output["tagSet"] !== undefined &&
    output["tagSet"]["item"] !== undefined
  ) {
    contents.Tags = deserializeAws_ec2TagList(
      __getArrayIfSingleItem(output["tagSet"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2ServiceConfigurationSet = (
  output: any,
  context: __SerdeContext
): ServiceConfiguration[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2ServiceConfiguration(entry, context)
  );
};

const deserializeAws_ec2ServiceDetail = (
  output: any,
  context: __SerdeContext
): ServiceDetail => {
  let contents: any = {
    __type: "ServiceDetail",
    AcceptanceRequired: undefined,
    AvailabilityZones: undefined,
    BaseEndpointDnsNames: undefined,
    ManagesVpcEndpoints: undefined,
    Owner: undefined,
    PrivateDnsName: undefined,
    PrivateDnsNameVerificationState: undefined,
    ServiceId: undefined,
    ServiceName: undefined,
    ServiceType: undefined,
    Tags: undefined,
    VpcEndpointPolicySupported: undefined
  };
  if (output["acceptanceRequired"] !== undefined) {
    contents.AcceptanceRequired = output["acceptanceRequired"] == "true";
  }
  if (output.availabilityZoneSet === "") {
    contents.AvailabilityZones = [];
  }
  if (
    output["availabilityZoneSet"] !== undefined &&
    output["availabilityZoneSet"]["item"] !== undefined
  ) {
    contents.AvailabilityZones = deserializeAws_ec2ValueStringList(
      __getArrayIfSingleItem(output["availabilityZoneSet"]["item"]),
      context
    );
  }
  if (output.baseEndpointDnsNameSet === "") {
    contents.BaseEndpointDnsNames = [];
  }
  if (
    output["baseEndpointDnsNameSet"] !== undefined &&
    output["baseEndpointDnsNameSet"]["item"] !== undefined
  ) {
    contents.BaseEndpointDnsNames = deserializeAws_ec2ValueStringList(
      __getArrayIfSingleItem(output["baseEndpointDnsNameSet"]["item"]),
      context
    );
  }
  if (output["managesVpcEndpoints"] !== undefined) {
    contents.ManagesVpcEndpoints = output["managesVpcEndpoints"] == "true";
  }
  if (output["owner"] !== undefined) {
    contents.Owner = output["owner"];
  }
  if (output["privateDnsName"] !== undefined) {
    contents.PrivateDnsName = output["privateDnsName"];
  }
  if (output["privateDnsNameVerificationState"] !== undefined) {
    contents.PrivateDnsNameVerificationState =
      output["privateDnsNameVerificationState"];
  }
  if (output["serviceId"] !== undefined) {
    contents.ServiceId = output["serviceId"];
  }
  if (output["serviceName"] !== undefined) {
    contents.ServiceName = output["serviceName"];
  }
  if (output.serviceType === "") {
    contents.ServiceType = [];
  }
  if (
    output["serviceType"] !== undefined &&
    output["serviceType"]["item"] !== undefined
  ) {
    contents.ServiceType = deserializeAws_ec2ServiceTypeDetailSet(
      __getArrayIfSingleItem(output["serviceType"]["item"]),
      context
    );
  }
  if (output.tagSet === "") {
    contents.Tags = [];
  }
  if (
    output["tagSet"] !== undefined &&
    output["tagSet"]["item"] !== undefined
  ) {
    contents.Tags = deserializeAws_ec2TagList(
      __getArrayIfSingleItem(output["tagSet"]["item"]),
      context
    );
  }
  if (output["vpcEndpointPolicySupported"] !== undefined) {
    contents.VpcEndpointPolicySupported =
      output["vpcEndpointPolicySupported"] == "true";
  }
  return contents;
};

const deserializeAws_ec2ServiceDetailSet = (
  output: any,
  context: __SerdeContext
): ServiceDetail[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2ServiceDetail(entry, context)
  );
};

const deserializeAws_ec2ServiceTypeDetail = (
  output: any,
  context: __SerdeContext
): ServiceTypeDetail => {
  let contents: any = {
    __type: "ServiceTypeDetail",
    ServiceType: undefined
  };
  if (output["serviceType"] !== undefined) {
    contents.ServiceType = output["serviceType"];
  }
  return contents;
};

const deserializeAws_ec2ServiceTypeDetailSet = (
  output: any,
  context: __SerdeContext
): ServiceTypeDetail[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2ServiceTypeDetail(entry, context)
  );
};

const deserializeAws_ec2Snapshot = (
  output: any,
  context: __SerdeContext
): Snapshot => {
  let contents: any = {
    __type: "Snapshot",
    DataEncryptionKeyId: undefined,
    Description: undefined,
    Encrypted: undefined,
    KmsKeyId: undefined,
    OwnerAlias: undefined,
    OwnerId: undefined,
    Progress: undefined,
    SnapshotId: undefined,
    StartTime: undefined,
    State: undefined,
    StateMessage: undefined,
    Tags: undefined,
    VolumeId: undefined,
    VolumeSize: undefined
  };
  if (output["dataEncryptionKeyId"] !== undefined) {
    contents.DataEncryptionKeyId = output["dataEncryptionKeyId"];
  }
  if (output["description"] !== undefined) {
    contents.Description = output["description"];
  }
  if (output["encrypted"] !== undefined) {
    contents.Encrypted = output["encrypted"] == "true";
  }
  if (output["kmsKeyId"] !== undefined) {
    contents.KmsKeyId = output["kmsKeyId"];
  }
  if (output["ownerAlias"] !== undefined) {
    contents.OwnerAlias = output["ownerAlias"];
  }
  if (output["ownerId"] !== undefined) {
    contents.OwnerId = output["ownerId"];
  }
  if (output["progress"] !== undefined) {
    contents.Progress = output["progress"];
  }
  if (output["snapshotId"] !== undefined) {
    contents.SnapshotId = output["snapshotId"];
  }
  if (output["startTime"] !== undefined) {
    contents.StartTime = new Date(output["startTime"]);
  }
  if (output["status"] !== undefined) {
    contents.State = output["status"];
  }
  if (output["statusMessage"] !== undefined) {
    contents.StateMessage = output["statusMessage"];
  }
  if (output.tagSet === "") {
    contents.Tags = [];
  }
  if (
    output["tagSet"] !== undefined &&
    output["tagSet"]["item"] !== undefined
  ) {
    contents.Tags = deserializeAws_ec2TagList(
      __getArrayIfSingleItem(output["tagSet"]["item"]),
      context
    );
  }
  if (output["volumeId"] !== undefined) {
    contents.VolumeId = output["volumeId"];
  }
  if (output["volumeSize"] !== undefined) {
    contents.VolumeSize = parseInt(output["volumeSize"]);
  }
  return contents;
};

const deserializeAws_ec2SnapshotDetail = (
  output: any,
  context: __SerdeContext
): SnapshotDetail => {
  let contents: any = {
    __type: "SnapshotDetail",
    Description: undefined,
    DeviceName: undefined,
    DiskImageSize: undefined,
    Format: undefined,
    Progress: undefined,
    SnapshotId: undefined,
    Status: undefined,
    StatusMessage: undefined,
    Url: undefined,
    UserBucket: undefined
  };
  if (output["description"] !== undefined) {
    contents.Description = output["description"];
  }
  if (output["deviceName"] !== undefined) {
    contents.DeviceName = output["deviceName"];
  }
  if (output["diskImageSize"] !== undefined) {
    contents.DiskImageSize = parseFloat(output["diskImageSize"]);
  }
  if (output["format"] !== undefined) {
    contents.Format = output["format"];
  }
  if (output["progress"] !== undefined) {
    contents.Progress = output["progress"];
  }
  if (output["snapshotId"] !== undefined) {
    contents.SnapshotId = output["snapshotId"];
  }
  if (output["status"] !== undefined) {
    contents.Status = output["status"];
  }
  if (output["statusMessage"] !== undefined) {
    contents.StatusMessage = output["statusMessage"];
  }
  if (output["url"] !== undefined) {
    contents.Url = output["url"];
  }
  if (output["userBucket"] !== undefined) {
    contents.UserBucket = deserializeAws_ec2UserBucketDetails(
      output["userBucket"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2SnapshotDetailList = (
  output: any,
  context: __SerdeContext
): SnapshotDetail[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2SnapshotDetail(entry, context)
  );
};

const deserializeAws_ec2SnapshotInfo = (
  output: any,
  context: __SerdeContext
): SnapshotInfo => {
  let contents: any = {
    __type: "SnapshotInfo",
    Description: undefined,
    Encrypted: undefined,
    OwnerId: undefined,
    Progress: undefined,
    SnapshotId: undefined,
    StartTime: undefined,
    State: undefined,
    Tags: undefined,
    VolumeId: undefined,
    VolumeSize: undefined
  };
  if (output["description"] !== undefined) {
    contents.Description = output["description"];
  }
  if (output["encrypted"] !== undefined) {
    contents.Encrypted = output["encrypted"] == "true";
  }
  if (output["ownerId"] !== undefined) {
    contents.OwnerId = output["ownerId"];
  }
  if (output["progress"] !== undefined) {
    contents.Progress = output["progress"];
  }
  if (output["snapshotId"] !== undefined) {
    contents.SnapshotId = output["snapshotId"];
  }
  if (output["startTime"] !== undefined) {
    contents.StartTime = new Date(output["startTime"]);
  }
  if (output["state"] !== undefined) {
    contents.State = output["state"];
  }
  if (output.tagSet === "") {
    contents.Tags = [];
  }
  if (
    output["tagSet"] !== undefined &&
    output["tagSet"]["item"] !== undefined
  ) {
    contents.Tags = deserializeAws_ec2TagList(
      __getArrayIfSingleItem(output["tagSet"]["item"]),
      context
    );
  }
  if (output["volumeId"] !== undefined) {
    contents.VolumeId = output["volumeId"];
  }
  if (output["volumeSize"] !== undefined) {
    contents.VolumeSize = parseInt(output["volumeSize"]);
  }
  return contents;
};

const deserializeAws_ec2SnapshotList = (
  output: any,
  context: __SerdeContext
): Snapshot[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2Snapshot(entry, context)
  );
};

const deserializeAws_ec2SnapshotSet = (
  output: any,
  context: __SerdeContext
): SnapshotInfo[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2SnapshotInfo(entry, context)
  );
};

const deserializeAws_ec2SnapshotTaskDetail = (
  output: any,
  context: __SerdeContext
): SnapshotTaskDetail => {
  let contents: any = {
    __type: "SnapshotTaskDetail",
    Description: undefined,
    DiskImageSize: undefined,
    Encrypted: undefined,
    Format: undefined,
    KmsKeyId: undefined,
    Progress: undefined,
    SnapshotId: undefined,
    Status: undefined,
    StatusMessage: undefined,
    Url: undefined,
    UserBucket: undefined
  };
  if (output["description"] !== undefined) {
    contents.Description = output["description"];
  }
  if (output["diskImageSize"] !== undefined) {
    contents.DiskImageSize = parseFloat(output["diskImageSize"]);
  }
  if (output["encrypted"] !== undefined) {
    contents.Encrypted = output["encrypted"] == "true";
  }
  if (output["format"] !== undefined) {
    contents.Format = output["format"];
  }
  if (output["kmsKeyId"] !== undefined) {
    contents.KmsKeyId = output["kmsKeyId"];
  }
  if (output["progress"] !== undefined) {
    contents.Progress = output["progress"];
  }
  if (output["snapshotId"] !== undefined) {
    contents.SnapshotId = output["snapshotId"];
  }
  if (output["status"] !== undefined) {
    contents.Status = output["status"];
  }
  if (output["statusMessage"] !== undefined) {
    contents.StatusMessage = output["statusMessage"];
  }
  if (output["url"] !== undefined) {
    contents.Url = output["url"];
  }
  if (output["userBucket"] !== undefined) {
    contents.UserBucket = deserializeAws_ec2UserBucketDetails(
      output["userBucket"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2SpotDatafeedSubscription = (
  output: any,
  context: __SerdeContext
): SpotDatafeedSubscription => {
  let contents: any = {
    __type: "SpotDatafeedSubscription",
    Bucket: undefined,
    Fault: undefined,
    OwnerId: undefined,
    Prefix: undefined,
    State: undefined
  };
  if (output["bucket"] !== undefined) {
    contents.Bucket = output["bucket"];
  }
  if (output["fault"] !== undefined) {
    contents.Fault = deserializeAws_ec2SpotInstanceStateFault(
      output["fault"],
      context
    );
  }
  if (output["ownerId"] !== undefined) {
    contents.OwnerId = output["ownerId"];
  }
  if (output["prefix"] !== undefined) {
    contents.Prefix = output["prefix"];
  }
  if (output["state"] !== undefined) {
    contents.State = output["state"];
  }
  return contents;
};

const deserializeAws_ec2SpotFleetLaunchSpecification = (
  output: any,
  context: __SerdeContext
): SpotFleetLaunchSpecification => {
  let contents: any = {
    __type: "SpotFleetLaunchSpecification",
    AddressingType: undefined,
    BlockDeviceMappings: undefined,
    EbsOptimized: undefined,
    IamInstanceProfile: undefined,
    ImageId: undefined,
    InstanceType: undefined,
    KernelId: undefined,
    KeyName: undefined,
    Monitoring: undefined,
    NetworkInterfaces: undefined,
    Placement: undefined,
    RamdiskId: undefined,
    SecurityGroups: undefined,
    SpotPrice: undefined,
    SubnetId: undefined,
    TagSpecifications: undefined,
    UserData: undefined,
    WeightedCapacity: undefined
  };
  if (output["addressingType"] !== undefined) {
    contents.AddressingType = output["addressingType"];
  }
  if (output.blockDeviceMapping === "") {
    contents.BlockDeviceMappings = [];
  }
  if (
    output["blockDeviceMapping"] !== undefined &&
    output["blockDeviceMapping"]["item"] !== undefined
  ) {
    contents.BlockDeviceMappings = deserializeAws_ec2BlockDeviceMappingList(
      __getArrayIfSingleItem(output["blockDeviceMapping"]["item"]),
      context
    );
  }
  if (output["ebsOptimized"] !== undefined) {
    contents.EbsOptimized = output["ebsOptimized"] == "true";
  }
  if (output["iamInstanceProfile"] !== undefined) {
    contents.IamInstanceProfile = deserializeAws_ec2IamInstanceProfileSpecification(
      output["iamInstanceProfile"],
      context
    );
  }
  if (output["imageId"] !== undefined) {
    contents.ImageId = output["imageId"];
  }
  if (output["instanceType"] !== undefined) {
    contents.InstanceType = output["instanceType"];
  }
  if (output["kernelId"] !== undefined) {
    contents.KernelId = output["kernelId"];
  }
  if (output["keyName"] !== undefined) {
    contents.KeyName = output["keyName"];
  }
  if (output["monitoring"] !== undefined) {
    contents.Monitoring = deserializeAws_ec2SpotFleetMonitoring(
      output["monitoring"],
      context
    );
  }
  if (output.networkInterfaceSet === "") {
    contents.NetworkInterfaces = [];
  }
  if (
    output["networkInterfaceSet"] !== undefined &&
    output["networkInterfaceSet"]["item"] !== undefined
  ) {
    contents.NetworkInterfaces = deserializeAws_ec2InstanceNetworkInterfaceSpecificationList(
      __getArrayIfSingleItem(output["networkInterfaceSet"]["item"]),
      context
    );
  }
  if (output["placement"] !== undefined) {
    contents.Placement = deserializeAws_ec2SpotPlacement(
      output["placement"],
      context
    );
  }
  if (output["ramdiskId"] !== undefined) {
    contents.RamdiskId = output["ramdiskId"];
  }
  if (output.groupSet === "") {
    contents.SecurityGroups = [];
  }
  if (
    output["groupSet"] !== undefined &&
    output["groupSet"]["item"] !== undefined
  ) {
    contents.SecurityGroups = deserializeAws_ec2GroupIdentifierList(
      __getArrayIfSingleItem(output["groupSet"]["item"]),
      context
    );
  }
  if (output["spotPrice"] !== undefined) {
    contents.SpotPrice = output["spotPrice"];
  }
  if (output["subnetId"] !== undefined) {
    contents.SubnetId = output["subnetId"];
  }
  if (output.tagSpecificationSet === "") {
    contents.TagSpecifications = [];
  }
  if (
    output["tagSpecificationSet"] !== undefined &&
    output["tagSpecificationSet"]["item"] !== undefined
  ) {
    contents.TagSpecifications = deserializeAws_ec2SpotFleetTagSpecificationList(
      __getArrayIfSingleItem(output["tagSpecificationSet"]["item"]),
      context
    );
  }
  if (output["userData"] !== undefined) {
    contents.UserData = output["userData"];
  }
  if (output["weightedCapacity"] !== undefined) {
    contents.WeightedCapacity = parseFloat(output["weightedCapacity"]);
  }
  return contents;
};

const deserializeAws_ec2SpotFleetMonitoring = (
  output: any,
  context: __SerdeContext
): SpotFleetMonitoring => {
  let contents: any = {
    __type: "SpotFleetMonitoring",
    Enabled: undefined
  };
  if (output["enabled"] !== undefined) {
    contents.Enabled = output["enabled"] == "true";
  }
  return contents;
};

const deserializeAws_ec2SpotFleetRequestConfig = (
  output: any,
  context: __SerdeContext
): SpotFleetRequestConfig => {
  let contents: any = {
    __type: "SpotFleetRequestConfig",
    ActivityStatus: undefined,
    CreateTime: undefined,
    SpotFleetRequestConfig: undefined,
    SpotFleetRequestId: undefined,
    SpotFleetRequestState: undefined
  };
  if (output["activityStatus"] !== undefined) {
    contents.ActivityStatus = output["activityStatus"];
  }
  if (output["createTime"] !== undefined) {
    contents.CreateTime = new Date(output["createTime"]);
  }
  if (output["spotFleetRequestConfig"] !== undefined) {
    contents.SpotFleetRequestConfig = deserializeAws_ec2SpotFleetRequestConfigData(
      output["spotFleetRequestConfig"],
      context
    );
  }
  if (output["spotFleetRequestId"] !== undefined) {
    contents.SpotFleetRequestId = output["spotFleetRequestId"];
  }
  if (output["spotFleetRequestState"] !== undefined) {
    contents.SpotFleetRequestState = output["spotFleetRequestState"];
  }
  return contents;
};

const deserializeAws_ec2SpotFleetRequestConfigData = (
  output: any,
  context: __SerdeContext
): SpotFleetRequestConfigData => {
  let contents: any = {
    __type: "SpotFleetRequestConfigData",
    AllocationStrategy: undefined,
    ClientToken: undefined,
    ExcessCapacityTerminationPolicy: undefined,
    FulfilledCapacity: undefined,
    IamFleetRole: undefined,
    InstanceInterruptionBehavior: undefined,
    InstancePoolsToUseCount: undefined,
    LaunchSpecifications: undefined,
    LaunchTemplateConfigs: undefined,
    LoadBalancersConfig: undefined,
    OnDemandAllocationStrategy: undefined,
    OnDemandFulfilledCapacity: undefined,
    OnDemandMaxTotalPrice: undefined,
    OnDemandTargetCapacity: undefined,
    ReplaceUnhealthyInstances: undefined,
    SpotMaxTotalPrice: undefined,
    SpotPrice: undefined,
    TargetCapacity: undefined,
    TerminateInstancesWithExpiration: undefined,
    Type: undefined,
    ValidFrom: undefined,
    ValidUntil: undefined
  };
  if (output["allocationStrategy"] !== undefined) {
    contents.AllocationStrategy = output["allocationStrategy"];
  }
  if (output["clientToken"] !== undefined) {
    contents.ClientToken = output["clientToken"];
  }
  if (output["excessCapacityTerminationPolicy"] !== undefined) {
    contents.ExcessCapacityTerminationPolicy =
      output["excessCapacityTerminationPolicy"];
  }
  if (output["fulfilledCapacity"] !== undefined) {
    contents.FulfilledCapacity = parseFloat(output["fulfilledCapacity"]);
  }
  if (output["iamFleetRole"] !== undefined) {
    contents.IamFleetRole = output["iamFleetRole"];
  }
  if (output["instanceInterruptionBehavior"] !== undefined) {
    contents.InstanceInterruptionBehavior =
      output["instanceInterruptionBehavior"];
  }
  if (output["instancePoolsToUseCount"] !== undefined) {
    contents.InstancePoolsToUseCount = parseInt(
      output["instancePoolsToUseCount"]
    );
  }
  if (output.launchSpecifications === "") {
    contents.LaunchSpecifications = [];
  }
  if (
    output["launchSpecifications"] !== undefined &&
    output["launchSpecifications"]["item"] !== undefined
  ) {
    contents.LaunchSpecifications = deserializeAws_ec2LaunchSpecsList(
      __getArrayIfSingleItem(output["launchSpecifications"]["item"]),
      context
    );
  }
  if (output.launchTemplateConfigs === "") {
    contents.LaunchTemplateConfigs = [];
  }
  if (
    output["launchTemplateConfigs"] !== undefined &&
    output["launchTemplateConfigs"]["item"] !== undefined
  ) {
    contents.LaunchTemplateConfigs = deserializeAws_ec2LaunchTemplateConfigList(
      __getArrayIfSingleItem(output["launchTemplateConfigs"]["item"]),
      context
    );
  }
  if (output["loadBalancersConfig"] !== undefined) {
    contents.LoadBalancersConfig = deserializeAws_ec2LoadBalancersConfig(
      output["loadBalancersConfig"],
      context
    );
  }
  if (output["onDemandAllocationStrategy"] !== undefined) {
    contents.OnDemandAllocationStrategy = output["onDemandAllocationStrategy"];
  }
  if (output["onDemandFulfilledCapacity"] !== undefined) {
    contents.OnDemandFulfilledCapacity = parseFloat(
      output["onDemandFulfilledCapacity"]
    );
  }
  if (output["onDemandMaxTotalPrice"] !== undefined) {
    contents.OnDemandMaxTotalPrice = output["onDemandMaxTotalPrice"];
  }
  if (output["onDemandTargetCapacity"] !== undefined) {
    contents.OnDemandTargetCapacity = parseInt(
      output["onDemandTargetCapacity"]
    );
  }
  if (output["replaceUnhealthyInstances"] !== undefined) {
    contents.ReplaceUnhealthyInstances =
      output["replaceUnhealthyInstances"] == "true";
  }
  if (output["spotMaxTotalPrice"] !== undefined) {
    contents.SpotMaxTotalPrice = output["spotMaxTotalPrice"];
  }
  if (output["spotPrice"] !== undefined) {
    contents.SpotPrice = output["spotPrice"];
  }
  if (output["targetCapacity"] !== undefined) {
    contents.TargetCapacity = parseInt(output["targetCapacity"]);
  }
  if (output["terminateInstancesWithExpiration"] !== undefined) {
    contents.TerminateInstancesWithExpiration =
      output["terminateInstancesWithExpiration"] == "true";
  }
  if (output["type"] !== undefined) {
    contents.Type = output["type"];
  }
  if (output["validFrom"] !== undefined) {
    contents.ValidFrom = new Date(output["validFrom"]);
  }
  if (output["validUntil"] !== undefined) {
    contents.ValidUntil = new Date(output["validUntil"]);
  }
  return contents;
};

const deserializeAws_ec2SpotFleetRequestConfigSet = (
  output: any,
  context: __SerdeContext
): SpotFleetRequestConfig[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2SpotFleetRequestConfig(entry, context)
  );
};

const deserializeAws_ec2SpotFleetTagSpecification = (
  output: any,
  context: __SerdeContext
): SpotFleetTagSpecification => {
  let contents: any = {
    __type: "SpotFleetTagSpecification",
    ResourceType: undefined,
    Tags: undefined
  };
  if (output["resourceType"] !== undefined) {
    contents.ResourceType = output["resourceType"];
  }
  if (output.tag === "") {
    contents.Tags = [];
  }
  if (output["tag"] !== undefined && output["tag"]["item"] !== undefined) {
    contents.Tags = deserializeAws_ec2TagList(
      __getArrayIfSingleItem(output["tag"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2SpotFleetTagSpecificationList = (
  output: any,
  context: __SerdeContext
): SpotFleetTagSpecification[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2SpotFleetTagSpecification(entry, context)
  );
};

const deserializeAws_ec2SpotInstanceRequest = (
  output: any,
  context: __SerdeContext
): SpotInstanceRequest => {
  let contents: any = {
    __type: "SpotInstanceRequest",
    ActualBlockHourlyPrice: undefined,
    AvailabilityZoneGroup: undefined,
    BlockDurationMinutes: undefined,
    CreateTime: undefined,
    Fault: undefined,
    InstanceId: undefined,
    InstanceInterruptionBehavior: undefined,
    LaunchGroup: undefined,
    LaunchSpecification: undefined,
    LaunchedAvailabilityZone: undefined,
    ProductDescription: undefined,
    SpotInstanceRequestId: undefined,
    SpotPrice: undefined,
    State: undefined,
    Status: undefined,
    Tags: undefined,
    Type: undefined,
    ValidFrom: undefined,
    ValidUntil: undefined
  };
  if (output["actualBlockHourlyPrice"] !== undefined) {
    contents.ActualBlockHourlyPrice = output["actualBlockHourlyPrice"];
  }
  if (output["availabilityZoneGroup"] !== undefined) {
    contents.AvailabilityZoneGroup = output["availabilityZoneGroup"];
  }
  if (output["blockDurationMinutes"] !== undefined) {
    contents.BlockDurationMinutes = parseInt(output["blockDurationMinutes"]);
  }
  if (output["createTime"] !== undefined) {
    contents.CreateTime = new Date(output["createTime"]);
  }
  if (output["fault"] !== undefined) {
    contents.Fault = deserializeAws_ec2SpotInstanceStateFault(
      output["fault"],
      context
    );
  }
  if (output["instanceId"] !== undefined) {
    contents.InstanceId = output["instanceId"];
  }
  if (output["instanceInterruptionBehavior"] !== undefined) {
    contents.InstanceInterruptionBehavior =
      output["instanceInterruptionBehavior"];
  }
  if (output["launchGroup"] !== undefined) {
    contents.LaunchGroup = output["launchGroup"];
  }
  if (output["launchSpecification"] !== undefined) {
    contents.LaunchSpecification = deserializeAws_ec2LaunchSpecification(
      output["launchSpecification"],
      context
    );
  }
  if (output["launchedAvailabilityZone"] !== undefined) {
    contents.LaunchedAvailabilityZone = output["launchedAvailabilityZone"];
  }
  if (output["productDescription"] !== undefined) {
    contents.ProductDescription = output["productDescription"];
  }
  if (output["spotInstanceRequestId"] !== undefined) {
    contents.SpotInstanceRequestId = output["spotInstanceRequestId"];
  }
  if (output["spotPrice"] !== undefined) {
    contents.SpotPrice = output["spotPrice"];
  }
  if (output["state"] !== undefined) {
    contents.State = output["state"];
  }
  if (output["status"] !== undefined) {
    contents.Status = deserializeAws_ec2SpotInstanceStatus(
      output["status"],
      context
    );
  }
  if (output.tagSet === "") {
    contents.Tags = [];
  }
  if (
    output["tagSet"] !== undefined &&
    output["tagSet"]["item"] !== undefined
  ) {
    contents.Tags = deserializeAws_ec2TagList(
      __getArrayIfSingleItem(output["tagSet"]["item"]),
      context
    );
  }
  if (output["type"] !== undefined) {
    contents.Type = output["type"];
  }
  if (output["validFrom"] !== undefined) {
    contents.ValidFrom = new Date(output["validFrom"]);
  }
  if (output["validUntil"] !== undefined) {
    contents.ValidUntil = new Date(output["validUntil"]);
  }
  return contents;
};

const deserializeAws_ec2SpotInstanceRequestList = (
  output: any,
  context: __SerdeContext
): SpotInstanceRequest[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2SpotInstanceRequest(entry, context)
  );
};

const deserializeAws_ec2SpotInstanceStateFault = (
  output: any,
  context: __SerdeContext
): SpotInstanceStateFault => {
  let contents: any = {
    __type: "SpotInstanceStateFault",
    Code: undefined,
    Message: undefined
  };
  if (output["code"] !== undefined) {
    contents.Code = output["code"];
  }
  if (output["message"] !== undefined) {
    contents.Message = output["message"];
  }
  return contents;
};

const deserializeAws_ec2SpotInstanceStatus = (
  output: any,
  context: __SerdeContext
): SpotInstanceStatus => {
  let contents: any = {
    __type: "SpotInstanceStatus",
    Code: undefined,
    Message: undefined,
    UpdateTime: undefined
  };
  if (output["code"] !== undefined) {
    contents.Code = output["code"];
  }
  if (output["message"] !== undefined) {
    contents.Message = output["message"];
  }
  if (output["updateTime"] !== undefined) {
    contents.UpdateTime = new Date(output["updateTime"]);
  }
  return contents;
};

const deserializeAws_ec2SpotOptions = (
  output: any,
  context: __SerdeContext
): SpotOptions => {
  let contents: any = {
    __type: "SpotOptions",
    AllocationStrategy: undefined,
    InstanceInterruptionBehavior: undefined,
    InstancePoolsToUseCount: undefined,
    MaxTotalPrice: undefined,
    MinTargetCapacity: undefined,
    SingleAvailabilityZone: undefined,
    SingleInstanceType: undefined
  };
  if (output["allocationStrategy"] !== undefined) {
    contents.AllocationStrategy = output["allocationStrategy"];
  }
  if (output["instanceInterruptionBehavior"] !== undefined) {
    contents.InstanceInterruptionBehavior =
      output["instanceInterruptionBehavior"];
  }
  if (output["instancePoolsToUseCount"] !== undefined) {
    contents.InstancePoolsToUseCount = parseInt(
      output["instancePoolsToUseCount"]
    );
  }
  if (output["maxTotalPrice"] !== undefined) {
    contents.MaxTotalPrice = output["maxTotalPrice"];
  }
  if (output["minTargetCapacity"] !== undefined) {
    contents.MinTargetCapacity = parseInt(output["minTargetCapacity"]);
  }
  if (output["singleAvailabilityZone"] !== undefined) {
    contents.SingleAvailabilityZone =
      output["singleAvailabilityZone"] == "true";
  }
  if (output["singleInstanceType"] !== undefined) {
    contents.SingleInstanceType = output["singleInstanceType"] == "true";
  }
  return contents;
};

const deserializeAws_ec2SpotPlacement = (
  output: any,
  context: __SerdeContext
): SpotPlacement => {
  let contents: any = {
    __type: "SpotPlacement",
    AvailabilityZone: undefined,
    GroupName: undefined,
    Tenancy: undefined
  };
  if (output["availabilityZone"] !== undefined) {
    contents.AvailabilityZone = output["availabilityZone"];
  }
  if (output["groupName"] !== undefined) {
    contents.GroupName = output["groupName"];
  }
  if (output["tenancy"] !== undefined) {
    contents.Tenancy = output["tenancy"];
  }
  return contents;
};

const deserializeAws_ec2SpotPrice = (
  output: any,
  context: __SerdeContext
): SpotPrice => {
  let contents: any = {
    __type: "SpotPrice",
    AvailabilityZone: undefined,
    InstanceType: undefined,
    ProductDescription: undefined,
    SpotPrice: undefined,
    Timestamp: undefined
  };
  if (output["availabilityZone"] !== undefined) {
    contents.AvailabilityZone = output["availabilityZone"];
  }
  if (output["instanceType"] !== undefined) {
    contents.InstanceType = output["instanceType"];
  }
  if (output["productDescription"] !== undefined) {
    contents.ProductDescription = output["productDescription"];
  }
  if (output["spotPrice"] !== undefined) {
    contents.SpotPrice = output["spotPrice"];
  }
  if (output["timestamp"] !== undefined) {
    contents.Timestamp = new Date(output["timestamp"]);
  }
  return contents;
};

const deserializeAws_ec2SpotPriceHistoryList = (
  output: any,
  context: __SerdeContext
): SpotPrice[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2SpotPrice(entry, context)
  );
};

const deserializeAws_ec2StaleIpPermission = (
  output: any,
  context: __SerdeContext
): StaleIpPermission => {
  let contents: any = {
    __type: "StaleIpPermission",
    FromPort: undefined,
    IpProtocol: undefined,
    IpRanges: undefined,
    PrefixListIds: undefined,
    ToPort: undefined,
    UserIdGroupPairs: undefined
  };
  if (output["fromPort"] !== undefined) {
    contents.FromPort = parseInt(output["fromPort"]);
  }
  if (output["ipProtocol"] !== undefined) {
    contents.IpProtocol = output["ipProtocol"];
  }
  if (output.ipRanges === "") {
    contents.IpRanges = [];
  }
  if (
    output["ipRanges"] !== undefined &&
    output["ipRanges"]["item"] !== undefined
  ) {
    contents.IpRanges = deserializeAws_ec2IpRanges(
      __getArrayIfSingleItem(output["ipRanges"]["item"]),
      context
    );
  }
  if (output.prefixListIds === "") {
    contents.PrefixListIds = [];
  }
  if (
    output["prefixListIds"] !== undefined &&
    output["prefixListIds"]["item"] !== undefined
  ) {
    contents.PrefixListIds = deserializeAws_ec2PrefixListIdSet(
      __getArrayIfSingleItem(output["prefixListIds"]["item"]),
      context
    );
  }
  if (output["toPort"] !== undefined) {
    contents.ToPort = parseInt(output["toPort"]);
  }
  if (output.groups === "") {
    contents.UserIdGroupPairs = [];
  }
  if (
    output["groups"] !== undefined &&
    output["groups"]["item"] !== undefined
  ) {
    contents.UserIdGroupPairs = deserializeAws_ec2UserIdGroupPairSet(
      __getArrayIfSingleItem(output["groups"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2StaleIpPermissionSet = (
  output: any,
  context: __SerdeContext
): StaleIpPermission[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2StaleIpPermission(entry, context)
  );
};

const deserializeAws_ec2StaleSecurityGroup = (
  output: any,
  context: __SerdeContext
): StaleSecurityGroup => {
  let contents: any = {
    __type: "StaleSecurityGroup",
    Description: undefined,
    GroupId: undefined,
    GroupName: undefined,
    StaleIpPermissions: undefined,
    StaleIpPermissionsEgress: undefined,
    VpcId: undefined
  };
  if (output["description"] !== undefined) {
    contents.Description = output["description"];
  }
  if (output["groupId"] !== undefined) {
    contents.GroupId = output["groupId"];
  }
  if (output["groupName"] !== undefined) {
    contents.GroupName = output["groupName"];
  }
  if (output.staleIpPermissions === "") {
    contents.StaleIpPermissions = [];
  }
  if (
    output["staleIpPermissions"] !== undefined &&
    output["staleIpPermissions"]["item"] !== undefined
  ) {
    contents.StaleIpPermissions = deserializeAws_ec2StaleIpPermissionSet(
      __getArrayIfSingleItem(output["staleIpPermissions"]["item"]),
      context
    );
  }
  if (output.staleIpPermissionsEgress === "") {
    contents.StaleIpPermissionsEgress = [];
  }
  if (
    output["staleIpPermissionsEgress"] !== undefined &&
    output["staleIpPermissionsEgress"]["item"] !== undefined
  ) {
    contents.StaleIpPermissionsEgress = deserializeAws_ec2StaleIpPermissionSet(
      __getArrayIfSingleItem(output["staleIpPermissionsEgress"]["item"]),
      context
    );
  }
  if (output["vpcId"] !== undefined) {
    contents.VpcId = output["vpcId"];
  }
  return contents;
};

const deserializeAws_ec2StaleSecurityGroupSet = (
  output: any,
  context: __SerdeContext
): StaleSecurityGroup[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2StaleSecurityGroup(entry, context)
  );
};

const deserializeAws_ec2StartInstancesResult = (
  output: any,
  context: __SerdeContext
): StartInstancesResult => {
  let contents: any = {
    __type: "StartInstancesResult",
    StartingInstances: undefined
  };
  if (output.instancesSet === "") {
    contents.StartingInstances = [];
  }
  if (
    output["instancesSet"] !== undefined &&
    output["instancesSet"]["item"] !== undefined
  ) {
    contents.StartingInstances = deserializeAws_ec2InstanceStateChangeList(
      __getArrayIfSingleItem(output["instancesSet"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2StartVpcEndpointServicePrivateDnsVerificationResult = (
  output: any,
  context: __SerdeContext
): StartVpcEndpointServicePrivateDnsVerificationResult => {
  let contents: any = {
    __type: "StartVpcEndpointServicePrivateDnsVerificationResult",
    ReturnValue: undefined
  };
  if (output["return"] !== undefined) {
    contents.ReturnValue = output["return"] == "true";
  }
  return contents;
};

const deserializeAws_ec2StateReason = (
  output: any,
  context: __SerdeContext
): StateReason => {
  let contents: any = {
    __type: "StateReason",
    Code: undefined,
    Message: undefined
  };
  if (output["code"] !== undefined) {
    contents.Code = output["code"];
  }
  if (output["message"] !== undefined) {
    contents.Message = output["message"];
  }
  return contents;
};

const deserializeAws_ec2StopInstancesResult = (
  output: any,
  context: __SerdeContext
): StopInstancesResult => {
  let contents: any = {
    __type: "StopInstancesResult",
    StoppingInstances: undefined
  };
  if (output.instancesSet === "") {
    contents.StoppingInstances = [];
  }
  if (
    output["instancesSet"] !== undefined &&
    output["instancesSet"]["item"] !== undefined
  ) {
    contents.StoppingInstances = deserializeAws_ec2InstanceStateChangeList(
      __getArrayIfSingleItem(output["instancesSet"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2Storage = (
  output: any,
  context: __SerdeContext
): Storage => {
  let contents: any = {
    __type: "Storage",
    S3: undefined
  };
  if (output["S3"] !== undefined) {
    contents.S3 = deserializeAws_ec2S3Storage(output["S3"], context);
  }
  return contents;
};

const deserializeAws_ec2Subnet = (
  output: any,
  context: __SerdeContext
): Subnet => {
  let contents: any = {
    __type: "Subnet",
    AssignIpv6AddressOnCreation: undefined,
    AvailabilityZone: undefined,
    AvailabilityZoneId: undefined,
    AvailableIpAddressCount: undefined,
    CidrBlock: undefined,
    DefaultForAz: undefined,
    Ipv6CidrBlockAssociationSet: undefined,
    MapPublicIpOnLaunch: undefined,
    OutpostArn: undefined,
    OwnerId: undefined,
    State: undefined,
    SubnetArn: undefined,
    SubnetId: undefined,
    Tags: undefined,
    VpcId: undefined
  };
  if (output["assignIpv6AddressOnCreation"] !== undefined) {
    contents.AssignIpv6AddressOnCreation =
      output["assignIpv6AddressOnCreation"] == "true";
  }
  if (output["availabilityZone"] !== undefined) {
    contents.AvailabilityZone = output["availabilityZone"];
  }
  if (output["availabilityZoneId"] !== undefined) {
    contents.AvailabilityZoneId = output["availabilityZoneId"];
  }
  if (output["availableIpAddressCount"] !== undefined) {
    contents.AvailableIpAddressCount = parseInt(
      output["availableIpAddressCount"]
    );
  }
  if (output["cidrBlock"] !== undefined) {
    contents.CidrBlock = output["cidrBlock"];
  }
  if (output["defaultForAz"] !== undefined) {
    contents.DefaultForAz = output["defaultForAz"] == "true";
  }
  if (output.ipv6CidrBlockAssociationSet === "") {
    contents.Ipv6CidrBlockAssociationSet = [];
  }
  if (
    output["ipv6CidrBlockAssociationSet"] !== undefined &&
    output["ipv6CidrBlockAssociationSet"]["item"] !== undefined
  ) {
    contents.Ipv6CidrBlockAssociationSet = deserializeAws_ec2SubnetIpv6CidrBlockAssociationSet(
      __getArrayIfSingleItem(output["ipv6CidrBlockAssociationSet"]["item"]),
      context
    );
  }
  if (output["mapPublicIpOnLaunch"] !== undefined) {
    contents.MapPublicIpOnLaunch = output["mapPublicIpOnLaunch"] == "true";
  }
  if (output["outpostArn"] !== undefined) {
    contents.OutpostArn = output["outpostArn"];
  }
  if (output["ownerId"] !== undefined) {
    contents.OwnerId = output["ownerId"];
  }
  if (output["state"] !== undefined) {
    contents.State = output["state"];
  }
  if (output["subnetArn"] !== undefined) {
    contents.SubnetArn = output["subnetArn"];
  }
  if (output["subnetId"] !== undefined) {
    contents.SubnetId = output["subnetId"];
  }
  if (output.tagSet === "") {
    contents.Tags = [];
  }
  if (
    output["tagSet"] !== undefined &&
    output["tagSet"]["item"] !== undefined
  ) {
    contents.Tags = deserializeAws_ec2TagList(
      __getArrayIfSingleItem(output["tagSet"]["item"]),
      context
    );
  }
  if (output["vpcId"] !== undefined) {
    contents.VpcId = output["vpcId"];
  }
  return contents;
};

const deserializeAws_ec2SubnetAssociation = (
  output: any,
  context: __SerdeContext
): SubnetAssociation => {
  let contents: any = {
    __type: "SubnetAssociation",
    State: undefined,
    SubnetId: undefined
  };
  if (output["state"] !== undefined) {
    contents.State = output["state"];
  }
  if (output["subnetId"] !== undefined) {
    contents.SubnetId = output["subnetId"];
  }
  return contents;
};

const deserializeAws_ec2SubnetAssociationList = (
  output: any,
  context: __SerdeContext
): SubnetAssociation[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2SubnetAssociation(entry, context)
  );
};

const deserializeAws_ec2SubnetCidrBlockState = (
  output: any,
  context: __SerdeContext
): SubnetCidrBlockState => {
  let contents: any = {
    __type: "SubnetCidrBlockState",
    State: undefined,
    StatusMessage: undefined
  };
  if (output["state"] !== undefined) {
    contents.State = output["state"];
  }
  if (output["statusMessage"] !== undefined) {
    contents.StatusMessage = output["statusMessage"];
  }
  return contents;
};

const deserializeAws_ec2SubnetIpv6CidrBlockAssociation = (
  output: any,
  context: __SerdeContext
): SubnetIpv6CidrBlockAssociation => {
  let contents: any = {
    __type: "SubnetIpv6CidrBlockAssociation",
    AssociationId: undefined,
    Ipv6CidrBlock: undefined,
    Ipv6CidrBlockState: undefined
  };
  if (output["associationId"] !== undefined) {
    contents.AssociationId = output["associationId"];
  }
  if (output["ipv6CidrBlock"] !== undefined) {
    contents.Ipv6CidrBlock = output["ipv6CidrBlock"];
  }
  if (output["ipv6CidrBlockState"] !== undefined) {
    contents.Ipv6CidrBlockState = deserializeAws_ec2SubnetCidrBlockState(
      output["ipv6CidrBlockState"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2SubnetIpv6CidrBlockAssociationSet = (
  output: any,
  context: __SerdeContext
): SubnetIpv6CidrBlockAssociation[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2SubnetIpv6CidrBlockAssociation(entry, context)
  );
};

const deserializeAws_ec2SubnetList = (
  output: any,
  context: __SerdeContext
): Subnet[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2Subnet(entry, context)
  );
};

const deserializeAws_ec2SuccessfulInstanceCreditSpecificationItem = (
  output: any,
  context: __SerdeContext
): SuccessfulInstanceCreditSpecificationItem => {
  let contents: any = {
    __type: "SuccessfulInstanceCreditSpecificationItem",
    InstanceId: undefined
  };
  if (output["instanceId"] !== undefined) {
    contents.InstanceId = output["instanceId"];
  }
  return contents;
};

const deserializeAws_ec2SuccessfulInstanceCreditSpecificationSet = (
  output: any,
  context: __SerdeContext
): SuccessfulInstanceCreditSpecificationItem[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2SuccessfulInstanceCreditSpecificationItem(entry, context)
  );
};

const deserializeAws_ec2SuccessfulQueuedPurchaseDeletion = (
  output: any,
  context: __SerdeContext
): SuccessfulQueuedPurchaseDeletion => {
  let contents: any = {
    __type: "SuccessfulQueuedPurchaseDeletion",
    ReservedInstancesId: undefined
  };
  if (output["reservedInstancesId"] !== undefined) {
    contents.ReservedInstancesId = output["reservedInstancesId"];
  }
  return contents;
};

const deserializeAws_ec2SuccessfulQueuedPurchaseDeletionSet = (
  output: any,
  context: __SerdeContext
): SuccessfulQueuedPurchaseDeletion[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2SuccessfulQueuedPurchaseDeletion(entry, context)
  );
};

const deserializeAws_ec2Tag = (output: any, context: __SerdeContext): Tag => {
  let contents: any = {
    __type: "Tag",
    Key: undefined,
    Value: undefined
  };
  if (output["key"] !== undefined) {
    contents.Key = output["key"];
  }
  if (output["value"] !== undefined) {
    contents.Value = output["value"];
  }
  return contents;
};

const deserializeAws_ec2TagDescription = (
  output: any,
  context: __SerdeContext
): TagDescription => {
  let contents: any = {
    __type: "TagDescription",
    Key: undefined,
    ResourceId: undefined,
    ResourceType: undefined,
    Value: undefined
  };
  if (output["key"] !== undefined) {
    contents.Key = output["key"];
  }
  if (output["resourceId"] !== undefined) {
    contents.ResourceId = output["resourceId"];
  }
  if (output["resourceType"] !== undefined) {
    contents.ResourceType = output["resourceType"];
  }
  if (output["value"] !== undefined) {
    contents.Value = output["value"];
  }
  return contents;
};

const deserializeAws_ec2TagDescriptionList = (
  output: any,
  context: __SerdeContext
): TagDescription[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2TagDescription(entry, context)
  );
};

const deserializeAws_ec2TagList = (
  output: any,
  context: __SerdeContext
): Tag[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2Tag(entry, context)
  );
};

const deserializeAws_ec2TargetCapacitySpecification = (
  output: any,
  context: __SerdeContext
): TargetCapacitySpecification => {
  let contents: any = {
    __type: "TargetCapacitySpecification",
    DefaultTargetCapacityType: undefined,
    OnDemandTargetCapacity: undefined,
    SpotTargetCapacity: undefined,
    TotalTargetCapacity: undefined
  };
  if (output["defaultTargetCapacityType"] !== undefined) {
    contents.DefaultTargetCapacityType = output["defaultTargetCapacityType"];
  }
  if (output["onDemandTargetCapacity"] !== undefined) {
    contents.OnDemandTargetCapacity = parseInt(
      output["onDemandTargetCapacity"]
    );
  }
  if (output["spotTargetCapacity"] !== undefined) {
    contents.SpotTargetCapacity = parseInt(output["spotTargetCapacity"]);
  }
  if (output["totalTargetCapacity"] !== undefined) {
    contents.TotalTargetCapacity = parseInt(output["totalTargetCapacity"]);
  }
  return contents;
};

const deserializeAws_ec2TargetConfiguration = (
  output: any,
  context: __SerdeContext
): TargetConfiguration => {
  let contents: any = {
    __type: "TargetConfiguration",
    InstanceCount: undefined,
    OfferingId: undefined
  };
  if (output["instanceCount"] !== undefined) {
    contents.InstanceCount = parseInt(output["instanceCount"]);
  }
  if (output["offeringId"] !== undefined) {
    contents.OfferingId = output["offeringId"];
  }
  return contents;
};

const deserializeAws_ec2TargetGroup = (
  output: any,
  context: __SerdeContext
): TargetGroup => {
  let contents: any = {
    __type: "TargetGroup",
    Arn: undefined
  };
  if (output["arn"] !== undefined) {
    contents.Arn = output["arn"];
  }
  return contents;
};

const deserializeAws_ec2TargetGroups = (
  output: any,
  context: __SerdeContext
): TargetGroup[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2TargetGroup(entry, context)
  );
};

const deserializeAws_ec2TargetGroupsConfig = (
  output: any,
  context: __SerdeContext
): TargetGroupsConfig => {
  let contents: any = {
    __type: "TargetGroupsConfig",
    TargetGroups: undefined
  };
  if (output.targetGroups === "") {
    contents.TargetGroups = [];
  }
  if (
    output["targetGroups"] !== undefined &&
    output["targetGroups"]["item"] !== undefined
  ) {
    contents.TargetGroups = deserializeAws_ec2TargetGroups(
      __getArrayIfSingleItem(output["targetGroups"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2TargetNetwork = (
  output: any,
  context: __SerdeContext
): TargetNetwork => {
  let contents: any = {
    __type: "TargetNetwork",
    AssociationId: undefined,
    ClientVpnEndpointId: undefined,
    SecurityGroups: undefined,
    Status: undefined,
    TargetNetworkId: undefined,
    VpcId: undefined
  };
  if (output["associationId"] !== undefined) {
    contents.AssociationId = output["associationId"];
  }
  if (output["clientVpnEndpointId"] !== undefined) {
    contents.ClientVpnEndpointId = output["clientVpnEndpointId"];
  }
  if (output.securityGroups === "") {
    contents.SecurityGroups = [];
  }
  if (
    output["securityGroups"] !== undefined &&
    output["securityGroups"]["item"] !== undefined
  ) {
    contents.SecurityGroups = deserializeAws_ec2ValueStringList(
      __getArrayIfSingleItem(output["securityGroups"]["item"]),
      context
    );
  }
  if (output["status"] !== undefined) {
    contents.Status = deserializeAws_ec2AssociationStatus(
      output["status"],
      context
    );
  }
  if (output["targetNetworkId"] !== undefined) {
    contents.TargetNetworkId = output["targetNetworkId"];
  }
  if (output["vpcId"] !== undefined) {
    contents.VpcId = output["vpcId"];
  }
  return contents;
};

const deserializeAws_ec2TargetNetworkSet = (
  output: any,
  context: __SerdeContext
): TargetNetwork[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2TargetNetwork(entry, context)
  );
};

const deserializeAws_ec2TargetReservationValue = (
  output: any,
  context: __SerdeContext
): TargetReservationValue => {
  let contents: any = {
    __type: "TargetReservationValue",
    ReservationValue: undefined,
    TargetConfiguration: undefined
  };
  if (output["reservationValue"] !== undefined) {
    contents.ReservationValue = deserializeAws_ec2ReservationValue(
      output["reservationValue"],
      context
    );
  }
  if (output["targetConfiguration"] !== undefined) {
    contents.TargetConfiguration = deserializeAws_ec2TargetConfiguration(
      output["targetConfiguration"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2TargetReservationValueSet = (
  output: any,
  context: __SerdeContext
): TargetReservationValue[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2TargetReservationValue(entry, context)
  );
};

const deserializeAws_ec2TerminateClientVpnConnectionsResult = (
  output: any,
  context: __SerdeContext
): TerminateClientVpnConnectionsResult => {
  let contents: any = {
    __type: "TerminateClientVpnConnectionsResult",
    ClientVpnEndpointId: undefined,
    ConnectionStatuses: undefined,
    Username: undefined
  };
  if (output["clientVpnEndpointId"] !== undefined) {
    contents.ClientVpnEndpointId = output["clientVpnEndpointId"];
  }
  if (output.connectionStatuses === "") {
    contents.ConnectionStatuses = [];
  }
  if (
    output["connectionStatuses"] !== undefined &&
    output["connectionStatuses"]["item"] !== undefined
  ) {
    contents.ConnectionStatuses = deserializeAws_ec2TerminateConnectionStatusSet(
      __getArrayIfSingleItem(output["connectionStatuses"]["item"]),
      context
    );
  }
  if (output["username"] !== undefined) {
    contents.Username = output["username"];
  }
  return contents;
};

const deserializeAws_ec2TerminateConnectionStatus = (
  output: any,
  context: __SerdeContext
): TerminateConnectionStatus => {
  let contents: any = {
    __type: "TerminateConnectionStatus",
    ConnectionId: undefined,
    CurrentStatus: undefined,
    PreviousStatus: undefined
  };
  if (output["connectionId"] !== undefined) {
    contents.ConnectionId = output["connectionId"];
  }
  if (output["currentStatus"] !== undefined) {
    contents.CurrentStatus = deserializeAws_ec2ClientVpnConnectionStatus(
      output["currentStatus"],
      context
    );
  }
  if (output["previousStatus"] !== undefined) {
    contents.PreviousStatus = deserializeAws_ec2ClientVpnConnectionStatus(
      output["previousStatus"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2TerminateConnectionStatusSet = (
  output: any,
  context: __SerdeContext
): TerminateConnectionStatus[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2TerminateConnectionStatus(entry, context)
  );
};

const deserializeAws_ec2TerminateInstancesResult = (
  output: any,
  context: __SerdeContext
): TerminateInstancesResult => {
  let contents: any = {
    __type: "TerminateInstancesResult",
    TerminatingInstances: undefined
  };
  if (output.instancesSet === "") {
    contents.TerminatingInstances = [];
  }
  if (
    output["instancesSet"] !== undefined &&
    output["instancesSet"]["item"] !== undefined
  ) {
    contents.TerminatingInstances = deserializeAws_ec2InstanceStateChangeList(
      __getArrayIfSingleItem(output["instancesSet"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2ThreadsPerCoreList = (
  output: any,
  context: __SerdeContext
): number[] => {
  return (output || []).map((entry: any) => parseInt(entry));
};

const deserializeAws_ec2TrafficMirrorFilter = (
  output: any,
  context: __SerdeContext
): TrafficMirrorFilter => {
  let contents: any = {
    __type: "TrafficMirrorFilter",
    Description: undefined,
    EgressFilterRules: undefined,
    IngressFilterRules: undefined,
    NetworkServices: undefined,
    Tags: undefined,
    TrafficMirrorFilterId: undefined
  };
  if (output["description"] !== undefined) {
    contents.Description = output["description"];
  }
  if (output.egressFilterRuleSet === "") {
    contents.EgressFilterRules = [];
  }
  if (
    output["egressFilterRuleSet"] !== undefined &&
    output["egressFilterRuleSet"]["item"] !== undefined
  ) {
    contents.EgressFilterRules = deserializeAws_ec2TrafficMirrorFilterRuleList(
      __getArrayIfSingleItem(output["egressFilterRuleSet"]["item"]),
      context
    );
  }
  if (output.ingressFilterRuleSet === "") {
    contents.IngressFilterRules = [];
  }
  if (
    output["ingressFilterRuleSet"] !== undefined &&
    output["ingressFilterRuleSet"]["item"] !== undefined
  ) {
    contents.IngressFilterRules = deserializeAws_ec2TrafficMirrorFilterRuleList(
      __getArrayIfSingleItem(output["ingressFilterRuleSet"]["item"]),
      context
    );
  }
  if (output.networkServiceSet === "") {
    contents.NetworkServices = [];
  }
  if (
    output["networkServiceSet"] !== undefined &&
    output["networkServiceSet"]["item"] !== undefined
  ) {
    contents.NetworkServices = deserializeAws_ec2TrafficMirrorNetworkServiceList(
      __getArrayIfSingleItem(output["networkServiceSet"]["item"]),
      context
    );
  }
  if (output.tagSet === "") {
    contents.Tags = [];
  }
  if (
    output["tagSet"] !== undefined &&
    output["tagSet"]["item"] !== undefined
  ) {
    contents.Tags = deserializeAws_ec2TagList(
      __getArrayIfSingleItem(output["tagSet"]["item"]),
      context
    );
  }
  if (output["trafficMirrorFilterId"] !== undefined) {
    contents.TrafficMirrorFilterId = output["trafficMirrorFilterId"];
  }
  return contents;
};

const deserializeAws_ec2TrafficMirrorFilterRule = (
  output: any,
  context: __SerdeContext
): TrafficMirrorFilterRule => {
  let contents: any = {
    __type: "TrafficMirrorFilterRule",
    Description: undefined,
    DestinationCidrBlock: undefined,
    DestinationPortRange: undefined,
    Protocol: undefined,
    RuleAction: undefined,
    RuleNumber: undefined,
    SourceCidrBlock: undefined,
    SourcePortRange: undefined,
    TrafficDirection: undefined,
    TrafficMirrorFilterId: undefined,
    TrafficMirrorFilterRuleId: undefined
  };
  if (output["description"] !== undefined) {
    contents.Description = output["description"];
  }
  if (output["destinationCidrBlock"] !== undefined) {
    contents.DestinationCidrBlock = output["destinationCidrBlock"];
  }
  if (output["destinationPortRange"] !== undefined) {
    contents.DestinationPortRange = deserializeAws_ec2TrafficMirrorPortRange(
      output["destinationPortRange"],
      context
    );
  }
  if (output["protocol"] !== undefined) {
    contents.Protocol = parseInt(output["protocol"]);
  }
  if (output["ruleAction"] !== undefined) {
    contents.RuleAction = output["ruleAction"];
  }
  if (output["ruleNumber"] !== undefined) {
    contents.RuleNumber = parseInt(output["ruleNumber"]);
  }
  if (output["sourceCidrBlock"] !== undefined) {
    contents.SourceCidrBlock = output["sourceCidrBlock"];
  }
  if (output["sourcePortRange"] !== undefined) {
    contents.SourcePortRange = deserializeAws_ec2TrafficMirrorPortRange(
      output["sourcePortRange"],
      context
    );
  }
  if (output["trafficDirection"] !== undefined) {
    contents.TrafficDirection = output["trafficDirection"];
  }
  if (output["trafficMirrorFilterId"] !== undefined) {
    contents.TrafficMirrorFilterId = output["trafficMirrorFilterId"];
  }
  if (output["trafficMirrorFilterRuleId"] !== undefined) {
    contents.TrafficMirrorFilterRuleId = output["trafficMirrorFilterRuleId"];
  }
  return contents;
};

const deserializeAws_ec2TrafficMirrorFilterRuleList = (
  output: any,
  context: __SerdeContext
): TrafficMirrorFilterRule[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2TrafficMirrorFilterRule(entry, context)
  );
};

const deserializeAws_ec2TrafficMirrorFilterSet = (
  output: any,
  context: __SerdeContext
): TrafficMirrorFilter[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2TrafficMirrorFilter(entry, context)
  );
};

const deserializeAws_ec2TrafficMirrorNetworkServiceList = (
  output: any,
  context: __SerdeContext
): (TrafficMirrorNetworkService | string)[] => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_ec2TrafficMirrorPortRange = (
  output: any,
  context: __SerdeContext
): TrafficMirrorPortRange => {
  let contents: any = {
    __type: "TrafficMirrorPortRange",
    FromPort: undefined,
    ToPort: undefined
  };
  if (output["fromPort"] !== undefined) {
    contents.FromPort = parseInt(output["fromPort"]);
  }
  if (output["toPort"] !== undefined) {
    contents.ToPort = parseInt(output["toPort"]);
  }
  return contents;
};

const deserializeAws_ec2TrafficMirrorSession = (
  output: any,
  context: __SerdeContext
): TrafficMirrorSession => {
  let contents: any = {
    __type: "TrafficMirrorSession",
    Description: undefined,
    NetworkInterfaceId: undefined,
    OwnerId: undefined,
    PacketLength: undefined,
    SessionNumber: undefined,
    Tags: undefined,
    TrafficMirrorFilterId: undefined,
    TrafficMirrorSessionId: undefined,
    TrafficMirrorTargetId: undefined,
    VirtualNetworkId: undefined
  };
  if (output["description"] !== undefined) {
    contents.Description = output["description"];
  }
  if (output["networkInterfaceId"] !== undefined) {
    contents.NetworkInterfaceId = output["networkInterfaceId"];
  }
  if (output["ownerId"] !== undefined) {
    contents.OwnerId = output["ownerId"];
  }
  if (output["packetLength"] !== undefined) {
    contents.PacketLength = parseInt(output["packetLength"]);
  }
  if (output["sessionNumber"] !== undefined) {
    contents.SessionNumber = parseInt(output["sessionNumber"]);
  }
  if (output.tagSet === "") {
    contents.Tags = [];
  }
  if (
    output["tagSet"] !== undefined &&
    output["tagSet"]["item"] !== undefined
  ) {
    contents.Tags = deserializeAws_ec2TagList(
      __getArrayIfSingleItem(output["tagSet"]["item"]),
      context
    );
  }
  if (output["trafficMirrorFilterId"] !== undefined) {
    contents.TrafficMirrorFilterId = output["trafficMirrorFilterId"];
  }
  if (output["trafficMirrorSessionId"] !== undefined) {
    contents.TrafficMirrorSessionId = output["trafficMirrorSessionId"];
  }
  if (output["trafficMirrorTargetId"] !== undefined) {
    contents.TrafficMirrorTargetId = output["trafficMirrorTargetId"];
  }
  if (output["virtualNetworkId"] !== undefined) {
    contents.VirtualNetworkId = parseInt(output["virtualNetworkId"]);
  }
  return contents;
};

const deserializeAws_ec2TrafficMirrorSessionSet = (
  output: any,
  context: __SerdeContext
): TrafficMirrorSession[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2TrafficMirrorSession(entry, context)
  );
};

const deserializeAws_ec2TrafficMirrorTarget = (
  output: any,
  context: __SerdeContext
): TrafficMirrorTarget => {
  let contents: any = {
    __type: "TrafficMirrorTarget",
    Description: undefined,
    NetworkInterfaceId: undefined,
    NetworkLoadBalancerArn: undefined,
    OwnerId: undefined,
    Tags: undefined,
    TrafficMirrorTargetId: undefined,
    Type: undefined
  };
  if (output["description"] !== undefined) {
    contents.Description = output["description"];
  }
  if (output["networkInterfaceId"] !== undefined) {
    contents.NetworkInterfaceId = output["networkInterfaceId"];
  }
  if (output["networkLoadBalancerArn"] !== undefined) {
    contents.NetworkLoadBalancerArn = output["networkLoadBalancerArn"];
  }
  if (output["ownerId"] !== undefined) {
    contents.OwnerId = output["ownerId"];
  }
  if (output.tagSet === "") {
    contents.Tags = [];
  }
  if (
    output["tagSet"] !== undefined &&
    output["tagSet"]["item"] !== undefined
  ) {
    contents.Tags = deserializeAws_ec2TagList(
      __getArrayIfSingleItem(output["tagSet"]["item"]),
      context
    );
  }
  if (output["trafficMirrorTargetId"] !== undefined) {
    contents.TrafficMirrorTargetId = output["trafficMirrorTargetId"];
  }
  if (output["type"] !== undefined) {
    contents.Type = output["type"];
  }
  return contents;
};

const deserializeAws_ec2TrafficMirrorTargetSet = (
  output: any,
  context: __SerdeContext
): TrafficMirrorTarget[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2TrafficMirrorTarget(entry, context)
  );
};

const deserializeAws_ec2TransitGateway = (
  output: any,
  context: __SerdeContext
): TransitGateway => {
  let contents: any = {
    __type: "TransitGateway",
    CreationTime: undefined,
    Description: undefined,
    Options: undefined,
    OwnerId: undefined,
    State: undefined,
    Tags: undefined,
    TransitGatewayArn: undefined,
    TransitGatewayId: undefined
  };
  if (output["creationTime"] !== undefined) {
    contents.CreationTime = new Date(output["creationTime"]);
  }
  if (output["description"] !== undefined) {
    contents.Description = output["description"];
  }
  if (output["options"] !== undefined) {
    contents.Options = deserializeAws_ec2TransitGatewayOptions(
      output["options"],
      context
    );
  }
  if (output["ownerId"] !== undefined) {
    contents.OwnerId = output["ownerId"];
  }
  if (output["state"] !== undefined) {
    contents.State = output["state"];
  }
  if (output.tagSet === "") {
    contents.Tags = [];
  }
  if (
    output["tagSet"] !== undefined &&
    output["tagSet"]["item"] !== undefined
  ) {
    contents.Tags = deserializeAws_ec2TagList(
      __getArrayIfSingleItem(output["tagSet"]["item"]),
      context
    );
  }
  if (output["transitGatewayArn"] !== undefined) {
    contents.TransitGatewayArn = output["transitGatewayArn"];
  }
  if (output["transitGatewayId"] !== undefined) {
    contents.TransitGatewayId = output["transitGatewayId"];
  }
  return contents;
};

const deserializeAws_ec2TransitGatewayAssociation = (
  output: any,
  context: __SerdeContext
): TransitGatewayAssociation => {
  let contents: any = {
    __type: "TransitGatewayAssociation",
    ResourceId: undefined,
    ResourceType: undefined,
    State: undefined,
    TransitGatewayAttachmentId: undefined,
    TransitGatewayRouteTableId: undefined
  };
  if (output["resourceId"] !== undefined) {
    contents.ResourceId = output["resourceId"];
  }
  if (output["resourceType"] !== undefined) {
    contents.ResourceType = output["resourceType"];
  }
  if (output["state"] !== undefined) {
    contents.State = output["state"];
  }
  if (output["transitGatewayAttachmentId"] !== undefined) {
    contents.TransitGatewayAttachmentId = output["transitGatewayAttachmentId"];
  }
  if (output["transitGatewayRouteTableId"] !== undefined) {
    contents.TransitGatewayRouteTableId = output["transitGatewayRouteTableId"];
  }
  return contents;
};

const deserializeAws_ec2TransitGatewayAttachment = (
  output: any,
  context: __SerdeContext
): TransitGatewayAttachment => {
  let contents: any = {
    __type: "TransitGatewayAttachment",
    Association: undefined,
    CreationTime: undefined,
    ResourceId: undefined,
    ResourceOwnerId: undefined,
    ResourceType: undefined,
    State: undefined,
    Tags: undefined,
    TransitGatewayAttachmentId: undefined,
    TransitGatewayId: undefined,
    TransitGatewayOwnerId: undefined
  };
  if (output["association"] !== undefined) {
    contents.Association = deserializeAws_ec2TransitGatewayAttachmentAssociation(
      output["association"],
      context
    );
  }
  if (output["creationTime"] !== undefined) {
    contents.CreationTime = new Date(output["creationTime"]);
  }
  if (output["resourceId"] !== undefined) {
    contents.ResourceId = output["resourceId"];
  }
  if (output["resourceOwnerId"] !== undefined) {
    contents.ResourceOwnerId = output["resourceOwnerId"];
  }
  if (output["resourceType"] !== undefined) {
    contents.ResourceType = output["resourceType"];
  }
  if (output["state"] !== undefined) {
    contents.State = output["state"];
  }
  if (output.tagSet === "") {
    contents.Tags = [];
  }
  if (
    output["tagSet"] !== undefined &&
    output["tagSet"]["item"] !== undefined
  ) {
    contents.Tags = deserializeAws_ec2TagList(
      __getArrayIfSingleItem(output["tagSet"]["item"]),
      context
    );
  }
  if (output["transitGatewayAttachmentId"] !== undefined) {
    contents.TransitGatewayAttachmentId = output["transitGatewayAttachmentId"];
  }
  if (output["transitGatewayId"] !== undefined) {
    contents.TransitGatewayId = output["transitGatewayId"];
  }
  if (output["transitGatewayOwnerId"] !== undefined) {
    contents.TransitGatewayOwnerId = output["transitGatewayOwnerId"];
  }
  return contents;
};

const deserializeAws_ec2TransitGatewayAttachmentAssociation = (
  output: any,
  context: __SerdeContext
): TransitGatewayAttachmentAssociation => {
  let contents: any = {
    __type: "TransitGatewayAttachmentAssociation",
    State: undefined,
    TransitGatewayRouteTableId: undefined
  };
  if (output["state"] !== undefined) {
    contents.State = output["state"];
  }
  if (output["transitGatewayRouteTableId"] !== undefined) {
    contents.TransitGatewayRouteTableId = output["transitGatewayRouteTableId"];
  }
  return contents;
};

const deserializeAws_ec2TransitGatewayAttachmentList = (
  output: any,
  context: __SerdeContext
): TransitGatewayAttachment[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2TransitGatewayAttachment(entry, context)
  );
};

const deserializeAws_ec2TransitGatewayAttachmentPropagation = (
  output: any,
  context: __SerdeContext
): TransitGatewayAttachmentPropagation => {
  let contents: any = {
    __type: "TransitGatewayAttachmentPropagation",
    State: undefined,
    TransitGatewayRouteTableId: undefined
  };
  if (output["state"] !== undefined) {
    contents.State = output["state"];
  }
  if (output["transitGatewayRouteTableId"] !== undefined) {
    contents.TransitGatewayRouteTableId = output["transitGatewayRouteTableId"];
  }
  return contents;
};

const deserializeAws_ec2TransitGatewayAttachmentPropagationList = (
  output: any,
  context: __SerdeContext
): TransitGatewayAttachmentPropagation[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2TransitGatewayAttachmentPropagation(entry, context)
  );
};

const deserializeAws_ec2TransitGatewayList = (
  output: any,
  context: __SerdeContext
): TransitGateway[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2TransitGateway(entry, context)
  );
};

const deserializeAws_ec2TransitGatewayMulticastDeregisteredGroupMembers = (
  output: any,
  context: __SerdeContext
): TransitGatewayMulticastDeregisteredGroupMembers => {
  let contents: any = {
    __type: "TransitGatewayMulticastDeregisteredGroupMembers",
    DeregisteredNetworkInterfaceIds: undefined,
    GroupIpAddress: undefined,
    TransitGatewayMulticastDomainId: undefined
  };
  if (output.deregisteredNetworkInterfaceIds === "") {
    contents.DeregisteredNetworkInterfaceIds = [];
  }
  if (
    output["deregisteredNetworkInterfaceIds"] !== undefined &&
    output["deregisteredNetworkInterfaceIds"]["item"] !== undefined
  ) {
    contents.DeregisteredNetworkInterfaceIds = deserializeAws_ec2ValueStringList(
      __getArrayIfSingleItem(output["deregisteredNetworkInterfaceIds"]["item"]),
      context
    );
  }
  if (output["groupIpAddress"] !== undefined) {
    contents.GroupIpAddress = output["groupIpAddress"];
  }
  if (output["transitGatewayMulticastDomainId"] !== undefined) {
    contents.TransitGatewayMulticastDomainId =
      output["transitGatewayMulticastDomainId"];
  }
  return contents;
};

const deserializeAws_ec2TransitGatewayMulticastDeregisteredGroupSources = (
  output: any,
  context: __SerdeContext
): TransitGatewayMulticastDeregisteredGroupSources => {
  let contents: any = {
    __type: "TransitGatewayMulticastDeregisteredGroupSources",
    DeregisteredNetworkInterfaceIds: undefined,
    GroupIpAddress: undefined,
    TransitGatewayMulticastDomainId: undefined
  };
  if (output.deregisteredNetworkInterfaceIds === "") {
    contents.DeregisteredNetworkInterfaceIds = [];
  }
  if (
    output["deregisteredNetworkInterfaceIds"] !== undefined &&
    output["deregisteredNetworkInterfaceIds"]["item"] !== undefined
  ) {
    contents.DeregisteredNetworkInterfaceIds = deserializeAws_ec2ValueStringList(
      __getArrayIfSingleItem(output["deregisteredNetworkInterfaceIds"]["item"]),
      context
    );
  }
  if (output["groupIpAddress"] !== undefined) {
    contents.GroupIpAddress = output["groupIpAddress"];
  }
  if (output["transitGatewayMulticastDomainId"] !== undefined) {
    contents.TransitGatewayMulticastDomainId =
      output["transitGatewayMulticastDomainId"];
  }
  return contents;
};

const deserializeAws_ec2TransitGatewayMulticastDomain = (
  output: any,
  context: __SerdeContext
): TransitGatewayMulticastDomain => {
  let contents: any = {
    __type: "TransitGatewayMulticastDomain",
    CreationTime: undefined,
    State: undefined,
    Tags: undefined,
    TransitGatewayId: undefined,
    TransitGatewayMulticastDomainId: undefined
  };
  if (output["creationTime"] !== undefined) {
    contents.CreationTime = new Date(output["creationTime"]);
  }
  if (output["state"] !== undefined) {
    contents.State = output["state"];
  }
  if (output.tagSet === "") {
    contents.Tags = [];
  }
  if (
    output["tagSet"] !== undefined &&
    output["tagSet"]["item"] !== undefined
  ) {
    contents.Tags = deserializeAws_ec2TagList(
      __getArrayIfSingleItem(output["tagSet"]["item"]),
      context
    );
  }
  if (output["transitGatewayId"] !== undefined) {
    contents.TransitGatewayId = output["transitGatewayId"];
  }
  if (output["transitGatewayMulticastDomainId"] !== undefined) {
    contents.TransitGatewayMulticastDomainId =
      output["transitGatewayMulticastDomainId"];
  }
  return contents;
};

const deserializeAws_ec2TransitGatewayMulticastDomainAssociation = (
  output: any,
  context: __SerdeContext
): TransitGatewayMulticastDomainAssociation => {
  let contents: any = {
    __type: "TransitGatewayMulticastDomainAssociation",
    ResourceId: undefined,
    ResourceType: undefined,
    Subnet: undefined,
    TransitGatewayAttachmentId: undefined
  };
  if (output["resourceId"] !== undefined) {
    contents.ResourceId = output["resourceId"];
  }
  if (output["resourceType"] !== undefined) {
    contents.ResourceType = output["resourceType"];
  }
  if (output["subnet"] !== undefined) {
    contents.Subnet = deserializeAws_ec2SubnetAssociation(
      output["subnet"],
      context
    );
  }
  if (output["transitGatewayAttachmentId"] !== undefined) {
    contents.TransitGatewayAttachmentId = output["transitGatewayAttachmentId"];
  }
  return contents;
};

const deserializeAws_ec2TransitGatewayMulticastDomainAssociationList = (
  output: any,
  context: __SerdeContext
): TransitGatewayMulticastDomainAssociation[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2TransitGatewayMulticastDomainAssociation(entry, context)
  );
};

const deserializeAws_ec2TransitGatewayMulticastDomainAssociations = (
  output: any,
  context: __SerdeContext
): TransitGatewayMulticastDomainAssociations => {
  let contents: any = {
    __type: "TransitGatewayMulticastDomainAssociations",
    ResourceId: undefined,
    ResourceType: undefined,
    Subnets: undefined,
    TransitGatewayAttachmentId: undefined,
    TransitGatewayMulticastDomainId: undefined
  };
  if (output["resourceId"] !== undefined) {
    contents.ResourceId = output["resourceId"];
  }
  if (output["resourceType"] !== undefined) {
    contents.ResourceType = output["resourceType"];
  }
  if (output.subnets === "") {
    contents.Subnets = [];
  }
  if (
    output["subnets"] !== undefined &&
    output["subnets"]["item"] !== undefined
  ) {
    contents.Subnets = deserializeAws_ec2SubnetAssociationList(
      __getArrayIfSingleItem(output["subnets"]["item"]),
      context
    );
  }
  if (output["transitGatewayAttachmentId"] !== undefined) {
    contents.TransitGatewayAttachmentId = output["transitGatewayAttachmentId"];
  }
  if (output["transitGatewayMulticastDomainId"] !== undefined) {
    contents.TransitGatewayMulticastDomainId =
      output["transitGatewayMulticastDomainId"];
  }
  return contents;
};

const deserializeAws_ec2TransitGatewayMulticastDomainList = (
  output: any,
  context: __SerdeContext
): TransitGatewayMulticastDomain[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2TransitGatewayMulticastDomain(entry, context)
  );
};

const deserializeAws_ec2TransitGatewayMulticastGroup = (
  output: any,
  context: __SerdeContext
): TransitGatewayMulticastGroup => {
  let contents: any = {
    __type: "TransitGatewayMulticastGroup",
    GroupIpAddress: undefined,
    GroupMember: undefined,
    GroupSource: undefined,
    MemberType: undefined,
    NetworkInterfaceId: undefined,
    ResourceId: undefined,
    ResourceType: undefined,
    SourceType: undefined,
    SubnetId: undefined,
    TransitGatewayAttachmentId: undefined
  };
  if (output["groupIpAddress"] !== undefined) {
    contents.GroupIpAddress = output["groupIpAddress"];
  }
  if (output["groupMember"] !== undefined) {
    contents.GroupMember = output["groupMember"] == "true";
  }
  if (output["groupSource"] !== undefined) {
    contents.GroupSource = output["groupSource"] == "true";
  }
  if (output["memberType"] !== undefined) {
    contents.MemberType = output["memberType"];
  }
  if (output["networkInterfaceId"] !== undefined) {
    contents.NetworkInterfaceId = output["networkInterfaceId"];
  }
  if (output["resourceId"] !== undefined) {
    contents.ResourceId = output["resourceId"];
  }
  if (output["resourceType"] !== undefined) {
    contents.ResourceType = output["resourceType"];
  }
  if (output["sourceType"] !== undefined) {
    contents.SourceType = output["sourceType"];
  }
  if (output["subnetId"] !== undefined) {
    contents.SubnetId = output["subnetId"];
  }
  if (output["transitGatewayAttachmentId"] !== undefined) {
    contents.TransitGatewayAttachmentId = output["transitGatewayAttachmentId"];
  }
  return contents;
};

const deserializeAws_ec2TransitGatewayMulticastGroupList = (
  output: any,
  context: __SerdeContext
): TransitGatewayMulticastGroup[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2TransitGatewayMulticastGroup(entry, context)
  );
};

const deserializeAws_ec2TransitGatewayMulticastRegisteredGroupMembers = (
  output: any,
  context: __SerdeContext
): TransitGatewayMulticastRegisteredGroupMembers => {
  let contents: any = {
    __type: "TransitGatewayMulticastRegisteredGroupMembers",
    GroupIpAddress: undefined,
    RegisteredNetworkInterfaceIds: undefined,
    TransitGatewayMulticastDomainId: undefined
  };
  if (output["groupIpAddress"] !== undefined) {
    contents.GroupIpAddress = output["groupIpAddress"];
  }
  if (output.registeredNetworkInterfaceIds === "") {
    contents.RegisteredNetworkInterfaceIds = [];
  }
  if (
    output["registeredNetworkInterfaceIds"] !== undefined &&
    output["registeredNetworkInterfaceIds"]["item"] !== undefined
  ) {
    contents.RegisteredNetworkInterfaceIds = deserializeAws_ec2ValueStringList(
      __getArrayIfSingleItem(output["registeredNetworkInterfaceIds"]["item"]),
      context
    );
  }
  if (output["transitGatewayMulticastDomainId"] !== undefined) {
    contents.TransitGatewayMulticastDomainId =
      output["transitGatewayMulticastDomainId"];
  }
  return contents;
};

const deserializeAws_ec2TransitGatewayMulticastRegisteredGroupSources = (
  output: any,
  context: __SerdeContext
): TransitGatewayMulticastRegisteredGroupSources => {
  let contents: any = {
    __type: "TransitGatewayMulticastRegisteredGroupSources",
    GroupIpAddress: undefined,
    RegisteredNetworkInterfaceIds: undefined,
    TransitGatewayMulticastDomainId: undefined
  };
  if (output["groupIpAddress"] !== undefined) {
    contents.GroupIpAddress = output["groupIpAddress"];
  }
  if (output.registeredNetworkInterfaceIds === "") {
    contents.RegisteredNetworkInterfaceIds = [];
  }
  if (
    output["registeredNetworkInterfaceIds"] !== undefined &&
    output["registeredNetworkInterfaceIds"]["item"] !== undefined
  ) {
    contents.RegisteredNetworkInterfaceIds = deserializeAws_ec2ValueStringList(
      __getArrayIfSingleItem(output["registeredNetworkInterfaceIds"]["item"]),
      context
    );
  }
  if (output["transitGatewayMulticastDomainId"] !== undefined) {
    contents.TransitGatewayMulticastDomainId =
      output["transitGatewayMulticastDomainId"];
  }
  return contents;
};

const deserializeAws_ec2TransitGatewayOptions = (
  output: any,
  context: __SerdeContext
): TransitGatewayOptions => {
  let contents: any = {
    __type: "TransitGatewayOptions",
    AmazonSideAsn: undefined,
    AssociationDefaultRouteTableId: undefined,
    AutoAcceptSharedAttachments: undefined,
    DefaultRouteTableAssociation: undefined,
    DefaultRouteTablePropagation: undefined,
    DnsSupport: undefined,
    MulticastSupport: undefined,
    PropagationDefaultRouteTableId: undefined,
    VpnEcmpSupport: undefined
  };
  if (output["amazonSideAsn"] !== undefined) {
    contents.AmazonSideAsn = parseInt(output["amazonSideAsn"]);
  }
  if (output["associationDefaultRouteTableId"] !== undefined) {
    contents.AssociationDefaultRouteTableId =
      output["associationDefaultRouteTableId"];
  }
  if (output["autoAcceptSharedAttachments"] !== undefined) {
    contents.AutoAcceptSharedAttachments =
      output["autoAcceptSharedAttachments"];
  }
  if (output["defaultRouteTableAssociation"] !== undefined) {
    contents.DefaultRouteTableAssociation =
      output["defaultRouteTableAssociation"];
  }
  if (output["defaultRouteTablePropagation"] !== undefined) {
    contents.DefaultRouteTablePropagation =
      output["defaultRouteTablePropagation"];
  }
  if (output["dnsSupport"] !== undefined) {
    contents.DnsSupport = output["dnsSupport"];
  }
  if (output["multicastSupport"] !== undefined) {
    contents.MulticastSupport = output["multicastSupport"];
  }
  if (output["propagationDefaultRouteTableId"] !== undefined) {
    contents.PropagationDefaultRouteTableId =
      output["propagationDefaultRouteTableId"];
  }
  if (output["vpnEcmpSupport"] !== undefined) {
    contents.VpnEcmpSupport = output["vpnEcmpSupport"];
  }
  return contents;
};

const deserializeAws_ec2TransitGatewayPeeringAttachment = (
  output: any,
  context: __SerdeContext
): TransitGatewayPeeringAttachment => {
  let contents: any = {
    __type: "TransitGatewayPeeringAttachment",
    AccepterTgwInfo: undefined,
    CreationTime: undefined,
    RequesterTgwInfo: undefined,
    State: undefined,
    Status: undefined,
    Tags: undefined,
    TransitGatewayAttachmentId: undefined
  };
  if (output["accepterTgwInfo"] !== undefined) {
    contents.AccepterTgwInfo = deserializeAws_ec2PeeringTgwInfo(
      output["accepterTgwInfo"],
      context
    );
  }
  if (output["creationTime"] !== undefined) {
    contents.CreationTime = new Date(output["creationTime"]);
  }
  if (output["requesterTgwInfo"] !== undefined) {
    contents.RequesterTgwInfo = deserializeAws_ec2PeeringTgwInfo(
      output["requesterTgwInfo"],
      context
    );
  }
  if (output["state"] !== undefined) {
    contents.State = output["state"];
  }
  if (output["status"] !== undefined) {
    contents.Status = deserializeAws_ec2PeeringAttachmentStatus(
      output["status"],
      context
    );
  }
  if (output.tagSet === "") {
    contents.Tags = [];
  }
  if (
    output["tagSet"] !== undefined &&
    output["tagSet"]["item"] !== undefined
  ) {
    contents.Tags = deserializeAws_ec2TagList(
      __getArrayIfSingleItem(output["tagSet"]["item"]),
      context
    );
  }
  if (output["transitGatewayAttachmentId"] !== undefined) {
    contents.TransitGatewayAttachmentId = output["transitGatewayAttachmentId"];
  }
  return contents;
};

const deserializeAws_ec2TransitGatewayPeeringAttachmentList = (
  output: any,
  context: __SerdeContext
): TransitGatewayPeeringAttachment[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2TransitGatewayPeeringAttachment(entry, context)
  );
};

const deserializeAws_ec2TransitGatewayPropagation = (
  output: any,
  context: __SerdeContext
): TransitGatewayPropagation => {
  let contents: any = {
    __type: "TransitGatewayPropagation",
    ResourceId: undefined,
    ResourceType: undefined,
    State: undefined,
    TransitGatewayAttachmentId: undefined,
    TransitGatewayRouteTableId: undefined
  };
  if (output["resourceId"] !== undefined) {
    contents.ResourceId = output["resourceId"];
  }
  if (output["resourceType"] !== undefined) {
    contents.ResourceType = output["resourceType"];
  }
  if (output["state"] !== undefined) {
    contents.State = output["state"];
  }
  if (output["transitGatewayAttachmentId"] !== undefined) {
    contents.TransitGatewayAttachmentId = output["transitGatewayAttachmentId"];
  }
  if (output["transitGatewayRouteTableId"] !== undefined) {
    contents.TransitGatewayRouteTableId = output["transitGatewayRouteTableId"];
  }
  return contents;
};

const deserializeAws_ec2TransitGatewayRoute = (
  output: any,
  context: __SerdeContext
): TransitGatewayRoute => {
  let contents: any = {
    __type: "TransitGatewayRoute",
    DestinationCidrBlock: undefined,
    State: undefined,
    TransitGatewayAttachments: undefined,
    Type: undefined
  };
  if (output["destinationCidrBlock"] !== undefined) {
    contents.DestinationCidrBlock = output["destinationCidrBlock"];
  }
  if (output["state"] !== undefined) {
    contents.State = output["state"];
  }
  if (output.transitGatewayAttachments === "") {
    contents.TransitGatewayAttachments = [];
  }
  if (
    output["transitGatewayAttachments"] !== undefined &&
    output["transitGatewayAttachments"]["item"] !== undefined
  ) {
    contents.TransitGatewayAttachments = deserializeAws_ec2TransitGatewayRouteAttachmentList(
      __getArrayIfSingleItem(output["transitGatewayAttachments"]["item"]),
      context
    );
  }
  if (output["type"] !== undefined) {
    contents.Type = output["type"];
  }
  return contents;
};

const deserializeAws_ec2TransitGatewayRouteAttachment = (
  output: any,
  context: __SerdeContext
): TransitGatewayRouteAttachment => {
  let contents: any = {
    __type: "TransitGatewayRouteAttachment",
    ResourceId: undefined,
    ResourceType: undefined,
    TransitGatewayAttachmentId: undefined
  };
  if (output["resourceId"] !== undefined) {
    contents.ResourceId = output["resourceId"];
  }
  if (output["resourceType"] !== undefined) {
    contents.ResourceType = output["resourceType"];
  }
  if (output["transitGatewayAttachmentId"] !== undefined) {
    contents.TransitGatewayAttachmentId = output["transitGatewayAttachmentId"];
  }
  return contents;
};

const deserializeAws_ec2TransitGatewayRouteAttachmentList = (
  output: any,
  context: __SerdeContext
): TransitGatewayRouteAttachment[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2TransitGatewayRouteAttachment(entry, context)
  );
};

const deserializeAws_ec2TransitGatewayRouteList = (
  output: any,
  context: __SerdeContext
): TransitGatewayRoute[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2TransitGatewayRoute(entry, context)
  );
};

const deserializeAws_ec2TransitGatewayRouteTable = (
  output: any,
  context: __SerdeContext
): TransitGatewayRouteTable => {
  let contents: any = {
    __type: "TransitGatewayRouteTable",
    CreationTime: undefined,
    DefaultAssociationRouteTable: undefined,
    DefaultPropagationRouteTable: undefined,
    State: undefined,
    Tags: undefined,
    TransitGatewayId: undefined,
    TransitGatewayRouteTableId: undefined
  };
  if (output["creationTime"] !== undefined) {
    contents.CreationTime = new Date(output["creationTime"]);
  }
  if (output["defaultAssociationRouteTable"] !== undefined) {
    contents.DefaultAssociationRouteTable =
      output["defaultAssociationRouteTable"] == "true";
  }
  if (output["defaultPropagationRouteTable"] !== undefined) {
    contents.DefaultPropagationRouteTable =
      output["defaultPropagationRouteTable"] == "true";
  }
  if (output["state"] !== undefined) {
    contents.State = output["state"];
  }
  if (output.tagSet === "") {
    contents.Tags = [];
  }
  if (
    output["tagSet"] !== undefined &&
    output["tagSet"]["item"] !== undefined
  ) {
    contents.Tags = deserializeAws_ec2TagList(
      __getArrayIfSingleItem(output["tagSet"]["item"]),
      context
    );
  }
  if (output["transitGatewayId"] !== undefined) {
    contents.TransitGatewayId = output["transitGatewayId"];
  }
  if (output["transitGatewayRouteTableId"] !== undefined) {
    contents.TransitGatewayRouteTableId = output["transitGatewayRouteTableId"];
  }
  return contents;
};

const deserializeAws_ec2TransitGatewayRouteTableAssociation = (
  output: any,
  context: __SerdeContext
): TransitGatewayRouteTableAssociation => {
  let contents: any = {
    __type: "TransitGatewayRouteTableAssociation",
    ResourceId: undefined,
    ResourceType: undefined,
    State: undefined,
    TransitGatewayAttachmentId: undefined
  };
  if (output["resourceId"] !== undefined) {
    contents.ResourceId = output["resourceId"];
  }
  if (output["resourceType"] !== undefined) {
    contents.ResourceType = output["resourceType"];
  }
  if (output["state"] !== undefined) {
    contents.State = output["state"];
  }
  if (output["transitGatewayAttachmentId"] !== undefined) {
    contents.TransitGatewayAttachmentId = output["transitGatewayAttachmentId"];
  }
  return contents;
};

const deserializeAws_ec2TransitGatewayRouteTableAssociationList = (
  output: any,
  context: __SerdeContext
): TransitGatewayRouteTableAssociation[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2TransitGatewayRouteTableAssociation(entry, context)
  );
};

const deserializeAws_ec2TransitGatewayRouteTableList = (
  output: any,
  context: __SerdeContext
): TransitGatewayRouteTable[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2TransitGatewayRouteTable(entry, context)
  );
};

const deserializeAws_ec2TransitGatewayRouteTablePropagation = (
  output: any,
  context: __SerdeContext
): TransitGatewayRouteTablePropagation => {
  let contents: any = {
    __type: "TransitGatewayRouteTablePropagation",
    ResourceId: undefined,
    ResourceType: undefined,
    State: undefined,
    TransitGatewayAttachmentId: undefined
  };
  if (output["resourceId"] !== undefined) {
    contents.ResourceId = output["resourceId"];
  }
  if (output["resourceType"] !== undefined) {
    contents.ResourceType = output["resourceType"];
  }
  if (output["state"] !== undefined) {
    contents.State = output["state"];
  }
  if (output["transitGatewayAttachmentId"] !== undefined) {
    contents.TransitGatewayAttachmentId = output["transitGatewayAttachmentId"];
  }
  return contents;
};

const deserializeAws_ec2TransitGatewayRouteTablePropagationList = (
  output: any,
  context: __SerdeContext
): TransitGatewayRouteTablePropagation[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2TransitGatewayRouteTablePropagation(entry, context)
  );
};

const deserializeAws_ec2TransitGatewayVpcAttachment = (
  output: any,
  context: __SerdeContext
): TransitGatewayVpcAttachment => {
  let contents: any = {
    __type: "TransitGatewayVpcAttachment",
    CreationTime: undefined,
    Options: undefined,
    State: undefined,
    SubnetIds: undefined,
    Tags: undefined,
    TransitGatewayAttachmentId: undefined,
    TransitGatewayId: undefined,
    VpcId: undefined,
    VpcOwnerId: undefined
  };
  if (output["creationTime"] !== undefined) {
    contents.CreationTime = new Date(output["creationTime"]);
  }
  if (output["options"] !== undefined) {
    contents.Options = deserializeAws_ec2TransitGatewayVpcAttachmentOptions(
      output["options"],
      context
    );
  }
  if (output["state"] !== undefined) {
    contents.State = output["state"];
  }
  if (output.subnetIds === "") {
    contents.SubnetIds = [];
  }
  if (
    output["subnetIds"] !== undefined &&
    output["subnetIds"]["item"] !== undefined
  ) {
    contents.SubnetIds = deserializeAws_ec2ValueStringList(
      __getArrayIfSingleItem(output["subnetIds"]["item"]),
      context
    );
  }
  if (output.tagSet === "") {
    contents.Tags = [];
  }
  if (
    output["tagSet"] !== undefined &&
    output["tagSet"]["item"] !== undefined
  ) {
    contents.Tags = deserializeAws_ec2TagList(
      __getArrayIfSingleItem(output["tagSet"]["item"]),
      context
    );
  }
  if (output["transitGatewayAttachmentId"] !== undefined) {
    contents.TransitGatewayAttachmentId = output["transitGatewayAttachmentId"];
  }
  if (output["transitGatewayId"] !== undefined) {
    contents.TransitGatewayId = output["transitGatewayId"];
  }
  if (output["vpcId"] !== undefined) {
    contents.VpcId = output["vpcId"];
  }
  if (output["vpcOwnerId"] !== undefined) {
    contents.VpcOwnerId = output["vpcOwnerId"];
  }
  return contents;
};

const deserializeAws_ec2TransitGatewayVpcAttachmentList = (
  output: any,
  context: __SerdeContext
): TransitGatewayVpcAttachment[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2TransitGatewayVpcAttachment(entry, context)
  );
};

const deserializeAws_ec2TransitGatewayVpcAttachmentOptions = (
  output: any,
  context: __SerdeContext
): TransitGatewayVpcAttachmentOptions => {
  let contents: any = {
    __type: "TransitGatewayVpcAttachmentOptions",
    DnsSupport: undefined,
    Ipv6Support: undefined
  };
  if (output["dnsSupport"] !== undefined) {
    contents.DnsSupport = output["dnsSupport"];
  }
  if (output["ipv6Support"] !== undefined) {
    contents.Ipv6Support = output["ipv6Support"];
  }
  return contents;
};

const deserializeAws_ec2TunnelOption = (
  output: any,
  context: __SerdeContext
): TunnelOption => {
  let contents: any = {
    __type: "TunnelOption",
    DpdTimeoutSeconds: undefined,
    IkeVersions: undefined,
    OutsideIpAddress: undefined,
    Phase1DHGroupNumbers: undefined,
    Phase1EncryptionAlgorithms: undefined,
    Phase1IntegrityAlgorithms: undefined,
    Phase1LifetimeSeconds: undefined,
    Phase2DHGroupNumbers: undefined,
    Phase2EncryptionAlgorithms: undefined,
    Phase2IntegrityAlgorithms: undefined,
    Phase2LifetimeSeconds: undefined,
    PreSharedKey: undefined,
    RekeyFuzzPercentage: undefined,
    RekeyMarginTimeSeconds: undefined,
    ReplayWindowSize: undefined,
    TunnelInsideCidr: undefined
  };
  if (output["dpdTimeoutSeconds"] !== undefined) {
    contents.DpdTimeoutSeconds = parseInt(output["dpdTimeoutSeconds"]);
  }
  if (output.ikeVersionSet === "") {
    contents.IkeVersions = [];
  }
  if (
    output["ikeVersionSet"] !== undefined &&
    output["ikeVersionSet"]["item"] !== undefined
  ) {
    contents.IkeVersions = deserializeAws_ec2IKEVersionsList(
      __getArrayIfSingleItem(output["ikeVersionSet"]["item"]),
      context
    );
  }
  if (output["outsideIpAddress"] !== undefined) {
    contents.OutsideIpAddress = output["outsideIpAddress"];
  }
  if (output.phase1DHGroupNumberSet === "") {
    contents.Phase1DHGroupNumbers = [];
  }
  if (
    output["phase1DHGroupNumberSet"] !== undefined &&
    output["phase1DHGroupNumberSet"]["item"] !== undefined
  ) {
    contents.Phase1DHGroupNumbers = deserializeAws_ec2Phase1DHGroupNumbersList(
      __getArrayIfSingleItem(output["phase1DHGroupNumberSet"]["item"]),
      context
    );
  }
  if (output.phase1EncryptionAlgorithmSet === "") {
    contents.Phase1EncryptionAlgorithms = [];
  }
  if (
    output["phase1EncryptionAlgorithmSet"] !== undefined &&
    output["phase1EncryptionAlgorithmSet"]["item"] !== undefined
  ) {
    contents.Phase1EncryptionAlgorithms = deserializeAws_ec2Phase1EncryptionAlgorithmsList(
      __getArrayIfSingleItem(output["phase1EncryptionAlgorithmSet"]["item"]),
      context
    );
  }
  if (output.phase1IntegrityAlgorithmSet === "") {
    contents.Phase1IntegrityAlgorithms = [];
  }
  if (
    output["phase1IntegrityAlgorithmSet"] !== undefined &&
    output["phase1IntegrityAlgorithmSet"]["item"] !== undefined
  ) {
    contents.Phase1IntegrityAlgorithms = deserializeAws_ec2Phase1IntegrityAlgorithmsList(
      __getArrayIfSingleItem(output["phase1IntegrityAlgorithmSet"]["item"]),
      context
    );
  }
  if (output["phase1LifetimeSeconds"] !== undefined) {
    contents.Phase1LifetimeSeconds = parseInt(output["phase1LifetimeSeconds"]);
  }
  if (output.phase2DHGroupNumberSet === "") {
    contents.Phase2DHGroupNumbers = [];
  }
  if (
    output["phase2DHGroupNumberSet"] !== undefined &&
    output["phase2DHGroupNumberSet"]["item"] !== undefined
  ) {
    contents.Phase2DHGroupNumbers = deserializeAws_ec2Phase2DHGroupNumbersList(
      __getArrayIfSingleItem(output["phase2DHGroupNumberSet"]["item"]),
      context
    );
  }
  if (output.phase2EncryptionAlgorithmSet === "") {
    contents.Phase2EncryptionAlgorithms = [];
  }
  if (
    output["phase2EncryptionAlgorithmSet"] !== undefined &&
    output["phase2EncryptionAlgorithmSet"]["item"] !== undefined
  ) {
    contents.Phase2EncryptionAlgorithms = deserializeAws_ec2Phase2EncryptionAlgorithmsList(
      __getArrayIfSingleItem(output["phase2EncryptionAlgorithmSet"]["item"]),
      context
    );
  }
  if (output.phase2IntegrityAlgorithmSet === "") {
    contents.Phase2IntegrityAlgorithms = [];
  }
  if (
    output["phase2IntegrityAlgorithmSet"] !== undefined &&
    output["phase2IntegrityAlgorithmSet"]["item"] !== undefined
  ) {
    contents.Phase2IntegrityAlgorithms = deserializeAws_ec2Phase2IntegrityAlgorithmsList(
      __getArrayIfSingleItem(output["phase2IntegrityAlgorithmSet"]["item"]),
      context
    );
  }
  if (output["phase2LifetimeSeconds"] !== undefined) {
    contents.Phase2LifetimeSeconds = parseInt(output["phase2LifetimeSeconds"]);
  }
  if (output["preSharedKey"] !== undefined) {
    contents.PreSharedKey = output["preSharedKey"];
  }
  if (output["rekeyFuzzPercentage"] !== undefined) {
    contents.RekeyFuzzPercentage = parseInt(output["rekeyFuzzPercentage"]);
  }
  if (output["rekeyMarginTimeSeconds"] !== undefined) {
    contents.RekeyMarginTimeSeconds = parseInt(
      output["rekeyMarginTimeSeconds"]
    );
  }
  if (output["replayWindowSize"] !== undefined) {
    contents.ReplayWindowSize = parseInt(output["replayWindowSize"]);
  }
  if (output["tunnelInsideCidr"] !== undefined) {
    contents.TunnelInsideCidr = output["tunnelInsideCidr"];
  }
  return contents;
};

const deserializeAws_ec2TunnelOptionsList = (
  output: any,
  context: __SerdeContext
): TunnelOption[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2TunnelOption(entry, context)
  );
};

const deserializeAws_ec2UnassignIpv6AddressesResult = (
  output: any,
  context: __SerdeContext
): UnassignIpv6AddressesResult => {
  let contents: any = {
    __type: "UnassignIpv6AddressesResult",
    NetworkInterfaceId: undefined,
    UnassignedIpv6Addresses: undefined
  };
  if (output["networkInterfaceId"] !== undefined) {
    contents.NetworkInterfaceId = output["networkInterfaceId"];
  }
  if (output.unassignedIpv6Addresses === "") {
    contents.UnassignedIpv6Addresses = [];
  }
  if (
    output["unassignedIpv6Addresses"] !== undefined &&
    output["unassignedIpv6Addresses"]["item"] !== undefined
  ) {
    contents.UnassignedIpv6Addresses = deserializeAws_ec2Ipv6AddressList(
      __getArrayIfSingleItem(output["unassignedIpv6Addresses"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2UnmonitorInstancesResult = (
  output: any,
  context: __SerdeContext
): UnmonitorInstancesResult => {
  let contents: any = {
    __type: "UnmonitorInstancesResult",
    InstanceMonitorings: undefined
  };
  if (output.instancesSet === "") {
    contents.InstanceMonitorings = [];
  }
  if (
    output["instancesSet"] !== undefined &&
    output["instancesSet"]["item"] !== undefined
  ) {
    contents.InstanceMonitorings = deserializeAws_ec2InstanceMonitoringList(
      __getArrayIfSingleItem(output["instancesSet"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2UnsuccessfulInstanceCreditSpecificationItem = (
  output: any,
  context: __SerdeContext
): UnsuccessfulInstanceCreditSpecificationItem => {
  let contents: any = {
    __type: "UnsuccessfulInstanceCreditSpecificationItem",
    Error: undefined,
    InstanceId: undefined
  };
  if (output["error"] !== undefined) {
    contents.Error = deserializeAws_ec2UnsuccessfulInstanceCreditSpecificationItemError(
      output["error"],
      context
    );
  }
  if (output["instanceId"] !== undefined) {
    contents.InstanceId = output["instanceId"];
  }
  return contents;
};

const deserializeAws_ec2UnsuccessfulInstanceCreditSpecificationItemError = (
  output: any,
  context: __SerdeContext
): UnsuccessfulInstanceCreditSpecificationItemError => {
  let contents: any = {
    __type: "UnsuccessfulInstanceCreditSpecificationItemError",
    Code: undefined,
    Message: undefined
  };
  if (output["code"] !== undefined) {
    contents.Code = output["code"];
  }
  if (output["message"] !== undefined) {
    contents.Message = output["message"];
  }
  return contents;
};

const deserializeAws_ec2UnsuccessfulInstanceCreditSpecificationSet = (
  output: any,
  context: __SerdeContext
): UnsuccessfulInstanceCreditSpecificationItem[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2UnsuccessfulInstanceCreditSpecificationItem(
      entry,
      context
    )
  );
};

const deserializeAws_ec2UnsuccessfulItem = (
  output: any,
  context: __SerdeContext
): UnsuccessfulItem => {
  let contents: any = {
    __type: "UnsuccessfulItem",
    Error: undefined,
    ResourceId: undefined
  };
  if (output["error"] !== undefined) {
    contents.Error = deserializeAws_ec2UnsuccessfulItemError(
      output["error"],
      context
    );
  }
  if (output["resourceId"] !== undefined) {
    contents.ResourceId = output["resourceId"];
  }
  return contents;
};

const deserializeAws_ec2UnsuccessfulItemError = (
  output: any,
  context: __SerdeContext
): UnsuccessfulItemError => {
  let contents: any = {
    __type: "UnsuccessfulItemError",
    Code: undefined,
    Message: undefined
  };
  if (output["code"] !== undefined) {
    contents.Code = output["code"];
  }
  if (output["message"] !== undefined) {
    contents.Message = output["message"];
  }
  return contents;
};

const deserializeAws_ec2UnsuccessfulItemList = (
  output: any,
  context: __SerdeContext
): UnsuccessfulItem[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2UnsuccessfulItem(entry, context)
  );
};

const deserializeAws_ec2UnsuccessfulItemSet = (
  output: any,
  context: __SerdeContext
): UnsuccessfulItem[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2UnsuccessfulItem(entry, context)
  );
};

const deserializeAws_ec2UpdateSecurityGroupRuleDescriptionsEgressResult = (
  output: any,
  context: __SerdeContext
): UpdateSecurityGroupRuleDescriptionsEgressResult => {
  let contents: any = {
    __type: "UpdateSecurityGroupRuleDescriptionsEgressResult",
    Return: undefined
  };
  if (output["return"] !== undefined) {
    contents.Return = output["return"] == "true";
  }
  return contents;
};

const deserializeAws_ec2UpdateSecurityGroupRuleDescriptionsIngressResult = (
  output: any,
  context: __SerdeContext
): UpdateSecurityGroupRuleDescriptionsIngressResult => {
  let contents: any = {
    __type: "UpdateSecurityGroupRuleDescriptionsIngressResult",
    Return: undefined
  };
  if (output["return"] !== undefined) {
    contents.Return = output["return"] == "true";
  }
  return contents;
};

const deserializeAws_ec2UsageClassTypeList = (
  output: any,
  context: __SerdeContext
): (UsageClassType | string)[] => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_ec2UserBucketDetails = (
  output: any,
  context: __SerdeContext
): UserBucketDetails => {
  let contents: any = {
    __type: "UserBucketDetails",
    S3Bucket: undefined,
    S3Key: undefined
  };
  if (output["s3Bucket"] !== undefined) {
    contents.S3Bucket = output["s3Bucket"];
  }
  if (output["s3Key"] !== undefined) {
    contents.S3Key = output["s3Key"];
  }
  return contents;
};

const deserializeAws_ec2UserIdGroupPair = (
  output: any,
  context: __SerdeContext
): UserIdGroupPair => {
  let contents: any = {
    __type: "UserIdGroupPair",
    Description: undefined,
    GroupId: undefined,
    GroupName: undefined,
    PeeringStatus: undefined,
    UserId: undefined,
    VpcId: undefined,
    VpcPeeringConnectionId: undefined
  };
  if (output["description"] !== undefined) {
    contents.Description = output["description"];
  }
  if (output["groupId"] !== undefined) {
    contents.GroupId = output["groupId"];
  }
  if (output["groupName"] !== undefined) {
    contents.GroupName = output["groupName"];
  }
  if (output["peeringStatus"] !== undefined) {
    contents.PeeringStatus = output["peeringStatus"];
  }
  if (output["userId"] !== undefined) {
    contents.UserId = output["userId"];
  }
  if (output["vpcId"] !== undefined) {
    contents.VpcId = output["vpcId"];
  }
  if (output["vpcPeeringConnectionId"] !== undefined) {
    contents.VpcPeeringConnectionId = output["vpcPeeringConnectionId"];
  }
  return contents;
};

const deserializeAws_ec2UserIdGroupPairList = (
  output: any,
  context: __SerdeContext
): UserIdGroupPair[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2UserIdGroupPair(entry, context)
  );
};

const deserializeAws_ec2UserIdGroupPairSet = (
  output: any,
  context: __SerdeContext
): UserIdGroupPair[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2UserIdGroupPair(entry, context)
  );
};

const deserializeAws_ec2ValueStringList = (
  output: any,
  context: __SerdeContext
): string[] => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_ec2VCpuInfo = (
  output: any,
  context: __SerdeContext
): VCpuInfo => {
  let contents: any = {
    __type: "VCpuInfo",
    DefaultCores: undefined,
    DefaultThreadsPerCore: undefined,
    DefaultVCpus: undefined,
    ValidCores: undefined,
    ValidThreadsPerCore: undefined
  };
  if (output["defaultCores"] !== undefined) {
    contents.DefaultCores = parseInt(output["defaultCores"]);
  }
  if (output["defaultThreadsPerCore"] !== undefined) {
    contents.DefaultThreadsPerCore = parseInt(output["defaultThreadsPerCore"]);
  }
  if (output["defaultVCpus"] !== undefined) {
    contents.DefaultVCpus = parseInt(output["defaultVCpus"]);
  }
  if (output.validCores === "") {
    contents.ValidCores = [];
  }
  if (
    output["validCores"] !== undefined &&
    output["validCores"]["item"] !== undefined
  ) {
    contents.ValidCores = deserializeAws_ec2CoreCountList(
      __getArrayIfSingleItem(output["validCores"]["item"]),
      context
    );
  }
  if (output.validThreadsPerCore === "") {
    contents.ValidThreadsPerCore = [];
  }
  if (
    output["validThreadsPerCore"] !== undefined &&
    output["validThreadsPerCore"]["item"] !== undefined
  ) {
    contents.ValidThreadsPerCore = deserializeAws_ec2ThreadsPerCoreList(
      __getArrayIfSingleItem(output["validThreadsPerCore"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2VgwTelemetry = (
  output: any,
  context: __SerdeContext
): VgwTelemetry => {
  let contents: any = {
    __type: "VgwTelemetry",
    AcceptedRouteCount: undefined,
    CertificateArn: undefined,
    LastStatusChange: undefined,
    OutsideIpAddress: undefined,
    Status: undefined,
    StatusMessage: undefined
  };
  if (output["acceptedRouteCount"] !== undefined) {
    contents.AcceptedRouteCount = parseInt(output["acceptedRouteCount"]);
  }
  if (output["certificateArn"] !== undefined) {
    contents.CertificateArn = output["certificateArn"];
  }
  if (output["lastStatusChange"] !== undefined) {
    contents.LastStatusChange = new Date(output["lastStatusChange"]);
  }
  if (output["outsideIpAddress"] !== undefined) {
    contents.OutsideIpAddress = output["outsideIpAddress"];
  }
  if (output["status"] !== undefined) {
    contents.Status = output["status"];
  }
  if (output["statusMessage"] !== undefined) {
    contents.StatusMessage = output["statusMessage"];
  }
  return contents;
};

const deserializeAws_ec2VgwTelemetryList = (
  output: any,
  context: __SerdeContext
): VgwTelemetry[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2VgwTelemetry(entry, context)
  );
};

const deserializeAws_ec2Volume = (
  output: any,
  context: __SerdeContext
): Volume => {
  let contents: any = {
    __type: "Volume",
    Attachments: undefined,
    AvailabilityZone: undefined,
    CreateTime: undefined,
    Encrypted: undefined,
    FastRestored: undefined,
    Iops: undefined,
    KmsKeyId: undefined,
    OutpostArn: undefined,
    Size: undefined,
    SnapshotId: undefined,
    State: undefined,
    Tags: undefined,
    VolumeId: undefined,
    VolumeType: undefined
  };
  if (output.attachmentSet === "") {
    contents.Attachments = [];
  }
  if (
    output["attachmentSet"] !== undefined &&
    output["attachmentSet"]["item"] !== undefined
  ) {
    contents.Attachments = deserializeAws_ec2VolumeAttachmentList(
      __getArrayIfSingleItem(output["attachmentSet"]["item"]),
      context
    );
  }
  if (output["availabilityZone"] !== undefined) {
    contents.AvailabilityZone = output["availabilityZone"];
  }
  if (output["createTime"] !== undefined) {
    contents.CreateTime = new Date(output["createTime"]);
  }
  if (output["encrypted"] !== undefined) {
    contents.Encrypted = output["encrypted"] == "true";
  }
  if (output["fastRestored"] !== undefined) {
    contents.FastRestored = output["fastRestored"] == "true";
  }
  if (output["iops"] !== undefined) {
    contents.Iops = parseInt(output["iops"]);
  }
  if (output["kmsKeyId"] !== undefined) {
    contents.KmsKeyId = output["kmsKeyId"];
  }
  if (output["outpostArn"] !== undefined) {
    contents.OutpostArn = output["outpostArn"];
  }
  if (output["size"] !== undefined) {
    contents.Size = parseInt(output["size"]);
  }
  if (output["snapshotId"] !== undefined) {
    contents.SnapshotId = output["snapshotId"];
  }
  if (output["status"] !== undefined) {
    contents.State = output["status"];
  }
  if (output.tagSet === "") {
    contents.Tags = [];
  }
  if (
    output["tagSet"] !== undefined &&
    output["tagSet"]["item"] !== undefined
  ) {
    contents.Tags = deserializeAws_ec2TagList(
      __getArrayIfSingleItem(output["tagSet"]["item"]),
      context
    );
  }
  if (output["volumeId"] !== undefined) {
    contents.VolumeId = output["volumeId"];
  }
  if (output["volumeType"] !== undefined) {
    contents.VolumeType = output["volumeType"];
  }
  return contents;
};

const deserializeAws_ec2VolumeAttachment = (
  output: any,
  context: __SerdeContext
): VolumeAttachment => {
  let contents: any = {
    __type: "VolumeAttachment",
    AttachTime: undefined,
    DeleteOnTermination: undefined,
    Device: undefined,
    InstanceId: undefined,
    State: undefined,
    VolumeId: undefined
  };
  if (output["attachTime"] !== undefined) {
    contents.AttachTime = new Date(output["attachTime"]);
  }
  if (output["deleteOnTermination"] !== undefined) {
    contents.DeleteOnTermination = output["deleteOnTermination"] == "true";
  }
  if (output["device"] !== undefined) {
    contents.Device = output["device"];
  }
  if (output["instanceId"] !== undefined) {
    contents.InstanceId = output["instanceId"];
  }
  if (output["status"] !== undefined) {
    contents.State = output["status"];
  }
  if (output["volumeId"] !== undefined) {
    contents.VolumeId = output["volumeId"];
  }
  return contents;
};

const deserializeAws_ec2VolumeAttachmentList = (
  output: any,
  context: __SerdeContext
): VolumeAttachment[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2VolumeAttachment(entry, context)
  );
};

const deserializeAws_ec2VolumeList = (
  output: any,
  context: __SerdeContext
): Volume[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2Volume(entry, context)
  );
};

const deserializeAws_ec2VolumeModification = (
  output: any,
  context: __SerdeContext
): VolumeModification => {
  let contents: any = {
    __type: "VolumeModification",
    EndTime: undefined,
    ModificationState: undefined,
    OriginalIops: undefined,
    OriginalSize: undefined,
    OriginalVolumeType: undefined,
    Progress: undefined,
    StartTime: undefined,
    StatusMessage: undefined,
    TargetIops: undefined,
    TargetSize: undefined,
    TargetVolumeType: undefined,
    VolumeId: undefined
  };
  if (output["endTime"] !== undefined) {
    contents.EndTime = new Date(output["endTime"]);
  }
  if (output["modificationState"] !== undefined) {
    contents.ModificationState = output["modificationState"];
  }
  if (output["originalIops"] !== undefined) {
    contents.OriginalIops = parseInt(output["originalIops"]);
  }
  if (output["originalSize"] !== undefined) {
    contents.OriginalSize = parseInt(output["originalSize"]);
  }
  if (output["originalVolumeType"] !== undefined) {
    contents.OriginalVolumeType = output["originalVolumeType"];
  }
  if (output["progress"] !== undefined) {
    contents.Progress = parseInt(output["progress"]);
  }
  if (output["startTime"] !== undefined) {
    contents.StartTime = new Date(output["startTime"]);
  }
  if (output["statusMessage"] !== undefined) {
    contents.StatusMessage = output["statusMessage"];
  }
  if (output["targetIops"] !== undefined) {
    contents.TargetIops = parseInt(output["targetIops"]);
  }
  if (output["targetSize"] !== undefined) {
    contents.TargetSize = parseInt(output["targetSize"]);
  }
  if (output["targetVolumeType"] !== undefined) {
    contents.TargetVolumeType = output["targetVolumeType"];
  }
  if (output["volumeId"] !== undefined) {
    contents.VolumeId = output["volumeId"];
  }
  return contents;
};

const deserializeAws_ec2VolumeModificationList = (
  output: any,
  context: __SerdeContext
): VolumeModification[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2VolumeModification(entry, context)
  );
};

const deserializeAws_ec2VolumeStatusAction = (
  output: any,
  context: __SerdeContext
): VolumeStatusAction => {
  let contents: any = {
    __type: "VolumeStatusAction",
    Code: undefined,
    Description: undefined,
    EventId: undefined,
    EventType: undefined
  };
  if (output["code"] !== undefined) {
    contents.Code = output["code"];
  }
  if (output["description"] !== undefined) {
    contents.Description = output["description"];
  }
  if (output["eventId"] !== undefined) {
    contents.EventId = output["eventId"];
  }
  if (output["eventType"] !== undefined) {
    contents.EventType = output["eventType"];
  }
  return contents;
};

const deserializeAws_ec2VolumeStatusActionsList = (
  output: any,
  context: __SerdeContext
): VolumeStatusAction[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2VolumeStatusAction(entry, context)
  );
};

const deserializeAws_ec2VolumeStatusDetails = (
  output: any,
  context: __SerdeContext
): VolumeStatusDetails => {
  let contents: any = {
    __type: "VolumeStatusDetails",
    Name: undefined,
    Status: undefined
  };
  if (output["name"] !== undefined) {
    contents.Name = output["name"];
  }
  if (output["status"] !== undefined) {
    contents.Status = output["status"];
  }
  return contents;
};

const deserializeAws_ec2VolumeStatusDetailsList = (
  output: any,
  context: __SerdeContext
): VolumeStatusDetails[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2VolumeStatusDetails(entry, context)
  );
};

const deserializeAws_ec2VolumeStatusEvent = (
  output: any,
  context: __SerdeContext
): VolumeStatusEvent => {
  let contents: any = {
    __type: "VolumeStatusEvent",
    Description: undefined,
    EventId: undefined,
    EventType: undefined,
    NotAfter: undefined,
    NotBefore: undefined
  };
  if (output["description"] !== undefined) {
    contents.Description = output["description"];
  }
  if (output["eventId"] !== undefined) {
    contents.EventId = output["eventId"];
  }
  if (output["eventType"] !== undefined) {
    contents.EventType = output["eventType"];
  }
  if (output["notAfter"] !== undefined) {
    contents.NotAfter = new Date(output["notAfter"]);
  }
  if (output["notBefore"] !== undefined) {
    contents.NotBefore = new Date(output["notBefore"]);
  }
  return contents;
};

const deserializeAws_ec2VolumeStatusEventsList = (
  output: any,
  context: __SerdeContext
): VolumeStatusEvent[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2VolumeStatusEvent(entry, context)
  );
};

const deserializeAws_ec2VolumeStatusInfo = (
  output: any,
  context: __SerdeContext
): VolumeStatusInfo => {
  let contents: any = {
    __type: "VolumeStatusInfo",
    Details: undefined,
    Status: undefined
  };
  if (output.details === "") {
    contents.Details = [];
  }
  if (
    output["details"] !== undefined &&
    output["details"]["item"] !== undefined
  ) {
    contents.Details = deserializeAws_ec2VolumeStatusDetailsList(
      __getArrayIfSingleItem(output["details"]["item"]),
      context
    );
  }
  if (output["status"] !== undefined) {
    contents.Status = output["status"];
  }
  return contents;
};

const deserializeAws_ec2VolumeStatusItem = (
  output: any,
  context: __SerdeContext
): VolumeStatusItem => {
  let contents: any = {
    __type: "VolumeStatusItem",
    Actions: undefined,
    AvailabilityZone: undefined,
    Events: undefined,
    OutpostArn: undefined,
    VolumeId: undefined,
    VolumeStatus: undefined
  };
  if (output.actionsSet === "") {
    contents.Actions = [];
  }
  if (
    output["actionsSet"] !== undefined &&
    output["actionsSet"]["item"] !== undefined
  ) {
    contents.Actions = deserializeAws_ec2VolumeStatusActionsList(
      __getArrayIfSingleItem(output["actionsSet"]["item"]),
      context
    );
  }
  if (output["availabilityZone"] !== undefined) {
    contents.AvailabilityZone = output["availabilityZone"];
  }
  if (output.eventsSet === "") {
    contents.Events = [];
  }
  if (
    output["eventsSet"] !== undefined &&
    output["eventsSet"]["item"] !== undefined
  ) {
    contents.Events = deserializeAws_ec2VolumeStatusEventsList(
      __getArrayIfSingleItem(output["eventsSet"]["item"]),
      context
    );
  }
  if (output["outpostArn"] !== undefined) {
    contents.OutpostArn = output["outpostArn"];
  }
  if (output["volumeId"] !== undefined) {
    contents.VolumeId = output["volumeId"];
  }
  if (output["volumeStatus"] !== undefined) {
    contents.VolumeStatus = deserializeAws_ec2VolumeStatusInfo(
      output["volumeStatus"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2VolumeStatusList = (
  output: any,
  context: __SerdeContext
): VolumeStatusItem[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2VolumeStatusItem(entry, context)
  );
};

const deserializeAws_ec2Vpc = (output: any, context: __SerdeContext): Vpc => {
  let contents: any = {
    __type: "Vpc",
    CidrBlock: undefined,
    CidrBlockAssociationSet: undefined,
    DhcpOptionsId: undefined,
    InstanceTenancy: undefined,
    Ipv6CidrBlockAssociationSet: undefined,
    IsDefault: undefined,
    OwnerId: undefined,
    State: undefined,
    Tags: undefined,
    VpcId: undefined
  };
  if (output["cidrBlock"] !== undefined) {
    contents.CidrBlock = output["cidrBlock"];
  }
  if (output.cidrBlockAssociationSet === "") {
    contents.CidrBlockAssociationSet = [];
  }
  if (
    output["cidrBlockAssociationSet"] !== undefined &&
    output["cidrBlockAssociationSet"]["item"] !== undefined
  ) {
    contents.CidrBlockAssociationSet = deserializeAws_ec2VpcCidrBlockAssociationSet(
      __getArrayIfSingleItem(output["cidrBlockAssociationSet"]["item"]),
      context
    );
  }
  if (output["dhcpOptionsId"] !== undefined) {
    contents.DhcpOptionsId = output["dhcpOptionsId"];
  }
  if (output["instanceTenancy"] !== undefined) {
    contents.InstanceTenancy = output["instanceTenancy"];
  }
  if (output.ipv6CidrBlockAssociationSet === "") {
    contents.Ipv6CidrBlockAssociationSet = [];
  }
  if (
    output["ipv6CidrBlockAssociationSet"] !== undefined &&
    output["ipv6CidrBlockAssociationSet"]["item"] !== undefined
  ) {
    contents.Ipv6CidrBlockAssociationSet = deserializeAws_ec2VpcIpv6CidrBlockAssociationSet(
      __getArrayIfSingleItem(output["ipv6CidrBlockAssociationSet"]["item"]),
      context
    );
  }
  if (output["isDefault"] !== undefined) {
    contents.IsDefault = output["isDefault"] == "true";
  }
  if (output["ownerId"] !== undefined) {
    contents.OwnerId = output["ownerId"];
  }
  if (output["state"] !== undefined) {
    contents.State = output["state"];
  }
  if (output.tagSet === "") {
    contents.Tags = [];
  }
  if (
    output["tagSet"] !== undefined &&
    output["tagSet"]["item"] !== undefined
  ) {
    contents.Tags = deserializeAws_ec2TagList(
      __getArrayIfSingleItem(output["tagSet"]["item"]),
      context
    );
  }
  if (output["vpcId"] !== undefined) {
    contents.VpcId = output["vpcId"];
  }
  return contents;
};

const deserializeAws_ec2VpcAttachment = (
  output: any,
  context: __SerdeContext
): VpcAttachment => {
  let contents: any = {
    __type: "VpcAttachment",
    State: undefined,
    VpcId: undefined
  };
  if (output["state"] !== undefined) {
    contents.State = output["state"];
  }
  if (output["vpcId"] !== undefined) {
    contents.VpcId = output["vpcId"];
  }
  return contents;
};

const deserializeAws_ec2VpcAttachmentList = (
  output: any,
  context: __SerdeContext
): VpcAttachment[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2VpcAttachment(entry, context)
  );
};

const deserializeAws_ec2VpcCidrBlockAssociation = (
  output: any,
  context: __SerdeContext
): VpcCidrBlockAssociation => {
  let contents: any = {
    __type: "VpcCidrBlockAssociation",
    AssociationId: undefined,
    CidrBlock: undefined,
    CidrBlockState: undefined
  };
  if (output["associationId"] !== undefined) {
    contents.AssociationId = output["associationId"];
  }
  if (output["cidrBlock"] !== undefined) {
    contents.CidrBlock = output["cidrBlock"];
  }
  if (output["cidrBlockState"] !== undefined) {
    contents.CidrBlockState = deserializeAws_ec2VpcCidrBlockState(
      output["cidrBlockState"],
      context
    );
  }
  return contents;
};

const deserializeAws_ec2VpcCidrBlockAssociationSet = (
  output: any,
  context: __SerdeContext
): VpcCidrBlockAssociation[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2VpcCidrBlockAssociation(entry, context)
  );
};

const deserializeAws_ec2VpcCidrBlockState = (
  output: any,
  context: __SerdeContext
): VpcCidrBlockState => {
  let contents: any = {
    __type: "VpcCidrBlockState",
    State: undefined,
    StatusMessage: undefined
  };
  if (output["state"] !== undefined) {
    contents.State = output["state"];
  }
  if (output["statusMessage"] !== undefined) {
    contents.StatusMessage = output["statusMessage"];
  }
  return contents;
};

const deserializeAws_ec2VpcClassicLink = (
  output: any,
  context: __SerdeContext
): VpcClassicLink => {
  let contents: any = {
    __type: "VpcClassicLink",
    ClassicLinkEnabled: undefined,
    Tags: undefined,
    VpcId: undefined
  };
  if (output["classicLinkEnabled"] !== undefined) {
    contents.ClassicLinkEnabled = output["classicLinkEnabled"] == "true";
  }
  if (output.tagSet === "") {
    contents.Tags = [];
  }
  if (
    output["tagSet"] !== undefined &&
    output["tagSet"]["item"] !== undefined
  ) {
    contents.Tags = deserializeAws_ec2TagList(
      __getArrayIfSingleItem(output["tagSet"]["item"]),
      context
    );
  }
  if (output["vpcId"] !== undefined) {
    contents.VpcId = output["vpcId"];
  }
  return contents;
};

const deserializeAws_ec2VpcClassicLinkList = (
  output: any,
  context: __SerdeContext
): VpcClassicLink[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2VpcClassicLink(entry, context)
  );
};

const deserializeAws_ec2VpcEndpoint = (
  output: any,
  context: __SerdeContext
): VpcEndpoint => {
  let contents: any = {
    __type: "VpcEndpoint",
    CreationTimestamp: undefined,
    DnsEntries: undefined,
    Groups: undefined,
    LastError: undefined,
    NetworkInterfaceIds: undefined,
    OwnerId: undefined,
    PolicyDocument: undefined,
    PrivateDnsEnabled: undefined,
    RequesterManaged: undefined,
    RouteTableIds: undefined,
    ServiceName: undefined,
    State: undefined,
    SubnetIds: undefined,
    Tags: undefined,
    VpcEndpointId: undefined,
    VpcEndpointType: undefined,
    VpcId: undefined
  };
  if (output["creationTimestamp"] !== undefined) {
    contents.CreationTimestamp = new Date(output["creationTimestamp"]);
  }
  if (output.dnsEntrySet === "") {
    contents.DnsEntries = [];
  }
  if (
    output["dnsEntrySet"] !== undefined &&
    output["dnsEntrySet"]["item"] !== undefined
  ) {
    contents.DnsEntries = deserializeAws_ec2DnsEntrySet(
      __getArrayIfSingleItem(output["dnsEntrySet"]["item"]),
      context
    );
  }
  if (output.groupSet === "") {
    contents.Groups = [];
  }
  if (
    output["groupSet"] !== undefined &&
    output["groupSet"]["item"] !== undefined
  ) {
    contents.Groups = deserializeAws_ec2GroupIdentifierSet(
      __getArrayIfSingleItem(output["groupSet"]["item"]),
      context
    );
  }
  if (output["lastError"] !== undefined) {
    contents.LastError = deserializeAws_ec2LastError(
      output["lastError"],
      context
    );
  }
  if (output.networkInterfaceIdSet === "") {
    contents.NetworkInterfaceIds = [];
  }
  if (
    output["networkInterfaceIdSet"] !== undefined &&
    output["networkInterfaceIdSet"]["item"] !== undefined
  ) {
    contents.NetworkInterfaceIds = deserializeAws_ec2ValueStringList(
      __getArrayIfSingleItem(output["networkInterfaceIdSet"]["item"]),
      context
    );
  }
  if (output["ownerId"] !== undefined) {
    contents.OwnerId = output["ownerId"];
  }
  if (output["policyDocument"] !== undefined) {
    contents.PolicyDocument = output["policyDocument"];
  }
  if (output["privateDnsEnabled"] !== undefined) {
    contents.PrivateDnsEnabled = output["privateDnsEnabled"] == "true";
  }
  if (output["requesterManaged"] !== undefined) {
    contents.RequesterManaged = output["requesterManaged"] == "true";
  }
  if (output.routeTableIdSet === "") {
    contents.RouteTableIds = [];
  }
  if (
    output["routeTableIdSet"] !== undefined &&
    output["routeTableIdSet"]["item"] !== undefined
  ) {
    contents.RouteTableIds = deserializeAws_ec2ValueStringList(
      __getArrayIfSingleItem(output["routeTableIdSet"]["item"]),
      context
    );
  }
  if (output["serviceName"] !== undefined) {
    contents.ServiceName = output["serviceName"];
  }
  if (output["state"] !== undefined) {
    contents.State = output["state"];
  }
  if (output.subnetIdSet === "") {
    contents.SubnetIds = [];
  }
  if (
    output["subnetIdSet"] !== undefined &&
    output["subnetIdSet"]["item"] !== undefined
  ) {
    contents.SubnetIds = deserializeAws_ec2ValueStringList(
      __getArrayIfSingleItem(output["subnetIdSet"]["item"]),
      context
    );
  }
  if (output.tagSet === "") {
    contents.Tags = [];
  }
  if (
    output["tagSet"] !== undefined &&
    output["tagSet"]["item"] !== undefined
  ) {
    contents.Tags = deserializeAws_ec2TagList(
      __getArrayIfSingleItem(output["tagSet"]["item"]),
      context
    );
  }
  if (output["vpcEndpointId"] !== undefined) {
    contents.VpcEndpointId = output["vpcEndpointId"];
  }
  if (output["vpcEndpointType"] !== undefined) {
    contents.VpcEndpointType = output["vpcEndpointType"];
  }
  if (output["vpcId"] !== undefined) {
    contents.VpcId = output["vpcId"];
  }
  return contents;
};

const deserializeAws_ec2VpcEndpointConnection = (
  output: any,
  context: __SerdeContext
): VpcEndpointConnection => {
  let contents: any = {
    __type: "VpcEndpointConnection",
    CreationTimestamp: undefined,
    DnsEntries: undefined,
    NetworkLoadBalancerArns: undefined,
    ServiceId: undefined,
    VpcEndpointId: undefined,
    VpcEndpointOwner: undefined,
    VpcEndpointState: undefined
  };
  if (output["creationTimestamp"] !== undefined) {
    contents.CreationTimestamp = new Date(output["creationTimestamp"]);
  }
  if (output.dnsEntrySet === "") {
    contents.DnsEntries = [];
  }
  if (
    output["dnsEntrySet"] !== undefined &&
    output["dnsEntrySet"]["item"] !== undefined
  ) {
    contents.DnsEntries = deserializeAws_ec2DnsEntrySet(
      __getArrayIfSingleItem(output["dnsEntrySet"]["item"]),
      context
    );
  }
  if (output.networkLoadBalancerArnSet === "") {
    contents.NetworkLoadBalancerArns = [];
  }
  if (
    output["networkLoadBalancerArnSet"] !== undefined &&
    output["networkLoadBalancerArnSet"]["item"] !== undefined
  ) {
    contents.NetworkLoadBalancerArns = deserializeAws_ec2ValueStringList(
      __getArrayIfSingleItem(output["networkLoadBalancerArnSet"]["item"]),
      context
    );
  }
  if (output["serviceId"] !== undefined) {
    contents.ServiceId = output["serviceId"];
  }
  if (output["vpcEndpointId"] !== undefined) {
    contents.VpcEndpointId = output["vpcEndpointId"];
  }
  if (output["vpcEndpointOwner"] !== undefined) {
    contents.VpcEndpointOwner = output["vpcEndpointOwner"];
  }
  if (output["vpcEndpointState"] !== undefined) {
    contents.VpcEndpointState = output["vpcEndpointState"];
  }
  return contents;
};

const deserializeAws_ec2VpcEndpointConnectionSet = (
  output: any,
  context: __SerdeContext
): VpcEndpointConnection[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2VpcEndpointConnection(entry, context)
  );
};

const deserializeAws_ec2VpcEndpointSet = (
  output: any,
  context: __SerdeContext
): VpcEndpoint[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2VpcEndpoint(entry, context)
  );
};

const deserializeAws_ec2VpcIpv6CidrBlockAssociation = (
  output: any,
  context: __SerdeContext
): VpcIpv6CidrBlockAssociation => {
  let contents: any = {
    __type: "VpcIpv6CidrBlockAssociation",
    AssociationId: undefined,
    Ipv6CidrBlock: undefined,
    Ipv6CidrBlockState: undefined,
    Ipv6Pool: undefined,
    NetworkBorderGroup: undefined
  };
  if (output["associationId"] !== undefined) {
    contents.AssociationId = output["associationId"];
  }
  if (output["ipv6CidrBlock"] !== undefined) {
    contents.Ipv6CidrBlock = output["ipv6CidrBlock"];
  }
  if (output["ipv6CidrBlockState"] !== undefined) {
    contents.Ipv6CidrBlockState = deserializeAws_ec2VpcCidrBlockState(
      output["ipv6CidrBlockState"],
      context
    );
  }
  if (output["ipv6Pool"] !== undefined) {
    contents.Ipv6Pool = output["ipv6Pool"];
  }
  if (output["networkBorderGroup"] !== undefined) {
    contents.NetworkBorderGroup = output["networkBorderGroup"];
  }
  return contents;
};

const deserializeAws_ec2VpcIpv6CidrBlockAssociationSet = (
  output: any,
  context: __SerdeContext
): VpcIpv6CidrBlockAssociation[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2VpcIpv6CidrBlockAssociation(entry, context)
  );
};

const deserializeAws_ec2VpcList = (
  output: any,
  context: __SerdeContext
): Vpc[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2Vpc(entry, context)
  );
};

const deserializeAws_ec2VpcPeeringConnection = (
  output: any,
  context: __SerdeContext
): VpcPeeringConnection => {
  let contents: any = {
    __type: "VpcPeeringConnection",
    AccepterVpcInfo: undefined,
    ExpirationTime: undefined,
    RequesterVpcInfo: undefined,
    Status: undefined,
    Tags: undefined,
    VpcPeeringConnectionId: undefined
  };
  if (output["accepterVpcInfo"] !== undefined) {
    contents.AccepterVpcInfo = deserializeAws_ec2VpcPeeringConnectionVpcInfo(
      output["accepterVpcInfo"],
      context
    );
  }
  if (output["expirationTime"] !== undefined) {
    contents.ExpirationTime = new Date(output["expirationTime"]);
  }
  if (output["requesterVpcInfo"] !== undefined) {
    contents.RequesterVpcInfo = deserializeAws_ec2VpcPeeringConnectionVpcInfo(
      output["requesterVpcInfo"],
      context
    );
  }
  if (output["status"] !== undefined) {
    contents.Status = deserializeAws_ec2VpcPeeringConnectionStateReason(
      output["status"],
      context
    );
  }
  if (output.tagSet === "") {
    contents.Tags = [];
  }
  if (
    output["tagSet"] !== undefined &&
    output["tagSet"]["item"] !== undefined
  ) {
    contents.Tags = deserializeAws_ec2TagList(
      __getArrayIfSingleItem(output["tagSet"]["item"]),
      context
    );
  }
  if (output["vpcPeeringConnectionId"] !== undefined) {
    contents.VpcPeeringConnectionId = output["vpcPeeringConnectionId"];
  }
  return contents;
};

const deserializeAws_ec2VpcPeeringConnectionList = (
  output: any,
  context: __SerdeContext
): VpcPeeringConnection[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2VpcPeeringConnection(entry, context)
  );
};

const deserializeAws_ec2VpcPeeringConnectionOptionsDescription = (
  output: any,
  context: __SerdeContext
): VpcPeeringConnectionOptionsDescription => {
  let contents: any = {
    __type: "VpcPeeringConnectionOptionsDescription",
    AllowDnsResolutionFromRemoteVpc: undefined,
    AllowEgressFromLocalClassicLinkToRemoteVpc: undefined,
    AllowEgressFromLocalVpcToRemoteClassicLink: undefined
  };
  if (output["allowDnsResolutionFromRemoteVpc"] !== undefined) {
    contents.AllowDnsResolutionFromRemoteVpc =
      output["allowDnsResolutionFromRemoteVpc"] == "true";
  }
  if (output["allowEgressFromLocalClassicLinkToRemoteVpc"] !== undefined) {
    contents.AllowEgressFromLocalClassicLinkToRemoteVpc =
      output["allowEgressFromLocalClassicLinkToRemoteVpc"] == "true";
  }
  if (output["allowEgressFromLocalVpcToRemoteClassicLink"] !== undefined) {
    contents.AllowEgressFromLocalVpcToRemoteClassicLink =
      output["allowEgressFromLocalVpcToRemoteClassicLink"] == "true";
  }
  return contents;
};

const deserializeAws_ec2VpcPeeringConnectionStateReason = (
  output: any,
  context: __SerdeContext
): VpcPeeringConnectionStateReason => {
  let contents: any = {
    __type: "VpcPeeringConnectionStateReason",
    Code: undefined,
    Message: undefined
  };
  if (output["code"] !== undefined) {
    contents.Code = output["code"];
  }
  if (output["message"] !== undefined) {
    contents.Message = output["message"];
  }
  return contents;
};

const deserializeAws_ec2VpcPeeringConnectionVpcInfo = (
  output: any,
  context: __SerdeContext
): VpcPeeringConnectionVpcInfo => {
  let contents: any = {
    __type: "VpcPeeringConnectionVpcInfo",
    CidrBlock: undefined,
    CidrBlockSet: undefined,
    Ipv6CidrBlockSet: undefined,
    OwnerId: undefined,
    PeeringOptions: undefined,
    Region: undefined,
    VpcId: undefined
  };
  if (output["cidrBlock"] !== undefined) {
    contents.CidrBlock = output["cidrBlock"];
  }
  if (output.cidrBlockSet === "") {
    contents.CidrBlockSet = [];
  }
  if (
    output["cidrBlockSet"] !== undefined &&
    output["cidrBlockSet"]["item"] !== undefined
  ) {
    contents.CidrBlockSet = deserializeAws_ec2CidrBlockSet(
      __getArrayIfSingleItem(output["cidrBlockSet"]["item"]),
      context
    );
  }
  if (output.ipv6CidrBlockSet === "") {
    contents.Ipv6CidrBlockSet = [];
  }
  if (
    output["ipv6CidrBlockSet"] !== undefined &&
    output["ipv6CidrBlockSet"]["item"] !== undefined
  ) {
    contents.Ipv6CidrBlockSet = deserializeAws_ec2Ipv6CidrBlockSet(
      __getArrayIfSingleItem(output["ipv6CidrBlockSet"]["item"]),
      context
    );
  }
  if (output["ownerId"] !== undefined) {
    contents.OwnerId = output["ownerId"];
  }
  if (output["peeringOptions"] !== undefined) {
    contents.PeeringOptions = deserializeAws_ec2VpcPeeringConnectionOptionsDescription(
      output["peeringOptions"],
      context
    );
  }
  if (output["region"] !== undefined) {
    contents.Region = output["region"];
  }
  if (output["vpcId"] !== undefined) {
    contents.VpcId = output["vpcId"];
  }
  return contents;
};

const deserializeAws_ec2VpnConnection = (
  output: any,
  context: __SerdeContext
): VpnConnection => {
  let contents: any = {
    __type: "VpnConnection",
    Category: undefined,
    CustomerGatewayConfiguration: undefined,
    CustomerGatewayId: undefined,
    Options: undefined,
    Routes: undefined,
    State: undefined,
    Tags: undefined,
    TransitGatewayId: undefined,
    Type: undefined,
    VgwTelemetry: undefined,
    VpnConnectionId: undefined,
    VpnGatewayId: undefined
  };
  if (output["category"] !== undefined) {
    contents.Category = output["category"];
  }
  if (output["customerGatewayConfiguration"] !== undefined) {
    contents.CustomerGatewayConfiguration =
      output["customerGatewayConfiguration"];
  }
  if (output["customerGatewayId"] !== undefined) {
    contents.CustomerGatewayId = output["customerGatewayId"];
  }
  if (output["options"] !== undefined) {
    contents.Options = deserializeAws_ec2VpnConnectionOptions(
      output["options"],
      context
    );
  }
  if (output.routes === "") {
    contents.Routes = [];
  }
  if (
    output["routes"] !== undefined &&
    output["routes"]["item"] !== undefined
  ) {
    contents.Routes = deserializeAws_ec2VpnStaticRouteList(
      __getArrayIfSingleItem(output["routes"]["item"]),
      context
    );
  }
  if (output["state"] !== undefined) {
    contents.State = output["state"];
  }
  if (output.tagSet === "") {
    contents.Tags = [];
  }
  if (
    output["tagSet"] !== undefined &&
    output["tagSet"]["item"] !== undefined
  ) {
    contents.Tags = deserializeAws_ec2TagList(
      __getArrayIfSingleItem(output["tagSet"]["item"]),
      context
    );
  }
  if (output["transitGatewayId"] !== undefined) {
    contents.TransitGatewayId = output["transitGatewayId"];
  }
  if (output["type"] !== undefined) {
    contents.Type = output["type"];
  }
  if (output.vgwTelemetry === "") {
    contents.VgwTelemetry = [];
  }
  if (
    output["vgwTelemetry"] !== undefined &&
    output["vgwTelemetry"]["item"] !== undefined
  ) {
    contents.VgwTelemetry = deserializeAws_ec2VgwTelemetryList(
      __getArrayIfSingleItem(output["vgwTelemetry"]["item"]),
      context
    );
  }
  if (output["vpnConnectionId"] !== undefined) {
    contents.VpnConnectionId = output["vpnConnectionId"];
  }
  if (output["vpnGatewayId"] !== undefined) {
    contents.VpnGatewayId = output["vpnGatewayId"];
  }
  return contents;
};

const deserializeAws_ec2VpnConnectionList = (
  output: any,
  context: __SerdeContext
): VpnConnection[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2VpnConnection(entry, context)
  );
};

const deserializeAws_ec2VpnConnectionOptions = (
  output: any,
  context: __SerdeContext
): VpnConnectionOptions => {
  let contents: any = {
    __type: "VpnConnectionOptions",
    EnableAcceleration: undefined,
    StaticRoutesOnly: undefined,
    TunnelOptions: undefined
  };
  if (output["enableAcceleration"] !== undefined) {
    contents.EnableAcceleration = output["enableAcceleration"] == "true";
  }
  if (output["staticRoutesOnly"] !== undefined) {
    contents.StaticRoutesOnly = output["staticRoutesOnly"] == "true";
  }
  if (output.tunnelOptionSet === "") {
    contents.TunnelOptions = [];
  }
  if (
    output["tunnelOptionSet"] !== undefined &&
    output["tunnelOptionSet"]["item"] !== undefined
  ) {
    contents.TunnelOptions = deserializeAws_ec2TunnelOptionsList(
      __getArrayIfSingleItem(output["tunnelOptionSet"]["item"]),
      context
    );
  }
  return contents;
};

const deserializeAws_ec2VpnGateway = (
  output: any,
  context: __SerdeContext
): VpnGateway => {
  let contents: any = {
    __type: "VpnGateway",
    AmazonSideAsn: undefined,
    AvailabilityZone: undefined,
    State: undefined,
    Tags: undefined,
    Type: undefined,
    VpcAttachments: undefined,
    VpnGatewayId: undefined
  };
  if (output["amazonSideAsn"] !== undefined) {
    contents.AmazonSideAsn = parseInt(output["amazonSideAsn"]);
  }
  if (output["availabilityZone"] !== undefined) {
    contents.AvailabilityZone = output["availabilityZone"];
  }
  if (output["state"] !== undefined) {
    contents.State = output["state"];
  }
  if (output.tagSet === "") {
    contents.Tags = [];
  }
  if (
    output["tagSet"] !== undefined &&
    output["tagSet"]["item"] !== undefined
  ) {
    contents.Tags = deserializeAws_ec2TagList(
      __getArrayIfSingleItem(output["tagSet"]["item"]),
      context
    );
  }
  if (output["type"] !== undefined) {
    contents.Type = output["type"];
  }
  if (output.attachments === "") {
    contents.VpcAttachments = [];
  }
  if (
    output["attachments"] !== undefined &&
    output["attachments"]["item"] !== undefined
  ) {
    contents.VpcAttachments = deserializeAws_ec2VpcAttachmentList(
      __getArrayIfSingleItem(output["attachments"]["item"]),
      context
    );
  }
  if (output["vpnGatewayId"] !== undefined) {
    contents.VpnGatewayId = output["vpnGatewayId"];
  }
  return contents;
};

const deserializeAws_ec2VpnGatewayList = (
  output: any,
  context: __SerdeContext
): VpnGateway[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2VpnGateway(entry, context)
  );
};

const deserializeAws_ec2VpnStaticRoute = (
  output: any,
  context: __SerdeContext
): VpnStaticRoute => {
  let contents: any = {
    __type: "VpnStaticRoute",
    DestinationCidrBlock: undefined,
    Source: undefined,
    State: undefined
  };
  if (output["destinationCidrBlock"] !== undefined) {
    contents.DestinationCidrBlock = output["destinationCidrBlock"];
  }
  if (output["source"] !== undefined) {
    contents.Source = output["source"];
  }
  if (output["state"] !== undefined) {
    contents.State = output["state"];
  }
  return contents;
};

const deserializeAws_ec2VpnStaticRouteList = (
  output: any,
  context: __SerdeContext
): VpnStaticRoute[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_ec2VpnStaticRoute(entry, context)
  );
};

const deserializeAws_ec2WithdrawByoipCidrResult = (
  output: any,
  context: __SerdeContext
): WithdrawByoipCidrResult => {
  let contents: any = {
    __type: "WithdrawByoipCidrResult",
    ByoipCidr: undefined
  };
  if (output["byoipCidr"] !== undefined) {
    contents.ByoipCidr = deserializeAws_ec2ByoipCidr(
      output["byoipCidr"],
      context
    );
  }
  return contents;
};

const deserializeMetadata = (output: __HttpResponse): __ResponseMetadata => ({
  httpStatusCode: output.statusCode,
  httpHeaders: output.headers,
  requestId: output.headers["x-amzn-requestid"]
});

// Collect low-level response body stream to Uint8Array.
const collectBody = (
  streamBody: any = new Uint8Array(),
  context: __SerdeContext
): Promise<Uint8Array> => {
  if (streamBody instanceof Uint8Array) {
    return Promise.resolve(streamBody);
  }
  return (
    context.streamCollector(streamBody) || Promise.resolve(new Uint8Array())
  );
};

// Encode Uint8Array data into string with utf-8.
const collectBodyString = (
  streamBody: any,
  context: __SerdeContext
): Promise<string> =>
  collectBody(streamBody, context).then(body => context.utf8Encoder(body));

const buildHttpRpcRequest = async (
  context: __SerdeContext,
  headers: __HeaderBag,
  path: string,
  resolvedHostname: string | undefined,
  body: any
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port } = await context.endpoint();
  const contents: any = {
    protocol,
    hostname,
    port,
    method: "POST",
    path,
    headers
  };
  if (resolvedHostname !== undefined) {
    contents.hostname = resolvedHostname;
  }
  if (body !== undefined) {
    contents.body = body;
  }
  return new __HttpRequest(contents);
};

const decodeEscapedXML = (str: string) =>
  str
    .replace(/&amp;/g, "&")
    .replace(/&apos;/g, "'")
    .replace(/&quot;/g, '"')
    .replace(/&gt;/g, ">")
    .replace(/&lt;/g, "<");

const parseBody = (streamBody: any, context: __SerdeContext): any =>
  collectBodyString(streamBody, context).then(encoded => {
    if (encoded.length) {
      const parsedObj = xmlParse(encoded, {
        attributeNamePrefix: "",
        ignoreAttributes: false,
        parseNodeValue: false,
        tagValueProcessor: (val, tagName) => decodeEscapedXML(val)
      });
      const textNodeName = "#text";
      const key = Object.keys(parsedObj)[0];
      const parsedObjToReturn = parsedObj[key];
      if (parsedObjToReturn[textNodeName]) {
        parsedObjToReturn[key] = parsedObjToReturn[textNodeName];
        delete parsedObjToReturn[textNodeName];
      }
      return __getValueFromTextNode(parsedObjToReturn);
    }
    return {};
  });

const buildFormUrlencodedString = (formEntries: {
  [key: string]: string;
}): string =>
  Object.entries(formEntries)
    .map(
      ([key, value]) =>
        __extendedEncodeURIComponent(key) +
        "=" +
        __extendedEncodeURIComponent(value)
    )
    .join("&");

const loadEc2ErrorCode = (output: __HttpResponse, data: any): string => {
  if (data.Errors.Error.Code !== undefined) {
    return data.Errors.Error.Code;
  }
  if (output.statusCode == 404) {
    return "NotFound";
  }
  return "";
};
