"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const protocol_http_1 = require("@aws-sdk/protocol-http");
const smithy_client_1 = require("@aws-sdk/smithy-client");
const fast_xml_parser_1 = require("fast-xml-parser");
const uuid_1 = require("uuid");
async function serializeAws_ec2AcceptReservedInstancesExchangeQuoteCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2AcceptReservedInstancesExchangeQuoteRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "AcceptReservedInstancesExchangeQuote", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2AcceptReservedInstancesExchangeQuoteCommand = serializeAws_ec2AcceptReservedInstancesExchangeQuoteCommand;
async function serializeAws_ec2AcceptTransitGatewayPeeringAttachmentCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2AcceptTransitGatewayPeeringAttachmentRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "AcceptTransitGatewayPeeringAttachment", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2AcceptTransitGatewayPeeringAttachmentCommand = serializeAws_ec2AcceptTransitGatewayPeeringAttachmentCommand;
async function serializeAws_ec2AcceptTransitGatewayVpcAttachmentCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2AcceptTransitGatewayVpcAttachmentRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "AcceptTransitGatewayVpcAttachment", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2AcceptTransitGatewayVpcAttachmentCommand = serializeAws_ec2AcceptTransitGatewayVpcAttachmentCommand;
async function serializeAws_ec2AcceptVpcEndpointConnectionsCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2AcceptVpcEndpointConnectionsRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "AcceptVpcEndpointConnections", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2AcceptVpcEndpointConnectionsCommand = serializeAws_ec2AcceptVpcEndpointConnectionsCommand;
async function serializeAws_ec2AcceptVpcPeeringConnectionCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2AcceptVpcPeeringConnectionRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "AcceptVpcPeeringConnection", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2AcceptVpcPeeringConnectionCommand = serializeAws_ec2AcceptVpcPeeringConnectionCommand;
async function serializeAws_ec2AdvertiseByoipCidrCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2AdvertiseByoipCidrRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "AdvertiseByoipCidr", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2AdvertiseByoipCidrCommand = serializeAws_ec2AdvertiseByoipCidrCommand;
async function serializeAws_ec2AllocateAddressCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2AllocateAddressRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "AllocateAddress", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2AllocateAddressCommand = serializeAws_ec2AllocateAddressCommand;
async function serializeAws_ec2AllocateHostsCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2AllocateHostsRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "AllocateHosts", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2AllocateHostsCommand = serializeAws_ec2AllocateHostsCommand;
async function serializeAws_ec2ApplySecurityGroupsToClientVpnTargetNetworkCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2ApplySecurityGroupsToClientVpnTargetNetworkRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "ApplySecurityGroupsToClientVpnTargetNetwork", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2ApplySecurityGroupsToClientVpnTargetNetworkCommand = serializeAws_ec2ApplySecurityGroupsToClientVpnTargetNetworkCommand;
async function serializeAws_ec2AssignIpv6AddressesCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2AssignIpv6AddressesRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "AssignIpv6Addresses", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2AssignIpv6AddressesCommand = serializeAws_ec2AssignIpv6AddressesCommand;
async function serializeAws_ec2AssignPrivateIpAddressesCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2AssignPrivateIpAddressesRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "AssignPrivateIpAddresses", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2AssignPrivateIpAddressesCommand = serializeAws_ec2AssignPrivateIpAddressesCommand;
async function serializeAws_ec2AssociateAddressCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2AssociateAddressRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "AssociateAddress", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2AssociateAddressCommand = serializeAws_ec2AssociateAddressCommand;
async function serializeAws_ec2AssociateClientVpnTargetNetworkCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2AssociateClientVpnTargetNetworkRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "AssociateClientVpnTargetNetwork", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2AssociateClientVpnTargetNetworkCommand = serializeAws_ec2AssociateClientVpnTargetNetworkCommand;
async function serializeAws_ec2AssociateDhcpOptionsCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2AssociateDhcpOptionsRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "AssociateDhcpOptions", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2AssociateDhcpOptionsCommand = serializeAws_ec2AssociateDhcpOptionsCommand;
async function serializeAws_ec2AssociateIamInstanceProfileCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2AssociateIamInstanceProfileRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "AssociateIamInstanceProfile", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2AssociateIamInstanceProfileCommand = serializeAws_ec2AssociateIamInstanceProfileCommand;
async function serializeAws_ec2AssociateRouteTableCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2AssociateRouteTableRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "AssociateRouteTable", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2AssociateRouteTableCommand = serializeAws_ec2AssociateRouteTableCommand;
async function serializeAws_ec2AssociateSubnetCidrBlockCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2AssociateSubnetCidrBlockRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "AssociateSubnetCidrBlock", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2AssociateSubnetCidrBlockCommand = serializeAws_ec2AssociateSubnetCidrBlockCommand;
async function serializeAws_ec2AssociateTransitGatewayMulticastDomainCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2AssociateTransitGatewayMulticastDomainRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "AssociateTransitGatewayMulticastDomain", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2AssociateTransitGatewayMulticastDomainCommand = serializeAws_ec2AssociateTransitGatewayMulticastDomainCommand;
async function serializeAws_ec2AssociateTransitGatewayRouteTableCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2AssociateTransitGatewayRouteTableRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "AssociateTransitGatewayRouteTable", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2AssociateTransitGatewayRouteTableCommand = serializeAws_ec2AssociateTransitGatewayRouteTableCommand;
async function serializeAws_ec2AssociateVpcCidrBlockCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2AssociateVpcCidrBlockRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "AssociateVpcCidrBlock", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2AssociateVpcCidrBlockCommand = serializeAws_ec2AssociateVpcCidrBlockCommand;
async function serializeAws_ec2AttachClassicLinkVpcCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2AttachClassicLinkVpcRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "AttachClassicLinkVpc", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2AttachClassicLinkVpcCommand = serializeAws_ec2AttachClassicLinkVpcCommand;
async function serializeAws_ec2AttachInternetGatewayCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2AttachInternetGatewayRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "AttachInternetGateway", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2AttachInternetGatewayCommand = serializeAws_ec2AttachInternetGatewayCommand;
async function serializeAws_ec2AttachNetworkInterfaceCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2AttachNetworkInterfaceRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "AttachNetworkInterface", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2AttachNetworkInterfaceCommand = serializeAws_ec2AttachNetworkInterfaceCommand;
async function serializeAws_ec2AttachVolumeCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2AttachVolumeRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "AttachVolume", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2AttachVolumeCommand = serializeAws_ec2AttachVolumeCommand;
async function serializeAws_ec2AttachVpnGatewayCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2AttachVpnGatewayRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "AttachVpnGateway", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2AttachVpnGatewayCommand = serializeAws_ec2AttachVpnGatewayCommand;
async function serializeAws_ec2AuthorizeClientVpnIngressCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2AuthorizeClientVpnIngressRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "AuthorizeClientVpnIngress", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2AuthorizeClientVpnIngressCommand = serializeAws_ec2AuthorizeClientVpnIngressCommand;
async function serializeAws_ec2AuthorizeSecurityGroupEgressCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2AuthorizeSecurityGroupEgressRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "AuthorizeSecurityGroupEgress", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2AuthorizeSecurityGroupEgressCommand = serializeAws_ec2AuthorizeSecurityGroupEgressCommand;
async function serializeAws_ec2AuthorizeSecurityGroupIngressCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2AuthorizeSecurityGroupIngressRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "AuthorizeSecurityGroupIngress", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2AuthorizeSecurityGroupIngressCommand = serializeAws_ec2AuthorizeSecurityGroupIngressCommand;
async function serializeAws_ec2BundleInstanceCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2BundleInstanceRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "BundleInstance", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2BundleInstanceCommand = serializeAws_ec2BundleInstanceCommand;
async function serializeAws_ec2CancelBundleTaskCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2CancelBundleTaskRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "CancelBundleTask", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2CancelBundleTaskCommand = serializeAws_ec2CancelBundleTaskCommand;
async function serializeAws_ec2CancelCapacityReservationCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2CancelCapacityReservationRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "CancelCapacityReservation", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2CancelCapacityReservationCommand = serializeAws_ec2CancelCapacityReservationCommand;
async function serializeAws_ec2CancelConversionTaskCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2CancelConversionRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "CancelConversionTask", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2CancelConversionTaskCommand = serializeAws_ec2CancelConversionTaskCommand;
async function serializeAws_ec2CancelExportTaskCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2CancelExportTaskRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "CancelExportTask", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2CancelExportTaskCommand = serializeAws_ec2CancelExportTaskCommand;
async function serializeAws_ec2CancelImportTaskCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2CancelImportTaskRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "CancelImportTask", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2CancelImportTaskCommand = serializeAws_ec2CancelImportTaskCommand;
async function serializeAws_ec2CancelReservedInstancesListingCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2CancelReservedInstancesListingRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "CancelReservedInstancesListing", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2CancelReservedInstancesListingCommand = serializeAws_ec2CancelReservedInstancesListingCommand;
async function serializeAws_ec2CancelSpotFleetRequestsCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2CancelSpotFleetRequestsRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "CancelSpotFleetRequests", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2CancelSpotFleetRequestsCommand = serializeAws_ec2CancelSpotFleetRequestsCommand;
async function serializeAws_ec2CancelSpotInstanceRequestsCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2CancelSpotInstanceRequestsRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "CancelSpotInstanceRequests", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2CancelSpotInstanceRequestsCommand = serializeAws_ec2CancelSpotInstanceRequestsCommand;
async function serializeAws_ec2ConfirmProductInstanceCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2ConfirmProductInstanceRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "ConfirmProductInstance", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2ConfirmProductInstanceCommand = serializeAws_ec2ConfirmProductInstanceCommand;
async function serializeAws_ec2CopyFpgaImageCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2CopyFpgaImageRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "CopyFpgaImage", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2CopyFpgaImageCommand = serializeAws_ec2CopyFpgaImageCommand;
async function serializeAws_ec2CopyImageCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2CopyImageRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "CopyImage", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2CopyImageCommand = serializeAws_ec2CopyImageCommand;
async function serializeAws_ec2CopySnapshotCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2CopySnapshotRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "CopySnapshot", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2CopySnapshotCommand = serializeAws_ec2CopySnapshotCommand;
async function serializeAws_ec2CreateCapacityReservationCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2CreateCapacityReservationRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "CreateCapacityReservation", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2CreateCapacityReservationCommand = serializeAws_ec2CreateCapacityReservationCommand;
async function serializeAws_ec2CreateClientVpnEndpointCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2CreateClientVpnEndpointRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "CreateClientVpnEndpoint", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2CreateClientVpnEndpointCommand = serializeAws_ec2CreateClientVpnEndpointCommand;
async function serializeAws_ec2CreateClientVpnRouteCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2CreateClientVpnRouteRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "CreateClientVpnRoute", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2CreateClientVpnRouteCommand = serializeAws_ec2CreateClientVpnRouteCommand;
async function serializeAws_ec2CreateCustomerGatewayCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2CreateCustomerGatewayRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "CreateCustomerGateway", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2CreateCustomerGatewayCommand = serializeAws_ec2CreateCustomerGatewayCommand;
async function serializeAws_ec2CreateDefaultSubnetCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2CreateDefaultSubnetRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "CreateDefaultSubnet", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2CreateDefaultSubnetCommand = serializeAws_ec2CreateDefaultSubnetCommand;
async function serializeAws_ec2CreateDefaultVpcCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2CreateDefaultVpcRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "CreateDefaultVpc", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2CreateDefaultVpcCommand = serializeAws_ec2CreateDefaultVpcCommand;
async function serializeAws_ec2CreateDhcpOptionsCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2CreateDhcpOptionsRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "CreateDhcpOptions", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2CreateDhcpOptionsCommand = serializeAws_ec2CreateDhcpOptionsCommand;
async function serializeAws_ec2CreateEgressOnlyInternetGatewayCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2CreateEgressOnlyInternetGatewayRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "CreateEgressOnlyInternetGateway", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2CreateEgressOnlyInternetGatewayCommand = serializeAws_ec2CreateEgressOnlyInternetGatewayCommand;
async function serializeAws_ec2CreateFleetCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2CreateFleetRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "CreateFleet", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2CreateFleetCommand = serializeAws_ec2CreateFleetCommand;
async function serializeAws_ec2CreateFlowLogsCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2CreateFlowLogsRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "CreateFlowLogs", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2CreateFlowLogsCommand = serializeAws_ec2CreateFlowLogsCommand;
async function serializeAws_ec2CreateFpgaImageCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2CreateFpgaImageRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "CreateFpgaImage", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2CreateFpgaImageCommand = serializeAws_ec2CreateFpgaImageCommand;
async function serializeAws_ec2CreateImageCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2CreateImageRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "CreateImage", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2CreateImageCommand = serializeAws_ec2CreateImageCommand;
async function serializeAws_ec2CreateInstanceExportTaskCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2CreateInstanceExportTaskRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "CreateInstanceExportTask", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2CreateInstanceExportTaskCommand = serializeAws_ec2CreateInstanceExportTaskCommand;
async function serializeAws_ec2CreateInternetGatewayCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2CreateInternetGatewayRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "CreateInternetGateway", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2CreateInternetGatewayCommand = serializeAws_ec2CreateInternetGatewayCommand;
async function serializeAws_ec2CreateKeyPairCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2CreateKeyPairRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "CreateKeyPair", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2CreateKeyPairCommand = serializeAws_ec2CreateKeyPairCommand;
async function serializeAws_ec2CreateLaunchTemplateCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2CreateLaunchTemplateRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "CreateLaunchTemplate", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2CreateLaunchTemplateCommand = serializeAws_ec2CreateLaunchTemplateCommand;
async function serializeAws_ec2CreateLaunchTemplateVersionCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2CreateLaunchTemplateVersionRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "CreateLaunchTemplateVersion", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2CreateLaunchTemplateVersionCommand = serializeAws_ec2CreateLaunchTemplateVersionCommand;
async function serializeAws_ec2CreateLocalGatewayRouteCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2CreateLocalGatewayRouteRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "CreateLocalGatewayRoute", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2CreateLocalGatewayRouteCommand = serializeAws_ec2CreateLocalGatewayRouteCommand;
async function serializeAws_ec2CreateLocalGatewayRouteTableVpcAssociationCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2CreateLocalGatewayRouteTableVpcAssociationRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "CreateLocalGatewayRouteTableVpcAssociation", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2CreateLocalGatewayRouteTableVpcAssociationCommand = serializeAws_ec2CreateLocalGatewayRouteTableVpcAssociationCommand;
async function serializeAws_ec2CreateNatGatewayCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2CreateNatGatewayRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "CreateNatGateway", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2CreateNatGatewayCommand = serializeAws_ec2CreateNatGatewayCommand;
async function serializeAws_ec2CreateNetworkAclCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2CreateNetworkAclRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "CreateNetworkAcl", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2CreateNetworkAclCommand = serializeAws_ec2CreateNetworkAclCommand;
async function serializeAws_ec2CreateNetworkAclEntryCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2CreateNetworkAclEntryRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "CreateNetworkAclEntry", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2CreateNetworkAclEntryCommand = serializeAws_ec2CreateNetworkAclEntryCommand;
async function serializeAws_ec2CreateNetworkInterfaceCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2CreateNetworkInterfaceRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "CreateNetworkInterface", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2CreateNetworkInterfaceCommand = serializeAws_ec2CreateNetworkInterfaceCommand;
async function serializeAws_ec2CreateNetworkInterfacePermissionCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2CreateNetworkInterfacePermissionRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "CreateNetworkInterfacePermission", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2CreateNetworkInterfacePermissionCommand = serializeAws_ec2CreateNetworkInterfacePermissionCommand;
async function serializeAws_ec2CreatePlacementGroupCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2CreatePlacementGroupRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "CreatePlacementGroup", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2CreatePlacementGroupCommand = serializeAws_ec2CreatePlacementGroupCommand;
async function serializeAws_ec2CreateReservedInstancesListingCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2CreateReservedInstancesListingRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "CreateReservedInstancesListing", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2CreateReservedInstancesListingCommand = serializeAws_ec2CreateReservedInstancesListingCommand;
async function serializeAws_ec2CreateRouteCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2CreateRouteRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "CreateRoute", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2CreateRouteCommand = serializeAws_ec2CreateRouteCommand;
async function serializeAws_ec2CreateRouteTableCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2CreateRouteTableRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "CreateRouteTable", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2CreateRouteTableCommand = serializeAws_ec2CreateRouteTableCommand;
async function serializeAws_ec2CreateSecurityGroupCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2CreateSecurityGroupRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "CreateSecurityGroup", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2CreateSecurityGroupCommand = serializeAws_ec2CreateSecurityGroupCommand;
async function serializeAws_ec2CreateSnapshotCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2CreateSnapshotRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "CreateSnapshot", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2CreateSnapshotCommand = serializeAws_ec2CreateSnapshotCommand;
async function serializeAws_ec2CreateSnapshotsCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2CreateSnapshotsRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "CreateSnapshots", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2CreateSnapshotsCommand = serializeAws_ec2CreateSnapshotsCommand;
async function serializeAws_ec2CreateSpotDatafeedSubscriptionCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2CreateSpotDatafeedSubscriptionRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "CreateSpotDatafeedSubscription", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2CreateSpotDatafeedSubscriptionCommand = serializeAws_ec2CreateSpotDatafeedSubscriptionCommand;
async function serializeAws_ec2CreateSubnetCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2CreateSubnetRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "CreateSubnet", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2CreateSubnetCommand = serializeAws_ec2CreateSubnetCommand;
async function serializeAws_ec2CreateTagsCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2CreateTagsRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "CreateTags", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2CreateTagsCommand = serializeAws_ec2CreateTagsCommand;
async function serializeAws_ec2CreateTrafficMirrorFilterCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2CreateTrafficMirrorFilterRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "CreateTrafficMirrorFilter", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2CreateTrafficMirrorFilterCommand = serializeAws_ec2CreateTrafficMirrorFilterCommand;
async function serializeAws_ec2CreateTrafficMirrorFilterRuleCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2CreateTrafficMirrorFilterRuleRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "CreateTrafficMirrorFilterRule", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2CreateTrafficMirrorFilterRuleCommand = serializeAws_ec2CreateTrafficMirrorFilterRuleCommand;
async function serializeAws_ec2CreateTrafficMirrorSessionCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2CreateTrafficMirrorSessionRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "CreateTrafficMirrorSession", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2CreateTrafficMirrorSessionCommand = serializeAws_ec2CreateTrafficMirrorSessionCommand;
async function serializeAws_ec2CreateTrafficMirrorTargetCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2CreateTrafficMirrorTargetRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "CreateTrafficMirrorTarget", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2CreateTrafficMirrorTargetCommand = serializeAws_ec2CreateTrafficMirrorTargetCommand;
async function serializeAws_ec2CreateTransitGatewayCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2CreateTransitGatewayRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "CreateTransitGateway", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2CreateTransitGatewayCommand = serializeAws_ec2CreateTransitGatewayCommand;
async function serializeAws_ec2CreateTransitGatewayMulticastDomainCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2CreateTransitGatewayMulticastDomainRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "CreateTransitGatewayMulticastDomain", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2CreateTransitGatewayMulticastDomainCommand = serializeAws_ec2CreateTransitGatewayMulticastDomainCommand;
async function serializeAws_ec2CreateTransitGatewayPeeringAttachmentCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2CreateTransitGatewayPeeringAttachmentRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "CreateTransitGatewayPeeringAttachment", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2CreateTransitGatewayPeeringAttachmentCommand = serializeAws_ec2CreateTransitGatewayPeeringAttachmentCommand;
async function serializeAws_ec2CreateTransitGatewayRouteCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2CreateTransitGatewayRouteRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "CreateTransitGatewayRoute", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2CreateTransitGatewayRouteCommand = serializeAws_ec2CreateTransitGatewayRouteCommand;
async function serializeAws_ec2CreateTransitGatewayRouteTableCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2CreateTransitGatewayRouteTableRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "CreateTransitGatewayRouteTable", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2CreateTransitGatewayRouteTableCommand = serializeAws_ec2CreateTransitGatewayRouteTableCommand;
async function serializeAws_ec2CreateTransitGatewayVpcAttachmentCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2CreateTransitGatewayVpcAttachmentRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "CreateTransitGatewayVpcAttachment", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2CreateTransitGatewayVpcAttachmentCommand = serializeAws_ec2CreateTransitGatewayVpcAttachmentCommand;
async function serializeAws_ec2CreateVolumeCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2CreateVolumeRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "CreateVolume", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2CreateVolumeCommand = serializeAws_ec2CreateVolumeCommand;
async function serializeAws_ec2CreateVpcCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2CreateVpcRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "CreateVpc", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2CreateVpcCommand = serializeAws_ec2CreateVpcCommand;
async function serializeAws_ec2CreateVpcEndpointCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2CreateVpcEndpointRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "CreateVpcEndpoint", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2CreateVpcEndpointCommand = serializeAws_ec2CreateVpcEndpointCommand;
async function serializeAws_ec2CreateVpcEndpointConnectionNotificationCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2CreateVpcEndpointConnectionNotificationRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "CreateVpcEndpointConnectionNotification", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2CreateVpcEndpointConnectionNotificationCommand = serializeAws_ec2CreateVpcEndpointConnectionNotificationCommand;
async function serializeAws_ec2CreateVpcEndpointServiceConfigurationCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2CreateVpcEndpointServiceConfigurationRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "CreateVpcEndpointServiceConfiguration", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2CreateVpcEndpointServiceConfigurationCommand = serializeAws_ec2CreateVpcEndpointServiceConfigurationCommand;
async function serializeAws_ec2CreateVpcPeeringConnectionCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2CreateVpcPeeringConnectionRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "CreateVpcPeeringConnection", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2CreateVpcPeeringConnectionCommand = serializeAws_ec2CreateVpcPeeringConnectionCommand;
async function serializeAws_ec2CreateVpnConnectionCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2CreateVpnConnectionRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "CreateVpnConnection", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2CreateVpnConnectionCommand = serializeAws_ec2CreateVpnConnectionCommand;
async function serializeAws_ec2CreateVpnConnectionRouteCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2CreateVpnConnectionRouteRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "CreateVpnConnectionRoute", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2CreateVpnConnectionRouteCommand = serializeAws_ec2CreateVpnConnectionRouteCommand;
async function serializeAws_ec2CreateVpnGatewayCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2CreateVpnGatewayRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "CreateVpnGateway", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2CreateVpnGatewayCommand = serializeAws_ec2CreateVpnGatewayCommand;
async function serializeAws_ec2DeleteClientVpnEndpointCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DeleteClientVpnEndpointRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DeleteClientVpnEndpoint", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DeleteClientVpnEndpointCommand = serializeAws_ec2DeleteClientVpnEndpointCommand;
async function serializeAws_ec2DeleteClientVpnRouteCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DeleteClientVpnRouteRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DeleteClientVpnRoute", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DeleteClientVpnRouteCommand = serializeAws_ec2DeleteClientVpnRouteCommand;
async function serializeAws_ec2DeleteCustomerGatewayCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DeleteCustomerGatewayRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DeleteCustomerGateway", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DeleteCustomerGatewayCommand = serializeAws_ec2DeleteCustomerGatewayCommand;
async function serializeAws_ec2DeleteDhcpOptionsCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DeleteDhcpOptionsRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DeleteDhcpOptions", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DeleteDhcpOptionsCommand = serializeAws_ec2DeleteDhcpOptionsCommand;
async function serializeAws_ec2DeleteEgressOnlyInternetGatewayCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DeleteEgressOnlyInternetGatewayRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DeleteEgressOnlyInternetGateway", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DeleteEgressOnlyInternetGatewayCommand = serializeAws_ec2DeleteEgressOnlyInternetGatewayCommand;
async function serializeAws_ec2DeleteFleetsCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DeleteFleetsRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DeleteFleets", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DeleteFleetsCommand = serializeAws_ec2DeleteFleetsCommand;
async function serializeAws_ec2DeleteFlowLogsCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DeleteFlowLogsRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DeleteFlowLogs", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DeleteFlowLogsCommand = serializeAws_ec2DeleteFlowLogsCommand;
async function serializeAws_ec2DeleteFpgaImageCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DeleteFpgaImageRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DeleteFpgaImage", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DeleteFpgaImageCommand = serializeAws_ec2DeleteFpgaImageCommand;
async function serializeAws_ec2DeleteInternetGatewayCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DeleteInternetGatewayRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DeleteInternetGateway", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DeleteInternetGatewayCommand = serializeAws_ec2DeleteInternetGatewayCommand;
async function serializeAws_ec2DeleteKeyPairCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DeleteKeyPairRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DeleteKeyPair", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DeleteKeyPairCommand = serializeAws_ec2DeleteKeyPairCommand;
async function serializeAws_ec2DeleteLaunchTemplateCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DeleteLaunchTemplateRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DeleteLaunchTemplate", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DeleteLaunchTemplateCommand = serializeAws_ec2DeleteLaunchTemplateCommand;
async function serializeAws_ec2DeleteLaunchTemplateVersionsCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DeleteLaunchTemplateVersionsRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DeleteLaunchTemplateVersions", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DeleteLaunchTemplateVersionsCommand = serializeAws_ec2DeleteLaunchTemplateVersionsCommand;
async function serializeAws_ec2DeleteLocalGatewayRouteCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DeleteLocalGatewayRouteRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DeleteLocalGatewayRoute", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DeleteLocalGatewayRouteCommand = serializeAws_ec2DeleteLocalGatewayRouteCommand;
async function serializeAws_ec2DeleteLocalGatewayRouteTableVpcAssociationCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DeleteLocalGatewayRouteTableVpcAssociationRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DeleteLocalGatewayRouteTableVpcAssociation", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DeleteLocalGatewayRouteTableVpcAssociationCommand = serializeAws_ec2DeleteLocalGatewayRouteTableVpcAssociationCommand;
async function serializeAws_ec2DeleteNatGatewayCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DeleteNatGatewayRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DeleteNatGateway", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DeleteNatGatewayCommand = serializeAws_ec2DeleteNatGatewayCommand;
async function serializeAws_ec2DeleteNetworkAclCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DeleteNetworkAclRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DeleteNetworkAcl", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DeleteNetworkAclCommand = serializeAws_ec2DeleteNetworkAclCommand;
async function serializeAws_ec2DeleteNetworkAclEntryCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DeleteNetworkAclEntryRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DeleteNetworkAclEntry", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DeleteNetworkAclEntryCommand = serializeAws_ec2DeleteNetworkAclEntryCommand;
async function serializeAws_ec2DeleteNetworkInterfaceCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DeleteNetworkInterfaceRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DeleteNetworkInterface", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DeleteNetworkInterfaceCommand = serializeAws_ec2DeleteNetworkInterfaceCommand;
async function serializeAws_ec2DeleteNetworkInterfacePermissionCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DeleteNetworkInterfacePermissionRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DeleteNetworkInterfacePermission", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DeleteNetworkInterfacePermissionCommand = serializeAws_ec2DeleteNetworkInterfacePermissionCommand;
async function serializeAws_ec2DeletePlacementGroupCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DeletePlacementGroupRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DeletePlacementGroup", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DeletePlacementGroupCommand = serializeAws_ec2DeletePlacementGroupCommand;
async function serializeAws_ec2DeleteQueuedReservedInstancesCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DeleteQueuedReservedInstancesRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DeleteQueuedReservedInstances", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DeleteQueuedReservedInstancesCommand = serializeAws_ec2DeleteQueuedReservedInstancesCommand;
async function serializeAws_ec2DeleteRouteCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DeleteRouteRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DeleteRoute", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DeleteRouteCommand = serializeAws_ec2DeleteRouteCommand;
async function serializeAws_ec2DeleteRouteTableCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DeleteRouteTableRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DeleteRouteTable", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DeleteRouteTableCommand = serializeAws_ec2DeleteRouteTableCommand;
async function serializeAws_ec2DeleteSecurityGroupCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DeleteSecurityGroupRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DeleteSecurityGroup", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DeleteSecurityGroupCommand = serializeAws_ec2DeleteSecurityGroupCommand;
async function serializeAws_ec2DeleteSnapshotCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DeleteSnapshotRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DeleteSnapshot", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DeleteSnapshotCommand = serializeAws_ec2DeleteSnapshotCommand;
async function serializeAws_ec2DeleteSpotDatafeedSubscriptionCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DeleteSpotDatafeedSubscriptionRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DeleteSpotDatafeedSubscription", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DeleteSpotDatafeedSubscriptionCommand = serializeAws_ec2DeleteSpotDatafeedSubscriptionCommand;
async function serializeAws_ec2DeleteSubnetCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DeleteSubnetRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DeleteSubnet", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DeleteSubnetCommand = serializeAws_ec2DeleteSubnetCommand;
async function serializeAws_ec2DeleteTagsCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DeleteTagsRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DeleteTags", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DeleteTagsCommand = serializeAws_ec2DeleteTagsCommand;
async function serializeAws_ec2DeleteTrafficMirrorFilterCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DeleteTrafficMirrorFilterRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DeleteTrafficMirrorFilter", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DeleteTrafficMirrorFilterCommand = serializeAws_ec2DeleteTrafficMirrorFilterCommand;
async function serializeAws_ec2DeleteTrafficMirrorFilterRuleCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DeleteTrafficMirrorFilterRuleRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DeleteTrafficMirrorFilterRule", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DeleteTrafficMirrorFilterRuleCommand = serializeAws_ec2DeleteTrafficMirrorFilterRuleCommand;
async function serializeAws_ec2DeleteTrafficMirrorSessionCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DeleteTrafficMirrorSessionRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DeleteTrafficMirrorSession", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DeleteTrafficMirrorSessionCommand = serializeAws_ec2DeleteTrafficMirrorSessionCommand;
async function serializeAws_ec2DeleteTrafficMirrorTargetCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DeleteTrafficMirrorTargetRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DeleteTrafficMirrorTarget", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DeleteTrafficMirrorTargetCommand = serializeAws_ec2DeleteTrafficMirrorTargetCommand;
async function serializeAws_ec2DeleteTransitGatewayCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DeleteTransitGatewayRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DeleteTransitGateway", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DeleteTransitGatewayCommand = serializeAws_ec2DeleteTransitGatewayCommand;
async function serializeAws_ec2DeleteTransitGatewayMulticastDomainCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DeleteTransitGatewayMulticastDomainRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DeleteTransitGatewayMulticastDomain", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DeleteTransitGatewayMulticastDomainCommand = serializeAws_ec2DeleteTransitGatewayMulticastDomainCommand;
async function serializeAws_ec2DeleteTransitGatewayPeeringAttachmentCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DeleteTransitGatewayPeeringAttachmentRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DeleteTransitGatewayPeeringAttachment", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DeleteTransitGatewayPeeringAttachmentCommand = serializeAws_ec2DeleteTransitGatewayPeeringAttachmentCommand;
async function serializeAws_ec2DeleteTransitGatewayRouteCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DeleteTransitGatewayRouteRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DeleteTransitGatewayRoute", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DeleteTransitGatewayRouteCommand = serializeAws_ec2DeleteTransitGatewayRouteCommand;
async function serializeAws_ec2DeleteTransitGatewayRouteTableCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DeleteTransitGatewayRouteTableRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DeleteTransitGatewayRouteTable", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DeleteTransitGatewayRouteTableCommand = serializeAws_ec2DeleteTransitGatewayRouteTableCommand;
async function serializeAws_ec2DeleteTransitGatewayVpcAttachmentCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DeleteTransitGatewayVpcAttachmentRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DeleteTransitGatewayVpcAttachment", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DeleteTransitGatewayVpcAttachmentCommand = serializeAws_ec2DeleteTransitGatewayVpcAttachmentCommand;
async function serializeAws_ec2DeleteVolumeCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DeleteVolumeRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DeleteVolume", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DeleteVolumeCommand = serializeAws_ec2DeleteVolumeCommand;
async function serializeAws_ec2DeleteVpcCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DeleteVpcRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DeleteVpc", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DeleteVpcCommand = serializeAws_ec2DeleteVpcCommand;
async function serializeAws_ec2DeleteVpcEndpointConnectionNotificationsCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DeleteVpcEndpointConnectionNotificationsRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DeleteVpcEndpointConnectionNotifications", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DeleteVpcEndpointConnectionNotificationsCommand = serializeAws_ec2DeleteVpcEndpointConnectionNotificationsCommand;
async function serializeAws_ec2DeleteVpcEndpointServiceConfigurationsCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DeleteVpcEndpointServiceConfigurationsRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DeleteVpcEndpointServiceConfigurations", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DeleteVpcEndpointServiceConfigurationsCommand = serializeAws_ec2DeleteVpcEndpointServiceConfigurationsCommand;
async function serializeAws_ec2DeleteVpcEndpointsCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DeleteVpcEndpointsRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DeleteVpcEndpoints", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DeleteVpcEndpointsCommand = serializeAws_ec2DeleteVpcEndpointsCommand;
async function serializeAws_ec2DeleteVpcPeeringConnectionCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DeleteVpcPeeringConnectionRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DeleteVpcPeeringConnection", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DeleteVpcPeeringConnectionCommand = serializeAws_ec2DeleteVpcPeeringConnectionCommand;
async function serializeAws_ec2DeleteVpnConnectionCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DeleteVpnConnectionRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DeleteVpnConnection", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DeleteVpnConnectionCommand = serializeAws_ec2DeleteVpnConnectionCommand;
async function serializeAws_ec2DeleteVpnConnectionRouteCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DeleteVpnConnectionRouteRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DeleteVpnConnectionRoute", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DeleteVpnConnectionRouteCommand = serializeAws_ec2DeleteVpnConnectionRouteCommand;
async function serializeAws_ec2DeleteVpnGatewayCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DeleteVpnGatewayRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DeleteVpnGateway", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DeleteVpnGatewayCommand = serializeAws_ec2DeleteVpnGatewayCommand;
async function serializeAws_ec2DeprovisionByoipCidrCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DeprovisionByoipCidrRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DeprovisionByoipCidr", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DeprovisionByoipCidrCommand = serializeAws_ec2DeprovisionByoipCidrCommand;
async function serializeAws_ec2DeregisterImageCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DeregisterImageRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DeregisterImage", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DeregisterImageCommand = serializeAws_ec2DeregisterImageCommand;
async function serializeAws_ec2DeregisterTransitGatewayMulticastGroupMembersCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DeregisterTransitGatewayMulticastGroupMembersRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DeregisterTransitGatewayMulticastGroupMembers", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DeregisterTransitGatewayMulticastGroupMembersCommand = serializeAws_ec2DeregisterTransitGatewayMulticastGroupMembersCommand;
async function serializeAws_ec2DeregisterTransitGatewayMulticastGroupSourcesCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DeregisterTransitGatewayMulticastGroupSourcesRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DeregisterTransitGatewayMulticastGroupSources", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DeregisterTransitGatewayMulticastGroupSourcesCommand = serializeAws_ec2DeregisterTransitGatewayMulticastGroupSourcesCommand;
async function serializeAws_ec2DescribeAccountAttributesCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeAccountAttributesRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeAccountAttributes", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeAccountAttributesCommand = serializeAws_ec2DescribeAccountAttributesCommand;
async function serializeAws_ec2DescribeAddressesCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeAddressesRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeAddresses", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeAddressesCommand = serializeAws_ec2DescribeAddressesCommand;
async function serializeAws_ec2DescribeAggregateIdFormatCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeAggregateIdFormatRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeAggregateIdFormat", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeAggregateIdFormatCommand = serializeAws_ec2DescribeAggregateIdFormatCommand;
async function serializeAws_ec2DescribeAvailabilityZonesCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeAvailabilityZonesRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeAvailabilityZones", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeAvailabilityZonesCommand = serializeAws_ec2DescribeAvailabilityZonesCommand;
async function serializeAws_ec2DescribeBundleTasksCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeBundleTasksRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeBundleTasks", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeBundleTasksCommand = serializeAws_ec2DescribeBundleTasksCommand;
async function serializeAws_ec2DescribeByoipCidrsCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeByoipCidrsRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeByoipCidrs", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeByoipCidrsCommand = serializeAws_ec2DescribeByoipCidrsCommand;
async function serializeAws_ec2DescribeCapacityReservationsCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeCapacityReservationsRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeCapacityReservations", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeCapacityReservationsCommand = serializeAws_ec2DescribeCapacityReservationsCommand;
async function serializeAws_ec2DescribeClassicLinkInstancesCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeClassicLinkInstancesRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeClassicLinkInstances", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeClassicLinkInstancesCommand = serializeAws_ec2DescribeClassicLinkInstancesCommand;
async function serializeAws_ec2DescribeClientVpnAuthorizationRulesCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeClientVpnAuthorizationRulesRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeClientVpnAuthorizationRules", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeClientVpnAuthorizationRulesCommand = serializeAws_ec2DescribeClientVpnAuthorizationRulesCommand;
async function serializeAws_ec2DescribeClientVpnConnectionsCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeClientVpnConnectionsRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeClientVpnConnections", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeClientVpnConnectionsCommand = serializeAws_ec2DescribeClientVpnConnectionsCommand;
async function serializeAws_ec2DescribeClientVpnEndpointsCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeClientVpnEndpointsRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeClientVpnEndpoints", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeClientVpnEndpointsCommand = serializeAws_ec2DescribeClientVpnEndpointsCommand;
async function serializeAws_ec2DescribeClientVpnRoutesCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeClientVpnRoutesRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeClientVpnRoutes", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeClientVpnRoutesCommand = serializeAws_ec2DescribeClientVpnRoutesCommand;
async function serializeAws_ec2DescribeClientVpnTargetNetworksCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeClientVpnTargetNetworksRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeClientVpnTargetNetworks", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeClientVpnTargetNetworksCommand = serializeAws_ec2DescribeClientVpnTargetNetworksCommand;
async function serializeAws_ec2DescribeCoipPoolsCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeCoipPoolsRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeCoipPools", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeCoipPoolsCommand = serializeAws_ec2DescribeCoipPoolsCommand;
async function serializeAws_ec2DescribeConversionTasksCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeConversionTasksRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeConversionTasks", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeConversionTasksCommand = serializeAws_ec2DescribeConversionTasksCommand;
async function serializeAws_ec2DescribeCustomerGatewaysCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeCustomerGatewaysRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeCustomerGateways", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeCustomerGatewaysCommand = serializeAws_ec2DescribeCustomerGatewaysCommand;
async function serializeAws_ec2DescribeDhcpOptionsCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeDhcpOptionsRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeDhcpOptions", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeDhcpOptionsCommand = serializeAws_ec2DescribeDhcpOptionsCommand;
async function serializeAws_ec2DescribeEgressOnlyInternetGatewaysCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeEgressOnlyInternetGatewaysRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeEgressOnlyInternetGateways", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeEgressOnlyInternetGatewaysCommand = serializeAws_ec2DescribeEgressOnlyInternetGatewaysCommand;
async function serializeAws_ec2DescribeElasticGpusCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeElasticGpusRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeElasticGpus", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeElasticGpusCommand = serializeAws_ec2DescribeElasticGpusCommand;
async function serializeAws_ec2DescribeExportImageTasksCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeExportImageTasksRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeExportImageTasks", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeExportImageTasksCommand = serializeAws_ec2DescribeExportImageTasksCommand;
async function serializeAws_ec2DescribeExportTasksCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeExportTasksRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeExportTasks", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeExportTasksCommand = serializeAws_ec2DescribeExportTasksCommand;
async function serializeAws_ec2DescribeFastSnapshotRestoresCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeFastSnapshotRestoresRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeFastSnapshotRestores", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeFastSnapshotRestoresCommand = serializeAws_ec2DescribeFastSnapshotRestoresCommand;
async function serializeAws_ec2DescribeFleetHistoryCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeFleetHistoryRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeFleetHistory", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeFleetHistoryCommand = serializeAws_ec2DescribeFleetHistoryCommand;
async function serializeAws_ec2DescribeFleetInstancesCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeFleetInstancesRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeFleetInstances", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeFleetInstancesCommand = serializeAws_ec2DescribeFleetInstancesCommand;
async function serializeAws_ec2DescribeFleetsCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeFleetsRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeFleets", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeFleetsCommand = serializeAws_ec2DescribeFleetsCommand;
async function serializeAws_ec2DescribeFlowLogsCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeFlowLogsRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeFlowLogs", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeFlowLogsCommand = serializeAws_ec2DescribeFlowLogsCommand;
async function serializeAws_ec2DescribeFpgaImageAttributeCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeFpgaImageAttributeRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeFpgaImageAttribute", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeFpgaImageAttributeCommand = serializeAws_ec2DescribeFpgaImageAttributeCommand;
async function serializeAws_ec2DescribeFpgaImagesCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeFpgaImagesRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeFpgaImages", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeFpgaImagesCommand = serializeAws_ec2DescribeFpgaImagesCommand;
async function serializeAws_ec2DescribeHostReservationOfferingsCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeHostReservationOfferingsRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeHostReservationOfferings", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeHostReservationOfferingsCommand = serializeAws_ec2DescribeHostReservationOfferingsCommand;
async function serializeAws_ec2DescribeHostReservationsCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeHostReservationsRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeHostReservations", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeHostReservationsCommand = serializeAws_ec2DescribeHostReservationsCommand;
async function serializeAws_ec2DescribeHostsCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeHostsRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeHosts", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeHostsCommand = serializeAws_ec2DescribeHostsCommand;
async function serializeAws_ec2DescribeIamInstanceProfileAssociationsCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeIamInstanceProfileAssociationsRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeIamInstanceProfileAssociations", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeIamInstanceProfileAssociationsCommand = serializeAws_ec2DescribeIamInstanceProfileAssociationsCommand;
async function serializeAws_ec2DescribeIdFormatCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeIdFormatRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeIdFormat", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeIdFormatCommand = serializeAws_ec2DescribeIdFormatCommand;
async function serializeAws_ec2DescribeIdentityIdFormatCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeIdentityIdFormatRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeIdentityIdFormat", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeIdentityIdFormatCommand = serializeAws_ec2DescribeIdentityIdFormatCommand;
async function serializeAws_ec2DescribeImageAttributeCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeImageAttributeRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeImageAttribute", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeImageAttributeCommand = serializeAws_ec2DescribeImageAttributeCommand;
async function serializeAws_ec2DescribeImagesCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeImagesRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeImages", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeImagesCommand = serializeAws_ec2DescribeImagesCommand;
async function serializeAws_ec2DescribeImportImageTasksCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeImportImageTasksRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeImportImageTasks", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeImportImageTasksCommand = serializeAws_ec2DescribeImportImageTasksCommand;
async function serializeAws_ec2DescribeImportSnapshotTasksCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeImportSnapshotTasksRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeImportSnapshotTasks", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeImportSnapshotTasksCommand = serializeAws_ec2DescribeImportSnapshotTasksCommand;
async function serializeAws_ec2DescribeInstanceAttributeCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeInstanceAttributeRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeInstanceAttribute", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeInstanceAttributeCommand = serializeAws_ec2DescribeInstanceAttributeCommand;
async function serializeAws_ec2DescribeInstanceCreditSpecificationsCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeInstanceCreditSpecificationsRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeInstanceCreditSpecifications", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeInstanceCreditSpecificationsCommand = serializeAws_ec2DescribeInstanceCreditSpecificationsCommand;
async function serializeAws_ec2DescribeInstanceStatusCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeInstanceStatusRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeInstanceStatus", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeInstanceStatusCommand = serializeAws_ec2DescribeInstanceStatusCommand;
async function serializeAws_ec2DescribeInstanceTypeOfferingsCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeInstanceTypeOfferingsRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeInstanceTypeOfferings", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeInstanceTypeOfferingsCommand = serializeAws_ec2DescribeInstanceTypeOfferingsCommand;
async function serializeAws_ec2DescribeInstanceTypesCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeInstanceTypesRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeInstanceTypes", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeInstanceTypesCommand = serializeAws_ec2DescribeInstanceTypesCommand;
async function serializeAws_ec2DescribeInstancesCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeInstancesRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeInstances", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeInstancesCommand = serializeAws_ec2DescribeInstancesCommand;
async function serializeAws_ec2DescribeInternetGatewaysCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeInternetGatewaysRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeInternetGateways", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeInternetGatewaysCommand = serializeAws_ec2DescribeInternetGatewaysCommand;
async function serializeAws_ec2DescribeIpv6PoolsCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeIpv6PoolsRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeIpv6Pools", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeIpv6PoolsCommand = serializeAws_ec2DescribeIpv6PoolsCommand;
async function serializeAws_ec2DescribeKeyPairsCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeKeyPairsRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeKeyPairs", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeKeyPairsCommand = serializeAws_ec2DescribeKeyPairsCommand;
async function serializeAws_ec2DescribeLaunchTemplateVersionsCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeLaunchTemplateVersionsRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeLaunchTemplateVersions", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeLaunchTemplateVersionsCommand = serializeAws_ec2DescribeLaunchTemplateVersionsCommand;
async function serializeAws_ec2DescribeLaunchTemplatesCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeLaunchTemplatesRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeLaunchTemplates", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeLaunchTemplatesCommand = serializeAws_ec2DescribeLaunchTemplatesCommand;
async function serializeAws_ec2DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociations", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsCommand = serializeAws_ec2DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsCommand;
async function serializeAws_ec2DescribeLocalGatewayRouteTableVpcAssociationsCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeLocalGatewayRouteTableVpcAssociationsRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeLocalGatewayRouteTableVpcAssociations", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeLocalGatewayRouteTableVpcAssociationsCommand = serializeAws_ec2DescribeLocalGatewayRouteTableVpcAssociationsCommand;
async function serializeAws_ec2DescribeLocalGatewayRouteTablesCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeLocalGatewayRouteTablesRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeLocalGatewayRouteTables", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeLocalGatewayRouteTablesCommand = serializeAws_ec2DescribeLocalGatewayRouteTablesCommand;
async function serializeAws_ec2DescribeLocalGatewayVirtualInterfaceGroupsCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeLocalGatewayVirtualInterfaceGroupsRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeLocalGatewayVirtualInterfaceGroups", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeLocalGatewayVirtualInterfaceGroupsCommand = serializeAws_ec2DescribeLocalGatewayVirtualInterfaceGroupsCommand;
async function serializeAws_ec2DescribeLocalGatewayVirtualInterfacesCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeLocalGatewayVirtualInterfacesRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeLocalGatewayVirtualInterfaces", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeLocalGatewayVirtualInterfacesCommand = serializeAws_ec2DescribeLocalGatewayVirtualInterfacesCommand;
async function serializeAws_ec2DescribeLocalGatewaysCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeLocalGatewaysRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeLocalGateways", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeLocalGatewaysCommand = serializeAws_ec2DescribeLocalGatewaysCommand;
async function serializeAws_ec2DescribeMovingAddressesCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeMovingAddressesRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeMovingAddresses", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeMovingAddressesCommand = serializeAws_ec2DescribeMovingAddressesCommand;
async function serializeAws_ec2DescribeNatGatewaysCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeNatGatewaysRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeNatGateways", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeNatGatewaysCommand = serializeAws_ec2DescribeNatGatewaysCommand;
async function serializeAws_ec2DescribeNetworkAclsCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeNetworkAclsRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeNetworkAcls", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeNetworkAclsCommand = serializeAws_ec2DescribeNetworkAclsCommand;
async function serializeAws_ec2DescribeNetworkInterfaceAttributeCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeNetworkInterfaceAttributeRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeNetworkInterfaceAttribute", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeNetworkInterfaceAttributeCommand = serializeAws_ec2DescribeNetworkInterfaceAttributeCommand;
async function serializeAws_ec2DescribeNetworkInterfacePermissionsCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeNetworkInterfacePermissionsRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeNetworkInterfacePermissions", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeNetworkInterfacePermissionsCommand = serializeAws_ec2DescribeNetworkInterfacePermissionsCommand;
async function serializeAws_ec2DescribeNetworkInterfacesCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeNetworkInterfacesRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeNetworkInterfaces", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeNetworkInterfacesCommand = serializeAws_ec2DescribeNetworkInterfacesCommand;
async function serializeAws_ec2DescribePlacementGroupsCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribePlacementGroupsRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribePlacementGroups", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribePlacementGroupsCommand = serializeAws_ec2DescribePlacementGroupsCommand;
async function serializeAws_ec2DescribePrefixListsCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribePrefixListsRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribePrefixLists", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribePrefixListsCommand = serializeAws_ec2DescribePrefixListsCommand;
async function serializeAws_ec2DescribePrincipalIdFormatCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribePrincipalIdFormatRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribePrincipalIdFormat", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribePrincipalIdFormatCommand = serializeAws_ec2DescribePrincipalIdFormatCommand;
async function serializeAws_ec2DescribePublicIpv4PoolsCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribePublicIpv4PoolsRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribePublicIpv4Pools", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribePublicIpv4PoolsCommand = serializeAws_ec2DescribePublicIpv4PoolsCommand;
async function serializeAws_ec2DescribeRegionsCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeRegionsRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeRegions", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeRegionsCommand = serializeAws_ec2DescribeRegionsCommand;
async function serializeAws_ec2DescribeReservedInstancesCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeReservedInstancesRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeReservedInstances", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeReservedInstancesCommand = serializeAws_ec2DescribeReservedInstancesCommand;
async function serializeAws_ec2DescribeReservedInstancesListingsCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeReservedInstancesListingsRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeReservedInstancesListings", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeReservedInstancesListingsCommand = serializeAws_ec2DescribeReservedInstancesListingsCommand;
async function serializeAws_ec2DescribeReservedInstancesModificationsCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeReservedInstancesModificationsRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeReservedInstancesModifications", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeReservedInstancesModificationsCommand = serializeAws_ec2DescribeReservedInstancesModificationsCommand;
async function serializeAws_ec2DescribeReservedInstancesOfferingsCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeReservedInstancesOfferingsRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeReservedInstancesOfferings", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeReservedInstancesOfferingsCommand = serializeAws_ec2DescribeReservedInstancesOfferingsCommand;
async function serializeAws_ec2DescribeRouteTablesCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeRouteTablesRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeRouteTables", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeRouteTablesCommand = serializeAws_ec2DescribeRouteTablesCommand;
async function serializeAws_ec2DescribeScheduledInstanceAvailabilityCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeScheduledInstanceAvailabilityRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeScheduledInstanceAvailability", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeScheduledInstanceAvailabilityCommand = serializeAws_ec2DescribeScheduledInstanceAvailabilityCommand;
async function serializeAws_ec2DescribeScheduledInstancesCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeScheduledInstancesRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeScheduledInstances", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeScheduledInstancesCommand = serializeAws_ec2DescribeScheduledInstancesCommand;
async function serializeAws_ec2DescribeSecurityGroupReferencesCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeSecurityGroupReferencesRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeSecurityGroupReferences", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeSecurityGroupReferencesCommand = serializeAws_ec2DescribeSecurityGroupReferencesCommand;
async function serializeAws_ec2DescribeSecurityGroupsCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeSecurityGroupsRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeSecurityGroups", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeSecurityGroupsCommand = serializeAws_ec2DescribeSecurityGroupsCommand;
async function serializeAws_ec2DescribeSnapshotAttributeCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeSnapshotAttributeRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeSnapshotAttribute", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeSnapshotAttributeCommand = serializeAws_ec2DescribeSnapshotAttributeCommand;
async function serializeAws_ec2DescribeSnapshotsCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeSnapshotsRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeSnapshots", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeSnapshotsCommand = serializeAws_ec2DescribeSnapshotsCommand;
async function serializeAws_ec2DescribeSpotDatafeedSubscriptionCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeSpotDatafeedSubscriptionRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeSpotDatafeedSubscription", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeSpotDatafeedSubscriptionCommand = serializeAws_ec2DescribeSpotDatafeedSubscriptionCommand;
async function serializeAws_ec2DescribeSpotFleetInstancesCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeSpotFleetInstancesRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeSpotFleetInstances", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeSpotFleetInstancesCommand = serializeAws_ec2DescribeSpotFleetInstancesCommand;
async function serializeAws_ec2DescribeSpotFleetRequestHistoryCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeSpotFleetRequestHistoryRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeSpotFleetRequestHistory", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeSpotFleetRequestHistoryCommand = serializeAws_ec2DescribeSpotFleetRequestHistoryCommand;
async function serializeAws_ec2DescribeSpotFleetRequestsCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeSpotFleetRequestsRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeSpotFleetRequests", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeSpotFleetRequestsCommand = serializeAws_ec2DescribeSpotFleetRequestsCommand;
async function serializeAws_ec2DescribeSpotInstanceRequestsCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeSpotInstanceRequestsRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeSpotInstanceRequests", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeSpotInstanceRequestsCommand = serializeAws_ec2DescribeSpotInstanceRequestsCommand;
async function serializeAws_ec2DescribeSpotPriceHistoryCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeSpotPriceHistoryRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeSpotPriceHistory", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeSpotPriceHistoryCommand = serializeAws_ec2DescribeSpotPriceHistoryCommand;
async function serializeAws_ec2DescribeStaleSecurityGroupsCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeStaleSecurityGroupsRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeStaleSecurityGroups", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeStaleSecurityGroupsCommand = serializeAws_ec2DescribeStaleSecurityGroupsCommand;
async function serializeAws_ec2DescribeSubnetsCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeSubnetsRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeSubnets", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeSubnetsCommand = serializeAws_ec2DescribeSubnetsCommand;
async function serializeAws_ec2DescribeTagsCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeTagsRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeTags", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeTagsCommand = serializeAws_ec2DescribeTagsCommand;
async function serializeAws_ec2DescribeTrafficMirrorFiltersCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeTrafficMirrorFiltersRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeTrafficMirrorFilters", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeTrafficMirrorFiltersCommand = serializeAws_ec2DescribeTrafficMirrorFiltersCommand;
async function serializeAws_ec2DescribeTrafficMirrorSessionsCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeTrafficMirrorSessionsRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeTrafficMirrorSessions", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeTrafficMirrorSessionsCommand = serializeAws_ec2DescribeTrafficMirrorSessionsCommand;
async function serializeAws_ec2DescribeTrafficMirrorTargetsCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeTrafficMirrorTargetsRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeTrafficMirrorTargets", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeTrafficMirrorTargetsCommand = serializeAws_ec2DescribeTrafficMirrorTargetsCommand;
async function serializeAws_ec2DescribeTransitGatewayAttachmentsCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeTransitGatewayAttachmentsRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeTransitGatewayAttachments", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeTransitGatewayAttachmentsCommand = serializeAws_ec2DescribeTransitGatewayAttachmentsCommand;
async function serializeAws_ec2DescribeTransitGatewayMulticastDomainsCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeTransitGatewayMulticastDomainsRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeTransitGatewayMulticastDomains", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeTransitGatewayMulticastDomainsCommand = serializeAws_ec2DescribeTransitGatewayMulticastDomainsCommand;
async function serializeAws_ec2DescribeTransitGatewayPeeringAttachmentsCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeTransitGatewayPeeringAttachmentsRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeTransitGatewayPeeringAttachments", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeTransitGatewayPeeringAttachmentsCommand = serializeAws_ec2DescribeTransitGatewayPeeringAttachmentsCommand;
async function serializeAws_ec2DescribeTransitGatewayRouteTablesCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeTransitGatewayRouteTablesRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeTransitGatewayRouteTables", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeTransitGatewayRouteTablesCommand = serializeAws_ec2DescribeTransitGatewayRouteTablesCommand;
async function serializeAws_ec2DescribeTransitGatewayVpcAttachmentsCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeTransitGatewayVpcAttachmentsRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeTransitGatewayVpcAttachments", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeTransitGatewayVpcAttachmentsCommand = serializeAws_ec2DescribeTransitGatewayVpcAttachmentsCommand;
async function serializeAws_ec2DescribeTransitGatewaysCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeTransitGatewaysRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeTransitGateways", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeTransitGatewaysCommand = serializeAws_ec2DescribeTransitGatewaysCommand;
async function serializeAws_ec2DescribeVolumeAttributeCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeVolumeAttributeRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeVolumeAttribute", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeVolumeAttributeCommand = serializeAws_ec2DescribeVolumeAttributeCommand;
async function serializeAws_ec2DescribeVolumeStatusCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeVolumeStatusRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeVolumeStatus", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeVolumeStatusCommand = serializeAws_ec2DescribeVolumeStatusCommand;
async function serializeAws_ec2DescribeVolumesCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeVolumesRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeVolumes", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeVolumesCommand = serializeAws_ec2DescribeVolumesCommand;
async function serializeAws_ec2DescribeVolumesModificationsCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeVolumesModificationsRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeVolumesModifications", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeVolumesModificationsCommand = serializeAws_ec2DescribeVolumesModificationsCommand;
async function serializeAws_ec2DescribeVpcAttributeCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeVpcAttributeRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeVpcAttribute", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeVpcAttributeCommand = serializeAws_ec2DescribeVpcAttributeCommand;
async function serializeAws_ec2DescribeVpcClassicLinkCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeVpcClassicLinkRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeVpcClassicLink", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeVpcClassicLinkCommand = serializeAws_ec2DescribeVpcClassicLinkCommand;
async function serializeAws_ec2DescribeVpcClassicLinkDnsSupportCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeVpcClassicLinkDnsSupportRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeVpcClassicLinkDnsSupport", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeVpcClassicLinkDnsSupportCommand = serializeAws_ec2DescribeVpcClassicLinkDnsSupportCommand;
async function serializeAws_ec2DescribeVpcEndpointConnectionNotificationsCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeVpcEndpointConnectionNotificationsRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeVpcEndpointConnectionNotifications", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeVpcEndpointConnectionNotificationsCommand = serializeAws_ec2DescribeVpcEndpointConnectionNotificationsCommand;
async function serializeAws_ec2DescribeVpcEndpointConnectionsCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeVpcEndpointConnectionsRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeVpcEndpointConnections", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeVpcEndpointConnectionsCommand = serializeAws_ec2DescribeVpcEndpointConnectionsCommand;
async function serializeAws_ec2DescribeVpcEndpointServiceConfigurationsCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeVpcEndpointServiceConfigurationsRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeVpcEndpointServiceConfigurations", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeVpcEndpointServiceConfigurationsCommand = serializeAws_ec2DescribeVpcEndpointServiceConfigurationsCommand;
async function serializeAws_ec2DescribeVpcEndpointServicePermissionsCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeVpcEndpointServicePermissionsRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeVpcEndpointServicePermissions", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeVpcEndpointServicePermissionsCommand = serializeAws_ec2DescribeVpcEndpointServicePermissionsCommand;
async function serializeAws_ec2DescribeVpcEndpointServicesCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeVpcEndpointServicesRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeVpcEndpointServices", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeVpcEndpointServicesCommand = serializeAws_ec2DescribeVpcEndpointServicesCommand;
async function serializeAws_ec2DescribeVpcEndpointsCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeVpcEndpointsRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeVpcEndpoints", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeVpcEndpointsCommand = serializeAws_ec2DescribeVpcEndpointsCommand;
async function serializeAws_ec2DescribeVpcPeeringConnectionsCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeVpcPeeringConnectionsRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeVpcPeeringConnections", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeVpcPeeringConnectionsCommand = serializeAws_ec2DescribeVpcPeeringConnectionsCommand;
async function serializeAws_ec2DescribeVpcsCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeVpcsRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeVpcs", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeVpcsCommand = serializeAws_ec2DescribeVpcsCommand;
async function serializeAws_ec2DescribeVpnConnectionsCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeVpnConnectionsRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeVpnConnections", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeVpnConnectionsCommand = serializeAws_ec2DescribeVpnConnectionsCommand;
async function serializeAws_ec2DescribeVpnGatewaysCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DescribeVpnGatewaysRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DescribeVpnGateways", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DescribeVpnGatewaysCommand = serializeAws_ec2DescribeVpnGatewaysCommand;
async function serializeAws_ec2DetachClassicLinkVpcCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DetachClassicLinkVpcRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DetachClassicLinkVpc", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DetachClassicLinkVpcCommand = serializeAws_ec2DetachClassicLinkVpcCommand;
async function serializeAws_ec2DetachInternetGatewayCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DetachInternetGatewayRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DetachInternetGateway", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DetachInternetGatewayCommand = serializeAws_ec2DetachInternetGatewayCommand;
async function serializeAws_ec2DetachNetworkInterfaceCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DetachNetworkInterfaceRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DetachNetworkInterface", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DetachNetworkInterfaceCommand = serializeAws_ec2DetachNetworkInterfaceCommand;
async function serializeAws_ec2DetachVolumeCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DetachVolumeRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DetachVolume", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DetachVolumeCommand = serializeAws_ec2DetachVolumeCommand;
async function serializeAws_ec2DetachVpnGatewayCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DetachVpnGatewayRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DetachVpnGateway", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DetachVpnGatewayCommand = serializeAws_ec2DetachVpnGatewayCommand;
async function serializeAws_ec2DisableEbsEncryptionByDefaultCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DisableEbsEncryptionByDefaultRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DisableEbsEncryptionByDefault", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DisableEbsEncryptionByDefaultCommand = serializeAws_ec2DisableEbsEncryptionByDefaultCommand;
async function serializeAws_ec2DisableFastSnapshotRestoresCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DisableFastSnapshotRestoresRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DisableFastSnapshotRestores", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DisableFastSnapshotRestoresCommand = serializeAws_ec2DisableFastSnapshotRestoresCommand;
async function serializeAws_ec2DisableTransitGatewayRouteTablePropagationCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DisableTransitGatewayRouteTablePropagationRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DisableTransitGatewayRouteTablePropagation", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DisableTransitGatewayRouteTablePropagationCommand = serializeAws_ec2DisableTransitGatewayRouteTablePropagationCommand;
async function serializeAws_ec2DisableVgwRoutePropagationCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DisableVgwRoutePropagationRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DisableVgwRoutePropagation", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DisableVgwRoutePropagationCommand = serializeAws_ec2DisableVgwRoutePropagationCommand;
async function serializeAws_ec2DisableVpcClassicLinkCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DisableVpcClassicLinkRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DisableVpcClassicLink", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DisableVpcClassicLinkCommand = serializeAws_ec2DisableVpcClassicLinkCommand;
async function serializeAws_ec2DisableVpcClassicLinkDnsSupportCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DisableVpcClassicLinkDnsSupportRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DisableVpcClassicLinkDnsSupport", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DisableVpcClassicLinkDnsSupportCommand = serializeAws_ec2DisableVpcClassicLinkDnsSupportCommand;
async function serializeAws_ec2DisassociateAddressCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DisassociateAddressRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DisassociateAddress", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DisassociateAddressCommand = serializeAws_ec2DisassociateAddressCommand;
async function serializeAws_ec2DisassociateClientVpnTargetNetworkCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DisassociateClientVpnTargetNetworkRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DisassociateClientVpnTargetNetwork", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DisassociateClientVpnTargetNetworkCommand = serializeAws_ec2DisassociateClientVpnTargetNetworkCommand;
async function serializeAws_ec2DisassociateIamInstanceProfileCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DisassociateIamInstanceProfileRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DisassociateIamInstanceProfile", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DisassociateIamInstanceProfileCommand = serializeAws_ec2DisassociateIamInstanceProfileCommand;
async function serializeAws_ec2DisassociateRouteTableCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DisassociateRouteTableRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DisassociateRouteTable", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DisassociateRouteTableCommand = serializeAws_ec2DisassociateRouteTableCommand;
async function serializeAws_ec2DisassociateSubnetCidrBlockCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DisassociateSubnetCidrBlockRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DisassociateSubnetCidrBlock", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DisassociateSubnetCidrBlockCommand = serializeAws_ec2DisassociateSubnetCidrBlockCommand;
async function serializeAws_ec2DisassociateTransitGatewayMulticastDomainCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DisassociateTransitGatewayMulticastDomainRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DisassociateTransitGatewayMulticastDomain", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DisassociateTransitGatewayMulticastDomainCommand = serializeAws_ec2DisassociateTransitGatewayMulticastDomainCommand;
async function serializeAws_ec2DisassociateTransitGatewayRouteTableCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DisassociateTransitGatewayRouteTableRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DisassociateTransitGatewayRouteTable", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DisassociateTransitGatewayRouteTableCommand = serializeAws_ec2DisassociateTransitGatewayRouteTableCommand;
async function serializeAws_ec2DisassociateVpcCidrBlockCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2DisassociateVpcCidrBlockRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "DisassociateVpcCidrBlock", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2DisassociateVpcCidrBlockCommand = serializeAws_ec2DisassociateVpcCidrBlockCommand;
async function serializeAws_ec2EnableEbsEncryptionByDefaultCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2EnableEbsEncryptionByDefaultRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "EnableEbsEncryptionByDefault", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2EnableEbsEncryptionByDefaultCommand = serializeAws_ec2EnableEbsEncryptionByDefaultCommand;
async function serializeAws_ec2EnableFastSnapshotRestoresCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2EnableFastSnapshotRestoresRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "EnableFastSnapshotRestores", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2EnableFastSnapshotRestoresCommand = serializeAws_ec2EnableFastSnapshotRestoresCommand;
async function serializeAws_ec2EnableTransitGatewayRouteTablePropagationCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2EnableTransitGatewayRouteTablePropagationRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "EnableTransitGatewayRouteTablePropagation", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2EnableTransitGatewayRouteTablePropagationCommand = serializeAws_ec2EnableTransitGatewayRouteTablePropagationCommand;
async function serializeAws_ec2EnableVgwRoutePropagationCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2EnableVgwRoutePropagationRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "EnableVgwRoutePropagation", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2EnableVgwRoutePropagationCommand = serializeAws_ec2EnableVgwRoutePropagationCommand;
async function serializeAws_ec2EnableVolumeIOCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2EnableVolumeIORequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "EnableVolumeIO", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2EnableVolumeIOCommand = serializeAws_ec2EnableVolumeIOCommand;
async function serializeAws_ec2EnableVpcClassicLinkCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2EnableVpcClassicLinkRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "EnableVpcClassicLink", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2EnableVpcClassicLinkCommand = serializeAws_ec2EnableVpcClassicLinkCommand;
async function serializeAws_ec2EnableVpcClassicLinkDnsSupportCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2EnableVpcClassicLinkDnsSupportRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "EnableVpcClassicLinkDnsSupport", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2EnableVpcClassicLinkDnsSupportCommand = serializeAws_ec2EnableVpcClassicLinkDnsSupportCommand;
async function serializeAws_ec2ExportClientVpnClientCertificateRevocationListCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2ExportClientVpnClientCertificateRevocationListRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "ExportClientVpnClientCertificateRevocationList", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2ExportClientVpnClientCertificateRevocationListCommand = serializeAws_ec2ExportClientVpnClientCertificateRevocationListCommand;
async function serializeAws_ec2ExportClientVpnClientConfigurationCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2ExportClientVpnClientConfigurationRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "ExportClientVpnClientConfiguration", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2ExportClientVpnClientConfigurationCommand = serializeAws_ec2ExportClientVpnClientConfigurationCommand;
async function serializeAws_ec2ExportImageCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2ExportImageRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "ExportImage", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2ExportImageCommand = serializeAws_ec2ExportImageCommand;
async function serializeAws_ec2ExportTransitGatewayRoutesCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2ExportTransitGatewayRoutesRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "ExportTransitGatewayRoutes", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2ExportTransitGatewayRoutesCommand = serializeAws_ec2ExportTransitGatewayRoutesCommand;
async function serializeAws_ec2GetAssociatedIpv6PoolCidrsCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2GetAssociatedIpv6PoolCidrsRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "GetAssociatedIpv6PoolCidrs", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2GetAssociatedIpv6PoolCidrsCommand = serializeAws_ec2GetAssociatedIpv6PoolCidrsCommand;
async function serializeAws_ec2GetCapacityReservationUsageCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2GetCapacityReservationUsageRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "GetCapacityReservationUsage", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2GetCapacityReservationUsageCommand = serializeAws_ec2GetCapacityReservationUsageCommand;
async function serializeAws_ec2GetCoipPoolUsageCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2GetCoipPoolUsageRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "GetCoipPoolUsage", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2GetCoipPoolUsageCommand = serializeAws_ec2GetCoipPoolUsageCommand;
async function serializeAws_ec2GetConsoleOutputCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2GetConsoleOutputRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "GetConsoleOutput", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2GetConsoleOutputCommand = serializeAws_ec2GetConsoleOutputCommand;
async function serializeAws_ec2GetConsoleScreenshotCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2GetConsoleScreenshotRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "GetConsoleScreenshot", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2GetConsoleScreenshotCommand = serializeAws_ec2GetConsoleScreenshotCommand;
async function serializeAws_ec2GetDefaultCreditSpecificationCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2GetDefaultCreditSpecificationRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "GetDefaultCreditSpecification", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2GetDefaultCreditSpecificationCommand = serializeAws_ec2GetDefaultCreditSpecificationCommand;
async function serializeAws_ec2GetEbsDefaultKmsKeyIdCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2GetEbsDefaultKmsKeyIdRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "GetEbsDefaultKmsKeyId", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2GetEbsDefaultKmsKeyIdCommand = serializeAws_ec2GetEbsDefaultKmsKeyIdCommand;
async function serializeAws_ec2GetEbsEncryptionByDefaultCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2GetEbsEncryptionByDefaultRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "GetEbsEncryptionByDefault", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2GetEbsEncryptionByDefaultCommand = serializeAws_ec2GetEbsEncryptionByDefaultCommand;
async function serializeAws_ec2GetHostReservationPurchasePreviewCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2GetHostReservationPurchasePreviewRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "GetHostReservationPurchasePreview", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2GetHostReservationPurchasePreviewCommand = serializeAws_ec2GetHostReservationPurchasePreviewCommand;
async function serializeAws_ec2GetLaunchTemplateDataCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2GetLaunchTemplateDataRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "GetLaunchTemplateData", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2GetLaunchTemplateDataCommand = serializeAws_ec2GetLaunchTemplateDataCommand;
async function serializeAws_ec2GetPasswordDataCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2GetPasswordDataRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "GetPasswordData", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2GetPasswordDataCommand = serializeAws_ec2GetPasswordDataCommand;
async function serializeAws_ec2GetReservedInstancesExchangeQuoteCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2GetReservedInstancesExchangeQuoteRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "GetReservedInstancesExchangeQuote", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2GetReservedInstancesExchangeQuoteCommand = serializeAws_ec2GetReservedInstancesExchangeQuoteCommand;
async function serializeAws_ec2GetTransitGatewayAttachmentPropagationsCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2GetTransitGatewayAttachmentPropagationsRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "GetTransitGatewayAttachmentPropagations", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2GetTransitGatewayAttachmentPropagationsCommand = serializeAws_ec2GetTransitGatewayAttachmentPropagationsCommand;
async function serializeAws_ec2GetTransitGatewayMulticastDomainAssociationsCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2GetTransitGatewayMulticastDomainAssociationsRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "GetTransitGatewayMulticastDomainAssociations", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2GetTransitGatewayMulticastDomainAssociationsCommand = serializeAws_ec2GetTransitGatewayMulticastDomainAssociationsCommand;
async function serializeAws_ec2GetTransitGatewayRouteTableAssociationsCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2GetTransitGatewayRouteTableAssociationsRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "GetTransitGatewayRouteTableAssociations", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2GetTransitGatewayRouteTableAssociationsCommand = serializeAws_ec2GetTransitGatewayRouteTableAssociationsCommand;
async function serializeAws_ec2GetTransitGatewayRouteTablePropagationsCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2GetTransitGatewayRouteTablePropagationsRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "GetTransitGatewayRouteTablePropagations", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2GetTransitGatewayRouteTablePropagationsCommand = serializeAws_ec2GetTransitGatewayRouteTablePropagationsCommand;
async function serializeAws_ec2ImportClientVpnClientCertificateRevocationListCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2ImportClientVpnClientCertificateRevocationListRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "ImportClientVpnClientCertificateRevocationList", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2ImportClientVpnClientCertificateRevocationListCommand = serializeAws_ec2ImportClientVpnClientCertificateRevocationListCommand;
async function serializeAws_ec2ImportImageCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2ImportImageRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "ImportImage", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2ImportImageCommand = serializeAws_ec2ImportImageCommand;
async function serializeAws_ec2ImportInstanceCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2ImportInstanceRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "ImportInstance", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2ImportInstanceCommand = serializeAws_ec2ImportInstanceCommand;
async function serializeAws_ec2ImportKeyPairCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2ImportKeyPairRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "ImportKeyPair", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2ImportKeyPairCommand = serializeAws_ec2ImportKeyPairCommand;
async function serializeAws_ec2ImportSnapshotCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2ImportSnapshotRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "ImportSnapshot", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2ImportSnapshotCommand = serializeAws_ec2ImportSnapshotCommand;
async function serializeAws_ec2ImportVolumeCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2ImportVolumeRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "ImportVolume", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2ImportVolumeCommand = serializeAws_ec2ImportVolumeCommand;
async function serializeAws_ec2ModifyCapacityReservationCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2ModifyCapacityReservationRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "ModifyCapacityReservation", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2ModifyCapacityReservationCommand = serializeAws_ec2ModifyCapacityReservationCommand;
async function serializeAws_ec2ModifyClientVpnEndpointCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2ModifyClientVpnEndpointRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "ModifyClientVpnEndpoint", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2ModifyClientVpnEndpointCommand = serializeAws_ec2ModifyClientVpnEndpointCommand;
async function serializeAws_ec2ModifyDefaultCreditSpecificationCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2ModifyDefaultCreditSpecificationRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "ModifyDefaultCreditSpecification", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2ModifyDefaultCreditSpecificationCommand = serializeAws_ec2ModifyDefaultCreditSpecificationCommand;
async function serializeAws_ec2ModifyEbsDefaultKmsKeyIdCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2ModifyEbsDefaultKmsKeyIdRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "ModifyEbsDefaultKmsKeyId", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2ModifyEbsDefaultKmsKeyIdCommand = serializeAws_ec2ModifyEbsDefaultKmsKeyIdCommand;
async function serializeAws_ec2ModifyFleetCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2ModifyFleetRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "ModifyFleet", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2ModifyFleetCommand = serializeAws_ec2ModifyFleetCommand;
async function serializeAws_ec2ModifyFpgaImageAttributeCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2ModifyFpgaImageAttributeRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "ModifyFpgaImageAttribute", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2ModifyFpgaImageAttributeCommand = serializeAws_ec2ModifyFpgaImageAttributeCommand;
async function serializeAws_ec2ModifyHostsCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2ModifyHostsRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "ModifyHosts", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2ModifyHostsCommand = serializeAws_ec2ModifyHostsCommand;
async function serializeAws_ec2ModifyIdFormatCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2ModifyIdFormatRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "ModifyIdFormat", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2ModifyIdFormatCommand = serializeAws_ec2ModifyIdFormatCommand;
async function serializeAws_ec2ModifyIdentityIdFormatCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2ModifyIdentityIdFormatRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "ModifyIdentityIdFormat", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2ModifyIdentityIdFormatCommand = serializeAws_ec2ModifyIdentityIdFormatCommand;
async function serializeAws_ec2ModifyImageAttributeCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2ModifyImageAttributeRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "ModifyImageAttribute", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2ModifyImageAttributeCommand = serializeAws_ec2ModifyImageAttributeCommand;
async function serializeAws_ec2ModifyInstanceAttributeCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2ModifyInstanceAttributeRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "ModifyInstanceAttribute", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2ModifyInstanceAttributeCommand = serializeAws_ec2ModifyInstanceAttributeCommand;
async function serializeAws_ec2ModifyInstanceCapacityReservationAttributesCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2ModifyInstanceCapacityReservationAttributesRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "ModifyInstanceCapacityReservationAttributes", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2ModifyInstanceCapacityReservationAttributesCommand = serializeAws_ec2ModifyInstanceCapacityReservationAttributesCommand;
async function serializeAws_ec2ModifyInstanceCreditSpecificationCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2ModifyInstanceCreditSpecificationRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "ModifyInstanceCreditSpecification", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2ModifyInstanceCreditSpecificationCommand = serializeAws_ec2ModifyInstanceCreditSpecificationCommand;
async function serializeAws_ec2ModifyInstanceEventStartTimeCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2ModifyInstanceEventStartTimeRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "ModifyInstanceEventStartTime", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2ModifyInstanceEventStartTimeCommand = serializeAws_ec2ModifyInstanceEventStartTimeCommand;
async function serializeAws_ec2ModifyInstanceMetadataOptionsCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2ModifyInstanceMetadataOptionsRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "ModifyInstanceMetadataOptions", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2ModifyInstanceMetadataOptionsCommand = serializeAws_ec2ModifyInstanceMetadataOptionsCommand;
async function serializeAws_ec2ModifyInstancePlacementCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2ModifyInstancePlacementRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "ModifyInstancePlacement", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2ModifyInstancePlacementCommand = serializeAws_ec2ModifyInstancePlacementCommand;
async function serializeAws_ec2ModifyLaunchTemplateCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2ModifyLaunchTemplateRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "ModifyLaunchTemplate", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2ModifyLaunchTemplateCommand = serializeAws_ec2ModifyLaunchTemplateCommand;
async function serializeAws_ec2ModifyNetworkInterfaceAttributeCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2ModifyNetworkInterfaceAttributeRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "ModifyNetworkInterfaceAttribute", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2ModifyNetworkInterfaceAttributeCommand = serializeAws_ec2ModifyNetworkInterfaceAttributeCommand;
async function serializeAws_ec2ModifyReservedInstancesCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2ModifyReservedInstancesRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "ModifyReservedInstances", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2ModifyReservedInstancesCommand = serializeAws_ec2ModifyReservedInstancesCommand;
async function serializeAws_ec2ModifySnapshotAttributeCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2ModifySnapshotAttributeRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "ModifySnapshotAttribute", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2ModifySnapshotAttributeCommand = serializeAws_ec2ModifySnapshotAttributeCommand;
async function serializeAws_ec2ModifySpotFleetRequestCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2ModifySpotFleetRequestRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "ModifySpotFleetRequest", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2ModifySpotFleetRequestCommand = serializeAws_ec2ModifySpotFleetRequestCommand;
async function serializeAws_ec2ModifySubnetAttributeCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2ModifySubnetAttributeRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "ModifySubnetAttribute", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2ModifySubnetAttributeCommand = serializeAws_ec2ModifySubnetAttributeCommand;
async function serializeAws_ec2ModifyTrafficMirrorFilterNetworkServicesCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2ModifyTrafficMirrorFilterNetworkServicesRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "ModifyTrafficMirrorFilterNetworkServices", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2ModifyTrafficMirrorFilterNetworkServicesCommand = serializeAws_ec2ModifyTrafficMirrorFilterNetworkServicesCommand;
async function serializeAws_ec2ModifyTrafficMirrorFilterRuleCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2ModifyTrafficMirrorFilterRuleRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "ModifyTrafficMirrorFilterRule", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2ModifyTrafficMirrorFilterRuleCommand = serializeAws_ec2ModifyTrafficMirrorFilterRuleCommand;
async function serializeAws_ec2ModifyTrafficMirrorSessionCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2ModifyTrafficMirrorSessionRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "ModifyTrafficMirrorSession", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2ModifyTrafficMirrorSessionCommand = serializeAws_ec2ModifyTrafficMirrorSessionCommand;
async function serializeAws_ec2ModifyTransitGatewayVpcAttachmentCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2ModifyTransitGatewayVpcAttachmentRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "ModifyTransitGatewayVpcAttachment", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2ModifyTransitGatewayVpcAttachmentCommand = serializeAws_ec2ModifyTransitGatewayVpcAttachmentCommand;
async function serializeAws_ec2ModifyVolumeCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2ModifyVolumeRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "ModifyVolume", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2ModifyVolumeCommand = serializeAws_ec2ModifyVolumeCommand;
async function serializeAws_ec2ModifyVolumeAttributeCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2ModifyVolumeAttributeRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "ModifyVolumeAttribute", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2ModifyVolumeAttributeCommand = serializeAws_ec2ModifyVolumeAttributeCommand;
async function serializeAws_ec2ModifyVpcAttributeCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2ModifyVpcAttributeRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "ModifyVpcAttribute", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2ModifyVpcAttributeCommand = serializeAws_ec2ModifyVpcAttributeCommand;
async function serializeAws_ec2ModifyVpcEndpointCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2ModifyVpcEndpointRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "ModifyVpcEndpoint", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2ModifyVpcEndpointCommand = serializeAws_ec2ModifyVpcEndpointCommand;
async function serializeAws_ec2ModifyVpcEndpointConnectionNotificationCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2ModifyVpcEndpointConnectionNotificationRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "ModifyVpcEndpointConnectionNotification", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2ModifyVpcEndpointConnectionNotificationCommand = serializeAws_ec2ModifyVpcEndpointConnectionNotificationCommand;
async function serializeAws_ec2ModifyVpcEndpointServiceConfigurationCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2ModifyVpcEndpointServiceConfigurationRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "ModifyVpcEndpointServiceConfiguration", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2ModifyVpcEndpointServiceConfigurationCommand = serializeAws_ec2ModifyVpcEndpointServiceConfigurationCommand;
async function serializeAws_ec2ModifyVpcEndpointServicePermissionsCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2ModifyVpcEndpointServicePermissionsRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "ModifyVpcEndpointServicePermissions", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2ModifyVpcEndpointServicePermissionsCommand = serializeAws_ec2ModifyVpcEndpointServicePermissionsCommand;
async function serializeAws_ec2ModifyVpcPeeringConnectionOptionsCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2ModifyVpcPeeringConnectionOptionsRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "ModifyVpcPeeringConnectionOptions", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2ModifyVpcPeeringConnectionOptionsCommand = serializeAws_ec2ModifyVpcPeeringConnectionOptionsCommand;
async function serializeAws_ec2ModifyVpcTenancyCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2ModifyVpcTenancyRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "ModifyVpcTenancy", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2ModifyVpcTenancyCommand = serializeAws_ec2ModifyVpcTenancyCommand;
async function serializeAws_ec2ModifyVpnConnectionCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2ModifyVpnConnectionRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "ModifyVpnConnection", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2ModifyVpnConnectionCommand = serializeAws_ec2ModifyVpnConnectionCommand;
async function serializeAws_ec2ModifyVpnTunnelCertificateCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2ModifyVpnTunnelCertificateRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "ModifyVpnTunnelCertificate", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2ModifyVpnTunnelCertificateCommand = serializeAws_ec2ModifyVpnTunnelCertificateCommand;
async function serializeAws_ec2ModifyVpnTunnelOptionsCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2ModifyVpnTunnelOptionsRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "ModifyVpnTunnelOptions", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2ModifyVpnTunnelOptionsCommand = serializeAws_ec2ModifyVpnTunnelOptionsCommand;
async function serializeAws_ec2MonitorInstancesCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2MonitorInstancesRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "MonitorInstances", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2MonitorInstancesCommand = serializeAws_ec2MonitorInstancesCommand;
async function serializeAws_ec2MoveAddressToVpcCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2MoveAddressToVpcRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "MoveAddressToVpc", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2MoveAddressToVpcCommand = serializeAws_ec2MoveAddressToVpcCommand;
async function serializeAws_ec2ProvisionByoipCidrCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2ProvisionByoipCidrRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "ProvisionByoipCidr", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2ProvisionByoipCidrCommand = serializeAws_ec2ProvisionByoipCidrCommand;
async function serializeAws_ec2PurchaseHostReservationCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2PurchaseHostReservationRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "PurchaseHostReservation", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2PurchaseHostReservationCommand = serializeAws_ec2PurchaseHostReservationCommand;
async function serializeAws_ec2PurchaseReservedInstancesOfferingCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2PurchaseReservedInstancesOfferingRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "PurchaseReservedInstancesOffering", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2PurchaseReservedInstancesOfferingCommand = serializeAws_ec2PurchaseReservedInstancesOfferingCommand;
async function serializeAws_ec2PurchaseScheduledInstancesCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2PurchaseScheduledInstancesRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "PurchaseScheduledInstances", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2PurchaseScheduledInstancesCommand = serializeAws_ec2PurchaseScheduledInstancesCommand;
async function serializeAws_ec2RebootInstancesCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2RebootInstancesRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "RebootInstances", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2RebootInstancesCommand = serializeAws_ec2RebootInstancesCommand;
async function serializeAws_ec2RegisterImageCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2RegisterImageRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "RegisterImage", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2RegisterImageCommand = serializeAws_ec2RegisterImageCommand;
async function serializeAws_ec2RegisterTransitGatewayMulticastGroupMembersCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2RegisterTransitGatewayMulticastGroupMembersRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "RegisterTransitGatewayMulticastGroupMembers", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2RegisterTransitGatewayMulticastGroupMembersCommand = serializeAws_ec2RegisterTransitGatewayMulticastGroupMembersCommand;
async function serializeAws_ec2RegisterTransitGatewayMulticastGroupSourcesCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2RegisterTransitGatewayMulticastGroupSourcesRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "RegisterTransitGatewayMulticastGroupSources", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2RegisterTransitGatewayMulticastGroupSourcesCommand = serializeAws_ec2RegisterTransitGatewayMulticastGroupSourcesCommand;
async function serializeAws_ec2RejectTransitGatewayPeeringAttachmentCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2RejectTransitGatewayPeeringAttachmentRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "RejectTransitGatewayPeeringAttachment", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2RejectTransitGatewayPeeringAttachmentCommand = serializeAws_ec2RejectTransitGatewayPeeringAttachmentCommand;
async function serializeAws_ec2RejectTransitGatewayVpcAttachmentCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2RejectTransitGatewayVpcAttachmentRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "RejectTransitGatewayVpcAttachment", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2RejectTransitGatewayVpcAttachmentCommand = serializeAws_ec2RejectTransitGatewayVpcAttachmentCommand;
async function serializeAws_ec2RejectVpcEndpointConnectionsCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2RejectVpcEndpointConnectionsRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "RejectVpcEndpointConnections", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2RejectVpcEndpointConnectionsCommand = serializeAws_ec2RejectVpcEndpointConnectionsCommand;
async function serializeAws_ec2RejectVpcPeeringConnectionCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2RejectVpcPeeringConnectionRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "RejectVpcPeeringConnection", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2RejectVpcPeeringConnectionCommand = serializeAws_ec2RejectVpcPeeringConnectionCommand;
async function serializeAws_ec2ReleaseAddressCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2ReleaseAddressRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "ReleaseAddress", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2ReleaseAddressCommand = serializeAws_ec2ReleaseAddressCommand;
async function serializeAws_ec2ReleaseHostsCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2ReleaseHostsRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "ReleaseHosts", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2ReleaseHostsCommand = serializeAws_ec2ReleaseHostsCommand;
async function serializeAws_ec2ReplaceIamInstanceProfileAssociationCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2ReplaceIamInstanceProfileAssociationRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "ReplaceIamInstanceProfileAssociation", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2ReplaceIamInstanceProfileAssociationCommand = serializeAws_ec2ReplaceIamInstanceProfileAssociationCommand;
async function serializeAws_ec2ReplaceNetworkAclAssociationCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2ReplaceNetworkAclAssociationRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "ReplaceNetworkAclAssociation", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2ReplaceNetworkAclAssociationCommand = serializeAws_ec2ReplaceNetworkAclAssociationCommand;
async function serializeAws_ec2ReplaceNetworkAclEntryCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2ReplaceNetworkAclEntryRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "ReplaceNetworkAclEntry", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2ReplaceNetworkAclEntryCommand = serializeAws_ec2ReplaceNetworkAclEntryCommand;
async function serializeAws_ec2ReplaceRouteCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2ReplaceRouteRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "ReplaceRoute", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2ReplaceRouteCommand = serializeAws_ec2ReplaceRouteCommand;
async function serializeAws_ec2ReplaceRouteTableAssociationCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2ReplaceRouteTableAssociationRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "ReplaceRouteTableAssociation", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2ReplaceRouteTableAssociationCommand = serializeAws_ec2ReplaceRouteTableAssociationCommand;
async function serializeAws_ec2ReplaceTransitGatewayRouteCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2ReplaceTransitGatewayRouteRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "ReplaceTransitGatewayRoute", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2ReplaceTransitGatewayRouteCommand = serializeAws_ec2ReplaceTransitGatewayRouteCommand;
async function serializeAws_ec2ReportInstanceStatusCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2ReportInstanceStatusRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "ReportInstanceStatus", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2ReportInstanceStatusCommand = serializeAws_ec2ReportInstanceStatusCommand;
async function serializeAws_ec2RequestSpotFleetCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2RequestSpotFleetRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "RequestSpotFleet", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2RequestSpotFleetCommand = serializeAws_ec2RequestSpotFleetCommand;
async function serializeAws_ec2RequestSpotInstancesCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2RequestSpotInstancesRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "RequestSpotInstances", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2RequestSpotInstancesCommand = serializeAws_ec2RequestSpotInstancesCommand;
async function serializeAws_ec2ResetEbsDefaultKmsKeyIdCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2ResetEbsDefaultKmsKeyIdRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "ResetEbsDefaultKmsKeyId", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2ResetEbsDefaultKmsKeyIdCommand = serializeAws_ec2ResetEbsDefaultKmsKeyIdCommand;
async function serializeAws_ec2ResetFpgaImageAttributeCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2ResetFpgaImageAttributeRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "ResetFpgaImageAttribute", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2ResetFpgaImageAttributeCommand = serializeAws_ec2ResetFpgaImageAttributeCommand;
async function serializeAws_ec2ResetImageAttributeCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2ResetImageAttributeRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "ResetImageAttribute", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2ResetImageAttributeCommand = serializeAws_ec2ResetImageAttributeCommand;
async function serializeAws_ec2ResetInstanceAttributeCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2ResetInstanceAttributeRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "ResetInstanceAttribute", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2ResetInstanceAttributeCommand = serializeAws_ec2ResetInstanceAttributeCommand;
async function serializeAws_ec2ResetNetworkInterfaceAttributeCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2ResetNetworkInterfaceAttributeRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "ResetNetworkInterfaceAttribute", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2ResetNetworkInterfaceAttributeCommand = serializeAws_ec2ResetNetworkInterfaceAttributeCommand;
async function serializeAws_ec2ResetSnapshotAttributeCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2ResetSnapshotAttributeRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "ResetSnapshotAttribute", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2ResetSnapshotAttributeCommand = serializeAws_ec2ResetSnapshotAttributeCommand;
async function serializeAws_ec2RestoreAddressToClassicCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2RestoreAddressToClassicRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "RestoreAddressToClassic", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2RestoreAddressToClassicCommand = serializeAws_ec2RestoreAddressToClassicCommand;
async function serializeAws_ec2RevokeClientVpnIngressCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2RevokeClientVpnIngressRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "RevokeClientVpnIngress", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2RevokeClientVpnIngressCommand = serializeAws_ec2RevokeClientVpnIngressCommand;
async function serializeAws_ec2RevokeSecurityGroupEgressCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2RevokeSecurityGroupEgressRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "RevokeSecurityGroupEgress", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2RevokeSecurityGroupEgressCommand = serializeAws_ec2RevokeSecurityGroupEgressCommand;
async function serializeAws_ec2RevokeSecurityGroupIngressCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2RevokeSecurityGroupIngressRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "RevokeSecurityGroupIngress", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2RevokeSecurityGroupIngressCommand = serializeAws_ec2RevokeSecurityGroupIngressCommand;
async function serializeAws_ec2RunInstancesCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2RunInstancesRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "RunInstances", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2RunInstancesCommand = serializeAws_ec2RunInstancesCommand;
async function serializeAws_ec2RunScheduledInstancesCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2RunScheduledInstancesRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "RunScheduledInstances", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2RunScheduledInstancesCommand = serializeAws_ec2RunScheduledInstancesCommand;
async function serializeAws_ec2SearchLocalGatewayRoutesCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2SearchLocalGatewayRoutesRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "SearchLocalGatewayRoutes", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2SearchLocalGatewayRoutesCommand = serializeAws_ec2SearchLocalGatewayRoutesCommand;
async function serializeAws_ec2SearchTransitGatewayMulticastGroupsCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2SearchTransitGatewayMulticastGroupsRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "SearchTransitGatewayMulticastGroups", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2SearchTransitGatewayMulticastGroupsCommand = serializeAws_ec2SearchTransitGatewayMulticastGroupsCommand;
async function serializeAws_ec2SearchTransitGatewayRoutesCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2SearchTransitGatewayRoutesRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "SearchTransitGatewayRoutes", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2SearchTransitGatewayRoutesCommand = serializeAws_ec2SearchTransitGatewayRoutesCommand;
async function serializeAws_ec2SendDiagnosticInterruptCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2SendDiagnosticInterruptRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "SendDiagnosticInterrupt", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2SendDiagnosticInterruptCommand = serializeAws_ec2SendDiagnosticInterruptCommand;
async function serializeAws_ec2StartInstancesCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2StartInstancesRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "StartInstances", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2StartInstancesCommand = serializeAws_ec2StartInstancesCommand;
async function serializeAws_ec2StartVpcEndpointServicePrivateDnsVerificationCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2StartVpcEndpointServicePrivateDnsVerificationRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "StartVpcEndpointServicePrivateDnsVerification", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2StartVpcEndpointServicePrivateDnsVerificationCommand = serializeAws_ec2StartVpcEndpointServicePrivateDnsVerificationCommand;
async function serializeAws_ec2StopInstancesCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2StopInstancesRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "StopInstances", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2StopInstancesCommand = serializeAws_ec2StopInstancesCommand;
async function serializeAws_ec2TerminateClientVpnConnectionsCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2TerminateClientVpnConnectionsRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "TerminateClientVpnConnections", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2TerminateClientVpnConnectionsCommand = serializeAws_ec2TerminateClientVpnConnectionsCommand;
async function serializeAws_ec2TerminateInstancesCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2TerminateInstancesRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "TerminateInstances", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2TerminateInstancesCommand = serializeAws_ec2TerminateInstancesCommand;
async function serializeAws_ec2UnassignIpv6AddressesCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2UnassignIpv6AddressesRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "UnassignIpv6Addresses", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2UnassignIpv6AddressesCommand = serializeAws_ec2UnassignIpv6AddressesCommand;
async function serializeAws_ec2UnassignPrivateIpAddressesCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2UnassignPrivateIpAddressesRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "UnassignPrivateIpAddresses", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2UnassignPrivateIpAddressesCommand = serializeAws_ec2UnassignPrivateIpAddressesCommand;
async function serializeAws_ec2UnmonitorInstancesCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2UnmonitorInstancesRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "UnmonitorInstances", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2UnmonitorInstancesCommand = serializeAws_ec2UnmonitorInstancesCommand;
async function serializeAws_ec2UpdateSecurityGroupRuleDescriptionsEgressCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2UpdateSecurityGroupRuleDescriptionsEgressRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "UpdateSecurityGroupRuleDescriptionsEgress", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2UpdateSecurityGroupRuleDescriptionsEgressCommand = serializeAws_ec2UpdateSecurityGroupRuleDescriptionsEgressCommand;
async function serializeAws_ec2UpdateSecurityGroupRuleDescriptionsIngressCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2UpdateSecurityGroupRuleDescriptionsIngressRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "UpdateSecurityGroupRuleDescriptionsIngress", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2UpdateSecurityGroupRuleDescriptionsIngressCommand = serializeAws_ec2UpdateSecurityGroupRuleDescriptionsIngressCommand;
async function serializeAws_ec2WithdrawByoipCidrCommand(input, context) {
    const headers = {};
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    let body;
    const entries = serializeAws_ec2WithdrawByoipCidrRequest(input, context);
    body = buildFormUrlencodedString(Object.assign(Object.assign({}, entries), { Action: "WithdrawByoipCidr", Version: "2016-11-15" }));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
}
exports.serializeAws_ec2WithdrawByoipCidrCommand = serializeAws_ec2WithdrawByoipCidrCommand;
async function deserializeAws_ec2AcceptReservedInstancesExchangeQuoteCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2AcceptReservedInstancesExchangeQuoteCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2AcceptReservedInstancesExchangeQuoteResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "AcceptReservedInstancesExchangeQuoteResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2AcceptReservedInstancesExchangeQuoteCommand = deserializeAws_ec2AcceptReservedInstancesExchangeQuoteCommand;
async function deserializeAws_ec2AcceptReservedInstancesExchangeQuoteCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2AcceptTransitGatewayPeeringAttachmentCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2AcceptTransitGatewayPeeringAttachmentCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2AcceptTransitGatewayPeeringAttachmentResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "AcceptTransitGatewayPeeringAttachmentResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2AcceptTransitGatewayPeeringAttachmentCommand = deserializeAws_ec2AcceptTransitGatewayPeeringAttachmentCommand;
async function deserializeAws_ec2AcceptTransitGatewayPeeringAttachmentCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2AcceptTransitGatewayVpcAttachmentCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2AcceptTransitGatewayVpcAttachmentCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2AcceptTransitGatewayVpcAttachmentResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "AcceptTransitGatewayVpcAttachmentResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2AcceptTransitGatewayVpcAttachmentCommand = deserializeAws_ec2AcceptTransitGatewayVpcAttachmentCommand;
async function deserializeAws_ec2AcceptTransitGatewayVpcAttachmentCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2AcceptVpcEndpointConnectionsCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2AcceptVpcEndpointConnectionsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2AcceptVpcEndpointConnectionsResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "AcceptVpcEndpointConnectionsResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2AcceptVpcEndpointConnectionsCommand = deserializeAws_ec2AcceptVpcEndpointConnectionsCommand;
async function deserializeAws_ec2AcceptVpcEndpointConnectionsCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2AcceptVpcPeeringConnectionCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2AcceptVpcPeeringConnectionCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2AcceptVpcPeeringConnectionResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "AcceptVpcPeeringConnectionResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2AcceptVpcPeeringConnectionCommand = deserializeAws_ec2AcceptVpcPeeringConnectionCommand;
async function deserializeAws_ec2AcceptVpcPeeringConnectionCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2AdvertiseByoipCidrCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2AdvertiseByoipCidrCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2AdvertiseByoipCidrResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "AdvertiseByoipCidrResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2AdvertiseByoipCidrCommand = deserializeAws_ec2AdvertiseByoipCidrCommand;
async function deserializeAws_ec2AdvertiseByoipCidrCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2AllocateAddressCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2AllocateAddressCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2AllocateAddressResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "AllocateAddressResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2AllocateAddressCommand = deserializeAws_ec2AllocateAddressCommand;
async function deserializeAws_ec2AllocateAddressCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2AllocateHostsCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2AllocateHostsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2AllocateHostsResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "AllocateHostsResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2AllocateHostsCommand = deserializeAws_ec2AllocateHostsCommand;
async function deserializeAws_ec2AllocateHostsCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2ApplySecurityGroupsToClientVpnTargetNetworkCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2ApplySecurityGroupsToClientVpnTargetNetworkCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2ApplySecurityGroupsToClientVpnTargetNetworkResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "ApplySecurityGroupsToClientVpnTargetNetworkResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2ApplySecurityGroupsToClientVpnTargetNetworkCommand = deserializeAws_ec2ApplySecurityGroupsToClientVpnTargetNetworkCommand;
async function deserializeAws_ec2ApplySecurityGroupsToClientVpnTargetNetworkCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2AssignIpv6AddressesCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2AssignIpv6AddressesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2AssignIpv6AddressesResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "AssignIpv6AddressesResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2AssignIpv6AddressesCommand = deserializeAws_ec2AssignIpv6AddressesCommand;
async function deserializeAws_ec2AssignIpv6AddressesCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2AssignPrivateIpAddressesCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2AssignPrivateIpAddressesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2AssignPrivateIpAddressesResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "AssignPrivateIpAddressesResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2AssignPrivateIpAddressesCommand = deserializeAws_ec2AssignPrivateIpAddressesCommand;
async function deserializeAws_ec2AssignPrivateIpAddressesCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2AssociateAddressCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2AssociateAddressCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2AssociateAddressResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "AssociateAddressResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2AssociateAddressCommand = deserializeAws_ec2AssociateAddressCommand;
async function deserializeAws_ec2AssociateAddressCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2AssociateClientVpnTargetNetworkCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2AssociateClientVpnTargetNetworkCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2AssociateClientVpnTargetNetworkResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "AssociateClientVpnTargetNetworkResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2AssociateClientVpnTargetNetworkCommand = deserializeAws_ec2AssociateClientVpnTargetNetworkCommand;
async function deserializeAws_ec2AssociateClientVpnTargetNetworkCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2AssociateDhcpOptionsCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2AssociateDhcpOptionsCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output)
    };
    return Promise.resolve(response);
}
exports.deserializeAws_ec2AssociateDhcpOptionsCommand = deserializeAws_ec2AssociateDhcpOptionsCommand;
async function deserializeAws_ec2AssociateDhcpOptionsCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2AssociateIamInstanceProfileCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2AssociateIamInstanceProfileCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2AssociateIamInstanceProfileResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "AssociateIamInstanceProfileResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2AssociateIamInstanceProfileCommand = deserializeAws_ec2AssociateIamInstanceProfileCommand;
async function deserializeAws_ec2AssociateIamInstanceProfileCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2AssociateRouteTableCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2AssociateRouteTableCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2AssociateRouteTableResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "AssociateRouteTableResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2AssociateRouteTableCommand = deserializeAws_ec2AssociateRouteTableCommand;
async function deserializeAws_ec2AssociateRouteTableCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2AssociateSubnetCidrBlockCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2AssociateSubnetCidrBlockCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2AssociateSubnetCidrBlockResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "AssociateSubnetCidrBlockResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2AssociateSubnetCidrBlockCommand = deserializeAws_ec2AssociateSubnetCidrBlockCommand;
async function deserializeAws_ec2AssociateSubnetCidrBlockCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2AssociateTransitGatewayMulticastDomainCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2AssociateTransitGatewayMulticastDomainCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2AssociateTransitGatewayMulticastDomainResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "AssociateTransitGatewayMulticastDomainResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2AssociateTransitGatewayMulticastDomainCommand = deserializeAws_ec2AssociateTransitGatewayMulticastDomainCommand;
async function deserializeAws_ec2AssociateTransitGatewayMulticastDomainCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2AssociateTransitGatewayRouteTableCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2AssociateTransitGatewayRouteTableCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2AssociateTransitGatewayRouteTableResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "AssociateTransitGatewayRouteTableResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2AssociateTransitGatewayRouteTableCommand = deserializeAws_ec2AssociateTransitGatewayRouteTableCommand;
async function deserializeAws_ec2AssociateTransitGatewayRouteTableCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2AssociateVpcCidrBlockCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2AssociateVpcCidrBlockCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2AssociateVpcCidrBlockResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "AssociateVpcCidrBlockResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2AssociateVpcCidrBlockCommand = deserializeAws_ec2AssociateVpcCidrBlockCommand;
async function deserializeAws_ec2AssociateVpcCidrBlockCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2AttachClassicLinkVpcCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2AttachClassicLinkVpcCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2AttachClassicLinkVpcResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "AttachClassicLinkVpcResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2AttachClassicLinkVpcCommand = deserializeAws_ec2AttachClassicLinkVpcCommand;
async function deserializeAws_ec2AttachClassicLinkVpcCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2AttachInternetGatewayCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2AttachInternetGatewayCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output)
    };
    return Promise.resolve(response);
}
exports.deserializeAws_ec2AttachInternetGatewayCommand = deserializeAws_ec2AttachInternetGatewayCommand;
async function deserializeAws_ec2AttachInternetGatewayCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2AttachNetworkInterfaceCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2AttachNetworkInterfaceCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2AttachNetworkInterfaceResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "AttachNetworkInterfaceResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2AttachNetworkInterfaceCommand = deserializeAws_ec2AttachNetworkInterfaceCommand;
async function deserializeAws_ec2AttachNetworkInterfaceCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2AttachVolumeCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2AttachVolumeCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2VolumeAttachment(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "VolumeAttachment" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2AttachVolumeCommand = deserializeAws_ec2AttachVolumeCommand;
async function deserializeAws_ec2AttachVolumeCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2AttachVpnGatewayCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2AttachVpnGatewayCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2AttachVpnGatewayResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "AttachVpnGatewayResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2AttachVpnGatewayCommand = deserializeAws_ec2AttachVpnGatewayCommand;
async function deserializeAws_ec2AttachVpnGatewayCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2AuthorizeClientVpnIngressCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2AuthorizeClientVpnIngressCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2AuthorizeClientVpnIngressResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "AuthorizeClientVpnIngressResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2AuthorizeClientVpnIngressCommand = deserializeAws_ec2AuthorizeClientVpnIngressCommand;
async function deserializeAws_ec2AuthorizeClientVpnIngressCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2AuthorizeSecurityGroupEgressCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2AuthorizeSecurityGroupEgressCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output)
    };
    return Promise.resolve(response);
}
exports.deserializeAws_ec2AuthorizeSecurityGroupEgressCommand = deserializeAws_ec2AuthorizeSecurityGroupEgressCommand;
async function deserializeAws_ec2AuthorizeSecurityGroupEgressCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2AuthorizeSecurityGroupIngressCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2AuthorizeSecurityGroupIngressCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output)
    };
    return Promise.resolve(response);
}
exports.deserializeAws_ec2AuthorizeSecurityGroupIngressCommand = deserializeAws_ec2AuthorizeSecurityGroupIngressCommand;
async function deserializeAws_ec2AuthorizeSecurityGroupIngressCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2BundleInstanceCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2BundleInstanceCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2BundleInstanceResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "BundleInstanceResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2BundleInstanceCommand = deserializeAws_ec2BundleInstanceCommand;
async function deserializeAws_ec2BundleInstanceCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2CancelBundleTaskCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2CancelBundleTaskCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2CancelBundleTaskResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "CancelBundleTaskResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2CancelBundleTaskCommand = deserializeAws_ec2CancelBundleTaskCommand;
async function deserializeAws_ec2CancelBundleTaskCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2CancelCapacityReservationCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2CancelCapacityReservationCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2CancelCapacityReservationResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "CancelCapacityReservationResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2CancelCapacityReservationCommand = deserializeAws_ec2CancelCapacityReservationCommand;
async function deserializeAws_ec2CancelCapacityReservationCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2CancelConversionTaskCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2CancelConversionTaskCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output)
    };
    return Promise.resolve(response);
}
exports.deserializeAws_ec2CancelConversionTaskCommand = deserializeAws_ec2CancelConversionTaskCommand;
async function deserializeAws_ec2CancelConversionTaskCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2CancelExportTaskCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2CancelExportTaskCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output)
    };
    return Promise.resolve(response);
}
exports.deserializeAws_ec2CancelExportTaskCommand = deserializeAws_ec2CancelExportTaskCommand;
async function deserializeAws_ec2CancelExportTaskCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2CancelImportTaskCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2CancelImportTaskCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2CancelImportTaskResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "CancelImportTaskResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2CancelImportTaskCommand = deserializeAws_ec2CancelImportTaskCommand;
async function deserializeAws_ec2CancelImportTaskCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2CancelReservedInstancesListingCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2CancelReservedInstancesListingCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2CancelReservedInstancesListingResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "CancelReservedInstancesListingResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2CancelReservedInstancesListingCommand = deserializeAws_ec2CancelReservedInstancesListingCommand;
async function deserializeAws_ec2CancelReservedInstancesListingCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2CancelSpotFleetRequestsCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2CancelSpotFleetRequestsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2CancelSpotFleetRequestsResponse(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "CancelSpotFleetRequestsResponse" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2CancelSpotFleetRequestsCommand = deserializeAws_ec2CancelSpotFleetRequestsCommand;
async function deserializeAws_ec2CancelSpotFleetRequestsCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2CancelSpotInstanceRequestsCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2CancelSpotInstanceRequestsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2CancelSpotInstanceRequestsResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "CancelSpotInstanceRequestsResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2CancelSpotInstanceRequestsCommand = deserializeAws_ec2CancelSpotInstanceRequestsCommand;
async function deserializeAws_ec2CancelSpotInstanceRequestsCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2ConfirmProductInstanceCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2ConfirmProductInstanceCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2ConfirmProductInstanceResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "ConfirmProductInstanceResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2ConfirmProductInstanceCommand = deserializeAws_ec2ConfirmProductInstanceCommand;
async function deserializeAws_ec2ConfirmProductInstanceCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2CopyFpgaImageCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2CopyFpgaImageCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2CopyFpgaImageResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "CopyFpgaImageResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2CopyFpgaImageCommand = deserializeAws_ec2CopyFpgaImageCommand;
async function deserializeAws_ec2CopyFpgaImageCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2CopyImageCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2CopyImageCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2CopyImageResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "CopyImageResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2CopyImageCommand = deserializeAws_ec2CopyImageCommand;
async function deserializeAws_ec2CopyImageCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2CopySnapshotCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2CopySnapshotCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2CopySnapshotResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "CopySnapshotResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2CopySnapshotCommand = deserializeAws_ec2CopySnapshotCommand;
async function deserializeAws_ec2CopySnapshotCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2CreateCapacityReservationCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2CreateCapacityReservationCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2CreateCapacityReservationResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "CreateCapacityReservationResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2CreateCapacityReservationCommand = deserializeAws_ec2CreateCapacityReservationCommand;
async function deserializeAws_ec2CreateCapacityReservationCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2CreateClientVpnEndpointCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2CreateClientVpnEndpointCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2CreateClientVpnEndpointResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "CreateClientVpnEndpointResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2CreateClientVpnEndpointCommand = deserializeAws_ec2CreateClientVpnEndpointCommand;
async function deserializeAws_ec2CreateClientVpnEndpointCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2CreateClientVpnRouteCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2CreateClientVpnRouteCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2CreateClientVpnRouteResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "CreateClientVpnRouteResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2CreateClientVpnRouteCommand = deserializeAws_ec2CreateClientVpnRouteCommand;
async function deserializeAws_ec2CreateClientVpnRouteCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2CreateCustomerGatewayCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2CreateCustomerGatewayCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2CreateCustomerGatewayResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "CreateCustomerGatewayResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2CreateCustomerGatewayCommand = deserializeAws_ec2CreateCustomerGatewayCommand;
async function deserializeAws_ec2CreateCustomerGatewayCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2CreateDefaultSubnetCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2CreateDefaultSubnetCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2CreateDefaultSubnetResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "CreateDefaultSubnetResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2CreateDefaultSubnetCommand = deserializeAws_ec2CreateDefaultSubnetCommand;
async function deserializeAws_ec2CreateDefaultSubnetCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2CreateDefaultVpcCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2CreateDefaultVpcCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2CreateDefaultVpcResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "CreateDefaultVpcResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2CreateDefaultVpcCommand = deserializeAws_ec2CreateDefaultVpcCommand;
async function deserializeAws_ec2CreateDefaultVpcCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2CreateDhcpOptionsCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2CreateDhcpOptionsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2CreateDhcpOptionsResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "CreateDhcpOptionsResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2CreateDhcpOptionsCommand = deserializeAws_ec2CreateDhcpOptionsCommand;
async function deserializeAws_ec2CreateDhcpOptionsCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2CreateEgressOnlyInternetGatewayCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2CreateEgressOnlyInternetGatewayCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2CreateEgressOnlyInternetGatewayResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "CreateEgressOnlyInternetGatewayResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2CreateEgressOnlyInternetGatewayCommand = deserializeAws_ec2CreateEgressOnlyInternetGatewayCommand;
async function deserializeAws_ec2CreateEgressOnlyInternetGatewayCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2CreateFleetCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2CreateFleetCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2CreateFleetResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "CreateFleetResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2CreateFleetCommand = deserializeAws_ec2CreateFleetCommand;
async function deserializeAws_ec2CreateFleetCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2CreateFlowLogsCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2CreateFlowLogsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2CreateFlowLogsResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "CreateFlowLogsResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2CreateFlowLogsCommand = deserializeAws_ec2CreateFlowLogsCommand;
async function deserializeAws_ec2CreateFlowLogsCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2CreateFpgaImageCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2CreateFpgaImageCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2CreateFpgaImageResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "CreateFpgaImageResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2CreateFpgaImageCommand = deserializeAws_ec2CreateFpgaImageCommand;
async function deserializeAws_ec2CreateFpgaImageCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2CreateImageCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2CreateImageCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2CreateImageResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "CreateImageResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2CreateImageCommand = deserializeAws_ec2CreateImageCommand;
async function deserializeAws_ec2CreateImageCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2CreateInstanceExportTaskCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2CreateInstanceExportTaskCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2CreateInstanceExportTaskResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "CreateInstanceExportTaskResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2CreateInstanceExportTaskCommand = deserializeAws_ec2CreateInstanceExportTaskCommand;
async function deserializeAws_ec2CreateInstanceExportTaskCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2CreateInternetGatewayCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2CreateInternetGatewayCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2CreateInternetGatewayResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "CreateInternetGatewayResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2CreateInternetGatewayCommand = deserializeAws_ec2CreateInternetGatewayCommand;
async function deserializeAws_ec2CreateInternetGatewayCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2CreateKeyPairCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2CreateKeyPairCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2KeyPair(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "KeyPair" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2CreateKeyPairCommand = deserializeAws_ec2CreateKeyPairCommand;
async function deserializeAws_ec2CreateKeyPairCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2CreateLaunchTemplateCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2CreateLaunchTemplateCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2CreateLaunchTemplateResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "CreateLaunchTemplateResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2CreateLaunchTemplateCommand = deserializeAws_ec2CreateLaunchTemplateCommand;
async function deserializeAws_ec2CreateLaunchTemplateCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2CreateLaunchTemplateVersionCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2CreateLaunchTemplateVersionCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2CreateLaunchTemplateVersionResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "CreateLaunchTemplateVersionResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2CreateLaunchTemplateVersionCommand = deserializeAws_ec2CreateLaunchTemplateVersionCommand;
async function deserializeAws_ec2CreateLaunchTemplateVersionCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2CreateLocalGatewayRouteCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2CreateLocalGatewayRouteCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2CreateLocalGatewayRouteResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "CreateLocalGatewayRouteResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2CreateLocalGatewayRouteCommand = deserializeAws_ec2CreateLocalGatewayRouteCommand;
async function deserializeAws_ec2CreateLocalGatewayRouteCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2CreateLocalGatewayRouteTableVpcAssociationCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2CreateLocalGatewayRouteTableVpcAssociationCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2CreateLocalGatewayRouteTableVpcAssociationResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "CreateLocalGatewayRouteTableVpcAssociationResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2CreateLocalGatewayRouteTableVpcAssociationCommand = deserializeAws_ec2CreateLocalGatewayRouteTableVpcAssociationCommand;
async function deserializeAws_ec2CreateLocalGatewayRouteTableVpcAssociationCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2CreateNatGatewayCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2CreateNatGatewayCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2CreateNatGatewayResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "CreateNatGatewayResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2CreateNatGatewayCommand = deserializeAws_ec2CreateNatGatewayCommand;
async function deserializeAws_ec2CreateNatGatewayCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2CreateNetworkAclCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2CreateNetworkAclCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2CreateNetworkAclResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "CreateNetworkAclResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2CreateNetworkAclCommand = deserializeAws_ec2CreateNetworkAclCommand;
async function deserializeAws_ec2CreateNetworkAclCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2CreateNetworkAclEntryCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2CreateNetworkAclEntryCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output)
    };
    return Promise.resolve(response);
}
exports.deserializeAws_ec2CreateNetworkAclEntryCommand = deserializeAws_ec2CreateNetworkAclEntryCommand;
async function deserializeAws_ec2CreateNetworkAclEntryCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2CreateNetworkInterfaceCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2CreateNetworkInterfaceCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2CreateNetworkInterfaceResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "CreateNetworkInterfaceResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2CreateNetworkInterfaceCommand = deserializeAws_ec2CreateNetworkInterfaceCommand;
async function deserializeAws_ec2CreateNetworkInterfaceCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2CreateNetworkInterfacePermissionCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2CreateNetworkInterfacePermissionCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2CreateNetworkInterfacePermissionResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "CreateNetworkInterfacePermissionResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2CreateNetworkInterfacePermissionCommand = deserializeAws_ec2CreateNetworkInterfacePermissionCommand;
async function deserializeAws_ec2CreateNetworkInterfacePermissionCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2CreatePlacementGroupCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2CreatePlacementGroupCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output)
    };
    return Promise.resolve(response);
}
exports.deserializeAws_ec2CreatePlacementGroupCommand = deserializeAws_ec2CreatePlacementGroupCommand;
async function deserializeAws_ec2CreatePlacementGroupCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2CreateReservedInstancesListingCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2CreateReservedInstancesListingCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2CreateReservedInstancesListingResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "CreateReservedInstancesListingResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2CreateReservedInstancesListingCommand = deserializeAws_ec2CreateReservedInstancesListingCommand;
async function deserializeAws_ec2CreateReservedInstancesListingCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2CreateRouteCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2CreateRouteCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2CreateRouteResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "CreateRouteResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2CreateRouteCommand = deserializeAws_ec2CreateRouteCommand;
async function deserializeAws_ec2CreateRouteCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2CreateRouteTableCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2CreateRouteTableCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2CreateRouteTableResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "CreateRouteTableResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2CreateRouteTableCommand = deserializeAws_ec2CreateRouteTableCommand;
async function deserializeAws_ec2CreateRouteTableCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2CreateSecurityGroupCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2CreateSecurityGroupCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2CreateSecurityGroupResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "CreateSecurityGroupResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2CreateSecurityGroupCommand = deserializeAws_ec2CreateSecurityGroupCommand;
async function deserializeAws_ec2CreateSecurityGroupCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2CreateSnapshotCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2CreateSnapshotCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2Snapshot(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "Snapshot" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2CreateSnapshotCommand = deserializeAws_ec2CreateSnapshotCommand;
async function deserializeAws_ec2CreateSnapshotCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2CreateSnapshotsCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2CreateSnapshotsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2CreateSnapshotsResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "CreateSnapshotsResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2CreateSnapshotsCommand = deserializeAws_ec2CreateSnapshotsCommand;
async function deserializeAws_ec2CreateSnapshotsCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2CreateSpotDatafeedSubscriptionCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2CreateSpotDatafeedSubscriptionCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2CreateSpotDatafeedSubscriptionResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "CreateSpotDatafeedSubscriptionResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2CreateSpotDatafeedSubscriptionCommand = deserializeAws_ec2CreateSpotDatafeedSubscriptionCommand;
async function deserializeAws_ec2CreateSpotDatafeedSubscriptionCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2CreateSubnetCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2CreateSubnetCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2CreateSubnetResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "CreateSubnetResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2CreateSubnetCommand = deserializeAws_ec2CreateSubnetCommand;
async function deserializeAws_ec2CreateSubnetCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2CreateTagsCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2CreateTagsCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output)
    };
    return Promise.resolve(response);
}
exports.deserializeAws_ec2CreateTagsCommand = deserializeAws_ec2CreateTagsCommand;
async function deserializeAws_ec2CreateTagsCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2CreateTrafficMirrorFilterCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2CreateTrafficMirrorFilterCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2CreateTrafficMirrorFilterResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "CreateTrafficMirrorFilterResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2CreateTrafficMirrorFilterCommand = deserializeAws_ec2CreateTrafficMirrorFilterCommand;
async function deserializeAws_ec2CreateTrafficMirrorFilterCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2CreateTrafficMirrorFilterRuleCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2CreateTrafficMirrorFilterRuleCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2CreateTrafficMirrorFilterRuleResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "CreateTrafficMirrorFilterRuleResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2CreateTrafficMirrorFilterRuleCommand = deserializeAws_ec2CreateTrafficMirrorFilterRuleCommand;
async function deserializeAws_ec2CreateTrafficMirrorFilterRuleCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2CreateTrafficMirrorSessionCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2CreateTrafficMirrorSessionCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2CreateTrafficMirrorSessionResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "CreateTrafficMirrorSessionResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2CreateTrafficMirrorSessionCommand = deserializeAws_ec2CreateTrafficMirrorSessionCommand;
async function deserializeAws_ec2CreateTrafficMirrorSessionCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2CreateTrafficMirrorTargetCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2CreateTrafficMirrorTargetCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2CreateTrafficMirrorTargetResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "CreateTrafficMirrorTargetResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2CreateTrafficMirrorTargetCommand = deserializeAws_ec2CreateTrafficMirrorTargetCommand;
async function deserializeAws_ec2CreateTrafficMirrorTargetCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2CreateTransitGatewayCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2CreateTransitGatewayCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2CreateTransitGatewayResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "CreateTransitGatewayResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2CreateTransitGatewayCommand = deserializeAws_ec2CreateTransitGatewayCommand;
async function deserializeAws_ec2CreateTransitGatewayCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2CreateTransitGatewayMulticastDomainCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2CreateTransitGatewayMulticastDomainCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2CreateTransitGatewayMulticastDomainResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "CreateTransitGatewayMulticastDomainResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2CreateTransitGatewayMulticastDomainCommand = deserializeAws_ec2CreateTransitGatewayMulticastDomainCommand;
async function deserializeAws_ec2CreateTransitGatewayMulticastDomainCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2CreateTransitGatewayPeeringAttachmentCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2CreateTransitGatewayPeeringAttachmentCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2CreateTransitGatewayPeeringAttachmentResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "CreateTransitGatewayPeeringAttachmentResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2CreateTransitGatewayPeeringAttachmentCommand = deserializeAws_ec2CreateTransitGatewayPeeringAttachmentCommand;
async function deserializeAws_ec2CreateTransitGatewayPeeringAttachmentCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2CreateTransitGatewayRouteCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2CreateTransitGatewayRouteCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2CreateTransitGatewayRouteResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "CreateTransitGatewayRouteResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2CreateTransitGatewayRouteCommand = deserializeAws_ec2CreateTransitGatewayRouteCommand;
async function deserializeAws_ec2CreateTransitGatewayRouteCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2CreateTransitGatewayRouteTableCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2CreateTransitGatewayRouteTableCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2CreateTransitGatewayRouteTableResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "CreateTransitGatewayRouteTableResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2CreateTransitGatewayRouteTableCommand = deserializeAws_ec2CreateTransitGatewayRouteTableCommand;
async function deserializeAws_ec2CreateTransitGatewayRouteTableCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2CreateTransitGatewayVpcAttachmentCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2CreateTransitGatewayVpcAttachmentCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2CreateTransitGatewayVpcAttachmentResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "CreateTransitGatewayVpcAttachmentResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2CreateTransitGatewayVpcAttachmentCommand = deserializeAws_ec2CreateTransitGatewayVpcAttachmentCommand;
async function deserializeAws_ec2CreateTransitGatewayVpcAttachmentCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2CreateVolumeCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2CreateVolumeCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2Volume(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "Volume" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2CreateVolumeCommand = deserializeAws_ec2CreateVolumeCommand;
async function deserializeAws_ec2CreateVolumeCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2CreateVpcCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2CreateVpcCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2CreateVpcResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "CreateVpcResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2CreateVpcCommand = deserializeAws_ec2CreateVpcCommand;
async function deserializeAws_ec2CreateVpcCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2CreateVpcEndpointCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2CreateVpcEndpointCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2CreateVpcEndpointResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "CreateVpcEndpointResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2CreateVpcEndpointCommand = deserializeAws_ec2CreateVpcEndpointCommand;
async function deserializeAws_ec2CreateVpcEndpointCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2CreateVpcEndpointConnectionNotificationCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2CreateVpcEndpointConnectionNotificationCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2CreateVpcEndpointConnectionNotificationResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "CreateVpcEndpointConnectionNotificationResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2CreateVpcEndpointConnectionNotificationCommand = deserializeAws_ec2CreateVpcEndpointConnectionNotificationCommand;
async function deserializeAws_ec2CreateVpcEndpointConnectionNotificationCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2CreateVpcEndpointServiceConfigurationCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2CreateVpcEndpointServiceConfigurationCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2CreateVpcEndpointServiceConfigurationResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "CreateVpcEndpointServiceConfigurationResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2CreateVpcEndpointServiceConfigurationCommand = deserializeAws_ec2CreateVpcEndpointServiceConfigurationCommand;
async function deserializeAws_ec2CreateVpcEndpointServiceConfigurationCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2CreateVpcPeeringConnectionCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2CreateVpcPeeringConnectionCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2CreateVpcPeeringConnectionResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "CreateVpcPeeringConnectionResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2CreateVpcPeeringConnectionCommand = deserializeAws_ec2CreateVpcPeeringConnectionCommand;
async function deserializeAws_ec2CreateVpcPeeringConnectionCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2CreateVpnConnectionCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2CreateVpnConnectionCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2CreateVpnConnectionResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "CreateVpnConnectionResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2CreateVpnConnectionCommand = deserializeAws_ec2CreateVpnConnectionCommand;
async function deserializeAws_ec2CreateVpnConnectionCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2CreateVpnConnectionRouteCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2CreateVpnConnectionRouteCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output)
    };
    return Promise.resolve(response);
}
exports.deserializeAws_ec2CreateVpnConnectionRouteCommand = deserializeAws_ec2CreateVpnConnectionRouteCommand;
async function deserializeAws_ec2CreateVpnConnectionRouteCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2CreateVpnGatewayCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2CreateVpnGatewayCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2CreateVpnGatewayResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "CreateVpnGatewayResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2CreateVpnGatewayCommand = deserializeAws_ec2CreateVpnGatewayCommand;
async function deserializeAws_ec2CreateVpnGatewayCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DeleteClientVpnEndpointCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DeleteClientVpnEndpointCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DeleteClientVpnEndpointResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DeleteClientVpnEndpointResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DeleteClientVpnEndpointCommand = deserializeAws_ec2DeleteClientVpnEndpointCommand;
async function deserializeAws_ec2DeleteClientVpnEndpointCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DeleteClientVpnRouteCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DeleteClientVpnRouteCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DeleteClientVpnRouteResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DeleteClientVpnRouteResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DeleteClientVpnRouteCommand = deserializeAws_ec2DeleteClientVpnRouteCommand;
async function deserializeAws_ec2DeleteClientVpnRouteCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DeleteCustomerGatewayCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DeleteCustomerGatewayCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output)
    };
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DeleteCustomerGatewayCommand = deserializeAws_ec2DeleteCustomerGatewayCommand;
async function deserializeAws_ec2DeleteCustomerGatewayCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DeleteDhcpOptionsCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DeleteDhcpOptionsCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output)
    };
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DeleteDhcpOptionsCommand = deserializeAws_ec2DeleteDhcpOptionsCommand;
async function deserializeAws_ec2DeleteDhcpOptionsCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DeleteEgressOnlyInternetGatewayCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DeleteEgressOnlyInternetGatewayCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DeleteEgressOnlyInternetGatewayResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DeleteEgressOnlyInternetGatewayResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DeleteEgressOnlyInternetGatewayCommand = deserializeAws_ec2DeleteEgressOnlyInternetGatewayCommand;
async function deserializeAws_ec2DeleteEgressOnlyInternetGatewayCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DeleteFleetsCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DeleteFleetsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DeleteFleetsResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DeleteFleetsResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DeleteFleetsCommand = deserializeAws_ec2DeleteFleetsCommand;
async function deserializeAws_ec2DeleteFleetsCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DeleteFlowLogsCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DeleteFlowLogsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DeleteFlowLogsResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DeleteFlowLogsResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DeleteFlowLogsCommand = deserializeAws_ec2DeleteFlowLogsCommand;
async function deserializeAws_ec2DeleteFlowLogsCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DeleteFpgaImageCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DeleteFpgaImageCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DeleteFpgaImageResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DeleteFpgaImageResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DeleteFpgaImageCommand = deserializeAws_ec2DeleteFpgaImageCommand;
async function deserializeAws_ec2DeleteFpgaImageCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DeleteInternetGatewayCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DeleteInternetGatewayCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output)
    };
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DeleteInternetGatewayCommand = deserializeAws_ec2DeleteInternetGatewayCommand;
async function deserializeAws_ec2DeleteInternetGatewayCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DeleteKeyPairCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DeleteKeyPairCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output)
    };
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DeleteKeyPairCommand = deserializeAws_ec2DeleteKeyPairCommand;
async function deserializeAws_ec2DeleteKeyPairCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DeleteLaunchTemplateCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DeleteLaunchTemplateCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DeleteLaunchTemplateResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DeleteLaunchTemplateResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DeleteLaunchTemplateCommand = deserializeAws_ec2DeleteLaunchTemplateCommand;
async function deserializeAws_ec2DeleteLaunchTemplateCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DeleteLaunchTemplateVersionsCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DeleteLaunchTemplateVersionsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DeleteLaunchTemplateVersionsResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DeleteLaunchTemplateVersionsResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DeleteLaunchTemplateVersionsCommand = deserializeAws_ec2DeleteLaunchTemplateVersionsCommand;
async function deserializeAws_ec2DeleteLaunchTemplateVersionsCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DeleteLocalGatewayRouteCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DeleteLocalGatewayRouteCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DeleteLocalGatewayRouteResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DeleteLocalGatewayRouteResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DeleteLocalGatewayRouteCommand = deserializeAws_ec2DeleteLocalGatewayRouteCommand;
async function deserializeAws_ec2DeleteLocalGatewayRouteCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DeleteLocalGatewayRouteTableVpcAssociationCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DeleteLocalGatewayRouteTableVpcAssociationCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DeleteLocalGatewayRouteTableVpcAssociationResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DeleteLocalGatewayRouteTableVpcAssociationResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DeleteLocalGatewayRouteTableVpcAssociationCommand = deserializeAws_ec2DeleteLocalGatewayRouteTableVpcAssociationCommand;
async function deserializeAws_ec2DeleteLocalGatewayRouteTableVpcAssociationCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DeleteNatGatewayCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DeleteNatGatewayCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DeleteNatGatewayResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DeleteNatGatewayResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DeleteNatGatewayCommand = deserializeAws_ec2DeleteNatGatewayCommand;
async function deserializeAws_ec2DeleteNatGatewayCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DeleteNetworkAclCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DeleteNetworkAclCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output)
    };
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DeleteNetworkAclCommand = deserializeAws_ec2DeleteNetworkAclCommand;
async function deserializeAws_ec2DeleteNetworkAclCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DeleteNetworkAclEntryCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DeleteNetworkAclEntryCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output)
    };
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DeleteNetworkAclEntryCommand = deserializeAws_ec2DeleteNetworkAclEntryCommand;
async function deserializeAws_ec2DeleteNetworkAclEntryCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DeleteNetworkInterfaceCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DeleteNetworkInterfaceCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output)
    };
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DeleteNetworkInterfaceCommand = deserializeAws_ec2DeleteNetworkInterfaceCommand;
async function deserializeAws_ec2DeleteNetworkInterfaceCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DeleteNetworkInterfacePermissionCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DeleteNetworkInterfacePermissionCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DeleteNetworkInterfacePermissionResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DeleteNetworkInterfacePermissionResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DeleteNetworkInterfacePermissionCommand = deserializeAws_ec2DeleteNetworkInterfacePermissionCommand;
async function deserializeAws_ec2DeleteNetworkInterfacePermissionCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DeletePlacementGroupCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DeletePlacementGroupCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output)
    };
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DeletePlacementGroupCommand = deserializeAws_ec2DeletePlacementGroupCommand;
async function deserializeAws_ec2DeletePlacementGroupCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DeleteQueuedReservedInstancesCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DeleteQueuedReservedInstancesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DeleteQueuedReservedInstancesResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DeleteQueuedReservedInstancesResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DeleteQueuedReservedInstancesCommand = deserializeAws_ec2DeleteQueuedReservedInstancesCommand;
async function deserializeAws_ec2DeleteQueuedReservedInstancesCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DeleteRouteCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DeleteRouteCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output)
    };
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DeleteRouteCommand = deserializeAws_ec2DeleteRouteCommand;
async function deserializeAws_ec2DeleteRouteCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DeleteRouteTableCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DeleteRouteTableCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output)
    };
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DeleteRouteTableCommand = deserializeAws_ec2DeleteRouteTableCommand;
async function deserializeAws_ec2DeleteRouteTableCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DeleteSecurityGroupCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DeleteSecurityGroupCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output)
    };
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DeleteSecurityGroupCommand = deserializeAws_ec2DeleteSecurityGroupCommand;
async function deserializeAws_ec2DeleteSecurityGroupCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DeleteSnapshotCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DeleteSnapshotCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output)
    };
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DeleteSnapshotCommand = deserializeAws_ec2DeleteSnapshotCommand;
async function deserializeAws_ec2DeleteSnapshotCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DeleteSpotDatafeedSubscriptionCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DeleteSpotDatafeedSubscriptionCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output)
    };
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DeleteSpotDatafeedSubscriptionCommand = deserializeAws_ec2DeleteSpotDatafeedSubscriptionCommand;
async function deserializeAws_ec2DeleteSpotDatafeedSubscriptionCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DeleteSubnetCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DeleteSubnetCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output)
    };
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DeleteSubnetCommand = deserializeAws_ec2DeleteSubnetCommand;
async function deserializeAws_ec2DeleteSubnetCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DeleteTagsCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DeleteTagsCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output)
    };
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DeleteTagsCommand = deserializeAws_ec2DeleteTagsCommand;
async function deserializeAws_ec2DeleteTagsCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DeleteTrafficMirrorFilterCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DeleteTrafficMirrorFilterCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DeleteTrafficMirrorFilterResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DeleteTrafficMirrorFilterResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DeleteTrafficMirrorFilterCommand = deserializeAws_ec2DeleteTrafficMirrorFilterCommand;
async function deserializeAws_ec2DeleteTrafficMirrorFilterCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DeleteTrafficMirrorFilterRuleCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DeleteTrafficMirrorFilterRuleCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DeleteTrafficMirrorFilterRuleResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DeleteTrafficMirrorFilterRuleResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DeleteTrafficMirrorFilterRuleCommand = deserializeAws_ec2DeleteTrafficMirrorFilterRuleCommand;
async function deserializeAws_ec2DeleteTrafficMirrorFilterRuleCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DeleteTrafficMirrorSessionCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DeleteTrafficMirrorSessionCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DeleteTrafficMirrorSessionResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DeleteTrafficMirrorSessionResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DeleteTrafficMirrorSessionCommand = deserializeAws_ec2DeleteTrafficMirrorSessionCommand;
async function deserializeAws_ec2DeleteTrafficMirrorSessionCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DeleteTrafficMirrorTargetCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DeleteTrafficMirrorTargetCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DeleteTrafficMirrorTargetResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DeleteTrafficMirrorTargetResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DeleteTrafficMirrorTargetCommand = deserializeAws_ec2DeleteTrafficMirrorTargetCommand;
async function deserializeAws_ec2DeleteTrafficMirrorTargetCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DeleteTransitGatewayCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DeleteTransitGatewayCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DeleteTransitGatewayResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DeleteTransitGatewayResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DeleteTransitGatewayCommand = deserializeAws_ec2DeleteTransitGatewayCommand;
async function deserializeAws_ec2DeleteTransitGatewayCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DeleteTransitGatewayMulticastDomainCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DeleteTransitGatewayMulticastDomainCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DeleteTransitGatewayMulticastDomainResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DeleteTransitGatewayMulticastDomainResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DeleteTransitGatewayMulticastDomainCommand = deserializeAws_ec2DeleteTransitGatewayMulticastDomainCommand;
async function deserializeAws_ec2DeleteTransitGatewayMulticastDomainCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DeleteTransitGatewayPeeringAttachmentCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DeleteTransitGatewayPeeringAttachmentCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DeleteTransitGatewayPeeringAttachmentResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DeleteTransitGatewayPeeringAttachmentResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DeleteTransitGatewayPeeringAttachmentCommand = deserializeAws_ec2DeleteTransitGatewayPeeringAttachmentCommand;
async function deserializeAws_ec2DeleteTransitGatewayPeeringAttachmentCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DeleteTransitGatewayRouteCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DeleteTransitGatewayRouteCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DeleteTransitGatewayRouteResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DeleteTransitGatewayRouteResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DeleteTransitGatewayRouteCommand = deserializeAws_ec2DeleteTransitGatewayRouteCommand;
async function deserializeAws_ec2DeleteTransitGatewayRouteCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DeleteTransitGatewayRouteTableCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DeleteTransitGatewayRouteTableCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DeleteTransitGatewayRouteTableResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DeleteTransitGatewayRouteTableResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DeleteTransitGatewayRouteTableCommand = deserializeAws_ec2DeleteTransitGatewayRouteTableCommand;
async function deserializeAws_ec2DeleteTransitGatewayRouteTableCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DeleteTransitGatewayVpcAttachmentCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DeleteTransitGatewayVpcAttachmentCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DeleteTransitGatewayVpcAttachmentResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DeleteTransitGatewayVpcAttachmentResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DeleteTransitGatewayVpcAttachmentCommand = deserializeAws_ec2DeleteTransitGatewayVpcAttachmentCommand;
async function deserializeAws_ec2DeleteTransitGatewayVpcAttachmentCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DeleteVolumeCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DeleteVolumeCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output)
    };
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DeleteVolumeCommand = deserializeAws_ec2DeleteVolumeCommand;
async function deserializeAws_ec2DeleteVolumeCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DeleteVpcCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DeleteVpcCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output)
    };
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DeleteVpcCommand = deserializeAws_ec2DeleteVpcCommand;
async function deserializeAws_ec2DeleteVpcCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DeleteVpcEndpointConnectionNotificationsCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DeleteVpcEndpointConnectionNotificationsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DeleteVpcEndpointConnectionNotificationsResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DeleteVpcEndpointConnectionNotificationsResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DeleteVpcEndpointConnectionNotificationsCommand = deserializeAws_ec2DeleteVpcEndpointConnectionNotificationsCommand;
async function deserializeAws_ec2DeleteVpcEndpointConnectionNotificationsCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DeleteVpcEndpointServiceConfigurationsCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DeleteVpcEndpointServiceConfigurationsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DeleteVpcEndpointServiceConfigurationsResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DeleteVpcEndpointServiceConfigurationsResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DeleteVpcEndpointServiceConfigurationsCommand = deserializeAws_ec2DeleteVpcEndpointServiceConfigurationsCommand;
async function deserializeAws_ec2DeleteVpcEndpointServiceConfigurationsCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DeleteVpcEndpointsCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DeleteVpcEndpointsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DeleteVpcEndpointsResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DeleteVpcEndpointsResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DeleteVpcEndpointsCommand = deserializeAws_ec2DeleteVpcEndpointsCommand;
async function deserializeAws_ec2DeleteVpcEndpointsCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DeleteVpcPeeringConnectionCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DeleteVpcPeeringConnectionCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DeleteVpcPeeringConnectionResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DeleteVpcPeeringConnectionResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DeleteVpcPeeringConnectionCommand = deserializeAws_ec2DeleteVpcPeeringConnectionCommand;
async function deserializeAws_ec2DeleteVpcPeeringConnectionCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DeleteVpnConnectionCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DeleteVpnConnectionCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output)
    };
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DeleteVpnConnectionCommand = deserializeAws_ec2DeleteVpnConnectionCommand;
async function deserializeAws_ec2DeleteVpnConnectionCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DeleteVpnConnectionRouteCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DeleteVpnConnectionRouteCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output)
    };
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DeleteVpnConnectionRouteCommand = deserializeAws_ec2DeleteVpnConnectionRouteCommand;
async function deserializeAws_ec2DeleteVpnConnectionRouteCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DeleteVpnGatewayCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DeleteVpnGatewayCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output)
    };
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DeleteVpnGatewayCommand = deserializeAws_ec2DeleteVpnGatewayCommand;
async function deserializeAws_ec2DeleteVpnGatewayCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DeprovisionByoipCidrCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DeprovisionByoipCidrCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DeprovisionByoipCidrResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DeprovisionByoipCidrResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DeprovisionByoipCidrCommand = deserializeAws_ec2DeprovisionByoipCidrCommand;
async function deserializeAws_ec2DeprovisionByoipCidrCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DeregisterImageCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DeregisterImageCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output)
    };
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DeregisterImageCommand = deserializeAws_ec2DeregisterImageCommand;
async function deserializeAws_ec2DeregisterImageCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DeregisterTransitGatewayMulticastGroupMembersCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DeregisterTransitGatewayMulticastGroupMembersCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DeregisterTransitGatewayMulticastGroupMembersResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DeregisterTransitGatewayMulticastGroupMembersResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DeregisterTransitGatewayMulticastGroupMembersCommand = deserializeAws_ec2DeregisterTransitGatewayMulticastGroupMembersCommand;
async function deserializeAws_ec2DeregisterTransitGatewayMulticastGroupMembersCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DeregisterTransitGatewayMulticastGroupSourcesCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DeregisterTransitGatewayMulticastGroupSourcesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DeregisterTransitGatewayMulticastGroupSourcesResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DeregisterTransitGatewayMulticastGroupSourcesResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DeregisterTransitGatewayMulticastGroupSourcesCommand = deserializeAws_ec2DeregisterTransitGatewayMulticastGroupSourcesCommand;
async function deserializeAws_ec2DeregisterTransitGatewayMulticastGroupSourcesCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeAccountAttributesCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeAccountAttributesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribeAccountAttributesResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeAccountAttributesResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeAccountAttributesCommand = deserializeAws_ec2DescribeAccountAttributesCommand;
async function deserializeAws_ec2DescribeAccountAttributesCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeAddressesCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeAddressesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribeAddressesResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeAddressesResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeAddressesCommand = deserializeAws_ec2DescribeAddressesCommand;
async function deserializeAws_ec2DescribeAddressesCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeAggregateIdFormatCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeAggregateIdFormatCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribeAggregateIdFormatResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeAggregateIdFormatResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeAggregateIdFormatCommand = deserializeAws_ec2DescribeAggregateIdFormatCommand;
async function deserializeAws_ec2DescribeAggregateIdFormatCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeAvailabilityZonesCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeAvailabilityZonesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribeAvailabilityZonesResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeAvailabilityZonesResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeAvailabilityZonesCommand = deserializeAws_ec2DescribeAvailabilityZonesCommand;
async function deserializeAws_ec2DescribeAvailabilityZonesCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeBundleTasksCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeBundleTasksCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribeBundleTasksResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeBundleTasksResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeBundleTasksCommand = deserializeAws_ec2DescribeBundleTasksCommand;
async function deserializeAws_ec2DescribeBundleTasksCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeByoipCidrsCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeByoipCidrsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribeByoipCidrsResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeByoipCidrsResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeByoipCidrsCommand = deserializeAws_ec2DescribeByoipCidrsCommand;
async function deserializeAws_ec2DescribeByoipCidrsCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeCapacityReservationsCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeCapacityReservationsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribeCapacityReservationsResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeCapacityReservationsResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeCapacityReservationsCommand = deserializeAws_ec2DescribeCapacityReservationsCommand;
async function deserializeAws_ec2DescribeCapacityReservationsCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeClassicLinkInstancesCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeClassicLinkInstancesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribeClassicLinkInstancesResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeClassicLinkInstancesResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeClassicLinkInstancesCommand = deserializeAws_ec2DescribeClassicLinkInstancesCommand;
async function deserializeAws_ec2DescribeClassicLinkInstancesCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeClientVpnAuthorizationRulesCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeClientVpnAuthorizationRulesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribeClientVpnAuthorizationRulesResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeClientVpnAuthorizationRulesResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeClientVpnAuthorizationRulesCommand = deserializeAws_ec2DescribeClientVpnAuthorizationRulesCommand;
async function deserializeAws_ec2DescribeClientVpnAuthorizationRulesCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeClientVpnConnectionsCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeClientVpnConnectionsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribeClientVpnConnectionsResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeClientVpnConnectionsResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeClientVpnConnectionsCommand = deserializeAws_ec2DescribeClientVpnConnectionsCommand;
async function deserializeAws_ec2DescribeClientVpnConnectionsCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeClientVpnEndpointsCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeClientVpnEndpointsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribeClientVpnEndpointsResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeClientVpnEndpointsResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeClientVpnEndpointsCommand = deserializeAws_ec2DescribeClientVpnEndpointsCommand;
async function deserializeAws_ec2DescribeClientVpnEndpointsCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeClientVpnRoutesCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeClientVpnRoutesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribeClientVpnRoutesResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeClientVpnRoutesResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeClientVpnRoutesCommand = deserializeAws_ec2DescribeClientVpnRoutesCommand;
async function deserializeAws_ec2DescribeClientVpnRoutesCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeClientVpnTargetNetworksCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeClientVpnTargetNetworksCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribeClientVpnTargetNetworksResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeClientVpnTargetNetworksResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeClientVpnTargetNetworksCommand = deserializeAws_ec2DescribeClientVpnTargetNetworksCommand;
async function deserializeAws_ec2DescribeClientVpnTargetNetworksCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeCoipPoolsCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeCoipPoolsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribeCoipPoolsResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeCoipPoolsResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeCoipPoolsCommand = deserializeAws_ec2DescribeCoipPoolsCommand;
async function deserializeAws_ec2DescribeCoipPoolsCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeConversionTasksCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeConversionTasksCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribeConversionTasksResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeConversionTasksResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeConversionTasksCommand = deserializeAws_ec2DescribeConversionTasksCommand;
async function deserializeAws_ec2DescribeConversionTasksCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeCustomerGatewaysCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeCustomerGatewaysCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribeCustomerGatewaysResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeCustomerGatewaysResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeCustomerGatewaysCommand = deserializeAws_ec2DescribeCustomerGatewaysCommand;
async function deserializeAws_ec2DescribeCustomerGatewaysCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeDhcpOptionsCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeDhcpOptionsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribeDhcpOptionsResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeDhcpOptionsResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeDhcpOptionsCommand = deserializeAws_ec2DescribeDhcpOptionsCommand;
async function deserializeAws_ec2DescribeDhcpOptionsCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeEgressOnlyInternetGatewaysCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeEgressOnlyInternetGatewaysCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribeEgressOnlyInternetGatewaysResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeEgressOnlyInternetGatewaysResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeEgressOnlyInternetGatewaysCommand = deserializeAws_ec2DescribeEgressOnlyInternetGatewaysCommand;
async function deserializeAws_ec2DescribeEgressOnlyInternetGatewaysCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeElasticGpusCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeElasticGpusCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribeElasticGpusResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeElasticGpusResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeElasticGpusCommand = deserializeAws_ec2DescribeElasticGpusCommand;
async function deserializeAws_ec2DescribeElasticGpusCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeExportImageTasksCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeExportImageTasksCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribeExportImageTasksResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeExportImageTasksResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeExportImageTasksCommand = deserializeAws_ec2DescribeExportImageTasksCommand;
async function deserializeAws_ec2DescribeExportImageTasksCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeExportTasksCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeExportTasksCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribeExportTasksResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeExportTasksResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeExportTasksCommand = deserializeAws_ec2DescribeExportTasksCommand;
async function deserializeAws_ec2DescribeExportTasksCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeFastSnapshotRestoresCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeFastSnapshotRestoresCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribeFastSnapshotRestoresResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeFastSnapshotRestoresResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeFastSnapshotRestoresCommand = deserializeAws_ec2DescribeFastSnapshotRestoresCommand;
async function deserializeAws_ec2DescribeFastSnapshotRestoresCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeFleetHistoryCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeFleetHistoryCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribeFleetHistoryResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeFleetHistoryResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeFleetHistoryCommand = deserializeAws_ec2DescribeFleetHistoryCommand;
async function deserializeAws_ec2DescribeFleetHistoryCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeFleetInstancesCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeFleetInstancesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribeFleetInstancesResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeFleetInstancesResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeFleetInstancesCommand = deserializeAws_ec2DescribeFleetInstancesCommand;
async function deserializeAws_ec2DescribeFleetInstancesCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeFleetsCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeFleetsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribeFleetsResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeFleetsResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeFleetsCommand = deserializeAws_ec2DescribeFleetsCommand;
async function deserializeAws_ec2DescribeFleetsCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeFlowLogsCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeFlowLogsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribeFlowLogsResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeFlowLogsResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeFlowLogsCommand = deserializeAws_ec2DescribeFlowLogsCommand;
async function deserializeAws_ec2DescribeFlowLogsCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeFpgaImageAttributeCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeFpgaImageAttributeCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribeFpgaImageAttributeResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeFpgaImageAttributeResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeFpgaImageAttributeCommand = deserializeAws_ec2DescribeFpgaImageAttributeCommand;
async function deserializeAws_ec2DescribeFpgaImageAttributeCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeFpgaImagesCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeFpgaImagesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribeFpgaImagesResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeFpgaImagesResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeFpgaImagesCommand = deserializeAws_ec2DescribeFpgaImagesCommand;
async function deserializeAws_ec2DescribeFpgaImagesCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeHostReservationOfferingsCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeHostReservationOfferingsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribeHostReservationOfferingsResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeHostReservationOfferingsResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeHostReservationOfferingsCommand = deserializeAws_ec2DescribeHostReservationOfferingsCommand;
async function deserializeAws_ec2DescribeHostReservationOfferingsCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeHostReservationsCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeHostReservationsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribeHostReservationsResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeHostReservationsResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeHostReservationsCommand = deserializeAws_ec2DescribeHostReservationsCommand;
async function deserializeAws_ec2DescribeHostReservationsCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeHostsCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeHostsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribeHostsResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeHostsResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeHostsCommand = deserializeAws_ec2DescribeHostsCommand;
async function deserializeAws_ec2DescribeHostsCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeIamInstanceProfileAssociationsCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeIamInstanceProfileAssociationsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribeIamInstanceProfileAssociationsResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeIamInstanceProfileAssociationsResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeIamInstanceProfileAssociationsCommand = deserializeAws_ec2DescribeIamInstanceProfileAssociationsCommand;
async function deserializeAws_ec2DescribeIamInstanceProfileAssociationsCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeIdFormatCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeIdFormatCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribeIdFormatResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeIdFormatResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeIdFormatCommand = deserializeAws_ec2DescribeIdFormatCommand;
async function deserializeAws_ec2DescribeIdFormatCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeIdentityIdFormatCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeIdentityIdFormatCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribeIdentityIdFormatResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeIdentityIdFormatResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeIdentityIdFormatCommand = deserializeAws_ec2DescribeIdentityIdFormatCommand;
async function deserializeAws_ec2DescribeIdentityIdFormatCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeImageAttributeCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeImageAttributeCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2ImageAttribute(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "ImageAttribute" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeImageAttributeCommand = deserializeAws_ec2DescribeImageAttributeCommand;
async function deserializeAws_ec2DescribeImageAttributeCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeImagesCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeImagesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribeImagesResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeImagesResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeImagesCommand = deserializeAws_ec2DescribeImagesCommand;
async function deserializeAws_ec2DescribeImagesCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeImportImageTasksCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeImportImageTasksCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribeImportImageTasksResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeImportImageTasksResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeImportImageTasksCommand = deserializeAws_ec2DescribeImportImageTasksCommand;
async function deserializeAws_ec2DescribeImportImageTasksCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeImportSnapshotTasksCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeImportSnapshotTasksCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribeImportSnapshotTasksResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeImportSnapshotTasksResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeImportSnapshotTasksCommand = deserializeAws_ec2DescribeImportSnapshotTasksCommand;
async function deserializeAws_ec2DescribeImportSnapshotTasksCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeInstanceAttributeCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeInstanceAttributeCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2InstanceAttribute(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "InstanceAttribute" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeInstanceAttributeCommand = deserializeAws_ec2DescribeInstanceAttributeCommand;
async function deserializeAws_ec2DescribeInstanceAttributeCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeInstanceCreditSpecificationsCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeInstanceCreditSpecificationsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribeInstanceCreditSpecificationsResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeInstanceCreditSpecificationsResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeInstanceCreditSpecificationsCommand = deserializeAws_ec2DescribeInstanceCreditSpecificationsCommand;
async function deserializeAws_ec2DescribeInstanceCreditSpecificationsCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeInstanceStatusCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeInstanceStatusCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribeInstanceStatusResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeInstanceStatusResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeInstanceStatusCommand = deserializeAws_ec2DescribeInstanceStatusCommand;
async function deserializeAws_ec2DescribeInstanceStatusCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeInstanceTypeOfferingsCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeInstanceTypeOfferingsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribeInstanceTypeOfferingsResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeInstanceTypeOfferingsResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeInstanceTypeOfferingsCommand = deserializeAws_ec2DescribeInstanceTypeOfferingsCommand;
async function deserializeAws_ec2DescribeInstanceTypeOfferingsCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeInstanceTypesCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeInstanceTypesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribeInstanceTypesResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeInstanceTypesResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeInstanceTypesCommand = deserializeAws_ec2DescribeInstanceTypesCommand;
async function deserializeAws_ec2DescribeInstanceTypesCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeInstancesCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeInstancesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribeInstancesResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeInstancesResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeInstancesCommand = deserializeAws_ec2DescribeInstancesCommand;
async function deserializeAws_ec2DescribeInstancesCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeInternetGatewaysCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeInternetGatewaysCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribeInternetGatewaysResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeInternetGatewaysResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeInternetGatewaysCommand = deserializeAws_ec2DescribeInternetGatewaysCommand;
async function deserializeAws_ec2DescribeInternetGatewaysCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeIpv6PoolsCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeIpv6PoolsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribeIpv6PoolsResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeIpv6PoolsResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeIpv6PoolsCommand = deserializeAws_ec2DescribeIpv6PoolsCommand;
async function deserializeAws_ec2DescribeIpv6PoolsCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeKeyPairsCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeKeyPairsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribeKeyPairsResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeKeyPairsResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeKeyPairsCommand = deserializeAws_ec2DescribeKeyPairsCommand;
async function deserializeAws_ec2DescribeKeyPairsCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeLaunchTemplateVersionsCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeLaunchTemplateVersionsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribeLaunchTemplateVersionsResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeLaunchTemplateVersionsResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeLaunchTemplateVersionsCommand = deserializeAws_ec2DescribeLaunchTemplateVersionsCommand;
async function deserializeAws_ec2DescribeLaunchTemplateVersionsCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeLaunchTemplatesCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeLaunchTemplatesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribeLaunchTemplatesResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeLaunchTemplatesResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeLaunchTemplatesCommand = deserializeAws_ec2DescribeLaunchTemplatesCommand;
async function deserializeAws_ec2DescribeLaunchTemplatesCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsCommand = deserializeAws_ec2DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsCommand;
async function deserializeAws_ec2DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeLocalGatewayRouteTableVpcAssociationsCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeLocalGatewayRouteTableVpcAssociationsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribeLocalGatewayRouteTableVpcAssociationsResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeLocalGatewayRouteTableVpcAssociationsResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeLocalGatewayRouteTableVpcAssociationsCommand = deserializeAws_ec2DescribeLocalGatewayRouteTableVpcAssociationsCommand;
async function deserializeAws_ec2DescribeLocalGatewayRouteTableVpcAssociationsCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeLocalGatewayRouteTablesCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeLocalGatewayRouteTablesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribeLocalGatewayRouteTablesResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeLocalGatewayRouteTablesResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeLocalGatewayRouteTablesCommand = deserializeAws_ec2DescribeLocalGatewayRouteTablesCommand;
async function deserializeAws_ec2DescribeLocalGatewayRouteTablesCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeLocalGatewayVirtualInterfaceGroupsCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeLocalGatewayVirtualInterfaceGroupsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribeLocalGatewayVirtualInterfaceGroupsResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeLocalGatewayVirtualInterfaceGroupsResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeLocalGatewayVirtualInterfaceGroupsCommand = deserializeAws_ec2DescribeLocalGatewayVirtualInterfaceGroupsCommand;
async function deserializeAws_ec2DescribeLocalGatewayVirtualInterfaceGroupsCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeLocalGatewayVirtualInterfacesCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeLocalGatewayVirtualInterfacesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribeLocalGatewayVirtualInterfacesResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeLocalGatewayVirtualInterfacesResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeLocalGatewayVirtualInterfacesCommand = deserializeAws_ec2DescribeLocalGatewayVirtualInterfacesCommand;
async function deserializeAws_ec2DescribeLocalGatewayVirtualInterfacesCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeLocalGatewaysCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeLocalGatewaysCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribeLocalGatewaysResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeLocalGatewaysResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeLocalGatewaysCommand = deserializeAws_ec2DescribeLocalGatewaysCommand;
async function deserializeAws_ec2DescribeLocalGatewaysCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeMovingAddressesCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeMovingAddressesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribeMovingAddressesResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeMovingAddressesResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeMovingAddressesCommand = deserializeAws_ec2DescribeMovingAddressesCommand;
async function deserializeAws_ec2DescribeMovingAddressesCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeNatGatewaysCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeNatGatewaysCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribeNatGatewaysResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeNatGatewaysResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeNatGatewaysCommand = deserializeAws_ec2DescribeNatGatewaysCommand;
async function deserializeAws_ec2DescribeNatGatewaysCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeNetworkAclsCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeNetworkAclsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribeNetworkAclsResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeNetworkAclsResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeNetworkAclsCommand = deserializeAws_ec2DescribeNetworkAclsCommand;
async function deserializeAws_ec2DescribeNetworkAclsCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeNetworkInterfaceAttributeCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeNetworkInterfaceAttributeCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribeNetworkInterfaceAttributeResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeNetworkInterfaceAttributeResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeNetworkInterfaceAttributeCommand = deserializeAws_ec2DescribeNetworkInterfaceAttributeCommand;
async function deserializeAws_ec2DescribeNetworkInterfaceAttributeCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeNetworkInterfacePermissionsCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeNetworkInterfacePermissionsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribeNetworkInterfacePermissionsResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeNetworkInterfacePermissionsResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeNetworkInterfacePermissionsCommand = deserializeAws_ec2DescribeNetworkInterfacePermissionsCommand;
async function deserializeAws_ec2DescribeNetworkInterfacePermissionsCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeNetworkInterfacesCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeNetworkInterfacesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribeNetworkInterfacesResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeNetworkInterfacesResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeNetworkInterfacesCommand = deserializeAws_ec2DescribeNetworkInterfacesCommand;
async function deserializeAws_ec2DescribeNetworkInterfacesCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribePlacementGroupsCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribePlacementGroupsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribePlacementGroupsResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribePlacementGroupsResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribePlacementGroupsCommand = deserializeAws_ec2DescribePlacementGroupsCommand;
async function deserializeAws_ec2DescribePlacementGroupsCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribePrefixListsCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribePrefixListsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribePrefixListsResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribePrefixListsResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribePrefixListsCommand = deserializeAws_ec2DescribePrefixListsCommand;
async function deserializeAws_ec2DescribePrefixListsCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribePrincipalIdFormatCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribePrincipalIdFormatCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribePrincipalIdFormatResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribePrincipalIdFormatResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribePrincipalIdFormatCommand = deserializeAws_ec2DescribePrincipalIdFormatCommand;
async function deserializeAws_ec2DescribePrincipalIdFormatCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribePublicIpv4PoolsCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribePublicIpv4PoolsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribePublicIpv4PoolsResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribePublicIpv4PoolsResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribePublicIpv4PoolsCommand = deserializeAws_ec2DescribePublicIpv4PoolsCommand;
async function deserializeAws_ec2DescribePublicIpv4PoolsCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeRegionsCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeRegionsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribeRegionsResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeRegionsResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeRegionsCommand = deserializeAws_ec2DescribeRegionsCommand;
async function deserializeAws_ec2DescribeRegionsCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeReservedInstancesCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeReservedInstancesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribeReservedInstancesResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeReservedInstancesResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeReservedInstancesCommand = deserializeAws_ec2DescribeReservedInstancesCommand;
async function deserializeAws_ec2DescribeReservedInstancesCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeReservedInstancesListingsCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeReservedInstancesListingsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribeReservedInstancesListingsResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeReservedInstancesListingsResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeReservedInstancesListingsCommand = deserializeAws_ec2DescribeReservedInstancesListingsCommand;
async function deserializeAws_ec2DescribeReservedInstancesListingsCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeReservedInstancesModificationsCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeReservedInstancesModificationsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribeReservedInstancesModificationsResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeReservedInstancesModificationsResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeReservedInstancesModificationsCommand = deserializeAws_ec2DescribeReservedInstancesModificationsCommand;
async function deserializeAws_ec2DescribeReservedInstancesModificationsCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeReservedInstancesOfferingsCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeReservedInstancesOfferingsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribeReservedInstancesOfferingsResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeReservedInstancesOfferingsResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeReservedInstancesOfferingsCommand = deserializeAws_ec2DescribeReservedInstancesOfferingsCommand;
async function deserializeAws_ec2DescribeReservedInstancesOfferingsCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeRouteTablesCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeRouteTablesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribeRouteTablesResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeRouteTablesResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeRouteTablesCommand = deserializeAws_ec2DescribeRouteTablesCommand;
async function deserializeAws_ec2DescribeRouteTablesCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeScheduledInstanceAvailabilityCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeScheduledInstanceAvailabilityCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribeScheduledInstanceAvailabilityResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeScheduledInstanceAvailabilityResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeScheduledInstanceAvailabilityCommand = deserializeAws_ec2DescribeScheduledInstanceAvailabilityCommand;
async function deserializeAws_ec2DescribeScheduledInstanceAvailabilityCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeScheduledInstancesCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeScheduledInstancesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribeScheduledInstancesResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeScheduledInstancesResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeScheduledInstancesCommand = deserializeAws_ec2DescribeScheduledInstancesCommand;
async function deserializeAws_ec2DescribeScheduledInstancesCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeSecurityGroupReferencesCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeSecurityGroupReferencesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribeSecurityGroupReferencesResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeSecurityGroupReferencesResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeSecurityGroupReferencesCommand = deserializeAws_ec2DescribeSecurityGroupReferencesCommand;
async function deserializeAws_ec2DescribeSecurityGroupReferencesCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeSecurityGroupsCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeSecurityGroupsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribeSecurityGroupsResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeSecurityGroupsResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeSecurityGroupsCommand = deserializeAws_ec2DescribeSecurityGroupsCommand;
async function deserializeAws_ec2DescribeSecurityGroupsCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeSnapshotAttributeCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeSnapshotAttributeCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribeSnapshotAttributeResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeSnapshotAttributeResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeSnapshotAttributeCommand = deserializeAws_ec2DescribeSnapshotAttributeCommand;
async function deserializeAws_ec2DescribeSnapshotAttributeCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeSnapshotsCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeSnapshotsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribeSnapshotsResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeSnapshotsResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeSnapshotsCommand = deserializeAws_ec2DescribeSnapshotsCommand;
async function deserializeAws_ec2DescribeSnapshotsCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeSpotDatafeedSubscriptionCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeSpotDatafeedSubscriptionCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribeSpotDatafeedSubscriptionResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeSpotDatafeedSubscriptionResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeSpotDatafeedSubscriptionCommand = deserializeAws_ec2DescribeSpotDatafeedSubscriptionCommand;
async function deserializeAws_ec2DescribeSpotDatafeedSubscriptionCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeSpotFleetInstancesCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeSpotFleetInstancesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribeSpotFleetInstancesResponse(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeSpotFleetInstancesResponse" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeSpotFleetInstancesCommand = deserializeAws_ec2DescribeSpotFleetInstancesCommand;
async function deserializeAws_ec2DescribeSpotFleetInstancesCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeSpotFleetRequestHistoryCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeSpotFleetRequestHistoryCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribeSpotFleetRequestHistoryResponse(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeSpotFleetRequestHistoryResponse" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeSpotFleetRequestHistoryCommand = deserializeAws_ec2DescribeSpotFleetRequestHistoryCommand;
async function deserializeAws_ec2DescribeSpotFleetRequestHistoryCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeSpotFleetRequestsCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeSpotFleetRequestsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribeSpotFleetRequestsResponse(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeSpotFleetRequestsResponse" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeSpotFleetRequestsCommand = deserializeAws_ec2DescribeSpotFleetRequestsCommand;
async function deserializeAws_ec2DescribeSpotFleetRequestsCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeSpotInstanceRequestsCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeSpotInstanceRequestsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribeSpotInstanceRequestsResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeSpotInstanceRequestsResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeSpotInstanceRequestsCommand = deserializeAws_ec2DescribeSpotInstanceRequestsCommand;
async function deserializeAws_ec2DescribeSpotInstanceRequestsCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeSpotPriceHistoryCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeSpotPriceHistoryCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribeSpotPriceHistoryResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeSpotPriceHistoryResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeSpotPriceHistoryCommand = deserializeAws_ec2DescribeSpotPriceHistoryCommand;
async function deserializeAws_ec2DescribeSpotPriceHistoryCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeStaleSecurityGroupsCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeStaleSecurityGroupsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribeStaleSecurityGroupsResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeStaleSecurityGroupsResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeStaleSecurityGroupsCommand = deserializeAws_ec2DescribeStaleSecurityGroupsCommand;
async function deserializeAws_ec2DescribeStaleSecurityGroupsCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeSubnetsCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeSubnetsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribeSubnetsResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeSubnetsResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeSubnetsCommand = deserializeAws_ec2DescribeSubnetsCommand;
async function deserializeAws_ec2DescribeSubnetsCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeTagsCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeTagsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribeTagsResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeTagsResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeTagsCommand = deserializeAws_ec2DescribeTagsCommand;
async function deserializeAws_ec2DescribeTagsCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeTrafficMirrorFiltersCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeTrafficMirrorFiltersCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribeTrafficMirrorFiltersResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeTrafficMirrorFiltersResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeTrafficMirrorFiltersCommand = deserializeAws_ec2DescribeTrafficMirrorFiltersCommand;
async function deserializeAws_ec2DescribeTrafficMirrorFiltersCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeTrafficMirrorSessionsCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeTrafficMirrorSessionsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribeTrafficMirrorSessionsResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeTrafficMirrorSessionsResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeTrafficMirrorSessionsCommand = deserializeAws_ec2DescribeTrafficMirrorSessionsCommand;
async function deserializeAws_ec2DescribeTrafficMirrorSessionsCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeTrafficMirrorTargetsCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeTrafficMirrorTargetsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribeTrafficMirrorTargetsResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeTrafficMirrorTargetsResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeTrafficMirrorTargetsCommand = deserializeAws_ec2DescribeTrafficMirrorTargetsCommand;
async function deserializeAws_ec2DescribeTrafficMirrorTargetsCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeTransitGatewayAttachmentsCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeTransitGatewayAttachmentsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribeTransitGatewayAttachmentsResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeTransitGatewayAttachmentsResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeTransitGatewayAttachmentsCommand = deserializeAws_ec2DescribeTransitGatewayAttachmentsCommand;
async function deserializeAws_ec2DescribeTransitGatewayAttachmentsCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeTransitGatewayMulticastDomainsCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeTransitGatewayMulticastDomainsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribeTransitGatewayMulticastDomainsResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeTransitGatewayMulticastDomainsResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeTransitGatewayMulticastDomainsCommand = deserializeAws_ec2DescribeTransitGatewayMulticastDomainsCommand;
async function deserializeAws_ec2DescribeTransitGatewayMulticastDomainsCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeTransitGatewayPeeringAttachmentsCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeTransitGatewayPeeringAttachmentsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribeTransitGatewayPeeringAttachmentsResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeTransitGatewayPeeringAttachmentsResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeTransitGatewayPeeringAttachmentsCommand = deserializeAws_ec2DescribeTransitGatewayPeeringAttachmentsCommand;
async function deserializeAws_ec2DescribeTransitGatewayPeeringAttachmentsCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeTransitGatewayRouteTablesCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeTransitGatewayRouteTablesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribeTransitGatewayRouteTablesResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeTransitGatewayRouteTablesResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeTransitGatewayRouteTablesCommand = deserializeAws_ec2DescribeTransitGatewayRouteTablesCommand;
async function deserializeAws_ec2DescribeTransitGatewayRouteTablesCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeTransitGatewayVpcAttachmentsCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeTransitGatewayVpcAttachmentsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribeTransitGatewayVpcAttachmentsResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeTransitGatewayVpcAttachmentsResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeTransitGatewayVpcAttachmentsCommand = deserializeAws_ec2DescribeTransitGatewayVpcAttachmentsCommand;
async function deserializeAws_ec2DescribeTransitGatewayVpcAttachmentsCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeTransitGatewaysCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeTransitGatewaysCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribeTransitGatewaysResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeTransitGatewaysResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeTransitGatewaysCommand = deserializeAws_ec2DescribeTransitGatewaysCommand;
async function deserializeAws_ec2DescribeTransitGatewaysCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeVolumeAttributeCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeVolumeAttributeCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribeVolumeAttributeResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeVolumeAttributeResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeVolumeAttributeCommand = deserializeAws_ec2DescribeVolumeAttributeCommand;
async function deserializeAws_ec2DescribeVolumeAttributeCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeVolumeStatusCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeVolumeStatusCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribeVolumeStatusResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeVolumeStatusResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeVolumeStatusCommand = deserializeAws_ec2DescribeVolumeStatusCommand;
async function deserializeAws_ec2DescribeVolumeStatusCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeVolumesCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeVolumesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribeVolumesResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeVolumesResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeVolumesCommand = deserializeAws_ec2DescribeVolumesCommand;
async function deserializeAws_ec2DescribeVolumesCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeVolumesModificationsCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeVolumesModificationsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribeVolumesModificationsResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeVolumesModificationsResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeVolumesModificationsCommand = deserializeAws_ec2DescribeVolumesModificationsCommand;
async function deserializeAws_ec2DescribeVolumesModificationsCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeVpcAttributeCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeVpcAttributeCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribeVpcAttributeResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeVpcAttributeResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeVpcAttributeCommand = deserializeAws_ec2DescribeVpcAttributeCommand;
async function deserializeAws_ec2DescribeVpcAttributeCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeVpcClassicLinkCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeVpcClassicLinkCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribeVpcClassicLinkResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeVpcClassicLinkResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeVpcClassicLinkCommand = deserializeAws_ec2DescribeVpcClassicLinkCommand;
async function deserializeAws_ec2DescribeVpcClassicLinkCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeVpcClassicLinkDnsSupportCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeVpcClassicLinkDnsSupportCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribeVpcClassicLinkDnsSupportResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeVpcClassicLinkDnsSupportResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeVpcClassicLinkDnsSupportCommand = deserializeAws_ec2DescribeVpcClassicLinkDnsSupportCommand;
async function deserializeAws_ec2DescribeVpcClassicLinkDnsSupportCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeVpcEndpointConnectionNotificationsCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeVpcEndpointConnectionNotificationsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribeVpcEndpointConnectionNotificationsResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeVpcEndpointConnectionNotificationsResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeVpcEndpointConnectionNotificationsCommand = deserializeAws_ec2DescribeVpcEndpointConnectionNotificationsCommand;
async function deserializeAws_ec2DescribeVpcEndpointConnectionNotificationsCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeVpcEndpointConnectionsCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeVpcEndpointConnectionsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribeVpcEndpointConnectionsResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeVpcEndpointConnectionsResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeVpcEndpointConnectionsCommand = deserializeAws_ec2DescribeVpcEndpointConnectionsCommand;
async function deserializeAws_ec2DescribeVpcEndpointConnectionsCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeVpcEndpointServiceConfigurationsCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeVpcEndpointServiceConfigurationsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribeVpcEndpointServiceConfigurationsResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeVpcEndpointServiceConfigurationsResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeVpcEndpointServiceConfigurationsCommand = deserializeAws_ec2DescribeVpcEndpointServiceConfigurationsCommand;
async function deserializeAws_ec2DescribeVpcEndpointServiceConfigurationsCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeVpcEndpointServicePermissionsCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeVpcEndpointServicePermissionsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribeVpcEndpointServicePermissionsResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeVpcEndpointServicePermissionsResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeVpcEndpointServicePermissionsCommand = deserializeAws_ec2DescribeVpcEndpointServicePermissionsCommand;
async function deserializeAws_ec2DescribeVpcEndpointServicePermissionsCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeVpcEndpointServicesCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeVpcEndpointServicesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribeVpcEndpointServicesResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeVpcEndpointServicesResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeVpcEndpointServicesCommand = deserializeAws_ec2DescribeVpcEndpointServicesCommand;
async function deserializeAws_ec2DescribeVpcEndpointServicesCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeVpcEndpointsCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeVpcEndpointsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribeVpcEndpointsResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeVpcEndpointsResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeVpcEndpointsCommand = deserializeAws_ec2DescribeVpcEndpointsCommand;
async function deserializeAws_ec2DescribeVpcEndpointsCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeVpcPeeringConnectionsCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeVpcPeeringConnectionsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribeVpcPeeringConnectionsResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeVpcPeeringConnectionsResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeVpcPeeringConnectionsCommand = deserializeAws_ec2DescribeVpcPeeringConnectionsCommand;
async function deserializeAws_ec2DescribeVpcPeeringConnectionsCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeVpcsCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeVpcsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribeVpcsResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeVpcsResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeVpcsCommand = deserializeAws_ec2DescribeVpcsCommand;
async function deserializeAws_ec2DescribeVpcsCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeVpnConnectionsCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeVpnConnectionsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribeVpnConnectionsResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeVpnConnectionsResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeVpnConnectionsCommand = deserializeAws_ec2DescribeVpnConnectionsCommand;
async function deserializeAws_ec2DescribeVpnConnectionsCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DescribeVpnGatewaysCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DescribeVpnGatewaysCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DescribeVpnGatewaysResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DescribeVpnGatewaysResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DescribeVpnGatewaysCommand = deserializeAws_ec2DescribeVpnGatewaysCommand;
async function deserializeAws_ec2DescribeVpnGatewaysCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DetachClassicLinkVpcCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DetachClassicLinkVpcCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DetachClassicLinkVpcResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DetachClassicLinkVpcResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DetachClassicLinkVpcCommand = deserializeAws_ec2DetachClassicLinkVpcCommand;
async function deserializeAws_ec2DetachClassicLinkVpcCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DetachInternetGatewayCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DetachInternetGatewayCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output)
    };
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DetachInternetGatewayCommand = deserializeAws_ec2DetachInternetGatewayCommand;
async function deserializeAws_ec2DetachInternetGatewayCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DetachNetworkInterfaceCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DetachNetworkInterfaceCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output)
    };
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DetachNetworkInterfaceCommand = deserializeAws_ec2DetachNetworkInterfaceCommand;
async function deserializeAws_ec2DetachNetworkInterfaceCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DetachVolumeCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DetachVolumeCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2VolumeAttachment(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "VolumeAttachment" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DetachVolumeCommand = deserializeAws_ec2DetachVolumeCommand;
async function deserializeAws_ec2DetachVolumeCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DetachVpnGatewayCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DetachVpnGatewayCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output)
    };
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DetachVpnGatewayCommand = deserializeAws_ec2DetachVpnGatewayCommand;
async function deserializeAws_ec2DetachVpnGatewayCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DisableEbsEncryptionByDefaultCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DisableEbsEncryptionByDefaultCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DisableEbsEncryptionByDefaultResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DisableEbsEncryptionByDefaultResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DisableEbsEncryptionByDefaultCommand = deserializeAws_ec2DisableEbsEncryptionByDefaultCommand;
async function deserializeAws_ec2DisableEbsEncryptionByDefaultCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DisableFastSnapshotRestoresCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DisableFastSnapshotRestoresCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DisableFastSnapshotRestoresResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DisableFastSnapshotRestoresResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DisableFastSnapshotRestoresCommand = deserializeAws_ec2DisableFastSnapshotRestoresCommand;
async function deserializeAws_ec2DisableFastSnapshotRestoresCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DisableTransitGatewayRouteTablePropagationCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DisableTransitGatewayRouteTablePropagationCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DisableTransitGatewayRouteTablePropagationResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DisableTransitGatewayRouteTablePropagationResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DisableTransitGatewayRouteTablePropagationCommand = deserializeAws_ec2DisableTransitGatewayRouteTablePropagationCommand;
async function deserializeAws_ec2DisableTransitGatewayRouteTablePropagationCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DisableVgwRoutePropagationCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DisableVgwRoutePropagationCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output)
    };
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DisableVgwRoutePropagationCommand = deserializeAws_ec2DisableVgwRoutePropagationCommand;
async function deserializeAws_ec2DisableVgwRoutePropagationCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DisableVpcClassicLinkCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DisableVpcClassicLinkCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DisableVpcClassicLinkResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DisableVpcClassicLinkResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DisableVpcClassicLinkCommand = deserializeAws_ec2DisableVpcClassicLinkCommand;
async function deserializeAws_ec2DisableVpcClassicLinkCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DisableVpcClassicLinkDnsSupportCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DisableVpcClassicLinkDnsSupportCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DisableVpcClassicLinkDnsSupportResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DisableVpcClassicLinkDnsSupportResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DisableVpcClassicLinkDnsSupportCommand = deserializeAws_ec2DisableVpcClassicLinkDnsSupportCommand;
async function deserializeAws_ec2DisableVpcClassicLinkDnsSupportCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DisassociateAddressCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DisassociateAddressCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output)
    };
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DisassociateAddressCommand = deserializeAws_ec2DisassociateAddressCommand;
async function deserializeAws_ec2DisassociateAddressCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DisassociateClientVpnTargetNetworkCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DisassociateClientVpnTargetNetworkCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DisassociateClientVpnTargetNetworkResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DisassociateClientVpnTargetNetworkResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DisassociateClientVpnTargetNetworkCommand = deserializeAws_ec2DisassociateClientVpnTargetNetworkCommand;
async function deserializeAws_ec2DisassociateClientVpnTargetNetworkCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DisassociateIamInstanceProfileCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DisassociateIamInstanceProfileCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DisassociateIamInstanceProfileResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DisassociateIamInstanceProfileResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DisassociateIamInstanceProfileCommand = deserializeAws_ec2DisassociateIamInstanceProfileCommand;
async function deserializeAws_ec2DisassociateIamInstanceProfileCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DisassociateRouteTableCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DisassociateRouteTableCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output)
    };
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DisassociateRouteTableCommand = deserializeAws_ec2DisassociateRouteTableCommand;
async function deserializeAws_ec2DisassociateRouteTableCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DisassociateSubnetCidrBlockCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DisassociateSubnetCidrBlockCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DisassociateSubnetCidrBlockResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DisassociateSubnetCidrBlockResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DisassociateSubnetCidrBlockCommand = deserializeAws_ec2DisassociateSubnetCidrBlockCommand;
async function deserializeAws_ec2DisassociateSubnetCidrBlockCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DisassociateTransitGatewayMulticastDomainCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DisassociateTransitGatewayMulticastDomainCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DisassociateTransitGatewayMulticastDomainResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DisassociateTransitGatewayMulticastDomainResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DisassociateTransitGatewayMulticastDomainCommand = deserializeAws_ec2DisassociateTransitGatewayMulticastDomainCommand;
async function deserializeAws_ec2DisassociateTransitGatewayMulticastDomainCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DisassociateTransitGatewayRouteTableCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DisassociateTransitGatewayRouteTableCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DisassociateTransitGatewayRouteTableResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DisassociateTransitGatewayRouteTableResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DisassociateTransitGatewayRouteTableCommand = deserializeAws_ec2DisassociateTransitGatewayRouteTableCommand;
async function deserializeAws_ec2DisassociateTransitGatewayRouteTableCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2DisassociateVpcCidrBlockCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2DisassociateVpcCidrBlockCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2DisassociateVpcCidrBlockResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "DisassociateVpcCidrBlockResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2DisassociateVpcCidrBlockCommand = deserializeAws_ec2DisassociateVpcCidrBlockCommand;
async function deserializeAws_ec2DisassociateVpcCidrBlockCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2EnableEbsEncryptionByDefaultCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2EnableEbsEncryptionByDefaultCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2EnableEbsEncryptionByDefaultResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "EnableEbsEncryptionByDefaultResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2EnableEbsEncryptionByDefaultCommand = deserializeAws_ec2EnableEbsEncryptionByDefaultCommand;
async function deserializeAws_ec2EnableEbsEncryptionByDefaultCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2EnableFastSnapshotRestoresCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2EnableFastSnapshotRestoresCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2EnableFastSnapshotRestoresResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "EnableFastSnapshotRestoresResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2EnableFastSnapshotRestoresCommand = deserializeAws_ec2EnableFastSnapshotRestoresCommand;
async function deserializeAws_ec2EnableFastSnapshotRestoresCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2EnableTransitGatewayRouteTablePropagationCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2EnableTransitGatewayRouteTablePropagationCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2EnableTransitGatewayRouteTablePropagationResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "EnableTransitGatewayRouteTablePropagationResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2EnableTransitGatewayRouteTablePropagationCommand = deserializeAws_ec2EnableTransitGatewayRouteTablePropagationCommand;
async function deserializeAws_ec2EnableTransitGatewayRouteTablePropagationCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2EnableVgwRoutePropagationCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2EnableVgwRoutePropagationCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output)
    };
    return Promise.resolve(response);
}
exports.deserializeAws_ec2EnableVgwRoutePropagationCommand = deserializeAws_ec2EnableVgwRoutePropagationCommand;
async function deserializeAws_ec2EnableVgwRoutePropagationCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2EnableVolumeIOCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2EnableVolumeIOCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output)
    };
    return Promise.resolve(response);
}
exports.deserializeAws_ec2EnableVolumeIOCommand = deserializeAws_ec2EnableVolumeIOCommand;
async function deserializeAws_ec2EnableVolumeIOCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2EnableVpcClassicLinkCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2EnableVpcClassicLinkCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2EnableVpcClassicLinkResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "EnableVpcClassicLinkResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2EnableVpcClassicLinkCommand = deserializeAws_ec2EnableVpcClassicLinkCommand;
async function deserializeAws_ec2EnableVpcClassicLinkCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2EnableVpcClassicLinkDnsSupportCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2EnableVpcClassicLinkDnsSupportCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2EnableVpcClassicLinkDnsSupportResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "EnableVpcClassicLinkDnsSupportResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2EnableVpcClassicLinkDnsSupportCommand = deserializeAws_ec2EnableVpcClassicLinkDnsSupportCommand;
async function deserializeAws_ec2EnableVpcClassicLinkDnsSupportCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2ExportClientVpnClientCertificateRevocationListCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2ExportClientVpnClientCertificateRevocationListCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2ExportClientVpnClientCertificateRevocationListResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "ExportClientVpnClientCertificateRevocationListResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2ExportClientVpnClientCertificateRevocationListCommand = deserializeAws_ec2ExportClientVpnClientCertificateRevocationListCommand;
async function deserializeAws_ec2ExportClientVpnClientCertificateRevocationListCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2ExportClientVpnClientConfigurationCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2ExportClientVpnClientConfigurationCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2ExportClientVpnClientConfigurationResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "ExportClientVpnClientConfigurationResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2ExportClientVpnClientConfigurationCommand = deserializeAws_ec2ExportClientVpnClientConfigurationCommand;
async function deserializeAws_ec2ExportClientVpnClientConfigurationCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2ExportImageCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2ExportImageCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2ExportImageResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "ExportImageResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2ExportImageCommand = deserializeAws_ec2ExportImageCommand;
async function deserializeAws_ec2ExportImageCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2ExportTransitGatewayRoutesCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2ExportTransitGatewayRoutesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2ExportTransitGatewayRoutesResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "ExportTransitGatewayRoutesResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2ExportTransitGatewayRoutesCommand = deserializeAws_ec2ExportTransitGatewayRoutesCommand;
async function deserializeAws_ec2ExportTransitGatewayRoutesCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2GetAssociatedIpv6PoolCidrsCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2GetAssociatedIpv6PoolCidrsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2GetAssociatedIpv6PoolCidrsResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "GetAssociatedIpv6PoolCidrsResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2GetAssociatedIpv6PoolCidrsCommand = deserializeAws_ec2GetAssociatedIpv6PoolCidrsCommand;
async function deserializeAws_ec2GetAssociatedIpv6PoolCidrsCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2GetCapacityReservationUsageCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2GetCapacityReservationUsageCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2GetCapacityReservationUsageResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "GetCapacityReservationUsageResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2GetCapacityReservationUsageCommand = deserializeAws_ec2GetCapacityReservationUsageCommand;
async function deserializeAws_ec2GetCapacityReservationUsageCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2GetCoipPoolUsageCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2GetCoipPoolUsageCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2GetCoipPoolUsageResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "GetCoipPoolUsageResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2GetCoipPoolUsageCommand = deserializeAws_ec2GetCoipPoolUsageCommand;
async function deserializeAws_ec2GetCoipPoolUsageCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2GetConsoleOutputCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2GetConsoleOutputCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2GetConsoleOutputResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "GetConsoleOutputResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2GetConsoleOutputCommand = deserializeAws_ec2GetConsoleOutputCommand;
async function deserializeAws_ec2GetConsoleOutputCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2GetConsoleScreenshotCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2GetConsoleScreenshotCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2GetConsoleScreenshotResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "GetConsoleScreenshotResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2GetConsoleScreenshotCommand = deserializeAws_ec2GetConsoleScreenshotCommand;
async function deserializeAws_ec2GetConsoleScreenshotCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2GetDefaultCreditSpecificationCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2GetDefaultCreditSpecificationCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2GetDefaultCreditSpecificationResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "GetDefaultCreditSpecificationResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2GetDefaultCreditSpecificationCommand = deserializeAws_ec2GetDefaultCreditSpecificationCommand;
async function deserializeAws_ec2GetDefaultCreditSpecificationCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2GetEbsDefaultKmsKeyIdCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2GetEbsDefaultKmsKeyIdCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2GetEbsDefaultKmsKeyIdResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "GetEbsDefaultKmsKeyIdResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2GetEbsDefaultKmsKeyIdCommand = deserializeAws_ec2GetEbsDefaultKmsKeyIdCommand;
async function deserializeAws_ec2GetEbsDefaultKmsKeyIdCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2GetEbsEncryptionByDefaultCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2GetEbsEncryptionByDefaultCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2GetEbsEncryptionByDefaultResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "GetEbsEncryptionByDefaultResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2GetEbsEncryptionByDefaultCommand = deserializeAws_ec2GetEbsEncryptionByDefaultCommand;
async function deserializeAws_ec2GetEbsEncryptionByDefaultCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2GetHostReservationPurchasePreviewCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2GetHostReservationPurchasePreviewCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2GetHostReservationPurchasePreviewResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "GetHostReservationPurchasePreviewResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2GetHostReservationPurchasePreviewCommand = deserializeAws_ec2GetHostReservationPurchasePreviewCommand;
async function deserializeAws_ec2GetHostReservationPurchasePreviewCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2GetLaunchTemplateDataCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2GetLaunchTemplateDataCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2GetLaunchTemplateDataResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "GetLaunchTemplateDataResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2GetLaunchTemplateDataCommand = deserializeAws_ec2GetLaunchTemplateDataCommand;
async function deserializeAws_ec2GetLaunchTemplateDataCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2GetPasswordDataCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2GetPasswordDataCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2GetPasswordDataResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "GetPasswordDataResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2GetPasswordDataCommand = deserializeAws_ec2GetPasswordDataCommand;
async function deserializeAws_ec2GetPasswordDataCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2GetReservedInstancesExchangeQuoteCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2GetReservedInstancesExchangeQuoteCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2GetReservedInstancesExchangeQuoteResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "GetReservedInstancesExchangeQuoteResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2GetReservedInstancesExchangeQuoteCommand = deserializeAws_ec2GetReservedInstancesExchangeQuoteCommand;
async function deserializeAws_ec2GetReservedInstancesExchangeQuoteCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2GetTransitGatewayAttachmentPropagationsCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2GetTransitGatewayAttachmentPropagationsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2GetTransitGatewayAttachmentPropagationsResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "GetTransitGatewayAttachmentPropagationsResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2GetTransitGatewayAttachmentPropagationsCommand = deserializeAws_ec2GetTransitGatewayAttachmentPropagationsCommand;
async function deserializeAws_ec2GetTransitGatewayAttachmentPropagationsCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2GetTransitGatewayMulticastDomainAssociationsCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2GetTransitGatewayMulticastDomainAssociationsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2GetTransitGatewayMulticastDomainAssociationsResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "GetTransitGatewayMulticastDomainAssociationsResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2GetTransitGatewayMulticastDomainAssociationsCommand = deserializeAws_ec2GetTransitGatewayMulticastDomainAssociationsCommand;
async function deserializeAws_ec2GetTransitGatewayMulticastDomainAssociationsCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2GetTransitGatewayRouteTableAssociationsCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2GetTransitGatewayRouteTableAssociationsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2GetTransitGatewayRouteTableAssociationsResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "GetTransitGatewayRouteTableAssociationsResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2GetTransitGatewayRouteTableAssociationsCommand = deserializeAws_ec2GetTransitGatewayRouteTableAssociationsCommand;
async function deserializeAws_ec2GetTransitGatewayRouteTableAssociationsCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2GetTransitGatewayRouteTablePropagationsCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2GetTransitGatewayRouteTablePropagationsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2GetTransitGatewayRouteTablePropagationsResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "GetTransitGatewayRouteTablePropagationsResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2GetTransitGatewayRouteTablePropagationsCommand = deserializeAws_ec2GetTransitGatewayRouteTablePropagationsCommand;
async function deserializeAws_ec2GetTransitGatewayRouteTablePropagationsCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2ImportClientVpnClientCertificateRevocationListCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2ImportClientVpnClientCertificateRevocationListCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2ImportClientVpnClientCertificateRevocationListResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "ImportClientVpnClientCertificateRevocationListResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2ImportClientVpnClientCertificateRevocationListCommand = deserializeAws_ec2ImportClientVpnClientCertificateRevocationListCommand;
async function deserializeAws_ec2ImportClientVpnClientCertificateRevocationListCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2ImportImageCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2ImportImageCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2ImportImageResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "ImportImageResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2ImportImageCommand = deserializeAws_ec2ImportImageCommand;
async function deserializeAws_ec2ImportImageCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2ImportInstanceCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2ImportInstanceCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2ImportInstanceResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "ImportInstanceResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2ImportInstanceCommand = deserializeAws_ec2ImportInstanceCommand;
async function deserializeAws_ec2ImportInstanceCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2ImportKeyPairCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2ImportKeyPairCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2ImportKeyPairResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "ImportKeyPairResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2ImportKeyPairCommand = deserializeAws_ec2ImportKeyPairCommand;
async function deserializeAws_ec2ImportKeyPairCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2ImportSnapshotCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2ImportSnapshotCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2ImportSnapshotResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "ImportSnapshotResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2ImportSnapshotCommand = deserializeAws_ec2ImportSnapshotCommand;
async function deserializeAws_ec2ImportSnapshotCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2ImportVolumeCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2ImportVolumeCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2ImportVolumeResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "ImportVolumeResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2ImportVolumeCommand = deserializeAws_ec2ImportVolumeCommand;
async function deserializeAws_ec2ImportVolumeCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2ModifyCapacityReservationCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2ModifyCapacityReservationCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2ModifyCapacityReservationResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "ModifyCapacityReservationResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2ModifyCapacityReservationCommand = deserializeAws_ec2ModifyCapacityReservationCommand;
async function deserializeAws_ec2ModifyCapacityReservationCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2ModifyClientVpnEndpointCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2ModifyClientVpnEndpointCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2ModifyClientVpnEndpointResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "ModifyClientVpnEndpointResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2ModifyClientVpnEndpointCommand = deserializeAws_ec2ModifyClientVpnEndpointCommand;
async function deserializeAws_ec2ModifyClientVpnEndpointCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2ModifyDefaultCreditSpecificationCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2ModifyDefaultCreditSpecificationCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2ModifyDefaultCreditSpecificationResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "ModifyDefaultCreditSpecificationResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2ModifyDefaultCreditSpecificationCommand = deserializeAws_ec2ModifyDefaultCreditSpecificationCommand;
async function deserializeAws_ec2ModifyDefaultCreditSpecificationCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2ModifyEbsDefaultKmsKeyIdCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2ModifyEbsDefaultKmsKeyIdCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2ModifyEbsDefaultKmsKeyIdResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "ModifyEbsDefaultKmsKeyIdResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2ModifyEbsDefaultKmsKeyIdCommand = deserializeAws_ec2ModifyEbsDefaultKmsKeyIdCommand;
async function deserializeAws_ec2ModifyEbsDefaultKmsKeyIdCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2ModifyFleetCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2ModifyFleetCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2ModifyFleetResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "ModifyFleetResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2ModifyFleetCommand = deserializeAws_ec2ModifyFleetCommand;
async function deserializeAws_ec2ModifyFleetCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2ModifyFpgaImageAttributeCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2ModifyFpgaImageAttributeCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2ModifyFpgaImageAttributeResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "ModifyFpgaImageAttributeResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2ModifyFpgaImageAttributeCommand = deserializeAws_ec2ModifyFpgaImageAttributeCommand;
async function deserializeAws_ec2ModifyFpgaImageAttributeCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2ModifyHostsCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2ModifyHostsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2ModifyHostsResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "ModifyHostsResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2ModifyHostsCommand = deserializeAws_ec2ModifyHostsCommand;
async function deserializeAws_ec2ModifyHostsCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2ModifyIdFormatCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2ModifyIdFormatCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output)
    };
    return Promise.resolve(response);
}
exports.deserializeAws_ec2ModifyIdFormatCommand = deserializeAws_ec2ModifyIdFormatCommand;
async function deserializeAws_ec2ModifyIdFormatCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2ModifyIdentityIdFormatCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2ModifyIdentityIdFormatCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output)
    };
    return Promise.resolve(response);
}
exports.deserializeAws_ec2ModifyIdentityIdFormatCommand = deserializeAws_ec2ModifyIdentityIdFormatCommand;
async function deserializeAws_ec2ModifyIdentityIdFormatCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2ModifyImageAttributeCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2ModifyImageAttributeCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output)
    };
    return Promise.resolve(response);
}
exports.deserializeAws_ec2ModifyImageAttributeCommand = deserializeAws_ec2ModifyImageAttributeCommand;
async function deserializeAws_ec2ModifyImageAttributeCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2ModifyInstanceAttributeCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2ModifyInstanceAttributeCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output)
    };
    return Promise.resolve(response);
}
exports.deserializeAws_ec2ModifyInstanceAttributeCommand = deserializeAws_ec2ModifyInstanceAttributeCommand;
async function deserializeAws_ec2ModifyInstanceAttributeCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2ModifyInstanceCapacityReservationAttributesCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2ModifyInstanceCapacityReservationAttributesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2ModifyInstanceCapacityReservationAttributesResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "ModifyInstanceCapacityReservationAttributesResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2ModifyInstanceCapacityReservationAttributesCommand = deserializeAws_ec2ModifyInstanceCapacityReservationAttributesCommand;
async function deserializeAws_ec2ModifyInstanceCapacityReservationAttributesCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2ModifyInstanceCreditSpecificationCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2ModifyInstanceCreditSpecificationCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2ModifyInstanceCreditSpecificationResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "ModifyInstanceCreditSpecificationResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2ModifyInstanceCreditSpecificationCommand = deserializeAws_ec2ModifyInstanceCreditSpecificationCommand;
async function deserializeAws_ec2ModifyInstanceCreditSpecificationCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2ModifyInstanceEventStartTimeCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2ModifyInstanceEventStartTimeCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2ModifyInstanceEventStartTimeResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "ModifyInstanceEventStartTimeResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2ModifyInstanceEventStartTimeCommand = deserializeAws_ec2ModifyInstanceEventStartTimeCommand;
async function deserializeAws_ec2ModifyInstanceEventStartTimeCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2ModifyInstanceMetadataOptionsCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2ModifyInstanceMetadataOptionsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2ModifyInstanceMetadataOptionsResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "ModifyInstanceMetadataOptionsResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2ModifyInstanceMetadataOptionsCommand = deserializeAws_ec2ModifyInstanceMetadataOptionsCommand;
async function deserializeAws_ec2ModifyInstanceMetadataOptionsCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2ModifyInstancePlacementCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2ModifyInstancePlacementCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2ModifyInstancePlacementResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "ModifyInstancePlacementResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2ModifyInstancePlacementCommand = deserializeAws_ec2ModifyInstancePlacementCommand;
async function deserializeAws_ec2ModifyInstancePlacementCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2ModifyLaunchTemplateCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2ModifyLaunchTemplateCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2ModifyLaunchTemplateResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "ModifyLaunchTemplateResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2ModifyLaunchTemplateCommand = deserializeAws_ec2ModifyLaunchTemplateCommand;
async function deserializeAws_ec2ModifyLaunchTemplateCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2ModifyNetworkInterfaceAttributeCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2ModifyNetworkInterfaceAttributeCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output)
    };
    return Promise.resolve(response);
}
exports.deserializeAws_ec2ModifyNetworkInterfaceAttributeCommand = deserializeAws_ec2ModifyNetworkInterfaceAttributeCommand;
async function deserializeAws_ec2ModifyNetworkInterfaceAttributeCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2ModifyReservedInstancesCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2ModifyReservedInstancesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2ModifyReservedInstancesResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "ModifyReservedInstancesResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2ModifyReservedInstancesCommand = deserializeAws_ec2ModifyReservedInstancesCommand;
async function deserializeAws_ec2ModifyReservedInstancesCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2ModifySnapshotAttributeCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2ModifySnapshotAttributeCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output)
    };
    return Promise.resolve(response);
}
exports.deserializeAws_ec2ModifySnapshotAttributeCommand = deserializeAws_ec2ModifySnapshotAttributeCommand;
async function deserializeAws_ec2ModifySnapshotAttributeCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2ModifySpotFleetRequestCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2ModifySpotFleetRequestCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2ModifySpotFleetRequestResponse(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "ModifySpotFleetRequestResponse" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2ModifySpotFleetRequestCommand = deserializeAws_ec2ModifySpotFleetRequestCommand;
async function deserializeAws_ec2ModifySpotFleetRequestCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2ModifySubnetAttributeCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2ModifySubnetAttributeCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output)
    };
    return Promise.resolve(response);
}
exports.deserializeAws_ec2ModifySubnetAttributeCommand = deserializeAws_ec2ModifySubnetAttributeCommand;
async function deserializeAws_ec2ModifySubnetAttributeCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2ModifyTrafficMirrorFilterNetworkServicesCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2ModifyTrafficMirrorFilterNetworkServicesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2ModifyTrafficMirrorFilterNetworkServicesResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "ModifyTrafficMirrorFilterNetworkServicesResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2ModifyTrafficMirrorFilterNetworkServicesCommand = deserializeAws_ec2ModifyTrafficMirrorFilterNetworkServicesCommand;
async function deserializeAws_ec2ModifyTrafficMirrorFilterNetworkServicesCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2ModifyTrafficMirrorFilterRuleCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2ModifyTrafficMirrorFilterRuleCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2ModifyTrafficMirrorFilterRuleResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "ModifyTrafficMirrorFilterRuleResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2ModifyTrafficMirrorFilterRuleCommand = deserializeAws_ec2ModifyTrafficMirrorFilterRuleCommand;
async function deserializeAws_ec2ModifyTrafficMirrorFilterRuleCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2ModifyTrafficMirrorSessionCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2ModifyTrafficMirrorSessionCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2ModifyTrafficMirrorSessionResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "ModifyTrafficMirrorSessionResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2ModifyTrafficMirrorSessionCommand = deserializeAws_ec2ModifyTrafficMirrorSessionCommand;
async function deserializeAws_ec2ModifyTrafficMirrorSessionCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2ModifyTransitGatewayVpcAttachmentCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2ModifyTransitGatewayVpcAttachmentCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2ModifyTransitGatewayVpcAttachmentResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "ModifyTransitGatewayVpcAttachmentResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2ModifyTransitGatewayVpcAttachmentCommand = deserializeAws_ec2ModifyTransitGatewayVpcAttachmentCommand;
async function deserializeAws_ec2ModifyTransitGatewayVpcAttachmentCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2ModifyVolumeCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2ModifyVolumeCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2ModifyVolumeResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "ModifyVolumeResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2ModifyVolumeCommand = deserializeAws_ec2ModifyVolumeCommand;
async function deserializeAws_ec2ModifyVolumeCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2ModifyVolumeAttributeCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2ModifyVolumeAttributeCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output)
    };
    return Promise.resolve(response);
}
exports.deserializeAws_ec2ModifyVolumeAttributeCommand = deserializeAws_ec2ModifyVolumeAttributeCommand;
async function deserializeAws_ec2ModifyVolumeAttributeCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2ModifyVpcAttributeCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2ModifyVpcAttributeCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output)
    };
    return Promise.resolve(response);
}
exports.deserializeAws_ec2ModifyVpcAttributeCommand = deserializeAws_ec2ModifyVpcAttributeCommand;
async function deserializeAws_ec2ModifyVpcAttributeCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2ModifyVpcEndpointCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2ModifyVpcEndpointCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2ModifyVpcEndpointResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "ModifyVpcEndpointResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2ModifyVpcEndpointCommand = deserializeAws_ec2ModifyVpcEndpointCommand;
async function deserializeAws_ec2ModifyVpcEndpointCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2ModifyVpcEndpointConnectionNotificationCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2ModifyVpcEndpointConnectionNotificationCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2ModifyVpcEndpointConnectionNotificationResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "ModifyVpcEndpointConnectionNotificationResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2ModifyVpcEndpointConnectionNotificationCommand = deserializeAws_ec2ModifyVpcEndpointConnectionNotificationCommand;
async function deserializeAws_ec2ModifyVpcEndpointConnectionNotificationCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2ModifyVpcEndpointServiceConfigurationCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2ModifyVpcEndpointServiceConfigurationCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2ModifyVpcEndpointServiceConfigurationResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "ModifyVpcEndpointServiceConfigurationResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2ModifyVpcEndpointServiceConfigurationCommand = deserializeAws_ec2ModifyVpcEndpointServiceConfigurationCommand;
async function deserializeAws_ec2ModifyVpcEndpointServiceConfigurationCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2ModifyVpcEndpointServicePermissionsCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2ModifyVpcEndpointServicePermissionsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2ModifyVpcEndpointServicePermissionsResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "ModifyVpcEndpointServicePermissionsResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2ModifyVpcEndpointServicePermissionsCommand = deserializeAws_ec2ModifyVpcEndpointServicePermissionsCommand;
async function deserializeAws_ec2ModifyVpcEndpointServicePermissionsCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2ModifyVpcPeeringConnectionOptionsCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2ModifyVpcPeeringConnectionOptionsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2ModifyVpcPeeringConnectionOptionsResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "ModifyVpcPeeringConnectionOptionsResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2ModifyVpcPeeringConnectionOptionsCommand = deserializeAws_ec2ModifyVpcPeeringConnectionOptionsCommand;
async function deserializeAws_ec2ModifyVpcPeeringConnectionOptionsCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2ModifyVpcTenancyCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2ModifyVpcTenancyCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2ModifyVpcTenancyResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "ModifyVpcTenancyResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2ModifyVpcTenancyCommand = deserializeAws_ec2ModifyVpcTenancyCommand;
async function deserializeAws_ec2ModifyVpcTenancyCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2ModifyVpnConnectionCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2ModifyVpnConnectionCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2ModifyVpnConnectionResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "ModifyVpnConnectionResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2ModifyVpnConnectionCommand = deserializeAws_ec2ModifyVpnConnectionCommand;
async function deserializeAws_ec2ModifyVpnConnectionCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2ModifyVpnTunnelCertificateCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2ModifyVpnTunnelCertificateCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2ModifyVpnTunnelCertificateResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "ModifyVpnTunnelCertificateResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2ModifyVpnTunnelCertificateCommand = deserializeAws_ec2ModifyVpnTunnelCertificateCommand;
async function deserializeAws_ec2ModifyVpnTunnelCertificateCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2ModifyVpnTunnelOptionsCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2ModifyVpnTunnelOptionsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2ModifyVpnTunnelOptionsResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "ModifyVpnTunnelOptionsResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2ModifyVpnTunnelOptionsCommand = deserializeAws_ec2ModifyVpnTunnelOptionsCommand;
async function deserializeAws_ec2ModifyVpnTunnelOptionsCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2MonitorInstancesCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2MonitorInstancesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2MonitorInstancesResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "MonitorInstancesResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2MonitorInstancesCommand = deserializeAws_ec2MonitorInstancesCommand;
async function deserializeAws_ec2MonitorInstancesCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2MoveAddressToVpcCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2MoveAddressToVpcCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2MoveAddressToVpcResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "MoveAddressToVpcResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2MoveAddressToVpcCommand = deserializeAws_ec2MoveAddressToVpcCommand;
async function deserializeAws_ec2MoveAddressToVpcCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2ProvisionByoipCidrCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2ProvisionByoipCidrCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2ProvisionByoipCidrResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "ProvisionByoipCidrResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2ProvisionByoipCidrCommand = deserializeAws_ec2ProvisionByoipCidrCommand;
async function deserializeAws_ec2ProvisionByoipCidrCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2PurchaseHostReservationCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2PurchaseHostReservationCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2PurchaseHostReservationResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "PurchaseHostReservationResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2PurchaseHostReservationCommand = deserializeAws_ec2PurchaseHostReservationCommand;
async function deserializeAws_ec2PurchaseHostReservationCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2PurchaseReservedInstancesOfferingCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2PurchaseReservedInstancesOfferingCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2PurchaseReservedInstancesOfferingResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "PurchaseReservedInstancesOfferingResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2PurchaseReservedInstancesOfferingCommand = deserializeAws_ec2PurchaseReservedInstancesOfferingCommand;
async function deserializeAws_ec2PurchaseReservedInstancesOfferingCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2PurchaseScheduledInstancesCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2PurchaseScheduledInstancesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2PurchaseScheduledInstancesResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "PurchaseScheduledInstancesResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2PurchaseScheduledInstancesCommand = deserializeAws_ec2PurchaseScheduledInstancesCommand;
async function deserializeAws_ec2PurchaseScheduledInstancesCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2RebootInstancesCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2RebootInstancesCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output)
    };
    return Promise.resolve(response);
}
exports.deserializeAws_ec2RebootInstancesCommand = deserializeAws_ec2RebootInstancesCommand;
async function deserializeAws_ec2RebootInstancesCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2RegisterImageCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2RegisterImageCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2RegisterImageResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "RegisterImageResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2RegisterImageCommand = deserializeAws_ec2RegisterImageCommand;
async function deserializeAws_ec2RegisterImageCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2RegisterTransitGatewayMulticastGroupMembersCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2RegisterTransitGatewayMulticastGroupMembersCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2RegisterTransitGatewayMulticastGroupMembersResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "RegisterTransitGatewayMulticastGroupMembersResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2RegisterTransitGatewayMulticastGroupMembersCommand = deserializeAws_ec2RegisterTransitGatewayMulticastGroupMembersCommand;
async function deserializeAws_ec2RegisterTransitGatewayMulticastGroupMembersCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2RegisterTransitGatewayMulticastGroupSourcesCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2RegisterTransitGatewayMulticastGroupSourcesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2RegisterTransitGatewayMulticastGroupSourcesResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "RegisterTransitGatewayMulticastGroupSourcesResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2RegisterTransitGatewayMulticastGroupSourcesCommand = deserializeAws_ec2RegisterTransitGatewayMulticastGroupSourcesCommand;
async function deserializeAws_ec2RegisterTransitGatewayMulticastGroupSourcesCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2RejectTransitGatewayPeeringAttachmentCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2RejectTransitGatewayPeeringAttachmentCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2RejectTransitGatewayPeeringAttachmentResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "RejectTransitGatewayPeeringAttachmentResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2RejectTransitGatewayPeeringAttachmentCommand = deserializeAws_ec2RejectTransitGatewayPeeringAttachmentCommand;
async function deserializeAws_ec2RejectTransitGatewayPeeringAttachmentCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2RejectTransitGatewayVpcAttachmentCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2RejectTransitGatewayVpcAttachmentCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2RejectTransitGatewayVpcAttachmentResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "RejectTransitGatewayVpcAttachmentResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2RejectTransitGatewayVpcAttachmentCommand = deserializeAws_ec2RejectTransitGatewayVpcAttachmentCommand;
async function deserializeAws_ec2RejectTransitGatewayVpcAttachmentCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2RejectVpcEndpointConnectionsCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2RejectVpcEndpointConnectionsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2RejectVpcEndpointConnectionsResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "RejectVpcEndpointConnectionsResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2RejectVpcEndpointConnectionsCommand = deserializeAws_ec2RejectVpcEndpointConnectionsCommand;
async function deserializeAws_ec2RejectVpcEndpointConnectionsCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2RejectVpcPeeringConnectionCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2RejectVpcPeeringConnectionCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2RejectVpcPeeringConnectionResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "RejectVpcPeeringConnectionResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2RejectVpcPeeringConnectionCommand = deserializeAws_ec2RejectVpcPeeringConnectionCommand;
async function deserializeAws_ec2RejectVpcPeeringConnectionCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2ReleaseAddressCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2ReleaseAddressCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output)
    };
    return Promise.resolve(response);
}
exports.deserializeAws_ec2ReleaseAddressCommand = deserializeAws_ec2ReleaseAddressCommand;
async function deserializeAws_ec2ReleaseAddressCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2ReleaseHostsCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2ReleaseHostsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2ReleaseHostsResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "ReleaseHostsResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2ReleaseHostsCommand = deserializeAws_ec2ReleaseHostsCommand;
async function deserializeAws_ec2ReleaseHostsCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2ReplaceIamInstanceProfileAssociationCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2ReplaceIamInstanceProfileAssociationCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2ReplaceIamInstanceProfileAssociationResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "ReplaceIamInstanceProfileAssociationResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2ReplaceIamInstanceProfileAssociationCommand = deserializeAws_ec2ReplaceIamInstanceProfileAssociationCommand;
async function deserializeAws_ec2ReplaceIamInstanceProfileAssociationCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2ReplaceNetworkAclAssociationCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2ReplaceNetworkAclAssociationCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2ReplaceNetworkAclAssociationResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "ReplaceNetworkAclAssociationResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2ReplaceNetworkAclAssociationCommand = deserializeAws_ec2ReplaceNetworkAclAssociationCommand;
async function deserializeAws_ec2ReplaceNetworkAclAssociationCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2ReplaceNetworkAclEntryCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2ReplaceNetworkAclEntryCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output)
    };
    return Promise.resolve(response);
}
exports.deserializeAws_ec2ReplaceNetworkAclEntryCommand = deserializeAws_ec2ReplaceNetworkAclEntryCommand;
async function deserializeAws_ec2ReplaceNetworkAclEntryCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2ReplaceRouteCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2ReplaceRouteCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output)
    };
    return Promise.resolve(response);
}
exports.deserializeAws_ec2ReplaceRouteCommand = deserializeAws_ec2ReplaceRouteCommand;
async function deserializeAws_ec2ReplaceRouteCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2ReplaceRouteTableAssociationCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2ReplaceRouteTableAssociationCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2ReplaceRouteTableAssociationResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "ReplaceRouteTableAssociationResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2ReplaceRouteTableAssociationCommand = deserializeAws_ec2ReplaceRouteTableAssociationCommand;
async function deserializeAws_ec2ReplaceRouteTableAssociationCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2ReplaceTransitGatewayRouteCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2ReplaceTransitGatewayRouteCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2ReplaceTransitGatewayRouteResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "ReplaceTransitGatewayRouteResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2ReplaceTransitGatewayRouteCommand = deserializeAws_ec2ReplaceTransitGatewayRouteCommand;
async function deserializeAws_ec2ReplaceTransitGatewayRouteCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2ReportInstanceStatusCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2ReportInstanceStatusCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output)
    };
    return Promise.resolve(response);
}
exports.deserializeAws_ec2ReportInstanceStatusCommand = deserializeAws_ec2ReportInstanceStatusCommand;
async function deserializeAws_ec2ReportInstanceStatusCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2RequestSpotFleetCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2RequestSpotFleetCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2RequestSpotFleetResponse(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "RequestSpotFleetResponse" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2RequestSpotFleetCommand = deserializeAws_ec2RequestSpotFleetCommand;
async function deserializeAws_ec2RequestSpotFleetCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2RequestSpotInstancesCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2RequestSpotInstancesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2RequestSpotInstancesResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "RequestSpotInstancesResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2RequestSpotInstancesCommand = deserializeAws_ec2RequestSpotInstancesCommand;
async function deserializeAws_ec2RequestSpotInstancesCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2ResetEbsDefaultKmsKeyIdCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2ResetEbsDefaultKmsKeyIdCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2ResetEbsDefaultKmsKeyIdResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "ResetEbsDefaultKmsKeyIdResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2ResetEbsDefaultKmsKeyIdCommand = deserializeAws_ec2ResetEbsDefaultKmsKeyIdCommand;
async function deserializeAws_ec2ResetEbsDefaultKmsKeyIdCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2ResetFpgaImageAttributeCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2ResetFpgaImageAttributeCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2ResetFpgaImageAttributeResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "ResetFpgaImageAttributeResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2ResetFpgaImageAttributeCommand = deserializeAws_ec2ResetFpgaImageAttributeCommand;
async function deserializeAws_ec2ResetFpgaImageAttributeCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2ResetImageAttributeCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2ResetImageAttributeCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output)
    };
    return Promise.resolve(response);
}
exports.deserializeAws_ec2ResetImageAttributeCommand = deserializeAws_ec2ResetImageAttributeCommand;
async function deserializeAws_ec2ResetImageAttributeCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2ResetInstanceAttributeCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2ResetInstanceAttributeCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output)
    };
    return Promise.resolve(response);
}
exports.deserializeAws_ec2ResetInstanceAttributeCommand = deserializeAws_ec2ResetInstanceAttributeCommand;
async function deserializeAws_ec2ResetInstanceAttributeCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2ResetNetworkInterfaceAttributeCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2ResetNetworkInterfaceAttributeCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output)
    };
    return Promise.resolve(response);
}
exports.deserializeAws_ec2ResetNetworkInterfaceAttributeCommand = deserializeAws_ec2ResetNetworkInterfaceAttributeCommand;
async function deserializeAws_ec2ResetNetworkInterfaceAttributeCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2ResetSnapshotAttributeCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2ResetSnapshotAttributeCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output)
    };
    return Promise.resolve(response);
}
exports.deserializeAws_ec2ResetSnapshotAttributeCommand = deserializeAws_ec2ResetSnapshotAttributeCommand;
async function deserializeAws_ec2ResetSnapshotAttributeCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2RestoreAddressToClassicCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2RestoreAddressToClassicCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2RestoreAddressToClassicResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "RestoreAddressToClassicResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2RestoreAddressToClassicCommand = deserializeAws_ec2RestoreAddressToClassicCommand;
async function deserializeAws_ec2RestoreAddressToClassicCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2RevokeClientVpnIngressCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2RevokeClientVpnIngressCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2RevokeClientVpnIngressResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "RevokeClientVpnIngressResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2RevokeClientVpnIngressCommand = deserializeAws_ec2RevokeClientVpnIngressCommand;
async function deserializeAws_ec2RevokeClientVpnIngressCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2RevokeSecurityGroupEgressCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2RevokeSecurityGroupEgressCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output)
    };
    return Promise.resolve(response);
}
exports.deserializeAws_ec2RevokeSecurityGroupEgressCommand = deserializeAws_ec2RevokeSecurityGroupEgressCommand;
async function deserializeAws_ec2RevokeSecurityGroupEgressCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2RevokeSecurityGroupIngressCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2RevokeSecurityGroupIngressCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output)
    };
    return Promise.resolve(response);
}
exports.deserializeAws_ec2RevokeSecurityGroupIngressCommand = deserializeAws_ec2RevokeSecurityGroupIngressCommand;
async function deserializeAws_ec2RevokeSecurityGroupIngressCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2RunInstancesCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2RunInstancesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2Reservation(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "Reservation" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2RunInstancesCommand = deserializeAws_ec2RunInstancesCommand;
async function deserializeAws_ec2RunInstancesCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2RunScheduledInstancesCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2RunScheduledInstancesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2RunScheduledInstancesResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "RunScheduledInstancesResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2RunScheduledInstancesCommand = deserializeAws_ec2RunScheduledInstancesCommand;
async function deserializeAws_ec2RunScheduledInstancesCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2SearchLocalGatewayRoutesCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2SearchLocalGatewayRoutesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2SearchLocalGatewayRoutesResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "SearchLocalGatewayRoutesResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2SearchLocalGatewayRoutesCommand = deserializeAws_ec2SearchLocalGatewayRoutesCommand;
async function deserializeAws_ec2SearchLocalGatewayRoutesCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2SearchTransitGatewayMulticastGroupsCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2SearchTransitGatewayMulticastGroupsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2SearchTransitGatewayMulticastGroupsResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "SearchTransitGatewayMulticastGroupsResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2SearchTransitGatewayMulticastGroupsCommand = deserializeAws_ec2SearchTransitGatewayMulticastGroupsCommand;
async function deserializeAws_ec2SearchTransitGatewayMulticastGroupsCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2SearchTransitGatewayRoutesCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2SearchTransitGatewayRoutesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2SearchTransitGatewayRoutesResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "SearchTransitGatewayRoutesResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2SearchTransitGatewayRoutesCommand = deserializeAws_ec2SearchTransitGatewayRoutesCommand;
async function deserializeAws_ec2SearchTransitGatewayRoutesCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2SendDiagnosticInterruptCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2SendDiagnosticInterruptCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output)
    };
    return Promise.resolve(response);
}
exports.deserializeAws_ec2SendDiagnosticInterruptCommand = deserializeAws_ec2SendDiagnosticInterruptCommand;
async function deserializeAws_ec2SendDiagnosticInterruptCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2StartInstancesCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2StartInstancesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2StartInstancesResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "StartInstancesResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2StartInstancesCommand = deserializeAws_ec2StartInstancesCommand;
async function deserializeAws_ec2StartInstancesCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2StartVpcEndpointServicePrivateDnsVerificationCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2StartVpcEndpointServicePrivateDnsVerificationCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2StartVpcEndpointServicePrivateDnsVerificationResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "StartVpcEndpointServicePrivateDnsVerificationResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2StartVpcEndpointServicePrivateDnsVerificationCommand = deserializeAws_ec2StartVpcEndpointServicePrivateDnsVerificationCommand;
async function deserializeAws_ec2StartVpcEndpointServicePrivateDnsVerificationCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2StopInstancesCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2StopInstancesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2StopInstancesResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "StopInstancesResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2StopInstancesCommand = deserializeAws_ec2StopInstancesCommand;
async function deserializeAws_ec2StopInstancesCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2TerminateClientVpnConnectionsCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2TerminateClientVpnConnectionsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2TerminateClientVpnConnectionsResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "TerminateClientVpnConnectionsResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2TerminateClientVpnConnectionsCommand = deserializeAws_ec2TerminateClientVpnConnectionsCommand;
async function deserializeAws_ec2TerminateClientVpnConnectionsCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2TerminateInstancesCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2TerminateInstancesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2TerminateInstancesResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "TerminateInstancesResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2TerminateInstancesCommand = deserializeAws_ec2TerminateInstancesCommand;
async function deserializeAws_ec2TerminateInstancesCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2UnassignIpv6AddressesCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2UnassignIpv6AddressesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2UnassignIpv6AddressesResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "UnassignIpv6AddressesResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2UnassignIpv6AddressesCommand = deserializeAws_ec2UnassignIpv6AddressesCommand;
async function deserializeAws_ec2UnassignIpv6AddressesCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2UnassignPrivateIpAddressesCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2UnassignPrivateIpAddressesCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output)
    };
    return Promise.resolve(response);
}
exports.deserializeAws_ec2UnassignPrivateIpAddressesCommand = deserializeAws_ec2UnassignPrivateIpAddressesCommand;
async function deserializeAws_ec2UnassignPrivateIpAddressesCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2UnmonitorInstancesCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2UnmonitorInstancesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2UnmonitorInstancesResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "UnmonitorInstancesResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2UnmonitorInstancesCommand = deserializeAws_ec2UnmonitorInstancesCommand;
async function deserializeAws_ec2UnmonitorInstancesCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2UpdateSecurityGroupRuleDescriptionsEgressCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2UpdateSecurityGroupRuleDescriptionsEgressCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2UpdateSecurityGroupRuleDescriptionsEgressResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "UpdateSecurityGroupRuleDescriptionsEgressResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2UpdateSecurityGroupRuleDescriptionsEgressCommand = deserializeAws_ec2UpdateSecurityGroupRuleDescriptionsEgressCommand;
async function deserializeAws_ec2UpdateSecurityGroupRuleDescriptionsEgressCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2UpdateSecurityGroupRuleDescriptionsIngressCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2UpdateSecurityGroupRuleDescriptionsIngressCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2UpdateSecurityGroupRuleDescriptionsIngressResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "UpdateSecurityGroupRuleDescriptionsIngressResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2UpdateSecurityGroupRuleDescriptionsIngressCommand = deserializeAws_ec2UpdateSecurityGroupRuleDescriptionsIngressCommand;
async function deserializeAws_ec2UpdateSecurityGroupRuleDescriptionsIngressCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
async function deserializeAws_ec2WithdrawByoipCidrCommand(output, context) {
    if (output.statusCode >= 400) {
        return deserializeAws_ec2WithdrawByoipCidrCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_ec2WithdrawByoipCidrResult(data, context);
    const response = Object.assign({ $metadata: deserializeMetadata(output), __type: "WithdrawByoipCidrResult" }, contents);
    return Promise.resolve(response);
}
exports.deserializeAws_ec2WithdrawByoipCidrCommand = deserializeAws_ec2WithdrawByoipCidrCommand;
async function deserializeAws_ec2WithdrawByoipCidrCommandError(output, context) {
    const parsedOutput = Object.assign(Object.assign({}, output), { body: await parseBody(output.body, context) });
    let response;
    let errorCode = "UnknownError";
    errorCode = loadEc2ErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        default:
            const parsedBody = parsedOutput.body;
            errorCode =
                parsedBody.Errors.Error.code ||
                    parsedBody.Errors.Error.Code ||
                    errorCode;
            response = Object.assign(Object.assign({}, parsedBody.Errors.Error), { name: `${errorCode}`, message: parsedBody.Errors.Error.message ||
                    parsedBody.Errors.Error.Message ||
                    errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
    }
    const message = response.message || response.Message || errorCode;
    response.message = message;
    delete response.Message;
    return Promise.reject(Object.assign(new Error(message), response));
}
const serializeAws_ec2AcceptReservedInstancesExchangeQuoteRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.ReservedInstanceIds !== undefined) {
        const memberEntries = serializeAws_ec2ReservedInstanceIdSet(input.ReservedInstanceIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `ReservedInstanceId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.TargetConfigurations !== undefined) {
        const memberEntries = serializeAws_ec2TargetConfigurationRequestSet(input.TargetConfigurations, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `TargetConfiguration.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2AcceptTransitGatewayPeeringAttachmentRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.TransitGatewayAttachmentId !== undefined) {
        entries["TransitGatewayAttachmentId"] = input.TransitGatewayAttachmentId;
    }
    return entries;
};
const serializeAws_ec2AcceptTransitGatewayVpcAttachmentRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.TransitGatewayAttachmentId !== undefined) {
        entries["TransitGatewayAttachmentId"] = input.TransitGatewayAttachmentId;
    }
    return entries;
};
const serializeAws_ec2AcceptVpcEndpointConnectionsRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.ServiceId !== undefined) {
        entries["ServiceId"] = input.ServiceId;
    }
    if (input.VpcEndpointIds !== undefined) {
        const memberEntries = serializeAws_ec2ValueStringList(input.VpcEndpointIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `VpcEndpointId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2AcceptVpcPeeringConnectionRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.VpcPeeringConnectionId !== undefined) {
        entries["VpcPeeringConnectionId"] = input.VpcPeeringConnectionId;
    }
    return entries;
};
const serializeAws_ec2AccountAttributeNameStringList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        entries[`AttributeName.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const serializeAws_ec2AdvertiseByoipCidrRequest = (input, context) => {
    const entries = {};
    if (input.Cidr !== undefined) {
        entries["Cidr"] = input.Cidr;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    return entries;
};
const serializeAws_ec2AllocateAddressRequest = (input, context) => {
    const entries = {};
    if (input.Address !== undefined) {
        entries["Address"] = input.Address;
    }
    if (input.CustomerOwnedIpv4Pool !== undefined) {
        entries["CustomerOwnedIpv4Pool"] = input.CustomerOwnedIpv4Pool;
    }
    if (input.Domain !== undefined) {
        entries["Domain"] = input.Domain;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.NetworkBorderGroup !== undefined) {
        entries["NetworkBorderGroup"] = input.NetworkBorderGroup;
    }
    if (input.PublicIpv4Pool !== undefined) {
        entries["PublicIpv4Pool"] = input.PublicIpv4Pool;
    }
    return entries;
};
const serializeAws_ec2AllocateHostsRequest = (input, context) => {
    const entries = {};
    if (input.AutoPlacement !== undefined) {
        entries["AutoPlacement"] = input.AutoPlacement;
    }
    if (input.AvailabilityZone !== undefined) {
        entries["AvailabilityZone"] = input.AvailabilityZone;
    }
    if (input.ClientToken !== undefined) {
        entries["ClientToken"] = input.ClientToken;
    }
    if (input.HostRecovery !== undefined) {
        entries["HostRecovery"] = input.HostRecovery;
    }
    if (input.InstanceFamily !== undefined) {
        entries["InstanceFamily"] = input.InstanceFamily;
    }
    if (input.InstanceType !== undefined) {
        entries["InstanceType"] = input.InstanceType;
    }
    if (input.Quantity !== undefined) {
        entries["Quantity"] = input.Quantity;
    }
    if (input.TagSpecifications !== undefined) {
        const memberEntries = serializeAws_ec2TagSpecificationList(input.TagSpecifications, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2AllocationIdList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        entries[`AllocationId.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const serializeAws_ec2ApplySecurityGroupsToClientVpnTargetNetworkRequest = (input, context) => {
    const entries = {};
    if (input.ClientVpnEndpointId !== undefined) {
        entries["ClientVpnEndpointId"] = input.ClientVpnEndpointId;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.SecurityGroupIds !== undefined) {
        const memberEntries = serializeAws_ec2ClientVpnSecurityGroupIdSet(input.SecurityGroupIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `SecurityGroupId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.VpcId !== undefined) {
        entries["VpcId"] = input.VpcId;
    }
    return entries;
};
const serializeAws_ec2AssignIpv6AddressesRequest = (input, context) => {
    const entries = {};
    if (input.Ipv6AddressCount !== undefined) {
        entries["Ipv6AddressCount"] = input.Ipv6AddressCount;
    }
    if (input.Ipv6Addresses !== undefined) {
        const memberEntries = serializeAws_ec2Ipv6AddressList(input.Ipv6Addresses, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Ipv6Addresses.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.NetworkInterfaceId !== undefined) {
        entries["NetworkInterfaceId"] = input.NetworkInterfaceId;
    }
    return entries;
};
const serializeAws_ec2AssignPrivateIpAddressesRequest = (input, context) => {
    const entries = {};
    if (input.AllowReassignment !== undefined) {
        entries["AllowReassignment"] = input.AllowReassignment;
    }
    if (input.NetworkInterfaceId !== undefined) {
        entries["NetworkInterfaceId"] = input.NetworkInterfaceId;
    }
    if (input.PrivateIpAddresses !== undefined) {
        const memberEntries = serializeAws_ec2PrivateIpAddressStringList(input.PrivateIpAddresses, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `PrivateIpAddress.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.SecondaryPrivateIpAddressCount !== undefined) {
        entries["SecondaryPrivateIpAddressCount"] =
            input.SecondaryPrivateIpAddressCount;
    }
    return entries;
};
const serializeAws_ec2AssociateAddressRequest = (input, context) => {
    const entries = {};
    if (input.AllocationId !== undefined) {
        entries["AllocationId"] = input.AllocationId;
    }
    if (input.AllowReassociation !== undefined) {
        entries["AllowReassociation"] = input.AllowReassociation;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.InstanceId !== undefined) {
        entries["InstanceId"] = input.InstanceId;
    }
    if (input.NetworkInterfaceId !== undefined) {
        entries["NetworkInterfaceId"] = input.NetworkInterfaceId;
    }
    if (input.PrivateIpAddress !== undefined) {
        entries["PrivateIpAddress"] = input.PrivateIpAddress;
    }
    if (input.PublicIp !== undefined) {
        entries["PublicIp"] = input.PublicIp;
    }
    return entries;
};
const serializeAws_ec2AssociateClientVpnTargetNetworkRequest = (input, context) => {
    const entries = {};
    if (input.ClientToken === undefined) {
        input.ClientToken = uuid_1.v4();
    }
    if (input.ClientToken !== undefined) {
        entries["ClientToken"] = input.ClientToken;
    }
    if (input.ClientVpnEndpointId !== undefined) {
        entries["ClientVpnEndpointId"] = input.ClientVpnEndpointId;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.SubnetId !== undefined) {
        entries["SubnetId"] = input.SubnetId;
    }
    return entries;
};
const serializeAws_ec2AssociateDhcpOptionsRequest = (input, context) => {
    const entries = {};
    if (input.DhcpOptionsId !== undefined) {
        entries["DhcpOptionsId"] = input.DhcpOptionsId;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.VpcId !== undefined) {
        entries["VpcId"] = input.VpcId;
    }
    return entries;
};
const serializeAws_ec2AssociateIamInstanceProfileRequest = (input, context) => {
    const entries = {};
    if (input.IamInstanceProfile !== undefined) {
        const memberEntries = serializeAws_ec2IamInstanceProfileSpecification(input.IamInstanceProfile, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `IamInstanceProfile.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.InstanceId !== undefined) {
        entries["InstanceId"] = input.InstanceId;
    }
    return entries;
};
const serializeAws_ec2AssociateRouteTableRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.GatewayId !== undefined) {
        entries["GatewayId"] = input.GatewayId;
    }
    if (input.RouteTableId !== undefined) {
        entries["RouteTableId"] = input.RouteTableId;
    }
    if (input.SubnetId !== undefined) {
        entries["SubnetId"] = input.SubnetId;
    }
    return entries;
};
const serializeAws_ec2AssociateSubnetCidrBlockRequest = (input, context) => {
    const entries = {};
    if (input.Ipv6CidrBlock !== undefined) {
        entries["Ipv6CidrBlock"] = input.Ipv6CidrBlock;
    }
    if (input.SubnetId !== undefined) {
        entries["SubnetId"] = input.SubnetId;
    }
    return entries;
};
const serializeAws_ec2AssociateTransitGatewayMulticastDomainRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.SubnetIds !== undefined) {
        const memberEntries = serializeAws_ec2ValueStringList(input.SubnetIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `SubnetIds.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.TransitGatewayAttachmentId !== undefined) {
        entries["TransitGatewayAttachmentId"] = input.TransitGatewayAttachmentId;
    }
    if (input.TransitGatewayMulticastDomainId !== undefined) {
        entries["TransitGatewayMulticastDomainId"] =
            input.TransitGatewayMulticastDomainId;
    }
    return entries;
};
const serializeAws_ec2AssociateTransitGatewayRouteTableRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.TransitGatewayAttachmentId !== undefined) {
        entries["TransitGatewayAttachmentId"] = input.TransitGatewayAttachmentId;
    }
    if (input.TransitGatewayRouteTableId !== undefined) {
        entries["TransitGatewayRouteTableId"] = input.TransitGatewayRouteTableId;
    }
    return entries;
};
const serializeAws_ec2AssociateVpcCidrBlockRequest = (input, context) => {
    const entries = {};
    if (input.AmazonProvidedIpv6CidrBlock !== undefined) {
        entries["AmazonProvidedIpv6CidrBlock"] = input.AmazonProvidedIpv6CidrBlock;
    }
    if (input.CidrBlock !== undefined) {
        entries["CidrBlock"] = input.CidrBlock;
    }
    if (input.Ipv6CidrBlock !== undefined) {
        entries["Ipv6CidrBlock"] = input.Ipv6CidrBlock;
    }
    if (input.Ipv6CidrBlockNetworkBorderGroup !== undefined) {
        entries["Ipv6CidrBlockNetworkBorderGroup"] =
            input.Ipv6CidrBlockNetworkBorderGroup;
    }
    if (input.Ipv6Pool !== undefined) {
        entries["Ipv6Pool"] = input.Ipv6Pool;
    }
    if (input.VpcId !== undefined) {
        entries["VpcId"] = input.VpcId;
    }
    return entries;
};
const serializeAws_ec2AssociationIdList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        entries[`AssociationId.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const serializeAws_ec2AttachClassicLinkVpcRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Groups !== undefined) {
        const memberEntries = serializeAws_ec2GroupIdStringList(input.Groups, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `SecurityGroupId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.InstanceId !== undefined) {
        entries["InstanceId"] = input.InstanceId;
    }
    if (input.VpcId !== undefined) {
        entries["VpcId"] = input.VpcId;
    }
    return entries;
};
const serializeAws_ec2AttachInternetGatewayRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.InternetGatewayId !== undefined) {
        entries["InternetGatewayId"] = input.InternetGatewayId;
    }
    if (input.VpcId !== undefined) {
        entries["VpcId"] = input.VpcId;
    }
    return entries;
};
const serializeAws_ec2AttachNetworkInterfaceRequest = (input, context) => {
    const entries = {};
    if (input.DeviceIndex !== undefined) {
        entries["DeviceIndex"] = input.DeviceIndex;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.InstanceId !== undefined) {
        entries["InstanceId"] = input.InstanceId;
    }
    if (input.NetworkInterfaceId !== undefined) {
        entries["NetworkInterfaceId"] = input.NetworkInterfaceId;
    }
    return entries;
};
const serializeAws_ec2AttachVolumeRequest = (input, context) => {
    const entries = {};
    if (input.Device !== undefined) {
        entries["Device"] = input.Device;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.InstanceId !== undefined) {
        entries["InstanceId"] = input.InstanceId;
    }
    if (input.VolumeId !== undefined) {
        entries["VolumeId"] = input.VolumeId;
    }
    return entries;
};
const serializeAws_ec2AttachVpnGatewayRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.VpcId !== undefined) {
        entries["VpcId"] = input.VpcId;
    }
    if (input.VpnGatewayId !== undefined) {
        entries["VpnGatewayId"] = input.VpnGatewayId;
    }
    return entries;
};
const serializeAws_ec2AttributeBooleanValue = (input, context) => {
    const entries = {};
    if (input.Value !== undefined) {
        entries["Value"] = input.Value;
    }
    return entries;
};
const serializeAws_ec2AttributeValue = (input, context) => {
    const entries = {};
    if (input.Value !== undefined) {
        entries["Value"] = input.Value;
    }
    return entries;
};
const serializeAws_ec2AuthorizeClientVpnIngressRequest = (input, context) => {
    const entries = {};
    if (input.AccessGroupId !== undefined) {
        entries["AccessGroupId"] = input.AccessGroupId;
    }
    if (input.AuthorizeAllGroups !== undefined) {
        entries["AuthorizeAllGroups"] = input.AuthorizeAllGroups;
    }
    if (input.ClientToken === undefined) {
        input.ClientToken = uuid_1.v4();
    }
    if (input.ClientToken !== undefined) {
        entries["ClientToken"] = input.ClientToken;
    }
    if (input.ClientVpnEndpointId !== undefined) {
        entries["ClientVpnEndpointId"] = input.ClientVpnEndpointId;
    }
    if (input.Description !== undefined) {
        entries["Description"] = input.Description;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.TargetNetworkCidr !== undefined) {
        entries["TargetNetworkCidr"] = input.TargetNetworkCidr;
    }
    return entries;
};
const serializeAws_ec2AuthorizeSecurityGroupEgressRequest = (input, context) => {
    const entries = {};
    if (input.CidrIp !== undefined) {
        entries["CidrIp"] = input.CidrIp;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.FromPort !== undefined) {
        entries["FromPort"] = input.FromPort;
    }
    if (input.GroupId !== undefined) {
        entries["GroupId"] = input.GroupId;
    }
    if (input.IpPermissions !== undefined) {
        const memberEntries = serializeAws_ec2IpPermissionList(input.IpPermissions, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `IpPermissions.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.IpProtocol !== undefined) {
        entries["IpProtocol"] = input.IpProtocol;
    }
    if (input.SourceSecurityGroupName !== undefined) {
        entries["SourceSecurityGroupName"] = input.SourceSecurityGroupName;
    }
    if (input.SourceSecurityGroupOwnerId !== undefined) {
        entries["SourceSecurityGroupOwnerId"] = input.SourceSecurityGroupOwnerId;
    }
    if (input.ToPort !== undefined) {
        entries["ToPort"] = input.ToPort;
    }
    return entries;
};
const serializeAws_ec2AuthorizeSecurityGroupIngressRequest = (input, context) => {
    const entries = {};
    if (input.CidrIp !== undefined) {
        entries["CidrIp"] = input.CidrIp;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.FromPort !== undefined) {
        entries["FromPort"] = input.FromPort;
    }
    if (input.GroupId !== undefined) {
        entries["GroupId"] = input.GroupId;
    }
    if (input.GroupName !== undefined) {
        entries["GroupName"] = input.GroupName;
    }
    if (input.IpPermissions !== undefined) {
        const memberEntries = serializeAws_ec2IpPermissionList(input.IpPermissions, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `IpPermissions.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.IpProtocol !== undefined) {
        entries["IpProtocol"] = input.IpProtocol;
    }
    if (input.SourceSecurityGroupName !== undefined) {
        entries["SourceSecurityGroupName"] = input.SourceSecurityGroupName;
    }
    if (input.SourceSecurityGroupOwnerId !== undefined) {
        entries["SourceSecurityGroupOwnerId"] = input.SourceSecurityGroupOwnerId;
    }
    if (input.ToPort !== undefined) {
        entries["ToPort"] = input.ToPort;
    }
    return entries;
};
const serializeAws_ec2AvailabilityZoneStringList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        entries[`AvailabilityZone.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const serializeAws_ec2BillingProductList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const serializeAws_ec2BlobAttributeValue = (input, context) => {
    const entries = {};
    if (input.Value !== undefined) {
        entries["Value"] = context.base64Encoder(input.Value);
    }
    return entries;
};
const serializeAws_ec2BlockDeviceMapping = (input, context) => {
    const entries = {};
    if (input.DeviceName !== undefined) {
        entries["DeviceName"] = input.DeviceName;
    }
    if (input.Ebs !== undefined) {
        const memberEntries = serializeAws_ec2EbsBlockDevice(input.Ebs, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Ebs.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.NoDevice !== undefined) {
        entries["NoDevice"] = input.NoDevice;
    }
    if (input.VirtualName !== undefined) {
        entries["VirtualName"] = input.VirtualName;
    }
    return entries;
};
const serializeAws_ec2BlockDeviceMappingList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        const memberEntries = serializeAws_ec2BlockDeviceMapping(entry, context);
        Object.keys(memberEntries).forEach(key => {
            entries[`Item.${counter}.${key}`] = memberEntries[key];
        });
        counter++;
    }
    return entries;
};
const serializeAws_ec2BlockDeviceMappingRequestList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        const memberEntries = serializeAws_ec2BlockDeviceMapping(entry, context);
        Object.keys(memberEntries).forEach(key => {
            entries[`BlockDeviceMapping.${counter}.${key}`] = memberEntries[key];
        });
        counter++;
    }
    return entries;
};
const serializeAws_ec2BundleIdStringList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        entries[`BundleId.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const serializeAws_ec2BundleInstanceRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.InstanceId !== undefined) {
        entries["InstanceId"] = input.InstanceId;
    }
    if (input.Storage !== undefined) {
        const memberEntries = serializeAws_ec2Storage(input.Storage, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Storage.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2CancelBundleTaskRequest = (input, context) => {
    const entries = {};
    if (input.BundleId !== undefined) {
        entries["BundleId"] = input.BundleId;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    return entries;
};
const serializeAws_ec2CancelCapacityReservationRequest = (input, context) => {
    const entries = {};
    if (input.CapacityReservationId !== undefined) {
        entries["CapacityReservationId"] = input.CapacityReservationId;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    return entries;
};
const serializeAws_ec2CancelConversionRequest = (input, context) => {
    const entries = {};
    if (input.ConversionTaskId !== undefined) {
        entries["ConversionTaskId"] = input.ConversionTaskId;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.ReasonMessage !== undefined) {
        entries["ReasonMessage"] = input.ReasonMessage;
    }
    return entries;
};
const serializeAws_ec2CancelExportTaskRequest = (input, context) => {
    const entries = {};
    if (input.ExportTaskId !== undefined) {
        entries["ExportTaskId"] = input.ExportTaskId;
    }
    return entries;
};
const serializeAws_ec2CancelImportTaskRequest = (input, context) => {
    const entries = {};
    if (input.CancelReason !== undefined) {
        entries["CancelReason"] = input.CancelReason;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.ImportTaskId !== undefined) {
        entries["ImportTaskId"] = input.ImportTaskId;
    }
    return entries;
};
const serializeAws_ec2CancelReservedInstancesListingRequest = (input, context) => {
    const entries = {};
    if (input.ReservedInstancesListingId !== undefined) {
        entries["ReservedInstancesListingId"] = input.ReservedInstancesListingId;
    }
    return entries;
};
const serializeAws_ec2CancelSpotFleetRequestsRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.SpotFleetRequestIds !== undefined) {
        const memberEntries = serializeAws_ec2ValueStringList(input.SpotFleetRequestIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `SpotFleetRequestId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.TerminateInstances !== undefined) {
        entries["TerminateInstances"] = input.TerminateInstances;
    }
    return entries;
};
const serializeAws_ec2CancelSpotInstanceRequestsRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.SpotInstanceRequestIds !== undefined) {
        const memberEntries = serializeAws_ec2SpotInstanceRequestIdList(input.SpotInstanceRequestIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `SpotInstanceRequestId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2CapacityReservationIdSet = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const serializeAws_ec2CapacityReservationOptionsRequest = (input, context) => {
    const entries = {};
    if (input.UsageStrategy !== undefined) {
        entries["UsageStrategy"] = input.UsageStrategy;
    }
    return entries;
};
const serializeAws_ec2CapacityReservationSpecification = (input, context) => {
    const entries = {};
    if (input.CapacityReservationPreference !== undefined) {
        entries["CapacityReservationPreference"] =
            input.CapacityReservationPreference;
    }
    if (input.CapacityReservationTarget !== undefined) {
        const memberEntries = serializeAws_ec2CapacityReservationTarget(input.CapacityReservationTarget, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `CapacityReservationTarget.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2CapacityReservationTarget = (input, context) => {
    const entries = {};
    if (input.CapacityReservationId !== undefined) {
        entries["CapacityReservationId"] = input.CapacityReservationId;
    }
    return entries;
};
const serializeAws_ec2CertificateAuthenticationRequest = (input, context) => {
    const entries = {};
    if (input.ClientRootCertificateChainArn !== undefined) {
        entries["ClientRootCertificateChainArn"] =
            input.ClientRootCertificateChainArn;
    }
    return entries;
};
const serializeAws_ec2CidrAuthorizationContext = (input, context) => {
    const entries = {};
    if (input.Message !== undefined) {
        entries["Message"] = input.Message;
    }
    if (input.Signature !== undefined) {
        entries["Signature"] = input.Signature;
    }
    return entries;
};
const serializeAws_ec2ClassicLoadBalancer = (input, context) => {
    const entries = {};
    if (input.Name !== undefined) {
        entries["Name"] = input.Name;
    }
    return entries;
};
const serializeAws_ec2ClassicLoadBalancers = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        const memberEntries = serializeAws_ec2ClassicLoadBalancer(entry, context);
        Object.keys(memberEntries).forEach(key => {
            entries[`Item.${counter}.${key}`] = memberEntries[key];
        });
        counter++;
    }
    return entries;
};
const serializeAws_ec2ClassicLoadBalancersConfig = (input, context) => {
    const entries = {};
    if (input.ClassicLoadBalancers !== undefined) {
        const memberEntries = serializeAws_ec2ClassicLoadBalancers(input.ClassicLoadBalancers, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `ClassicLoadBalancers.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2ClientData = (input, context) => {
    const entries = {};
    if (input.Comment !== undefined) {
        entries["Comment"] = input.Comment;
    }
    if (input.UploadEnd !== undefined) {
        entries["UploadEnd"] = input.UploadEnd.toISOString().split(".")[0] + "Z";
    }
    if (input.UploadSize !== undefined) {
        entries["UploadSize"] = input.UploadSize;
    }
    if (input.UploadStart !== undefined) {
        entries["UploadStart"] =
            input.UploadStart.toISOString().split(".")[0] + "Z";
    }
    return entries;
};
const serializeAws_ec2ClientVpnAuthenticationRequest = (input, context) => {
    const entries = {};
    if (input.ActiveDirectory !== undefined) {
        const memberEntries = serializeAws_ec2DirectoryServiceAuthenticationRequest(input.ActiveDirectory, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `ActiveDirectory.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.MutualAuthentication !== undefined) {
        const memberEntries = serializeAws_ec2CertificateAuthenticationRequest(input.MutualAuthentication, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `MutualAuthentication.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.Type !== undefined) {
        entries["Type"] = input.Type;
    }
    return entries;
};
const serializeAws_ec2ClientVpnAuthenticationRequestList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        const memberEntries = serializeAws_ec2ClientVpnAuthenticationRequest(entry, context);
        Object.keys(memberEntries).forEach(key => {
            entries[`Member.${counter}.${key}`] = memberEntries[key];
        });
        counter++;
    }
    return entries;
};
const serializeAws_ec2ClientVpnSecurityGroupIdSet = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const serializeAws_ec2CoipPoolIdSet = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const serializeAws_ec2ConfirmProductInstanceRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.InstanceId !== undefined) {
        entries["InstanceId"] = input.InstanceId;
    }
    if (input.ProductCode !== undefined) {
        entries["ProductCode"] = input.ProductCode;
    }
    return entries;
};
const serializeAws_ec2ConnectionLogOptions = (input, context) => {
    const entries = {};
    if (input.CloudwatchLogGroup !== undefined) {
        entries["CloudwatchLogGroup"] = input.CloudwatchLogGroup;
    }
    if (input.CloudwatchLogStream !== undefined) {
        entries["CloudwatchLogStream"] = input.CloudwatchLogStream;
    }
    if (input.Enabled !== undefined) {
        entries["Enabled"] = input.Enabled;
    }
    return entries;
};
const serializeAws_ec2ConversionIdStringList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const serializeAws_ec2CopyFpgaImageRequest = (input, context) => {
    const entries = {};
    if (input.ClientToken !== undefined) {
        entries["ClientToken"] = input.ClientToken;
    }
    if (input.Description !== undefined) {
        entries["Description"] = input.Description;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Name !== undefined) {
        entries["Name"] = input.Name;
    }
    if (input.SourceFpgaImageId !== undefined) {
        entries["SourceFpgaImageId"] = input.SourceFpgaImageId;
    }
    if (input.SourceRegion !== undefined) {
        entries["SourceRegion"] = input.SourceRegion;
    }
    return entries;
};
const serializeAws_ec2CopyImageRequest = (input, context) => {
    const entries = {};
    if (input.ClientToken !== undefined) {
        entries["ClientToken"] = input.ClientToken;
    }
    if (input.Description !== undefined) {
        entries["Description"] = input.Description;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Encrypted !== undefined) {
        entries["Encrypted"] = input.Encrypted;
    }
    if (input.KmsKeyId !== undefined) {
        entries["KmsKeyId"] = input.KmsKeyId;
    }
    if (input.Name !== undefined) {
        entries["Name"] = input.Name;
    }
    if (input.SourceImageId !== undefined) {
        entries["SourceImageId"] = input.SourceImageId;
    }
    if (input.SourceRegion !== undefined) {
        entries["SourceRegion"] = input.SourceRegion;
    }
    return entries;
};
const serializeAws_ec2CopySnapshotRequest = (input, context) => {
    const entries = {};
    if (input.Description !== undefined) {
        entries["Description"] = input.Description;
    }
    if (input.DestinationRegion !== undefined) {
        entries["DestinationRegion"] = input.DestinationRegion;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Encrypted !== undefined) {
        entries["Encrypted"] = input.Encrypted;
    }
    if (input.KmsKeyId !== undefined) {
        entries["KmsKeyId"] = input.KmsKeyId;
    }
    if (input.PresignedUrl !== undefined) {
        entries["PresignedUrl"] = input.PresignedUrl;
    }
    if (input.SourceRegion !== undefined) {
        entries["SourceRegion"] = input.SourceRegion;
    }
    if (input.SourceSnapshotId !== undefined) {
        entries["SourceSnapshotId"] = input.SourceSnapshotId;
    }
    if (input.TagSpecifications !== undefined) {
        const memberEntries = serializeAws_ec2TagSpecificationList(input.TagSpecifications, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2CpuOptionsRequest = (input, context) => {
    const entries = {};
    if (input.CoreCount !== undefined) {
        entries["CoreCount"] = input.CoreCount;
    }
    if (input.ThreadsPerCore !== undefined) {
        entries["ThreadsPerCore"] = input.ThreadsPerCore;
    }
    return entries;
};
const serializeAws_ec2CreateCapacityReservationRequest = (input, context) => {
    const entries = {};
    if (input.AvailabilityZone !== undefined) {
        entries["AvailabilityZone"] = input.AvailabilityZone;
    }
    if (input.AvailabilityZoneId !== undefined) {
        entries["AvailabilityZoneId"] = input.AvailabilityZoneId;
    }
    if (input.ClientToken !== undefined) {
        entries["ClientToken"] = input.ClientToken;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.EbsOptimized !== undefined) {
        entries["EbsOptimized"] = input.EbsOptimized;
    }
    if (input.EndDate !== undefined) {
        entries["EndDate"] = input.EndDate.toISOString().split(".")[0] + "Z";
    }
    if (input.EndDateType !== undefined) {
        entries["EndDateType"] = input.EndDateType;
    }
    if (input.EphemeralStorage !== undefined) {
        entries["EphemeralStorage"] = input.EphemeralStorage;
    }
    if (input.InstanceCount !== undefined) {
        entries["InstanceCount"] = input.InstanceCount;
    }
    if (input.InstanceMatchCriteria !== undefined) {
        entries["InstanceMatchCriteria"] = input.InstanceMatchCriteria;
    }
    if (input.InstancePlatform !== undefined) {
        entries["InstancePlatform"] = input.InstancePlatform;
    }
    if (input.InstanceType !== undefined) {
        entries["InstanceType"] = input.InstanceType;
    }
    if (input.TagSpecifications !== undefined) {
        const memberEntries = serializeAws_ec2TagSpecificationList(input.TagSpecifications, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `TagSpecifications.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.Tenancy !== undefined) {
        entries["Tenancy"] = input.Tenancy;
    }
    return entries;
};
const serializeAws_ec2CreateClientVpnEndpointRequest = (input, context) => {
    const entries = {};
    if (input.AuthenticationOptions !== undefined) {
        const memberEntries = serializeAws_ec2ClientVpnAuthenticationRequestList(input.AuthenticationOptions, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Authentication.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.ClientCidrBlock !== undefined) {
        entries["ClientCidrBlock"] = input.ClientCidrBlock;
    }
    if (input.ClientToken === undefined) {
        input.ClientToken = uuid_1.v4();
    }
    if (input.ClientToken !== undefined) {
        entries["ClientToken"] = input.ClientToken;
    }
    if (input.ConnectionLogOptions !== undefined) {
        const memberEntries = serializeAws_ec2ConnectionLogOptions(input.ConnectionLogOptions, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `ConnectionLogOptions.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.Description !== undefined) {
        entries["Description"] = input.Description;
    }
    if (input.DnsServers !== undefined) {
        const memberEntries = serializeAws_ec2ValueStringList(input.DnsServers, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `DnsServers.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.ServerCertificateArn !== undefined) {
        entries["ServerCertificateArn"] = input.ServerCertificateArn;
    }
    if (input.SplitTunnel !== undefined) {
        entries["SplitTunnel"] = input.SplitTunnel;
    }
    if (input.TagSpecifications !== undefined) {
        const memberEntries = serializeAws_ec2TagSpecificationList(input.TagSpecifications, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.TransportProtocol !== undefined) {
        entries["TransportProtocol"] = input.TransportProtocol;
    }
    if (input.VpnPort !== undefined) {
        entries["VpnPort"] = input.VpnPort;
    }
    return entries;
};
const serializeAws_ec2CreateClientVpnRouteRequest = (input, context) => {
    const entries = {};
    if (input.ClientToken === undefined) {
        input.ClientToken = uuid_1.v4();
    }
    if (input.ClientToken !== undefined) {
        entries["ClientToken"] = input.ClientToken;
    }
    if (input.ClientVpnEndpointId !== undefined) {
        entries["ClientVpnEndpointId"] = input.ClientVpnEndpointId;
    }
    if (input.Description !== undefined) {
        entries["Description"] = input.Description;
    }
    if (input.DestinationCidrBlock !== undefined) {
        entries["DestinationCidrBlock"] = input.DestinationCidrBlock;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.TargetVpcSubnetId !== undefined) {
        entries["TargetVpcSubnetId"] = input.TargetVpcSubnetId;
    }
    return entries;
};
const serializeAws_ec2CreateCustomerGatewayRequest = (input, context) => {
    const entries = {};
    if (input.BgpAsn !== undefined) {
        entries["BgpAsn"] = input.BgpAsn;
    }
    if (input.CertificateArn !== undefined) {
        entries["CertificateArn"] = input.CertificateArn;
    }
    if (input.DeviceName !== undefined) {
        entries["DeviceName"] = input.DeviceName;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.PublicIp !== undefined) {
        entries["IpAddress"] = input.PublicIp;
    }
    if (input.Type !== undefined) {
        entries["Type"] = input.Type;
    }
    return entries;
};
const serializeAws_ec2CreateDefaultSubnetRequest = (input, context) => {
    const entries = {};
    if (input.AvailabilityZone !== undefined) {
        entries["AvailabilityZone"] = input.AvailabilityZone;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    return entries;
};
const serializeAws_ec2CreateDefaultVpcRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    return entries;
};
const serializeAws_ec2CreateDhcpOptionsRequest = (input, context) => {
    const entries = {};
    if (input.DhcpConfigurations !== undefined) {
        const memberEntries = serializeAws_ec2NewDhcpConfigurationList(input.DhcpConfigurations, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `DhcpConfiguration.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    return entries;
};
const serializeAws_ec2CreateEgressOnlyInternetGatewayRequest = (input, context) => {
    const entries = {};
    if (input.ClientToken !== undefined) {
        entries["ClientToken"] = input.ClientToken;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.VpcId !== undefined) {
        entries["VpcId"] = input.VpcId;
    }
    return entries;
};
const serializeAws_ec2CreateFleetRequest = (input, context) => {
    const entries = {};
    if (input.ClientToken !== undefined) {
        entries["ClientToken"] = input.ClientToken;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.ExcessCapacityTerminationPolicy !== undefined) {
        entries["ExcessCapacityTerminationPolicy"] =
            input.ExcessCapacityTerminationPolicy;
    }
    if (input.LaunchTemplateConfigs !== undefined) {
        const memberEntries = serializeAws_ec2FleetLaunchTemplateConfigListRequest(input.LaunchTemplateConfigs, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `LaunchTemplateConfigs.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.OnDemandOptions !== undefined) {
        const memberEntries = serializeAws_ec2OnDemandOptionsRequest(input.OnDemandOptions, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `OnDemandOptions.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.ReplaceUnhealthyInstances !== undefined) {
        entries["ReplaceUnhealthyInstances"] = input.ReplaceUnhealthyInstances;
    }
    if (input.SpotOptions !== undefined) {
        const memberEntries = serializeAws_ec2SpotOptionsRequest(input.SpotOptions, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `SpotOptions.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.TagSpecifications !== undefined) {
        const memberEntries = serializeAws_ec2TagSpecificationList(input.TagSpecifications, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.TargetCapacitySpecification !== undefined) {
        const memberEntries = serializeAws_ec2TargetCapacitySpecificationRequest(input.TargetCapacitySpecification, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `TargetCapacitySpecification.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.TerminateInstancesWithExpiration !== undefined) {
        entries["TerminateInstancesWithExpiration"] =
            input.TerminateInstancesWithExpiration;
    }
    if (input.Type !== undefined) {
        entries["Type"] = input.Type;
    }
    if (input.ValidFrom !== undefined) {
        entries["ValidFrom"] = input.ValidFrom.toISOString().split(".")[0] + "Z";
    }
    if (input.ValidUntil !== undefined) {
        entries["ValidUntil"] = input.ValidUntil.toISOString().split(".")[0] + "Z";
    }
    return entries;
};
const serializeAws_ec2CreateFlowLogsRequest = (input, context) => {
    const entries = {};
    if (input.ClientToken !== undefined) {
        entries["ClientToken"] = input.ClientToken;
    }
    if (input.DeliverLogsPermissionArn !== undefined) {
        entries["DeliverLogsPermissionArn"] = input.DeliverLogsPermissionArn;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.LogDestination !== undefined) {
        entries["LogDestination"] = input.LogDestination;
    }
    if (input.LogDestinationType !== undefined) {
        entries["LogDestinationType"] = input.LogDestinationType;
    }
    if (input.LogFormat !== undefined) {
        entries["LogFormat"] = input.LogFormat;
    }
    if (input.LogGroupName !== undefined) {
        entries["LogGroupName"] = input.LogGroupName;
    }
    if (input.ResourceIds !== undefined) {
        const memberEntries = serializeAws_ec2ValueStringList(input.ResourceIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `ResourceId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.ResourceType !== undefined) {
        entries["ResourceType"] = input.ResourceType;
    }
    if (input.TrafficType !== undefined) {
        entries["TrafficType"] = input.TrafficType;
    }
    return entries;
};
const serializeAws_ec2CreateFpgaImageRequest = (input, context) => {
    const entries = {};
    if (input.ClientToken !== undefined) {
        entries["ClientToken"] = input.ClientToken;
    }
    if (input.Description !== undefined) {
        entries["Description"] = input.Description;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.InputStorageLocation !== undefined) {
        const memberEntries = serializeAws_ec2StorageLocation(input.InputStorageLocation, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `InputStorageLocation.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.LogsStorageLocation !== undefined) {
        const memberEntries = serializeAws_ec2StorageLocation(input.LogsStorageLocation, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `LogsStorageLocation.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.Name !== undefined) {
        entries["Name"] = input.Name;
    }
    if (input.TagSpecifications !== undefined) {
        const memberEntries = serializeAws_ec2TagSpecificationList(input.TagSpecifications, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2CreateImageRequest = (input, context) => {
    const entries = {};
    if (input.BlockDeviceMappings !== undefined) {
        const memberEntries = serializeAws_ec2BlockDeviceMappingRequestList(input.BlockDeviceMappings, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `BlockDeviceMapping.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.Description !== undefined) {
        entries["Description"] = input.Description;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.InstanceId !== undefined) {
        entries["InstanceId"] = input.InstanceId;
    }
    if (input.Name !== undefined) {
        entries["Name"] = input.Name;
    }
    if (input.NoReboot !== undefined) {
        entries["NoReboot"] = input.NoReboot;
    }
    return entries;
};
const serializeAws_ec2CreateInstanceExportTaskRequest = (input, context) => {
    const entries = {};
    if (input.Description !== undefined) {
        entries["Description"] = input.Description;
    }
    if (input.ExportToS3Task !== undefined) {
        const memberEntries = serializeAws_ec2ExportToS3TaskSpecification(input.ExportToS3Task, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `ExportToS3.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.InstanceId !== undefined) {
        entries["InstanceId"] = input.InstanceId;
    }
    if (input.TargetEnvironment !== undefined) {
        entries["TargetEnvironment"] = input.TargetEnvironment;
    }
    return entries;
};
const serializeAws_ec2CreateInternetGatewayRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    return entries;
};
const serializeAws_ec2CreateKeyPairRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.KeyName !== undefined) {
        entries["KeyName"] = input.KeyName;
    }
    return entries;
};
const serializeAws_ec2CreateLaunchTemplateRequest = (input, context) => {
    const entries = {};
    if (input.ClientToken !== undefined) {
        entries["ClientToken"] = input.ClientToken;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.LaunchTemplateData !== undefined) {
        const memberEntries = serializeAws_ec2RequestLaunchTemplateData(input.LaunchTemplateData, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `LaunchTemplateData.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.LaunchTemplateName !== undefined) {
        entries["LaunchTemplateName"] = input.LaunchTemplateName;
    }
    if (input.TagSpecifications !== undefined) {
        const memberEntries = serializeAws_ec2TagSpecificationList(input.TagSpecifications, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.VersionDescription !== undefined) {
        entries["VersionDescription"] = input.VersionDescription;
    }
    return entries;
};
const serializeAws_ec2CreateLaunchTemplateVersionRequest = (input, context) => {
    const entries = {};
    if (input.ClientToken !== undefined) {
        entries["ClientToken"] = input.ClientToken;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.LaunchTemplateData !== undefined) {
        const memberEntries = serializeAws_ec2RequestLaunchTemplateData(input.LaunchTemplateData, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `LaunchTemplateData.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.LaunchTemplateId !== undefined) {
        entries["LaunchTemplateId"] = input.LaunchTemplateId;
    }
    if (input.LaunchTemplateName !== undefined) {
        entries["LaunchTemplateName"] = input.LaunchTemplateName;
    }
    if (input.SourceVersion !== undefined) {
        entries["SourceVersion"] = input.SourceVersion;
    }
    if (input.VersionDescription !== undefined) {
        entries["VersionDescription"] = input.VersionDescription;
    }
    return entries;
};
const serializeAws_ec2CreateLocalGatewayRouteRequest = (input, context) => {
    const entries = {};
    if (input.DestinationCidrBlock !== undefined) {
        entries["DestinationCidrBlock"] = input.DestinationCidrBlock;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.LocalGatewayRouteTableId !== undefined) {
        entries["LocalGatewayRouteTableId"] = input.LocalGatewayRouteTableId;
    }
    if (input.LocalGatewayVirtualInterfaceGroupId !== undefined) {
        entries["LocalGatewayVirtualInterfaceGroupId"] =
            input.LocalGatewayVirtualInterfaceGroupId;
    }
    return entries;
};
const serializeAws_ec2CreateLocalGatewayRouteTableVpcAssociationRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.LocalGatewayRouteTableId !== undefined) {
        entries["LocalGatewayRouteTableId"] = input.LocalGatewayRouteTableId;
    }
    if (input.VpcId !== undefined) {
        entries["VpcId"] = input.VpcId;
    }
    return entries;
};
const serializeAws_ec2CreateNatGatewayRequest = (input, context) => {
    const entries = {};
    if (input.AllocationId !== undefined) {
        entries["AllocationId"] = input.AllocationId;
    }
    if (input.ClientToken !== undefined) {
        entries["ClientToken"] = input.ClientToken;
    }
    if (input.SubnetId !== undefined) {
        entries["SubnetId"] = input.SubnetId;
    }
    return entries;
};
const serializeAws_ec2CreateNetworkAclEntryRequest = (input, context) => {
    const entries = {};
    if (input.CidrBlock !== undefined) {
        entries["CidrBlock"] = input.CidrBlock;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Egress !== undefined) {
        entries["Egress"] = input.Egress;
    }
    if (input.IcmpTypeCode !== undefined) {
        const memberEntries = serializeAws_ec2IcmpTypeCode(input.IcmpTypeCode, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Icmp.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.Ipv6CidrBlock !== undefined) {
        entries["Ipv6CidrBlock"] = input.Ipv6CidrBlock;
    }
    if (input.NetworkAclId !== undefined) {
        entries["NetworkAclId"] = input.NetworkAclId;
    }
    if (input.PortRange !== undefined) {
        const memberEntries = serializeAws_ec2PortRange(input.PortRange, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `PortRange.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.Protocol !== undefined) {
        entries["Protocol"] = input.Protocol;
    }
    if (input.RuleAction !== undefined) {
        entries["RuleAction"] = input.RuleAction;
    }
    if (input.RuleNumber !== undefined) {
        entries["RuleNumber"] = input.RuleNumber;
    }
    return entries;
};
const serializeAws_ec2CreateNetworkAclRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.VpcId !== undefined) {
        entries["VpcId"] = input.VpcId;
    }
    return entries;
};
const serializeAws_ec2CreateNetworkInterfacePermissionRequest = (input, context) => {
    const entries = {};
    if (input.AwsAccountId !== undefined) {
        entries["AwsAccountId"] = input.AwsAccountId;
    }
    if (input.AwsService !== undefined) {
        entries["AwsService"] = input.AwsService;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.NetworkInterfaceId !== undefined) {
        entries["NetworkInterfaceId"] = input.NetworkInterfaceId;
    }
    if (input.Permission !== undefined) {
        entries["Permission"] = input.Permission;
    }
    return entries;
};
const serializeAws_ec2CreateNetworkInterfaceRequest = (input, context) => {
    const entries = {};
    if (input.Description !== undefined) {
        entries["Description"] = input.Description;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Groups !== undefined) {
        const memberEntries = serializeAws_ec2SecurityGroupIdStringList(input.Groups, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `SecurityGroupId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.InterfaceType !== undefined) {
        entries["InterfaceType"] = input.InterfaceType;
    }
    if (input.Ipv6AddressCount !== undefined) {
        entries["Ipv6AddressCount"] = input.Ipv6AddressCount;
    }
    if (input.Ipv6Addresses !== undefined) {
        const memberEntries = serializeAws_ec2InstanceIpv6AddressList(input.Ipv6Addresses, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Ipv6Addresses.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.PrivateIpAddress !== undefined) {
        entries["PrivateIpAddress"] = input.PrivateIpAddress;
    }
    if (input.PrivateIpAddresses !== undefined) {
        const memberEntries = serializeAws_ec2PrivateIpAddressSpecificationList(input.PrivateIpAddresses, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `PrivateIpAddresses.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.SecondaryPrivateIpAddressCount !== undefined) {
        entries["SecondaryPrivateIpAddressCount"] =
            input.SecondaryPrivateIpAddressCount;
    }
    if (input.SubnetId !== undefined) {
        entries["SubnetId"] = input.SubnetId;
    }
    return entries;
};
const serializeAws_ec2CreatePlacementGroupRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.GroupName !== undefined) {
        entries["GroupName"] = input.GroupName;
    }
    if (input.PartitionCount !== undefined) {
        entries["PartitionCount"] = input.PartitionCount;
    }
    if (input.Strategy !== undefined) {
        entries["Strategy"] = input.Strategy;
    }
    return entries;
};
const serializeAws_ec2CreateReservedInstancesListingRequest = (input, context) => {
    const entries = {};
    if (input.ClientToken !== undefined) {
        entries["ClientToken"] = input.ClientToken;
    }
    if (input.InstanceCount !== undefined) {
        entries["InstanceCount"] = input.InstanceCount;
    }
    if (input.PriceSchedules !== undefined) {
        const memberEntries = serializeAws_ec2PriceScheduleSpecificationList(input.PriceSchedules, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `PriceSchedules.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.ReservedInstancesId !== undefined) {
        entries["ReservedInstancesId"] = input.ReservedInstancesId;
    }
    return entries;
};
const serializeAws_ec2CreateRouteRequest = (input, context) => {
    const entries = {};
    if (input.DestinationCidrBlock !== undefined) {
        entries["DestinationCidrBlock"] = input.DestinationCidrBlock;
    }
    if (input.DestinationIpv6CidrBlock !== undefined) {
        entries["DestinationIpv6CidrBlock"] = input.DestinationIpv6CidrBlock;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.EgressOnlyInternetGatewayId !== undefined) {
        entries["EgressOnlyInternetGatewayId"] = input.EgressOnlyInternetGatewayId;
    }
    if (input.GatewayId !== undefined) {
        entries["GatewayId"] = input.GatewayId;
    }
    if (input.InstanceId !== undefined) {
        entries["InstanceId"] = input.InstanceId;
    }
    if (input.LocalGatewayId !== undefined) {
        entries["LocalGatewayId"] = input.LocalGatewayId;
    }
    if (input.NatGatewayId !== undefined) {
        entries["NatGatewayId"] = input.NatGatewayId;
    }
    if (input.NetworkInterfaceId !== undefined) {
        entries["NetworkInterfaceId"] = input.NetworkInterfaceId;
    }
    if (input.RouteTableId !== undefined) {
        entries["RouteTableId"] = input.RouteTableId;
    }
    if (input.TransitGatewayId !== undefined) {
        entries["TransitGatewayId"] = input.TransitGatewayId;
    }
    if (input.VpcPeeringConnectionId !== undefined) {
        entries["VpcPeeringConnectionId"] = input.VpcPeeringConnectionId;
    }
    return entries;
};
const serializeAws_ec2CreateRouteTableRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.VpcId !== undefined) {
        entries["VpcId"] = input.VpcId;
    }
    return entries;
};
const serializeAws_ec2CreateSecurityGroupRequest = (input, context) => {
    const entries = {};
    if (input.Description !== undefined) {
        entries["GroupDescription"] = input.Description;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.GroupName !== undefined) {
        entries["GroupName"] = input.GroupName;
    }
    if (input.VpcId !== undefined) {
        entries["VpcId"] = input.VpcId;
    }
    return entries;
};
const serializeAws_ec2CreateSnapshotRequest = (input, context) => {
    const entries = {};
    if (input.Description !== undefined) {
        entries["Description"] = input.Description;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.TagSpecifications !== undefined) {
        const memberEntries = serializeAws_ec2TagSpecificationList(input.TagSpecifications, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.VolumeId !== undefined) {
        entries["VolumeId"] = input.VolumeId;
    }
    return entries;
};
const serializeAws_ec2CreateSnapshotsRequest = (input, context) => {
    const entries = {};
    if (input.CopyTagsFromSource !== undefined) {
        entries["CopyTagsFromSource"] = input.CopyTagsFromSource;
    }
    if (input.Description !== undefined) {
        entries["Description"] = input.Description;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.InstanceSpecification !== undefined) {
        const memberEntries = serializeAws_ec2InstanceSpecification(input.InstanceSpecification, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `InstanceSpecification.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.TagSpecifications !== undefined) {
        const memberEntries = serializeAws_ec2TagSpecificationList(input.TagSpecifications, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2CreateSpotDatafeedSubscriptionRequest = (input, context) => {
    const entries = {};
    if (input.Bucket !== undefined) {
        entries["Bucket"] = input.Bucket;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Prefix !== undefined) {
        entries["Prefix"] = input.Prefix;
    }
    return entries;
};
const serializeAws_ec2CreateSubnetRequest = (input, context) => {
    const entries = {};
    if (input.AvailabilityZone !== undefined) {
        entries["AvailabilityZone"] = input.AvailabilityZone;
    }
    if (input.AvailabilityZoneId !== undefined) {
        entries["AvailabilityZoneId"] = input.AvailabilityZoneId;
    }
    if (input.CidrBlock !== undefined) {
        entries["CidrBlock"] = input.CidrBlock;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Ipv6CidrBlock !== undefined) {
        entries["Ipv6CidrBlock"] = input.Ipv6CidrBlock;
    }
    if (input.OutpostArn !== undefined) {
        entries["OutpostArn"] = input.OutpostArn;
    }
    if (input.VpcId !== undefined) {
        entries["VpcId"] = input.VpcId;
    }
    return entries;
};
const serializeAws_ec2CreateTagsRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Resources !== undefined) {
        const memberEntries = serializeAws_ec2ResourceIdList(input.Resources, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `ResourceId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.Tags !== undefined) {
        const memberEntries = serializeAws_ec2TagList(input.Tags, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Tag.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2CreateTrafficMirrorFilterRequest = (input, context) => {
    const entries = {};
    if (input.ClientToken === undefined) {
        input.ClientToken = uuid_1.v4();
    }
    if (input.ClientToken !== undefined) {
        entries["ClientToken"] = input.ClientToken;
    }
    if (input.Description !== undefined) {
        entries["Description"] = input.Description;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.TagSpecifications !== undefined) {
        const memberEntries = serializeAws_ec2TagSpecificationList(input.TagSpecifications, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2CreateTrafficMirrorFilterRuleRequest = (input, context) => {
    const entries = {};
    if (input.ClientToken === undefined) {
        input.ClientToken = uuid_1.v4();
    }
    if (input.ClientToken !== undefined) {
        entries["ClientToken"] = input.ClientToken;
    }
    if (input.Description !== undefined) {
        entries["Description"] = input.Description;
    }
    if (input.DestinationCidrBlock !== undefined) {
        entries["DestinationCidrBlock"] = input.DestinationCidrBlock;
    }
    if (input.DestinationPortRange !== undefined) {
        const memberEntries = serializeAws_ec2TrafficMirrorPortRangeRequest(input.DestinationPortRange, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `DestinationPortRange.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Protocol !== undefined) {
        entries["Protocol"] = input.Protocol;
    }
    if (input.RuleAction !== undefined) {
        entries["RuleAction"] = input.RuleAction;
    }
    if (input.RuleNumber !== undefined) {
        entries["RuleNumber"] = input.RuleNumber;
    }
    if (input.SourceCidrBlock !== undefined) {
        entries["SourceCidrBlock"] = input.SourceCidrBlock;
    }
    if (input.SourcePortRange !== undefined) {
        const memberEntries = serializeAws_ec2TrafficMirrorPortRangeRequest(input.SourcePortRange, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `SourcePortRange.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.TrafficDirection !== undefined) {
        entries["TrafficDirection"] = input.TrafficDirection;
    }
    if (input.TrafficMirrorFilterId !== undefined) {
        entries["TrafficMirrorFilterId"] = input.TrafficMirrorFilterId;
    }
    return entries;
};
const serializeAws_ec2CreateTrafficMirrorSessionRequest = (input, context) => {
    const entries = {};
    if (input.ClientToken === undefined) {
        input.ClientToken = uuid_1.v4();
    }
    if (input.ClientToken !== undefined) {
        entries["ClientToken"] = input.ClientToken;
    }
    if (input.Description !== undefined) {
        entries["Description"] = input.Description;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.NetworkInterfaceId !== undefined) {
        entries["NetworkInterfaceId"] = input.NetworkInterfaceId;
    }
    if (input.PacketLength !== undefined) {
        entries["PacketLength"] = input.PacketLength;
    }
    if (input.SessionNumber !== undefined) {
        entries["SessionNumber"] = input.SessionNumber;
    }
    if (input.TagSpecifications !== undefined) {
        const memberEntries = serializeAws_ec2TagSpecificationList(input.TagSpecifications, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.TrafficMirrorFilterId !== undefined) {
        entries["TrafficMirrorFilterId"] = input.TrafficMirrorFilterId;
    }
    if (input.TrafficMirrorTargetId !== undefined) {
        entries["TrafficMirrorTargetId"] = input.TrafficMirrorTargetId;
    }
    if (input.VirtualNetworkId !== undefined) {
        entries["VirtualNetworkId"] = input.VirtualNetworkId;
    }
    return entries;
};
const serializeAws_ec2CreateTrafficMirrorTargetRequest = (input, context) => {
    const entries = {};
    if (input.ClientToken === undefined) {
        input.ClientToken = uuid_1.v4();
    }
    if (input.ClientToken !== undefined) {
        entries["ClientToken"] = input.ClientToken;
    }
    if (input.Description !== undefined) {
        entries["Description"] = input.Description;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.NetworkInterfaceId !== undefined) {
        entries["NetworkInterfaceId"] = input.NetworkInterfaceId;
    }
    if (input.NetworkLoadBalancerArn !== undefined) {
        entries["NetworkLoadBalancerArn"] = input.NetworkLoadBalancerArn;
    }
    if (input.TagSpecifications !== undefined) {
        const memberEntries = serializeAws_ec2TagSpecificationList(input.TagSpecifications, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2CreateTransitGatewayMulticastDomainRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.TagSpecifications !== undefined) {
        const memberEntries = serializeAws_ec2TagSpecificationList(input.TagSpecifications, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.TransitGatewayId !== undefined) {
        entries["TransitGatewayId"] = input.TransitGatewayId;
    }
    return entries;
};
const serializeAws_ec2CreateTransitGatewayPeeringAttachmentRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.PeerAccountId !== undefined) {
        entries["PeerAccountId"] = input.PeerAccountId;
    }
    if (input.PeerRegion !== undefined) {
        entries["PeerRegion"] = input.PeerRegion;
    }
    if (input.PeerTransitGatewayId !== undefined) {
        entries["PeerTransitGatewayId"] = input.PeerTransitGatewayId;
    }
    if (input.TagSpecifications !== undefined) {
        const memberEntries = serializeAws_ec2TagSpecificationList(input.TagSpecifications, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.TransitGatewayId !== undefined) {
        entries["TransitGatewayId"] = input.TransitGatewayId;
    }
    return entries;
};
const serializeAws_ec2CreateTransitGatewayRequest = (input, context) => {
    const entries = {};
    if (input.Description !== undefined) {
        entries["Description"] = input.Description;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Options !== undefined) {
        const memberEntries = serializeAws_ec2TransitGatewayRequestOptions(input.Options, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Options.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.TagSpecifications !== undefined) {
        const memberEntries = serializeAws_ec2TagSpecificationList(input.TagSpecifications, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2CreateTransitGatewayRouteRequest = (input, context) => {
    const entries = {};
    if (input.Blackhole !== undefined) {
        entries["Blackhole"] = input.Blackhole;
    }
    if (input.DestinationCidrBlock !== undefined) {
        entries["DestinationCidrBlock"] = input.DestinationCidrBlock;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.TransitGatewayAttachmentId !== undefined) {
        entries["TransitGatewayAttachmentId"] = input.TransitGatewayAttachmentId;
    }
    if (input.TransitGatewayRouteTableId !== undefined) {
        entries["TransitGatewayRouteTableId"] = input.TransitGatewayRouteTableId;
    }
    return entries;
};
const serializeAws_ec2CreateTransitGatewayRouteTableRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.TagSpecifications !== undefined) {
        const memberEntries = serializeAws_ec2TagSpecificationList(input.TagSpecifications, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `TagSpecifications.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.TransitGatewayId !== undefined) {
        entries["TransitGatewayId"] = input.TransitGatewayId;
    }
    return entries;
};
const serializeAws_ec2CreateTransitGatewayVpcAttachmentRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Options !== undefined) {
        const memberEntries = serializeAws_ec2CreateTransitGatewayVpcAttachmentRequestOptions(input.Options, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Options.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.SubnetIds !== undefined) {
        const memberEntries = serializeAws_ec2ValueStringList(input.SubnetIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `SubnetIds.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.TagSpecifications !== undefined) {
        const memberEntries = serializeAws_ec2TagSpecificationList(input.TagSpecifications, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `TagSpecifications.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.TransitGatewayId !== undefined) {
        entries["TransitGatewayId"] = input.TransitGatewayId;
    }
    if (input.VpcId !== undefined) {
        entries["VpcId"] = input.VpcId;
    }
    return entries;
};
const serializeAws_ec2CreateTransitGatewayVpcAttachmentRequestOptions = (input, context) => {
    const entries = {};
    if (input.DnsSupport !== undefined) {
        entries["DnsSupport"] = input.DnsSupport;
    }
    if (input.Ipv6Support !== undefined) {
        entries["Ipv6Support"] = input.Ipv6Support;
    }
    return entries;
};
const serializeAws_ec2CreateVolumePermission = (input, context) => {
    const entries = {};
    if (input.Group !== undefined) {
        entries["Group"] = input.Group;
    }
    if (input.UserId !== undefined) {
        entries["UserId"] = input.UserId;
    }
    return entries;
};
const serializeAws_ec2CreateVolumePermissionList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        const memberEntries = serializeAws_ec2CreateVolumePermission(entry, context);
        Object.keys(memberEntries).forEach(key => {
            entries[`Item.${counter}.${key}`] = memberEntries[key];
        });
        counter++;
    }
    return entries;
};
const serializeAws_ec2CreateVolumePermissionModifications = (input, context) => {
    const entries = {};
    if (input.Add !== undefined) {
        const memberEntries = serializeAws_ec2CreateVolumePermissionList(input.Add, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Add.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.Remove !== undefined) {
        const memberEntries = serializeAws_ec2CreateVolumePermissionList(input.Remove, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Remove.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2CreateVolumeRequest = (input, context) => {
    const entries = {};
    if (input.AvailabilityZone !== undefined) {
        entries["AvailabilityZone"] = input.AvailabilityZone;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Encrypted !== undefined) {
        entries["Encrypted"] = input.Encrypted;
    }
    if (input.Iops !== undefined) {
        entries["Iops"] = input.Iops;
    }
    if (input.KmsKeyId !== undefined) {
        entries["KmsKeyId"] = input.KmsKeyId;
    }
    if (input.OutpostArn !== undefined) {
        entries["OutpostArn"] = input.OutpostArn;
    }
    if (input.Size !== undefined) {
        entries["Size"] = input.Size;
    }
    if (input.SnapshotId !== undefined) {
        entries["SnapshotId"] = input.SnapshotId;
    }
    if (input.TagSpecifications !== undefined) {
        const memberEntries = serializeAws_ec2TagSpecificationList(input.TagSpecifications, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.VolumeType !== undefined) {
        entries["VolumeType"] = input.VolumeType;
    }
    return entries;
};
const serializeAws_ec2CreateVpcEndpointConnectionNotificationRequest = (input, context) => {
    const entries = {};
    if (input.ClientToken !== undefined) {
        entries["ClientToken"] = input.ClientToken;
    }
    if (input.ConnectionEvents !== undefined) {
        const memberEntries = serializeAws_ec2ValueStringList(input.ConnectionEvents, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `ConnectionEvents.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.ConnectionNotificationArn !== undefined) {
        entries["ConnectionNotificationArn"] = input.ConnectionNotificationArn;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.ServiceId !== undefined) {
        entries["ServiceId"] = input.ServiceId;
    }
    if (input.VpcEndpointId !== undefined) {
        entries["VpcEndpointId"] = input.VpcEndpointId;
    }
    return entries;
};
const serializeAws_ec2CreateVpcEndpointRequest = (input, context) => {
    const entries = {};
    if (input.ClientToken !== undefined) {
        entries["ClientToken"] = input.ClientToken;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.PolicyDocument !== undefined) {
        entries["PolicyDocument"] = input.PolicyDocument;
    }
    if (input.PrivateDnsEnabled !== undefined) {
        entries["PrivateDnsEnabled"] = input.PrivateDnsEnabled;
    }
    if (input.RouteTableIds !== undefined) {
        const memberEntries = serializeAws_ec2ValueStringList(input.RouteTableIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `RouteTableId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.SecurityGroupIds !== undefined) {
        const memberEntries = serializeAws_ec2ValueStringList(input.SecurityGroupIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `SecurityGroupId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.ServiceName !== undefined) {
        entries["ServiceName"] = input.ServiceName;
    }
    if (input.SubnetIds !== undefined) {
        const memberEntries = serializeAws_ec2ValueStringList(input.SubnetIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `SubnetId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.VpcEndpointType !== undefined) {
        entries["VpcEndpointType"] = input.VpcEndpointType;
    }
    if (input.VpcId !== undefined) {
        entries["VpcId"] = input.VpcId;
    }
    return entries;
};
const serializeAws_ec2CreateVpcEndpointServiceConfigurationRequest = (input, context) => {
    const entries = {};
    if (input.AcceptanceRequired !== undefined) {
        entries["AcceptanceRequired"] = input.AcceptanceRequired;
    }
    if (input.ClientToken !== undefined) {
        entries["ClientToken"] = input.ClientToken;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.NetworkLoadBalancerArns !== undefined) {
        const memberEntries = serializeAws_ec2ValueStringList(input.NetworkLoadBalancerArns, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `NetworkLoadBalancerArn.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.PrivateDnsName !== undefined) {
        entries["PrivateDnsName"] = input.PrivateDnsName;
    }
    return entries;
};
const serializeAws_ec2CreateVpcPeeringConnectionRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.PeerOwnerId !== undefined) {
        entries["PeerOwnerId"] = input.PeerOwnerId;
    }
    if (input.PeerRegion !== undefined) {
        entries["PeerRegion"] = input.PeerRegion;
    }
    if (input.PeerVpcId !== undefined) {
        entries["PeerVpcId"] = input.PeerVpcId;
    }
    if (input.VpcId !== undefined) {
        entries["VpcId"] = input.VpcId;
    }
    return entries;
};
const serializeAws_ec2CreateVpcRequest = (input, context) => {
    const entries = {};
    if (input.AmazonProvidedIpv6CidrBlock !== undefined) {
        entries["AmazonProvidedIpv6CidrBlock"] = input.AmazonProvidedIpv6CidrBlock;
    }
    if (input.CidrBlock !== undefined) {
        entries["CidrBlock"] = input.CidrBlock;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.InstanceTenancy !== undefined) {
        entries["InstanceTenancy"] = input.InstanceTenancy;
    }
    if (input.Ipv6CidrBlock !== undefined) {
        entries["Ipv6CidrBlock"] = input.Ipv6CidrBlock;
    }
    if (input.Ipv6CidrBlockNetworkBorderGroup !== undefined) {
        entries["Ipv6CidrBlockNetworkBorderGroup"] =
            input.Ipv6CidrBlockNetworkBorderGroup;
    }
    if (input.Ipv6Pool !== undefined) {
        entries["Ipv6Pool"] = input.Ipv6Pool;
    }
    return entries;
};
const serializeAws_ec2CreateVpnConnectionRequest = (input, context) => {
    const entries = {};
    if (input.CustomerGatewayId !== undefined) {
        entries["CustomerGatewayId"] = input.CustomerGatewayId;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Options !== undefined) {
        const memberEntries = serializeAws_ec2VpnConnectionOptionsSpecification(input.Options, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Options.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.TransitGatewayId !== undefined) {
        entries["TransitGatewayId"] = input.TransitGatewayId;
    }
    if (input.Type !== undefined) {
        entries["Type"] = input.Type;
    }
    if (input.VpnGatewayId !== undefined) {
        entries["VpnGatewayId"] = input.VpnGatewayId;
    }
    return entries;
};
const serializeAws_ec2CreateVpnConnectionRouteRequest = (input, context) => {
    const entries = {};
    if (input.DestinationCidrBlock !== undefined) {
        entries["DestinationCidrBlock"] = input.DestinationCidrBlock;
    }
    if (input.VpnConnectionId !== undefined) {
        entries["VpnConnectionId"] = input.VpnConnectionId;
    }
    return entries;
};
const serializeAws_ec2CreateVpnGatewayRequest = (input, context) => {
    const entries = {};
    if (input.AmazonSideAsn !== undefined) {
        entries["AmazonSideAsn"] = input.AmazonSideAsn;
    }
    if (input.AvailabilityZone !== undefined) {
        entries["AvailabilityZone"] = input.AvailabilityZone;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Type !== undefined) {
        entries["Type"] = input.Type;
    }
    return entries;
};
const serializeAws_ec2CreditSpecificationRequest = (input, context) => {
    const entries = {};
    if (input.CpuCredits !== undefined) {
        entries["CpuCredits"] = input.CpuCredits;
    }
    return entries;
};
const serializeAws_ec2CustomerGatewayIdStringList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        entries[`CustomerGatewayId.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const serializeAws_ec2DeleteClientVpnEndpointRequest = (input, context) => {
    const entries = {};
    if (input.ClientVpnEndpointId !== undefined) {
        entries["ClientVpnEndpointId"] = input.ClientVpnEndpointId;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    return entries;
};
const serializeAws_ec2DeleteClientVpnRouteRequest = (input, context) => {
    const entries = {};
    if (input.ClientVpnEndpointId !== undefined) {
        entries["ClientVpnEndpointId"] = input.ClientVpnEndpointId;
    }
    if (input.DestinationCidrBlock !== undefined) {
        entries["DestinationCidrBlock"] = input.DestinationCidrBlock;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.TargetVpcSubnetId !== undefined) {
        entries["TargetVpcSubnetId"] = input.TargetVpcSubnetId;
    }
    return entries;
};
const serializeAws_ec2DeleteCustomerGatewayRequest = (input, context) => {
    const entries = {};
    if (input.CustomerGatewayId !== undefined) {
        entries["CustomerGatewayId"] = input.CustomerGatewayId;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    return entries;
};
const serializeAws_ec2DeleteDhcpOptionsRequest = (input, context) => {
    const entries = {};
    if (input.DhcpOptionsId !== undefined) {
        entries["DhcpOptionsId"] = input.DhcpOptionsId;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    return entries;
};
const serializeAws_ec2DeleteEgressOnlyInternetGatewayRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.EgressOnlyInternetGatewayId !== undefined) {
        entries["EgressOnlyInternetGatewayId"] = input.EgressOnlyInternetGatewayId;
    }
    return entries;
};
const serializeAws_ec2DeleteFleetsRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.FleetIds !== undefined) {
        const memberEntries = serializeAws_ec2FleetIdSet(input.FleetIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `FleetId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.TerminateInstances !== undefined) {
        entries["TerminateInstances"] = input.TerminateInstances;
    }
    return entries;
};
const serializeAws_ec2DeleteFlowLogsRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.FlowLogIds !== undefined) {
        const memberEntries = serializeAws_ec2ValueStringList(input.FlowLogIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `FlowLogId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2DeleteFpgaImageRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.FpgaImageId !== undefined) {
        entries["FpgaImageId"] = input.FpgaImageId;
    }
    return entries;
};
const serializeAws_ec2DeleteInternetGatewayRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.InternetGatewayId !== undefined) {
        entries["InternetGatewayId"] = input.InternetGatewayId;
    }
    return entries;
};
const serializeAws_ec2DeleteKeyPairRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.KeyName !== undefined) {
        entries["KeyName"] = input.KeyName;
    }
    return entries;
};
const serializeAws_ec2DeleteLaunchTemplateRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.LaunchTemplateId !== undefined) {
        entries["LaunchTemplateId"] = input.LaunchTemplateId;
    }
    if (input.LaunchTemplateName !== undefined) {
        entries["LaunchTemplateName"] = input.LaunchTemplateName;
    }
    return entries;
};
const serializeAws_ec2DeleteLaunchTemplateVersionsRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.LaunchTemplateId !== undefined) {
        entries["LaunchTemplateId"] = input.LaunchTemplateId;
    }
    if (input.LaunchTemplateName !== undefined) {
        entries["LaunchTemplateName"] = input.LaunchTemplateName;
    }
    if (input.Versions !== undefined) {
        const memberEntries = serializeAws_ec2VersionStringList(input.Versions, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `LaunchTemplateVersion.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2DeleteLocalGatewayRouteRequest = (input, context) => {
    const entries = {};
    if (input.DestinationCidrBlock !== undefined) {
        entries["DestinationCidrBlock"] = input.DestinationCidrBlock;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.LocalGatewayRouteTableId !== undefined) {
        entries["LocalGatewayRouteTableId"] = input.LocalGatewayRouteTableId;
    }
    return entries;
};
const serializeAws_ec2DeleteLocalGatewayRouteTableVpcAssociationRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.LocalGatewayRouteTableVpcAssociationId !== undefined) {
        entries["LocalGatewayRouteTableVpcAssociationId"] =
            input.LocalGatewayRouteTableVpcAssociationId;
    }
    return entries;
};
const serializeAws_ec2DeleteNatGatewayRequest = (input, context) => {
    const entries = {};
    if (input.NatGatewayId !== undefined) {
        entries["NatGatewayId"] = input.NatGatewayId;
    }
    return entries;
};
const serializeAws_ec2DeleteNetworkAclEntryRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Egress !== undefined) {
        entries["Egress"] = input.Egress;
    }
    if (input.NetworkAclId !== undefined) {
        entries["NetworkAclId"] = input.NetworkAclId;
    }
    if (input.RuleNumber !== undefined) {
        entries["RuleNumber"] = input.RuleNumber;
    }
    return entries;
};
const serializeAws_ec2DeleteNetworkAclRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.NetworkAclId !== undefined) {
        entries["NetworkAclId"] = input.NetworkAclId;
    }
    return entries;
};
const serializeAws_ec2DeleteNetworkInterfacePermissionRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Force !== undefined) {
        entries["Force"] = input.Force;
    }
    if (input.NetworkInterfacePermissionId !== undefined) {
        entries["NetworkInterfacePermissionId"] =
            input.NetworkInterfacePermissionId;
    }
    return entries;
};
const serializeAws_ec2DeleteNetworkInterfaceRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.NetworkInterfaceId !== undefined) {
        entries["NetworkInterfaceId"] = input.NetworkInterfaceId;
    }
    return entries;
};
const serializeAws_ec2DeletePlacementGroupRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.GroupName !== undefined) {
        entries["GroupName"] = input.GroupName;
    }
    return entries;
};
const serializeAws_ec2DeleteQueuedReservedInstancesIdList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const serializeAws_ec2DeleteQueuedReservedInstancesRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.ReservedInstancesIds !== undefined) {
        const memberEntries = serializeAws_ec2DeleteQueuedReservedInstancesIdList(input.ReservedInstancesIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `ReservedInstancesId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2DeleteRouteRequest = (input, context) => {
    const entries = {};
    if (input.DestinationCidrBlock !== undefined) {
        entries["DestinationCidrBlock"] = input.DestinationCidrBlock;
    }
    if (input.DestinationIpv6CidrBlock !== undefined) {
        entries["DestinationIpv6CidrBlock"] = input.DestinationIpv6CidrBlock;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.RouteTableId !== undefined) {
        entries["RouteTableId"] = input.RouteTableId;
    }
    return entries;
};
const serializeAws_ec2DeleteRouteTableRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.RouteTableId !== undefined) {
        entries["RouteTableId"] = input.RouteTableId;
    }
    return entries;
};
const serializeAws_ec2DeleteSecurityGroupRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.GroupId !== undefined) {
        entries["GroupId"] = input.GroupId;
    }
    if (input.GroupName !== undefined) {
        entries["GroupName"] = input.GroupName;
    }
    return entries;
};
const serializeAws_ec2DeleteSnapshotRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.SnapshotId !== undefined) {
        entries["SnapshotId"] = input.SnapshotId;
    }
    return entries;
};
const serializeAws_ec2DeleteSpotDatafeedSubscriptionRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    return entries;
};
const serializeAws_ec2DeleteSubnetRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.SubnetId !== undefined) {
        entries["SubnetId"] = input.SubnetId;
    }
    return entries;
};
const serializeAws_ec2DeleteTagsRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Resources !== undefined) {
        const memberEntries = serializeAws_ec2ResourceIdList(input.Resources, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `ResourceId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.Tags !== undefined) {
        const memberEntries = serializeAws_ec2TagList(input.Tags, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Tag.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2DeleteTrafficMirrorFilterRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.TrafficMirrorFilterId !== undefined) {
        entries["TrafficMirrorFilterId"] = input.TrafficMirrorFilterId;
    }
    return entries;
};
const serializeAws_ec2DeleteTrafficMirrorFilterRuleRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.TrafficMirrorFilterRuleId !== undefined) {
        entries["TrafficMirrorFilterRuleId"] = input.TrafficMirrorFilterRuleId;
    }
    return entries;
};
const serializeAws_ec2DeleteTrafficMirrorSessionRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.TrafficMirrorSessionId !== undefined) {
        entries["TrafficMirrorSessionId"] = input.TrafficMirrorSessionId;
    }
    return entries;
};
const serializeAws_ec2DeleteTrafficMirrorTargetRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.TrafficMirrorTargetId !== undefined) {
        entries["TrafficMirrorTargetId"] = input.TrafficMirrorTargetId;
    }
    return entries;
};
const serializeAws_ec2DeleteTransitGatewayMulticastDomainRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.TransitGatewayMulticastDomainId !== undefined) {
        entries["TransitGatewayMulticastDomainId"] =
            input.TransitGatewayMulticastDomainId;
    }
    return entries;
};
const serializeAws_ec2DeleteTransitGatewayPeeringAttachmentRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.TransitGatewayAttachmentId !== undefined) {
        entries["TransitGatewayAttachmentId"] = input.TransitGatewayAttachmentId;
    }
    return entries;
};
const serializeAws_ec2DeleteTransitGatewayRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.TransitGatewayId !== undefined) {
        entries["TransitGatewayId"] = input.TransitGatewayId;
    }
    return entries;
};
const serializeAws_ec2DeleteTransitGatewayRouteRequest = (input, context) => {
    const entries = {};
    if (input.DestinationCidrBlock !== undefined) {
        entries["DestinationCidrBlock"] = input.DestinationCidrBlock;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.TransitGatewayRouteTableId !== undefined) {
        entries["TransitGatewayRouteTableId"] = input.TransitGatewayRouteTableId;
    }
    return entries;
};
const serializeAws_ec2DeleteTransitGatewayRouteTableRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.TransitGatewayRouteTableId !== undefined) {
        entries["TransitGatewayRouteTableId"] = input.TransitGatewayRouteTableId;
    }
    return entries;
};
const serializeAws_ec2DeleteTransitGatewayVpcAttachmentRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.TransitGatewayAttachmentId !== undefined) {
        entries["TransitGatewayAttachmentId"] = input.TransitGatewayAttachmentId;
    }
    return entries;
};
const serializeAws_ec2DeleteVolumeRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.VolumeId !== undefined) {
        entries["VolumeId"] = input.VolumeId;
    }
    return entries;
};
const serializeAws_ec2DeleteVpcEndpointConnectionNotificationsRequest = (input, context) => {
    const entries = {};
    if (input.ConnectionNotificationIds !== undefined) {
        const memberEntries = serializeAws_ec2ValueStringList(input.ConnectionNotificationIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `ConnectionNotificationId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    return entries;
};
const serializeAws_ec2DeleteVpcEndpointServiceConfigurationsRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.ServiceIds !== undefined) {
        const memberEntries = serializeAws_ec2ValueStringList(input.ServiceIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `ServiceId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2DeleteVpcEndpointsRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.VpcEndpointIds !== undefined) {
        const memberEntries = serializeAws_ec2ValueStringList(input.VpcEndpointIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `VpcEndpointId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2DeleteVpcPeeringConnectionRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.VpcPeeringConnectionId !== undefined) {
        entries["VpcPeeringConnectionId"] = input.VpcPeeringConnectionId;
    }
    return entries;
};
const serializeAws_ec2DeleteVpcRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.VpcId !== undefined) {
        entries["VpcId"] = input.VpcId;
    }
    return entries;
};
const serializeAws_ec2DeleteVpnConnectionRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.VpnConnectionId !== undefined) {
        entries["VpnConnectionId"] = input.VpnConnectionId;
    }
    return entries;
};
const serializeAws_ec2DeleteVpnConnectionRouteRequest = (input, context) => {
    const entries = {};
    if (input.DestinationCidrBlock !== undefined) {
        entries["DestinationCidrBlock"] = input.DestinationCidrBlock;
    }
    if (input.VpnConnectionId !== undefined) {
        entries["VpnConnectionId"] = input.VpnConnectionId;
    }
    return entries;
};
const serializeAws_ec2DeleteVpnGatewayRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.VpnGatewayId !== undefined) {
        entries["VpnGatewayId"] = input.VpnGatewayId;
    }
    return entries;
};
const serializeAws_ec2DeprovisionByoipCidrRequest = (input, context) => {
    const entries = {};
    if (input.Cidr !== undefined) {
        entries["Cidr"] = input.Cidr;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    return entries;
};
const serializeAws_ec2DeregisterImageRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.ImageId !== undefined) {
        entries["ImageId"] = input.ImageId;
    }
    return entries;
};
const serializeAws_ec2DeregisterTransitGatewayMulticastGroupMembersRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.GroupIpAddress !== undefined) {
        entries["GroupIpAddress"] = input.GroupIpAddress;
    }
    if (input.NetworkInterfaceIds !== undefined) {
        const memberEntries = serializeAws_ec2ValueStringList(input.NetworkInterfaceIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `NetworkInterfaceIds.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.TransitGatewayMulticastDomainId !== undefined) {
        entries["TransitGatewayMulticastDomainId"] =
            input.TransitGatewayMulticastDomainId;
    }
    return entries;
};
const serializeAws_ec2DeregisterTransitGatewayMulticastGroupSourcesRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.GroupIpAddress !== undefined) {
        entries["GroupIpAddress"] = input.GroupIpAddress;
    }
    if (input.NetworkInterfaceIds !== undefined) {
        const memberEntries = serializeAws_ec2ValueStringList(input.NetworkInterfaceIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `NetworkInterfaceIds.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.TransitGatewayMulticastDomainId !== undefined) {
        entries["TransitGatewayMulticastDomainId"] =
            input.TransitGatewayMulticastDomainId;
    }
    return entries;
};
const serializeAws_ec2DescribeAccountAttributesRequest = (input, context) => {
    const entries = {};
    if (input.AttributeNames !== undefined) {
        const memberEntries = serializeAws_ec2AccountAttributeNameStringList(input.AttributeNames, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `AttributeName.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    return entries;
};
const serializeAws_ec2DescribeAddressesRequest = (input, context) => {
    const entries = {};
    if (input.AllocationIds !== undefined) {
        const memberEntries = serializeAws_ec2AllocationIdList(input.AllocationIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `AllocationId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Filters !== undefined) {
        const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.PublicIps !== undefined) {
        const memberEntries = serializeAws_ec2PublicIpStringList(input.PublicIps, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `PublicIp.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2DescribeAggregateIdFormatRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    return entries;
};
const serializeAws_ec2DescribeAvailabilityZonesRequest = (input, context) => {
    const entries = {};
    if (input.AllAvailabilityZones !== undefined) {
        entries["AllAvailabilityZones"] = input.AllAvailabilityZones;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Filters !== undefined) {
        const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.ZoneIds !== undefined) {
        const memberEntries = serializeAws_ec2ZoneIdStringList(input.ZoneIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `ZoneId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.ZoneNames !== undefined) {
        const memberEntries = serializeAws_ec2ZoneNameStringList(input.ZoneNames, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `ZoneName.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2DescribeBundleTasksRequest = (input, context) => {
    const entries = {};
    if (input.BundleIds !== undefined) {
        const memberEntries = serializeAws_ec2BundleIdStringList(input.BundleIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `BundleId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Filters !== undefined) {
        const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2DescribeByoipCidrsRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.MaxResults !== undefined) {
        entries["MaxResults"] = input.MaxResults;
    }
    if (input.NextToken !== undefined) {
        entries["NextToken"] = input.NextToken;
    }
    return entries;
};
const serializeAws_ec2DescribeCapacityReservationsRequest = (input, context) => {
    const entries = {};
    if (input.CapacityReservationIds !== undefined) {
        const memberEntries = serializeAws_ec2CapacityReservationIdSet(input.CapacityReservationIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `CapacityReservationId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Filters !== undefined) {
        const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.MaxResults !== undefined) {
        entries["MaxResults"] = input.MaxResults;
    }
    if (input.NextToken !== undefined) {
        entries["NextToken"] = input.NextToken;
    }
    return entries;
};
const serializeAws_ec2DescribeClassicLinkInstancesRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Filters !== undefined) {
        const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.InstanceIds !== undefined) {
        const memberEntries = serializeAws_ec2InstanceIdStringList(input.InstanceIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `InstanceId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.MaxResults !== undefined) {
        entries["MaxResults"] = input.MaxResults;
    }
    if (input.NextToken !== undefined) {
        entries["NextToken"] = input.NextToken;
    }
    return entries;
};
const serializeAws_ec2DescribeClientVpnAuthorizationRulesRequest = (input, context) => {
    const entries = {};
    if (input.ClientVpnEndpointId !== undefined) {
        entries["ClientVpnEndpointId"] = input.ClientVpnEndpointId;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Filters !== undefined) {
        const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.MaxResults !== undefined) {
        entries["MaxResults"] = input.MaxResults;
    }
    if (input.NextToken !== undefined) {
        entries["NextToken"] = input.NextToken;
    }
    return entries;
};
const serializeAws_ec2DescribeClientVpnConnectionsRequest = (input, context) => {
    const entries = {};
    if (input.ClientVpnEndpointId !== undefined) {
        entries["ClientVpnEndpointId"] = input.ClientVpnEndpointId;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Filters !== undefined) {
        const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.MaxResults !== undefined) {
        entries["MaxResults"] = input.MaxResults;
    }
    if (input.NextToken !== undefined) {
        entries["NextToken"] = input.NextToken;
    }
    return entries;
};
const serializeAws_ec2DescribeClientVpnEndpointsRequest = (input, context) => {
    const entries = {};
    if (input.ClientVpnEndpointIds !== undefined) {
        const memberEntries = serializeAws_ec2ValueStringList(input.ClientVpnEndpointIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `ClientVpnEndpointId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Filters !== undefined) {
        const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.MaxResults !== undefined) {
        entries["MaxResults"] = input.MaxResults;
    }
    if (input.NextToken !== undefined) {
        entries["NextToken"] = input.NextToken;
    }
    return entries;
};
const serializeAws_ec2DescribeClientVpnRoutesRequest = (input, context) => {
    const entries = {};
    if (input.ClientVpnEndpointId !== undefined) {
        entries["ClientVpnEndpointId"] = input.ClientVpnEndpointId;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Filters !== undefined) {
        const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.MaxResults !== undefined) {
        entries["MaxResults"] = input.MaxResults;
    }
    if (input.NextToken !== undefined) {
        entries["NextToken"] = input.NextToken;
    }
    return entries;
};
const serializeAws_ec2DescribeClientVpnTargetNetworksRequest = (input, context) => {
    const entries = {};
    if (input.AssociationIds !== undefined) {
        const memberEntries = serializeAws_ec2ValueStringList(input.AssociationIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `AssociationIds.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.ClientVpnEndpointId !== undefined) {
        entries["ClientVpnEndpointId"] = input.ClientVpnEndpointId;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Filters !== undefined) {
        const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.MaxResults !== undefined) {
        entries["MaxResults"] = input.MaxResults;
    }
    if (input.NextToken !== undefined) {
        entries["NextToken"] = input.NextToken;
    }
    return entries;
};
const serializeAws_ec2DescribeCoipPoolsRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Filters !== undefined) {
        const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.MaxResults !== undefined) {
        entries["MaxResults"] = input.MaxResults;
    }
    if (input.NextToken !== undefined) {
        entries["NextToken"] = input.NextToken;
    }
    if (input.PoolIds !== undefined) {
        const memberEntries = serializeAws_ec2CoipPoolIdSet(input.PoolIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `PoolId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2DescribeConversionTasksRequest = (input, context) => {
    const entries = {};
    if (input.ConversionTaskIds !== undefined) {
        const memberEntries = serializeAws_ec2ConversionIdStringList(input.ConversionTaskIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `ConversionTaskId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    return entries;
};
const serializeAws_ec2DescribeCustomerGatewaysRequest = (input, context) => {
    const entries = {};
    if (input.CustomerGatewayIds !== undefined) {
        const memberEntries = serializeAws_ec2CustomerGatewayIdStringList(input.CustomerGatewayIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `CustomerGatewayId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Filters !== undefined) {
        const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2DescribeDhcpOptionsRequest = (input, context) => {
    const entries = {};
    if (input.DhcpOptionsIds !== undefined) {
        const memberEntries = serializeAws_ec2DhcpOptionsIdStringList(input.DhcpOptionsIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `DhcpOptionsId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Filters !== undefined) {
        const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.MaxResults !== undefined) {
        entries["MaxResults"] = input.MaxResults;
    }
    if (input.NextToken !== undefined) {
        entries["NextToken"] = input.NextToken;
    }
    return entries;
};
const serializeAws_ec2DescribeEgressOnlyInternetGatewaysRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.EgressOnlyInternetGatewayIds !== undefined) {
        const memberEntries = serializeAws_ec2EgressOnlyInternetGatewayIdList(input.EgressOnlyInternetGatewayIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `EgressOnlyInternetGatewayId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.Filters !== undefined) {
        const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.MaxResults !== undefined) {
        entries["MaxResults"] = input.MaxResults;
    }
    if (input.NextToken !== undefined) {
        entries["NextToken"] = input.NextToken;
    }
    return entries;
};
const serializeAws_ec2DescribeElasticGpusRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.ElasticGpuIds !== undefined) {
        const memberEntries = serializeAws_ec2ElasticGpuIdSet(input.ElasticGpuIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `ElasticGpuId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.Filters !== undefined) {
        const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.MaxResults !== undefined) {
        entries["MaxResults"] = input.MaxResults;
    }
    if (input.NextToken !== undefined) {
        entries["NextToken"] = input.NextToken;
    }
    return entries;
};
const serializeAws_ec2DescribeExportImageTasksRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.ExportImageTaskIds !== undefined) {
        const memberEntries = serializeAws_ec2ExportImageTaskIdList(input.ExportImageTaskIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `ExportImageTaskId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.Filters !== undefined) {
        const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.MaxResults !== undefined) {
        entries["MaxResults"] = input.MaxResults;
    }
    if (input.NextToken !== undefined) {
        entries["NextToken"] = input.NextToken;
    }
    return entries;
};
const serializeAws_ec2DescribeExportTasksRequest = (input, context) => {
    const entries = {};
    if (input.ExportTaskIds !== undefined) {
        const memberEntries = serializeAws_ec2ExportTaskIdStringList(input.ExportTaskIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `ExportTaskId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.Filters !== undefined) {
        const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2DescribeFastSnapshotRestoresRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Filters !== undefined) {
        const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.MaxResults !== undefined) {
        entries["MaxResults"] = input.MaxResults;
    }
    if (input.NextToken !== undefined) {
        entries["NextToken"] = input.NextToken;
    }
    return entries;
};
const serializeAws_ec2DescribeFleetHistoryRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.EventType !== undefined) {
        entries["EventType"] = input.EventType;
    }
    if (input.FleetId !== undefined) {
        entries["FleetId"] = input.FleetId;
    }
    if (input.MaxResults !== undefined) {
        entries["MaxResults"] = input.MaxResults;
    }
    if (input.NextToken !== undefined) {
        entries["NextToken"] = input.NextToken;
    }
    if (input.StartTime !== undefined) {
        entries["StartTime"] = input.StartTime.toISOString().split(".")[0] + "Z";
    }
    return entries;
};
const serializeAws_ec2DescribeFleetInstancesRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Filters !== undefined) {
        const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.FleetId !== undefined) {
        entries["FleetId"] = input.FleetId;
    }
    if (input.MaxResults !== undefined) {
        entries["MaxResults"] = input.MaxResults;
    }
    if (input.NextToken !== undefined) {
        entries["NextToken"] = input.NextToken;
    }
    return entries;
};
const serializeAws_ec2DescribeFleetsRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Filters !== undefined) {
        const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.FleetIds !== undefined) {
        const memberEntries = serializeAws_ec2FleetIdSet(input.FleetIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `FleetId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.MaxResults !== undefined) {
        entries["MaxResults"] = input.MaxResults;
    }
    if (input.NextToken !== undefined) {
        entries["NextToken"] = input.NextToken;
    }
    return entries;
};
const serializeAws_ec2DescribeFlowLogsRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Filter !== undefined) {
        const memberEntries = serializeAws_ec2FilterList(input.Filter, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.FlowLogIds !== undefined) {
        const memberEntries = serializeAws_ec2ValueStringList(input.FlowLogIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `FlowLogId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.MaxResults !== undefined) {
        entries["MaxResults"] = input.MaxResults;
    }
    if (input.NextToken !== undefined) {
        entries["NextToken"] = input.NextToken;
    }
    return entries;
};
const serializeAws_ec2DescribeFpgaImageAttributeRequest = (input, context) => {
    const entries = {};
    if (input.Attribute !== undefined) {
        entries["Attribute"] = input.Attribute;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.FpgaImageId !== undefined) {
        entries["FpgaImageId"] = input.FpgaImageId;
    }
    return entries;
};
const serializeAws_ec2DescribeFpgaImagesRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Filters !== undefined) {
        const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.FpgaImageIds !== undefined) {
        const memberEntries = serializeAws_ec2FpgaImageIdList(input.FpgaImageIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `FpgaImageId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.MaxResults !== undefined) {
        entries["MaxResults"] = input.MaxResults;
    }
    if (input.NextToken !== undefined) {
        entries["NextToken"] = input.NextToken;
    }
    if (input.Owners !== undefined) {
        const memberEntries = serializeAws_ec2OwnerStringList(input.Owners, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Owner.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2DescribeHostReservationOfferingsRequest = (input, context) => {
    const entries = {};
    if (input.Filter !== undefined) {
        const memberEntries = serializeAws_ec2FilterList(input.Filter, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.MaxDuration !== undefined) {
        entries["MaxDuration"] = input.MaxDuration;
    }
    if (input.MaxResults !== undefined) {
        entries["MaxResults"] = input.MaxResults;
    }
    if (input.MinDuration !== undefined) {
        entries["MinDuration"] = input.MinDuration;
    }
    if (input.NextToken !== undefined) {
        entries["NextToken"] = input.NextToken;
    }
    if (input.OfferingId !== undefined) {
        entries["OfferingId"] = input.OfferingId;
    }
    return entries;
};
const serializeAws_ec2DescribeHostReservationsRequest = (input, context) => {
    const entries = {};
    if (input.Filter !== undefined) {
        const memberEntries = serializeAws_ec2FilterList(input.Filter, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.HostReservationIdSet !== undefined) {
        const memberEntries = serializeAws_ec2HostReservationIdSet(input.HostReservationIdSet, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `HostReservationIdSet.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.MaxResults !== undefined) {
        entries["MaxResults"] = input.MaxResults;
    }
    if (input.NextToken !== undefined) {
        entries["NextToken"] = input.NextToken;
    }
    return entries;
};
const serializeAws_ec2DescribeHostsRequest = (input, context) => {
    const entries = {};
    if (input.Filter !== undefined) {
        const memberEntries = serializeAws_ec2FilterList(input.Filter, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.HostIds !== undefined) {
        const memberEntries = serializeAws_ec2RequestHostIdList(input.HostIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `HostId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.MaxResults !== undefined) {
        entries["MaxResults"] = input.MaxResults;
    }
    if (input.NextToken !== undefined) {
        entries["NextToken"] = input.NextToken;
    }
    return entries;
};
const serializeAws_ec2DescribeIamInstanceProfileAssociationsRequest = (input, context) => {
    const entries = {};
    if (input.AssociationIds !== undefined) {
        const memberEntries = serializeAws_ec2AssociationIdList(input.AssociationIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `AssociationId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.Filters !== undefined) {
        const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.MaxResults !== undefined) {
        entries["MaxResults"] = input.MaxResults;
    }
    if (input.NextToken !== undefined) {
        entries["NextToken"] = input.NextToken;
    }
    return entries;
};
const serializeAws_ec2DescribeIdFormatRequest = (input, context) => {
    const entries = {};
    if (input.Resource !== undefined) {
        entries["Resource"] = input.Resource;
    }
    return entries;
};
const serializeAws_ec2DescribeIdentityIdFormatRequest = (input, context) => {
    const entries = {};
    if (input.PrincipalArn !== undefined) {
        entries["PrincipalArn"] = input.PrincipalArn;
    }
    if (input.Resource !== undefined) {
        entries["Resource"] = input.Resource;
    }
    return entries;
};
const serializeAws_ec2DescribeImageAttributeRequest = (input, context) => {
    const entries = {};
    if (input.Attribute !== undefined) {
        entries["Attribute"] = input.Attribute;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.ImageId !== undefined) {
        entries["ImageId"] = input.ImageId;
    }
    return entries;
};
const serializeAws_ec2DescribeImagesRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.ExecutableUsers !== undefined) {
        const memberEntries = serializeAws_ec2ExecutableByStringList(input.ExecutableUsers, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `ExecutableBy.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.Filters !== undefined) {
        const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.ImageIds !== undefined) {
        const memberEntries = serializeAws_ec2ImageIdStringList(input.ImageIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `ImageId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.Owners !== undefined) {
        const memberEntries = serializeAws_ec2OwnerStringList(input.Owners, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Owner.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2DescribeImportImageTasksRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Filters !== undefined) {
        const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Filters.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.ImportTaskIds !== undefined) {
        const memberEntries = serializeAws_ec2ImportTaskIdList(input.ImportTaskIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `ImportTaskId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.MaxResults !== undefined) {
        entries["MaxResults"] = input.MaxResults;
    }
    if (input.NextToken !== undefined) {
        entries["NextToken"] = input.NextToken;
    }
    return entries;
};
const serializeAws_ec2DescribeImportSnapshotTasksRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Filters !== undefined) {
        const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Filters.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.ImportTaskIds !== undefined) {
        const memberEntries = serializeAws_ec2ImportTaskIdList(input.ImportTaskIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `ImportTaskId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.MaxResults !== undefined) {
        entries["MaxResults"] = input.MaxResults;
    }
    if (input.NextToken !== undefined) {
        entries["NextToken"] = input.NextToken;
    }
    return entries;
};
const serializeAws_ec2DescribeInstanceAttributeRequest = (input, context) => {
    const entries = {};
    if (input.Attribute !== undefined) {
        entries["Attribute"] = input.Attribute;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.InstanceId !== undefined) {
        entries["InstanceId"] = input.InstanceId;
    }
    return entries;
};
const serializeAws_ec2DescribeInstanceCreditSpecificationsRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Filters !== undefined) {
        const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.InstanceIds !== undefined) {
        const memberEntries = serializeAws_ec2InstanceIdStringList(input.InstanceIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `InstanceId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.MaxResults !== undefined) {
        entries["MaxResults"] = input.MaxResults;
    }
    if (input.NextToken !== undefined) {
        entries["NextToken"] = input.NextToken;
    }
    return entries;
};
const serializeAws_ec2DescribeInstanceStatusRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Filters !== undefined) {
        const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.IncludeAllInstances !== undefined) {
        entries["IncludeAllInstances"] = input.IncludeAllInstances;
    }
    if (input.InstanceIds !== undefined) {
        const memberEntries = serializeAws_ec2InstanceIdStringList(input.InstanceIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `InstanceId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.MaxResults !== undefined) {
        entries["MaxResults"] = input.MaxResults;
    }
    if (input.NextToken !== undefined) {
        entries["NextToken"] = input.NextToken;
    }
    return entries;
};
const serializeAws_ec2DescribeInstanceTypeOfferingsRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Filters !== undefined) {
        const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.LocationType !== undefined) {
        entries["LocationType"] = input.LocationType;
    }
    if (input.MaxResults !== undefined) {
        entries["MaxResults"] = input.MaxResults;
    }
    if (input.NextToken !== undefined) {
        entries["NextToken"] = input.NextToken;
    }
    return entries;
};
const serializeAws_ec2DescribeInstanceTypesRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Filters !== undefined) {
        const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.InstanceTypes !== undefined) {
        const memberEntries = serializeAws_ec2RequestInstanceTypeList(input.InstanceTypes, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `InstanceType.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.MaxResults !== undefined) {
        entries["MaxResults"] = input.MaxResults;
    }
    if (input.NextToken !== undefined) {
        entries["NextToken"] = input.NextToken;
    }
    return entries;
};
const serializeAws_ec2DescribeInstancesRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Filters !== undefined) {
        const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.InstanceIds !== undefined) {
        const memberEntries = serializeAws_ec2InstanceIdStringList(input.InstanceIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `InstanceId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.MaxResults !== undefined) {
        entries["MaxResults"] = input.MaxResults;
    }
    if (input.NextToken !== undefined) {
        entries["NextToken"] = input.NextToken;
    }
    return entries;
};
const serializeAws_ec2DescribeInternetGatewaysRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Filters !== undefined) {
        const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.InternetGatewayIds !== undefined) {
        const memberEntries = serializeAws_ec2ValueStringList(input.InternetGatewayIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `InternetGatewayId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.MaxResults !== undefined) {
        entries["MaxResults"] = input.MaxResults;
    }
    if (input.NextToken !== undefined) {
        entries["NextToken"] = input.NextToken;
    }
    return entries;
};
const serializeAws_ec2DescribeIpv6PoolsRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Filters !== undefined) {
        const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.MaxResults !== undefined) {
        entries["MaxResults"] = input.MaxResults;
    }
    if (input.NextToken !== undefined) {
        entries["NextToken"] = input.NextToken;
    }
    if (input.PoolIds !== undefined) {
        const memberEntries = serializeAws_ec2ValueStringList(input.PoolIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `PoolId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2DescribeKeyPairsRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Filters !== undefined) {
        const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.KeyNames !== undefined) {
        const memberEntries = serializeAws_ec2KeyNameStringList(input.KeyNames, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `KeyName.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.KeyPairIds !== undefined) {
        const memberEntries = serializeAws_ec2KeyPairIdStringList(input.KeyPairIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `KeyPairId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2DescribeLaunchTemplateVersionsRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Filters !== undefined) {
        const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.LaunchTemplateId !== undefined) {
        entries["LaunchTemplateId"] = input.LaunchTemplateId;
    }
    if (input.LaunchTemplateName !== undefined) {
        entries["LaunchTemplateName"] = input.LaunchTemplateName;
    }
    if (input.MaxResults !== undefined) {
        entries["MaxResults"] = input.MaxResults;
    }
    if (input.MaxVersion !== undefined) {
        entries["MaxVersion"] = input.MaxVersion;
    }
    if (input.MinVersion !== undefined) {
        entries["MinVersion"] = input.MinVersion;
    }
    if (input.NextToken !== undefined) {
        entries["NextToken"] = input.NextToken;
    }
    if (input.Versions !== undefined) {
        const memberEntries = serializeAws_ec2VersionStringList(input.Versions, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `LaunchTemplateVersion.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2DescribeLaunchTemplatesRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Filters !== undefined) {
        const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.LaunchTemplateIds !== undefined) {
        const memberEntries = serializeAws_ec2ValueStringList(input.LaunchTemplateIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `LaunchTemplateId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.LaunchTemplateNames !== undefined) {
        const memberEntries = serializeAws_ec2LaunchTemplateNameStringList(input.LaunchTemplateNames, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `LaunchTemplateName.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.MaxResults !== undefined) {
        entries["MaxResults"] = input.MaxResults;
    }
    if (input.NextToken !== undefined) {
        entries["NextToken"] = input.NextToken;
    }
    return entries;
};
const serializeAws_ec2DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Filters !== undefined) {
        const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.LocalGatewayRouteTableVirtualInterfaceGroupAssociationIds !==
        undefined) {
        const memberEntries = serializeAws_ec2LocalGatewayRouteTableVirtualInterfaceGroupAssociationIdSet(input.LocalGatewayRouteTableVirtualInterfaceGroupAssociationIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `LocalGatewayRouteTableVirtualInterfaceGroupAssociationId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.MaxResults !== undefined) {
        entries["MaxResults"] = input.MaxResults;
    }
    if (input.NextToken !== undefined) {
        entries["NextToken"] = input.NextToken;
    }
    return entries;
};
const serializeAws_ec2DescribeLocalGatewayRouteTableVpcAssociationsRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Filters !== undefined) {
        const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.LocalGatewayRouteTableVpcAssociationIds !== undefined) {
        const memberEntries = serializeAws_ec2LocalGatewayRouteTableVpcAssociationIdSet(input.LocalGatewayRouteTableVpcAssociationIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `LocalGatewayRouteTableVpcAssociationId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.MaxResults !== undefined) {
        entries["MaxResults"] = input.MaxResults;
    }
    if (input.NextToken !== undefined) {
        entries["NextToken"] = input.NextToken;
    }
    return entries;
};
const serializeAws_ec2DescribeLocalGatewayRouteTablesRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Filters !== undefined) {
        const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.LocalGatewayRouteTableIds !== undefined) {
        const memberEntries = serializeAws_ec2LocalGatewayRouteTableIdSet(input.LocalGatewayRouteTableIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `LocalGatewayRouteTableId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.MaxResults !== undefined) {
        entries["MaxResults"] = input.MaxResults;
    }
    if (input.NextToken !== undefined) {
        entries["NextToken"] = input.NextToken;
    }
    return entries;
};
const serializeAws_ec2DescribeLocalGatewayVirtualInterfaceGroupsRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Filters !== undefined) {
        const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.LocalGatewayVirtualInterfaceGroupIds !== undefined) {
        const memberEntries = serializeAws_ec2LocalGatewayVirtualInterfaceGroupIdSet(input.LocalGatewayVirtualInterfaceGroupIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `LocalGatewayVirtualInterfaceGroupId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.MaxResults !== undefined) {
        entries["MaxResults"] = input.MaxResults;
    }
    if (input.NextToken !== undefined) {
        entries["NextToken"] = input.NextToken;
    }
    return entries;
};
const serializeAws_ec2DescribeLocalGatewayVirtualInterfacesRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Filters !== undefined) {
        const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.LocalGatewayVirtualInterfaceIds !== undefined) {
        const memberEntries = serializeAws_ec2LocalGatewayVirtualInterfaceIdSet(input.LocalGatewayVirtualInterfaceIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `LocalGatewayVirtualInterfaceId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.MaxResults !== undefined) {
        entries["MaxResults"] = input.MaxResults;
    }
    if (input.NextToken !== undefined) {
        entries["NextToken"] = input.NextToken;
    }
    return entries;
};
const serializeAws_ec2DescribeLocalGatewaysRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Filters !== undefined) {
        const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.LocalGatewayIds !== undefined) {
        const memberEntries = serializeAws_ec2LocalGatewayIdSet(input.LocalGatewayIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `LocalGatewayId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.MaxResults !== undefined) {
        entries["MaxResults"] = input.MaxResults;
    }
    if (input.NextToken !== undefined) {
        entries["NextToken"] = input.NextToken;
    }
    return entries;
};
const serializeAws_ec2DescribeMovingAddressesRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Filters !== undefined) {
        const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.MaxResults !== undefined) {
        entries["MaxResults"] = input.MaxResults;
    }
    if (input.NextToken !== undefined) {
        entries["NextToken"] = input.NextToken;
    }
    if (input.PublicIps !== undefined) {
        const memberEntries = serializeAws_ec2ValueStringList(input.PublicIps, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `PublicIp.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2DescribeNatGatewaysRequest = (input, context) => {
    const entries = {};
    if (input.Filter !== undefined) {
        const memberEntries = serializeAws_ec2FilterList(input.Filter, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.MaxResults !== undefined) {
        entries["MaxResults"] = input.MaxResults;
    }
    if (input.NatGatewayIds !== undefined) {
        const memberEntries = serializeAws_ec2ValueStringList(input.NatGatewayIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `NatGatewayId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.NextToken !== undefined) {
        entries["NextToken"] = input.NextToken;
    }
    return entries;
};
const serializeAws_ec2DescribeNetworkAclsRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Filters !== undefined) {
        const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.MaxResults !== undefined) {
        entries["MaxResults"] = input.MaxResults;
    }
    if (input.NetworkAclIds !== undefined) {
        const memberEntries = serializeAws_ec2ValueStringList(input.NetworkAclIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `NetworkAclId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.NextToken !== undefined) {
        entries["NextToken"] = input.NextToken;
    }
    return entries;
};
const serializeAws_ec2DescribeNetworkInterfaceAttributeRequest = (input, context) => {
    const entries = {};
    if (input.Attribute !== undefined) {
        entries["Attribute"] = input.Attribute;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.NetworkInterfaceId !== undefined) {
        entries["NetworkInterfaceId"] = input.NetworkInterfaceId;
    }
    return entries;
};
const serializeAws_ec2DescribeNetworkInterfacePermissionsRequest = (input, context) => {
    const entries = {};
    if (input.Filters !== undefined) {
        const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.MaxResults !== undefined) {
        entries["MaxResults"] = input.MaxResults;
    }
    if (input.NetworkInterfacePermissionIds !== undefined) {
        const memberEntries = serializeAws_ec2NetworkInterfacePermissionIdList(input.NetworkInterfacePermissionIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `NetworkInterfacePermissionId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.NextToken !== undefined) {
        entries["NextToken"] = input.NextToken;
    }
    return entries;
};
const serializeAws_ec2DescribeNetworkInterfacesRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Filters !== undefined) {
        const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.MaxResults !== undefined) {
        entries["MaxResults"] = input.MaxResults;
    }
    if (input.NetworkInterfaceIds !== undefined) {
        const memberEntries = serializeAws_ec2NetworkInterfaceIdList(input.NetworkInterfaceIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `NetworkInterfaceId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.NextToken !== undefined) {
        entries["NextToken"] = input.NextToken;
    }
    return entries;
};
const serializeAws_ec2DescribePlacementGroupsRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Filters !== undefined) {
        const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.GroupIds !== undefined) {
        const memberEntries = serializeAws_ec2PlacementGroupIdStringList(input.GroupIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `GroupId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.GroupNames !== undefined) {
        const memberEntries = serializeAws_ec2PlacementGroupStringList(input.GroupNames, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `GroupName.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2DescribePrefixListsRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Filters !== undefined) {
        const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.MaxResults !== undefined) {
        entries["MaxResults"] = input.MaxResults;
    }
    if (input.NextToken !== undefined) {
        entries["NextToken"] = input.NextToken;
    }
    if (input.PrefixListIds !== undefined) {
        const memberEntries = serializeAws_ec2ValueStringList(input.PrefixListIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `PrefixListId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2DescribePrincipalIdFormatRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.MaxResults !== undefined) {
        entries["MaxResults"] = input.MaxResults;
    }
    if (input.NextToken !== undefined) {
        entries["NextToken"] = input.NextToken;
    }
    if (input.Resources !== undefined) {
        const memberEntries = serializeAws_ec2ResourceList(input.Resources, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Resource.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2DescribePublicIpv4PoolsRequest = (input, context) => {
    const entries = {};
    if (input.MaxResults !== undefined) {
        entries["MaxResults"] = input.MaxResults;
    }
    if (input.NextToken !== undefined) {
        entries["NextToken"] = input.NextToken;
    }
    if (input.PoolIds !== undefined) {
        const memberEntries = serializeAws_ec2ValueStringList(input.PoolIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `PoolId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2DescribeRegionsRequest = (input, context) => {
    const entries = {};
    if (input.AllRegions !== undefined) {
        entries["AllRegions"] = input.AllRegions;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Filters !== undefined) {
        const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.RegionNames !== undefined) {
        const memberEntries = serializeAws_ec2RegionNameStringList(input.RegionNames, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `RegionName.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2DescribeReservedInstancesListingsRequest = (input, context) => {
    const entries = {};
    if (input.Filters !== undefined) {
        const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.ReservedInstancesId !== undefined) {
        entries["ReservedInstancesId"] = input.ReservedInstancesId;
    }
    if (input.ReservedInstancesListingId !== undefined) {
        entries["ReservedInstancesListingId"] = input.ReservedInstancesListingId;
    }
    return entries;
};
const serializeAws_ec2DescribeReservedInstancesModificationsRequest = (input, context) => {
    const entries = {};
    if (input.Filters !== undefined) {
        const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.NextToken !== undefined) {
        entries["NextToken"] = input.NextToken;
    }
    if (input.ReservedInstancesModificationIds !== undefined) {
        const memberEntries = serializeAws_ec2ReservedInstancesModificationIdStringList(input.ReservedInstancesModificationIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `ReservedInstancesModificationId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2DescribeReservedInstancesOfferingsRequest = (input, context) => {
    const entries = {};
    if (input.AvailabilityZone !== undefined) {
        entries["AvailabilityZone"] = input.AvailabilityZone;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Filters !== undefined) {
        const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.IncludeMarketplace !== undefined) {
        entries["IncludeMarketplace"] = input.IncludeMarketplace;
    }
    if (input.InstanceTenancy !== undefined) {
        entries["InstanceTenancy"] = input.InstanceTenancy;
    }
    if (input.InstanceType !== undefined) {
        entries["InstanceType"] = input.InstanceType;
    }
    if (input.MaxDuration !== undefined) {
        entries["MaxDuration"] = input.MaxDuration;
    }
    if (input.MaxInstanceCount !== undefined) {
        entries["MaxInstanceCount"] = input.MaxInstanceCount;
    }
    if (input.MaxResults !== undefined) {
        entries["MaxResults"] = input.MaxResults;
    }
    if (input.MinDuration !== undefined) {
        entries["MinDuration"] = input.MinDuration;
    }
    if (input.NextToken !== undefined) {
        entries["NextToken"] = input.NextToken;
    }
    if (input.OfferingClass !== undefined) {
        entries["OfferingClass"] = input.OfferingClass;
    }
    if (input.OfferingType !== undefined) {
        entries["OfferingType"] = input.OfferingType;
    }
    if (input.ProductDescription !== undefined) {
        entries["ProductDescription"] = input.ProductDescription;
    }
    if (input.ReservedInstancesOfferingIds !== undefined) {
        const memberEntries = serializeAws_ec2ReservedInstancesOfferingIdStringList(input.ReservedInstancesOfferingIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `ReservedInstancesOfferingId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2DescribeReservedInstancesRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Filters !== undefined) {
        const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.OfferingClass !== undefined) {
        entries["OfferingClass"] = input.OfferingClass;
    }
    if (input.OfferingType !== undefined) {
        entries["OfferingType"] = input.OfferingType;
    }
    if (input.ReservedInstancesIds !== undefined) {
        const memberEntries = serializeAws_ec2ReservedInstancesIdStringList(input.ReservedInstancesIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `ReservedInstancesId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2DescribeRouteTablesRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Filters !== undefined) {
        const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.MaxResults !== undefined) {
        entries["MaxResults"] = input.MaxResults;
    }
    if (input.NextToken !== undefined) {
        entries["NextToken"] = input.NextToken;
    }
    if (input.RouteTableIds !== undefined) {
        const memberEntries = serializeAws_ec2ValueStringList(input.RouteTableIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `RouteTableId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2DescribeScheduledInstanceAvailabilityRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Filters !== undefined) {
        const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.FirstSlotStartTimeRange !== undefined) {
        const memberEntries = serializeAws_ec2SlotDateTimeRangeRequest(input.FirstSlotStartTimeRange, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `FirstSlotStartTimeRange.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.MaxResults !== undefined) {
        entries["MaxResults"] = input.MaxResults;
    }
    if (input.MaxSlotDurationInHours !== undefined) {
        entries["MaxSlotDurationInHours"] = input.MaxSlotDurationInHours;
    }
    if (input.MinSlotDurationInHours !== undefined) {
        entries["MinSlotDurationInHours"] = input.MinSlotDurationInHours;
    }
    if (input.NextToken !== undefined) {
        entries["NextToken"] = input.NextToken;
    }
    if (input.Recurrence !== undefined) {
        const memberEntries = serializeAws_ec2ScheduledInstanceRecurrenceRequest(input.Recurrence, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Recurrence.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2DescribeScheduledInstancesRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Filters !== undefined) {
        const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.MaxResults !== undefined) {
        entries["MaxResults"] = input.MaxResults;
    }
    if (input.NextToken !== undefined) {
        entries["NextToken"] = input.NextToken;
    }
    if (input.ScheduledInstanceIds !== undefined) {
        const memberEntries = serializeAws_ec2ScheduledInstanceIdRequestSet(input.ScheduledInstanceIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `ScheduledInstanceId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.SlotStartTimeRange !== undefined) {
        const memberEntries = serializeAws_ec2SlotStartTimeRangeRequest(input.SlotStartTimeRange, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `SlotStartTimeRange.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2DescribeSecurityGroupReferencesRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.GroupId !== undefined) {
        const memberEntries = serializeAws_ec2GroupIds(input.GroupId, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `GroupId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2DescribeSecurityGroupsRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Filters !== undefined) {
        const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.GroupIds !== undefined) {
        const memberEntries = serializeAws_ec2GroupIdStringList(input.GroupIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `GroupId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.GroupNames !== undefined) {
        const memberEntries = serializeAws_ec2GroupNameStringList(input.GroupNames, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `GroupName.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.MaxResults !== undefined) {
        entries["MaxResults"] = input.MaxResults;
    }
    if (input.NextToken !== undefined) {
        entries["NextToken"] = input.NextToken;
    }
    return entries;
};
const serializeAws_ec2DescribeSnapshotAttributeRequest = (input, context) => {
    const entries = {};
    if (input.Attribute !== undefined) {
        entries["Attribute"] = input.Attribute;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.SnapshotId !== undefined) {
        entries["SnapshotId"] = input.SnapshotId;
    }
    return entries;
};
const serializeAws_ec2DescribeSnapshotsRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Filters !== undefined) {
        const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.MaxResults !== undefined) {
        entries["MaxResults"] = input.MaxResults;
    }
    if (input.NextToken !== undefined) {
        entries["NextToken"] = input.NextToken;
    }
    if (input.OwnerIds !== undefined) {
        const memberEntries = serializeAws_ec2OwnerStringList(input.OwnerIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Owner.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.RestorableByUserIds !== undefined) {
        const memberEntries = serializeAws_ec2RestorableByStringList(input.RestorableByUserIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `RestorableBy.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.SnapshotIds !== undefined) {
        const memberEntries = serializeAws_ec2SnapshotIdStringList(input.SnapshotIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `SnapshotId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2DescribeSpotDatafeedSubscriptionRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    return entries;
};
const serializeAws_ec2DescribeSpotFleetInstancesRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.MaxResults !== undefined) {
        entries["MaxResults"] = input.MaxResults;
    }
    if (input.NextToken !== undefined) {
        entries["NextToken"] = input.NextToken;
    }
    if (input.SpotFleetRequestId !== undefined) {
        entries["SpotFleetRequestId"] = input.SpotFleetRequestId;
    }
    return entries;
};
const serializeAws_ec2DescribeSpotFleetRequestHistoryRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.EventType !== undefined) {
        entries["EventType"] = input.EventType;
    }
    if (input.MaxResults !== undefined) {
        entries["MaxResults"] = input.MaxResults;
    }
    if (input.NextToken !== undefined) {
        entries["NextToken"] = input.NextToken;
    }
    if (input.SpotFleetRequestId !== undefined) {
        entries["SpotFleetRequestId"] = input.SpotFleetRequestId;
    }
    if (input.StartTime !== undefined) {
        entries["StartTime"] = input.StartTime.toISOString().split(".")[0] + "Z";
    }
    return entries;
};
const serializeAws_ec2DescribeSpotFleetRequestsRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.MaxResults !== undefined) {
        entries["MaxResults"] = input.MaxResults;
    }
    if (input.NextToken !== undefined) {
        entries["NextToken"] = input.NextToken;
    }
    if (input.SpotFleetRequestIds !== undefined) {
        const memberEntries = serializeAws_ec2ValueStringList(input.SpotFleetRequestIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `SpotFleetRequestId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2DescribeSpotInstanceRequestsRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Filters !== undefined) {
        const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.MaxResults !== undefined) {
        entries["MaxResults"] = input.MaxResults;
    }
    if (input.NextToken !== undefined) {
        entries["NextToken"] = input.NextToken;
    }
    if (input.SpotInstanceRequestIds !== undefined) {
        const memberEntries = serializeAws_ec2SpotInstanceRequestIdList(input.SpotInstanceRequestIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `SpotInstanceRequestId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2DescribeSpotPriceHistoryRequest = (input, context) => {
    const entries = {};
    if (input.AvailabilityZone !== undefined) {
        entries["AvailabilityZone"] = input.AvailabilityZone;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.EndTime !== undefined) {
        entries["EndTime"] = input.EndTime.toISOString().split(".")[0] + "Z";
    }
    if (input.Filters !== undefined) {
        const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.InstanceTypes !== undefined) {
        const memberEntries = serializeAws_ec2InstanceTypeList(input.InstanceTypes, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `InstanceType.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.MaxResults !== undefined) {
        entries["MaxResults"] = input.MaxResults;
    }
    if (input.NextToken !== undefined) {
        entries["NextToken"] = input.NextToken;
    }
    if (input.ProductDescriptions !== undefined) {
        const memberEntries = serializeAws_ec2ProductDescriptionList(input.ProductDescriptions, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `ProductDescription.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.StartTime !== undefined) {
        entries["StartTime"] = input.StartTime.toISOString().split(".")[0] + "Z";
    }
    return entries;
};
const serializeAws_ec2DescribeStaleSecurityGroupsRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.MaxResults !== undefined) {
        entries["MaxResults"] = input.MaxResults;
    }
    if (input.NextToken !== undefined) {
        entries["NextToken"] = input.NextToken;
    }
    if (input.VpcId !== undefined) {
        entries["VpcId"] = input.VpcId;
    }
    return entries;
};
const serializeAws_ec2DescribeSubnetsRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Filters !== undefined) {
        const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.MaxResults !== undefined) {
        entries["MaxResults"] = input.MaxResults;
    }
    if (input.NextToken !== undefined) {
        entries["NextToken"] = input.NextToken;
    }
    if (input.SubnetIds !== undefined) {
        const memberEntries = serializeAws_ec2SubnetIdStringList(input.SubnetIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `SubnetId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2DescribeTagsRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Filters !== undefined) {
        const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.MaxResults !== undefined) {
        entries["MaxResults"] = input.MaxResults;
    }
    if (input.NextToken !== undefined) {
        entries["NextToken"] = input.NextToken;
    }
    return entries;
};
const serializeAws_ec2DescribeTrafficMirrorFiltersRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Filters !== undefined) {
        const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.MaxResults !== undefined) {
        entries["MaxResults"] = input.MaxResults;
    }
    if (input.NextToken !== undefined) {
        entries["NextToken"] = input.NextToken;
    }
    if (input.TrafficMirrorFilterIds !== undefined) {
        const memberEntries = serializeAws_ec2ValueStringList(input.TrafficMirrorFilterIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `TrafficMirrorFilterId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2DescribeTrafficMirrorSessionsRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Filters !== undefined) {
        const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.MaxResults !== undefined) {
        entries["MaxResults"] = input.MaxResults;
    }
    if (input.NextToken !== undefined) {
        entries["NextToken"] = input.NextToken;
    }
    if (input.TrafficMirrorSessionIds !== undefined) {
        const memberEntries = serializeAws_ec2ValueStringList(input.TrafficMirrorSessionIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `TrafficMirrorSessionId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2DescribeTrafficMirrorTargetsRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Filters !== undefined) {
        const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.MaxResults !== undefined) {
        entries["MaxResults"] = input.MaxResults;
    }
    if (input.NextToken !== undefined) {
        entries["NextToken"] = input.NextToken;
    }
    if (input.TrafficMirrorTargetIds !== undefined) {
        const memberEntries = serializeAws_ec2ValueStringList(input.TrafficMirrorTargetIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `TrafficMirrorTargetId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2DescribeTransitGatewayAttachmentsRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Filters !== undefined) {
        const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.MaxResults !== undefined) {
        entries["MaxResults"] = input.MaxResults;
    }
    if (input.NextToken !== undefined) {
        entries["NextToken"] = input.NextToken;
    }
    if (input.TransitGatewayAttachmentIds !== undefined) {
        const memberEntries = serializeAws_ec2TransitGatewayAttachmentIdStringList(input.TransitGatewayAttachmentIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `TransitGatewayAttachmentIds.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2DescribeTransitGatewayMulticastDomainsRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Filters !== undefined) {
        const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.MaxResults !== undefined) {
        entries["MaxResults"] = input.MaxResults;
    }
    if (input.NextToken !== undefined) {
        entries["NextToken"] = input.NextToken;
    }
    if (input.TransitGatewayMulticastDomainIds !== undefined) {
        const memberEntries = serializeAws_ec2TransitGatewayMulticastDomainIdStringList(input.TransitGatewayMulticastDomainIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `TransitGatewayMulticastDomainIds.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2DescribeTransitGatewayPeeringAttachmentsRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Filters !== undefined) {
        const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.MaxResults !== undefined) {
        entries["MaxResults"] = input.MaxResults;
    }
    if (input.NextToken !== undefined) {
        entries["NextToken"] = input.NextToken;
    }
    if (input.TransitGatewayAttachmentIds !== undefined) {
        const memberEntries = serializeAws_ec2TransitGatewayAttachmentIdStringList(input.TransitGatewayAttachmentIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `TransitGatewayAttachmentIds.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2DescribeTransitGatewayRouteTablesRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Filters !== undefined) {
        const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.MaxResults !== undefined) {
        entries["MaxResults"] = input.MaxResults;
    }
    if (input.NextToken !== undefined) {
        entries["NextToken"] = input.NextToken;
    }
    if (input.TransitGatewayRouteTableIds !== undefined) {
        const memberEntries = serializeAws_ec2TransitGatewayRouteTableIdStringList(input.TransitGatewayRouteTableIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `TransitGatewayRouteTableIds.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2DescribeTransitGatewayVpcAttachmentsRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Filters !== undefined) {
        const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.MaxResults !== undefined) {
        entries["MaxResults"] = input.MaxResults;
    }
    if (input.NextToken !== undefined) {
        entries["NextToken"] = input.NextToken;
    }
    if (input.TransitGatewayAttachmentIds !== undefined) {
        const memberEntries = serializeAws_ec2TransitGatewayAttachmentIdStringList(input.TransitGatewayAttachmentIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `TransitGatewayAttachmentIds.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2DescribeTransitGatewaysRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Filters !== undefined) {
        const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.MaxResults !== undefined) {
        entries["MaxResults"] = input.MaxResults;
    }
    if (input.NextToken !== undefined) {
        entries["NextToken"] = input.NextToken;
    }
    if (input.TransitGatewayIds !== undefined) {
        const memberEntries = serializeAws_ec2TransitGatewayIdStringList(input.TransitGatewayIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `TransitGatewayIds.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2DescribeVolumeAttributeRequest = (input, context) => {
    const entries = {};
    if (input.Attribute !== undefined) {
        entries["Attribute"] = input.Attribute;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.VolumeId !== undefined) {
        entries["VolumeId"] = input.VolumeId;
    }
    return entries;
};
const serializeAws_ec2DescribeVolumeStatusRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Filters !== undefined) {
        const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.MaxResults !== undefined) {
        entries["MaxResults"] = input.MaxResults;
    }
    if (input.NextToken !== undefined) {
        entries["NextToken"] = input.NextToken;
    }
    if (input.VolumeIds !== undefined) {
        const memberEntries = serializeAws_ec2VolumeIdStringList(input.VolumeIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `VolumeId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2DescribeVolumesModificationsRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Filters !== undefined) {
        const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.MaxResults !== undefined) {
        entries["MaxResults"] = input.MaxResults;
    }
    if (input.NextToken !== undefined) {
        entries["NextToken"] = input.NextToken;
    }
    if (input.VolumeIds !== undefined) {
        const memberEntries = serializeAws_ec2VolumeIdStringList(input.VolumeIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `VolumeId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2DescribeVolumesRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Filters !== undefined) {
        const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.MaxResults !== undefined) {
        entries["MaxResults"] = input.MaxResults;
    }
    if (input.NextToken !== undefined) {
        entries["NextToken"] = input.NextToken;
    }
    if (input.VolumeIds !== undefined) {
        const memberEntries = serializeAws_ec2VolumeIdStringList(input.VolumeIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `VolumeId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2DescribeVpcAttributeRequest = (input, context) => {
    const entries = {};
    if (input.Attribute !== undefined) {
        entries["Attribute"] = input.Attribute;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.VpcId !== undefined) {
        entries["VpcId"] = input.VpcId;
    }
    return entries;
};
const serializeAws_ec2DescribeVpcClassicLinkDnsSupportRequest = (input, context) => {
    const entries = {};
    if (input.MaxResults !== undefined) {
        entries["MaxResults"] = input.MaxResults;
    }
    if (input.NextToken !== undefined) {
        entries["NextToken"] = input.NextToken;
    }
    if (input.VpcIds !== undefined) {
        const memberEntries = serializeAws_ec2VpcClassicLinkIdList(input.VpcIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `VpcIds.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2DescribeVpcClassicLinkRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Filters !== undefined) {
        const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.VpcIds !== undefined) {
        const memberEntries = serializeAws_ec2VpcClassicLinkIdList(input.VpcIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `VpcId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2DescribeVpcEndpointConnectionNotificationsRequest = (input, context) => {
    const entries = {};
    if (input.ConnectionNotificationId !== undefined) {
        entries["ConnectionNotificationId"] = input.ConnectionNotificationId;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Filters !== undefined) {
        const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.MaxResults !== undefined) {
        entries["MaxResults"] = input.MaxResults;
    }
    if (input.NextToken !== undefined) {
        entries["NextToken"] = input.NextToken;
    }
    return entries;
};
const serializeAws_ec2DescribeVpcEndpointConnectionsRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Filters !== undefined) {
        const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.MaxResults !== undefined) {
        entries["MaxResults"] = input.MaxResults;
    }
    if (input.NextToken !== undefined) {
        entries["NextToken"] = input.NextToken;
    }
    return entries;
};
const serializeAws_ec2DescribeVpcEndpointServiceConfigurationsRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Filters !== undefined) {
        const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.MaxResults !== undefined) {
        entries["MaxResults"] = input.MaxResults;
    }
    if (input.NextToken !== undefined) {
        entries["NextToken"] = input.NextToken;
    }
    if (input.ServiceIds !== undefined) {
        const memberEntries = serializeAws_ec2ValueStringList(input.ServiceIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `ServiceId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2DescribeVpcEndpointServicePermissionsRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Filters !== undefined) {
        const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.MaxResults !== undefined) {
        entries["MaxResults"] = input.MaxResults;
    }
    if (input.NextToken !== undefined) {
        entries["NextToken"] = input.NextToken;
    }
    if (input.ServiceId !== undefined) {
        entries["ServiceId"] = input.ServiceId;
    }
    return entries;
};
const serializeAws_ec2DescribeVpcEndpointServicesRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Filters !== undefined) {
        const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.MaxResults !== undefined) {
        entries["MaxResults"] = input.MaxResults;
    }
    if (input.NextToken !== undefined) {
        entries["NextToken"] = input.NextToken;
    }
    if (input.ServiceNames !== undefined) {
        const memberEntries = serializeAws_ec2ValueStringList(input.ServiceNames, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `ServiceName.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2DescribeVpcEndpointsRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Filters !== undefined) {
        const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.MaxResults !== undefined) {
        entries["MaxResults"] = input.MaxResults;
    }
    if (input.NextToken !== undefined) {
        entries["NextToken"] = input.NextToken;
    }
    if (input.VpcEndpointIds !== undefined) {
        const memberEntries = serializeAws_ec2ValueStringList(input.VpcEndpointIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `VpcEndpointId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2DescribeVpcPeeringConnectionsRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Filters !== undefined) {
        const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.MaxResults !== undefined) {
        entries["MaxResults"] = input.MaxResults;
    }
    if (input.NextToken !== undefined) {
        entries["NextToken"] = input.NextToken;
    }
    if (input.VpcPeeringConnectionIds !== undefined) {
        const memberEntries = serializeAws_ec2ValueStringList(input.VpcPeeringConnectionIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `VpcPeeringConnectionId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2DescribeVpcsRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Filters !== undefined) {
        const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.MaxResults !== undefined) {
        entries["MaxResults"] = input.MaxResults;
    }
    if (input.NextToken !== undefined) {
        entries["NextToken"] = input.NextToken;
    }
    if (input.VpcIds !== undefined) {
        const memberEntries = serializeAws_ec2VpcIdStringList(input.VpcIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `VpcId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2DescribeVpnConnectionsRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Filters !== undefined) {
        const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.VpnConnectionIds !== undefined) {
        const memberEntries = serializeAws_ec2VpnConnectionIdStringList(input.VpnConnectionIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `VpnConnectionId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2DescribeVpnGatewaysRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Filters !== undefined) {
        const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.VpnGatewayIds !== undefined) {
        const memberEntries = serializeAws_ec2VpnGatewayIdStringList(input.VpnGatewayIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `VpnGatewayId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2DetachClassicLinkVpcRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.InstanceId !== undefined) {
        entries["InstanceId"] = input.InstanceId;
    }
    if (input.VpcId !== undefined) {
        entries["VpcId"] = input.VpcId;
    }
    return entries;
};
const serializeAws_ec2DetachInternetGatewayRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.InternetGatewayId !== undefined) {
        entries["InternetGatewayId"] = input.InternetGatewayId;
    }
    if (input.VpcId !== undefined) {
        entries["VpcId"] = input.VpcId;
    }
    return entries;
};
const serializeAws_ec2DetachNetworkInterfaceRequest = (input, context) => {
    const entries = {};
    if (input.AttachmentId !== undefined) {
        entries["AttachmentId"] = input.AttachmentId;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Force !== undefined) {
        entries["Force"] = input.Force;
    }
    return entries;
};
const serializeAws_ec2DetachVolumeRequest = (input, context) => {
    const entries = {};
    if (input.Device !== undefined) {
        entries["Device"] = input.Device;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Force !== undefined) {
        entries["Force"] = input.Force;
    }
    if (input.InstanceId !== undefined) {
        entries["InstanceId"] = input.InstanceId;
    }
    if (input.VolumeId !== undefined) {
        entries["VolumeId"] = input.VolumeId;
    }
    return entries;
};
const serializeAws_ec2DetachVpnGatewayRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.VpcId !== undefined) {
        entries["VpcId"] = input.VpcId;
    }
    if (input.VpnGatewayId !== undefined) {
        entries["VpnGatewayId"] = input.VpnGatewayId;
    }
    return entries;
};
const serializeAws_ec2DhcpOptionsIdStringList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        entries[`DhcpOptionsId.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const serializeAws_ec2DirectoryServiceAuthenticationRequest = (input, context) => {
    const entries = {};
    if (input.DirectoryId !== undefined) {
        entries["DirectoryId"] = input.DirectoryId;
    }
    return entries;
};
const serializeAws_ec2DisableEbsEncryptionByDefaultRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    return entries;
};
const serializeAws_ec2DisableFastSnapshotRestoresRequest = (input, context) => {
    const entries = {};
    if (input.AvailabilityZones !== undefined) {
        const memberEntries = serializeAws_ec2AvailabilityZoneStringList(input.AvailabilityZones, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `AvailabilityZone.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.SourceSnapshotIds !== undefined) {
        const memberEntries = serializeAws_ec2SnapshotIdStringList(input.SourceSnapshotIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `SourceSnapshotId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2DisableTransitGatewayRouteTablePropagationRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.TransitGatewayAttachmentId !== undefined) {
        entries["TransitGatewayAttachmentId"] = input.TransitGatewayAttachmentId;
    }
    if (input.TransitGatewayRouteTableId !== undefined) {
        entries["TransitGatewayRouteTableId"] = input.TransitGatewayRouteTableId;
    }
    return entries;
};
const serializeAws_ec2DisableVgwRoutePropagationRequest = (input, context) => {
    const entries = {};
    if (input.GatewayId !== undefined) {
        entries["GatewayId"] = input.GatewayId;
    }
    if (input.RouteTableId !== undefined) {
        entries["RouteTableId"] = input.RouteTableId;
    }
    return entries;
};
const serializeAws_ec2DisableVpcClassicLinkDnsSupportRequest = (input, context) => {
    const entries = {};
    if (input.VpcId !== undefined) {
        entries["VpcId"] = input.VpcId;
    }
    return entries;
};
const serializeAws_ec2DisableVpcClassicLinkRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.VpcId !== undefined) {
        entries["VpcId"] = input.VpcId;
    }
    return entries;
};
const serializeAws_ec2DisassociateAddressRequest = (input, context) => {
    const entries = {};
    if (input.AssociationId !== undefined) {
        entries["AssociationId"] = input.AssociationId;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.PublicIp !== undefined) {
        entries["PublicIp"] = input.PublicIp;
    }
    return entries;
};
const serializeAws_ec2DisassociateClientVpnTargetNetworkRequest = (input, context) => {
    const entries = {};
    if (input.AssociationId !== undefined) {
        entries["AssociationId"] = input.AssociationId;
    }
    if (input.ClientVpnEndpointId !== undefined) {
        entries["ClientVpnEndpointId"] = input.ClientVpnEndpointId;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    return entries;
};
const serializeAws_ec2DisassociateIamInstanceProfileRequest = (input, context) => {
    const entries = {};
    if (input.AssociationId !== undefined) {
        entries["AssociationId"] = input.AssociationId;
    }
    return entries;
};
const serializeAws_ec2DisassociateRouteTableRequest = (input, context) => {
    const entries = {};
    if (input.AssociationId !== undefined) {
        entries["AssociationId"] = input.AssociationId;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    return entries;
};
const serializeAws_ec2DisassociateSubnetCidrBlockRequest = (input, context) => {
    const entries = {};
    if (input.AssociationId !== undefined) {
        entries["AssociationId"] = input.AssociationId;
    }
    return entries;
};
const serializeAws_ec2DisassociateTransitGatewayMulticastDomainRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.SubnetIds !== undefined) {
        const memberEntries = serializeAws_ec2ValueStringList(input.SubnetIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `SubnetIds.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.TransitGatewayAttachmentId !== undefined) {
        entries["TransitGatewayAttachmentId"] = input.TransitGatewayAttachmentId;
    }
    if (input.TransitGatewayMulticastDomainId !== undefined) {
        entries["TransitGatewayMulticastDomainId"] =
            input.TransitGatewayMulticastDomainId;
    }
    return entries;
};
const serializeAws_ec2DisassociateTransitGatewayRouteTableRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.TransitGatewayAttachmentId !== undefined) {
        entries["TransitGatewayAttachmentId"] = input.TransitGatewayAttachmentId;
    }
    if (input.TransitGatewayRouteTableId !== undefined) {
        entries["TransitGatewayRouteTableId"] = input.TransitGatewayRouteTableId;
    }
    return entries;
};
const serializeAws_ec2DisassociateVpcCidrBlockRequest = (input, context) => {
    const entries = {};
    if (input.AssociationId !== undefined) {
        entries["AssociationId"] = input.AssociationId;
    }
    return entries;
};
const serializeAws_ec2DiskImage = (input, context) => {
    const entries = {};
    if (input.Description !== undefined) {
        entries["Description"] = input.Description;
    }
    if (input.Image !== undefined) {
        const memberEntries = serializeAws_ec2DiskImageDetail(input.Image, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Image.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.Volume !== undefined) {
        const memberEntries = serializeAws_ec2VolumeDetail(input.Volume, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Volume.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2DiskImageDetail = (input, context) => {
    const entries = {};
    if (input.Bytes !== undefined) {
        entries["Bytes"] = input.Bytes;
    }
    if (input.Format !== undefined) {
        entries["Format"] = input.Format;
    }
    if (input.ImportManifestUrl !== undefined) {
        entries["ImportManifestUrl"] = input.ImportManifestUrl;
    }
    return entries;
};
const serializeAws_ec2DiskImageList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        const memberEntries = serializeAws_ec2DiskImage(entry, context);
        Object.keys(memberEntries).forEach(key => {
            entries[`Member.${counter}.${key}`] = memberEntries[key];
        });
        counter++;
    }
    return entries;
};
const serializeAws_ec2DnsServersOptionsModifyStructure = (input, context) => {
    const entries = {};
    if (input.CustomDnsServers !== undefined) {
        const memberEntries = serializeAws_ec2ValueStringList(input.CustomDnsServers, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `CustomDnsServers.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.Enabled !== undefined) {
        entries["Enabled"] = input.Enabled;
    }
    return entries;
};
const serializeAws_ec2EbsBlockDevice = (input, context) => {
    const entries = {};
    if (input.DeleteOnTermination !== undefined) {
        entries["DeleteOnTermination"] = input.DeleteOnTermination;
    }
    if (input.Encrypted !== undefined) {
        entries["Encrypted"] = input.Encrypted;
    }
    if (input.Iops !== undefined) {
        entries["Iops"] = input.Iops;
    }
    if (input.KmsKeyId !== undefined) {
        entries["KmsKeyId"] = input.KmsKeyId;
    }
    if (input.SnapshotId !== undefined) {
        entries["SnapshotId"] = input.SnapshotId;
    }
    if (input.VolumeSize !== undefined) {
        entries["VolumeSize"] = input.VolumeSize;
    }
    if (input.VolumeType !== undefined) {
        entries["VolumeType"] = input.VolumeType;
    }
    return entries;
};
const serializeAws_ec2EbsInstanceBlockDeviceSpecification = (input, context) => {
    const entries = {};
    if (input.DeleteOnTermination !== undefined) {
        entries["DeleteOnTermination"] = input.DeleteOnTermination;
    }
    if (input.VolumeId !== undefined) {
        entries["VolumeId"] = input.VolumeId;
    }
    return entries;
};
const serializeAws_ec2EgressOnlyInternetGatewayIdList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const serializeAws_ec2ElasticGpuIdSet = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const serializeAws_ec2ElasticGpuSpecification = (input, context) => {
    const entries = {};
    if (input.Type !== undefined) {
        entries["Type"] = input.Type;
    }
    return entries;
};
const serializeAws_ec2ElasticGpuSpecificationList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        const memberEntries = serializeAws_ec2ElasticGpuSpecification(entry, context);
        Object.keys(memberEntries).forEach(key => {
            entries[`ElasticGpuSpecification.${counter}.${key}`] = memberEntries[key];
        });
        counter++;
    }
    return entries;
};
const serializeAws_ec2ElasticGpuSpecifications = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        const memberEntries = serializeAws_ec2ElasticGpuSpecification(entry, context);
        Object.keys(memberEntries).forEach(key => {
            entries[`Item.${counter}.${key}`] = memberEntries[key];
        });
        counter++;
    }
    return entries;
};
const serializeAws_ec2ElasticInferenceAccelerator = (input, context) => {
    const entries = {};
    if (input.Count !== undefined) {
        entries["Count"] = input.Count;
    }
    if (input.Type !== undefined) {
        entries["Type"] = input.Type;
    }
    return entries;
};
const serializeAws_ec2ElasticInferenceAccelerators = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        const memberEntries = serializeAws_ec2ElasticInferenceAccelerator(entry, context);
        Object.keys(memberEntries).forEach(key => {
            entries[`Item.${counter}.${key}`] = memberEntries[key];
        });
        counter++;
    }
    return entries;
};
const serializeAws_ec2EnableEbsEncryptionByDefaultRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    return entries;
};
const serializeAws_ec2EnableFastSnapshotRestoresRequest = (input, context) => {
    const entries = {};
    if (input.AvailabilityZones !== undefined) {
        const memberEntries = serializeAws_ec2AvailabilityZoneStringList(input.AvailabilityZones, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `AvailabilityZone.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.SourceSnapshotIds !== undefined) {
        const memberEntries = serializeAws_ec2SnapshotIdStringList(input.SourceSnapshotIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `SourceSnapshotId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2EnableTransitGatewayRouteTablePropagationRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.TransitGatewayAttachmentId !== undefined) {
        entries["TransitGatewayAttachmentId"] = input.TransitGatewayAttachmentId;
    }
    if (input.TransitGatewayRouteTableId !== undefined) {
        entries["TransitGatewayRouteTableId"] = input.TransitGatewayRouteTableId;
    }
    return entries;
};
const serializeAws_ec2EnableVgwRoutePropagationRequest = (input, context) => {
    const entries = {};
    if (input.GatewayId !== undefined) {
        entries["GatewayId"] = input.GatewayId;
    }
    if (input.RouteTableId !== undefined) {
        entries["RouteTableId"] = input.RouteTableId;
    }
    return entries;
};
const serializeAws_ec2EnableVolumeIORequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.VolumeId !== undefined) {
        entries["VolumeId"] = input.VolumeId;
    }
    return entries;
};
const serializeAws_ec2EnableVpcClassicLinkDnsSupportRequest = (input, context) => {
    const entries = {};
    if (input.VpcId !== undefined) {
        entries["VpcId"] = input.VpcId;
    }
    return entries;
};
const serializeAws_ec2EnableVpcClassicLinkRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.VpcId !== undefined) {
        entries["VpcId"] = input.VpcId;
    }
    return entries;
};
const serializeAws_ec2ExecutableByStringList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        entries[`ExecutableBy.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const serializeAws_ec2ExportClientVpnClientCertificateRevocationListRequest = (input, context) => {
    const entries = {};
    if (input.ClientVpnEndpointId !== undefined) {
        entries["ClientVpnEndpointId"] = input.ClientVpnEndpointId;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    return entries;
};
const serializeAws_ec2ExportClientVpnClientConfigurationRequest = (input, context) => {
    const entries = {};
    if (input.ClientVpnEndpointId !== undefined) {
        entries["ClientVpnEndpointId"] = input.ClientVpnEndpointId;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    return entries;
};
const serializeAws_ec2ExportImageRequest = (input, context) => {
    const entries = {};
    if (input.ClientToken === undefined) {
        input.ClientToken = uuid_1.v4();
    }
    if (input.ClientToken !== undefined) {
        entries["ClientToken"] = input.ClientToken;
    }
    if (input.Description !== undefined) {
        entries["Description"] = input.Description;
    }
    if (input.DiskImageFormat !== undefined) {
        entries["DiskImageFormat"] = input.DiskImageFormat;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.ImageId !== undefined) {
        entries["ImageId"] = input.ImageId;
    }
    if (input.RoleName !== undefined) {
        entries["RoleName"] = input.RoleName;
    }
    if (input.S3ExportLocation !== undefined) {
        const memberEntries = serializeAws_ec2ExportTaskS3LocationRequest(input.S3ExportLocation, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `S3ExportLocation.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2ExportImageTaskIdList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        entries[`ExportImageTaskId.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const serializeAws_ec2ExportTaskIdStringList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        entries[`ExportTaskId.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const serializeAws_ec2ExportTaskS3LocationRequest = (input, context) => {
    const entries = {};
    if (input.S3Bucket !== undefined) {
        entries["S3Bucket"] = input.S3Bucket;
    }
    if (input.S3Prefix !== undefined) {
        entries["S3Prefix"] = input.S3Prefix;
    }
    return entries;
};
const serializeAws_ec2ExportToS3TaskSpecification = (input, context) => {
    const entries = {};
    if (input.ContainerFormat !== undefined) {
        entries["ContainerFormat"] = input.ContainerFormat;
    }
    if (input.DiskImageFormat !== undefined) {
        entries["DiskImageFormat"] = input.DiskImageFormat;
    }
    if (input.S3Bucket !== undefined) {
        entries["S3Bucket"] = input.S3Bucket;
    }
    if (input.S3Prefix !== undefined) {
        entries["S3Prefix"] = input.S3Prefix;
    }
    return entries;
};
const serializeAws_ec2ExportTransitGatewayRoutesRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Filters !== undefined) {
        const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.S3Bucket !== undefined) {
        entries["S3Bucket"] = input.S3Bucket;
    }
    if (input.TransitGatewayRouteTableId !== undefined) {
        entries["TransitGatewayRouteTableId"] = input.TransitGatewayRouteTableId;
    }
    return entries;
};
const serializeAws_ec2Filter = (input, context) => {
    const entries = {};
    if (input.Name !== undefined) {
        entries["Name"] = input.Name;
    }
    if (input.Values !== undefined) {
        const memberEntries = serializeAws_ec2ValueStringList(input.Values, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Value.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2FilterList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        const memberEntries = serializeAws_ec2Filter(entry, context);
        Object.keys(memberEntries).forEach(key => {
            entries[`Filter.${counter}.${key}`] = memberEntries[key];
        });
        counter++;
    }
    return entries;
};
const serializeAws_ec2FleetIdSet = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        entries[`Member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const serializeAws_ec2FleetLaunchTemplateConfigListRequest = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        const memberEntries = serializeAws_ec2FleetLaunchTemplateConfigRequest(entry, context);
        Object.keys(memberEntries).forEach(key => {
            entries[`Item.${counter}.${key}`] = memberEntries[key];
        });
        counter++;
    }
    return entries;
};
const serializeAws_ec2FleetLaunchTemplateConfigRequest = (input, context) => {
    const entries = {};
    if (input.LaunchTemplateSpecification !== undefined) {
        const memberEntries = serializeAws_ec2FleetLaunchTemplateSpecificationRequest(input.LaunchTemplateSpecification, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `LaunchTemplateSpecification.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.Overrides !== undefined) {
        const memberEntries = serializeAws_ec2FleetLaunchTemplateOverridesListRequest(input.Overrides, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Overrides.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2FleetLaunchTemplateOverridesListRequest = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        const memberEntries = serializeAws_ec2FleetLaunchTemplateOverridesRequest(entry, context);
        Object.keys(memberEntries).forEach(key => {
            entries[`Item.${counter}.${key}`] = memberEntries[key];
        });
        counter++;
    }
    return entries;
};
const serializeAws_ec2FleetLaunchTemplateOverridesRequest = (input, context) => {
    const entries = {};
    if (input.AvailabilityZone !== undefined) {
        entries["AvailabilityZone"] = input.AvailabilityZone;
    }
    if (input.InstanceType !== undefined) {
        entries["InstanceType"] = input.InstanceType;
    }
    if (input.MaxPrice !== undefined) {
        entries["MaxPrice"] = input.MaxPrice;
    }
    if (input.Placement !== undefined) {
        const memberEntries = serializeAws_ec2Placement(input.Placement, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Placement.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.Priority !== undefined) {
        entries["Priority"] = input.Priority;
    }
    if (input.SubnetId !== undefined) {
        entries["SubnetId"] = input.SubnetId;
    }
    if (input.WeightedCapacity !== undefined) {
        entries["WeightedCapacity"] = input.WeightedCapacity;
    }
    return entries;
};
const serializeAws_ec2FleetLaunchTemplateSpecification = (input, context) => {
    const entries = {};
    if (input.LaunchTemplateId !== undefined) {
        entries["LaunchTemplateId"] = input.LaunchTemplateId;
    }
    if (input.LaunchTemplateName !== undefined) {
        entries["LaunchTemplateName"] = input.LaunchTemplateName;
    }
    if (input.Version !== undefined) {
        entries["Version"] = input.Version;
    }
    return entries;
};
const serializeAws_ec2FleetLaunchTemplateSpecificationRequest = (input, context) => {
    const entries = {};
    if (input.LaunchTemplateId !== undefined) {
        entries["LaunchTemplateId"] = input.LaunchTemplateId;
    }
    if (input.LaunchTemplateName !== undefined) {
        entries["LaunchTemplateName"] = input.LaunchTemplateName;
    }
    if (input.Version !== undefined) {
        entries["Version"] = input.Version;
    }
    return entries;
};
const serializeAws_ec2FpgaImageIdList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const serializeAws_ec2GetAssociatedIpv6PoolCidrsRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.MaxResults !== undefined) {
        entries["MaxResults"] = input.MaxResults;
    }
    if (input.NextToken !== undefined) {
        entries["NextToken"] = input.NextToken;
    }
    if (input.PoolId !== undefined) {
        entries["PoolId"] = input.PoolId;
    }
    return entries;
};
const serializeAws_ec2GetCapacityReservationUsageRequest = (input, context) => {
    const entries = {};
    if (input.CapacityReservationId !== undefined) {
        entries["CapacityReservationId"] = input.CapacityReservationId;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.MaxResults !== undefined) {
        entries["MaxResults"] = input.MaxResults;
    }
    if (input.NextToken !== undefined) {
        entries["NextToken"] = input.NextToken;
    }
    return entries;
};
const serializeAws_ec2GetCoipPoolUsageRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Filters !== undefined) {
        const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.MaxResults !== undefined) {
        entries["MaxResults"] = input.MaxResults;
    }
    if (input.NextToken !== undefined) {
        entries["NextToken"] = input.NextToken;
    }
    if (input.PoolId !== undefined) {
        entries["PoolId"] = input.PoolId;
    }
    return entries;
};
const serializeAws_ec2GetConsoleOutputRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.InstanceId !== undefined) {
        entries["InstanceId"] = input.InstanceId;
    }
    if (input.Latest !== undefined) {
        entries["Latest"] = input.Latest;
    }
    return entries;
};
const serializeAws_ec2GetConsoleScreenshotRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.InstanceId !== undefined) {
        entries["InstanceId"] = input.InstanceId;
    }
    if (input.WakeUp !== undefined) {
        entries["WakeUp"] = input.WakeUp;
    }
    return entries;
};
const serializeAws_ec2GetDefaultCreditSpecificationRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.InstanceFamily !== undefined) {
        entries["InstanceFamily"] = input.InstanceFamily;
    }
    return entries;
};
const serializeAws_ec2GetEbsDefaultKmsKeyIdRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    return entries;
};
const serializeAws_ec2GetEbsEncryptionByDefaultRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    return entries;
};
const serializeAws_ec2GetHostReservationPurchasePreviewRequest = (input, context) => {
    const entries = {};
    if (input.HostIdSet !== undefined) {
        const memberEntries = serializeAws_ec2RequestHostIdSet(input.HostIdSet, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `HostIdSet.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.OfferingId !== undefined) {
        entries["OfferingId"] = input.OfferingId;
    }
    return entries;
};
const serializeAws_ec2GetLaunchTemplateDataRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.InstanceId !== undefined) {
        entries["InstanceId"] = input.InstanceId;
    }
    return entries;
};
const serializeAws_ec2GetPasswordDataRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.InstanceId !== undefined) {
        entries["InstanceId"] = input.InstanceId;
    }
    return entries;
};
const serializeAws_ec2GetReservedInstancesExchangeQuoteRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.ReservedInstanceIds !== undefined) {
        const memberEntries = serializeAws_ec2ReservedInstanceIdSet(input.ReservedInstanceIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `ReservedInstanceId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.TargetConfigurations !== undefined) {
        const memberEntries = serializeAws_ec2TargetConfigurationRequestSet(input.TargetConfigurations, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `TargetConfiguration.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2GetTransitGatewayAttachmentPropagationsRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Filters !== undefined) {
        const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.MaxResults !== undefined) {
        entries["MaxResults"] = input.MaxResults;
    }
    if (input.NextToken !== undefined) {
        entries["NextToken"] = input.NextToken;
    }
    if (input.TransitGatewayAttachmentId !== undefined) {
        entries["TransitGatewayAttachmentId"] = input.TransitGatewayAttachmentId;
    }
    return entries;
};
const serializeAws_ec2GetTransitGatewayMulticastDomainAssociationsRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Filters !== undefined) {
        const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.MaxResults !== undefined) {
        entries["MaxResults"] = input.MaxResults;
    }
    if (input.NextToken !== undefined) {
        entries["NextToken"] = input.NextToken;
    }
    if (input.TransitGatewayMulticastDomainId !== undefined) {
        entries["TransitGatewayMulticastDomainId"] =
            input.TransitGatewayMulticastDomainId;
    }
    return entries;
};
const serializeAws_ec2GetTransitGatewayRouteTableAssociationsRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Filters !== undefined) {
        const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.MaxResults !== undefined) {
        entries["MaxResults"] = input.MaxResults;
    }
    if (input.NextToken !== undefined) {
        entries["NextToken"] = input.NextToken;
    }
    if (input.TransitGatewayRouteTableId !== undefined) {
        entries["TransitGatewayRouteTableId"] = input.TransitGatewayRouteTableId;
    }
    return entries;
};
const serializeAws_ec2GetTransitGatewayRouteTablePropagationsRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Filters !== undefined) {
        const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.MaxResults !== undefined) {
        entries["MaxResults"] = input.MaxResults;
    }
    if (input.NextToken !== undefined) {
        entries["NextToken"] = input.NextToken;
    }
    if (input.TransitGatewayRouteTableId !== undefined) {
        entries["TransitGatewayRouteTableId"] = input.TransitGatewayRouteTableId;
    }
    return entries;
};
const serializeAws_ec2GroupIdStringList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        entries[`GroupId.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const serializeAws_ec2GroupIdentifier = (input, context) => {
    const entries = {};
    if (input.GroupId !== undefined) {
        entries["GroupId"] = input.GroupId;
    }
    if (input.GroupName !== undefined) {
        entries["GroupName"] = input.GroupName;
    }
    return entries;
};
const serializeAws_ec2GroupIdentifierList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        const memberEntries = serializeAws_ec2GroupIdentifier(entry, context);
        Object.keys(memberEntries).forEach(key => {
            entries[`Item.${counter}.${key}`] = memberEntries[key];
        });
        counter++;
    }
    return entries;
};
const serializeAws_ec2GroupIds = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const serializeAws_ec2GroupNameStringList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        entries[`GroupName.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const serializeAws_ec2HibernationOptionsRequest = (input, context) => {
    const entries = {};
    if (input.Configured !== undefined) {
        entries["Configured"] = input.Configured;
    }
    return entries;
};
const serializeAws_ec2HostReservationIdSet = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const serializeAws_ec2IKEVersionsRequestList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        const memberEntries = serializeAws_ec2IKEVersionsRequestListValue(entry, context);
        Object.keys(memberEntries).forEach(key => {
            entries[`Item.${counter}.${key}`] = memberEntries[key];
        });
        counter++;
    }
    return entries;
};
const serializeAws_ec2IKEVersionsRequestListValue = (input, context) => {
    const entries = {};
    if (input.Value !== undefined) {
        entries["Value"] = input.Value;
    }
    return entries;
};
const serializeAws_ec2IamInstanceProfileSpecification = (input, context) => {
    const entries = {};
    if (input.Arn !== undefined) {
        entries["Arn"] = input.Arn;
    }
    if (input.Name !== undefined) {
        entries["Name"] = input.Name;
    }
    return entries;
};
const serializeAws_ec2IcmpTypeCode = (input, context) => {
    const entries = {};
    if (input.Code !== undefined) {
        entries["Code"] = input.Code;
    }
    if (input.Type !== undefined) {
        entries["Type"] = input.Type;
    }
    return entries;
};
const serializeAws_ec2ImageDiskContainer = (input, context) => {
    const entries = {};
    if (input.Description !== undefined) {
        entries["Description"] = input.Description;
    }
    if (input.DeviceName !== undefined) {
        entries["DeviceName"] = input.DeviceName;
    }
    if (input.Format !== undefined) {
        entries["Format"] = input.Format;
    }
    if (input.SnapshotId !== undefined) {
        entries["SnapshotId"] = input.SnapshotId;
    }
    if (input.Url !== undefined) {
        entries["Url"] = input.Url;
    }
    if (input.UserBucket !== undefined) {
        const memberEntries = serializeAws_ec2UserBucket(input.UserBucket, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `UserBucket.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2ImageDiskContainerList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        const memberEntries = serializeAws_ec2ImageDiskContainer(entry, context);
        Object.keys(memberEntries).forEach(key => {
            entries[`Item.${counter}.${key}`] = memberEntries[key];
        });
        counter++;
    }
    return entries;
};
const serializeAws_ec2ImageIdStringList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        entries[`ImageId.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const serializeAws_ec2ImportClientVpnClientCertificateRevocationListRequest = (input, context) => {
    const entries = {};
    if (input.CertificateRevocationList !== undefined) {
        entries["CertificateRevocationList"] = input.CertificateRevocationList;
    }
    if (input.ClientVpnEndpointId !== undefined) {
        entries["ClientVpnEndpointId"] = input.ClientVpnEndpointId;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    return entries;
};
const serializeAws_ec2ImportImageLicenseConfigurationRequest = (input, context) => {
    const entries = {};
    if (input.LicenseConfigurationArn !== undefined) {
        entries["LicenseConfigurationArn"] = input.LicenseConfigurationArn;
    }
    return entries;
};
const serializeAws_ec2ImportImageLicenseSpecificationListRequest = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        const memberEntries = serializeAws_ec2ImportImageLicenseConfigurationRequest(entry, context);
        Object.keys(memberEntries).forEach(key => {
            entries[`Item.${counter}.${key}`] = memberEntries[key];
        });
        counter++;
    }
    return entries;
};
const serializeAws_ec2ImportImageRequest = (input, context) => {
    const entries = {};
    if (input.Architecture !== undefined) {
        entries["Architecture"] = input.Architecture;
    }
    if (input.ClientData !== undefined) {
        const memberEntries = serializeAws_ec2ClientData(input.ClientData, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `ClientData.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.ClientToken !== undefined) {
        entries["ClientToken"] = input.ClientToken;
    }
    if (input.Description !== undefined) {
        entries["Description"] = input.Description;
    }
    if (input.DiskContainers !== undefined) {
        const memberEntries = serializeAws_ec2ImageDiskContainerList(input.DiskContainers, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `DiskContainer.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Encrypted !== undefined) {
        entries["Encrypted"] = input.Encrypted;
    }
    if (input.Hypervisor !== undefined) {
        entries["Hypervisor"] = input.Hypervisor;
    }
    if (input.KmsKeyId !== undefined) {
        entries["KmsKeyId"] = input.KmsKeyId;
    }
    if (input.LicenseSpecifications !== undefined) {
        const memberEntries = serializeAws_ec2ImportImageLicenseSpecificationListRequest(input.LicenseSpecifications, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `LicenseSpecifications.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.LicenseType !== undefined) {
        entries["LicenseType"] = input.LicenseType;
    }
    if (input.Platform !== undefined) {
        entries["Platform"] = input.Platform;
    }
    if (input.RoleName !== undefined) {
        entries["RoleName"] = input.RoleName;
    }
    return entries;
};
const serializeAws_ec2ImportInstanceLaunchSpecification = (input, context) => {
    const entries = {};
    if (input.AdditionalInfo !== undefined) {
        entries["AdditionalInfo"] = input.AdditionalInfo;
    }
    if (input.Architecture !== undefined) {
        entries["Architecture"] = input.Architecture;
    }
    if (input.GroupIds !== undefined) {
        const memberEntries = serializeAws_ec2SecurityGroupIdStringList(input.GroupIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `GroupId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.GroupNames !== undefined) {
        const memberEntries = serializeAws_ec2SecurityGroupStringList(input.GroupNames, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `GroupName.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.InstanceInitiatedShutdownBehavior !== undefined) {
        entries["InstanceInitiatedShutdownBehavior"] =
            input.InstanceInitiatedShutdownBehavior;
    }
    if (input.InstanceType !== undefined) {
        entries["InstanceType"] = input.InstanceType;
    }
    if (input.Monitoring !== undefined) {
        entries["Monitoring"] = input.Monitoring;
    }
    if (input.Placement !== undefined) {
        const memberEntries = serializeAws_ec2Placement(input.Placement, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Placement.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.PrivateIpAddress !== undefined) {
        entries["PrivateIpAddress"] = input.PrivateIpAddress;
    }
    if (input.SubnetId !== undefined) {
        entries["SubnetId"] = input.SubnetId;
    }
    if (input.UserData !== undefined) {
        const memberEntries = serializeAws_ec2UserData(input.UserData, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `UserData.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2ImportInstanceRequest = (input, context) => {
    const entries = {};
    if (input.Description !== undefined) {
        entries["Description"] = input.Description;
    }
    if (input.DiskImages !== undefined) {
        const memberEntries = serializeAws_ec2DiskImageList(input.DiskImages, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `DiskImage.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.LaunchSpecification !== undefined) {
        const memberEntries = serializeAws_ec2ImportInstanceLaunchSpecification(input.LaunchSpecification, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `LaunchSpecification.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.Platform !== undefined) {
        entries["Platform"] = input.Platform;
    }
    return entries;
};
const serializeAws_ec2ImportKeyPairRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.KeyName !== undefined) {
        entries["KeyName"] = input.KeyName;
    }
    if (input.PublicKeyMaterial !== undefined) {
        entries["PublicKeyMaterial"] = context.base64Encoder(input.PublicKeyMaterial);
    }
    return entries;
};
const serializeAws_ec2ImportSnapshotRequest = (input, context) => {
    const entries = {};
    if (input.ClientData !== undefined) {
        const memberEntries = serializeAws_ec2ClientData(input.ClientData, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `ClientData.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.ClientToken !== undefined) {
        entries["ClientToken"] = input.ClientToken;
    }
    if (input.Description !== undefined) {
        entries["Description"] = input.Description;
    }
    if (input.DiskContainer !== undefined) {
        const memberEntries = serializeAws_ec2SnapshotDiskContainer(input.DiskContainer, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `DiskContainer.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Encrypted !== undefined) {
        entries["Encrypted"] = input.Encrypted;
    }
    if (input.KmsKeyId !== undefined) {
        entries["KmsKeyId"] = input.KmsKeyId;
    }
    if (input.RoleName !== undefined) {
        entries["RoleName"] = input.RoleName;
    }
    return entries;
};
const serializeAws_ec2ImportTaskIdList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        entries[`ImportTaskId.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const serializeAws_ec2ImportVolumeRequest = (input, context) => {
    const entries = {};
    if (input.AvailabilityZone !== undefined) {
        entries["AvailabilityZone"] = input.AvailabilityZone;
    }
    if (input.Description !== undefined) {
        entries["Description"] = input.Description;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Image !== undefined) {
        const memberEntries = serializeAws_ec2DiskImageDetail(input.Image, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Image.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.Volume !== undefined) {
        const memberEntries = serializeAws_ec2VolumeDetail(input.Volume, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Volume.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2InstanceBlockDeviceMappingSpecification = (input, context) => {
    const entries = {};
    if (input.DeviceName !== undefined) {
        entries["DeviceName"] = input.DeviceName;
    }
    if (input.Ebs !== undefined) {
        const memberEntries = serializeAws_ec2EbsInstanceBlockDeviceSpecification(input.Ebs, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Ebs.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.NoDevice !== undefined) {
        entries["NoDevice"] = input.NoDevice;
    }
    if (input.VirtualName !== undefined) {
        entries["VirtualName"] = input.VirtualName;
    }
    return entries;
};
const serializeAws_ec2InstanceBlockDeviceMappingSpecificationList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        const memberEntries = serializeAws_ec2InstanceBlockDeviceMappingSpecification(entry, context);
        Object.keys(memberEntries).forEach(key => {
            entries[`Item.${counter}.${key}`] = memberEntries[key];
        });
        counter++;
    }
    return entries;
};
const serializeAws_ec2InstanceCreditSpecificationListRequest = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        const memberEntries = serializeAws_ec2InstanceCreditSpecificationRequest(entry, context);
        Object.keys(memberEntries).forEach(key => {
            entries[`Item.${counter}.${key}`] = memberEntries[key];
        });
        counter++;
    }
    return entries;
};
const serializeAws_ec2InstanceCreditSpecificationRequest = (input, context) => {
    const entries = {};
    if (input.CpuCredits !== undefined) {
        entries["CpuCredits"] = input.CpuCredits;
    }
    if (input.InstanceId !== undefined) {
        entries["InstanceId"] = input.InstanceId;
    }
    return entries;
};
const serializeAws_ec2InstanceIdStringList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        entries[`InstanceId.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const serializeAws_ec2InstanceIpv6Address = (input, context) => {
    const entries = {};
    if (input.Ipv6Address !== undefined) {
        entries["Ipv6Address"] = input.Ipv6Address;
    }
    return entries;
};
const serializeAws_ec2InstanceIpv6AddressList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        const memberEntries = serializeAws_ec2InstanceIpv6Address(entry, context);
        Object.keys(memberEntries).forEach(key => {
            entries[`Item.${counter}.${key}`] = memberEntries[key];
        });
        counter++;
    }
    return entries;
};
const serializeAws_ec2InstanceIpv6AddressListRequest = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        const memberEntries = serializeAws_ec2InstanceIpv6AddressRequest(entry, context);
        Object.keys(memberEntries).forEach(key => {
            entries[`InstanceIpv6Address.${counter}.${key}`] = memberEntries[key];
        });
        counter++;
    }
    return entries;
};
const serializeAws_ec2InstanceIpv6AddressRequest = (input, context) => {
    const entries = {};
    if (input.Ipv6Address !== undefined) {
        entries["Ipv6Address"] = input.Ipv6Address;
    }
    return entries;
};
const serializeAws_ec2InstanceMarketOptionsRequest = (input, context) => {
    const entries = {};
    if (input.MarketType !== undefined) {
        entries["MarketType"] = input.MarketType;
    }
    if (input.SpotOptions !== undefined) {
        const memberEntries = serializeAws_ec2SpotMarketOptions(input.SpotOptions, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `SpotOptions.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2InstanceMetadataOptionsRequest = (input, context) => {
    const entries = {};
    if (input.HttpEndpoint !== undefined) {
        entries["HttpEndpoint"] = input.HttpEndpoint;
    }
    if (input.HttpPutResponseHopLimit !== undefined) {
        entries["HttpPutResponseHopLimit"] = input.HttpPutResponseHopLimit;
    }
    if (input.HttpTokens !== undefined) {
        entries["HttpTokens"] = input.HttpTokens;
    }
    return entries;
};
const serializeAws_ec2InstanceNetworkInterfaceSpecification = (input, context) => {
    const entries = {};
    if (input.AssociatePublicIpAddress !== undefined) {
        entries["AssociatePublicIpAddress"] = input.AssociatePublicIpAddress;
    }
    if (input.DeleteOnTermination !== undefined) {
        entries["DeleteOnTermination"] = input.DeleteOnTermination;
    }
    if (input.Description !== undefined) {
        entries["Description"] = input.Description;
    }
    if (input.DeviceIndex !== undefined) {
        entries["DeviceIndex"] = input.DeviceIndex;
    }
    if (input.Groups !== undefined) {
        const memberEntries = serializeAws_ec2SecurityGroupIdStringList(input.Groups, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `SecurityGroupId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.InterfaceType !== undefined) {
        entries["InterfaceType"] = input.InterfaceType;
    }
    if (input.Ipv6AddressCount !== undefined) {
        entries["Ipv6AddressCount"] = input.Ipv6AddressCount;
    }
    if (input.Ipv6Addresses !== undefined) {
        const memberEntries = serializeAws_ec2InstanceIpv6AddressList(input.Ipv6Addresses, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Ipv6Addresses.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.NetworkInterfaceId !== undefined) {
        entries["NetworkInterfaceId"] = input.NetworkInterfaceId;
    }
    if (input.PrivateIpAddress !== undefined) {
        entries["PrivateIpAddress"] = input.PrivateIpAddress;
    }
    if (input.PrivateIpAddresses !== undefined) {
        const memberEntries = serializeAws_ec2PrivateIpAddressSpecificationList(input.PrivateIpAddresses, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `PrivateIpAddresses.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.SecondaryPrivateIpAddressCount !== undefined) {
        entries["SecondaryPrivateIpAddressCount"] =
            input.SecondaryPrivateIpAddressCount;
    }
    if (input.SubnetId !== undefined) {
        entries["SubnetId"] = input.SubnetId;
    }
    return entries;
};
const serializeAws_ec2InstanceNetworkInterfaceSpecificationList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        const memberEntries = serializeAws_ec2InstanceNetworkInterfaceSpecification(entry, context);
        Object.keys(memberEntries).forEach(key => {
            entries[`Item.${counter}.${key}`] = memberEntries[key];
        });
        counter++;
    }
    return entries;
};
const serializeAws_ec2InstanceSpecification = (input, context) => {
    const entries = {};
    if (input.ExcludeBootVolume !== undefined) {
        entries["ExcludeBootVolume"] = input.ExcludeBootVolume;
    }
    if (input.InstanceId !== undefined) {
        entries["InstanceId"] = input.InstanceId;
    }
    return entries;
};
const serializeAws_ec2InstanceTypeList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        entries[`Member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const serializeAws_ec2IpPermission = (input, context) => {
    const entries = {};
    if (input.FromPort !== undefined) {
        entries["FromPort"] = input.FromPort;
    }
    if (input.IpProtocol !== undefined) {
        entries["IpProtocol"] = input.IpProtocol;
    }
    if (input.IpRanges !== undefined) {
        const memberEntries = serializeAws_ec2IpRangeList(input.IpRanges, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `IpRanges.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.Ipv6Ranges !== undefined) {
        const memberEntries = serializeAws_ec2Ipv6RangeList(input.Ipv6Ranges, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Ipv6Ranges.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.PrefixListIds !== undefined) {
        const memberEntries = serializeAws_ec2PrefixListIdList(input.PrefixListIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `PrefixListIds.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.ToPort !== undefined) {
        entries["ToPort"] = input.ToPort;
    }
    if (input.UserIdGroupPairs !== undefined) {
        const memberEntries = serializeAws_ec2UserIdGroupPairList(input.UserIdGroupPairs, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Groups.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2IpPermissionList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        const memberEntries = serializeAws_ec2IpPermission(entry, context);
        Object.keys(memberEntries).forEach(key => {
            entries[`Item.${counter}.${key}`] = memberEntries[key];
        });
        counter++;
    }
    return entries;
};
const serializeAws_ec2IpRange = (input, context) => {
    const entries = {};
    if (input.CidrIp !== undefined) {
        entries["CidrIp"] = input.CidrIp;
    }
    if (input.Description !== undefined) {
        entries["Description"] = input.Description;
    }
    return entries;
};
const serializeAws_ec2IpRangeList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        const memberEntries = serializeAws_ec2IpRange(entry, context);
        Object.keys(memberEntries).forEach(key => {
            entries[`Item.${counter}.${key}`] = memberEntries[key];
        });
        counter++;
    }
    return entries;
};
const serializeAws_ec2Ipv6AddressList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const serializeAws_ec2Ipv6Range = (input, context) => {
    const entries = {};
    if (input.CidrIpv6 !== undefined) {
        entries["CidrIpv6"] = input.CidrIpv6;
    }
    if (input.Description !== undefined) {
        entries["Description"] = input.Description;
    }
    return entries;
};
const serializeAws_ec2Ipv6RangeList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        const memberEntries = serializeAws_ec2Ipv6Range(entry, context);
        Object.keys(memberEntries).forEach(key => {
            entries[`Item.${counter}.${key}`] = memberEntries[key];
        });
        counter++;
    }
    return entries;
};
const serializeAws_ec2KeyNameStringList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        entries[`KeyName.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const serializeAws_ec2KeyPairIdStringList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        entries[`KeyPairId.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const serializeAws_ec2LaunchPermission = (input, context) => {
    const entries = {};
    if (input.Group !== undefined) {
        entries["Group"] = input.Group;
    }
    if (input.UserId !== undefined) {
        entries["UserId"] = input.UserId;
    }
    return entries;
};
const serializeAws_ec2LaunchPermissionList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        const memberEntries = serializeAws_ec2LaunchPermission(entry, context);
        Object.keys(memberEntries).forEach(key => {
            entries[`Item.${counter}.${key}`] = memberEntries[key];
        });
        counter++;
    }
    return entries;
};
const serializeAws_ec2LaunchPermissionModifications = (input, context) => {
    const entries = {};
    if (input.Add !== undefined) {
        const memberEntries = serializeAws_ec2LaunchPermissionList(input.Add, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Add.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.Remove !== undefined) {
        const memberEntries = serializeAws_ec2LaunchPermissionList(input.Remove, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Remove.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2LaunchSpecsList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        const memberEntries = serializeAws_ec2SpotFleetLaunchSpecification(entry, context);
        Object.keys(memberEntries).forEach(key => {
            entries[`Item.${counter}.${key}`] = memberEntries[key];
        });
        counter++;
    }
    return entries;
};
const serializeAws_ec2LaunchTemplateBlockDeviceMappingRequest = (input, context) => {
    const entries = {};
    if (input.DeviceName !== undefined) {
        entries["DeviceName"] = input.DeviceName;
    }
    if (input.Ebs !== undefined) {
        const memberEntries = serializeAws_ec2LaunchTemplateEbsBlockDeviceRequest(input.Ebs, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Ebs.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.NoDevice !== undefined) {
        entries["NoDevice"] = input.NoDevice;
    }
    if (input.VirtualName !== undefined) {
        entries["VirtualName"] = input.VirtualName;
    }
    return entries;
};
const serializeAws_ec2LaunchTemplateBlockDeviceMappingRequestList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        const memberEntries = serializeAws_ec2LaunchTemplateBlockDeviceMappingRequest(entry, context);
        Object.keys(memberEntries).forEach(key => {
            entries[`BlockDeviceMapping.${counter}.${key}`] = memberEntries[key];
        });
        counter++;
    }
    return entries;
};
const serializeAws_ec2LaunchTemplateCapacityReservationSpecificationRequest = (input, context) => {
    const entries = {};
    if (input.CapacityReservationPreference !== undefined) {
        entries["CapacityReservationPreference"] =
            input.CapacityReservationPreference;
    }
    if (input.CapacityReservationTarget !== undefined) {
        const memberEntries = serializeAws_ec2CapacityReservationTarget(input.CapacityReservationTarget, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `CapacityReservationTarget.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2LaunchTemplateConfig = (input, context) => {
    const entries = {};
    if (input.LaunchTemplateSpecification !== undefined) {
        const memberEntries = serializeAws_ec2FleetLaunchTemplateSpecification(input.LaunchTemplateSpecification, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `LaunchTemplateSpecification.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.Overrides !== undefined) {
        const memberEntries = serializeAws_ec2LaunchTemplateOverridesList(input.Overrides, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Overrides.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2LaunchTemplateConfigList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        const memberEntries = serializeAws_ec2LaunchTemplateConfig(entry, context);
        Object.keys(memberEntries).forEach(key => {
            entries[`Item.${counter}.${key}`] = memberEntries[key];
        });
        counter++;
    }
    return entries;
};
const serializeAws_ec2LaunchTemplateCpuOptionsRequest = (input, context) => {
    const entries = {};
    if (input.CoreCount !== undefined) {
        entries["CoreCount"] = input.CoreCount;
    }
    if (input.ThreadsPerCore !== undefined) {
        entries["ThreadsPerCore"] = input.ThreadsPerCore;
    }
    return entries;
};
const serializeAws_ec2LaunchTemplateEbsBlockDeviceRequest = (input, context) => {
    const entries = {};
    if (input.DeleteOnTermination !== undefined) {
        entries["DeleteOnTermination"] = input.DeleteOnTermination;
    }
    if (input.Encrypted !== undefined) {
        entries["Encrypted"] = input.Encrypted;
    }
    if (input.Iops !== undefined) {
        entries["Iops"] = input.Iops;
    }
    if (input.KmsKeyId !== undefined) {
        entries["KmsKeyId"] = input.KmsKeyId;
    }
    if (input.SnapshotId !== undefined) {
        entries["SnapshotId"] = input.SnapshotId;
    }
    if (input.VolumeSize !== undefined) {
        entries["VolumeSize"] = input.VolumeSize;
    }
    if (input.VolumeType !== undefined) {
        entries["VolumeType"] = input.VolumeType;
    }
    return entries;
};
const serializeAws_ec2LaunchTemplateElasticInferenceAccelerator = (input, context) => {
    const entries = {};
    if (input.Count !== undefined) {
        entries["Count"] = input.Count;
    }
    if (input.Type !== undefined) {
        entries["Type"] = input.Type;
    }
    return entries;
};
const serializeAws_ec2LaunchTemplateElasticInferenceAcceleratorList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        const memberEntries = serializeAws_ec2LaunchTemplateElasticInferenceAccelerator(entry, context);
        Object.keys(memberEntries).forEach(key => {
            entries[`Item.${counter}.${key}`] = memberEntries[key];
        });
        counter++;
    }
    return entries;
};
const serializeAws_ec2LaunchTemplateHibernationOptionsRequest = (input, context) => {
    const entries = {};
    if (input.Configured !== undefined) {
        entries["Configured"] = input.Configured;
    }
    return entries;
};
const serializeAws_ec2LaunchTemplateIamInstanceProfileSpecificationRequest = (input, context) => {
    const entries = {};
    if (input.Arn !== undefined) {
        entries["Arn"] = input.Arn;
    }
    if (input.Name !== undefined) {
        entries["Name"] = input.Name;
    }
    return entries;
};
const serializeAws_ec2LaunchTemplateInstanceMarketOptionsRequest = (input, context) => {
    const entries = {};
    if (input.MarketType !== undefined) {
        entries["MarketType"] = input.MarketType;
    }
    if (input.SpotOptions !== undefined) {
        const memberEntries = serializeAws_ec2LaunchTemplateSpotMarketOptionsRequest(input.SpotOptions, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `SpotOptions.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2LaunchTemplateInstanceMetadataOptionsRequest = (input, context) => {
    const entries = {};
    if (input.HttpEndpoint !== undefined) {
        entries["HttpEndpoint"] = input.HttpEndpoint;
    }
    if (input.HttpPutResponseHopLimit !== undefined) {
        entries["HttpPutResponseHopLimit"] = input.HttpPutResponseHopLimit;
    }
    if (input.HttpTokens !== undefined) {
        entries["HttpTokens"] = input.HttpTokens;
    }
    return entries;
};
const serializeAws_ec2LaunchTemplateInstanceNetworkInterfaceSpecificationRequest = (input, context) => {
    const entries = {};
    if (input.AssociatePublicIpAddress !== undefined) {
        entries["AssociatePublicIpAddress"] = input.AssociatePublicIpAddress;
    }
    if (input.DeleteOnTermination !== undefined) {
        entries["DeleteOnTermination"] = input.DeleteOnTermination;
    }
    if (input.Description !== undefined) {
        entries["Description"] = input.Description;
    }
    if (input.DeviceIndex !== undefined) {
        entries["DeviceIndex"] = input.DeviceIndex;
    }
    if (input.Groups !== undefined) {
        const memberEntries = serializeAws_ec2SecurityGroupIdStringList(input.Groups, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `SecurityGroupId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.InterfaceType !== undefined) {
        entries["InterfaceType"] = input.InterfaceType;
    }
    if (input.Ipv6AddressCount !== undefined) {
        entries["Ipv6AddressCount"] = input.Ipv6AddressCount;
    }
    if (input.Ipv6Addresses !== undefined) {
        const memberEntries = serializeAws_ec2InstanceIpv6AddressListRequest(input.Ipv6Addresses, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Ipv6Addresses.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.NetworkInterfaceId !== undefined) {
        entries["NetworkInterfaceId"] = input.NetworkInterfaceId;
    }
    if (input.PrivateIpAddress !== undefined) {
        entries["PrivateIpAddress"] = input.PrivateIpAddress;
    }
    if (input.PrivateIpAddresses !== undefined) {
        const memberEntries = serializeAws_ec2PrivateIpAddressSpecificationList(input.PrivateIpAddresses, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `PrivateIpAddresses.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.SecondaryPrivateIpAddressCount !== undefined) {
        entries["SecondaryPrivateIpAddressCount"] =
            input.SecondaryPrivateIpAddressCount;
    }
    if (input.SubnetId !== undefined) {
        entries["SubnetId"] = input.SubnetId;
    }
    return entries;
};
const serializeAws_ec2LaunchTemplateInstanceNetworkInterfaceSpecificationRequestList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        const memberEntries = serializeAws_ec2LaunchTemplateInstanceNetworkInterfaceSpecificationRequest(entry, context);
        Object.keys(memberEntries).forEach(key => {
            entries[`InstanceNetworkInterfaceSpecification.${counter}.${key}`] =
                memberEntries[key];
        });
        counter++;
    }
    return entries;
};
const serializeAws_ec2LaunchTemplateLicenseConfigurationRequest = (input, context) => {
    const entries = {};
    if (input.LicenseConfigurationArn !== undefined) {
        entries["LicenseConfigurationArn"] = input.LicenseConfigurationArn;
    }
    return entries;
};
const serializeAws_ec2LaunchTemplateLicenseSpecificationListRequest = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        const memberEntries = serializeAws_ec2LaunchTemplateLicenseConfigurationRequest(entry, context);
        Object.keys(memberEntries).forEach(key => {
            entries[`Item.${counter}.${key}`] = memberEntries[key];
        });
        counter++;
    }
    return entries;
};
const serializeAws_ec2LaunchTemplateNameStringList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const serializeAws_ec2LaunchTemplateOverrides = (input, context) => {
    const entries = {};
    if (input.AvailabilityZone !== undefined) {
        entries["AvailabilityZone"] = input.AvailabilityZone;
    }
    if (input.InstanceType !== undefined) {
        entries["InstanceType"] = input.InstanceType;
    }
    if (input.Priority !== undefined) {
        entries["Priority"] = input.Priority;
    }
    if (input.SpotPrice !== undefined) {
        entries["SpotPrice"] = input.SpotPrice;
    }
    if (input.SubnetId !== undefined) {
        entries["SubnetId"] = input.SubnetId;
    }
    if (input.WeightedCapacity !== undefined) {
        entries["WeightedCapacity"] = input.WeightedCapacity;
    }
    return entries;
};
const serializeAws_ec2LaunchTemplateOverridesList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        const memberEntries = serializeAws_ec2LaunchTemplateOverrides(entry, context);
        Object.keys(memberEntries).forEach(key => {
            entries[`Item.${counter}.${key}`] = memberEntries[key];
        });
        counter++;
    }
    return entries;
};
const serializeAws_ec2LaunchTemplatePlacementRequest = (input, context) => {
    const entries = {};
    if (input.Affinity !== undefined) {
        entries["Affinity"] = input.Affinity;
    }
    if (input.AvailabilityZone !== undefined) {
        entries["AvailabilityZone"] = input.AvailabilityZone;
    }
    if (input.GroupName !== undefined) {
        entries["GroupName"] = input.GroupName;
    }
    if (input.HostId !== undefined) {
        entries["HostId"] = input.HostId;
    }
    if (input.HostResourceGroupArn !== undefined) {
        entries["HostResourceGroupArn"] = input.HostResourceGroupArn;
    }
    if (input.PartitionNumber !== undefined) {
        entries["PartitionNumber"] = input.PartitionNumber;
    }
    if (input.SpreadDomain !== undefined) {
        entries["SpreadDomain"] = input.SpreadDomain;
    }
    if (input.Tenancy !== undefined) {
        entries["Tenancy"] = input.Tenancy;
    }
    return entries;
};
const serializeAws_ec2LaunchTemplateSpecification = (input, context) => {
    const entries = {};
    if (input.LaunchTemplateId !== undefined) {
        entries["LaunchTemplateId"] = input.LaunchTemplateId;
    }
    if (input.LaunchTemplateName !== undefined) {
        entries["LaunchTemplateName"] = input.LaunchTemplateName;
    }
    if (input.Version !== undefined) {
        entries["Version"] = input.Version;
    }
    return entries;
};
const serializeAws_ec2LaunchTemplateSpotMarketOptionsRequest = (input, context) => {
    const entries = {};
    if (input.BlockDurationMinutes !== undefined) {
        entries["BlockDurationMinutes"] = input.BlockDurationMinutes;
    }
    if (input.InstanceInterruptionBehavior !== undefined) {
        entries["InstanceInterruptionBehavior"] =
            input.InstanceInterruptionBehavior;
    }
    if (input.MaxPrice !== undefined) {
        entries["MaxPrice"] = input.MaxPrice;
    }
    if (input.SpotInstanceType !== undefined) {
        entries["SpotInstanceType"] = input.SpotInstanceType;
    }
    if (input.ValidUntil !== undefined) {
        entries["ValidUntil"] = input.ValidUntil.toISOString().split(".")[0] + "Z";
    }
    return entries;
};
const serializeAws_ec2LaunchTemplateTagSpecificationRequest = (input, context) => {
    const entries = {};
    if (input.ResourceType !== undefined) {
        entries["ResourceType"] = input.ResourceType;
    }
    if (input.Tags !== undefined) {
        const memberEntries = serializeAws_ec2TagList(input.Tags, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Tag.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2LaunchTemplateTagSpecificationRequestList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        const memberEntries = serializeAws_ec2LaunchTemplateTagSpecificationRequest(entry, context);
        Object.keys(memberEntries).forEach(key => {
            entries[`LaunchTemplateTagSpecificationRequest.${counter}.${key}`] =
                memberEntries[key];
        });
        counter++;
    }
    return entries;
};
const serializeAws_ec2LaunchTemplatesMonitoringRequest = (input, context) => {
    const entries = {};
    if (input.Enabled !== undefined) {
        entries["Enabled"] = input.Enabled;
    }
    return entries;
};
const serializeAws_ec2LicenseConfigurationRequest = (input, context) => {
    const entries = {};
    if (input.LicenseConfigurationArn !== undefined) {
        entries["LicenseConfigurationArn"] = input.LicenseConfigurationArn;
    }
    return entries;
};
const serializeAws_ec2LicenseSpecificationListRequest = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        const memberEntries = serializeAws_ec2LicenseConfigurationRequest(entry, context);
        Object.keys(memberEntries).forEach(key => {
            entries[`Item.${counter}.${key}`] = memberEntries[key];
        });
        counter++;
    }
    return entries;
};
const serializeAws_ec2LoadBalancersConfig = (input, context) => {
    const entries = {};
    if (input.ClassicLoadBalancersConfig !== undefined) {
        const memberEntries = serializeAws_ec2ClassicLoadBalancersConfig(input.ClassicLoadBalancersConfig, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `ClassicLoadBalancersConfig.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.TargetGroupsConfig !== undefined) {
        const memberEntries = serializeAws_ec2TargetGroupsConfig(input.TargetGroupsConfig, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `TargetGroupsConfig.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2LoadPermissionListRequest = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        const memberEntries = serializeAws_ec2LoadPermissionRequest(entry, context);
        Object.keys(memberEntries).forEach(key => {
            entries[`Item.${counter}.${key}`] = memberEntries[key];
        });
        counter++;
    }
    return entries;
};
const serializeAws_ec2LoadPermissionModifications = (input, context) => {
    const entries = {};
    if (input.Add !== undefined) {
        const memberEntries = serializeAws_ec2LoadPermissionListRequest(input.Add, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Add.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.Remove !== undefined) {
        const memberEntries = serializeAws_ec2LoadPermissionListRequest(input.Remove, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Remove.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2LoadPermissionRequest = (input, context) => {
    const entries = {};
    if (input.Group !== undefined) {
        entries["Group"] = input.Group;
    }
    if (input.UserId !== undefined) {
        entries["UserId"] = input.UserId;
    }
    return entries;
};
const serializeAws_ec2LocalGatewayIdSet = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const serializeAws_ec2LocalGatewayRouteTableIdSet = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const serializeAws_ec2LocalGatewayRouteTableVirtualInterfaceGroupAssociationIdSet = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const serializeAws_ec2LocalGatewayRouteTableVpcAssociationIdSet = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const serializeAws_ec2LocalGatewayVirtualInterfaceGroupIdSet = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const serializeAws_ec2LocalGatewayVirtualInterfaceIdSet = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const serializeAws_ec2ModifyCapacityReservationRequest = (input, context) => {
    const entries = {};
    if (input.CapacityReservationId !== undefined) {
        entries["CapacityReservationId"] = input.CapacityReservationId;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.EndDate !== undefined) {
        entries["EndDate"] = input.EndDate.toISOString().split(".")[0] + "Z";
    }
    if (input.EndDateType !== undefined) {
        entries["EndDateType"] = input.EndDateType;
    }
    if (input.InstanceCount !== undefined) {
        entries["InstanceCount"] = input.InstanceCount;
    }
    return entries;
};
const serializeAws_ec2ModifyClientVpnEndpointRequest = (input, context) => {
    const entries = {};
    if (input.ClientVpnEndpointId !== undefined) {
        entries["ClientVpnEndpointId"] = input.ClientVpnEndpointId;
    }
    if (input.ConnectionLogOptions !== undefined) {
        const memberEntries = serializeAws_ec2ConnectionLogOptions(input.ConnectionLogOptions, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `ConnectionLogOptions.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.Description !== undefined) {
        entries["Description"] = input.Description;
    }
    if (input.DnsServers !== undefined) {
        const memberEntries = serializeAws_ec2DnsServersOptionsModifyStructure(input.DnsServers, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `DnsServers.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.ServerCertificateArn !== undefined) {
        entries["ServerCertificateArn"] = input.ServerCertificateArn;
    }
    if (input.SplitTunnel !== undefined) {
        entries["SplitTunnel"] = input.SplitTunnel;
    }
    if (input.VpnPort !== undefined) {
        entries["VpnPort"] = input.VpnPort;
    }
    return entries;
};
const serializeAws_ec2ModifyDefaultCreditSpecificationRequest = (input, context) => {
    const entries = {};
    if (input.CpuCredits !== undefined) {
        entries["CpuCredits"] = input.CpuCredits;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.InstanceFamily !== undefined) {
        entries["InstanceFamily"] = input.InstanceFamily;
    }
    return entries;
};
const serializeAws_ec2ModifyEbsDefaultKmsKeyIdRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.KmsKeyId !== undefined) {
        entries["KmsKeyId"] = input.KmsKeyId;
    }
    return entries;
};
const serializeAws_ec2ModifyFleetRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.ExcessCapacityTerminationPolicy !== undefined) {
        entries["ExcessCapacityTerminationPolicy"] =
            input.ExcessCapacityTerminationPolicy;
    }
    if (input.FleetId !== undefined) {
        entries["FleetId"] = input.FleetId;
    }
    if (input.TargetCapacitySpecification !== undefined) {
        const memberEntries = serializeAws_ec2TargetCapacitySpecificationRequest(input.TargetCapacitySpecification, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `TargetCapacitySpecification.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2ModifyFpgaImageAttributeRequest = (input, context) => {
    const entries = {};
    if (input.Attribute !== undefined) {
        entries["Attribute"] = input.Attribute;
    }
    if (input.Description !== undefined) {
        entries["Description"] = input.Description;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.FpgaImageId !== undefined) {
        entries["FpgaImageId"] = input.FpgaImageId;
    }
    if (input.LoadPermission !== undefined) {
        const memberEntries = serializeAws_ec2LoadPermissionModifications(input.LoadPermission, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `LoadPermission.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.Name !== undefined) {
        entries["Name"] = input.Name;
    }
    if (input.OperationType !== undefined) {
        entries["OperationType"] = input.OperationType;
    }
    if (input.ProductCodes !== undefined) {
        const memberEntries = serializeAws_ec2ProductCodeStringList(input.ProductCodes, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `ProductCode.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.UserGroups !== undefined) {
        const memberEntries = serializeAws_ec2UserGroupStringList(input.UserGroups, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `UserGroup.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.UserIds !== undefined) {
        const memberEntries = serializeAws_ec2UserIdStringList(input.UserIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `UserId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2ModifyHostsRequest = (input, context) => {
    const entries = {};
    if (input.AutoPlacement !== undefined) {
        entries["AutoPlacement"] = input.AutoPlacement;
    }
    if (input.HostIds !== undefined) {
        const memberEntries = serializeAws_ec2RequestHostIdList(input.HostIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `HostId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.HostRecovery !== undefined) {
        entries["HostRecovery"] = input.HostRecovery;
    }
    if (input.InstanceFamily !== undefined) {
        entries["InstanceFamily"] = input.InstanceFamily;
    }
    if (input.InstanceType !== undefined) {
        entries["InstanceType"] = input.InstanceType;
    }
    return entries;
};
const serializeAws_ec2ModifyIdFormatRequest = (input, context) => {
    const entries = {};
    if (input.Resource !== undefined) {
        entries["Resource"] = input.Resource;
    }
    if (input.UseLongIds !== undefined) {
        entries["UseLongIds"] = input.UseLongIds;
    }
    return entries;
};
const serializeAws_ec2ModifyIdentityIdFormatRequest = (input, context) => {
    const entries = {};
    if (input.PrincipalArn !== undefined) {
        entries["PrincipalArn"] = input.PrincipalArn;
    }
    if (input.Resource !== undefined) {
        entries["Resource"] = input.Resource;
    }
    if (input.UseLongIds !== undefined) {
        entries["UseLongIds"] = input.UseLongIds;
    }
    return entries;
};
const serializeAws_ec2ModifyImageAttributeRequest = (input, context) => {
    const entries = {};
    if (input.Attribute !== undefined) {
        entries["Attribute"] = input.Attribute;
    }
    if (input.Description !== undefined) {
        const memberEntries = serializeAws_ec2AttributeValue(input.Description, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Description.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.ImageId !== undefined) {
        entries["ImageId"] = input.ImageId;
    }
    if (input.LaunchPermission !== undefined) {
        const memberEntries = serializeAws_ec2LaunchPermissionModifications(input.LaunchPermission, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `LaunchPermission.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.OperationType !== undefined) {
        entries["OperationType"] = input.OperationType;
    }
    if (input.ProductCodes !== undefined) {
        const memberEntries = serializeAws_ec2ProductCodeStringList(input.ProductCodes, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `ProductCode.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.UserGroups !== undefined) {
        const memberEntries = serializeAws_ec2UserGroupStringList(input.UserGroups, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `UserGroup.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.UserIds !== undefined) {
        const memberEntries = serializeAws_ec2UserIdStringList(input.UserIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `UserId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.Value !== undefined) {
        entries["Value"] = input.Value;
    }
    return entries;
};
const serializeAws_ec2ModifyInstanceAttributeRequest = (input, context) => {
    const entries = {};
    if (input.Attribute !== undefined) {
        entries["Attribute"] = input.Attribute;
    }
    if (input.BlockDeviceMappings !== undefined) {
        const memberEntries = serializeAws_ec2InstanceBlockDeviceMappingSpecificationList(input.BlockDeviceMappings, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `BlockDeviceMapping.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.DisableApiTermination !== undefined) {
        const memberEntries = serializeAws_ec2AttributeBooleanValue(input.DisableApiTermination, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `DisableApiTermination.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.EbsOptimized !== undefined) {
        const memberEntries = serializeAws_ec2AttributeBooleanValue(input.EbsOptimized, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `EbsOptimized.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.EnaSupport !== undefined) {
        const memberEntries = serializeAws_ec2AttributeBooleanValue(input.EnaSupport, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `EnaSupport.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.Groups !== undefined) {
        const memberEntries = serializeAws_ec2GroupIdStringList(input.Groups, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `GroupId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.InstanceId !== undefined) {
        entries["InstanceId"] = input.InstanceId;
    }
    if (input.InstanceInitiatedShutdownBehavior !== undefined) {
        const memberEntries = serializeAws_ec2AttributeValue(input.InstanceInitiatedShutdownBehavior, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `InstanceInitiatedShutdownBehavior.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.InstanceType !== undefined) {
        const memberEntries = serializeAws_ec2AttributeValue(input.InstanceType, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `InstanceType.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.Kernel !== undefined) {
        const memberEntries = serializeAws_ec2AttributeValue(input.Kernel, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Kernel.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.Ramdisk !== undefined) {
        const memberEntries = serializeAws_ec2AttributeValue(input.Ramdisk, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Ramdisk.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.SourceDestCheck !== undefined) {
        const memberEntries = serializeAws_ec2AttributeBooleanValue(input.SourceDestCheck, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `SourceDestCheck.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.SriovNetSupport !== undefined) {
        const memberEntries = serializeAws_ec2AttributeValue(input.SriovNetSupport, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `SriovNetSupport.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.UserData !== undefined) {
        const memberEntries = serializeAws_ec2BlobAttributeValue(input.UserData, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `UserData.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.Value !== undefined) {
        entries["Value"] = input.Value;
    }
    return entries;
};
const serializeAws_ec2ModifyInstanceCapacityReservationAttributesRequest = (input, context) => {
    const entries = {};
    if (input.CapacityReservationSpecification !== undefined) {
        const memberEntries = serializeAws_ec2CapacityReservationSpecification(input.CapacityReservationSpecification, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `CapacityReservationSpecification.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.InstanceId !== undefined) {
        entries["InstanceId"] = input.InstanceId;
    }
    return entries;
};
const serializeAws_ec2ModifyInstanceCreditSpecificationRequest = (input, context) => {
    const entries = {};
    if (input.ClientToken !== undefined) {
        entries["ClientToken"] = input.ClientToken;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.InstanceCreditSpecifications !== undefined) {
        const memberEntries = serializeAws_ec2InstanceCreditSpecificationListRequest(input.InstanceCreditSpecifications, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `InstanceCreditSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2ModifyInstanceEventStartTimeRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.InstanceEventId !== undefined) {
        entries["InstanceEventId"] = input.InstanceEventId;
    }
    if (input.InstanceId !== undefined) {
        entries["InstanceId"] = input.InstanceId;
    }
    if (input.NotBefore !== undefined) {
        entries["NotBefore"] = input.NotBefore.toISOString().split(".")[0] + "Z";
    }
    return entries;
};
const serializeAws_ec2ModifyInstanceMetadataOptionsRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.HttpEndpoint !== undefined) {
        entries["HttpEndpoint"] = input.HttpEndpoint;
    }
    if (input.HttpPutResponseHopLimit !== undefined) {
        entries["HttpPutResponseHopLimit"] = input.HttpPutResponseHopLimit;
    }
    if (input.HttpTokens !== undefined) {
        entries["HttpTokens"] = input.HttpTokens;
    }
    if (input.InstanceId !== undefined) {
        entries["InstanceId"] = input.InstanceId;
    }
    return entries;
};
const serializeAws_ec2ModifyInstancePlacementRequest = (input, context) => {
    const entries = {};
    if (input.Affinity !== undefined) {
        entries["Affinity"] = input.Affinity;
    }
    if (input.GroupName !== undefined) {
        entries["GroupName"] = input.GroupName;
    }
    if (input.HostId !== undefined) {
        entries["HostId"] = input.HostId;
    }
    if (input.HostResourceGroupArn !== undefined) {
        entries["HostResourceGroupArn"] = input.HostResourceGroupArn;
    }
    if (input.InstanceId !== undefined) {
        entries["InstanceId"] = input.InstanceId;
    }
    if (input.PartitionNumber !== undefined) {
        entries["PartitionNumber"] = input.PartitionNumber;
    }
    if (input.Tenancy !== undefined) {
        entries["Tenancy"] = input.Tenancy;
    }
    return entries;
};
const serializeAws_ec2ModifyLaunchTemplateRequest = (input, context) => {
    const entries = {};
    if (input.ClientToken !== undefined) {
        entries["ClientToken"] = input.ClientToken;
    }
    if (input.DefaultVersion !== undefined) {
        entries["SetDefaultVersion"] = input.DefaultVersion;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.LaunchTemplateId !== undefined) {
        entries["LaunchTemplateId"] = input.LaunchTemplateId;
    }
    if (input.LaunchTemplateName !== undefined) {
        entries["LaunchTemplateName"] = input.LaunchTemplateName;
    }
    return entries;
};
const serializeAws_ec2ModifyNetworkInterfaceAttributeRequest = (input, context) => {
    const entries = {};
    if (input.Attachment !== undefined) {
        const memberEntries = serializeAws_ec2NetworkInterfaceAttachmentChanges(input.Attachment, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Attachment.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.Description !== undefined) {
        const memberEntries = serializeAws_ec2AttributeValue(input.Description, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Description.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Groups !== undefined) {
        const memberEntries = serializeAws_ec2SecurityGroupIdStringList(input.Groups, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `SecurityGroupId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.NetworkInterfaceId !== undefined) {
        entries["NetworkInterfaceId"] = input.NetworkInterfaceId;
    }
    if (input.SourceDestCheck !== undefined) {
        const memberEntries = serializeAws_ec2AttributeBooleanValue(input.SourceDestCheck, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `SourceDestCheck.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2ModifyReservedInstancesRequest = (input, context) => {
    const entries = {};
    if (input.ClientToken !== undefined) {
        entries["ClientToken"] = input.ClientToken;
    }
    if (input.ReservedInstancesIds !== undefined) {
        const memberEntries = serializeAws_ec2ReservedInstancesIdStringList(input.ReservedInstancesIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `ReservedInstancesId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.TargetConfigurations !== undefined) {
        const memberEntries = serializeAws_ec2ReservedInstancesConfigurationList(input.TargetConfigurations, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `ReservedInstancesConfigurationSetItemType.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2ModifySnapshotAttributeRequest = (input, context) => {
    const entries = {};
    if (input.Attribute !== undefined) {
        entries["Attribute"] = input.Attribute;
    }
    if (input.CreateVolumePermission !== undefined) {
        const memberEntries = serializeAws_ec2CreateVolumePermissionModifications(input.CreateVolumePermission, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `CreateVolumePermission.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.GroupNames !== undefined) {
        const memberEntries = serializeAws_ec2GroupNameStringList(input.GroupNames, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `UserGroup.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.OperationType !== undefined) {
        entries["OperationType"] = input.OperationType;
    }
    if (input.SnapshotId !== undefined) {
        entries["SnapshotId"] = input.SnapshotId;
    }
    if (input.UserIds !== undefined) {
        const memberEntries = serializeAws_ec2UserIdStringList(input.UserIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `UserId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2ModifySpotFleetRequestRequest = (input, context) => {
    const entries = {};
    if (input.ExcessCapacityTerminationPolicy !== undefined) {
        entries["ExcessCapacityTerminationPolicy"] =
            input.ExcessCapacityTerminationPolicy;
    }
    if (input.OnDemandTargetCapacity !== undefined) {
        entries["OnDemandTargetCapacity"] = input.OnDemandTargetCapacity;
    }
    if (input.SpotFleetRequestId !== undefined) {
        entries["SpotFleetRequestId"] = input.SpotFleetRequestId;
    }
    if (input.TargetCapacity !== undefined) {
        entries["TargetCapacity"] = input.TargetCapacity;
    }
    return entries;
};
const serializeAws_ec2ModifySubnetAttributeRequest = (input, context) => {
    const entries = {};
    if (input.AssignIpv6AddressOnCreation !== undefined) {
        const memberEntries = serializeAws_ec2AttributeBooleanValue(input.AssignIpv6AddressOnCreation, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `AssignIpv6AddressOnCreation.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.MapPublicIpOnLaunch !== undefined) {
        const memberEntries = serializeAws_ec2AttributeBooleanValue(input.MapPublicIpOnLaunch, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `MapPublicIpOnLaunch.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.SubnetId !== undefined) {
        entries["SubnetId"] = input.SubnetId;
    }
    return entries;
};
const serializeAws_ec2ModifyTrafficMirrorFilterNetworkServicesRequest = (input, context) => {
    const entries = {};
    if (input.AddNetworkServices !== undefined) {
        const memberEntries = serializeAws_ec2TrafficMirrorNetworkServiceList(input.AddNetworkServices, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `AddNetworkService.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.RemoveNetworkServices !== undefined) {
        const memberEntries = serializeAws_ec2TrafficMirrorNetworkServiceList(input.RemoveNetworkServices, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `RemoveNetworkService.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.TrafficMirrorFilterId !== undefined) {
        entries["TrafficMirrorFilterId"] = input.TrafficMirrorFilterId;
    }
    return entries;
};
const serializeAws_ec2ModifyTrafficMirrorFilterRuleRequest = (input, context) => {
    const entries = {};
    if (input.Description !== undefined) {
        entries["Description"] = input.Description;
    }
    if (input.DestinationCidrBlock !== undefined) {
        entries["DestinationCidrBlock"] = input.DestinationCidrBlock;
    }
    if (input.DestinationPortRange !== undefined) {
        const memberEntries = serializeAws_ec2TrafficMirrorPortRangeRequest(input.DestinationPortRange, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `DestinationPortRange.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Protocol !== undefined) {
        entries["Protocol"] = input.Protocol;
    }
    if (input.RemoveFields !== undefined) {
        const memberEntries = serializeAws_ec2TrafficMirrorFilterRuleFieldList(input.RemoveFields, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `RemoveField.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.RuleAction !== undefined) {
        entries["RuleAction"] = input.RuleAction;
    }
    if (input.RuleNumber !== undefined) {
        entries["RuleNumber"] = input.RuleNumber;
    }
    if (input.SourceCidrBlock !== undefined) {
        entries["SourceCidrBlock"] = input.SourceCidrBlock;
    }
    if (input.SourcePortRange !== undefined) {
        const memberEntries = serializeAws_ec2TrafficMirrorPortRangeRequest(input.SourcePortRange, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `SourcePortRange.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.TrafficDirection !== undefined) {
        entries["TrafficDirection"] = input.TrafficDirection;
    }
    if (input.TrafficMirrorFilterRuleId !== undefined) {
        entries["TrafficMirrorFilterRuleId"] = input.TrafficMirrorFilterRuleId;
    }
    return entries;
};
const serializeAws_ec2ModifyTrafficMirrorSessionRequest = (input, context) => {
    const entries = {};
    if (input.Description !== undefined) {
        entries["Description"] = input.Description;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.PacketLength !== undefined) {
        entries["PacketLength"] = input.PacketLength;
    }
    if (input.RemoveFields !== undefined) {
        const memberEntries = serializeAws_ec2TrafficMirrorSessionFieldList(input.RemoveFields, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `RemoveField.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.SessionNumber !== undefined) {
        entries["SessionNumber"] = input.SessionNumber;
    }
    if (input.TrafficMirrorFilterId !== undefined) {
        entries["TrafficMirrorFilterId"] = input.TrafficMirrorFilterId;
    }
    if (input.TrafficMirrorSessionId !== undefined) {
        entries["TrafficMirrorSessionId"] = input.TrafficMirrorSessionId;
    }
    if (input.TrafficMirrorTargetId !== undefined) {
        entries["TrafficMirrorTargetId"] = input.TrafficMirrorTargetId;
    }
    if (input.VirtualNetworkId !== undefined) {
        entries["VirtualNetworkId"] = input.VirtualNetworkId;
    }
    return entries;
};
const serializeAws_ec2ModifyTransitGatewayVpcAttachmentRequest = (input, context) => {
    const entries = {};
    if (input.AddSubnetIds !== undefined) {
        const memberEntries = serializeAws_ec2ValueStringList(input.AddSubnetIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `AddSubnetIds.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Options !== undefined) {
        const memberEntries = serializeAws_ec2ModifyTransitGatewayVpcAttachmentRequestOptions(input.Options, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Options.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.RemoveSubnetIds !== undefined) {
        const memberEntries = serializeAws_ec2ValueStringList(input.RemoveSubnetIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `RemoveSubnetIds.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.TransitGatewayAttachmentId !== undefined) {
        entries["TransitGatewayAttachmentId"] = input.TransitGatewayAttachmentId;
    }
    return entries;
};
const serializeAws_ec2ModifyTransitGatewayVpcAttachmentRequestOptions = (input, context) => {
    const entries = {};
    if (input.DnsSupport !== undefined) {
        entries["DnsSupport"] = input.DnsSupport;
    }
    if (input.Ipv6Support !== undefined) {
        entries["Ipv6Support"] = input.Ipv6Support;
    }
    return entries;
};
const serializeAws_ec2ModifyVolumeAttributeRequest = (input, context) => {
    const entries = {};
    if (input.AutoEnableIO !== undefined) {
        const memberEntries = serializeAws_ec2AttributeBooleanValue(input.AutoEnableIO, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `AutoEnableIO.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.VolumeId !== undefined) {
        entries["VolumeId"] = input.VolumeId;
    }
    return entries;
};
const serializeAws_ec2ModifyVolumeRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Iops !== undefined) {
        entries["Iops"] = input.Iops;
    }
    if (input.Size !== undefined) {
        entries["Size"] = input.Size;
    }
    if (input.VolumeId !== undefined) {
        entries["VolumeId"] = input.VolumeId;
    }
    if (input.VolumeType !== undefined) {
        entries["VolumeType"] = input.VolumeType;
    }
    return entries;
};
const serializeAws_ec2ModifyVpcAttributeRequest = (input, context) => {
    const entries = {};
    if (input.EnableDnsHostnames !== undefined) {
        const memberEntries = serializeAws_ec2AttributeBooleanValue(input.EnableDnsHostnames, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `EnableDnsHostnames.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.EnableDnsSupport !== undefined) {
        const memberEntries = serializeAws_ec2AttributeBooleanValue(input.EnableDnsSupport, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `EnableDnsSupport.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.VpcId !== undefined) {
        entries["VpcId"] = input.VpcId;
    }
    return entries;
};
const serializeAws_ec2ModifyVpcEndpointConnectionNotificationRequest = (input, context) => {
    const entries = {};
    if (input.ConnectionEvents !== undefined) {
        const memberEntries = serializeAws_ec2ValueStringList(input.ConnectionEvents, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `ConnectionEvents.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.ConnectionNotificationArn !== undefined) {
        entries["ConnectionNotificationArn"] = input.ConnectionNotificationArn;
    }
    if (input.ConnectionNotificationId !== undefined) {
        entries["ConnectionNotificationId"] = input.ConnectionNotificationId;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    return entries;
};
const serializeAws_ec2ModifyVpcEndpointRequest = (input, context) => {
    const entries = {};
    if (input.AddRouteTableIds !== undefined) {
        const memberEntries = serializeAws_ec2ValueStringList(input.AddRouteTableIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `AddRouteTableId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.AddSecurityGroupIds !== undefined) {
        const memberEntries = serializeAws_ec2ValueStringList(input.AddSecurityGroupIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `AddSecurityGroupId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.AddSubnetIds !== undefined) {
        const memberEntries = serializeAws_ec2ValueStringList(input.AddSubnetIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `AddSubnetId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.PolicyDocument !== undefined) {
        entries["PolicyDocument"] = input.PolicyDocument;
    }
    if (input.PrivateDnsEnabled !== undefined) {
        entries["PrivateDnsEnabled"] = input.PrivateDnsEnabled;
    }
    if (input.RemoveRouteTableIds !== undefined) {
        const memberEntries = serializeAws_ec2ValueStringList(input.RemoveRouteTableIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `RemoveRouteTableId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.RemoveSecurityGroupIds !== undefined) {
        const memberEntries = serializeAws_ec2ValueStringList(input.RemoveSecurityGroupIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `RemoveSecurityGroupId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.RemoveSubnetIds !== undefined) {
        const memberEntries = serializeAws_ec2ValueStringList(input.RemoveSubnetIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `RemoveSubnetId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.ResetPolicy !== undefined) {
        entries["ResetPolicy"] = input.ResetPolicy;
    }
    if (input.VpcEndpointId !== undefined) {
        entries["VpcEndpointId"] = input.VpcEndpointId;
    }
    return entries;
};
const serializeAws_ec2ModifyVpcEndpointServiceConfigurationRequest = (input, context) => {
    const entries = {};
    if (input.AcceptanceRequired !== undefined) {
        entries["AcceptanceRequired"] = input.AcceptanceRequired;
    }
    if (input.AddNetworkLoadBalancerArns !== undefined) {
        const memberEntries = serializeAws_ec2ValueStringList(input.AddNetworkLoadBalancerArns, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `AddNetworkLoadBalancerArn.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.PrivateDnsName !== undefined) {
        entries["PrivateDnsName"] = input.PrivateDnsName;
    }
    if (input.RemoveNetworkLoadBalancerArns !== undefined) {
        const memberEntries = serializeAws_ec2ValueStringList(input.RemoveNetworkLoadBalancerArns, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `RemoveNetworkLoadBalancerArn.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.RemovePrivateDnsName !== undefined) {
        entries["RemovePrivateDnsName"] = input.RemovePrivateDnsName;
    }
    if (input.ServiceId !== undefined) {
        entries["ServiceId"] = input.ServiceId;
    }
    return entries;
};
const serializeAws_ec2ModifyVpcEndpointServicePermissionsRequest = (input, context) => {
    const entries = {};
    if (input.AddAllowedPrincipals !== undefined) {
        const memberEntries = serializeAws_ec2ValueStringList(input.AddAllowedPrincipals, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `AddAllowedPrincipals.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.RemoveAllowedPrincipals !== undefined) {
        const memberEntries = serializeAws_ec2ValueStringList(input.RemoveAllowedPrincipals, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `RemoveAllowedPrincipals.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.ServiceId !== undefined) {
        entries["ServiceId"] = input.ServiceId;
    }
    return entries;
};
const serializeAws_ec2ModifyVpcPeeringConnectionOptionsRequest = (input, context) => {
    const entries = {};
    if (input.AccepterPeeringConnectionOptions !== undefined) {
        const memberEntries = serializeAws_ec2PeeringConnectionOptionsRequest(input.AccepterPeeringConnectionOptions, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `AccepterPeeringConnectionOptions.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.RequesterPeeringConnectionOptions !== undefined) {
        const memberEntries = serializeAws_ec2PeeringConnectionOptionsRequest(input.RequesterPeeringConnectionOptions, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `RequesterPeeringConnectionOptions.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.VpcPeeringConnectionId !== undefined) {
        entries["VpcPeeringConnectionId"] = input.VpcPeeringConnectionId;
    }
    return entries;
};
const serializeAws_ec2ModifyVpcTenancyRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.InstanceTenancy !== undefined) {
        entries["InstanceTenancy"] = input.InstanceTenancy;
    }
    if (input.VpcId !== undefined) {
        entries["VpcId"] = input.VpcId;
    }
    return entries;
};
const serializeAws_ec2ModifyVpnConnectionRequest = (input, context) => {
    const entries = {};
    if (input.CustomerGatewayId !== undefined) {
        entries["CustomerGatewayId"] = input.CustomerGatewayId;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.TransitGatewayId !== undefined) {
        entries["TransitGatewayId"] = input.TransitGatewayId;
    }
    if (input.VpnConnectionId !== undefined) {
        entries["VpnConnectionId"] = input.VpnConnectionId;
    }
    if (input.VpnGatewayId !== undefined) {
        entries["VpnGatewayId"] = input.VpnGatewayId;
    }
    return entries;
};
const serializeAws_ec2ModifyVpnTunnelCertificateRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.VpnConnectionId !== undefined) {
        entries["VpnConnectionId"] = input.VpnConnectionId;
    }
    if (input.VpnTunnelOutsideIpAddress !== undefined) {
        entries["VpnTunnelOutsideIpAddress"] = input.VpnTunnelOutsideIpAddress;
    }
    return entries;
};
const serializeAws_ec2ModifyVpnTunnelOptionsRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.TunnelOptions !== undefined) {
        const memberEntries = serializeAws_ec2ModifyVpnTunnelOptionsSpecification(input.TunnelOptions, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `TunnelOptions.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.VpnConnectionId !== undefined) {
        entries["VpnConnectionId"] = input.VpnConnectionId;
    }
    if (input.VpnTunnelOutsideIpAddress !== undefined) {
        entries["VpnTunnelOutsideIpAddress"] = input.VpnTunnelOutsideIpAddress;
    }
    return entries;
};
const serializeAws_ec2ModifyVpnTunnelOptionsSpecification = (input, context) => {
    const entries = {};
    if (input.DPDTimeoutSeconds !== undefined) {
        entries["DPDTimeoutSeconds"] = input.DPDTimeoutSeconds;
    }
    if (input.IKEVersions !== undefined) {
        const memberEntries = serializeAws_ec2IKEVersionsRequestList(input.IKEVersions, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `IKEVersion.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.Phase1DHGroupNumbers !== undefined) {
        const memberEntries = serializeAws_ec2Phase1DHGroupNumbersRequestList(input.Phase1DHGroupNumbers, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Phase1DHGroupNumber.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.Phase1EncryptionAlgorithms !== undefined) {
        const memberEntries = serializeAws_ec2Phase1EncryptionAlgorithmsRequestList(input.Phase1EncryptionAlgorithms, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Phase1EncryptionAlgorithm.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.Phase1IntegrityAlgorithms !== undefined) {
        const memberEntries = serializeAws_ec2Phase1IntegrityAlgorithmsRequestList(input.Phase1IntegrityAlgorithms, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Phase1IntegrityAlgorithm.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.Phase1LifetimeSeconds !== undefined) {
        entries["Phase1LifetimeSeconds"] = input.Phase1LifetimeSeconds;
    }
    if (input.Phase2DHGroupNumbers !== undefined) {
        const memberEntries = serializeAws_ec2Phase2DHGroupNumbersRequestList(input.Phase2DHGroupNumbers, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Phase2DHGroupNumber.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.Phase2EncryptionAlgorithms !== undefined) {
        const memberEntries = serializeAws_ec2Phase2EncryptionAlgorithmsRequestList(input.Phase2EncryptionAlgorithms, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Phase2EncryptionAlgorithm.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.Phase2IntegrityAlgorithms !== undefined) {
        const memberEntries = serializeAws_ec2Phase2IntegrityAlgorithmsRequestList(input.Phase2IntegrityAlgorithms, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Phase2IntegrityAlgorithm.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.Phase2LifetimeSeconds !== undefined) {
        entries["Phase2LifetimeSeconds"] = input.Phase2LifetimeSeconds;
    }
    if (input.PreSharedKey !== undefined) {
        entries["PreSharedKey"] = input.PreSharedKey;
    }
    if (input.RekeyFuzzPercentage !== undefined) {
        entries["RekeyFuzzPercentage"] = input.RekeyFuzzPercentage;
    }
    if (input.RekeyMarginTimeSeconds !== undefined) {
        entries["RekeyMarginTimeSeconds"] = input.RekeyMarginTimeSeconds;
    }
    if (input.ReplayWindowSize !== undefined) {
        entries["ReplayWindowSize"] = input.ReplayWindowSize;
    }
    if (input.TunnelInsideCidr !== undefined) {
        entries["TunnelInsideCidr"] = input.TunnelInsideCidr;
    }
    return entries;
};
const serializeAws_ec2MonitorInstancesRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.InstanceIds !== undefined) {
        const memberEntries = serializeAws_ec2InstanceIdStringList(input.InstanceIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `InstanceId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2MoveAddressToVpcRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.PublicIp !== undefined) {
        entries["PublicIp"] = input.PublicIp;
    }
    return entries;
};
const serializeAws_ec2NetworkInterfaceAttachmentChanges = (input, context) => {
    const entries = {};
    if (input.AttachmentId !== undefined) {
        entries["AttachmentId"] = input.AttachmentId;
    }
    if (input.DeleteOnTermination !== undefined) {
        entries["DeleteOnTermination"] = input.DeleteOnTermination;
    }
    return entries;
};
const serializeAws_ec2NetworkInterfaceIdList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const serializeAws_ec2NetworkInterfacePermissionIdList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        entries[`Member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const serializeAws_ec2NewDhcpConfiguration = (input, context) => {
    const entries = {};
    if (input.Key !== undefined) {
        entries["Key"] = input.Key;
    }
    if (input.Values !== undefined) {
        const memberEntries = serializeAws_ec2ValueStringList(input.Values, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Value.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2NewDhcpConfigurationList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        const memberEntries = serializeAws_ec2NewDhcpConfiguration(entry, context);
        Object.keys(memberEntries).forEach(key => {
            entries[`Item.${counter}.${key}`] = memberEntries[key];
        });
        counter++;
    }
    return entries;
};
const serializeAws_ec2OccurrenceDayRequestSet = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        entries[`OccurenceDay.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const serializeAws_ec2OnDemandOptionsRequest = (input, context) => {
    const entries = {};
    if (input.AllocationStrategy !== undefined) {
        entries["AllocationStrategy"] = input.AllocationStrategy;
    }
    if (input.CapacityReservationOptions !== undefined) {
        const memberEntries = serializeAws_ec2CapacityReservationOptionsRequest(input.CapacityReservationOptions, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `CapacityReservationOptions.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.MaxTotalPrice !== undefined) {
        entries["MaxTotalPrice"] = input.MaxTotalPrice;
    }
    if (input.MinTargetCapacity !== undefined) {
        entries["MinTargetCapacity"] = input.MinTargetCapacity;
    }
    if (input.SingleAvailabilityZone !== undefined) {
        entries["SingleAvailabilityZone"] = input.SingleAvailabilityZone;
    }
    if (input.SingleInstanceType !== undefined) {
        entries["SingleInstanceType"] = input.SingleInstanceType;
    }
    return entries;
};
const serializeAws_ec2OwnerStringList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        entries[`Owner.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const serializeAws_ec2PeeringConnectionOptionsRequest = (input, context) => {
    const entries = {};
    if (input.AllowDnsResolutionFromRemoteVpc !== undefined) {
        entries["AllowDnsResolutionFromRemoteVpc"] =
            input.AllowDnsResolutionFromRemoteVpc;
    }
    if (input.AllowEgressFromLocalClassicLinkToRemoteVpc !== undefined) {
        entries["AllowEgressFromLocalClassicLinkToRemoteVpc"] =
            input.AllowEgressFromLocalClassicLinkToRemoteVpc;
    }
    if (input.AllowEgressFromLocalVpcToRemoteClassicLink !== undefined) {
        entries["AllowEgressFromLocalVpcToRemoteClassicLink"] =
            input.AllowEgressFromLocalVpcToRemoteClassicLink;
    }
    return entries;
};
const serializeAws_ec2Phase1DHGroupNumbersRequestList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        const memberEntries = serializeAws_ec2Phase1DHGroupNumbersRequestListValue(entry, context);
        Object.keys(memberEntries).forEach(key => {
            entries[`Item.${counter}.${key}`] = memberEntries[key];
        });
        counter++;
    }
    return entries;
};
const serializeAws_ec2Phase1DHGroupNumbersRequestListValue = (input, context) => {
    const entries = {};
    if (input.Value !== undefined) {
        entries["Value"] = input.Value;
    }
    return entries;
};
const serializeAws_ec2Phase1EncryptionAlgorithmsRequestList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        const memberEntries = serializeAws_ec2Phase1EncryptionAlgorithmsRequestListValue(entry, context);
        Object.keys(memberEntries).forEach(key => {
            entries[`Item.${counter}.${key}`] = memberEntries[key];
        });
        counter++;
    }
    return entries;
};
const serializeAws_ec2Phase1EncryptionAlgorithmsRequestListValue = (input, context) => {
    const entries = {};
    if (input.Value !== undefined) {
        entries["Value"] = input.Value;
    }
    return entries;
};
const serializeAws_ec2Phase1IntegrityAlgorithmsRequestList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        const memberEntries = serializeAws_ec2Phase1IntegrityAlgorithmsRequestListValue(entry, context);
        Object.keys(memberEntries).forEach(key => {
            entries[`Item.${counter}.${key}`] = memberEntries[key];
        });
        counter++;
    }
    return entries;
};
const serializeAws_ec2Phase1IntegrityAlgorithmsRequestListValue = (input, context) => {
    const entries = {};
    if (input.Value !== undefined) {
        entries["Value"] = input.Value;
    }
    return entries;
};
const serializeAws_ec2Phase2DHGroupNumbersRequestList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        const memberEntries = serializeAws_ec2Phase2DHGroupNumbersRequestListValue(entry, context);
        Object.keys(memberEntries).forEach(key => {
            entries[`Item.${counter}.${key}`] = memberEntries[key];
        });
        counter++;
    }
    return entries;
};
const serializeAws_ec2Phase2DHGroupNumbersRequestListValue = (input, context) => {
    const entries = {};
    if (input.Value !== undefined) {
        entries["Value"] = input.Value;
    }
    return entries;
};
const serializeAws_ec2Phase2EncryptionAlgorithmsRequestList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        const memberEntries = serializeAws_ec2Phase2EncryptionAlgorithmsRequestListValue(entry, context);
        Object.keys(memberEntries).forEach(key => {
            entries[`Item.${counter}.${key}`] = memberEntries[key];
        });
        counter++;
    }
    return entries;
};
const serializeAws_ec2Phase2EncryptionAlgorithmsRequestListValue = (input, context) => {
    const entries = {};
    if (input.Value !== undefined) {
        entries["Value"] = input.Value;
    }
    return entries;
};
const serializeAws_ec2Phase2IntegrityAlgorithmsRequestList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        const memberEntries = serializeAws_ec2Phase2IntegrityAlgorithmsRequestListValue(entry, context);
        Object.keys(memberEntries).forEach(key => {
            entries[`Item.${counter}.${key}`] = memberEntries[key];
        });
        counter++;
    }
    return entries;
};
const serializeAws_ec2Phase2IntegrityAlgorithmsRequestListValue = (input, context) => {
    const entries = {};
    if (input.Value !== undefined) {
        entries["Value"] = input.Value;
    }
    return entries;
};
const serializeAws_ec2Placement = (input, context) => {
    const entries = {};
    if (input.Affinity !== undefined) {
        entries["Affinity"] = input.Affinity;
    }
    if (input.AvailabilityZone !== undefined) {
        entries["AvailabilityZone"] = input.AvailabilityZone;
    }
    if (input.GroupName !== undefined) {
        entries["GroupName"] = input.GroupName;
    }
    if (input.HostId !== undefined) {
        entries["HostId"] = input.HostId;
    }
    if (input.HostResourceGroupArn !== undefined) {
        entries["HostResourceGroupArn"] = input.HostResourceGroupArn;
    }
    if (input.PartitionNumber !== undefined) {
        entries["PartitionNumber"] = input.PartitionNumber;
    }
    if (input.SpreadDomain !== undefined) {
        entries["SpreadDomain"] = input.SpreadDomain;
    }
    if (input.Tenancy !== undefined) {
        entries["Tenancy"] = input.Tenancy;
    }
    return entries;
};
const serializeAws_ec2PlacementGroupIdStringList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        entries[`GroupId.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const serializeAws_ec2PlacementGroupStringList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        entries[`Member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const serializeAws_ec2PortRange = (input, context) => {
    const entries = {};
    if (input.From !== undefined) {
        entries["From"] = input.From;
    }
    if (input.To !== undefined) {
        entries["To"] = input.To;
    }
    return entries;
};
const serializeAws_ec2PrefixListId = (input, context) => {
    const entries = {};
    if (input.Description !== undefined) {
        entries["Description"] = input.Description;
    }
    if (input.PrefixListId !== undefined) {
        entries["PrefixListId"] = input.PrefixListId;
    }
    return entries;
};
const serializeAws_ec2PrefixListIdList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        const memberEntries = serializeAws_ec2PrefixListId(entry, context);
        Object.keys(memberEntries).forEach(key => {
            entries[`Item.${counter}.${key}`] = memberEntries[key];
        });
        counter++;
    }
    return entries;
};
const serializeAws_ec2PriceScheduleSpecification = (input, context) => {
    const entries = {};
    if (input.CurrencyCode !== undefined) {
        entries["CurrencyCode"] = input.CurrencyCode;
    }
    if (input.Price !== undefined) {
        entries["Price"] = input.Price;
    }
    if (input.Term !== undefined) {
        entries["Term"] = input.Term;
    }
    return entries;
};
const serializeAws_ec2PriceScheduleSpecificationList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        const memberEntries = serializeAws_ec2PriceScheduleSpecification(entry, context);
        Object.keys(memberEntries).forEach(key => {
            entries[`Item.${counter}.${key}`] = memberEntries[key];
        });
        counter++;
    }
    return entries;
};
const serializeAws_ec2PrivateIpAddressConfigSet = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        const memberEntries = serializeAws_ec2ScheduledInstancesPrivateIpAddressConfig(entry, context);
        Object.keys(memberEntries).forEach(key => {
            entries[`PrivateIpAddressConfigSet.${counter}.${key}`] =
                memberEntries[key];
        });
        counter++;
    }
    return entries;
};
const serializeAws_ec2PrivateIpAddressSpecification = (input, context) => {
    const entries = {};
    if (input.Primary !== undefined) {
        entries["Primary"] = input.Primary;
    }
    if (input.PrivateIpAddress !== undefined) {
        entries["PrivateIpAddress"] = input.PrivateIpAddress;
    }
    return entries;
};
const serializeAws_ec2PrivateIpAddressSpecificationList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        const memberEntries = serializeAws_ec2PrivateIpAddressSpecification(entry, context);
        Object.keys(memberEntries).forEach(key => {
            entries[`Item.${counter}.${key}`] = memberEntries[key];
        });
        counter++;
    }
    return entries;
};
const serializeAws_ec2PrivateIpAddressStringList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        entries[`PrivateIpAddress.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const serializeAws_ec2ProductCodeStringList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        entries[`ProductCode.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const serializeAws_ec2ProductDescriptionList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        entries[`Member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const serializeAws_ec2ProvisionByoipCidrRequest = (input, context) => {
    const entries = {};
    if (input.Cidr !== undefined) {
        entries["Cidr"] = input.Cidr;
    }
    if (input.CidrAuthorizationContext !== undefined) {
        const memberEntries = serializeAws_ec2CidrAuthorizationContext(input.CidrAuthorizationContext, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `CidrAuthorizationContext.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.Description !== undefined) {
        entries["Description"] = input.Description;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.PubliclyAdvertisable !== undefined) {
        entries["PubliclyAdvertisable"] = input.PubliclyAdvertisable;
    }
    return entries;
};
const serializeAws_ec2PublicIpStringList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        entries[`PublicIp.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const serializeAws_ec2PurchaseHostReservationRequest = (input, context) => {
    const entries = {};
    if (input.ClientToken !== undefined) {
        entries["ClientToken"] = input.ClientToken;
    }
    if (input.CurrencyCode !== undefined) {
        entries["CurrencyCode"] = input.CurrencyCode;
    }
    if (input.HostIdSet !== undefined) {
        const memberEntries = serializeAws_ec2RequestHostIdSet(input.HostIdSet, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `HostIdSet.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.LimitPrice !== undefined) {
        entries["LimitPrice"] = input.LimitPrice;
    }
    if (input.OfferingId !== undefined) {
        entries["OfferingId"] = input.OfferingId;
    }
    return entries;
};
const serializeAws_ec2PurchaseRequest = (input, context) => {
    const entries = {};
    if (input.InstanceCount !== undefined) {
        entries["InstanceCount"] = input.InstanceCount;
    }
    if (input.PurchaseToken !== undefined) {
        entries["PurchaseToken"] = input.PurchaseToken;
    }
    return entries;
};
const serializeAws_ec2PurchaseRequestSet = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        const memberEntries = serializeAws_ec2PurchaseRequest(entry, context);
        Object.keys(memberEntries).forEach(key => {
            entries[`PurchaseRequest.${counter}.${key}`] = memberEntries[key];
        });
        counter++;
    }
    return entries;
};
const serializeAws_ec2PurchaseReservedInstancesOfferingRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.InstanceCount !== undefined) {
        entries["InstanceCount"] = input.InstanceCount;
    }
    if (input.LimitPrice !== undefined) {
        const memberEntries = serializeAws_ec2ReservedInstanceLimitPrice(input.LimitPrice, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `LimitPrice.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.PurchaseTime !== undefined) {
        entries["PurchaseTime"] =
            input.PurchaseTime.toISOString().split(".")[0] + "Z";
    }
    if (input.ReservedInstancesOfferingId !== undefined) {
        entries["ReservedInstancesOfferingId"] = input.ReservedInstancesOfferingId;
    }
    return entries;
};
const serializeAws_ec2PurchaseScheduledInstancesRequest = (input, context) => {
    const entries = {};
    if (input.ClientToken === undefined) {
        input.ClientToken = uuid_1.v4();
    }
    if (input.ClientToken !== undefined) {
        entries["ClientToken"] = input.ClientToken;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.PurchaseRequests !== undefined) {
        const memberEntries = serializeAws_ec2PurchaseRequestSet(input.PurchaseRequests, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `PurchaseRequest.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2ReasonCodesList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const serializeAws_ec2RebootInstancesRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.InstanceIds !== undefined) {
        const memberEntries = serializeAws_ec2InstanceIdStringList(input.InstanceIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `InstanceId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2RegionNameStringList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        entries[`RegionName.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const serializeAws_ec2RegisterImageRequest = (input, context) => {
    const entries = {};
    if (input.Architecture !== undefined) {
        entries["Architecture"] = input.Architecture;
    }
    if (input.BillingProducts !== undefined) {
        const memberEntries = serializeAws_ec2BillingProductList(input.BillingProducts, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `BillingProduct.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.BlockDeviceMappings !== undefined) {
        const memberEntries = serializeAws_ec2BlockDeviceMappingRequestList(input.BlockDeviceMappings, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `BlockDeviceMapping.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.Description !== undefined) {
        entries["Description"] = input.Description;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.EnaSupport !== undefined) {
        entries["EnaSupport"] = input.EnaSupport;
    }
    if (input.ImageLocation !== undefined) {
        entries["ImageLocation"] = input.ImageLocation;
    }
    if (input.KernelId !== undefined) {
        entries["KernelId"] = input.KernelId;
    }
    if (input.Name !== undefined) {
        entries["Name"] = input.Name;
    }
    if (input.RamdiskId !== undefined) {
        entries["RamdiskId"] = input.RamdiskId;
    }
    if (input.RootDeviceName !== undefined) {
        entries["RootDeviceName"] = input.RootDeviceName;
    }
    if (input.SriovNetSupport !== undefined) {
        entries["SriovNetSupport"] = input.SriovNetSupport;
    }
    if (input.VirtualizationType !== undefined) {
        entries["VirtualizationType"] = input.VirtualizationType;
    }
    return entries;
};
const serializeAws_ec2RegisterTransitGatewayMulticastGroupMembersRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.GroupIpAddress !== undefined) {
        entries["GroupIpAddress"] = input.GroupIpAddress;
    }
    if (input.NetworkInterfaceIds !== undefined) {
        const memberEntries = serializeAws_ec2ValueStringList(input.NetworkInterfaceIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `NetworkInterfaceIds.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.TransitGatewayMulticastDomainId !== undefined) {
        entries["TransitGatewayMulticastDomainId"] =
            input.TransitGatewayMulticastDomainId;
    }
    return entries;
};
const serializeAws_ec2RegisterTransitGatewayMulticastGroupSourcesRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.GroupIpAddress !== undefined) {
        entries["GroupIpAddress"] = input.GroupIpAddress;
    }
    if (input.NetworkInterfaceIds !== undefined) {
        const memberEntries = serializeAws_ec2ValueStringList(input.NetworkInterfaceIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `NetworkInterfaceIds.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.TransitGatewayMulticastDomainId !== undefined) {
        entries["TransitGatewayMulticastDomainId"] =
            input.TransitGatewayMulticastDomainId;
    }
    return entries;
};
const serializeAws_ec2RejectTransitGatewayPeeringAttachmentRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.TransitGatewayAttachmentId !== undefined) {
        entries["TransitGatewayAttachmentId"] = input.TransitGatewayAttachmentId;
    }
    return entries;
};
const serializeAws_ec2RejectTransitGatewayVpcAttachmentRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.TransitGatewayAttachmentId !== undefined) {
        entries["TransitGatewayAttachmentId"] = input.TransitGatewayAttachmentId;
    }
    return entries;
};
const serializeAws_ec2RejectVpcEndpointConnectionsRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.ServiceId !== undefined) {
        entries["ServiceId"] = input.ServiceId;
    }
    if (input.VpcEndpointIds !== undefined) {
        const memberEntries = serializeAws_ec2ValueStringList(input.VpcEndpointIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `VpcEndpointId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2RejectVpcPeeringConnectionRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.VpcPeeringConnectionId !== undefined) {
        entries["VpcPeeringConnectionId"] = input.VpcPeeringConnectionId;
    }
    return entries;
};
const serializeAws_ec2ReleaseAddressRequest = (input, context) => {
    const entries = {};
    if (input.AllocationId !== undefined) {
        entries["AllocationId"] = input.AllocationId;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.NetworkBorderGroup !== undefined) {
        entries["NetworkBorderGroup"] = input.NetworkBorderGroup;
    }
    if (input.PublicIp !== undefined) {
        entries["PublicIp"] = input.PublicIp;
    }
    return entries;
};
const serializeAws_ec2ReleaseHostsRequest = (input, context) => {
    const entries = {};
    if (input.HostIds !== undefined) {
        const memberEntries = serializeAws_ec2RequestHostIdList(input.HostIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `HostId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2ReplaceIamInstanceProfileAssociationRequest = (input, context) => {
    const entries = {};
    if (input.AssociationId !== undefined) {
        entries["AssociationId"] = input.AssociationId;
    }
    if (input.IamInstanceProfile !== undefined) {
        const memberEntries = serializeAws_ec2IamInstanceProfileSpecification(input.IamInstanceProfile, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `IamInstanceProfile.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2ReplaceNetworkAclAssociationRequest = (input, context) => {
    const entries = {};
    if (input.AssociationId !== undefined) {
        entries["AssociationId"] = input.AssociationId;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.NetworkAclId !== undefined) {
        entries["NetworkAclId"] = input.NetworkAclId;
    }
    return entries;
};
const serializeAws_ec2ReplaceNetworkAclEntryRequest = (input, context) => {
    const entries = {};
    if (input.CidrBlock !== undefined) {
        entries["CidrBlock"] = input.CidrBlock;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Egress !== undefined) {
        entries["Egress"] = input.Egress;
    }
    if (input.IcmpTypeCode !== undefined) {
        const memberEntries = serializeAws_ec2IcmpTypeCode(input.IcmpTypeCode, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Icmp.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.Ipv6CidrBlock !== undefined) {
        entries["Ipv6CidrBlock"] = input.Ipv6CidrBlock;
    }
    if (input.NetworkAclId !== undefined) {
        entries["NetworkAclId"] = input.NetworkAclId;
    }
    if (input.PortRange !== undefined) {
        const memberEntries = serializeAws_ec2PortRange(input.PortRange, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `PortRange.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.Protocol !== undefined) {
        entries["Protocol"] = input.Protocol;
    }
    if (input.RuleAction !== undefined) {
        entries["RuleAction"] = input.RuleAction;
    }
    if (input.RuleNumber !== undefined) {
        entries["RuleNumber"] = input.RuleNumber;
    }
    return entries;
};
const serializeAws_ec2ReplaceRouteRequest = (input, context) => {
    const entries = {};
    if (input.DestinationCidrBlock !== undefined) {
        entries["DestinationCidrBlock"] = input.DestinationCidrBlock;
    }
    if (input.DestinationIpv6CidrBlock !== undefined) {
        entries["DestinationIpv6CidrBlock"] = input.DestinationIpv6CidrBlock;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.EgressOnlyInternetGatewayId !== undefined) {
        entries["EgressOnlyInternetGatewayId"] = input.EgressOnlyInternetGatewayId;
    }
    if (input.GatewayId !== undefined) {
        entries["GatewayId"] = input.GatewayId;
    }
    if (input.InstanceId !== undefined) {
        entries["InstanceId"] = input.InstanceId;
    }
    if (input.LocalGatewayId !== undefined) {
        entries["LocalGatewayId"] = input.LocalGatewayId;
    }
    if (input.LocalTarget !== undefined) {
        entries["LocalTarget"] = input.LocalTarget;
    }
    if (input.NatGatewayId !== undefined) {
        entries["NatGatewayId"] = input.NatGatewayId;
    }
    if (input.NetworkInterfaceId !== undefined) {
        entries["NetworkInterfaceId"] = input.NetworkInterfaceId;
    }
    if (input.RouteTableId !== undefined) {
        entries["RouteTableId"] = input.RouteTableId;
    }
    if (input.TransitGatewayId !== undefined) {
        entries["TransitGatewayId"] = input.TransitGatewayId;
    }
    if (input.VpcPeeringConnectionId !== undefined) {
        entries["VpcPeeringConnectionId"] = input.VpcPeeringConnectionId;
    }
    return entries;
};
const serializeAws_ec2ReplaceRouteTableAssociationRequest = (input, context) => {
    const entries = {};
    if (input.AssociationId !== undefined) {
        entries["AssociationId"] = input.AssociationId;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.RouteTableId !== undefined) {
        entries["RouteTableId"] = input.RouteTableId;
    }
    return entries;
};
const serializeAws_ec2ReplaceTransitGatewayRouteRequest = (input, context) => {
    const entries = {};
    if (input.Blackhole !== undefined) {
        entries["Blackhole"] = input.Blackhole;
    }
    if (input.DestinationCidrBlock !== undefined) {
        entries["DestinationCidrBlock"] = input.DestinationCidrBlock;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.TransitGatewayAttachmentId !== undefined) {
        entries["TransitGatewayAttachmentId"] = input.TransitGatewayAttachmentId;
    }
    if (input.TransitGatewayRouteTableId !== undefined) {
        entries["TransitGatewayRouteTableId"] = input.TransitGatewayRouteTableId;
    }
    return entries;
};
const serializeAws_ec2ReportInstanceStatusRequest = (input, context) => {
    const entries = {};
    if (input.Description !== undefined) {
        entries["Description"] = input.Description;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.EndTime !== undefined) {
        entries["EndTime"] = input.EndTime.toISOString().split(".")[0] + "Z";
    }
    if (input.Instances !== undefined) {
        const memberEntries = serializeAws_ec2InstanceIdStringList(input.Instances, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `InstanceId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.ReasonCodes !== undefined) {
        const memberEntries = serializeAws_ec2ReasonCodesList(input.ReasonCodes, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `ReasonCode.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.StartTime !== undefined) {
        entries["StartTime"] = input.StartTime.toISOString().split(".")[0] + "Z";
    }
    if (input.Status !== undefined) {
        entries["Status"] = input.Status;
    }
    return entries;
};
const serializeAws_ec2RequestHostIdList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const serializeAws_ec2RequestHostIdSet = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const serializeAws_ec2RequestInstanceTypeList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        entries[`Member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const serializeAws_ec2RequestLaunchTemplateData = (input, context) => {
    const entries = {};
    if (input.BlockDeviceMappings !== undefined) {
        const memberEntries = serializeAws_ec2LaunchTemplateBlockDeviceMappingRequestList(input.BlockDeviceMappings, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `BlockDeviceMapping.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.CapacityReservationSpecification !== undefined) {
        const memberEntries = serializeAws_ec2LaunchTemplateCapacityReservationSpecificationRequest(input.CapacityReservationSpecification, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `CapacityReservationSpecification.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.CpuOptions !== undefined) {
        const memberEntries = serializeAws_ec2LaunchTemplateCpuOptionsRequest(input.CpuOptions, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `CpuOptions.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.CreditSpecification !== undefined) {
        const memberEntries = serializeAws_ec2CreditSpecificationRequest(input.CreditSpecification, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `CreditSpecification.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.DisableApiTermination !== undefined) {
        entries["DisableApiTermination"] = input.DisableApiTermination;
    }
    if (input.EbsOptimized !== undefined) {
        entries["EbsOptimized"] = input.EbsOptimized;
    }
    if (input.ElasticGpuSpecifications !== undefined) {
        const memberEntries = serializeAws_ec2ElasticGpuSpecificationList(input.ElasticGpuSpecifications, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `ElasticGpuSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.ElasticInferenceAccelerators !== undefined) {
        const memberEntries = serializeAws_ec2LaunchTemplateElasticInferenceAcceleratorList(input.ElasticInferenceAccelerators, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `ElasticInferenceAccelerator.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.HibernationOptions !== undefined) {
        const memberEntries = serializeAws_ec2LaunchTemplateHibernationOptionsRequest(input.HibernationOptions, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `HibernationOptions.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.IamInstanceProfile !== undefined) {
        const memberEntries = serializeAws_ec2LaunchTemplateIamInstanceProfileSpecificationRequest(input.IamInstanceProfile, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `IamInstanceProfile.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.ImageId !== undefined) {
        entries["ImageId"] = input.ImageId;
    }
    if (input.InstanceInitiatedShutdownBehavior !== undefined) {
        entries["InstanceInitiatedShutdownBehavior"] =
            input.InstanceInitiatedShutdownBehavior;
    }
    if (input.InstanceMarketOptions !== undefined) {
        const memberEntries = serializeAws_ec2LaunchTemplateInstanceMarketOptionsRequest(input.InstanceMarketOptions, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `InstanceMarketOptions.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.InstanceType !== undefined) {
        entries["InstanceType"] = input.InstanceType;
    }
    if (input.KernelId !== undefined) {
        entries["KernelId"] = input.KernelId;
    }
    if (input.KeyName !== undefined) {
        entries["KeyName"] = input.KeyName;
    }
    if (input.LicenseSpecifications !== undefined) {
        const memberEntries = serializeAws_ec2LaunchTemplateLicenseSpecificationListRequest(input.LicenseSpecifications, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `LicenseSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.MetadataOptions !== undefined) {
        const memberEntries = serializeAws_ec2LaunchTemplateInstanceMetadataOptionsRequest(input.MetadataOptions, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `MetadataOptions.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.Monitoring !== undefined) {
        const memberEntries = serializeAws_ec2LaunchTemplatesMonitoringRequest(input.Monitoring, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Monitoring.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.NetworkInterfaces !== undefined) {
        const memberEntries = serializeAws_ec2LaunchTemplateInstanceNetworkInterfaceSpecificationRequestList(input.NetworkInterfaces, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `NetworkInterface.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.Placement !== undefined) {
        const memberEntries = serializeAws_ec2LaunchTemplatePlacementRequest(input.Placement, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Placement.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.RamDiskId !== undefined) {
        entries["RamDiskId"] = input.RamDiskId;
    }
    if (input.SecurityGroupIds !== undefined) {
        const memberEntries = serializeAws_ec2SecurityGroupIdStringList(input.SecurityGroupIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `SecurityGroupId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.SecurityGroups !== undefined) {
        const memberEntries = serializeAws_ec2SecurityGroupStringList(input.SecurityGroups, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `SecurityGroup.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.TagSpecifications !== undefined) {
        const memberEntries = serializeAws_ec2LaunchTemplateTagSpecificationRequestList(input.TagSpecifications, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.UserData !== undefined) {
        entries["UserData"] = input.UserData;
    }
    return entries;
};
const serializeAws_ec2RequestSpotFleetRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.SpotFleetRequestConfig !== undefined) {
        const memberEntries = serializeAws_ec2SpotFleetRequestConfigData(input.SpotFleetRequestConfig, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `SpotFleetRequestConfig.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2RequestSpotInstancesRequest = (input, context) => {
    const entries = {};
    if (input.AvailabilityZoneGroup !== undefined) {
        entries["AvailabilityZoneGroup"] = input.AvailabilityZoneGroup;
    }
    if (input.BlockDurationMinutes !== undefined) {
        entries["BlockDurationMinutes"] = input.BlockDurationMinutes;
    }
    if (input.ClientToken !== undefined) {
        entries["ClientToken"] = input.ClientToken;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.InstanceCount !== undefined) {
        entries["InstanceCount"] = input.InstanceCount;
    }
    if (input.InstanceInterruptionBehavior !== undefined) {
        entries["InstanceInterruptionBehavior"] =
            input.InstanceInterruptionBehavior;
    }
    if (input.LaunchGroup !== undefined) {
        entries["LaunchGroup"] = input.LaunchGroup;
    }
    if (input.LaunchSpecification !== undefined) {
        const memberEntries = serializeAws_ec2RequestSpotLaunchSpecification(input.LaunchSpecification, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `LaunchSpecification.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.SpotPrice !== undefined) {
        entries["SpotPrice"] = input.SpotPrice;
    }
    if (input.Type !== undefined) {
        entries["Type"] = input.Type;
    }
    if (input.ValidFrom !== undefined) {
        entries["ValidFrom"] = input.ValidFrom.toISOString().split(".")[0] + "Z";
    }
    if (input.ValidUntil !== undefined) {
        entries["ValidUntil"] = input.ValidUntil.toISOString().split(".")[0] + "Z";
    }
    return entries;
};
const serializeAws_ec2RequestSpotLaunchSpecification = (input, context) => {
    const entries = {};
    if (input.AddressingType !== undefined) {
        entries["AddressingType"] = input.AddressingType;
    }
    if (input.BlockDeviceMappings !== undefined) {
        const memberEntries = serializeAws_ec2BlockDeviceMappingList(input.BlockDeviceMappings, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `BlockDeviceMapping.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.EbsOptimized !== undefined) {
        entries["EbsOptimized"] = input.EbsOptimized;
    }
    if (input.IamInstanceProfile !== undefined) {
        const memberEntries = serializeAws_ec2IamInstanceProfileSpecification(input.IamInstanceProfile, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `IamInstanceProfile.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.ImageId !== undefined) {
        entries["ImageId"] = input.ImageId;
    }
    if (input.InstanceType !== undefined) {
        entries["InstanceType"] = input.InstanceType;
    }
    if (input.KernelId !== undefined) {
        entries["KernelId"] = input.KernelId;
    }
    if (input.KeyName !== undefined) {
        entries["KeyName"] = input.KeyName;
    }
    if (input.Monitoring !== undefined) {
        const memberEntries = serializeAws_ec2RunInstancesMonitoringEnabled(input.Monitoring, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Monitoring.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.NetworkInterfaces !== undefined) {
        const memberEntries = serializeAws_ec2InstanceNetworkInterfaceSpecificationList(input.NetworkInterfaces, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `NetworkInterface.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.Placement !== undefined) {
        const memberEntries = serializeAws_ec2SpotPlacement(input.Placement, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Placement.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.RamdiskId !== undefined) {
        entries["RamdiskId"] = input.RamdiskId;
    }
    if (input.SecurityGroupIds !== undefined) {
        const memberEntries = serializeAws_ec2ValueStringList(input.SecurityGroupIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `SecurityGroupId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.SecurityGroups !== undefined) {
        const memberEntries = serializeAws_ec2ValueStringList(input.SecurityGroups, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `SecurityGroup.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.SubnetId !== undefined) {
        entries["SubnetId"] = input.SubnetId;
    }
    if (input.UserData !== undefined) {
        entries["UserData"] = input.UserData;
    }
    return entries;
};
const serializeAws_ec2ReservedInstanceIdSet = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        entries[`ReservedInstanceId.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const serializeAws_ec2ReservedInstanceLimitPrice = (input, context) => {
    const entries = {};
    if (input.Amount !== undefined) {
        entries["Amount"] = input.Amount;
    }
    if (input.CurrencyCode !== undefined) {
        entries["CurrencyCode"] = input.CurrencyCode;
    }
    return entries;
};
const serializeAws_ec2ReservedInstancesConfiguration = (input, context) => {
    const entries = {};
    if (input.AvailabilityZone !== undefined) {
        entries["AvailabilityZone"] = input.AvailabilityZone;
    }
    if (input.InstanceCount !== undefined) {
        entries["InstanceCount"] = input.InstanceCount;
    }
    if (input.InstanceType !== undefined) {
        entries["InstanceType"] = input.InstanceType;
    }
    if (input.Platform !== undefined) {
        entries["Platform"] = input.Platform;
    }
    if (input.Scope !== undefined) {
        entries["Scope"] = input.Scope;
    }
    return entries;
};
const serializeAws_ec2ReservedInstancesConfigurationList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        const memberEntries = serializeAws_ec2ReservedInstancesConfiguration(entry, context);
        Object.keys(memberEntries).forEach(key => {
            entries[`Item.${counter}.${key}`] = memberEntries[key];
        });
        counter++;
    }
    return entries;
};
const serializeAws_ec2ReservedInstancesIdStringList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        entries[`ReservedInstancesId.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const serializeAws_ec2ReservedInstancesModificationIdStringList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        entries[`ReservedInstancesModificationId.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const serializeAws_ec2ReservedInstancesOfferingIdStringList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        entries[`Member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const serializeAws_ec2ResetEbsDefaultKmsKeyIdRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    return entries;
};
const serializeAws_ec2ResetFpgaImageAttributeRequest = (input, context) => {
    const entries = {};
    if (input.Attribute !== undefined) {
        entries["Attribute"] = input.Attribute;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.FpgaImageId !== undefined) {
        entries["FpgaImageId"] = input.FpgaImageId;
    }
    return entries;
};
const serializeAws_ec2ResetImageAttributeRequest = (input, context) => {
    const entries = {};
    if (input.Attribute !== undefined) {
        entries["Attribute"] = input.Attribute;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.ImageId !== undefined) {
        entries["ImageId"] = input.ImageId;
    }
    return entries;
};
const serializeAws_ec2ResetInstanceAttributeRequest = (input, context) => {
    const entries = {};
    if (input.Attribute !== undefined) {
        entries["Attribute"] = input.Attribute;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.InstanceId !== undefined) {
        entries["InstanceId"] = input.InstanceId;
    }
    return entries;
};
const serializeAws_ec2ResetNetworkInterfaceAttributeRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.NetworkInterfaceId !== undefined) {
        entries["NetworkInterfaceId"] = input.NetworkInterfaceId;
    }
    if (input.SourceDestCheck !== undefined) {
        entries["SourceDestCheck"] = input.SourceDestCheck;
    }
    return entries;
};
const serializeAws_ec2ResetSnapshotAttributeRequest = (input, context) => {
    const entries = {};
    if (input.Attribute !== undefined) {
        entries["Attribute"] = input.Attribute;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.SnapshotId !== undefined) {
        entries["SnapshotId"] = input.SnapshotId;
    }
    return entries;
};
const serializeAws_ec2ResourceIdList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        entries[`Member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const serializeAws_ec2ResourceList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const serializeAws_ec2RestorableByStringList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        entries[`Member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const serializeAws_ec2RestoreAddressToClassicRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.PublicIp !== undefined) {
        entries["PublicIp"] = input.PublicIp;
    }
    return entries;
};
const serializeAws_ec2RevokeClientVpnIngressRequest = (input, context) => {
    const entries = {};
    if (input.AccessGroupId !== undefined) {
        entries["AccessGroupId"] = input.AccessGroupId;
    }
    if (input.ClientVpnEndpointId !== undefined) {
        entries["ClientVpnEndpointId"] = input.ClientVpnEndpointId;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.RevokeAllGroups !== undefined) {
        entries["RevokeAllGroups"] = input.RevokeAllGroups;
    }
    if (input.TargetNetworkCidr !== undefined) {
        entries["TargetNetworkCidr"] = input.TargetNetworkCidr;
    }
    return entries;
};
const serializeAws_ec2RevokeSecurityGroupEgressRequest = (input, context) => {
    const entries = {};
    if (input.CidrIp !== undefined) {
        entries["CidrIp"] = input.CidrIp;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.FromPort !== undefined) {
        entries["FromPort"] = input.FromPort;
    }
    if (input.GroupId !== undefined) {
        entries["GroupId"] = input.GroupId;
    }
    if (input.IpPermissions !== undefined) {
        const memberEntries = serializeAws_ec2IpPermissionList(input.IpPermissions, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `IpPermissions.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.IpProtocol !== undefined) {
        entries["IpProtocol"] = input.IpProtocol;
    }
    if (input.SourceSecurityGroupName !== undefined) {
        entries["SourceSecurityGroupName"] = input.SourceSecurityGroupName;
    }
    if (input.SourceSecurityGroupOwnerId !== undefined) {
        entries["SourceSecurityGroupOwnerId"] = input.SourceSecurityGroupOwnerId;
    }
    if (input.ToPort !== undefined) {
        entries["ToPort"] = input.ToPort;
    }
    return entries;
};
const serializeAws_ec2RevokeSecurityGroupIngressRequest = (input, context) => {
    const entries = {};
    if (input.CidrIp !== undefined) {
        entries["CidrIp"] = input.CidrIp;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.FromPort !== undefined) {
        entries["FromPort"] = input.FromPort;
    }
    if (input.GroupId !== undefined) {
        entries["GroupId"] = input.GroupId;
    }
    if (input.GroupName !== undefined) {
        entries["GroupName"] = input.GroupName;
    }
    if (input.IpPermissions !== undefined) {
        const memberEntries = serializeAws_ec2IpPermissionList(input.IpPermissions, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `IpPermissions.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.IpProtocol !== undefined) {
        entries["IpProtocol"] = input.IpProtocol;
    }
    if (input.SourceSecurityGroupName !== undefined) {
        entries["SourceSecurityGroupName"] = input.SourceSecurityGroupName;
    }
    if (input.SourceSecurityGroupOwnerId !== undefined) {
        entries["SourceSecurityGroupOwnerId"] = input.SourceSecurityGroupOwnerId;
    }
    if (input.ToPort !== undefined) {
        entries["ToPort"] = input.ToPort;
    }
    return entries;
};
const serializeAws_ec2RunInstancesMonitoringEnabled = (input, context) => {
    const entries = {};
    if (input.Enabled !== undefined) {
        entries["Enabled"] = input.Enabled;
    }
    return entries;
};
const serializeAws_ec2RunInstancesRequest = (input, context) => {
    const entries = {};
    if (input.AdditionalInfo !== undefined) {
        entries["AdditionalInfo"] = input.AdditionalInfo;
    }
    if (input.BlockDeviceMappings !== undefined) {
        const memberEntries = serializeAws_ec2BlockDeviceMappingRequestList(input.BlockDeviceMappings, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `BlockDeviceMapping.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.CapacityReservationSpecification !== undefined) {
        const memberEntries = serializeAws_ec2CapacityReservationSpecification(input.CapacityReservationSpecification, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `CapacityReservationSpecification.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.ClientToken !== undefined) {
        entries["ClientToken"] = input.ClientToken;
    }
    if (input.CpuOptions !== undefined) {
        const memberEntries = serializeAws_ec2CpuOptionsRequest(input.CpuOptions, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `CpuOptions.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.CreditSpecification !== undefined) {
        const memberEntries = serializeAws_ec2CreditSpecificationRequest(input.CreditSpecification, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `CreditSpecification.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.DisableApiTermination !== undefined) {
        entries["DisableApiTermination"] = input.DisableApiTermination;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.EbsOptimized !== undefined) {
        entries["EbsOptimized"] = input.EbsOptimized;
    }
    if (input.ElasticGpuSpecification !== undefined) {
        const memberEntries = serializeAws_ec2ElasticGpuSpecifications(input.ElasticGpuSpecification, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `ElasticGpuSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.ElasticInferenceAccelerators !== undefined) {
        const memberEntries = serializeAws_ec2ElasticInferenceAccelerators(input.ElasticInferenceAccelerators, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `ElasticInferenceAccelerator.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.HibernationOptions !== undefined) {
        const memberEntries = serializeAws_ec2HibernationOptionsRequest(input.HibernationOptions, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `HibernationOptions.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.IamInstanceProfile !== undefined) {
        const memberEntries = serializeAws_ec2IamInstanceProfileSpecification(input.IamInstanceProfile, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `IamInstanceProfile.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.ImageId !== undefined) {
        entries["ImageId"] = input.ImageId;
    }
    if (input.InstanceInitiatedShutdownBehavior !== undefined) {
        entries["InstanceInitiatedShutdownBehavior"] =
            input.InstanceInitiatedShutdownBehavior;
    }
    if (input.InstanceMarketOptions !== undefined) {
        const memberEntries = serializeAws_ec2InstanceMarketOptionsRequest(input.InstanceMarketOptions, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `InstanceMarketOptions.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.InstanceType !== undefined) {
        entries["InstanceType"] = input.InstanceType;
    }
    if (input.Ipv6AddressCount !== undefined) {
        entries["Ipv6AddressCount"] = input.Ipv6AddressCount;
    }
    if (input.Ipv6Addresses !== undefined) {
        const memberEntries = serializeAws_ec2InstanceIpv6AddressList(input.Ipv6Addresses, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Ipv6Address.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.KernelId !== undefined) {
        entries["KernelId"] = input.KernelId;
    }
    if (input.KeyName !== undefined) {
        entries["KeyName"] = input.KeyName;
    }
    if (input.LaunchTemplate !== undefined) {
        const memberEntries = serializeAws_ec2LaunchTemplateSpecification(input.LaunchTemplate, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `LaunchTemplate.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.LicenseSpecifications !== undefined) {
        const memberEntries = serializeAws_ec2LicenseSpecificationListRequest(input.LicenseSpecifications, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `LicenseSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.MaxCount !== undefined) {
        entries["MaxCount"] = input.MaxCount;
    }
    if (input.MetadataOptions !== undefined) {
        const memberEntries = serializeAws_ec2InstanceMetadataOptionsRequest(input.MetadataOptions, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `MetadataOptions.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.MinCount !== undefined) {
        entries["MinCount"] = input.MinCount;
    }
    if (input.Monitoring !== undefined) {
        const memberEntries = serializeAws_ec2RunInstancesMonitoringEnabled(input.Monitoring, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Monitoring.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.NetworkInterfaces !== undefined) {
        const memberEntries = serializeAws_ec2InstanceNetworkInterfaceSpecificationList(input.NetworkInterfaces, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `NetworkInterface.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.Placement !== undefined) {
        const memberEntries = serializeAws_ec2Placement(input.Placement, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Placement.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.PrivateIpAddress !== undefined) {
        entries["PrivateIpAddress"] = input.PrivateIpAddress;
    }
    if (input.RamdiskId !== undefined) {
        entries["RamdiskId"] = input.RamdiskId;
    }
    if (input.SecurityGroupIds !== undefined) {
        const memberEntries = serializeAws_ec2SecurityGroupIdStringList(input.SecurityGroupIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `SecurityGroupId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.SecurityGroups !== undefined) {
        const memberEntries = serializeAws_ec2SecurityGroupStringList(input.SecurityGroups, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `SecurityGroup.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.SubnetId !== undefined) {
        entries["SubnetId"] = input.SubnetId;
    }
    if (input.TagSpecifications !== undefined) {
        const memberEntries = serializeAws_ec2TagSpecificationList(input.TagSpecifications, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `TagSpecification.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.UserData !== undefined) {
        entries["UserData"] = input.UserData;
    }
    return entries;
};
const serializeAws_ec2RunScheduledInstancesRequest = (input, context) => {
    const entries = {};
    if (input.ClientToken === undefined) {
        input.ClientToken = uuid_1.v4();
    }
    if (input.ClientToken !== undefined) {
        entries["ClientToken"] = input.ClientToken;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.InstanceCount !== undefined) {
        entries["InstanceCount"] = input.InstanceCount;
    }
    if (input.LaunchSpecification !== undefined) {
        const memberEntries = serializeAws_ec2ScheduledInstancesLaunchSpecification(input.LaunchSpecification, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `LaunchSpecification.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.ScheduledInstanceId !== undefined) {
        entries["ScheduledInstanceId"] = input.ScheduledInstanceId;
    }
    return entries;
};
const serializeAws_ec2S3Storage = (input, context) => {
    const entries = {};
    if (input.AWSAccessKeyId !== undefined) {
        entries["AWSAccessKeyId"] = input.AWSAccessKeyId;
    }
    if (input.Bucket !== undefined) {
        entries["Bucket"] = input.Bucket;
    }
    if (input.Prefix !== undefined) {
        entries["Prefix"] = input.Prefix;
    }
    if (input.UploadPolicy !== undefined) {
        entries["UploadPolicy"] = context.base64Encoder(input.UploadPolicy);
    }
    if (input.UploadPolicySignature !== undefined) {
        entries["UploadPolicySignature"] = input.UploadPolicySignature;
    }
    return entries;
};
const serializeAws_ec2ScheduledInstanceIdRequestSet = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        entries[`ScheduledInstanceId.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const serializeAws_ec2ScheduledInstanceRecurrenceRequest = (input, context) => {
    const entries = {};
    if (input.Frequency !== undefined) {
        entries["Frequency"] = input.Frequency;
    }
    if (input.Interval !== undefined) {
        entries["Interval"] = input.Interval;
    }
    if (input.OccurrenceDays !== undefined) {
        const memberEntries = serializeAws_ec2OccurrenceDayRequestSet(input.OccurrenceDays, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `OccurrenceDay.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.OccurrenceRelativeToEnd !== undefined) {
        entries["OccurrenceRelativeToEnd"] = input.OccurrenceRelativeToEnd;
    }
    if (input.OccurrenceUnit !== undefined) {
        entries["OccurrenceUnit"] = input.OccurrenceUnit;
    }
    return entries;
};
const serializeAws_ec2ScheduledInstancesBlockDeviceMapping = (input, context) => {
    const entries = {};
    if (input.DeviceName !== undefined) {
        entries["DeviceName"] = input.DeviceName;
    }
    if (input.Ebs !== undefined) {
        const memberEntries = serializeAws_ec2ScheduledInstancesEbs(input.Ebs, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Ebs.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.NoDevice !== undefined) {
        entries["NoDevice"] = input.NoDevice;
    }
    if (input.VirtualName !== undefined) {
        entries["VirtualName"] = input.VirtualName;
    }
    return entries;
};
const serializeAws_ec2ScheduledInstancesBlockDeviceMappingSet = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        const memberEntries = serializeAws_ec2ScheduledInstancesBlockDeviceMapping(entry, context);
        Object.keys(memberEntries).forEach(key => {
            entries[`BlockDeviceMapping.${counter}.${key}`] = memberEntries[key];
        });
        counter++;
    }
    return entries;
};
const serializeAws_ec2ScheduledInstancesEbs = (input, context) => {
    const entries = {};
    if (input.DeleteOnTermination !== undefined) {
        entries["DeleteOnTermination"] = input.DeleteOnTermination;
    }
    if (input.Encrypted !== undefined) {
        entries["Encrypted"] = input.Encrypted;
    }
    if (input.Iops !== undefined) {
        entries["Iops"] = input.Iops;
    }
    if (input.SnapshotId !== undefined) {
        entries["SnapshotId"] = input.SnapshotId;
    }
    if (input.VolumeSize !== undefined) {
        entries["VolumeSize"] = input.VolumeSize;
    }
    if (input.VolumeType !== undefined) {
        entries["VolumeType"] = input.VolumeType;
    }
    return entries;
};
const serializeAws_ec2ScheduledInstancesIamInstanceProfile = (input, context) => {
    const entries = {};
    if (input.Arn !== undefined) {
        entries["Arn"] = input.Arn;
    }
    if (input.Name !== undefined) {
        entries["Name"] = input.Name;
    }
    return entries;
};
const serializeAws_ec2ScheduledInstancesIpv6Address = (input, context) => {
    const entries = {};
    if (input.Ipv6Address !== undefined) {
        entries["Ipv6Address"] = input.Ipv6Address;
    }
    return entries;
};
const serializeAws_ec2ScheduledInstancesIpv6AddressList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        const memberEntries = serializeAws_ec2ScheduledInstancesIpv6Address(entry, context);
        Object.keys(memberEntries).forEach(key => {
            entries[`Ipv6Address.${counter}.${key}`] = memberEntries[key];
        });
        counter++;
    }
    return entries;
};
const serializeAws_ec2ScheduledInstancesLaunchSpecification = (input, context) => {
    const entries = {};
    if (input.BlockDeviceMappings !== undefined) {
        const memberEntries = serializeAws_ec2ScheduledInstancesBlockDeviceMappingSet(input.BlockDeviceMappings, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `BlockDeviceMapping.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.EbsOptimized !== undefined) {
        entries["EbsOptimized"] = input.EbsOptimized;
    }
    if (input.IamInstanceProfile !== undefined) {
        const memberEntries = serializeAws_ec2ScheduledInstancesIamInstanceProfile(input.IamInstanceProfile, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `IamInstanceProfile.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.ImageId !== undefined) {
        entries["ImageId"] = input.ImageId;
    }
    if (input.InstanceType !== undefined) {
        entries["InstanceType"] = input.InstanceType;
    }
    if (input.KernelId !== undefined) {
        entries["KernelId"] = input.KernelId;
    }
    if (input.KeyName !== undefined) {
        entries["KeyName"] = input.KeyName;
    }
    if (input.Monitoring !== undefined) {
        const memberEntries = serializeAws_ec2ScheduledInstancesMonitoring(input.Monitoring, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Monitoring.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.NetworkInterfaces !== undefined) {
        const memberEntries = serializeAws_ec2ScheduledInstancesNetworkInterfaceSet(input.NetworkInterfaces, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `NetworkInterface.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.Placement !== undefined) {
        const memberEntries = serializeAws_ec2ScheduledInstancesPlacement(input.Placement, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Placement.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.RamdiskId !== undefined) {
        entries["RamdiskId"] = input.RamdiskId;
    }
    if (input.SecurityGroupIds !== undefined) {
        const memberEntries = serializeAws_ec2ScheduledInstancesSecurityGroupIdSet(input.SecurityGroupIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `SecurityGroupId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.SubnetId !== undefined) {
        entries["SubnetId"] = input.SubnetId;
    }
    if (input.UserData !== undefined) {
        entries["UserData"] = input.UserData;
    }
    return entries;
};
const serializeAws_ec2ScheduledInstancesMonitoring = (input, context) => {
    const entries = {};
    if (input.Enabled !== undefined) {
        entries["Enabled"] = input.Enabled;
    }
    return entries;
};
const serializeAws_ec2ScheduledInstancesNetworkInterface = (input, context) => {
    const entries = {};
    if (input.AssociatePublicIpAddress !== undefined) {
        entries["AssociatePublicIpAddress"] = input.AssociatePublicIpAddress;
    }
    if (input.DeleteOnTermination !== undefined) {
        entries["DeleteOnTermination"] = input.DeleteOnTermination;
    }
    if (input.Description !== undefined) {
        entries["Description"] = input.Description;
    }
    if (input.DeviceIndex !== undefined) {
        entries["DeviceIndex"] = input.DeviceIndex;
    }
    if (input.Groups !== undefined) {
        const memberEntries = serializeAws_ec2ScheduledInstancesSecurityGroupIdSet(input.Groups, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Group.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.Ipv6AddressCount !== undefined) {
        entries["Ipv6AddressCount"] = input.Ipv6AddressCount;
    }
    if (input.Ipv6Addresses !== undefined) {
        const memberEntries = serializeAws_ec2ScheduledInstancesIpv6AddressList(input.Ipv6Addresses, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Ipv6Address.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.NetworkInterfaceId !== undefined) {
        entries["NetworkInterfaceId"] = input.NetworkInterfaceId;
    }
    if (input.PrivateIpAddress !== undefined) {
        entries["PrivateIpAddress"] = input.PrivateIpAddress;
    }
    if (input.PrivateIpAddressConfigs !== undefined) {
        const memberEntries = serializeAws_ec2PrivateIpAddressConfigSet(input.PrivateIpAddressConfigs, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `PrivateIpAddressConfig.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.SecondaryPrivateIpAddressCount !== undefined) {
        entries["SecondaryPrivateIpAddressCount"] =
            input.SecondaryPrivateIpAddressCount;
    }
    if (input.SubnetId !== undefined) {
        entries["SubnetId"] = input.SubnetId;
    }
    return entries;
};
const serializeAws_ec2ScheduledInstancesNetworkInterfaceSet = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        const memberEntries = serializeAws_ec2ScheduledInstancesNetworkInterface(entry, context);
        Object.keys(memberEntries).forEach(key => {
            entries[`NetworkInterface.${counter}.${key}`] = memberEntries[key];
        });
        counter++;
    }
    return entries;
};
const serializeAws_ec2ScheduledInstancesPlacement = (input, context) => {
    const entries = {};
    if (input.AvailabilityZone !== undefined) {
        entries["AvailabilityZone"] = input.AvailabilityZone;
    }
    if (input.GroupName !== undefined) {
        entries["GroupName"] = input.GroupName;
    }
    return entries;
};
const serializeAws_ec2ScheduledInstancesPrivateIpAddressConfig = (input, context) => {
    const entries = {};
    if (input.Primary !== undefined) {
        entries["Primary"] = input.Primary;
    }
    if (input.PrivateIpAddress !== undefined) {
        entries["PrivateIpAddress"] = input.PrivateIpAddress;
    }
    return entries;
};
const serializeAws_ec2ScheduledInstancesSecurityGroupIdSet = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        entries[`SecurityGroupId.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const serializeAws_ec2SearchLocalGatewayRoutesRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Filters !== undefined) {
        const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.LocalGatewayRouteTableId !== undefined) {
        entries["LocalGatewayRouteTableId"] = input.LocalGatewayRouteTableId;
    }
    if (input.MaxResults !== undefined) {
        entries["MaxResults"] = input.MaxResults;
    }
    if (input.NextToken !== undefined) {
        entries["NextToken"] = input.NextToken;
    }
    return entries;
};
const serializeAws_ec2SearchTransitGatewayMulticastGroupsRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Filters !== undefined) {
        const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.MaxResults !== undefined) {
        entries["MaxResults"] = input.MaxResults;
    }
    if (input.NextToken !== undefined) {
        entries["NextToken"] = input.NextToken;
    }
    if (input.TransitGatewayMulticastDomainId !== undefined) {
        entries["TransitGatewayMulticastDomainId"] =
            input.TransitGatewayMulticastDomainId;
    }
    return entries;
};
const serializeAws_ec2SearchTransitGatewayRoutesRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Filters !== undefined) {
        const memberEntries = serializeAws_ec2FilterList(input.Filters, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Filter.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.MaxResults !== undefined) {
        entries["MaxResults"] = input.MaxResults;
    }
    if (input.TransitGatewayRouteTableId !== undefined) {
        entries["TransitGatewayRouteTableId"] = input.TransitGatewayRouteTableId;
    }
    return entries;
};
const serializeAws_ec2SecurityGroupIdStringList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        entries[`SecurityGroupId.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const serializeAws_ec2SecurityGroupStringList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        entries[`SecurityGroup.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const serializeAws_ec2SendDiagnosticInterruptRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.InstanceId !== undefined) {
        entries["InstanceId"] = input.InstanceId;
    }
    return entries;
};
const serializeAws_ec2SlotDateTimeRangeRequest = (input, context) => {
    const entries = {};
    if (input.EarliestTime !== undefined) {
        entries["EarliestTime"] =
            input.EarliestTime.toISOString().split(".")[0] + "Z";
    }
    if (input.LatestTime !== undefined) {
        entries["LatestTime"] = input.LatestTime.toISOString().split(".")[0] + "Z";
    }
    return entries;
};
const serializeAws_ec2SlotStartTimeRangeRequest = (input, context) => {
    const entries = {};
    if (input.EarliestTime !== undefined) {
        entries["EarliestTime"] =
            input.EarliestTime.toISOString().split(".")[0] + "Z";
    }
    if (input.LatestTime !== undefined) {
        entries["LatestTime"] = input.LatestTime.toISOString().split(".")[0] + "Z";
    }
    return entries;
};
const serializeAws_ec2SnapshotDiskContainer = (input, context) => {
    const entries = {};
    if (input.Description !== undefined) {
        entries["Description"] = input.Description;
    }
    if (input.Format !== undefined) {
        entries["Format"] = input.Format;
    }
    if (input.Url !== undefined) {
        entries["Url"] = input.Url;
    }
    if (input.UserBucket !== undefined) {
        const memberEntries = serializeAws_ec2UserBucket(input.UserBucket, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `UserBucket.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2SnapshotIdStringList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        entries[`SnapshotId.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const serializeAws_ec2SpotFleetLaunchSpecification = (input, context) => {
    const entries = {};
    if (input.AddressingType !== undefined) {
        entries["AddressingType"] = input.AddressingType;
    }
    if (input.BlockDeviceMappings !== undefined) {
        const memberEntries = serializeAws_ec2BlockDeviceMappingList(input.BlockDeviceMappings, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `BlockDeviceMapping.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.EbsOptimized !== undefined) {
        entries["EbsOptimized"] = input.EbsOptimized;
    }
    if (input.IamInstanceProfile !== undefined) {
        const memberEntries = serializeAws_ec2IamInstanceProfileSpecification(input.IamInstanceProfile, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `IamInstanceProfile.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.ImageId !== undefined) {
        entries["ImageId"] = input.ImageId;
    }
    if (input.InstanceType !== undefined) {
        entries["InstanceType"] = input.InstanceType;
    }
    if (input.KernelId !== undefined) {
        entries["KernelId"] = input.KernelId;
    }
    if (input.KeyName !== undefined) {
        entries["KeyName"] = input.KeyName;
    }
    if (input.Monitoring !== undefined) {
        const memberEntries = serializeAws_ec2SpotFleetMonitoring(input.Monitoring, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Monitoring.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.NetworkInterfaces !== undefined) {
        const memberEntries = serializeAws_ec2InstanceNetworkInterfaceSpecificationList(input.NetworkInterfaces, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `NetworkInterfaceSet.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.Placement !== undefined) {
        const memberEntries = serializeAws_ec2SpotPlacement(input.Placement, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Placement.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.RamdiskId !== undefined) {
        entries["RamdiskId"] = input.RamdiskId;
    }
    if (input.SecurityGroups !== undefined) {
        const memberEntries = serializeAws_ec2GroupIdentifierList(input.SecurityGroups, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `GroupSet.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.SpotPrice !== undefined) {
        entries["SpotPrice"] = input.SpotPrice;
    }
    if (input.SubnetId !== undefined) {
        entries["SubnetId"] = input.SubnetId;
    }
    if (input.TagSpecifications !== undefined) {
        const memberEntries = serializeAws_ec2SpotFleetTagSpecificationList(input.TagSpecifications, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `TagSpecificationSet.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.UserData !== undefined) {
        entries["UserData"] = input.UserData;
    }
    if (input.WeightedCapacity !== undefined) {
        entries["WeightedCapacity"] = input.WeightedCapacity;
    }
    return entries;
};
const serializeAws_ec2SpotFleetMonitoring = (input, context) => {
    const entries = {};
    if (input.Enabled !== undefined) {
        entries["Enabled"] = input.Enabled;
    }
    return entries;
};
const serializeAws_ec2SpotFleetRequestConfigData = (input, context) => {
    const entries = {};
    if (input.AllocationStrategy !== undefined) {
        entries["AllocationStrategy"] = input.AllocationStrategy;
    }
    if (input.ClientToken !== undefined) {
        entries["ClientToken"] = input.ClientToken;
    }
    if (input.ExcessCapacityTerminationPolicy !== undefined) {
        entries["ExcessCapacityTerminationPolicy"] =
            input.ExcessCapacityTerminationPolicy;
    }
    if (input.FulfilledCapacity !== undefined) {
        entries["FulfilledCapacity"] = input.FulfilledCapacity;
    }
    if (input.IamFleetRole !== undefined) {
        entries["IamFleetRole"] = input.IamFleetRole;
    }
    if (input.InstanceInterruptionBehavior !== undefined) {
        entries["InstanceInterruptionBehavior"] =
            input.InstanceInterruptionBehavior;
    }
    if (input.InstancePoolsToUseCount !== undefined) {
        entries["InstancePoolsToUseCount"] = input.InstancePoolsToUseCount;
    }
    if (input.LaunchSpecifications !== undefined) {
        const memberEntries = serializeAws_ec2LaunchSpecsList(input.LaunchSpecifications, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `LaunchSpecifications.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.LaunchTemplateConfigs !== undefined) {
        const memberEntries = serializeAws_ec2LaunchTemplateConfigList(input.LaunchTemplateConfigs, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `LaunchTemplateConfigs.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.LoadBalancersConfig !== undefined) {
        const memberEntries = serializeAws_ec2LoadBalancersConfig(input.LoadBalancersConfig, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `LoadBalancersConfig.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.OnDemandAllocationStrategy !== undefined) {
        entries["OnDemandAllocationStrategy"] = input.OnDemandAllocationStrategy;
    }
    if (input.OnDemandFulfilledCapacity !== undefined) {
        entries["OnDemandFulfilledCapacity"] = input.OnDemandFulfilledCapacity;
    }
    if (input.OnDemandMaxTotalPrice !== undefined) {
        entries["OnDemandMaxTotalPrice"] = input.OnDemandMaxTotalPrice;
    }
    if (input.OnDemandTargetCapacity !== undefined) {
        entries["OnDemandTargetCapacity"] = input.OnDemandTargetCapacity;
    }
    if (input.ReplaceUnhealthyInstances !== undefined) {
        entries["ReplaceUnhealthyInstances"] = input.ReplaceUnhealthyInstances;
    }
    if (input.SpotMaxTotalPrice !== undefined) {
        entries["SpotMaxTotalPrice"] = input.SpotMaxTotalPrice;
    }
    if (input.SpotPrice !== undefined) {
        entries["SpotPrice"] = input.SpotPrice;
    }
    if (input.TargetCapacity !== undefined) {
        entries["TargetCapacity"] = input.TargetCapacity;
    }
    if (input.TerminateInstancesWithExpiration !== undefined) {
        entries["TerminateInstancesWithExpiration"] =
            input.TerminateInstancesWithExpiration;
    }
    if (input.Type !== undefined) {
        entries["Type"] = input.Type;
    }
    if (input.ValidFrom !== undefined) {
        entries["ValidFrom"] = input.ValidFrom.toISOString().split(".")[0] + "Z";
    }
    if (input.ValidUntil !== undefined) {
        entries["ValidUntil"] = input.ValidUntil.toISOString().split(".")[0] + "Z";
    }
    return entries;
};
const serializeAws_ec2SpotFleetTagSpecification = (input, context) => {
    const entries = {};
    if (input.ResourceType !== undefined) {
        entries["ResourceType"] = input.ResourceType;
    }
    if (input.Tags !== undefined) {
        const memberEntries = serializeAws_ec2TagList(input.Tags, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Tag.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2SpotFleetTagSpecificationList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        const memberEntries = serializeAws_ec2SpotFleetTagSpecification(entry, context);
        Object.keys(memberEntries).forEach(key => {
            entries[`Item.${counter}.${key}`] = memberEntries[key];
        });
        counter++;
    }
    return entries;
};
const serializeAws_ec2SpotInstanceRequestIdList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        entries[`SpotInstanceRequestId.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const serializeAws_ec2SpotMarketOptions = (input, context) => {
    const entries = {};
    if (input.BlockDurationMinutes !== undefined) {
        entries["BlockDurationMinutes"] = input.BlockDurationMinutes;
    }
    if (input.InstanceInterruptionBehavior !== undefined) {
        entries["InstanceInterruptionBehavior"] =
            input.InstanceInterruptionBehavior;
    }
    if (input.MaxPrice !== undefined) {
        entries["MaxPrice"] = input.MaxPrice;
    }
    if (input.SpotInstanceType !== undefined) {
        entries["SpotInstanceType"] = input.SpotInstanceType;
    }
    if (input.ValidUntil !== undefined) {
        entries["ValidUntil"] = input.ValidUntil.toISOString().split(".")[0] + "Z";
    }
    return entries;
};
const serializeAws_ec2SpotOptionsRequest = (input, context) => {
    const entries = {};
    if (input.AllocationStrategy !== undefined) {
        entries["AllocationStrategy"] = input.AllocationStrategy;
    }
    if (input.InstanceInterruptionBehavior !== undefined) {
        entries["InstanceInterruptionBehavior"] =
            input.InstanceInterruptionBehavior;
    }
    if (input.InstancePoolsToUseCount !== undefined) {
        entries["InstancePoolsToUseCount"] = input.InstancePoolsToUseCount;
    }
    if (input.MaxTotalPrice !== undefined) {
        entries["MaxTotalPrice"] = input.MaxTotalPrice;
    }
    if (input.MinTargetCapacity !== undefined) {
        entries["MinTargetCapacity"] = input.MinTargetCapacity;
    }
    if (input.SingleAvailabilityZone !== undefined) {
        entries["SingleAvailabilityZone"] = input.SingleAvailabilityZone;
    }
    if (input.SingleInstanceType !== undefined) {
        entries["SingleInstanceType"] = input.SingleInstanceType;
    }
    return entries;
};
const serializeAws_ec2SpotPlacement = (input, context) => {
    const entries = {};
    if (input.AvailabilityZone !== undefined) {
        entries["AvailabilityZone"] = input.AvailabilityZone;
    }
    if (input.GroupName !== undefined) {
        entries["GroupName"] = input.GroupName;
    }
    if (input.Tenancy !== undefined) {
        entries["Tenancy"] = input.Tenancy;
    }
    return entries;
};
const serializeAws_ec2StartInstancesRequest = (input, context) => {
    const entries = {};
    if (input.AdditionalInfo !== undefined) {
        entries["AdditionalInfo"] = input.AdditionalInfo;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.InstanceIds !== undefined) {
        const memberEntries = serializeAws_ec2InstanceIdStringList(input.InstanceIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `InstanceId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2StartVpcEndpointServicePrivateDnsVerificationRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.ServiceId !== undefined) {
        entries["ServiceId"] = input.ServiceId;
    }
    return entries;
};
const serializeAws_ec2StopInstancesRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Force !== undefined) {
        entries["Force"] = input.Force;
    }
    if (input.Hibernate !== undefined) {
        entries["Hibernate"] = input.Hibernate;
    }
    if (input.InstanceIds !== undefined) {
        const memberEntries = serializeAws_ec2InstanceIdStringList(input.InstanceIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `InstanceId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2Storage = (input, context) => {
    const entries = {};
    if (input.S3 !== undefined) {
        const memberEntries = serializeAws_ec2S3Storage(input.S3, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `S3.${key}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2StorageLocation = (input, context) => {
    const entries = {};
    if (input.Bucket !== undefined) {
        entries["Bucket"] = input.Bucket;
    }
    if (input.Key !== undefined) {
        entries["Key"] = input.Key;
    }
    return entries;
};
const serializeAws_ec2SubnetIdStringList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        entries[`SubnetId.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const serializeAws_ec2Tag = (input, context) => {
    const entries = {};
    if (input.Key !== undefined) {
        entries["Key"] = input.Key;
    }
    if (input.Value !== undefined) {
        entries["Value"] = input.Value;
    }
    return entries;
};
const serializeAws_ec2TagList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        const memberEntries = serializeAws_ec2Tag(entry, context);
        Object.keys(memberEntries).forEach(key => {
            entries[`Item.${counter}.${key}`] = memberEntries[key];
        });
        counter++;
    }
    return entries;
};
const serializeAws_ec2TagSpecification = (input, context) => {
    const entries = {};
    if (input.ResourceType !== undefined) {
        entries["ResourceType"] = input.ResourceType;
    }
    if (input.Tags !== undefined) {
        const memberEntries = serializeAws_ec2TagList(input.Tags, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Tag.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2TagSpecificationList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        const memberEntries = serializeAws_ec2TagSpecification(entry, context);
        Object.keys(memberEntries).forEach(key => {
            entries[`Item.${counter}.${key}`] = memberEntries[key];
        });
        counter++;
    }
    return entries;
};
const serializeAws_ec2TargetCapacitySpecificationRequest = (input, context) => {
    const entries = {};
    if (input.DefaultTargetCapacityType !== undefined) {
        entries["DefaultTargetCapacityType"] = input.DefaultTargetCapacityType;
    }
    if (input.OnDemandTargetCapacity !== undefined) {
        entries["OnDemandTargetCapacity"] = input.OnDemandTargetCapacity;
    }
    if (input.SpotTargetCapacity !== undefined) {
        entries["SpotTargetCapacity"] = input.SpotTargetCapacity;
    }
    if (input.TotalTargetCapacity !== undefined) {
        entries["TotalTargetCapacity"] = input.TotalTargetCapacity;
    }
    return entries;
};
const serializeAws_ec2TargetConfigurationRequest = (input, context) => {
    const entries = {};
    if (input.InstanceCount !== undefined) {
        entries["InstanceCount"] = input.InstanceCount;
    }
    if (input.OfferingId !== undefined) {
        entries["OfferingId"] = input.OfferingId;
    }
    return entries;
};
const serializeAws_ec2TargetConfigurationRequestSet = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        const memberEntries = serializeAws_ec2TargetConfigurationRequest(entry, context);
        Object.keys(memberEntries).forEach(key => {
            entries[`TargetConfigurationRequest.${counter}.${key}`] =
                memberEntries[key];
        });
        counter++;
    }
    return entries;
};
const serializeAws_ec2TargetGroup = (input, context) => {
    const entries = {};
    if (input.Arn !== undefined) {
        entries["Arn"] = input.Arn;
    }
    return entries;
};
const serializeAws_ec2TargetGroups = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        const memberEntries = serializeAws_ec2TargetGroup(entry, context);
        Object.keys(memberEntries).forEach(key => {
            entries[`Item.${counter}.${key}`] = memberEntries[key];
        });
        counter++;
    }
    return entries;
};
const serializeAws_ec2TargetGroupsConfig = (input, context) => {
    const entries = {};
    if (input.TargetGroups !== undefined) {
        const memberEntries = serializeAws_ec2TargetGroups(input.TargetGroups, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `TargetGroups.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2TerminateClientVpnConnectionsRequest = (input, context) => {
    const entries = {};
    if (input.ClientVpnEndpointId !== undefined) {
        entries["ClientVpnEndpointId"] = input.ClientVpnEndpointId;
    }
    if (input.ConnectionId !== undefined) {
        entries["ConnectionId"] = input.ConnectionId;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.Username !== undefined) {
        entries["Username"] = input.Username;
    }
    return entries;
};
const serializeAws_ec2TerminateInstancesRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.InstanceIds !== undefined) {
        const memberEntries = serializeAws_ec2InstanceIdStringList(input.InstanceIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `InstanceId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2TrafficMirrorFilterRuleFieldList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        entries[`Member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const serializeAws_ec2TrafficMirrorNetworkServiceList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const serializeAws_ec2TrafficMirrorPortRangeRequest = (input, context) => {
    const entries = {};
    if (input.FromPort !== undefined) {
        entries["FromPort"] = input.FromPort;
    }
    if (input.ToPort !== undefined) {
        entries["ToPort"] = input.ToPort;
    }
    return entries;
};
const serializeAws_ec2TrafficMirrorSessionFieldList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        entries[`Member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const serializeAws_ec2TransitGatewayAttachmentIdStringList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        entries[`Member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const serializeAws_ec2TransitGatewayIdStringList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const serializeAws_ec2TransitGatewayMulticastDomainIdStringList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const serializeAws_ec2TransitGatewayRequestOptions = (input, context) => {
    const entries = {};
    if (input.AmazonSideAsn !== undefined) {
        entries["AmazonSideAsn"] = input.AmazonSideAsn;
    }
    if (input.AutoAcceptSharedAttachments !== undefined) {
        entries["AutoAcceptSharedAttachments"] = input.AutoAcceptSharedAttachments;
    }
    if (input.DefaultRouteTableAssociation !== undefined) {
        entries["DefaultRouteTableAssociation"] =
            input.DefaultRouteTableAssociation;
    }
    if (input.DefaultRouteTablePropagation !== undefined) {
        entries["DefaultRouteTablePropagation"] =
            input.DefaultRouteTablePropagation;
    }
    if (input.DnsSupport !== undefined) {
        entries["DnsSupport"] = input.DnsSupport;
    }
    if (input.MulticastSupport !== undefined) {
        entries["MulticastSupport"] = input.MulticastSupport;
    }
    if (input.VpnEcmpSupport !== undefined) {
        entries["VpnEcmpSupport"] = input.VpnEcmpSupport;
    }
    return entries;
};
const serializeAws_ec2TransitGatewayRouteTableIdStringList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const serializeAws_ec2UnassignIpv6AddressesRequest = (input, context) => {
    const entries = {};
    if (input.Ipv6Addresses !== undefined) {
        const memberEntries = serializeAws_ec2Ipv6AddressList(input.Ipv6Addresses, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Ipv6Addresses.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.NetworkInterfaceId !== undefined) {
        entries["NetworkInterfaceId"] = input.NetworkInterfaceId;
    }
    return entries;
};
const serializeAws_ec2UnassignPrivateIpAddressesRequest = (input, context) => {
    const entries = {};
    if (input.NetworkInterfaceId !== undefined) {
        entries["NetworkInterfaceId"] = input.NetworkInterfaceId;
    }
    if (input.PrivateIpAddresses !== undefined) {
        const memberEntries = serializeAws_ec2PrivateIpAddressStringList(input.PrivateIpAddresses, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `PrivateIpAddress.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2UnmonitorInstancesRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.InstanceIds !== undefined) {
        const memberEntries = serializeAws_ec2InstanceIdStringList(input.InstanceIds, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `InstanceId.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2UpdateSecurityGroupRuleDescriptionsEgressRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.GroupId !== undefined) {
        entries["GroupId"] = input.GroupId;
    }
    if (input.GroupName !== undefined) {
        entries["GroupName"] = input.GroupName;
    }
    if (input.IpPermissions !== undefined) {
        const memberEntries = serializeAws_ec2IpPermissionList(input.IpPermissions, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `IpPermissions.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2UpdateSecurityGroupRuleDescriptionsIngressRequest = (input, context) => {
    const entries = {};
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    if (input.GroupId !== undefined) {
        entries["GroupId"] = input.GroupId;
    }
    if (input.GroupName !== undefined) {
        entries["GroupName"] = input.GroupName;
    }
    if (input.IpPermissions !== undefined) {
        const memberEntries = serializeAws_ec2IpPermissionList(input.IpPermissions, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `IpPermissions.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2UserBucket = (input, context) => {
    const entries = {};
    if (input.S3Bucket !== undefined) {
        entries["S3Bucket"] = input.S3Bucket;
    }
    if (input.S3Key !== undefined) {
        entries["S3Key"] = input.S3Key;
    }
    return entries;
};
const serializeAws_ec2UserData = (input, context) => {
    const entries = {};
    if (input.Data !== undefined) {
        entries["Data"] = input.Data;
    }
    return entries;
};
const serializeAws_ec2UserGroupStringList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        entries[`UserGroup.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const serializeAws_ec2UserIdGroupPair = (input, context) => {
    const entries = {};
    if (input.Description !== undefined) {
        entries["Description"] = input.Description;
    }
    if (input.GroupId !== undefined) {
        entries["GroupId"] = input.GroupId;
    }
    if (input.GroupName !== undefined) {
        entries["GroupName"] = input.GroupName;
    }
    if (input.PeeringStatus !== undefined) {
        entries["PeeringStatus"] = input.PeeringStatus;
    }
    if (input.UserId !== undefined) {
        entries["UserId"] = input.UserId;
    }
    if (input.VpcId !== undefined) {
        entries["VpcId"] = input.VpcId;
    }
    if (input.VpcPeeringConnectionId !== undefined) {
        entries["VpcPeeringConnectionId"] = input.VpcPeeringConnectionId;
    }
    return entries;
};
const serializeAws_ec2UserIdGroupPairList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        const memberEntries = serializeAws_ec2UserIdGroupPair(entry, context);
        Object.keys(memberEntries).forEach(key => {
            entries[`Item.${counter}.${key}`] = memberEntries[key];
        });
        counter++;
    }
    return entries;
};
const serializeAws_ec2UserIdStringList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        entries[`UserId.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const serializeAws_ec2ValueStringList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const serializeAws_ec2VersionStringList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        entries[`Item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const serializeAws_ec2VolumeDetail = (input, context) => {
    const entries = {};
    if (input.Size !== undefined) {
        entries["Size"] = input.Size;
    }
    return entries;
};
const serializeAws_ec2VolumeIdStringList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        entries[`VolumeId.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const serializeAws_ec2VpcClassicLinkIdList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        entries[`VpcId.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const serializeAws_ec2VpcIdStringList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        entries[`VpcId.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const serializeAws_ec2VpnConnectionIdStringList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        entries[`VpnConnectionId.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const serializeAws_ec2VpnConnectionOptionsSpecification = (input, context) => {
    const entries = {};
    if (input.EnableAcceleration !== undefined) {
        entries["EnableAcceleration"] = input.EnableAcceleration;
    }
    if (input.StaticRoutesOnly !== undefined) {
        entries["StaticRoutesOnly"] = input.StaticRoutesOnly;
    }
    if (input.TunnelOptions !== undefined) {
        const memberEntries = serializeAws_ec2VpnTunnelOptionsSpecificationsList(input.TunnelOptions, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `TunnelOptions.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    return entries;
};
const serializeAws_ec2VpnGatewayIdStringList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        entries[`VpnGatewayId.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const serializeAws_ec2VpnTunnelOptionsSpecification = (input, context) => {
    const entries = {};
    if (input.DPDTimeoutSeconds !== undefined) {
        entries["DPDTimeoutSeconds"] = input.DPDTimeoutSeconds;
    }
    if (input.IKEVersions !== undefined) {
        const memberEntries = serializeAws_ec2IKEVersionsRequestList(input.IKEVersions, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `IKEVersion.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.Phase1DHGroupNumbers !== undefined) {
        const memberEntries = serializeAws_ec2Phase1DHGroupNumbersRequestList(input.Phase1DHGroupNumbers, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Phase1DHGroupNumber.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.Phase1EncryptionAlgorithms !== undefined) {
        const memberEntries = serializeAws_ec2Phase1EncryptionAlgorithmsRequestList(input.Phase1EncryptionAlgorithms, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Phase1EncryptionAlgorithm.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.Phase1IntegrityAlgorithms !== undefined) {
        const memberEntries = serializeAws_ec2Phase1IntegrityAlgorithmsRequestList(input.Phase1IntegrityAlgorithms, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Phase1IntegrityAlgorithm.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.Phase1LifetimeSeconds !== undefined) {
        entries["Phase1LifetimeSeconds"] = input.Phase1LifetimeSeconds;
    }
    if (input.Phase2DHGroupNumbers !== undefined) {
        const memberEntries = serializeAws_ec2Phase2DHGroupNumbersRequestList(input.Phase2DHGroupNumbers, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Phase2DHGroupNumber.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.Phase2EncryptionAlgorithms !== undefined) {
        const memberEntries = serializeAws_ec2Phase2EncryptionAlgorithmsRequestList(input.Phase2EncryptionAlgorithms, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Phase2EncryptionAlgorithm.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.Phase2IntegrityAlgorithms !== undefined) {
        const memberEntries = serializeAws_ec2Phase2IntegrityAlgorithmsRequestList(input.Phase2IntegrityAlgorithms, context);
        Object.keys(memberEntries).forEach(key => {
            const loc = `Phase2IntegrityAlgorithm.${key.substring(key.indexOf(".") + 1)}`;
            entries[loc] = memberEntries[key];
        });
    }
    if (input.Phase2LifetimeSeconds !== undefined) {
        entries["Phase2LifetimeSeconds"] = input.Phase2LifetimeSeconds;
    }
    if (input.PreSharedKey !== undefined) {
        entries["PreSharedKey"] = input.PreSharedKey;
    }
    if (input.RekeyFuzzPercentage !== undefined) {
        entries["RekeyFuzzPercentage"] = input.RekeyFuzzPercentage;
    }
    if (input.RekeyMarginTimeSeconds !== undefined) {
        entries["RekeyMarginTimeSeconds"] = input.RekeyMarginTimeSeconds;
    }
    if (input.ReplayWindowSize !== undefined) {
        entries["ReplayWindowSize"] = input.ReplayWindowSize;
    }
    if (input.TunnelInsideCidr !== undefined) {
        entries["TunnelInsideCidr"] = input.TunnelInsideCidr;
    }
    return entries;
};
const serializeAws_ec2VpnTunnelOptionsSpecificationsList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        const memberEntries = serializeAws_ec2VpnTunnelOptionsSpecification(entry, context);
        Object.keys(memberEntries).forEach(key => {
            entries[`Member.${counter}.${key}`] = memberEntries[key];
        });
        counter++;
    }
    return entries;
};
const serializeAws_ec2WithdrawByoipCidrRequest = (input, context) => {
    const entries = {};
    if (input.Cidr !== undefined) {
        entries["Cidr"] = input.Cidr;
    }
    if (input.DryRun !== undefined) {
        entries["DryRun"] = input.DryRun;
    }
    return entries;
};
const serializeAws_ec2ZoneIdStringList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        entries[`ZoneId.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const serializeAws_ec2ZoneNameStringList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (let entry of input) {
        entries[`ZoneName.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const deserializeAws_ec2AcceptReservedInstancesExchangeQuoteResult = (output, context) => {
    let contents = {
        __type: "AcceptReservedInstancesExchangeQuoteResult",
        ExchangeId: undefined
    };
    if (output["exchangeId"] !== undefined) {
        contents.ExchangeId = output["exchangeId"];
    }
    return contents;
};
const deserializeAws_ec2AcceptTransitGatewayPeeringAttachmentResult = (output, context) => {
    let contents = {
        __type: "AcceptTransitGatewayPeeringAttachmentResult",
        TransitGatewayPeeringAttachment: undefined
    };
    if (output["transitGatewayPeeringAttachment"] !== undefined) {
        contents.TransitGatewayPeeringAttachment = deserializeAws_ec2TransitGatewayPeeringAttachment(output["transitGatewayPeeringAttachment"], context);
    }
    return contents;
};
const deserializeAws_ec2AcceptTransitGatewayVpcAttachmentResult = (output, context) => {
    let contents = {
        __type: "AcceptTransitGatewayVpcAttachmentResult",
        TransitGatewayVpcAttachment: undefined
    };
    if (output["transitGatewayVpcAttachment"] !== undefined) {
        contents.TransitGatewayVpcAttachment = deserializeAws_ec2TransitGatewayVpcAttachment(output["transitGatewayVpcAttachment"], context);
    }
    return contents;
};
const deserializeAws_ec2AcceptVpcEndpointConnectionsResult = (output, context) => {
    let contents = {
        __type: "AcceptVpcEndpointConnectionsResult",
        Unsuccessful: undefined
    };
    if (output.unsuccessful === "") {
        contents.Unsuccessful = [];
    }
    if (output["unsuccessful"] !== undefined &&
        output["unsuccessful"]["item"] !== undefined) {
        const wrappedItem = output["unsuccessful"]["item"] instanceof Array
            ? output["unsuccessful"]["item"]
            : [output["unsuccessful"]["item"]];
        contents.Unsuccessful = deserializeAws_ec2UnsuccessfulItemSet(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2AcceptVpcPeeringConnectionResult = (output, context) => {
    let contents = {
        __type: "AcceptVpcPeeringConnectionResult",
        VpcPeeringConnection: undefined
    };
    if (output["vpcPeeringConnection"] !== undefined) {
        contents.VpcPeeringConnection = deserializeAws_ec2VpcPeeringConnection(output["vpcPeeringConnection"], context);
    }
    return contents;
};
const deserializeAws_ec2AccountAttribute = (output, context) => {
    let contents = {
        __type: "AccountAttribute",
        AttributeName: undefined,
        AttributeValues: undefined
    };
    if (output["attributeName"] !== undefined) {
        contents.AttributeName = output["attributeName"];
    }
    if (output.attributeValueSet === "") {
        contents.AttributeValues = [];
    }
    if (output["attributeValueSet"] !== undefined &&
        output["attributeValueSet"]["item"] !== undefined) {
        const wrappedItem = output["attributeValueSet"]["item"] instanceof Array
            ? output["attributeValueSet"]["item"]
            : [output["attributeValueSet"]["item"]];
        contents.AttributeValues = deserializeAws_ec2AccountAttributeValueList(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2AccountAttributeList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2AccountAttribute(entry, context));
    });
    return contents;
};
const deserializeAws_ec2AccountAttributeValue = (output, context) => {
    let contents = {
        __type: "AccountAttributeValue",
        AttributeValue: undefined
    };
    if (output["attributeValue"] !== undefined) {
        contents.AttributeValue = output["attributeValue"];
    }
    return contents;
};
const deserializeAws_ec2AccountAttributeValueList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2AccountAttributeValue(entry, context));
    });
    return contents;
};
const deserializeAws_ec2ActiveInstance = (output, context) => {
    let contents = {
        __type: "ActiveInstance",
        InstanceHealth: undefined,
        InstanceId: undefined,
        InstanceType: undefined,
        SpotInstanceRequestId: undefined
    };
    if (output["instanceHealth"] !== undefined) {
        contents.InstanceHealth = output["instanceHealth"];
    }
    if (output["instanceId"] !== undefined) {
        contents.InstanceId = output["instanceId"];
    }
    if (output["instanceType"] !== undefined) {
        contents.InstanceType = output["instanceType"];
    }
    if (output["spotInstanceRequestId"] !== undefined) {
        contents.SpotInstanceRequestId = output["spotInstanceRequestId"];
    }
    return contents;
};
const deserializeAws_ec2ActiveInstanceSet = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2ActiveInstance(entry, context));
    });
    return contents;
};
const deserializeAws_ec2Address = (output, context) => {
    let contents = {
        __type: "Address",
        AllocationId: undefined,
        AssociationId: undefined,
        CustomerOwnedIp: undefined,
        CustomerOwnedIpv4Pool: undefined,
        Domain: undefined,
        InstanceId: undefined,
        NetworkBorderGroup: undefined,
        NetworkInterfaceId: undefined,
        NetworkInterfaceOwnerId: undefined,
        PrivateIpAddress: undefined,
        PublicIp: undefined,
        PublicIpv4Pool: undefined,
        Tags: undefined
    };
    if (output["allocationId"] !== undefined) {
        contents.AllocationId = output["allocationId"];
    }
    if (output["associationId"] !== undefined) {
        contents.AssociationId = output["associationId"];
    }
    if (output["customerOwnedIp"] !== undefined) {
        contents.CustomerOwnedIp = output["customerOwnedIp"];
    }
    if (output["customerOwnedIpv4Pool"] !== undefined) {
        contents.CustomerOwnedIpv4Pool = output["customerOwnedIpv4Pool"];
    }
    if (output["domain"] !== undefined) {
        contents.Domain = output["domain"];
    }
    if (output["instanceId"] !== undefined) {
        contents.InstanceId = output["instanceId"];
    }
    if (output["networkBorderGroup"] !== undefined) {
        contents.NetworkBorderGroup = output["networkBorderGroup"];
    }
    if (output["networkInterfaceId"] !== undefined) {
        contents.NetworkInterfaceId = output["networkInterfaceId"];
    }
    if (output["networkInterfaceOwnerId"] !== undefined) {
        contents.NetworkInterfaceOwnerId = output["networkInterfaceOwnerId"];
    }
    if (output["privateIpAddress"] !== undefined) {
        contents.PrivateIpAddress = output["privateIpAddress"];
    }
    if (output["publicIp"] !== undefined) {
        contents.PublicIp = output["publicIp"];
    }
    if (output["publicIpv4Pool"] !== undefined) {
        contents.PublicIpv4Pool = output["publicIpv4Pool"];
    }
    if (output.tagSet === "") {
        contents.Tags = [];
    }
    if (output["tagSet"] !== undefined &&
        output["tagSet"]["item"] !== undefined) {
        const wrappedItem = output["tagSet"]["item"] instanceof Array
            ? output["tagSet"]["item"]
            : [output["tagSet"]["item"]];
        contents.Tags = deserializeAws_ec2TagList(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2AddressList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2Address(entry, context));
    });
    return contents;
};
const deserializeAws_ec2AdvertiseByoipCidrResult = (output, context) => {
    let contents = {
        __type: "AdvertiseByoipCidrResult",
        ByoipCidr: undefined
    };
    if (output["byoipCidr"] !== undefined) {
        contents.ByoipCidr = deserializeAws_ec2ByoipCidr(output["byoipCidr"], context);
    }
    return contents;
};
const deserializeAws_ec2AllocateAddressResult = (output, context) => {
    let contents = {
        __type: "AllocateAddressResult",
        AllocationId: undefined,
        CustomerOwnedIp: undefined,
        CustomerOwnedIpv4Pool: undefined,
        Domain: undefined,
        NetworkBorderGroup: undefined,
        PublicIp: undefined,
        PublicIpv4Pool: undefined
    };
    if (output["allocationId"] !== undefined) {
        contents.AllocationId = output["allocationId"];
    }
    if (output["customerOwnedIp"] !== undefined) {
        contents.CustomerOwnedIp = output["customerOwnedIp"];
    }
    if (output["customerOwnedIpv4Pool"] !== undefined) {
        contents.CustomerOwnedIpv4Pool = output["customerOwnedIpv4Pool"];
    }
    if (output["domain"] !== undefined) {
        contents.Domain = output["domain"];
    }
    if (output["networkBorderGroup"] !== undefined) {
        contents.NetworkBorderGroup = output["networkBorderGroup"];
    }
    if (output["publicIp"] !== undefined) {
        contents.PublicIp = output["publicIp"];
    }
    if (output["publicIpv4Pool"] !== undefined) {
        contents.PublicIpv4Pool = output["publicIpv4Pool"];
    }
    return contents;
};
const deserializeAws_ec2AllocateHostsResult = (output, context) => {
    let contents = {
        __type: "AllocateHostsResult",
        HostIds: undefined
    };
    if (output.hostIdSet === "") {
        contents.HostIds = [];
    }
    if (output["hostIdSet"] !== undefined &&
        output["hostIdSet"]["item"] !== undefined) {
        const wrappedItem = output["hostIdSet"]["item"] instanceof Array
            ? output["hostIdSet"]["item"]
            : [output["hostIdSet"]["item"]];
        contents.HostIds = deserializeAws_ec2ResponseHostIdList(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2AllowedPrincipal = (output, context) => {
    let contents = {
        __type: "AllowedPrincipal",
        Principal: undefined,
        PrincipalType: undefined
    };
    if (output["principal"] !== undefined) {
        contents.Principal = output["principal"];
    }
    if (output["principalType"] !== undefined) {
        contents.PrincipalType = output["principalType"];
    }
    return contents;
};
const deserializeAws_ec2AllowedPrincipalSet = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2AllowedPrincipal(entry, context));
    });
    return contents;
};
const deserializeAws_ec2ApplySecurityGroupsToClientVpnTargetNetworkResult = (output, context) => {
    let contents = {
        __type: "ApplySecurityGroupsToClientVpnTargetNetworkResult",
        SecurityGroupIds: undefined
    };
    if (output.securityGroupIds === "") {
        contents.SecurityGroupIds = [];
    }
    if (output["securityGroupIds"] !== undefined &&
        output["securityGroupIds"]["item"] !== undefined) {
        const wrappedItem = output["securityGroupIds"]["item"] instanceof Array
            ? output["securityGroupIds"]["item"]
            : [output["securityGroupIds"]["item"]];
        contents.SecurityGroupIds = deserializeAws_ec2ClientVpnSecurityGroupIdSet(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2ArchitectureTypeList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(entry);
    });
    return contents;
};
const deserializeAws_ec2AssignIpv6AddressesResult = (output, context) => {
    let contents = {
        __type: "AssignIpv6AddressesResult",
        AssignedIpv6Addresses: undefined,
        NetworkInterfaceId: undefined
    };
    if (output.assignedIpv6Addresses === "") {
        contents.AssignedIpv6Addresses = [];
    }
    if (output["assignedIpv6Addresses"] !== undefined &&
        output["assignedIpv6Addresses"]["item"] !== undefined) {
        const wrappedItem = output["assignedIpv6Addresses"]["item"] instanceof Array
            ? output["assignedIpv6Addresses"]["item"]
            : [output["assignedIpv6Addresses"]["item"]];
        contents.AssignedIpv6Addresses = deserializeAws_ec2Ipv6AddressList(wrappedItem, context);
    }
    if (output["networkInterfaceId"] !== undefined) {
        contents.NetworkInterfaceId = output["networkInterfaceId"];
    }
    return contents;
};
const deserializeAws_ec2AssignPrivateIpAddressesResult = (output, context) => {
    let contents = {
        __type: "AssignPrivateIpAddressesResult",
        AssignedPrivateIpAddresses: undefined,
        NetworkInterfaceId: undefined
    };
    if (output.assignedPrivateIpAddressesSet === "") {
        contents.AssignedPrivateIpAddresses = [];
    }
    if (output["assignedPrivateIpAddressesSet"] !== undefined &&
        output["assignedPrivateIpAddressesSet"]["item"] !== undefined) {
        const wrappedItem = output["assignedPrivateIpAddressesSet"]["item"] instanceof Array
            ? output["assignedPrivateIpAddressesSet"]["item"]
            : [output["assignedPrivateIpAddressesSet"]["item"]];
        contents.AssignedPrivateIpAddresses = deserializeAws_ec2AssignedPrivateIpAddressList(wrappedItem, context);
    }
    if (output["networkInterfaceId"] !== undefined) {
        contents.NetworkInterfaceId = output["networkInterfaceId"];
    }
    return contents;
};
const deserializeAws_ec2AssignedPrivateIpAddress = (output, context) => {
    let contents = {
        __type: "AssignedPrivateIpAddress",
        PrivateIpAddress: undefined
    };
    if (output["privateIpAddress"] !== undefined) {
        contents.PrivateIpAddress = output["privateIpAddress"];
    }
    return contents;
};
const deserializeAws_ec2AssignedPrivateIpAddressList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2AssignedPrivateIpAddress(entry, context));
    });
    return contents;
};
const deserializeAws_ec2AssociateAddressResult = (output, context) => {
    let contents = {
        __type: "AssociateAddressResult",
        AssociationId: undefined
    };
    if (output["associationId"] !== undefined) {
        contents.AssociationId = output["associationId"];
    }
    return contents;
};
const deserializeAws_ec2AssociateClientVpnTargetNetworkResult = (output, context) => {
    let contents = {
        __type: "AssociateClientVpnTargetNetworkResult",
        AssociationId: undefined,
        Status: undefined
    };
    if (output["associationId"] !== undefined) {
        contents.AssociationId = output["associationId"];
    }
    if (output["status"] !== undefined) {
        contents.Status = deserializeAws_ec2AssociationStatus(output["status"], context);
    }
    return contents;
};
const deserializeAws_ec2AssociateIamInstanceProfileResult = (output, context) => {
    let contents = {
        __type: "AssociateIamInstanceProfileResult",
        IamInstanceProfileAssociation: undefined
    };
    if (output["iamInstanceProfileAssociation"] !== undefined) {
        contents.IamInstanceProfileAssociation = deserializeAws_ec2IamInstanceProfileAssociation(output["iamInstanceProfileAssociation"], context);
    }
    return contents;
};
const deserializeAws_ec2AssociateRouteTableResult = (output, context) => {
    let contents = {
        __type: "AssociateRouteTableResult",
        AssociationId: undefined,
        AssociationState: undefined
    };
    if (output["associationId"] !== undefined) {
        contents.AssociationId = output["associationId"];
    }
    if (output["associationState"] !== undefined) {
        contents.AssociationState = deserializeAws_ec2RouteTableAssociationState(output["associationState"], context);
    }
    return contents;
};
const deserializeAws_ec2AssociateSubnetCidrBlockResult = (output, context) => {
    let contents = {
        __type: "AssociateSubnetCidrBlockResult",
        Ipv6CidrBlockAssociation: undefined,
        SubnetId: undefined
    };
    if (output["ipv6CidrBlockAssociation"] !== undefined) {
        contents.Ipv6CidrBlockAssociation = deserializeAws_ec2SubnetIpv6CidrBlockAssociation(output["ipv6CidrBlockAssociation"], context);
    }
    if (output["subnetId"] !== undefined) {
        contents.SubnetId = output["subnetId"];
    }
    return contents;
};
const deserializeAws_ec2AssociateTransitGatewayMulticastDomainResult = (output, context) => {
    let contents = {
        __type: "AssociateTransitGatewayMulticastDomainResult",
        Associations: undefined
    };
    if (output["associations"] !== undefined) {
        contents.Associations = deserializeAws_ec2TransitGatewayMulticastDomainAssociations(output["associations"], context);
    }
    return contents;
};
const deserializeAws_ec2AssociateTransitGatewayRouteTableResult = (output, context) => {
    let contents = {
        __type: "AssociateTransitGatewayRouteTableResult",
        Association: undefined
    };
    if (output["association"] !== undefined) {
        contents.Association = deserializeAws_ec2TransitGatewayAssociation(output["association"], context);
    }
    return contents;
};
const deserializeAws_ec2AssociateVpcCidrBlockResult = (output, context) => {
    let contents = {
        __type: "AssociateVpcCidrBlockResult",
        CidrBlockAssociation: undefined,
        Ipv6CidrBlockAssociation: undefined,
        VpcId: undefined
    };
    if (output["cidrBlockAssociation"] !== undefined) {
        contents.CidrBlockAssociation = deserializeAws_ec2VpcCidrBlockAssociation(output["cidrBlockAssociation"], context);
    }
    if (output["ipv6CidrBlockAssociation"] !== undefined) {
        contents.Ipv6CidrBlockAssociation = deserializeAws_ec2VpcIpv6CidrBlockAssociation(output["ipv6CidrBlockAssociation"], context);
    }
    if (output["vpcId"] !== undefined) {
        contents.VpcId = output["vpcId"];
    }
    return contents;
};
const deserializeAws_ec2AssociatedTargetNetwork = (output, context) => {
    let contents = {
        __type: "AssociatedTargetNetwork",
        NetworkId: undefined,
        NetworkType: undefined
    };
    if (output["networkId"] !== undefined) {
        contents.NetworkId = output["networkId"];
    }
    if (output["networkType"] !== undefined) {
        contents.NetworkType = output["networkType"];
    }
    return contents;
};
const deserializeAws_ec2AssociatedTargetNetworkSet = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2AssociatedTargetNetwork(entry, context));
    });
    return contents;
};
const deserializeAws_ec2AssociationStatus = (output, context) => {
    let contents = {
        __type: "AssociationStatus",
        Code: undefined,
        Message: undefined
    };
    if (output["code"] !== undefined) {
        contents.Code = output["code"];
    }
    if (output["message"] !== undefined) {
        contents.Message = output["message"];
    }
    return contents;
};
const deserializeAws_ec2AttachClassicLinkVpcResult = (output, context) => {
    let contents = {
        __type: "AttachClassicLinkVpcResult",
        Return: undefined
    };
    if (output["return"] !== undefined) {
        contents.Return = output["return"] == "true";
    }
    return contents;
};
const deserializeAws_ec2AttachNetworkInterfaceResult = (output, context) => {
    let contents = {
        __type: "AttachNetworkInterfaceResult",
        AttachmentId: undefined
    };
    if (output["attachmentId"] !== undefined) {
        contents.AttachmentId = output["attachmentId"];
    }
    return contents;
};
const deserializeAws_ec2AttachVpnGatewayResult = (output, context) => {
    let contents = {
        __type: "AttachVpnGatewayResult",
        VpcAttachment: undefined
    };
    if (output["attachment"] !== undefined) {
        contents.VpcAttachment = deserializeAws_ec2VpcAttachment(output["attachment"], context);
    }
    return contents;
};
const deserializeAws_ec2AttributeBooleanValue = (output, context) => {
    let contents = {
        __type: "AttributeBooleanValue",
        Value: undefined
    };
    if (output["value"] !== undefined) {
        contents.Value = output["value"] == "true";
    }
    return contents;
};
const deserializeAws_ec2AttributeValue = (output, context) => {
    let contents = {
        __type: "AttributeValue",
        Value: undefined
    };
    if (output["value"] !== undefined) {
        contents.Value = output["value"];
    }
    return contents;
};
const deserializeAws_ec2AuthorizationRule = (output, context) => {
    let contents = {
        __type: "AuthorizationRule",
        AccessAll: undefined,
        ClientVpnEndpointId: undefined,
        Description: undefined,
        DestinationCidr: undefined,
        GroupId: undefined,
        Status: undefined
    };
    if (output["accessAll"] !== undefined) {
        contents.AccessAll = output["accessAll"] == "true";
    }
    if (output["clientVpnEndpointId"] !== undefined) {
        contents.ClientVpnEndpointId = output["clientVpnEndpointId"];
    }
    if (output["description"] !== undefined) {
        contents.Description = output["description"];
    }
    if (output["destinationCidr"] !== undefined) {
        contents.DestinationCidr = output["destinationCidr"];
    }
    if (output["groupId"] !== undefined) {
        contents.GroupId = output["groupId"];
    }
    if (output["status"] !== undefined) {
        contents.Status = deserializeAws_ec2ClientVpnAuthorizationRuleStatus(output["status"], context);
    }
    return contents;
};
const deserializeAws_ec2AuthorizationRuleSet = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2AuthorizationRule(entry, context));
    });
    return contents;
};
const deserializeAws_ec2AuthorizeClientVpnIngressResult = (output, context) => {
    let contents = {
        __type: "AuthorizeClientVpnIngressResult",
        Status: undefined
    };
    if (output["status"] !== undefined) {
        contents.Status = deserializeAws_ec2ClientVpnAuthorizationRuleStatus(output["status"], context);
    }
    return contents;
};
const deserializeAws_ec2AvailabilityZone = (output, context) => {
    let contents = {
        __type: "AvailabilityZone",
        GroupName: undefined,
        Messages: undefined,
        NetworkBorderGroup: undefined,
        OptInStatus: undefined,
        RegionName: undefined,
        State: undefined,
        ZoneId: undefined,
        ZoneName: undefined
    };
    if (output["groupName"] !== undefined) {
        contents.GroupName = output["groupName"];
    }
    if (output.messageSet === "") {
        contents.Messages = [];
    }
    if (output["messageSet"] !== undefined &&
        output["messageSet"]["item"] !== undefined) {
        const wrappedItem = output["messageSet"]["item"] instanceof Array
            ? output["messageSet"]["item"]
            : [output["messageSet"]["item"]];
        contents.Messages = deserializeAws_ec2AvailabilityZoneMessageList(wrappedItem, context);
    }
    if (output["networkBorderGroup"] !== undefined) {
        contents.NetworkBorderGroup = output["networkBorderGroup"];
    }
    if (output["optInStatus"] !== undefined) {
        contents.OptInStatus = output["optInStatus"];
    }
    if (output["regionName"] !== undefined) {
        contents.RegionName = output["regionName"];
    }
    if (output["zoneState"] !== undefined) {
        contents.State = output["zoneState"];
    }
    if (output["zoneId"] !== undefined) {
        contents.ZoneId = output["zoneId"];
    }
    if (output["zoneName"] !== undefined) {
        contents.ZoneName = output["zoneName"];
    }
    return contents;
};
const deserializeAws_ec2AvailabilityZoneList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2AvailabilityZone(entry, context));
    });
    return contents;
};
const deserializeAws_ec2AvailabilityZoneMessage = (output, context) => {
    let contents = {
        __type: "AvailabilityZoneMessage",
        Message: undefined
    };
    if (output["message"] !== undefined) {
        contents.Message = output["message"];
    }
    return contents;
};
const deserializeAws_ec2AvailabilityZoneMessageList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2AvailabilityZoneMessage(entry, context));
    });
    return contents;
};
const deserializeAws_ec2AvailableCapacity = (output, context) => {
    let contents = {
        __type: "AvailableCapacity",
        AvailableInstanceCapacity: undefined,
        AvailableVCpus: undefined
    };
    if (output.availableInstanceCapacity === "") {
        contents.AvailableInstanceCapacity = [];
    }
    if (output["availableInstanceCapacity"] !== undefined &&
        output["availableInstanceCapacity"]["item"] !== undefined) {
        const wrappedItem = output["availableInstanceCapacity"]["item"] instanceof Array
            ? output["availableInstanceCapacity"]["item"]
            : [output["availableInstanceCapacity"]["item"]];
        contents.AvailableInstanceCapacity = deserializeAws_ec2AvailableInstanceCapacityList(wrappedItem, context);
    }
    if (output["availableVCpus"] !== undefined) {
        contents.AvailableVCpus = parseInt(output["availableVCpus"]);
    }
    return contents;
};
const deserializeAws_ec2AvailableInstanceCapacityList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2InstanceCapacity(entry, context));
    });
    return contents;
};
const deserializeAws_ec2BlockDeviceMapping = (output, context) => {
    let contents = {
        __type: "BlockDeviceMapping",
        DeviceName: undefined,
        Ebs: undefined,
        NoDevice: undefined,
        VirtualName: undefined
    };
    if (output["deviceName"] !== undefined) {
        contents.DeviceName = output["deviceName"];
    }
    if (output["ebs"] !== undefined) {
        contents.Ebs = deserializeAws_ec2EbsBlockDevice(output["ebs"], context);
    }
    if (output["noDevice"] !== undefined) {
        contents.NoDevice = output["noDevice"];
    }
    if (output["virtualName"] !== undefined) {
        contents.VirtualName = output["virtualName"];
    }
    return contents;
};
const deserializeAws_ec2BlockDeviceMappingList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2BlockDeviceMapping(entry, context));
    });
    return contents;
};
const deserializeAws_ec2BundleInstanceResult = (output, context) => {
    let contents = {
        __type: "BundleInstanceResult",
        BundleTask: undefined
    };
    if (output["bundleInstanceTask"] !== undefined) {
        contents.BundleTask = deserializeAws_ec2BundleTask(output["bundleInstanceTask"], context);
    }
    return contents;
};
const deserializeAws_ec2BundleTask = (output, context) => {
    let contents = {
        __type: "BundleTask",
        BundleId: undefined,
        BundleTaskError: undefined,
        InstanceId: undefined,
        Progress: undefined,
        StartTime: undefined,
        State: undefined,
        Storage: undefined,
        UpdateTime: undefined
    };
    if (output["bundleId"] !== undefined) {
        contents.BundleId = output["bundleId"];
    }
    if (output["error"] !== undefined) {
        contents.BundleTaskError = deserializeAws_ec2BundleTaskError(output["error"], context);
    }
    if (output["instanceId"] !== undefined) {
        contents.InstanceId = output["instanceId"];
    }
    if (output["progress"] !== undefined) {
        contents.Progress = output["progress"];
    }
    if (output["startTime"] !== undefined) {
        contents.StartTime = new Date(output["startTime"]);
    }
    if (output["state"] !== undefined) {
        contents.State = output["state"];
    }
    if (output["storage"] !== undefined) {
        contents.Storage = deserializeAws_ec2Storage(output["storage"], context);
    }
    if (output["updateTime"] !== undefined) {
        contents.UpdateTime = new Date(output["updateTime"]);
    }
    return contents;
};
const deserializeAws_ec2BundleTaskError = (output, context) => {
    let contents = {
        __type: "BundleTaskError",
        Code: undefined,
        Message: undefined
    };
    if (output["code"] !== undefined) {
        contents.Code = output["code"];
    }
    if (output["message"] !== undefined) {
        contents.Message = output["message"];
    }
    return contents;
};
const deserializeAws_ec2BundleTaskList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2BundleTask(entry, context));
    });
    return contents;
};
const deserializeAws_ec2ByoipCidr = (output, context) => {
    let contents = {
        __type: "ByoipCidr",
        Cidr: undefined,
        Description: undefined,
        State: undefined,
        StatusMessage: undefined
    };
    if (output["cidr"] !== undefined) {
        contents.Cidr = output["cidr"];
    }
    if (output["description"] !== undefined) {
        contents.Description = output["description"];
    }
    if (output["state"] !== undefined) {
        contents.State = output["state"];
    }
    if (output["statusMessage"] !== undefined) {
        contents.StatusMessage = output["statusMessage"];
    }
    return contents;
};
const deserializeAws_ec2ByoipCidrSet = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2ByoipCidr(entry, context));
    });
    return contents;
};
const deserializeAws_ec2CancelBundleTaskResult = (output, context) => {
    let contents = {
        __type: "CancelBundleTaskResult",
        BundleTask: undefined
    };
    if (output["bundleInstanceTask"] !== undefined) {
        contents.BundleTask = deserializeAws_ec2BundleTask(output["bundleInstanceTask"], context);
    }
    return contents;
};
const deserializeAws_ec2CancelCapacityReservationResult = (output, context) => {
    let contents = {
        __type: "CancelCapacityReservationResult",
        Return: undefined
    };
    if (output["return"] !== undefined) {
        contents.Return = output["return"] == "true";
    }
    return contents;
};
const deserializeAws_ec2CancelImportTaskResult = (output, context) => {
    let contents = {
        __type: "CancelImportTaskResult",
        ImportTaskId: undefined,
        PreviousState: undefined,
        State: undefined
    };
    if (output["importTaskId"] !== undefined) {
        contents.ImportTaskId = output["importTaskId"];
    }
    if (output["previousState"] !== undefined) {
        contents.PreviousState = output["previousState"];
    }
    if (output["state"] !== undefined) {
        contents.State = output["state"];
    }
    return contents;
};
const deserializeAws_ec2CancelReservedInstancesListingResult = (output, context) => {
    let contents = {
        __type: "CancelReservedInstancesListingResult",
        ReservedInstancesListings: undefined
    };
    if (output.reservedInstancesListingsSet === "") {
        contents.ReservedInstancesListings = [];
    }
    if (output["reservedInstancesListingsSet"] !== undefined &&
        output["reservedInstancesListingsSet"]["item"] !== undefined) {
        const wrappedItem = output["reservedInstancesListingsSet"]["item"] instanceof Array
            ? output["reservedInstancesListingsSet"]["item"]
            : [output["reservedInstancesListingsSet"]["item"]];
        contents.ReservedInstancesListings = deserializeAws_ec2ReservedInstancesListingList(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2CancelSpotFleetRequestsError = (output, context) => {
    let contents = {
        __type: "CancelSpotFleetRequestsError",
        Code: undefined,
        Message: undefined
    };
    if (output["code"] !== undefined) {
        contents.Code = output["code"];
    }
    if (output["message"] !== undefined) {
        contents.Message = output["message"];
    }
    return contents;
};
const deserializeAws_ec2CancelSpotFleetRequestsErrorItem = (output, context) => {
    let contents = {
        __type: "CancelSpotFleetRequestsErrorItem",
        Error: undefined,
        SpotFleetRequestId: undefined
    };
    if (output["error"] !== undefined) {
        contents.Error = deserializeAws_ec2CancelSpotFleetRequestsError(output["error"], context);
    }
    if (output["spotFleetRequestId"] !== undefined) {
        contents.SpotFleetRequestId = output["spotFleetRequestId"];
    }
    return contents;
};
const deserializeAws_ec2CancelSpotFleetRequestsErrorSet = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2CancelSpotFleetRequestsErrorItem(entry, context));
    });
    return contents;
};
const deserializeAws_ec2CancelSpotFleetRequestsResponse = (output, context) => {
    let contents = {
        __type: "CancelSpotFleetRequestsResponse",
        SuccessfulFleetRequests: undefined,
        UnsuccessfulFleetRequests: undefined
    };
    if (output.successfulFleetRequestSet === "") {
        contents.SuccessfulFleetRequests = [];
    }
    if (output["successfulFleetRequestSet"] !== undefined &&
        output["successfulFleetRequestSet"]["item"] !== undefined) {
        const wrappedItem = output["successfulFleetRequestSet"]["item"] instanceof Array
            ? output["successfulFleetRequestSet"]["item"]
            : [output["successfulFleetRequestSet"]["item"]];
        contents.SuccessfulFleetRequests = deserializeAws_ec2CancelSpotFleetRequestsSuccessSet(wrappedItem, context);
    }
    if (output.unsuccessfulFleetRequestSet === "") {
        contents.UnsuccessfulFleetRequests = [];
    }
    if (output["unsuccessfulFleetRequestSet"] !== undefined &&
        output["unsuccessfulFleetRequestSet"]["item"] !== undefined) {
        const wrappedItem = output["unsuccessfulFleetRequestSet"]["item"] instanceof Array
            ? output["unsuccessfulFleetRequestSet"]["item"]
            : [output["unsuccessfulFleetRequestSet"]["item"]];
        contents.UnsuccessfulFleetRequests = deserializeAws_ec2CancelSpotFleetRequestsErrorSet(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2CancelSpotFleetRequestsSuccessItem = (output, context) => {
    let contents = {
        __type: "CancelSpotFleetRequestsSuccessItem",
        CurrentSpotFleetRequestState: undefined,
        PreviousSpotFleetRequestState: undefined,
        SpotFleetRequestId: undefined
    };
    if (output["currentSpotFleetRequestState"] !== undefined) {
        contents.CurrentSpotFleetRequestState =
            output["currentSpotFleetRequestState"];
    }
    if (output["previousSpotFleetRequestState"] !== undefined) {
        contents.PreviousSpotFleetRequestState =
            output["previousSpotFleetRequestState"];
    }
    if (output["spotFleetRequestId"] !== undefined) {
        contents.SpotFleetRequestId = output["spotFleetRequestId"];
    }
    return contents;
};
const deserializeAws_ec2CancelSpotFleetRequestsSuccessSet = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2CancelSpotFleetRequestsSuccessItem(entry, context));
    });
    return contents;
};
const deserializeAws_ec2CancelSpotInstanceRequestsResult = (output, context) => {
    let contents = {
        __type: "CancelSpotInstanceRequestsResult",
        CancelledSpotInstanceRequests: undefined
    };
    if (output.spotInstanceRequestSet === "") {
        contents.CancelledSpotInstanceRequests = [];
    }
    if (output["spotInstanceRequestSet"] !== undefined &&
        output["spotInstanceRequestSet"]["item"] !== undefined) {
        const wrappedItem = output["spotInstanceRequestSet"]["item"] instanceof Array
            ? output["spotInstanceRequestSet"]["item"]
            : [output["spotInstanceRequestSet"]["item"]];
        contents.CancelledSpotInstanceRequests = deserializeAws_ec2CancelledSpotInstanceRequestList(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2CancelledSpotInstanceRequest = (output, context) => {
    let contents = {
        __type: "CancelledSpotInstanceRequest",
        SpotInstanceRequestId: undefined,
        State: undefined
    };
    if (output["spotInstanceRequestId"] !== undefined) {
        contents.SpotInstanceRequestId = output["spotInstanceRequestId"];
    }
    if (output["state"] !== undefined) {
        contents.State = output["state"];
    }
    return contents;
};
const deserializeAws_ec2CancelledSpotInstanceRequestList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2CancelledSpotInstanceRequest(entry, context));
    });
    return contents;
};
const deserializeAws_ec2CapacityReservation = (output, context) => {
    let contents = {
        __type: "CapacityReservation",
        AvailabilityZone: undefined,
        AvailabilityZoneId: undefined,
        AvailableInstanceCount: undefined,
        CapacityReservationArn: undefined,
        CapacityReservationId: undefined,
        CreateDate: undefined,
        EbsOptimized: undefined,
        EndDate: undefined,
        EndDateType: undefined,
        EphemeralStorage: undefined,
        InstanceMatchCriteria: undefined,
        InstancePlatform: undefined,
        InstanceType: undefined,
        OwnerId: undefined,
        State: undefined,
        Tags: undefined,
        Tenancy: undefined,
        TotalInstanceCount: undefined
    };
    if (output["availabilityZone"] !== undefined) {
        contents.AvailabilityZone = output["availabilityZone"];
    }
    if (output["availabilityZoneId"] !== undefined) {
        contents.AvailabilityZoneId = output["availabilityZoneId"];
    }
    if (output["availableInstanceCount"] !== undefined) {
        contents.AvailableInstanceCount = parseInt(output["availableInstanceCount"]);
    }
    if (output["capacityReservationArn"] !== undefined) {
        contents.CapacityReservationArn = output["capacityReservationArn"];
    }
    if (output["capacityReservationId"] !== undefined) {
        contents.CapacityReservationId = output["capacityReservationId"];
    }
    if (output["createDate"] !== undefined) {
        contents.CreateDate = new Date(output["createDate"]);
    }
    if (output["ebsOptimized"] !== undefined) {
        contents.EbsOptimized = output["ebsOptimized"] == "true";
    }
    if (output["endDate"] !== undefined) {
        contents.EndDate = new Date(output["endDate"]);
    }
    if (output["endDateType"] !== undefined) {
        contents.EndDateType = output["endDateType"];
    }
    if (output["ephemeralStorage"] !== undefined) {
        contents.EphemeralStorage = output["ephemeralStorage"] == "true";
    }
    if (output["instanceMatchCriteria"] !== undefined) {
        contents.InstanceMatchCriteria = output["instanceMatchCriteria"];
    }
    if (output["instancePlatform"] !== undefined) {
        contents.InstancePlatform = output["instancePlatform"];
    }
    if (output["instanceType"] !== undefined) {
        contents.InstanceType = output["instanceType"];
    }
    if (output["ownerId"] !== undefined) {
        contents.OwnerId = output["ownerId"];
    }
    if (output["state"] !== undefined) {
        contents.State = output["state"];
    }
    if (output.tagSet === "") {
        contents.Tags = [];
    }
    if (output["tagSet"] !== undefined &&
        output["tagSet"]["item"] !== undefined) {
        const wrappedItem = output["tagSet"]["item"] instanceof Array
            ? output["tagSet"]["item"]
            : [output["tagSet"]["item"]];
        contents.Tags = deserializeAws_ec2TagList(wrappedItem, context);
    }
    if (output["tenancy"] !== undefined) {
        contents.Tenancy = output["tenancy"];
    }
    if (output["totalInstanceCount"] !== undefined) {
        contents.TotalInstanceCount = parseInt(output["totalInstanceCount"]);
    }
    return contents;
};
const deserializeAws_ec2CapacityReservationOptions = (output, context) => {
    let contents = {
        __type: "CapacityReservationOptions",
        UsageStrategy: undefined
    };
    if (output["usageStrategy"] !== undefined) {
        contents.UsageStrategy = output["usageStrategy"];
    }
    return contents;
};
const deserializeAws_ec2CapacityReservationSet = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2CapacityReservation(entry, context));
    });
    return contents;
};
const deserializeAws_ec2CapacityReservationSpecificationResponse = (output, context) => {
    let contents = {
        __type: "CapacityReservationSpecificationResponse",
        CapacityReservationPreference: undefined,
        CapacityReservationTarget: undefined
    };
    if (output["capacityReservationPreference"] !== undefined) {
        contents.CapacityReservationPreference =
            output["capacityReservationPreference"];
    }
    if (output["capacityReservationTarget"] !== undefined) {
        contents.CapacityReservationTarget = deserializeAws_ec2CapacityReservationTargetResponse(output["capacityReservationTarget"], context);
    }
    return contents;
};
const deserializeAws_ec2CapacityReservationTargetResponse = (output, context) => {
    let contents = {
        __type: "CapacityReservationTargetResponse",
        CapacityReservationId: undefined
    };
    if (output["capacityReservationId"] !== undefined) {
        contents.CapacityReservationId = output["capacityReservationId"];
    }
    return contents;
};
const deserializeAws_ec2CertificateAuthentication = (output, context) => {
    let contents = {
        __type: "CertificateAuthentication",
        ClientRootCertificateChain: undefined
    };
    if (output["clientRootCertificateChain"] !== undefined) {
        contents.ClientRootCertificateChain = output["clientRootCertificateChain"];
    }
    return contents;
};
const deserializeAws_ec2CidrBlock = (output, context) => {
    let contents = {
        __type: "CidrBlock",
        CidrBlock: undefined
    };
    if (output["cidrBlock"] !== undefined) {
        contents.CidrBlock = output["cidrBlock"];
    }
    return contents;
};
const deserializeAws_ec2CidrBlockSet = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2CidrBlock(entry, context));
    });
    return contents;
};
const deserializeAws_ec2ClassicLinkDnsSupport = (output, context) => {
    let contents = {
        __type: "ClassicLinkDnsSupport",
        ClassicLinkDnsSupported: undefined,
        VpcId: undefined
    };
    if (output["classicLinkDnsSupported"] !== undefined) {
        contents.ClassicLinkDnsSupported =
            output["classicLinkDnsSupported"] == "true";
    }
    if (output["vpcId"] !== undefined) {
        contents.VpcId = output["vpcId"];
    }
    return contents;
};
const deserializeAws_ec2ClassicLinkDnsSupportList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2ClassicLinkDnsSupport(entry, context));
    });
    return contents;
};
const deserializeAws_ec2ClassicLinkInstance = (output, context) => {
    let contents = {
        __type: "ClassicLinkInstance",
        Groups: undefined,
        InstanceId: undefined,
        Tags: undefined,
        VpcId: undefined
    };
    if (output.groupSet === "") {
        contents.Groups = [];
    }
    if (output["groupSet"] !== undefined &&
        output["groupSet"]["item"] !== undefined) {
        const wrappedItem = output["groupSet"]["item"] instanceof Array
            ? output["groupSet"]["item"]
            : [output["groupSet"]["item"]];
        contents.Groups = deserializeAws_ec2GroupIdentifierList(wrappedItem, context);
    }
    if (output["instanceId"] !== undefined) {
        contents.InstanceId = output["instanceId"];
    }
    if (output.tagSet === "") {
        contents.Tags = [];
    }
    if (output["tagSet"] !== undefined &&
        output["tagSet"]["item"] !== undefined) {
        const wrappedItem = output["tagSet"]["item"] instanceof Array
            ? output["tagSet"]["item"]
            : [output["tagSet"]["item"]];
        contents.Tags = deserializeAws_ec2TagList(wrappedItem, context);
    }
    if (output["vpcId"] !== undefined) {
        contents.VpcId = output["vpcId"];
    }
    return contents;
};
const deserializeAws_ec2ClassicLinkInstanceList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2ClassicLinkInstance(entry, context));
    });
    return contents;
};
const deserializeAws_ec2ClassicLoadBalancer = (output, context) => {
    let contents = {
        __type: "ClassicLoadBalancer",
        Name: undefined
    };
    if (output["name"] !== undefined) {
        contents.Name = output["name"];
    }
    return contents;
};
const deserializeAws_ec2ClassicLoadBalancers = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2ClassicLoadBalancer(entry, context));
    });
    return contents;
};
const deserializeAws_ec2ClassicLoadBalancersConfig = (output, context) => {
    let contents = {
        __type: "ClassicLoadBalancersConfig",
        ClassicLoadBalancers: undefined
    };
    if (output.classicLoadBalancers === "") {
        contents.ClassicLoadBalancers = [];
    }
    if (output["classicLoadBalancers"] !== undefined &&
        output["classicLoadBalancers"]["item"] !== undefined) {
        const wrappedItem = output["classicLoadBalancers"]["item"] instanceof Array
            ? output["classicLoadBalancers"]["item"]
            : [output["classicLoadBalancers"]["item"]];
        contents.ClassicLoadBalancers = deserializeAws_ec2ClassicLoadBalancers(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2ClientCertificateRevocationListStatus = (output, context) => {
    let contents = {
        __type: "ClientCertificateRevocationListStatus",
        Code: undefined,
        Message: undefined
    };
    if (output["code"] !== undefined) {
        contents.Code = output["code"];
    }
    if (output["message"] !== undefined) {
        contents.Message = output["message"];
    }
    return contents;
};
const deserializeAws_ec2ClientVpnAuthentication = (output, context) => {
    let contents = {
        __type: "ClientVpnAuthentication",
        ActiveDirectory: undefined,
        MutualAuthentication: undefined,
        Type: undefined
    };
    if (output["activeDirectory"] !== undefined) {
        contents.ActiveDirectory = deserializeAws_ec2DirectoryServiceAuthentication(output["activeDirectory"], context);
    }
    if (output["mutualAuthentication"] !== undefined) {
        contents.MutualAuthentication = deserializeAws_ec2CertificateAuthentication(output["mutualAuthentication"], context);
    }
    if (output["type"] !== undefined) {
        contents.Type = output["type"];
    }
    return contents;
};
const deserializeAws_ec2ClientVpnAuthenticationList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2ClientVpnAuthentication(entry, context));
    });
    return contents;
};
const deserializeAws_ec2ClientVpnAuthorizationRuleStatus = (output, context) => {
    let contents = {
        __type: "ClientVpnAuthorizationRuleStatus",
        Code: undefined,
        Message: undefined
    };
    if (output["code"] !== undefined) {
        contents.Code = output["code"];
    }
    if (output["message"] !== undefined) {
        contents.Message = output["message"];
    }
    return contents;
};
const deserializeAws_ec2ClientVpnConnection = (output, context) => {
    let contents = {
        __type: "ClientVpnConnection",
        ClientIp: undefined,
        ClientVpnEndpointId: undefined,
        CommonName: undefined,
        ConnectionEndTime: undefined,
        ConnectionEstablishedTime: undefined,
        ConnectionId: undefined,
        EgressBytes: undefined,
        EgressPackets: undefined,
        IngressBytes: undefined,
        IngressPackets: undefined,
        Status: undefined,
        Timestamp: undefined,
        Username: undefined
    };
    if (output["clientIp"] !== undefined) {
        contents.ClientIp = output["clientIp"];
    }
    if (output["clientVpnEndpointId"] !== undefined) {
        contents.ClientVpnEndpointId = output["clientVpnEndpointId"];
    }
    if (output["commonName"] !== undefined) {
        contents.CommonName = output["commonName"];
    }
    if (output["connectionEndTime"] !== undefined) {
        contents.ConnectionEndTime = output["connectionEndTime"];
    }
    if (output["connectionEstablishedTime"] !== undefined) {
        contents.ConnectionEstablishedTime = output["connectionEstablishedTime"];
    }
    if (output["connectionId"] !== undefined) {
        contents.ConnectionId = output["connectionId"];
    }
    if (output["egressBytes"] !== undefined) {
        contents.EgressBytes = output["egressBytes"];
    }
    if (output["egressPackets"] !== undefined) {
        contents.EgressPackets = output["egressPackets"];
    }
    if (output["ingressBytes"] !== undefined) {
        contents.IngressBytes = output["ingressBytes"];
    }
    if (output["ingressPackets"] !== undefined) {
        contents.IngressPackets = output["ingressPackets"];
    }
    if (output["status"] !== undefined) {
        contents.Status = deserializeAws_ec2ClientVpnConnectionStatus(output["status"], context);
    }
    if (output["timestamp"] !== undefined) {
        contents.Timestamp = output["timestamp"];
    }
    if (output["username"] !== undefined) {
        contents.Username = output["username"];
    }
    return contents;
};
const deserializeAws_ec2ClientVpnConnectionSet = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2ClientVpnConnection(entry, context));
    });
    return contents;
};
const deserializeAws_ec2ClientVpnConnectionStatus = (output, context) => {
    let contents = {
        __type: "ClientVpnConnectionStatus",
        Code: undefined,
        Message: undefined
    };
    if (output["code"] !== undefined) {
        contents.Code = output["code"];
    }
    if (output["message"] !== undefined) {
        contents.Message = output["message"];
    }
    return contents;
};
const deserializeAws_ec2ClientVpnEndpoint = (output, context) => {
    let contents = {
        __type: "ClientVpnEndpoint",
        AssociatedTargetNetworks: undefined,
        AuthenticationOptions: undefined,
        ClientCidrBlock: undefined,
        ClientVpnEndpointId: undefined,
        ConnectionLogOptions: undefined,
        CreationTime: undefined,
        DeletionTime: undefined,
        Description: undefined,
        DnsName: undefined,
        DnsServers: undefined,
        ServerCertificateArn: undefined,
        SplitTunnel: undefined,
        Status: undefined,
        Tags: undefined,
        TransportProtocol: undefined,
        VpnPort: undefined,
        VpnProtocol: undefined
    };
    if (output.associatedTargetNetwork === "") {
        contents.AssociatedTargetNetworks = [];
    }
    if (output["associatedTargetNetwork"] !== undefined &&
        output["associatedTargetNetwork"]["item"] !== undefined) {
        const wrappedItem = output["associatedTargetNetwork"]["item"] instanceof Array
            ? output["associatedTargetNetwork"]["item"]
            : [output["associatedTargetNetwork"]["item"]];
        contents.AssociatedTargetNetworks = deserializeAws_ec2AssociatedTargetNetworkSet(wrappedItem, context);
    }
    if (output.authenticationOptions === "") {
        contents.AuthenticationOptions = [];
    }
    if (output["authenticationOptions"] !== undefined &&
        output["authenticationOptions"]["item"] !== undefined) {
        const wrappedItem = output["authenticationOptions"]["item"] instanceof Array
            ? output["authenticationOptions"]["item"]
            : [output["authenticationOptions"]["item"]];
        contents.AuthenticationOptions = deserializeAws_ec2ClientVpnAuthenticationList(wrappedItem, context);
    }
    if (output["clientCidrBlock"] !== undefined) {
        contents.ClientCidrBlock = output["clientCidrBlock"];
    }
    if (output["clientVpnEndpointId"] !== undefined) {
        contents.ClientVpnEndpointId = output["clientVpnEndpointId"];
    }
    if (output["connectionLogOptions"] !== undefined) {
        contents.ConnectionLogOptions = deserializeAws_ec2ConnectionLogResponseOptions(output["connectionLogOptions"], context);
    }
    if (output["creationTime"] !== undefined) {
        contents.CreationTime = output["creationTime"];
    }
    if (output["deletionTime"] !== undefined) {
        contents.DeletionTime = output["deletionTime"];
    }
    if (output["description"] !== undefined) {
        contents.Description = output["description"];
    }
    if (output["dnsName"] !== undefined) {
        contents.DnsName = output["dnsName"];
    }
    if (output.dnsServer === "") {
        contents.DnsServers = [];
    }
    if (output["dnsServer"] !== undefined &&
        output["dnsServer"]["item"] !== undefined) {
        const wrappedItem = output["dnsServer"]["item"] instanceof Array
            ? output["dnsServer"]["item"]
            : [output["dnsServer"]["item"]];
        contents.DnsServers = deserializeAws_ec2ValueStringList(wrappedItem, context);
    }
    if (output["serverCertificateArn"] !== undefined) {
        contents.ServerCertificateArn = output["serverCertificateArn"];
    }
    if (output["splitTunnel"] !== undefined) {
        contents.SplitTunnel = output["splitTunnel"] == "true";
    }
    if (output["status"] !== undefined) {
        contents.Status = deserializeAws_ec2ClientVpnEndpointStatus(output["status"], context);
    }
    if (output.tagSet === "") {
        contents.Tags = [];
    }
    if (output["tagSet"] !== undefined &&
        output["tagSet"]["item"] !== undefined) {
        const wrappedItem = output["tagSet"]["item"] instanceof Array
            ? output["tagSet"]["item"]
            : [output["tagSet"]["item"]];
        contents.Tags = deserializeAws_ec2TagList(wrappedItem, context);
    }
    if (output["transportProtocol"] !== undefined) {
        contents.TransportProtocol = output["transportProtocol"];
    }
    if (output["vpnPort"] !== undefined) {
        contents.VpnPort = parseInt(output["vpnPort"]);
    }
    if (output["vpnProtocol"] !== undefined) {
        contents.VpnProtocol = output["vpnProtocol"];
    }
    return contents;
};
const deserializeAws_ec2ClientVpnEndpointStatus = (output, context) => {
    let contents = {
        __type: "ClientVpnEndpointStatus",
        Code: undefined,
        Message: undefined
    };
    if (output["code"] !== undefined) {
        contents.Code = output["code"];
    }
    if (output["message"] !== undefined) {
        contents.Message = output["message"];
    }
    return contents;
};
const deserializeAws_ec2ClientVpnRoute = (output, context) => {
    let contents = {
        __type: "ClientVpnRoute",
        ClientVpnEndpointId: undefined,
        Description: undefined,
        DestinationCidr: undefined,
        Origin: undefined,
        Status: undefined,
        TargetSubnet: undefined,
        Type: undefined
    };
    if (output["clientVpnEndpointId"] !== undefined) {
        contents.ClientVpnEndpointId = output["clientVpnEndpointId"];
    }
    if (output["description"] !== undefined) {
        contents.Description = output["description"];
    }
    if (output["destinationCidr"] !== undefined) {
        contents.DestinationCidr = output["destinationCidr"];
    }
    if (output["origin"] !== undefined) {
        contents.Origin = output["origin"];
    }
    if (output["status"] !== undefined) {
        contents.Status = deserializeAws_ec2ClientVpnRouteStatus(output["status"], context);
    }
    if (output["targetSubnet"] !== undefined) {
        contents.TargetSubnet = output["targetSubnet"];
    }
    if (output["type"] !== undefined) {
        contents.Type = output["type"];
    }
    return contents;
};
const deserializeAws_ec2ClientVpnRouteSet = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2ClientVpnRoute(entry, context));
    });
    return contents;
};
const deserializeAws_ec2ClientVpnRouteStatus = (output, context) => {
    let contents = {
        __type: "ClientVpnRouteStatus",
        Code: undefined,
        Message: undefined
    };
    if (output["code"] !== undefined) {
        contents.Code = output["code"];
    }
    if (output["message"] !== undefined) {
        contents.Message = output["message"];
    }
    return contents;
};
const deserializeAws_ec2ClientVpnSecurityGroupIdSet = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(entry);
    });
    return contents;
};
const deserializeAws_ec2CoipAddressUsage = (output, context) => {
    let contents = {
        __type: "CoipAddressUsage",
        AllocationId: undefined,
        AwsAccountId: undefined,
        AwsService: undefined,
        CoIp: undefined
    };
    if (output["allocationId"] !== undefined) {
        contents.AllocationId = output["allocationId"];
    }
    if (output["awsAccountId"] !== undefined) {
        contents.AwsAccountId = output["awsAccountId"];
    }
    if (output["awsService"] !== undefined) {
        contents.AwsService = output["awsService"];
    }
    if (output["coIp"] !== undefined) {
        contents.CoIp = output["coIp"];
    }
    return contents;
};
const deserializeAws_ec2CoipAddressUsageSet = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2CoipAddressUsage(entry, context));
    });
    return contents;
};
const deserializeAws_ec2CoipPool = (output, context) => {
    let contents = {
        __type: "CoipPool",
        LocalGatewayRouteTableId: undefined,
        PoolCidrs: undefined,
        PoolId: undefined,
        Tags: undefined
    };
    if (output["localGatewayRouteTableId"] !== undefined) {
        contents.LocalGatewayRouteTableId = output["localGatewayRouteTableId"];
    }
    if (output.poolCidrSet === "") {
        contents.PoolCidrs = [];
    }
    if (output["poolCidrSet"] !== undefined &&
        output["poolCidrSet"]["item"] !== undefined) {
        const wrappedItem = output["poolCidrSet"]["item"] instanceof Array
            ? output["poolCidrSet"]["item"]
            : [output["poolCidrSet"]["item"]];
        contents.PoolCidrs = deserializeAws_ec2ValueStringList(wrappedItem, context);
    }
    if (output["poolId"] !== undefined) {
        contents.PoolId = output["poolId"];
    }
    if (output.tagSet === "") {
        contents.Tags = [];
    }
    if (output["tagSet"] !== undefined &&
        output["tagSet"]["item"] !== undefined) {
        const wrappedItem = output["tagSet"]["item"] instanceof Array
            ? output["tagSet"]["item"]
            : [output["tagSet"]["item"]];
        contents.Tags = deserializeAws_ec2TagList(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2CoipPoolSet = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2CoipPool(entry, context));
    });
    return contents;
};
const deserializeAws_ec2ConfirmProductInstanceResult = (output, context) => {
    let contents = {
        __type: "ConfirmProductInstanceResult",
        OwnerId: undefined,
        Return: undefined
    };
    if (output["ownerId"] !== undefined) {
        contents.OwnerId = output["ownerId"];
    }
    if (output["return"] !== undefined) {
        contents.Return = output["return"] == "true";
    }
    return contents;
};
const deserializeAws_ec2ConnectionLogResponseOptions = (output, context) => {
    let contents = {
        __type: "ConnectionLogResponseOptions",
        CloudwatchLogGroup: undefined,
        CloudwatchLogStream: undefined,
        Enabled: undefined
    };
    if (output["CloudwatchLogGroup"] !== undefined) {
        contents.CloudwatchLogGroup = output["CloudwatchLogGroup"];
    }
    if (output["CloudwatchLogStream"] !== undefined) {
        contents.CloudwatchLogStream = output["CloudwatchLogStream"];
    }
    if (output["Enabled"] !== undefined) {
        contents.Enabled = output["Enabled"] == "true";
    }
    return contents;
};
const deserializeAws_ec2ConnectionNotification = (output, context) => {
    let contents = {
        __type: "ConnectionNotification",
        ConnectionEvents: undefined,
        ConnectionNotificationArn: undefined,
        ConnectionNotificationId: undefined,
        ConnectionNotificationState: undefined,
        ConnectionNotificationType: undefined,
        ServiceId: undefined,
        VpcEndpointId: undefined
    };
    if (output.connectionEvents === "") {
        contents.ConnectionEvents = [];
    }
    if (output["connectionEvents"] !== undefined &&
        output["connectionEvents"]["item"] !== undefined) {
        const wrappedItem = output["connectionEvents"]["item"] instanceof Array
            ? output["connectionEvents"]["item"]
            : [output["connectionEvents"]["item"]];
        contents.ConnectionEvents = deserializeAws_ec2ValueStringList(wrappedItem, context);
    }
    if (output["connectionNotificationArn"] !== undefined) {
        contents.ConnectionNotificationArn = output["connectionNotificationArn"];
    }
    if (output["connectionNotificationId"] !== undefined) {
        contents.ConnectionNotificationId = output["connectionNotificationId"];
    }
    if (output["connectionNotificationState"] !== undefined) {
        contents.ConnectionNotificationState =
            output["connectionNotificationState"];
    }
    if (output["connectionNotificationType"] !== undefined) {
        contents.ConnectionNotificationType = output["connectionNotificationType"];
    }
    if (output["serviceId"] !== undefined) {
        contents.ServiceId = output["serviceId"];
    }
    if (output["vpcEndpointId"] !== undefined) {
        contents.VpcEndpointId = output["vpcEndpointId"];
    }
    return contents;
};
const deserializeAws_ec2ConnectionNotificationSet = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2ConnectionNotification(entry, context));
    });
    return contents;
};
const deserializeAws_ec2ConversionTask = (output, context) => {
    let contents = {
        __type: "ConversionTask",
        ConversionTaskId: undefined,
        ExpirationTime: undefined,
        ImportInstance: undefined,
        ImportVolume: undefined,
        State: undefined,
        StatusMessage: undefined,
        Tags: undefined
    };
    if (output["conversionTaskId"] !== undefined) {
        contents.ConversionTaskId = output["conversionTaskId"];
    }
    if (output["expirationTime"] !== undefined) {
        contents.ExpirationTime = output["expirationTime"];
    }
    if (output["importInstance"] !== undefined) {
        contents.ImportInstance = deserializeAws_ec2ImportInstanceTaskDetails(output["importInstance"], context);
    }
    if (output["importVolume"] !== undefined) {
        contents.ImportVolume = deserializeAws_ec2ImportVolumeTaskDetails(output["importVolume"], context);
    }
    if (output["state"] !== undefined) {
        contents.State = output["state"];
    }
    if (output["statusMessage"] !== undefined) {
        contents.StatusMessage = output["statusMessage"];
    }
    if (output.tagSet === "") {
        contents.Tags = [];
    }
    if (output["tagSet"] !== undefined &&
        output["tagSet"]["item"] !== undefined) {
        const wrappedItem = output["tagSet"]["item"] instanceof Array
            ? output["tagSet"]["item"]
            : [output["tagSet"]["item"]];
        contents.Tags = deserializeAws_ec2TagList(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2CopyFpgaImageResult = (output, context) => {
    let contents = {
        __type: "CopyFpgaImageResult",
        FpgaImageId: undefined
    };
    if (output["fpgaImageId"] !== undefined) {
        contents.FpgaImageId = output["fpgaImageId"];
    }
    return contents;
};
const deserializeAws_ec2CopyImageResult = (output, context) => {
    let contents = {
        __type: "CopyImageResult",
        ImageId: undefined
    };
    if (output["imageId"] !== undefined) {
        contents.ImageId = output["imageId"];
    }
    return contents;
};
const deserializeAws_ec2CopySnapshotResult = (output, context) => {
    let contents = {
        __type: "CopySnapshotResult",
        SnapshotId: undefined,
        Tags: undefined
    };
    if (output["snapshotId"] !== undefined) {
        contents.SnapshotId = output["snapshotId"];
    }
    if (output.tagSet === "") {
        contents.Tags = [];
    }
    if (output["tagSet"] !== undefined &&
        output["tagSet"]["item"] !== undefined) {
        const wrappedItem = output["tagSet"]["item"] instanceof Array
            ? output["tagSet"]["item"]
            : [output["tagSet"]["item"]];
        contents.Tags = deserializeAws_ec2TagList(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2CoreCountList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(parseInt(entry));
    });
    return contents;
};
const deserializeAws_ec2CpuOptions = (output, context) => {
    let contents = {
        __type: "CpuOptions",
        CoreCount: undefined,
        ThreadsPerCore: undefined
    };
    if (output["coreCount"] !== undefined) {
        contents.CoreCount = parseInt(output["coreCount"]);
    }
    if (output["threadsPerCore"] !== undefined) {
        contents.ThreadsPerCore = parseInt(output["threadsPerCore"]);
    }
    return contents;
};
const deserializeAws_ec2CreateCapacityReservationResult = (output, context) => {
    let contents = {
        __type: "CreateCapacityReservationResult",
        CapacityReservation: undefined
    };
    if (output["capacityReservation"] !== undefined) {
        contents.CapacityReservation = deserializeAws_ec2CapacityReservation(output["capacityReservation"], context);
    }
    return contents;
};
const deserializeAws_ec2CreateClientVpnEndpointResult = (output, context) => {
    let contents = {
        __type: "CreateClientVpnEndpointResult",
        ClientVpnEndpointId: undefined,
        DnsName: undefined,
        Status: undefined
    };
    if (output["clientVpnEndpointId"] !== undefined) {
        contents.ClientVpnEndpointId = output["clientVpnEndpointId"];
    }
    if (output["dnsName"] !== undefined) {
        contents.DnsName = output["dnsName"];
    }
    if (output["status"] !== undefined) {
        contents.Status = deserializeAws_ec2ClientVpnEndpointStatus(output["status"], context);
    }
    return contents;
};
const deserializeAws_ec2CreateClientVpnRouteResult = (output, context) => {
    let contents = {
        __type: "CreateClientVpnRouteResult",
        Status: undefined
    };
    if (output["status"] !== undefined) {
        contents.Status = deserializeAws_ec2ClientVpnRouteStatus(output["status"], context);
    }
    return contents;
};
const deserializeAws_ec2CreateCustomerGatewayResult = (output, context) => {
    let contents = {
        __type: "CreateCustomerGatewayResult",
        CustomerGateway: undefined
    };
    if (output["customerGateway"] !== undefined) {
        contents.CustomerGateway = deserializeAws_ec2CustomerGateway(output["customerGateway"], context);
    }
    return contents;
};
const deserializeAws_ec2CreateDefaultSubnetResult = (output, context) => {
    let contents = {
        __type: "CreateDefaultSubnetResult",
        Subnet: undefined
    };
    if (output["subnet"] !== undefined) {
        contents.Subnet = deserializeAws_ec2Subnet(output["subnet"], context);
    }
    return contents;
};
const deserializeAws_ec2CreateDefaultVpcResult = (output, context) => {
    let contents = {
        __type: "CreateDefaultVpcResult",
        Vpc: undefined
    };
    if (output["vpc"] !== undefined) {
        contents.Vpc = deserializeAws_ec2Vpc(output["vpc"], context);
    }
    return contents;
};
const deserializeAws_ec2CreateDhcpOptionsResult = (output, context) => {
    let contents = {
        __type: "CreateDhcpOptionsResult",
        DhcpOptions: undefined
    };
    if (output["dhcpOptions"] !== undefined) {
        contents.DhcpOptions = deserializeAws_ec2DhcpOptions(output["dhcpOptions"], context);
    }
    return contents;
};
const deserializeAws_ec2CreateEgressOnlyInternetGatewayResult = (output, context) => {
    let contents = {
        __type: "CreateEgressOnlyInternetGatewayResult",
        ClientToken: undefined,
        EgressOnlyInternetGateway: undefined
    };
    if (output["clientToken"] !== undefined) {
        contents.ClientToken = output["clientToken"];
    }
    if (output["egressOnlyInternetGateway"] !== undefined) {
        contents.EgressOnlyInternetGateway = deserializeAws_ec2EgressOnlyInternetGateway(output["egressOnlyInternetGateway"], context);
    }
    return contents;
};
const deserializeAws_ec2CreateFleetError = (output, context) => {
    let contents = {
        __type: "CreateFleetError",
        ErrorCode: undefined,
        ErrorMessage: undefined,
        LaunchTemplateAndOverrides: undefined,
        Lifecycle: undefined
    };
    if (output["errorCode"] !== undefined) {
        contents.ErrorCode = output["errorCode"];
    }
    if (output["errorMessage"] !== undefined) {
        contents.ErrorMessage = output["errorMessage"];
    }
    if (output["launchTemplateAndOverrides"] !== undefined) {
        contents.LaunchTemplateAndOverrides = deserializeAws_ec2LaunchTemplateAndOverridesResponse(output["launchTemplateAndOverrides"], context);
    }
    if (output["lifecycle"] !== undefined) {
        contents.Lifecycle = output["lifecycle"];
    }
    return contents;
};
const deserializeAws_ec2CreateFleetErrorsSet = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2CreateFleetError(entry, context));
    });
    return contents;
};
const deserializeAws_ec2CreateFleetInstance = (output, context) => {
    let contents = {
        __type: "CreateFleetInstance",
        InstanceIds: undefined,
        InstanceType: undefined,
        LaunchTemplateAndOverrides: undefined,
        Lifecycle: undefined,
        Platform: undefined
    };
    if (output.instanceIds === "") {
        contents.InstanceIds = [];
    }
    if (output["instanceIds"] !== undefined &&
        output["instanceIds"]["item"] !== undefined) {
        const wrappedItem = output["instanceIds"]["item"] instanceof Array
            ? output["instanceIds"]["item"]
            : [output["instanceIds"]["item"]];
        contents.InstanceIds = deserializeAws_ec2InstanceIdsSet(wrappedItem, context);
    }
    if (output["instanceType"] !== undefined) {
        contents.InstanceType = output["instanceType"];
    }
    if (output["launchTemplateAndOverrides"] !== undefined) {
        contents.LaunchTemplateAndOverrides = deserializeAws_ec2LaunchTemplateAndOverridesResponse(output["launchTemplateAndOverrides"], context);
    }
    if (output["lifecycle"] !== undefined) {
        contents.Lifecycle = output["lifecycle"];
    }
    if (output["platform"] !== undefined) {
        contents.Platform = output["platform"];
    }
    return contents;
};
const deserializeAws_ec2CreateFleetInstancesSet = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2CreateFleetInstance(entry, context));
    });
    return contents;
};
const deserializeAws_ec2CreateFleetResult = (output, context) => {
    let contents = {
        __type: "CreateFleetResult",
        Errors: undefined,
        FleetId: undefined,
        Instances: undefined
    };
    if (output.errorSet === "") {
        contents.Errors = [];
    }
    if (output["errorSet"] !== undefined &&
        output["errorSet"]["item"] !== undefined) {
        const wrappedItem = output["errorSet"]["item"] instanceof Array
            ? output["errorSet"]["item"]
            : [output["errorSet"]["item"]];
        contents.Errors = deserializeAws_ec2CreateFleetErrorsSet(wrappedItem, context);
    }
    if (output["fleetId"] !== undefined) {
        contents.FleetId = output["fleetId"];
    }
    if (output.fleetInstanceSet === "") {
        contents.Instances = [];
    }
    if (output["fleetInstanceSet"] !== undefined &&
        output["fleetInstanceSet"]["item"] !== undefined) {
        const wrappedItem = output["fleetInstanceSet"]["item"] instanceof Array
            ? output["fleetInstanceSet"]["item"]
            : [output["fleetInstanceSet"]["item"]];
        contents.Instances = deserializeAws_ec2CreateFleetInstancesSet(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2CreateFlowLogsResult = (output, context) => {
    let contents = {
        __type: "CreateFlowLogsResult",
        ClientToken: undefined,
        FlowLogIds: undefined,
        Unsuccessful: undefined
    };
    if (output["clientToken"] !== undefined) {
        contents.ClientToken = output["clientToken"];
    }
    if (output.flowLogIdSet === "") {
        contents.FlowLogIds = [];
    }
    if (output["flowLogIdSet"] !== undefined &&
        output["flowLogIdSet"]["item"] !== undefined) {
        const wrappedItem = output["flowLogIdSet"]["item"] instanceof Array
            ? output["flowLogIdSet"]["item"]
            : [output["flowLogIdSet"]["item"]];
        contents.FlowLogIds = deserializeAws_ec2ValueStringList(wrappedItem, context);
    }
    if (output.unsuccessful === "") {
        contents.Unsuccessful = [];
    }
    if (output["unsuccessful"] !== undefined &&
        output["unsuccessful"]["item"] !== undefined) {
        const wrappedItem = output["unsuccessful"]["item"] instanceof Array
            ? output["unsuccessful"]["item"]
            : [output["unsuccessful"]["item"]];
        contents.Unsuccessful = deserializeAws_ec2UnsuccessfulItemSet(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2CreateFpgaImageResult = (output, context) => {
    let contents = {
        __type: "CreateFpgaImageResult",
        FpgaImageGlobalId: undefined,
        FpgaImageId: undefined
    };
    if (output["fpgaImageGlobalId"] !== undefined) {
        contents.FpgaImageGlobalId = output["fpgaImageGlobalId"];
    }
    if (output["fpgaImageId"] !== undefined) {
        contents.FpgaImageId = output["fpgaImageId"];
    }
    return contents;
};
const deserializeAws_ec2CreateImageResult = (output, context) => {
    let contents = {
        __type: "CreateImageResult",
        ImageId: undefined
    };
    if (output["imageId"] !== undefined) {
        contents.ImageId = output["imageId"];
    }
    return contents;
};
const deserializeAws_ec2CreateInstanceExportTaskResult = (output, context) => {
    let contents = {
        __type: "CreateInstanceExportTaskResult",
        ExportTask: undefined
    };
    if (output["exportTask"] !== undefined) {
        contents.ExportTask = deserializeAws_ec2ExportTask(output["exportTask"], context);
    }
    return contents;
};
const deserializeAws_ec2CreateInternetGatewayResult = (output, context) => {
    let contents = {
        __type: "CreateInternetGatewayResult",
        InternetGateway: undefined
    };
    if (output["internetGateway"] !== undefined) {
        contents.InternetGateway = deserializeAws_ec2InternetGateway(output["internetGateway"], context);
    }
    return contents;
};
const deserializeAws_ec2CreateLaunchTemplateResult = (output, context) => {
    let contents = {
        __type: "CreateLaunchTemplateResult",
        LaunchTemplate: undefined
    };
    if (output["launchTemplate"] !== undefined) {
        contents.LaunchTemplate = deserializeAws_ec2LaunchTemplate(output["launchTemplate"], context);
    }
    return contents;
};
const deserializeAws_ec2CreateLaunchTemplateVersionResult = (output, context) => {
    let contents = {
        __type: "CreateLaunchTemplateVersionResult",
        LaunchTemplateVersion: undefined
    };
    if (output["launchTemplateVersion"] !== undefined) {
        contents.LaunchTemplateVersion = deserializeAws_ec2LaunchTemplateVersion(output["launchTemplateVersion"], context);
    }
    return contents;
};
const deserializeAws_ec2CreateLocalGatewayRouteResult = (output, context) => {
    let contents = {
        __type: "CreateLocalGatewayRouteResult",
        Route: undefined
    };
    if (output["route"] !== undefined) {
        contents.Route = deserializeAws_ec2LocalGatewayRoute(output["route"], context);
    }
    return contents;
};
const deserializeAws_ec2CreateLocalGatewayRouteTableVpcAssociationResult = (output, context) => {
    let contents = {
        __type: "CreateLocalGatewayRouteTableVpcAssociationResult",
        LocalGatewayRouteTableVpcAssociation: undefined
    };
    if (output["localGatewayRouteTableVpcAssociation"] !== undefined) {
        contents.LocalGatewayRouteTableVpcAssociation = deserializeAws_ec2LocalGatewayRouteTableVpcAssociation(output["localGatewayRouteTableVpcAssociation"], context);
    }
    return contents;
};
const deserializeAws_ec2CreateNatGatewayResult = (output, context) => {
    let contents = {
        __type: "CreateNatGatewayResult",
        ClientToken: undefined,
        NatGateway: undefined
    };
    if (output["clientToken"] !== undefined) {
        contents.ClientToken = output["clientToken"];
    }
    if (output["natGateway"] !== undefined) {
        contents.NatGateway = deserializeAws_ec2NatGateway(output["natGateway"], context);
    }
    return contents;
};
const deserializeAws_ec2CreateNetworkAclResult = (output, context) => {
    let contents = {
        __type: "CreateNetworkAclResult",
        NetworkAcl: undefined
    };
    if (output["networkAcl"] !== undefined) {
        contents.NetworkAcl = deserializeAws_ec2NetworkAcl(output["networkAcl"], context);
    }
    return contents;
};
const deserializeAws_ec2CreateNetworkInterfacePermissionResult = (output, context) => {
    let contents = {
        __type: "CreateNetworkInterfacePermissionResult",
        InterfacePermission: undefined
    };
    if (output["interfacePermission"] !== undefined) {
        contents.InterfacePermission = deserializeAws_ec2NetworkInterfacePermission(output["interfacePermission"], context);
    }
    return contents;
};
const deserializeAws_ec2CreateNetworkInterfaceResult = (output, context) => {
    let contents = {
        __type: "CreateNetworkInterfaceResult",
        NetworkInterface: undefined
    };
    if (output["networkInterface"] !== undefined) {
        contents.NetworkInterface = deserializeAws_ec2NetworkInterface(output["networkInterface"], context);
    }
    return contents;
};
const deserializeAws_ec2CreateReservedInstancesListingResult = (output, context) => {
    let contents = {
        __type: "CreateReservedInstancesListingResult",
        ReservedInstancesListings: undefined
    };
    if (output.reservedInstancesListingsSet === "") {
        contents.ReservedInstancesListings = [];
    }
    if (output["reservedInstancesListingsSet"] !== undefined &&
        output["reservedInstancesListingsSet"]["item"] !== undefined) {
        const wrappedItem = output["reservedInstancesListingsSet"]["item"] instanceof Array
            ? output["reservedInstancesListingsSet"]["item"]
            : [output["reservedInstancesListingsSet"]["item"]];
        contents.ReservedInstancesListings = deserializeAws_ec2ReservedInstancesListingList(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2CreateRouteResult = (output, context) => {
    let contents = {
        __type: "CreateRouteResult",
        Return: undefined
    };
    if (output["return"] !== undefined) {
        contents.Return = output["return"] == "true";
    }
    return contents;
};
const deserializeAws_ec2CreateRouteTableResult = (output, context) => {
    let contents = {
        __type: "CreateRouteTableResult",
        RouteTable: undefined
    };
    if (output["routeTable"] !== undefined) {
        contents.RouteTable = deserializeAws_ec2RouteTable(output["routeTable"], context);
    }
    return contents;
};
const deserializeAws_ec2CreateSecurityGroupResult = (output, context) => {
    let contents = {
        __type: "CreateSecurityGroupResult",
        GroupId: undefined
    };
    if (output["groupId"] !== undefined) {
        contents.GroupId = output["groupId"];
    }
    return contents;
};
const deserializeAws_ec2CreateSnapshotsResult = (output, context) => {
    let contents = {
        __type: "CreateSnapshotsResult",
        Snapshots: undefined
    };
    if (output.snapshotSet === "") {
        contents.Snapshots = [];
    }
    if (output["snapshotSet"] !== undefined &&
        output["snapshotSet"]["item"] !== undefined) {
        const wrappedItem = output["snapshotSet"]["item"] instanceof Array
            ? output["snapshotSet"]["item"]
            : [output["snapshotSet"]["item"]];
        contents.Snapshots = deserializeAws_ec2SnapshotSet(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2CreateSpotDatafeedSubscriptionResult = (output, context) => {
    let contents = {
        __type: "CreateSpotDatafeedSubscriptionResult",
        SpotDatafeedSubscription: undefined
    };
    if (output["spotDatafeedSubscription"] !== undefined) {
        contents.SpotDatafeedSubscription = deserializeAws_ec2SpotDatafeedSubscription(output["spotDatafeedSubscription"], context);
    }
    return contents;
};
const deserializeAws_ec2CreateSubnetResult = (output, context) => {
    let contents = {
        __type: "CreateSubnetResult",
        Subnet: undefined
    };
    if (output["subnet"] !== undefined) {
        contents.Subnet = deserializeAws_ec2Subnet(output["subnet"], context);
    }
    return contents;
};
const deserializeAws_ec2CreateTrafficMirrorFilterResult = (output, context) => {
    let contents = {
        __type: "CreateTrafficMirrorFilterResult",
        ClientToken: undefined,
        TrafficMirrorFilter: undefined
    };
    if (output["clientToken"] !== undefined) {
        contents.ClientToken = output["clientToken"];
    }
    if (output["trafficMirrorFilter"] !== undefined) {
        contents.TrafficMirrorFilter = deserializeAws_ec2TrafficMirrorFilter(output["trafficMirrorFilter"], context);
    }
    return contents;
};
const deserializeAws_ec2CreateTrafficMirrorFilterRuleResult = (output, context) => {
    let contents = {
        __type: "CreateTrafficMirrorFilterRuleResult",
        ClientToken: undefined,
        TrafficMirrorFilterRule: undefined
    };
    if (output["clientToken"] !== undefined) {
        contents.ClientToken = output["clientToken"];
    }
    if (output["trafficMirrorFilterRule"] !== undefined) {
        contents.TrafficMirrorFilterRule = deserializeAws_ec2TrafficMirrorFilterRule(output["trafficMirrorFilterRule"], context);
    }
    return contents;
};
const deserializeAws_ec2CreateTrafficMirrorSessionResult = (output, context) => {
    let contents = {
        __type: "CreateTrafficMirrorSessionResult",
        ClientToken: undefined,
        TrafficMirrorSession: undefined
    };
    if (output["clientToken"] !== undefined) {
        contents.ClientToken = output["clientToken"];
    }
    if (output["trafficMirrorSession"] !== undefined) {
        contents.TrafficMirrorSession = deserializeAws_ec2TrafficMirrorSession(output["trafficMirrorSession"], context);
    }
    return contents;
};
const deserializeAws_ec2CreateTrafficMirrorTargetResult = (output, context) => {
    let contents = {
        __type: "CreateTrafficMirrorTargetResult",
        ClientToken: undefined,
        TrafficMirrorTarget: undefined
    };
    if (output["clientToken"] !== undefined) {
        contents.ClientToken = output["clientToken"];
    }
    if (output["trafficMirrorTarget"] !== undefined) {
        contents.TrafficMirrorTarget = deserializeAws_ec2TrafficMirrorTarget(output["trafficMirrorTarget"], context);
    }
    return contents;
};
const deserializeAws_ec2CreateTransitGatewayMulticastDomainResult = (output, context) => {
    let contents = {
        __type: "CreateTransitGatewayMulticastDomainResult",
        TransitGatewayMulticastDomain: undefined
    };
    if (output["transitGatewayMulticastDomain"] !== undefined) {
        contents.TransitGatewayMulticastDomain = deserializeAws_ec2TransitGatewayMulticastDomain(output["transitGatewayMulticastDomain"], context);
    }
    return contents;
};
const deserializeAws_ec2CreateTransitGatewayPeeringAttachmentResult = (output, context) => {
    let contents = {
        __type: "CreateTransitGatewayPeeringAttachmentResult",
        TransitGatewayPeeringAttachment: undefined
    };
    if (output["transitGatewayPeeringAttachment"] !== undefined) {
        contents.TransitGatewayPeeringAttachment = deserializeAws_ec2TransitGatewayPeeringAttachment(output["transitGatewayPeeringAttachment"], context);
    }
    return contents;
};
const deserializeAws_ec2CreateTransitGatewayResult = (output, context) => {
    let contents = {
        __type: "CreateTransitGatewayResult",
        TransitGateway: undefined
    };
    if (output["transitGateway"] !== undefined) {
        contents.TransitGateway = deserializeAws_ec2TransitGateway(output["transitGateway"], context);
    }
    return contents;
};
const deserializeAws_ec2CreateTransitGatewayRouteResult = (output, context) => {
    let contents = {
        __type: "CreateTransitGatewayRouteResult",
        Route: undefined
    };
    if (output["route"] !== undefined) {
        contents.Route = deserializeAws_ec2TransitGatewayRoute(output["route"], context);
    }
    return contents;
};
const deserializeAws_ec2CreateTransitGatewayRouteTableResult = (output, context) => {
    let contents = {
        __type: "CreateTransitGatewayRouteTableResult",
        TransitGatewayRouteTable: undefined
    };
    if (output["transitGatewayRouteTable"] !== undefined) {
        contents.TransitGatewayRouteTable = deserializeAws_ec2TransitGatewayRouteTable(output["transitGatewayRouteTable"], context);
    }
    return contents;
};
const deserializeAws_ec2CreateTransitGatewayVpcAttachmentResult = (output, context) => {
    let contents = {
        __type: "CreateTransitGatewayVpcAttachmentResult",
        TransitGatewayVpcAttachment: undefined
    };
    if (output["transitGatewayVpcAttachment"] !== undefined) {
        contents.TransitGatewayVpcAttachment = deserializeAws_ec2TransitGatewayVpcAttachment(output["transitGatewayVpcAttachment"], context);
    }
    return contents;
};
const deserializeAws_ec2CreateVolumePermission = (output, context) => {
    let contents = {
        __type: "CreateVolumePermission",
        Group: undefined,
        UserId: undefined
    };
    if (output["group"] !== undefined) {
        contents.Group = output["group"];
    }
    if (output["userId"] !== undefined) {
        contents.UserId = output["userId"];
    }
    return contents;
};
const deserializeAws_ec2CreateVolumePermissionList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2CreateVolumePermission(entry, context));
    });
    return contents;
};
const deserializeAws_ec2CreateVpcEndpointConnectionNotificationResult = (output, context) => {
    let contents = {
        __type: "CreateVpcEndpointConnectionNotificationResult",
        ClientToken: undefined,
        ConnectionNotification: undefined
    };
    if (output["clientToken"] !== undefined) {
        contents.ClientToken = output["clientToken"];
    }
    if (output["connectionNotification"] !== undefined) {
        contents.ConnectionNotification = deserializeAws_ec2ConnectionNotification(output["connectionNotification"], context);
    }
    return contents;
};
const deserializeAws_ec2CreateVpcEndpointResult = (output, context) => {
    let contents = {
        __type: "CreateVpcEndpointResult",
        ClientToken: undefined,
        VpcEndpoint: undefined
    };
    if (output["clientToken"] !== undefined) {
        contents.ClientToken = output["clientToken"];
    }
    if (output["vpcEndpoint"] !== undefined) {
        contents.VpcEndpoint = deserializeAws_ec2VpcEndpoint(output["vpcEndpoint"], context);
    }
    return contents;
};
const deserializeAws_ec2CreateVpcEndpointServiceConfigurationResult = (output, context) => {
    let contents = {
        __type: "CreateVpcEndpointServiceConfigurationResult",
        ClientToken: undefined,
        ServiceConfiguration: undefined
    };
    if (output["clientToken"] !== undefined) {
        contents.ClientToken = output["clientToken"];
    }
    if (output["serviceConfiguration"] !== undefined) {
        contents.ServiceConfiguration = deserializeAws_ec2ServiceConfiguration(output["serviceConfiguration"], context);
    }
    return contents;
};
const deserializeAws_ec2CreateVpcPeeringConnectionResult = (output, context) => {
    let contents = {
        __type: "CreateVpcPeeringConnectionResult",
        VpcPeeringConnection: undefined
    };
    if (output["vpcPeeringConnection"] !== undefined) {
        contents.VpcPeeringConnection = deserializeAws_ec2VpcPeeringConnection(output["vpcPeeringConnection"], context);
    }
    return contents;
};
const deserializeAws_ec2CreateVpcResult = (output, context) => {
    let contents = {
        __type: "CreateVpcResult",
        Vpc: undefined
    };
    if (output["vpc"] !== undefined) {
        contents.Vpc = deserializeAws_ec2Vpc(output["vpc"], context);
    }
    return contents;
};
const deserializeAws_ec2CreateVpnConnectionResult = (output, context) => {
    let contents = {
        __type: "CreateVpnConnectionResult",
        VpnConnection: undefined
    };
    if (output["vpnConnection"] !== undefined) {
        contents.VpnConnection = deserializeAws_ec2VpnConnection(output["vpnConnection"], context);
    }
    return contents;
};
const deserializeAws_ec2CreateVpnGatewayResult = (output, context) => {
    let contents = {
        __type: "CreateVpnGatewayResult",
        VpnGateway: undefined
    };
    if (output["vpnGateway"] !== undefined) {
        contents.VpnGateway = deserializeAws_ec2VpnGateway(output["vpnGateway"], context);
    }
    return contents;
};
const deserializeAws_ec2CreditSpecification = (output, context) => {
    let contents = {
        __type: "CreditSpecification",
        CpuCredits: undefined
    };
    if (output["cpuCredits"] !== undefined) {
        contents.CpuCredits = output["cpuCredits"];
    }
    return contents;
};
const deserializeAws_ec2CustomerGateway = (output, context) => {
    let contents = {
        __type: "CustomerGateway",
        BgpAsn: undefined,
        CertificateArn: undefined,
        CustomerGatewayId: undefined,
        DeviceName: undefined,
        IpAddress: undefined,
        State: undefined,
        Tags: undefined,
        Type: undefined
    };
    if (output["bgpAsn"] !== undefined) {
        contents.BgpAsn = output["bgpAsn"];
    }
    if (output["certificateArn"] !== undefined) {
        contents.CertificateArn = output["certificateArn"];
    }
    if (output["customerGatewayId"] !== undefined) {
        contents.CustomerGatewayId = output["customerGatewayId"];
    }
    if (output["deviceName"] !== undefined) {
        contents.DeviceName = output["deviceName"];
    }
    if (output["ipAddress"] !== undefined) {
        contents.IpAddress = output["ipAddress"];
    }
    if (output["state"] !== undefined) {
        contents.State = output["state"];
    }
    if (output.tagSet === "") {
        contents.Tags = [];
    }
    if (output["tagSet"] !== undefined &&
        output["tagSet"]["item"] !== undefined) {
        const wrappedItem = output["tagSet"]["item"] instanceof Array
            ? output["tagSet"]["item"]
            : [output["tagSet"]["item"]];
        contents.Tags = deserializeAws_ec2TagList(wrappedItem, context);
    }
    if (output["type"] !== undefined) {
        contents.Type = output["type"];
    }
    return contents;
};
const deserializeAws_ec2CustomerGatewayList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2CustomerGateway(entry, context));
    });
    return contents;
};
const deserializeAws_ec2DeleteClientVpnEndpointResult = (output, context) => {
    let contents = {
        __type: "DeleteClientVpnEndpointResult",
        Status: undefined
    };
    if (output["status"] !== undefined) {
        contents.Status = deserializeAws_ec2ClientVpnEndpointStatus(output["status"], context);
    }
    return contents;
};
const deserializeAws_ec2DeleteClientVpnRouteResult = (output, context) => {
    let contents = {
        __type: "DeleteClientVpnRouteResult",
        Status: undefined
    };
    if (output["status"] !== undefined) {
        contents.Status = deserializeAws_ec2ClientVpnRouteStatus(output["status"], context);
    }
    return contents;
};
const deserializeAws_ec2DeleteEgressOnlyInternetGatewayResult = (output, context) => {
    let contents = {
        __type: "DeleteEgressOnlyInternetGatewayResult",
        ReturnCode: undefined
    };
    if (output["returnCode"] !== undefined) {
        contents.ReturnCode = output["returnCode"] == "true";
    }
    return contents;
};
const deserializeAws_ec2DeleteFleetError = (output, context) => {
    let contents = {
        __type: "DeleteFleetError",
        Code: undefined,
        Message: undefined
    };
    if (output["code"] !== undefined) {
        contents.Code = output["code"];
    }
    if (output["message"] !== undefined) {
        contents.Message = output["message"];
    }
    return contents;
};
const deserializeAws_ec2DeleteFleetErrorItem = (output, context) => {
    let contents = {
        __type: "DeleteFleetErrorItem",
        Error: undefined,
        FleetId: undefined
    };
    if (output["error"] !== undefined) {
        contents.Error = deserializeAws_ec2DeleteFleetError(output["error"], context);
    }
    if (output["fleetId"] !== undefined) {
        contents.FleetId = output["fleetId"];
    }
    return contents;
};
const deserializeAws_ec2DeleteFleetErrorSet = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2DeleteFleetErrorItem(entry, context));
    });
    return contents;
};
const deserializeAws_ec2DeleteFleetSuccessItem = (output, context) => {
    let contents = {
        __type: "DeleteFleetSuccessItem",
        CurrentFleetState: undefined,
        FleetId: undefined,
        PreviousFleetState: undefined
    };
    if (output["currentFleetState"] !== undefined) {
        contents.CurrentFleetState = output["currentFleetState"];
    }
    if (output["fleetId"] !== undefined) {
        contents.FleetId = output["fleetId"];
    }
    if (output["previousFleetState"] !== undefined) {
        contents.PreviousFleetState = output["previousFleetState"];
    }
    return contents;
};
const deserializeAws_ec2DeleteFleetSuccessSet = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2DeleteFleetSuccessItem(entry, context));
    });
    return contents;
};
const deserializeAws_ec2DeleteFleetsResult = (output, context) => {
    let contents = {
        __type: "DeleteFleetsResult",
        SuccessfulFleetDeletions: undefined,
        UnsuccessfulFleetDeletions: undefined
    };
    if (output.successfulFleetDeletionSet === "") {
        contents.SuccessfulFleetDeletions = [];
    }
    if (output["successfulFleetDeletionSet"] !== undefined &&
        output["successfulFleetDeletionSet"]["item"] !== undefined) {
        const wrappedItem = output["successfulFleetDeletionSet"]["item"] instanceof Array
            ? output["successfulFleetDeletionSet"]["item"]
            : [output["successfulFleetDeletionSet"]["item"]];
        contents.SuccessfulFleetDeletions = deserializeAws_ec2DeleteFleetSuccessSet(wrappedItem, context);
    }
    if (output.unsuccessfulFleetDeletionSet === "") {
        contents.UnsuccessfulFleetDeletions = [];
    }
    if (output["unsuccessfulFleetDeletionSet"] !== undefined &&
        output["unsuccessfulFleetDeletionSet"]["item"] !== undefined) {
        const wrappedItem = output["unsuccessfulFleetDeletionSet"]["item"] instanceof Array
            ? output["unsuccessfulFleetDeletionSet"]["item"]
            : [output["unsuccessfulFleetDeletionSet"]["item"]];
        contents.UnsuccessfulFleetDeletions = deserializeAws_ec2DeleteFleetErrorSet(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2DeleteFlowLogsResult = (output, context) => {
    let contents = {
        __type: "DeleteFlowLogsResult",
        Unsuccessful: undefined
    };
    if (output.unsuccessful === "") {
        contents.Unsuccessful = [];
    }
    if (output["unsuccessful"] !== undefined &&
        output["unsuccessful"]["item"] !== undefined) {
        const wrappedItem = output["unsuccessful"]["item"] instanceof Array
            ? output["unsuccessful"]["item"]
            : [output["unsuccessful"]["item"]];
        contents.Unsuccessful = deserializeAws_ec2UnsuccessfulItemSet(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2DeleteFpgaImageResult = (output, context) => {
    let contents = {
        __type: "DeleteFpgaImageResult",
        Return: undefined
    };
    if (output["return"] !== undefined) {
        contents.Return = output["return"] == "true";
    }
    return contents;
};
const deserializeAws_ec2DeleteLaunchTemplateResult = (output, context) => {
    let contents = {
        __type: "DeleteLaunchTemplateResult",
        LaunchTemplate: undefined
    };
    if (output["launchTemplate"] !== undefined) {
        contents.LaunchTemplate = deserializeAws_ec2LaunchTemplate(output["launchTemplate"], context);
    }
    return contents;
};
const deserializeAws_ec2DeleteLaunchTemplateVersionsResponseErrorItem = (output, context) => {
    let contents = {
        __type: "DeleteLaunchTemplateVersionsResponseErrorItem",
        LaunchTemplateId: undefined,
        LaunchTemplateName: undefined,
        ResponseError: undefined,
        VersionNumber: undefined
    };
    if (output["launchTemplateId"] !== undefined) {
        contents.LaunchTemplateId = output["launchTemplateId"];
    }
    if (output["launchTemplateName"] !== undefined) {
        contents.LaunchTemplateName = output["launchTemplateName"];
    }
    if (output["responseError"] !== undefined) {
        contents.ResponseError = deserializeAws_ec2ResponseError(output["responseError"], context);
    }
    if (output["versionNumber"] !== undefined) {
        contents.VersionNumber = parseInt(output["versionNumber"]);
    }
    return contents;
};
const deserializeAws_ec2DeleteLaunchTemplateVersionsResponseErrorSet = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2DeleteLaunchTemplateVersionsResponseErrorItem(entry, context));
    });
    return contents;
};
const deserializeAws_ec2DeleteLaunchTemplateVersionsResponseSuccessItem = (output, context) => {
    let contents = {
        __type: "DeleteLaunchTemplateVersionsResponseSuccessItem",
        LaunchTemplateId: undefined,
        LaunchTemplateName: undefined,
        VersionNumber: undefined
    };
    if (output["launchTemplateId"] !== undefined) {
        contents.LaunchTemplateId = output["launchTemplateId"];
    }
    if (output["launchTemplateName"] !== undefined) {
        contents.LaunchTemplateName = output["launchTemplateName"];
    }
    if (output["versionNumber"] !== undefined) {
        contents.VersionNumber = parseInt(output["versionNumber"]);
    }
    return contents;
};
const deserializeAws_ec2DeleteLaunchTemplateVersionsResponseSuccessSet = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2DeleteLaunchTemplateVersionsResponseSuccessItem(entry, context));
    });
    return contents;
};
const deserializeAws_ec2DeleteLaunchTemplateVersionsResult = (output, context) => {
    let contents = {
        __type: "DeleteLaunchTemplateVersionsResult",
        SuccessfullyDeletedLaunchTemplateVersions: undefined,
        UnsuccessfullyDeletedLaunchTemplateVersions: undefined
    };
    if (output.successfullyDeletedLaunchTemplateVersionSet === "") {
        contents.SuccessfullyDeletedLaunchTemplateVersions = [];
    }
    if (output["successfullyDeletedLaunchTemplateVersionSet"] !== undefined &&
        output["successfullyDeletedLaunchTemplateVersionSet"]["item"] !== undefined) {
        const wrappedItem = output["successfullyDeletedLaunchTemplateVersionSet"]["item"] instanceof
            Array
            ? output["successfullyDeletedLaunchTemplateVersionSet"]["item"]
            : [output["successfullyDeletedLaunchTemplateVersionSet"]["item"]];
        contents.SuccessfullyDeletedLaunchTemplateVersions = deserializeAws_ec2DeleteLaunchTemplateVersionsResponseSuccessSet(wrappedItem, context);
    }
    if (output.unsuccessfullyDeletedLaunchTemplateVersionSet === "") {
        contents.UnsuccessfullyDeletedLaunchTemplateVersions = [];
    }
    if (output["unsuccessfullyDeletedLaunchTemplateVersionSet"] !== undefined &&
        output["unsuccessfullyDeletedLaunchTemplateVersionSet"]["item"] !==
            undefined) {
        const wrappedItem = output["unsuccessfullyDeletedLaunchTemplateVersionSet"]["item"] instanceof
            Array
            ? output["unsuccessfullyDeletedLaunchTemplateVersionSet"]["item"]
            : [output["unsuccessfullyDeletedLaunchTemplateVersionSet"]["item"]];
        contents.UnsuccessfullyDeletedLaunchTemplateVersions = deserializeAws_ec2DeleteLaunchTemplateVersionsResponseErrorSet(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2DeleteLocalGatewayRouteResult = (output, context) => {
    let contents = {
        __type: "DeleteLocalGatewayRouteResult",
        Route: undefined
    };
    if (output["route"] !== undefined) {
        contents.Route = deserializeAws_ec2LocalGatewayRoute(output["route"], context);
    }
    return contents;
};
const deserializeAws_ec2DeleteLocalGatewayRouteTableVpcAssociationResult = (output, context) => {
    let contents = {
        __type: "DeleteLocalGatewayRouteTableVpcAssociationResult",
        LocalGatewayRouteTableVpcAssociation: undefined
    };
    if (output["localGatewayRouteTableVpcAssociation"] !== undefined) {
        contents.LocalGatewayRouteTableVpcAssociation = deserializeAws_ec2LocalGatewayRouteTableVpcAssociation(output["localGatewayRouteTableVpcAssociation"], context);
    }
    return contents;
};
const deserializeAws_ec2DeleteNatGatewayResult = (output, context) => {
    let contents = {
        __type: "DeleteNatGatewayResult",
        NatGatewayId: undefined
    };
    if (output["natGatewayId"] !== undefined) {
        contents.NatGatewayId = output["natGatewayId"];
    }
    return contents;
};
const deserializeAws_ec2DeleteNetworkInterfacePermissionResult = (output, context) => {
    let contents = {
        __type: "DeleteNetworkInterfacePermissionResult",
        Return: undefined
    };
    if (output["return"] !== undefined) {
        contents.Return = output["return"] == "true";
    }
    return contents;
};
const deserializeAws_ec2DeleteQueuedReservedInstancesError = (output, context) => {
    let contents = {
        __type: "DeleteQueuedReservedInstancesError",
        Code: undefined,
        Message: undefined
    };
    if (output["code"] !== undefined) {
        contents.Code = output["code"];
    }
    if (output["message"] !== undefined) {
        contents.Message = output["message"];
    }
    return contents;
};
const deserializeAws_ec2DeleteQueuedReservedInstancesResult = (output, context) => {
    let contents = {
        __type: "DeleteQueuedReservedInstancesResult",
        FailedQueuedPurchaseDeletions: undefined,
        SuccessfulQueuedPurchaseDeletions: undefined
    };
    if (output.failedQueuedPurchaseDeletionSet === "") {
        contents.FailedQueuedPurchaseDeletions = [];
    }
    if (output["failedQueuedPurchaseDeletionSet"] !== undefined &&
        output["failedQueuedPurchaseDeletionSet"]["item"] !== undefined) {
        const wrappedItem = output["failedQueuedPurchaseDeletionSet"]["item"] instanceof Array
            ? output["failedQueuedPurchaseDeletionSet"]["item"]
            : [output["failedQueuedPurchaseDeletionSet"]["item"]];
        contents.FailedQueuedPurchaseDeletions = deserializeAws_ec2FailedQueuedPurchaseDeletionSet(wrappedItem, context);
    }
    if (output.successfulQueuedPurchaseDeletionSet === "") {
        contents.SuccessfulQueuedPurchaseDeletions = [];
    }
    if (output["successfulQueuedPurchaseDeletionSet"] !== undefined &&
        output["successfulQueuedPurchaseDeletionSet"]["item"] !== undefined) {
        const wrappedItem = output["successfulQueuedPurchaseDeletionSet"]["item"] instanceof Array
            ? output["successfulQueuedPurchaseDeletionSet"]["item"]
            : [output["successfulQueuedPurchaseDeletionSet"]["item"]];
        contents.SuccessfulQueuedPurchaseDeletions = deserializeAws_ec2SuccessfulQueuedPurchaseDeletionSet(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2DeleteTrafficMirrorFilterResult = (output, context) => {
    let contents = {
        __type: "DeleteTrafficMirrorFilterResult",
        TrafficMirrorFilterId: undefined
    };
    if (output["trafficMirrorFilterId"] !== undefined) {
        contents.TrafficMirrorFilterId = output["trafficMirrorFilterId"];
    }
    return contents;
};
const deserializeAws_ec2DeleteTrafficMirrorFilterRuleResult = (output, context) => {
    let contents = {
        __type: "DeleteTrafficMirrorFilterRuleResult",
        TrafficMirrorFilterRuleId: undefined
    };
    if (output["trafficMirrorFilterRuleId"] !== undefined) {
        contents.TrafficMirrorFilterRuleId = output["trafficMirrorFilterRuleId"];
    }
    return contents;
};
const deserializeAws_ec2DeleteTrafficMirrorSessionResult = (output, context) => {
    let contents = {
        __type: "DeleteTrafficMirrorSessionResult",
        TrafficMirrorSessionId: undefined
    };
    if (output["trafficMirrorSessionId"] !== undefined) {
        contents.TrafficMirrorSessionId = output["trafficMirrorSessionId"];
    }
    return contents;
};
const deserializeAws_ec2DeleteTrafficMirrorTargetResult = (output, context) => {
    let contents = {
        __type: "DeleteTrafficMirrorTargetResult",
        TrafficMirrorTargetId: undefined
    };
    if (output["trafficMirrorTargetId"] !== undefined) {
        contents.TrafficMirrorTargetId = output["trafficMirrorTargetId"];
    }
    return contents;
};
const deserializeAws_ec2DeleteTransitGatewayMulticastDomainResult = (output, context) => {
    let contents = {
        __type: "DeleteTransitGatewayMulticastDomainResult",
        TransitGatewayMulticastDomain: undefined
    };
    if (output["transitGatewayMulticastDomain"] !== undefined) {
        contents.TransitGatewayMulticastDomain = deserializeAws_ec2TransitGatewayMulticastDomain(output["transitGatewayMulticastDomain"], context);
    }
    return contents;
};
const deserializeAws_ec2DeleteTransitGatewayPeeringAttachmentResult = (output, context) => {
    let contents = {
        __type: "DeleteTransitGatewayPeeringAttachmentResult",
        TransitGatewayPeeringAttachment: undefined
    };
    if (output["transitGatewayPeeringAttachment"] !== undefined) {
        contents.TransitGatewayPeeringAttachment = deserializeAws_ec2TransitGatewayPeeringAttachment(output["transitGatewayPeeringAttachment"], context);
    }
    return contents;
};
const deserializeAws_ec2DeleteTransitGatewayResult = (output, context) => {
    let contents = {
        __type: "DeleteTransitGatewayResult",
        TransitGateway: undefined
    };
    if (output["transitGateway"] !== undefined) {
        contents.TransitGateway = deserializeAws_ec2TransitGateway(output["transitGateway"], context);
    }
    return contents;
};
const deserializeAws_ec2DeleteTransitGatewayRouteResult = (output, context) => {
    let contents = {
        __type: "DeleteTransitGatewayRouteResult",
        Route: undefined
    };
    if (output["route"] !== undefined) {
        contents.Route = deserializeAws_ec2TransitGatewayRoute(output["route"], context);
    }
    return contents;
};
const deserializeAws_ec2DeleteTransitGatewayRouteTableResult = (output, context) => {
    let contents = {
        __type: "DeleteTransitGatewayRouteTableResult",
        TransitGatewayRouteTable: undefined
    };
    if (output["transitGatewayRouteTable"] !== undefined) {
        contents.TransitGatewayRouteTable = deserializeAws_ec2TransitGatewayRouteTable(output["transitGatewayRouteTable"], context);
    }
    return contents;
};
const deserializeAws_ec2DeleteTransitGatewayVpcAttachmentResult = (output, context) => {
    let contents = {
        __type: "DeleteTransitGatewayVpcAttachmentResult",
        TransitGatewayVpcAttachment: undefined
    };
    if (output["transitGatewayVpcAttachment"] !== undefined) {
        contents.TransitGatewayVpcAttachment = deserializeAws_ec2TransitGatewayVpcAttachment(output["transitGatewayVpcAttachment"], context);
    }
    return contents;
};
const deserializeAws_ec2DeleteVpcEndpointConnectionNotificationsResult = (output, context) => {
    let contents = {
        __type: "DeleteVpcEndpointConnectionNotificationsResult",
        Unsuccessful: undefined
    };
    if (output.unsuccessful === "") {
        contents.Unsuccessful = [];
    }
    if (output["unsuccessful"] !== undefined &&
        output["unsuccessful"]["item"] !== undefined) {
        const wrappedItem = output["unsuccessful"]["item"] instanceof Array
            ? output["unsuccessful"]["item"]
            : [output["unsuccessful"]["item"]];
        contents.Unsuccessful = deserializeAws_ec2UnsuccessfulItemSet(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2DeleteVpcEndpointServiceConfigurationsResult = (output, context) => {
    let contents = {
        __type: "DeleteVpcEndpointServiceConfigurationsResult",
        Unsuccessful: undefined
    };
    if (output.unsuccessful === "") {
        contents.Unsuccessful = [];
    }
    if (output["unsuccessful"] !== undefined &&
        output["unsuccessful"]["item"] !== undefined) {
        const wrappedItem = output["unsuccessful"]["item"] instanceof Array
            ? output["unsuccessful"]["item"]
            : [output["unsuccessful"]["item"]];
        contents.Unsuccessful = deserializeAws_ec2UnsuccessfulItemSet(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2DeleteVpcEndpointsResult = (output, context) => {
    let contents = {
        __type: "DeleteVpcEndpointsResult",
        Unsuccessful: undefined
    };
    if (output.unsuccessful === "") {
        contents.Unsuccessful = [];
    }
    if (output["unsuccessful"] !== undefined &&
        output["unsuccessful"]["item"] !== undefined) {
        const wrappedItem = output["unsuccessful"]["item"] instanceof Array
            ? output["unsuccessful"]["item"]
            : [output["unsuccessful"]["item"]];
        contents.Unsuccessful = deserializeAws_ec2UnsuccessfulItemSet(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2DeleteVpcPeeringConnectionResult = (output, context) => {
    let contents = {
        __type: "DeleteVpcPeeringConnectionResult",
        Return: undefined
    };
    if (output["return"] !== undefined) {
        contents.Return = output["return"] == "true";
    }
    return contents;
};
const deserializeAws_ec2DeprovisionByoipCidrResult = (output, context) => {
    let contents = {
        __type: "DeprovisionByoipCidrResult",
        ByoipCidr: undefined
    };
    if (output["byoipCidr"] !== undefined) {
        contents.ByoipCidr = deserializeAws_ec2ByoipCidr(output["byoipCidr"], context);
    }
    return contents;
};
const deserializeAws_ec2DeregisterTransitGatewayMulticastGroupMembersResult = (output, context) => {
    let contents = {
        __type: "DeregisterTransitGatewayMulticastGroupMembersResult",
        DeregisteredMulticastGroupMembers: undefined
    };
    if (output["deregisteredMulticastGroupMembers"] !== undefined) {
        contents.DeregisteredMulticastGroupMembers = deserializeAws_ec2TransitGatewayMulticastDeregisteredGroupMembers(output["deregisteredMulticastGroupMembers"], context);
    }
    return contents;
};
const deserializeAws_ec2DeregisterTransitGatewayMulticastGroupSourcesResult = (output, context) => {
    let contents = {
        __type: "DeregisterTransitGatewayMulticastGroupSourcesResult",
        DeregisteredMulticastGroupSources: undefined
    };
    if (output["deregisteredMulticastGroupSources"] !== undefined) {
        contents.DeregisteredMulticastGroupSources = deserializeAws_ec2TransitGatewayMulticastDeregisteredGroupSources(output["deregisteredMulticastGroupSources"], context);
    }
    return contents;
};
const deserializeAws_ec2DescribeAccountAttributesResult = (output, context) => {
    let contents = {
        __type: "DescribeAccountAttributesResult",
        AccountAttributes: undefined
    };
    if (output.accountAttributeSet === "") {
        contents.AccountAttributes = [];
    }
    if (output["accountAttributeSet"] !== undefined &&
        output["accountAttributeSet"]["item"] !== undefined) {
        const wrappedItem = output["accountAttributeSet"]["item"] instanceof Array
            ? output["accountAttributeSet"]["item"]
            : [output["accountAttributeSet"]["item"]];
        contents.AccountAttributes = deserializeAws_ec2AccountAttributeList(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2DescribeAddressesResult = (output, context) => {
    let contents = {
        __type: "DescribeAddressesResult",
        Addresses: undefined
    };
    if (output.addressesSet === "") {
        contents.Addresses = [];
    }
    if (output["addressesSet"] !== undefined &&
        output["addressesSet"]["item"] !== undefined) {
        const wrappedItem = output["addressesSet"]["item"] instanceof Array
            ? output["addressesSet"]["item"]
            : [output["addressesSet"]["item"]];
        contents.Addresses = deserializeAws_ec2AddressList(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2DescribeAggregateIdFormatResult = (output, context) => {
    let contents = {
        __type: "DescribeAggregateIdFormatResult",
        Statuses: undefined,
        UseLongIdsAggregated: undefined
    };
    if (output.statusSet === "") {
        contents.Statuses = [];
    }
    if (output["statusSet"] !== undefined &&
        output["statusSet"]["item"] !== undefined) {
        const wrappedItem = output["statusSet"]["item"] instanceof Array
            ? output["statusSet"]["item"]
            : [output["statusSet"]["item"]];
        contents.Statuses = deserializeAws_ec2IdFormatList(wrappedItem, context);
    }
    if (output["useLongIdsAggregated"] !== undefined) {
        contents.UseLongIdsAggregated = output["useLongIdsAggregated"] == "true";
    }
    return contents;
};
const deserializeAws_ec2DescribeAvailabilityZonesResult = (output, context) => {
    let contents = {
        __type: "DescribeAvailabilityZonesResult",
        AvailabilityZones: undefined
    };
    if (output.availabilityZoneInfo === "") {
        contents.AvailabilityZones = [];
    }
    if (output["availabilityZoneInfo"] !== undefined &&
        output["availabilityZoneInfo"]["item"] !== undefined) {
        const wrappedItem = output["availabilityZoneInfo"]["item"] instanceof Array
            ? output["availabilityZoneInfo"]["item"]
            : [output["availabilityZoneInfo"]["item"]];
        contents.AvailabilityZones = deserializeAws_ec2AvailabilityZoneList(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2DescribeBundleTasksResult = (output, context) => {
    let contents = {
        __type: "DescribeBundleTasksResult",
        BundleTasks: undefined
    };
    if (output.bundleInstanceTasksSet === "") {
        contents.BundleTasks = [];
    }
    if (output["bundleInstanceTasksSet"] !== undefined &&
        output["bundleInstanceTasksSet"]["item"] !== undefined) {
        const wrappedItem = output["bundleInstanceTasksSet"]["item"] instanceof Array
            ? output["bundleInstanceTasksSet"]["item"]
            : [output["bundleInstanceTasksSet"]["item"]];
        contents.BundleTasks = deserializeAws_ec2BundleTaskList(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2DescribeByoipCidrsResult = (output, context) => {
    let contents = {
        __type: "DescribeByoipCidrsResult",
        ByoipCidrs: undefined,
        NextToken: undefined
    };
    if (output.byoipCidrSet === "") {
        contents.ByoipCidrs = [];
    }
    if (output["byoipCidrSet"] !== undefined &&
        output["byoipCidrSet"]["item"] !== undefined) {
        const wrappedItem = output["byoipCidrSet"]["item"] instanceof Array
            ? output["byoipCidrSet"]["item"]
            : [output["byoipCidrSet"]["item"]];
        contents.ByoipCidrs = deserializeAws_ec2ByoipCidrSet(wrappedItem, context);
    }
    if (output["nextToken"] !== undefined) {
        contents.NextToken = output["nextToken"];
    }
    return contents;
};
const deserializeAws_ec2DescribeCapacityReservationsResult = (output, context) => {
    let contents = {
        __type: "DescribeCapacityReservationsResult",
        CapacityReservations: undefined,
        NextToken: undefined
    };
    if (output.capacityReservationSet === "") {
        contents.CapacityReservations = [];
    }
    if (output["capacityReservationSet"] !== undefined &&
        output["capacityReservationSet"]["item"] !== undefined) {
        const wrappedItem = output["capacityReservationSet"]["item"] instanceof Array
            ? output["capacityReservationSet"]["item"]
            : [output["capacityReservationSet"]["item"]];
        contents.CapacityReservations = deserializeAws_ec2CapacityReservationSet(wrappedItem, context);
    }
    if (output["nextToken"] !== undefined) {
        contents.NextToken = output["nextToken"];
    }
    return contents;
};
const deserializeAws_ec2DescribeClassicLinkInstancesResult = (output, context) => {
    let contents = {
        __type: "DescribeClassicLinkInstancesResult",
        Instances: undefined,
        NextToken: undefined
    };
    if (output.instancesSet === "") {
        contents.Instances = [];
    }
    if (output["instancesSet"] !== undefined &&
        output["instancesSet"]["item"] !== undefined) {
        const wrappedItem = output["instancesSet"]["item"] instanceof Array
            ? output["instancesSet"]["item"]
            : [output["instancesSet"]["item"]];
        contents.Instances = deserializeAws_ec2ClassicLinkInstanceList(wrappedItem, context);
    }
    if (output["nextToken"] !== undefined) {
        contents.NextToken = output["nextToken"];
    }
    return contents;
};
const deserializeAws_ec2DescribeClientVpnAuthorizationRulesResult = (output, context) => {
    let contents = {
        __type: "DescribeClientVpnAuthorizationRulesResult",
        AuthorizationRules: undefined,
        NextToken: undefined
    };
    if (output.authorizationRule === "") {
        contents.AuthorizationRules = [];
    }
    if (output["authorizationRule"] !== undefined &&
        output["authorizationRule"]["item"] !== undefined) {
        const wrappedItem = output["authorizationRule"]["item"] instanceof Array
            ? output["authorizationRule"]["item"]
            : [output["authorizationRule"]["item"]];
        contents.AuthorizationRules = deserializeAws_ec2AuthorizationRuleSet(wrappedItem, context);
    }
    if (output["nextToken"] !== undefined) {
        contents.NextToken = output["nextToken"];
    }
    return contents;
};
const deserializeAws_ec2DescribeClientVpnConnectionsResult = (output, context) => {
    let contents = {
        __type: "DescribeClientVpnConnectionsResult",
        Connections: undefined,
        NextToken: undefined
    };
    if (output.connections === "") {
        contents.Connections = [];
    }
    if (output["connections"] !== undefined &&
        output["connections"]["item"] !== undefined) {
        const wrappedItem = output["connections"]["item"] instanceof Array
            ? output["connections"]["item"]
            : [output["connections"]["item"]];
        contents.Connections = deserializeAws_ec2ClientVpnConnectionSet(wrappedItem, context);
    }
    if (output["nextToken"] !== undefined) {
        contents.NextToken = output["nextToken"];
    }
    return contents;
};
const deserializeAws_ec2DescribeClientVpnEndpointsResult = (output, context) => {
    let contents = {
        __type: "DescribeClientVpnEndpointsResult",
        ClientVpnEndpoints: undefined,
        NextToken: undefined
    };
    if (output.clientVpnEndpoint === "") {
        contents.ClientVpnEndpoints = [];
    }
    if (output["clientVpnEndpoint"] !== undefined &&
        output["clientVpnEndpoint"]["item"] !== undefined) {
        const wrappedItem = output["clientVpnEndpoint"]["item"] instanceof Array
            ? output["clientVpnEndpoint"]["item"]
            : [output["clientVpnEndpoint"]["item"]];
        contents.ClientVpnEndpoints = deserializeAws_ec2EndpointSet(wrappedItem, context);
    }
    if (output["nextToken"] !== undefined) {
        contents.NextToken = output["nextToken"];
    }
    return contents;
};
const deserializeAws_ec2DescribeClientVpnRoutesResult = (output, context) => {
    let contents = {
        __type: "DescribeClientVpnRoutesResult",
        NextToken: undefined,
        Routes: undefined
    };
    if (output["nextToken"] !== undefined) {
        contents.NextToken = output["nextToken"];
    }
    if (output.routes === "") {
        contents.Routes = [];
    }
    if (output["routes"] !== undefined &&
        output["routes"]["item"] !== undefined) {
        const wrappedItem = output["routes"]["item"] instanceof Array
            ? output["routes"]["item"]
            : [output["routes"]["item"]];
        contents.Routes = deserializeAws_ec2ClientVpnRouteSet(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2DescribeClientVpnTargetNetworksResult = (output, context) => {
    let contents = {
        __type: "DescribeClientVpnTargetNetworksResult",
        ClientVpnTargetNetworks: undefined,
        NextToken: undefined
    };
    if (output.clientVpnTargetNetworks === "") {
        contents.ClientVpnTargetNetworks = [];
    }
    if (output["clientVpnTargetNetworks"] !== undefined &&
        output["clientVpnTargetNetworks"]["item"] !== undefined) {
        const wrappedItem = output["clientVpnTargetNetworks"]["item"] instanceof Array
            ? output["clientVpnTargetNetworks"]["item"]
            : [output["clientVpnTargetNetworks"]["item"]];
        contents.ClientVpnTargetNetworks = deserializeAws_ec2TargetNetworkSet(wrappedItem, context);
    }
    if (output["nextToken"] !== undefined) {
        contents.NextToken = output["nextToken"];
    }
    return contents;
};
const deserializeAws_ec2DescribeCoipPoolsResult = (output, context) => {
    let contents = {
        __type: "DescribeCoipPoolsResult",
        CoipPools: undefined,
        NextToken: undefined
    };
    if (output.coipPoolSet === "") {
        contents.CoipPools = [];
    }
    if (output["coipPoolSet"] !== undefined &&
        output["coipPoolSet"]["item"] !== undefined) {
        const wrappedItem = output["coipPoolSet"]["item"] instanceof Array
            ? output["coipPoolSet"]["item"]
            : [output["coipPoolSet"]["item"]];
        contents.CoipPools = deserializeAws_ec2CoipPoolSet(wrappedItem, context);
    }
    if (output["nextToken"] !== undefined) {
        contents.NextToken = output["nextToken"];
    }
    return contents;
};
const deserializeAws_ec2DescribeConversionTaskList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2ConversionTask(entry, context));
    });
    return contents;
};
const deserializeAws_ec2DescribeConversionTasksResult = (output, context) => {
    let contents = {
        __type: "DescribeConversionTasksResult",
        ConversionTasks: undefined
    };
    if (output.conversionTasks === "") {
        contents.ConversionTasks = [];
    }
    if (output["conversionTasks"] !== undefined &&
        output["conversionTasks"]["item"] !== undefined) {
        const wrappedItem = output["conversionTasks"]["item"] instanceof Array
            ? output["conversionTasks"]["item"]
            : [output["conversionTasks"]["item"]];
        contents.ConversionTasks = deserializeAws_ec2DescribeConversionTaskList(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2DescribeCustomerGatewaysResult = (output, context) => {
    let contents = {
        __type: "DescribeCustomerGatewaysResult",
        CustomerGateways: undefined
    };
    if (output.customerGatewaySet === "") {
        contents.CustomerGateways = [];
    }
    if (output["customerGatewaySet"] !== undefined &&
        output["customerGatewaySet"]["item"] !== undefined) {
        const wrappedItem = output["customerGatewaySet"]["item"] instanceof Array
            ? output["customerGatewaySet"]["item"]
            : [output["customerGatewaySet"]["item"]];
        contents.CustomerGateways = deserializeAws_ec2CustomerGatewayList(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2DescribeDhcpOptionsResult = (output, context) => {
    let contents = {
        __type: "DescribeDhcpOptionsResult",
        DhcpOptions: undefined,
        NextToken: undefined
    };
    if (output.dhcpOptionsSet === "") {
        contents.DhcpOptions = [];
    }
    if (output["dhcpOptionsSet"] !== undefined &&
        output["dhcpOptionsSet"]["item"] !== undefined) {
        const wrappedItem = output["dhcpOptionsSet"]["item"] instanceof Array
            ? output["dhcpOptionsSet"]["item"]
            : [output["dhcpOptionsSet"]["item"]];
        contents.DhcpOptions = deserializeAws_ec2DhcpOptionsList(wrappedItem, context);
    }
    if (output["nextToken"] !== undefined) {
        contents.NextToken = output["nextToken"];
    }
    return contents;
};
const deserializeAws_ec2DescribeEgressOnlyInternetGatewaysResult = (output, context) => {
    let contents = {
        __type: "DescribeEgressOnlyInternetGatewaysResult",
        EgressOnlyInternetGateways: undefined,
        NextToken: undefined
    };
    if (output.egressOnlyInternetGatewaySet === "") {
        contents.EgressOnlyInternetGateways = [];
    }
    if (output["egressOnlyInternetGatewaySet"] !== undefined &&
        output["egressOnlyInternetGatewaySet"]["item"] !== undefined) {
        const wrappedItem = output["egressOnlyInternetGatewaySet"]["item"] instanceof Array
            ? output["egressOnlyInternetGatewaySet"]["item"]
            : [output["egressOnlyInternetGatewaySet"]["item"]];
        contents.EgressOnlyInternetGateways = deserializeAws_ec2EgressOnlyInternetGatewayList(wrappedItem, context);
    }
    if (output["nextToken"] !== undefined) {
        contents.NextToken = output["nextToken"];
    }
    return contents;
};
const deserializeAws_ec2DescribeElasticGpusResult = (output, context) => {
    let contents = {
        __type: "DescribeElasticGpusResult",
        ElasticGpuSet: undefined,
        MaxResults: undefined,
        NextToken: undefined
    };
    if (output.elasticGpuSet === "") {
        contents.ElasticGpuSet = [];
    }
    if (output["elasticGpuSet"] !== undefined &&
        output["elasticGpuSet"]["item"] !== undefined) {
        const wrappedItem = output["elasticGpuSet"]["item"] instanceof Array
            ? output["elasticGpuSet"]["item"]
            : [output["elasticGpuSet"]["item"]];
        contents.ElasticGpuSet = deserializeAws_ec2ElasticGpuSet(wrappedItem, context);
    }
    if (output["maxResults"] !== undefined) {
        contents.MaxResults = parseInt(output["maxResults"]);
    }
    if (output["nextToken"] !== undefined) {
        contents.NextToken = output["nextToken"];
    }
    return contents;
};
const deserializeAws_ec2DescribeExportImageTasksResult = (output, context) => {
    let contents = {
        __type: "DescribeExportImageTasksResult",
        ExportImageTasks: undefined,
        NextToken: undefined
    };
    if (output.exportImageTaskSet === "") {
        contents.ExportImageTasks = [];
    }
    if (output["exportImageTaskSet"] !== undefined &&
        output["exportImageTaskSet"]["item"] !== undefined) {
        const wrappedItem = output["exportImageTaskSet"]["item"] instanceof Array
            ? output["exportImageTaskSet"]["item"]
            : [output["exportImageTaskSet"]["item"]];
        contents.ExportImageTasks = deserializeAws_ec2ExportImageTaskList(wrappedItem, context);
    }
    if (output["nextToken"] !== undefined) {
        contents.NextToken = output["nextToken"];
    }
    return contents;
};
const deserializeAws_ec2DescribeExportTasksResult = (output, context) => {
    let contents = {
        __type: "DescribeExportTasksResult",
        ExportTasks: undefined
    };
    if (output.exportTaskSet === "") {
        contents.ExportTasks = [];
    }
    if (output["exportTaskSet"] !== undefined &&
        output["exportTaskSet"]["item"] !== undefined) {
        const wrappedItem = output["exportTaskSet"]["item"] instanceof Array
            ? output["exportTaskSet"]["item"]
            : [output["exportTaskSet"]["item"]];
        contents.ExportTasks = deserializeAws_ec2ExportTaskList(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2DescribeFastSnapshotRestoreSuccessItem = (output, context) => {
    let contents = {
        __type: "DescribeFastSnapshotRestoreSuccessItem",
        AvailabilityZone: undefined,
        DisabledTime: undefined,
        DisablingTime: undefined,
        EnabledTime: undefined,
        EnablingTime: undefined,
        OptimizingTime: undefined,
        OwnerAlias: undefined,
        OwnerId: undefined,
        SnapshotId: undefined,
        State: undefined,
        StateTransitionReason: undefined
    };
    if (output["availabilityZone"] !== undefined) {
        contents.AvailabilityZone = output["availabilityZone"];
    }
    if (output["disabledTime"] !== undefined) {
        contents.DisabledTime = new Date(output["disabledTime"]);
    }
    if (output["disablingTime"] !== undefined) {
        contents.DisablingTime = new Date(output["disablingTime"]);
    }
    if (output["enabledTime"] !== undefined) {
        contents.EnabledTime = new Date(output["enabledTime"]);
    }
    if (output["enablingTime"] !== undefined) {
        contents.EnablingTime = new Date(output["enablingTime"]);
    }
    if (output["optimizingTime"] !== undefined) {
        contents.OptimizingTime = new Date(output["optimizingTime"]);
    }
    if (output["ownerAlias"] !== undefined) {
        contents.OwnerAlias = output["ownerAlias"];
    }
    if (output["ownerId"] !== undefined) {
        contents.OwnerId = output["ownerId"];
    }
    if (output["snapshotId"] !== undefined) {
        contents.SnapshotId = output["snapshotId"];
    }
    if (output["state"] !== undefined) {
        contents.State = output["state"];
    }
    if (output["stateTransitionReason"] !== undefined) {
        contents.StateTransitionReason = output["stateTransitionReason"];
    }
    return contents;
};
const deserializeAws_ec2DescribeFastSnapshotRestoreSuccessSet = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2DescribeFastSnapshotRestoreSuccessItem(entry, context));
    });
    return contents;
};
const deserializeAws_ec2DescribeFastSnapshotRestoresResult = (output, context) => {
    let contents = {
        __type: "DescribeFastSnapshotRestoresResult",
        FastSnapshotRestores: undefined,
        NextToken: undefined
    };
    if (output.fastSnapshotRestoreSet === "") {
        contents.FastSnapshotRestores = [];
    }
    if (output["fastSnapshotRestoreSet"] !== undefined &&
        output["fastSnapshotRestoreSet"]["item"] !== undefined) {
        const wrappedItem = output["fastSnapshotRestoreSet"]["item"] instanceof Array
            ? output["fastSnapshotRestoreSet"]["item"]
            : [output["fastSnapshotRestoreSet"]["item"]];
        contents.FastSnapshotRestores = deserializeAws_ec2DescribeFastSnapshotRestoreSuccessSet(wrappedItem, context);
    }
    if (output["nextToken"] !== undefined) {
        contents.NextToken = output["nextToken"];
    }
    return contents;
};
const deserializeAws_ec2DescribeFleetError = (output, context) => {
    let contents = {
        __type: "DescribeFleetError",
        ErrorCode: undefined,
        ErrorMessage: undefined,
        LaunchTemplateAndOverrides: undefined,
        Lifecycle: undefined
    };
    if (output["errorCode"] !== undefined) {
        contents.ErrorCode = output["errorCode"];
    }
    if (output["errorMessage"] !== undefined) {
        contents.ErrorMessage = output["errorMessage"];
    }
    if (output["launchTemplateAndOverrides"] !== undefined) {
        contents.LaunchTemplateAndOverrides = deserializeAws_ec2LaunchTemplateAndOverridesResponse(output["launchTemplateAndOverrides"], context);
    }
    if (output["lifecycle"] !== undefined) {
        contents.Lifecycle = output["lifecycle"];
    }
    return contents;
};
const deserializeAws_ec2DescribeFleetHistoryResult = (output, context) => {
    let contents = {
        __type: "DescribeFleetHistoryResult",
        FleetId: undefined,
        HistoryRecords: undefined,
        LastEvaluatedTime: undefined,
        NextToken: undefined,
        StartTime: undefined
    };
    if (output["fleetId"] !== undefined) {
        contents.FleetId = output["fleetId"];
    }
    if (output.historyRecordSet === "") {
        contents.HistoryRecords = [];
    }
    if (output["historyRecordSet"] !== undefined &&
        output["historyRecordSet"]["item"] !== undefined) {
        const wrappedItem = output["historyRecordSet"]["item"] instanceof Array
            ? output["historyRecordSet"]["item"]
            : [output["historyRecordSet"]["item"]];
        contents.HistoryRecords = deserializeAws_ec2HistoryRecordSet(wrappedItem, context);
    }
    if (output["lastEvaluatedTime"] !== undefined) {
        contents.LastEvaluatedTime = new Date(output["lastEvaluatedTime"]);
    }
    if (output["nextToken"] !== undefined) {
        contents.NextToken = output["nextToken"];
    }
    if (output["startTime"] !== undefined) {
        contents.StartTime = new Date(output["startTime"]);
    }
    return contents;
};
const deserializeAws_ec2DescribeFleetInstancesResult = (output, context) => {
    let contents = {
        __type: "DescribeFleetInstancesResult",
        ActiveInstances: undefined,
        FleetId: undefined,
        NextToken: undefined
    };
    if (output.activeInstanceSet === "") {
        contents.ActiveInstances = [];
    }
    if (output["activeInstanceSet"] !== undefined &&
        output["activeInstanceSet"]["item"] !== undefined) {
        const wrappedItem = output["activeInstanceSet"]["item"] instanceof Array
            ? output["activeInstanceSet"]["item"]
            : [output["activeInstanceSet"]["item"]];
        contents.ActiveInstances = deserializeAws_ec2ActiveInstanceSet(wrappedItem, context);
    }
    if (output["fleetId"] !== undefined) {
        contents.FleetId = output["fleetId"];
    }
    if (output["nextToken"] !== undefined) {
        contents.NextToken = output["nextToken"];
    }
    return contents;
};
const deserializeAws_ec2DescribeFleetsErrorSet = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2DescribeFleetError(entry, context));
    });
    return contents;
};
const deserializeAws_ec2DescribeFleetsInstances = (output, context) => {
    let contents = {
        __type: "DescribeFleetsInstances",
        InstanceIds: undefined,
        InstanceType: undefined,
        LaunchTemplateAndOverrides: undefined,
        Lifecycle: undefined,
        Platform: undefined
    };
    if (output.instanceIds === "") {
        contents.InstanceIds = [];
    }
    if (output["instanceIds"] !== undefined &&
        output["instanceIds"]["item"] !== undefined) {
        const wrappedItem = output["instanceIds"]["item"] instanceof Array
            ? output["instanceIds"]["item"]
            : [output["instanceIds"]["item"]];
        contents.InstanceIds = deserializeAws_ec2InstanceIdsSet(wrappedItem, context);
    }
    if (output["instanceType"] !== undefined) {
        contents.InstanceType = output["instanceType"];
    }
    if (output["launchTemplateAndOverrides"] !== undefined) {
        contents.LaunchTemplateAndOverrides = deserializeAws_ec2LaunchTemplateAndOverridesResponse(output["launchTemplateAndOverrides"], context);
    }
    if (output["lifecycle"] !== undefined) {
        contents.Lifecycle = output["lifecycle"];
    }
    if (output["platform"] !== undefined) {
        contents.Platform = output["platform"];
    }
    return contents;
};
const deserializeAws_ec2DescribeFleetsInstancesSet = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2DescribeFleetsInstances(entry, context));
    });
    return contents;
};
const deserializeAws_ec2DescribeFleetsResult = (output, context) => {
    let contents = {
        __type: "DescribeFleetsResult",
        Fleets: undefined,
        NextToken: undefined
    };
    if (output.fleetSet === "") {
        contents.Fleets = [];
    }
    if (output["fleetSet"] !== undefined &&
        output["fleetSet"]["item"] !== undefined) {
        const wrappedItem = output["fleetSet"]["item"] instanceof Array
            ? output["fleetSet"]["item"]
            : [output["fleetSet"]["item"]];
        contents.Fleets = deserializeAws_ec2FleetSet(wrappedItem, context);
    }
    if (output["nextToken"] !== undefined) {
        contents.NextToken = output["nextToken"];
    }
    return contents;
};
const deserializeAws_ec2DescribeFlowLogsResult = (output, context) => {
    let contents = {
        __type: "DescribeFlowLogsResult",
        FlowLogs: undefined,
        NextToken: undefined
    };
    if (output.flowLogSet === "") {
        contents.FlowLogs = [];
    }
    if (output["flowLogSet"] !== undefined &&
        output["flowLogSet"]["item"] !== undefined) {
        const wrappedItem = output["flowLogSet"]["item"] instanceof Array
            ? output["flowLogSet"]["item"]
            : [output["flowLogSet"]["item"]];
        contents.FlowLogs = deserializeAws_ec2FlowLogSet(wrappedItem, context);
    }
    if (output["nextToken"] !== undefined) {
        contents.NextToken = output["nextToken"];
    }
    return contents;
};
const deserializeAws_ec2DescribeFpgaImageAttributeResult = (output, context) => {
    let contents = {
        __type: "DescribeFpgaImageAttributeResult",
        FpgaImageAttribute: undefined
    };
    if (output["fpgaImageAttribute"] !== undefined) {
        contents.FpgaImageAttribute = deserializeAws_ec2FpgaImageAttribute(output["fpgaImageAttribute"], context);
    }
    return contents;
};
const deserializeAws_ec2DescribeFpgaImagesResult = (output, context) => {
    let contents = {
        __type: "DescribeFpgaImagesResult",
        FpgaImages: undefined,
        NextToken: undefined
    };
    if (output.fpgaImageSet === "") {
        contents.FpgaImages = [];
    }
    if (output["fpgaImageSet"] !== undefined &&
        output["fpgaImageSet"]["item"] !== undefined) {
        const wrappedItem = output["fpgaImageSet"]["item"] instanceof Array
            ? output["fpgaImageSet"]["item"]
            : [output["fpgaImageSet"]["item"]];
        contents.FpgaImages = deserializeAws_ec2FpgaImageList(wrappedItem, context);
    }
    if (output["nextToken"] !== undefined) {
        contents.NextToken = output["nextToken"];
    }
    return contents;
};
const deserializeAws_ec2DescribeHostReservationOfferingsResult = (output, context) => {
    let contents = {
        __type: "DescribeHostReservationOfferingsResult",
        NextToken: undefined,
        OfferingSet: undefined
    };
    if (output["nextToken"] !== undefined) {
        contents.NextToken = output["nextToken"];
    }
    if (output.offeringSet === "") {
        contents.OfferingSet = [];
    }
    if (output["offeringSet"] !== undefined &&
        output["offeringSet"]["item"] !== undefined) {
        const wrappedItem = output["offeringSet"]["item"] instanceof Array
            ? output["offeringSet"]["item"]
            : [output["offeringSet"]["item"]];
        contents.OfferingSet = deserializeAws_ec2HostOfferingSet(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2DescribeHostReservationsResult = (output, context) => {
    let contents = {
        __type: "DescribeHostReservationsResult",
        HostReservationSet: undefined,
        NextToken: undefined
    };
    if (output.hostReservationSet === "") {
        contents.HostReservationSet = [];
    }
    if (output["hostReservationSet"] !== undefined &&
        output["hostReservationSet"]["item"] !== undefined) {
        const wrappedItem = output["hostReservationSet"]["item"] instanceof Array
            ? output["hostReservationSet"]["item"]
            : [output["hostReservationSet"]["item"]];
        contents.HostReservationSet = deserializeAws_ec2HostReservationSet(wrappedItem, context);
    }
    if (output["nextToken"] !== undefined) {
        contents.NextToken = output["nextToken"];
    }
    return contents;
};
const deserializeAws_ec2DescribeHostsResult = (output, context) => {
    let contents = {
        __type: "DescribeHostsResult",
        Hosts: undefined,
        NextToken: undefined
    };
    if (output.hostSet === "") {
        contents.Hosts = [];
    }
    if (output["hostSet"] !== undefined &&
        output["hostSet"]["item"] !== undefined) {
        const wrappedItem = output["hostSet"]["item"] instanceof Array
            ? output["hostSet"]["item"]
            : [output["hostSet"]["item"]];
        contents.Hosts = deserializeAws_ec2HostList(wrappedItem, context);
    }
    if (output["nextToken"] !== undefined) {
        contents.NextToken = output["nextToken"];
    }
    return contents;
};
const deserializeAws_ec2DescribeIamInstanceProfileAssociationsResult = (output, context) => {
    let contents = {
        __type: "DescribeIamInstanceProfileAssociationsResult",
        IamInstanceProfileAssociations: undefined,
        NextToken: undefined
    };
    if (output.iamInstanceProfileAssociationSet === "") {
        contents.IamInstanceProfileAssociations = [];
    }
    if (output["iamInstanceProfileAssociationSet"] !== undefined &&
        output["iamInstanceProfileAssociationSet"]["item"] !== undefined) {
        const wrappedItem = output["iamInstanceProfileAssociationSet"]["item"] instanceof Array
            ? output["iamInstanceProfileAssociationSet"]["item"]
            : [output["iamInstanceProfileAssociationSet"]["item"]];
        contents.IamInstanceProfileAssociations = deserializeAws_ec2IamInstanceProfileAssociationSet(wrappedItem, context);
    }
    if (output["nextToken"] !== undefined) {
        contents.NextToken = output["nextToken"];
    }
    return contents;
};
const deserializeAws_ec2DescribeIdFormatResult = (output, context) => {
    let contents = {
        __type: "DescribeIdFormatResult",
        Statuses: undefined
    };
    if (output.statusSet === "") {
        contents.Statuses = [];
    }
    if (output["statusSet"] !== undefined &&
        output["statusSet"]["item"] !== undefined) {
        const wrappedItem = output["statusSet"]["item"] instanceof Array
            ? output["statusSet"]["item"]
            : [output["statusSet"]["item"]];
        contents.Statuses = deserializeAws_ec2IdFormatList(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2DescribeIdentityIdFormatResult = (output, context) => {
    let contents = {
        __type: "DescribeIdentityIdFormatResult",
        Statuses: undefined
    };
    if (output.statusSet === "") {
        contents.Statuses = [];
    }
    if (output["statusSet"] !== undefined &&
        output["statusSet"]["item"] !== undefined) {
        const wrappedItem = output["statusSet"]["item"] instanceof Array
            ? output["statusSet"]["item"]
            : [output["statusSet"]["item"]];
        contents.Statuses = deserializeAws_ec2IdFormatList(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2DescribeImagesResult = (output, context) => {
    let contents = {
        __type: "DescribeImagesResult",
        Images: undefined
    };
    if (output.imagesSet === "") {
        contents.Images = [];
    }
    if (output["imagesSet"] !== undefined &&
        output["imagesSet"]["item"] !== undefined) {
        const wrappedItem = output["imagesSet"]["item"] instanceof Array
            ? output["imagesSet"]["item"]
            : [output["imagesSet"]["item"]];
        contents.Images = deserializeAws_ec2ImageList(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2DescribeImportImageTasksResult = (output, context) => {
    let contents = {
        __type: "DescribeImportImageTasksResult",
        ImportImageTasks: undefined,
        NextToken: undefined
    };
    if (output.importImageTaskSet === "") {
        contents.ImportImageTasks = [];
    }
    if (output["importImageTaskSet"] !== undefined &&
        output["importImageTaskSet"]["item"] !== undefined) {
        const wrappedItem = output["importImageTaskSet"]["item"] instanceof Array
            ? output["importImageTaskSet"]["item"]
            : [output["importImageTaskSet"]["item"]];
        contents.ImportImageTasks = deserializeAws_ec2ImportImageTaskList(wrappedItem, context);
    }
    if (output["nextToken"] !== undefined) {
        contents.NextToken = output["nextToken"];
    }
    return contents;
};
const deserializeAws_ec2DescribeImportSnapshotTasksResult = (output, context) => {
    let contents = {
        __type: "DescribeImportSnapshotTasksResult",
        ImportSnapshotTasks: undefined,
        NextToken: undefined
    };
    if (output.importSnapshotTaskSet === "") {
        contents.ImportSnapshotTasks = [];
    }
    if (output["importSnapshotTaskSet"] !== undefined &&
        output["importSnapshotTaskSet"]["item"] !== undefined) {
        const wrappedItem = output["importSnapshotTaskSet"]["item"] instanceof Array
            ? output["importSnapshotTaskSet"]["item"]
            : [output["importSnapshotTaskSet"]["item"]];
        contents.ImportSnapshotTasks = deserializeAws_ec2ImportSnapshotTaskList(wrappedItem, context);
    }
    if (output["nextToken"] !== undefined) {
        contents.NextToken = output["nextToken"];
    }
    return contents;
};
const deserializeAws_ec2DescribeInstanceCreditSpecificationsResult = (output, context) => {
    let contents = {
        __type: "DescribeInstanceCreditSpecificationsResult",
        InstanceCreditSpecifications: undefined,
        NextToken: undefined
    };
    if (output.instanceCreditSpecificationSet === "") {
        contents.InstanceCreditSpecifications = [];
    }
    if (output["instanceCreditSpecificationSet"] !== undefined &&
        output["instanceCreditSpecificationSet"]["item"] !== undefined) {
        const wrappedItem = output["instanceCreditSpecificationSet"]["item"] instanceof Array
            ? output["instanceCreditSpecificationSet"]["item"]
            : [output["instanceCreditSpecificationSet"]["item"]];
        contents.InstanceCreditSpecifications = deserializeAws_ec2InstanceCreditSpecificationList(wrappedItem, context);
    }
    if (output["nextToken"] !== undefined) {
        contents.NextToken = output["nextToken"];
    }
    return contents;
};
const deserializeAws_ec2DescribeInstanceStatusResult = (output, context) => {
    let contents = {
        __type: "DescribeInstanceStatusResult",
        InstanceStatuses: undefined,
        NextToken: undefined
    };
    if (output.instanceStatusSet === "") {
        contents.InstanceStatuses = [];
    }
    if (output["instanceStatusSet"] !== undefined &&
        output["instanceStatusSet"]["item"] !== undefined) {
        const wrappedItem = output["instanceStatusSet"]["item"] instanceof Array
            ? output["instanceStatusSet"]["item"]
            : [output["instanceStatusSet"]["item"]];
        contents.InstanceStatuses = deserializeAws_ec2InstanceStatusList(wrappedItem, context);
    }
    if (output["nextToken"] !== undefined) {
        contents.NextToken = output["nextToken"];
    }
    return contents;
};
const deserializeAws_ec2DescribeInstanceTypeOfferingsResult = (output, context) => {
    let contents = {
        __type: "DescribeInstanceTypeOfferingsResult",
        InstanceTypeOfferings: undefined,
        NextToken: undefined
    };
    if (output.instanceTypeOfferingSet === "") {
        contents.InstanceTypeOfferings = [];
    }
    if (output["instanceTypeOfferingSet"] !== undefined &&
        output["instanceTypeOfferingSet"]["item"] !== undefined) {
        const wrappedItem = output["instanceTypeOfferingSet"]["item"] instanceof Array
            ? output["instanceTypeOfferingSet"]["item"]
            : [output["instanceTypeOfferingSet"]["item"]];
        contents.InstanceTypeOfferings = deserializeAws_ec2InstanceTypeOfferingsList(wrappedItem, context);
    }
    if (output["nextToken"] !== undefined) {
        contents.NextToken = output["nextToken"];
    }
    return contents;
};
const deserializeAws_ec2DescribeInstanceTypesResult = (output, context) => {
    let contents = {
        __type: "DescribeInstanceTypesResult",
        InstanceTypes: undefined,
        NextToken: undefined
    };
    if (output.instanceTypeSet === "") {
        contents.InstanceTypes = [];
    }
    if (output["instanceTypeSet"] !== undefined &&
        output["instanceTypeSet"]["item"] !== undefined) {
        const wrappedItem = output["instanceTypeSet"]["item"] instanceof Array
            ? output["instanceTypeSet"]["item"]
            : [output["instanceTypeSet"]["item"]];
        contents.InstanceTypes = deserializeAws_ec2InstanceTypeInfoList(wrappedItem, context);
    }
    if (output["nextToken"] !== undefined) {
        contents.NextToken = output["nextToken"];
    }
    return contents;
};
const deserializeAws_ec2DescribeInstancesResult = (output, context) => {
    let contents = {
        __type: "DescribeInstancesResult",
        NextToken: undefined,
        Reservations: undefined
    };
    if (output["nextToken"] !== undefined) {
        contents.NextToken = output["nextToken"];
    }
    if (output.reservationSet === "") {
        contents.Reservations = [];
    }
    if (output["reservationSet"] !== undefined &&
        output["reservationSet"]["item"] !== undefined) {
        const wrappedItem = output["reservationSet"]["item"] instanceof Array
            ? output["reservationSet"]["item"]
            : [output["reservationSet"]["item"]];
        contents.Reservations = deserializeAws_ec2ReservationList(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2DescribeInternetGatewaysResult = (output, context) => {
    let contents = {
        __type: "DescribeInternetGatewaysResult",
        InternetGateways: undefined,
        NextToken: undefined
    };
    if (output.internetGatewaySet === "") {
        contents.InternetGateways = [];
    }
    if (output["internetGatewaySet"] !== undefined &&
        output["internetGatewaySet"]["item"] !== undefined) {
        const wrappedItem = output["internetGatewaySet"]["item"] instanceof Array
            ? output["internetGatewaySet"]["item"]
            : [output["internetGatewaySet"]["item"]];
        contents.InternetGateways = deserializeAws_ec2InternetGatewayList(wrappedItem, context);
    }
    if (output["nextToken"] !== undefined) {
        contents.NextToken = output["nextToken"];
    }
    return contents;
};
const deserializeAws_ec2DescribeIpv6PoolsResult = (output, context) => {
    let contents = {
        __type: "DescribeIpv6PoolsResult",
        Ipv6Pools: undefined,
        NextToken: undefined
    };
    if (output.ipv6PoolSet === "") {
        contents.Ipv6Pools = [];
    }
    if (output["ipv6PoolSet"] !== undefined &&
        output["ipv6PoolSet"]["item"] !== undefined) {
        const wrappedItem = output["ipv6PoolSet"]["item"] instanceof Array
            ? output["ipv6PoolSet"]["item"]
            : [output["ipv6PoolSet"]["item"]];
        contents.Ipv6Pools = deserializeAws_ec2Ipv6PoolSet(wrappedItem, context);
    }
    if (output["nextToken"] !== undefined) {
        contents.NextToken = output["nextToken"];
    }
    return contents;
};
const deserializeAws_ec2DescribeKeyPairsResult = (output, context) => {
    let contents = {
        __type: "DescribeKeyPairsResult",
        KeyPairs: undefined
    };
    if (output.keySet === "") {
        contents.KeyPairs = [];
    }
    if (output["keySet"] !== undefined &&
        output["keySet"]["item"] !== undefined) {
        const wrappedItem = output["keySet"]["item"] instanceof Array
            ? output["keySet"]["item"]
            : [output["keySet"]["item"]];
        contents.KeyPairs = deserializeAws_ec2KeyPairList(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2DescribeLaunchTemplateVersionsResult = (output, context) => {
    let contents = {
        __type: "DescribeLaunchTemplateVersionsResult",
        LaunchTemplateVersions: undefined,
        NextToken: undefined
    };
    if (output.launchTemplateVersionSet === "") {
        contents.LaunchTemplateVersions = [];
    }
    if (output["launchTemplateVersionSet"] !== undefined &&
        output["launchTemplateVersionSet"]["item"] !== undefined) {
        const wrappedItem = output["launchTemplateVersionSet"]["item"] instanceof Array
            ? output["launchTemplateVersionSet"]["item"]
            : [output["launchTemplateVersionSet"]["item"]];
        contents.LaunchTemplateVersions = deserializeAws_ec2LaunchTemplateVersionSet(wrappedItem, context);
    }
    if (output["nextToken"] !== undefined) {
        contents.NextToken = output["nextToken"];
    }
    return contents;
};
const deserializeAws_ec2DescribeLaunchTemplatesResult = (output, context) => {
    let contents = {
        __type: "DescribeLaunchTemplatesResult",
        LaunchTemplates: undefined,
        NextToken: undefined
    };
    if (output.launchTemplates === "") {
        contents.LaunchTemplates = [];
    }
    if (output["launchTemplates"] !== undefined &&
        output["launchTemplates"]["item"] !== undefined) {
        const wrappedItem = output["launchTemplates"]["item"] instanceof Array
            ? output["launchTemplates"]["item"]
            : [output["launchTemplates"]["item"]];
        contents.LaunchTemplates = deserializeAws_ec2LaunchTemplateSet(wrappedItem, context);
    }
    if (output["nextToken"] !== undefined) {
        contents.NextToken = output["nextToken"];
    }
    return contents;
};
const deserializeAws_ec2DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsResult = (output, context) => {
    let contents = {
        __type: "DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsResult",
        LocalGatewayRouteTableVirtualInterfaceGroupAssociations: undefined,
        NextToken: undefined
    };
    if (output.localGatewayRouteTableVirtualInterfaceGroupAssociationSet === "") {
        contents.LocalGatewayRouteTableVirtualInterfaceGroupAssociations = [];
    }
    if (output["localGatewayRouteTableVirtualInterfaceGroupAssociationSet"] !==
        undefined &&
        output["localGatewayRouteTableVirtualInterfaceGroupAssociationSet"]["item"] !== undefined) {
        const wrappedItem = output["localGatewayRouteTableVirtualInterfaceGroupAssociationSet"]["item"] instanceof Array
            ? output["localGatewayRouteTableVirtualInterfaceGroupAssociationSet"]["item"]
            : [
                output["localGatewayRouteTableVirtualInterfaceGroupAssociationSet"]["item"]
            ];
        contents.LocalGatewayRouteTableVirtualInterfaceGroupAssociations = deserializeAws_ec2LocalGatewayRouteTableVirtualInterfaceGroupAssociationSet(wrappedItem, context);
    }
    if (output["nextToken"] !== undefined) {
        contents.NextToken = output["nextToken"];
    }
    return contents;
};
const deserializeAws_ec2DescribeLocalGatewayRouteTableVpcAssociationsResult = (output, context) => {
    let contents = {
        __type: "DescribeLocalGatewayRouteTableVpcAssociationsResult",
        LocalGatewayRouteTableVpcAssociations: undefined,
        NextToken: undefined
    };
    if (output.localGatewayRouteTableVpcAssociationSet === "") {
        contents.LocalGatewayRouteTableVpcAssociations = [];
    }
    if (output["localGatewayRouteTableVpcAssociationSet"] !== undefined &&
        output["localGatewayRouteTableVpcAssociationSet"]["item"] !== undefined) {
        const wrappedItem = output["localGatewayRouteTableVpcAssociationSet"]["item"] instanceof Array
            ? output["localGatewayRouteTableVpcAssociationSet"]["item"]
            : [output["localGatewayRouteTableVpcAssociationSet"]["item"]];
        contents.LocalGatewayRouteTableVpcAssociations = deserializeAws_ec2LocalGatewayRouteTableVpcAssociationSet(wrappedItem, context);
    }
    if (output["nextToken"] !== undefined) {
        contents.NextToken = output["nextToken"];
    }
    return contents;
};
const deserializeAws_ec2DescribeLocalGatewayRouteTablesResult = (output, context) => {
    let contents = {
        __type: "DescribeLocalGatewayRouteTablesResult",
        LocalGatewayRouteTables: undefined,
        NextToken: undefined
    };
    if (output.localGatewayRouteTableSet === "") {
        contents.LocalGatewayRouteTables = [];
    }
    if (output["localGatewayRouteTableSet"] !== undefined &&
        output["localGatewayRouteTableSet"]["item"] !== undefined) {
        const wrappedItem = output["localGatewayRouteTableSet"]["item"] instanceof Array
            ? output["localGatewayRouteTableSet"]["item"]
            : [output["localGatewayRouteTableSet"]["item"]];
        contents.LocalGatewayRouteTables = deserializeAws_ec2LocalGatewayRouteTableSet(wrappedItem, context);
    }
    if (output["nextToken"] !== undefined) {
        contents.NextToken = output["nextToken"];
    }
    return contents;
};
const deserializeAws_ec2DescribeLocalGatewayVirtualInterfaceGroupsResult = (output, context) => {
    let contents = {
        __type: "DescribeLocalGatewayVirtualInterfaceGroupsResult",
        LocalGatewayVirtualInterfaceGroups: undefined,
        NextToken: undefined
    };
    if (output.localGatewayVirtualInterfaceGroupSet === "") {
        contents.LocalGatewayVirtualInterfaceGroups = [];
    }
    if (output["localGatewayVirtualInterfaceGroupSet"] !== undefined &&
        output["localGatewayVirtualInterfaceGroupSet"]["item"] !== undefined) {
        const wrappedItem = output["localGatewayVirtualInterfaceGroupSet"]["item"] instanceof Array
            ? output["localGatewayVirtualInterfaceGroupSet"]["item"]
            : [output["localGatewayVirtualInterfaceGroupSet"]["item"]];
        contents.LocalGatewayVirtualInterfaceGroups = deserializeAws_ec2LocalGatewayVirtualInterfaceGroupSet(wrappedItem, context);
    }
    if (output["nextToken"] !== undefined) {
        contents.NextToken = output["nextToken"];
    }
    return contents;
};
const deserializeAws_ec2DescribeLocalGatewayVirtualInterfacesResult = (output, context) => {
    let contents = {
        __type: "DescribeLocalGatewayVirtualInterfacesResult",
        LocalGatewayVirtualInterfaces: undefined,
        NextToken: undefined
    };
    if (output.localGatewayVirtualInterfaceSet === "") {
        contents.LocalGatewayVirtualInterfaces = [];
    }
    if (output["localGatewayVirtualInterfaceSet"] !== undefined &&
        output["localGatewayVirtualInterfaceSet"]["item"] !== undefined) {
        const wrappedItem = output["localGatewayVirtualInterfaceSet"]["item"] instanceof Array
            ? output["localGatewayVirtualInterfaceSet"]["item"]
            : [output["localGatewayVirtualInterfaceSet"]["item"]];
        contents.LocalGatewayVirtualInterfaces = deserializeAws_ec2LocalGatewayVirtualInterfaceSet(wrappedItem, context);
    }
    if (output["nextToken"] !== undefined) {
        contents.NextToken = output["nextToken"];
    }
    return contents;
};
const deserializeAws_ec2DescribeLocalGatewaysResult = (output, context) => {
    let contents = {
        __type: "DescribeLocalGatewaysResult",
        LocalGateways: undefined,
        NextToken: undefined
    };
    if (output.localGatewaySet === "") {
        contents.LocalGateways = [];
    }
    if (output["localGatewaySet"] !== undefined &&
        output["localGatewaySet"]["item"] !== undefined) {
        const wrappedItem = output["localGatewaySet"]["item"] instanceof Array
            ? output["localGatewaySet"]["item"]
            : [output["localGatewaySet"]["item"]];
        contents.LocalGateways = deserializeAws_ec2LocalGatewaySet(wrappedItem, context);
    }
    if (output["nextToken"] !== undefined) {
        contents.NextToken = output["nextToken"];
    }
    return contents;
};
const deserializeAws_ec2DescribeMovingAddressesResult = (output, context) => {
    let contents = {
        __type: "DescribeMovingAddressesResult",
        MovingAddressStatuses: undefined,
        NextToken: undefined
    };
    if (output.movingAddressStatusSet === "") {
        contents.MovingAddressStatuses = [];
    }
    if (output["movingAddressStatusSet"] !== undefined &&
        output["movingAddressStatusSet"]["item"] !== undefined) {
        const wrappedItem = output["movingAddressStatusSet"]["item"] instanceof Array
            ? output["movingAddressStatusSet"]["item"]
            : [output["movingAddressStatusSet"]["item"]];
        contents.MovingAddressStatuses = deserializeAws_ec2MovingAddressStatusSet(wrappedItem, context);
    }
    if (output["nextToken"] !== undefined) {
        contents.NextToken = output["nextToken"];
    }
    return contents;
};
const deserializeAws_ec2DescribeNatGatewaysResult = (output, context) => {
    let contents = {
        __type: "DescribeNatGatewaysResult",
        NatGateways: undefined,
        NextToken: undefined
    };
    if (output.natGatewaySet === "") {
        contents.NatGateways = [];
    }
    if (output["natGatewaySet"] !== undefined &&
        output["natGatewaySet"]["item"] !== undefined) {
        const wrappedItem = output["natGatewaySet"]["item"] instanceof Array
            ? output["natGatewaySet"]["item"]
            : [output["natGatewaySet"]["item"]];
        contents.NatGateways = deserializeAws_ec2NatGatewayList(wrappedItem, context);
    }
    if (output["nextToken"] !== undefined) {
        contents.NextToken = output["nextToken"];
    }
    return contents;
};
const deserializeAws_ec2DescribeNetworkAclsResult = (output, context) => {
    let contents = {
        __type: "DescribeNetworkAclsResult",
        NetworkAcls: undefined,
        NextToken: undefined
    };
    if (output.networkAclSet === "") {
        contents.NetworkAcls = [];
    }
    if (output["networkAclSet"] !== undefined &&
        output["networkAclSet"]["item"] !== undefined) {
        const wrappedItem = output["networkAclSet"]["item"] instanceof Array
            ? output["networkAclSet"]["item"]
            : [output["networkAclSet"]["item"]];
        contents.NetworkAcls = deserializeAws_ec2NetworkAclList(wrappedItem, context);
    }
    if (output["nextToken"] !== undefined) {
        contents.NextToken = output["nextToken"];
    }
    return contents;
};
const deserializeAws_ec2DescribeNetworkInterfaceAttributeResult = (output, context) => {
    let contents = {
        __type: "DescribeNetworkInterfaceAttributeResult",
        Attachment: undefined,
        Description: undefined,
        Groups: undefined,
        NetworkInterfaceId: undefined,
        SourceDestCheck: undefined
    };
    if (output["attachment"] !== undefined) {
        contents.Attachment = deserializeAws_ec2NetworkInterfaceAttachment(output["attachment"], context);
    }
    if (output["description"] !== undefined) {
        contents.Description = deserializeAws_ec2AttributeValue(output["description"], context);
    }
    if (output.groupSet === "") {
        contents.Groups = [];
    }
    if (output["groupSet"] !== undefined &&
        output["groupSet"]["item"] !== undefined) {
        const wrappedItem = output["groupSet"]["item"] instanceof Array
            ? output["groupSet"]["item"]
            : [output["groupSet"]["item"]];
        contents.Groups = deserializeAws_ec2GroupIdentifierList(wrappedItem, context);
    }
    if (output["networkInterfaceId"] !== undefined) {
        contents.NetworkInterfaceId = output["networkInterfaceId"];
    }
    if (output["sourceDestCheck"] !== undefined) {
        contents.SourceDestCheck = deserializeAws_ec2AttributeBooleanValue(output["sourceDestCheck"], context);
    }
    return contents;
};
const deserializeAws_ec2DescribeNetworkInterfacePermissionsResult = (output, context) => {
    let contents = {
        __type: "DescribeNetworkInterfacePermissionsResult",
        NetworkInterfacePermissions: undefined,
        NextToken: undefined
    };
    if (output.networkInterfacePermissions === "") {
        contents.NetworkInterfacePermissions = [];
    }
    if (output["networkInterfacePermissions"] !== undefined &&
        output["networkInterfacePermissions"]["item"] !== undefined) {
        const wrappedItem = output["networkInterfacePermissions"]["item"] instanceof Array
            ? output["networkInterfacePermissions"]["item"]
            : [output["networkInterfacePermissions"]["item"]];
        contents.NetworkInterfacePermissions = deserializeAws_ec2NetworkInterfacePermissionList(wrappedItem, context);
    }
    if (output["nextToken"] !== undefined) {
        contents.NextToken = output["nextToken"];
    }
    return contents;
};
const deserializeAws_ec2DescribeNetworkInterfacesResult = (output, context) => {
    let contents = {
        __type: "DescribeNetworkInterfacesResult",
        NetworkInterfaces: undefined,
        NextToken: undefined
    };
    if (output.networkInterfaceSet === "") {
        contents.NetworkInterfaces = [];
    }
    if (output["networkInterfaceSet"] !== undefined &&
        output["networkInterfaceSet"]["item"] !== undefined) {
        const wrappedItem = output["networkInterfaceSet"]["item"] instanceof Array
            ? output["networkInterfaceSet"]["item"]
            : [output["networkInterfaceSet"]["item"]];
        contents.NetworkInterfaces = deserializeAws_ec2NetworkInterfaceList(wrappedItem, context);
    }
    if (output["nextToken"] !== undefined) {
        contents.NextToken = output["nextToken"];
    }
    return contents;
};
const deserializeAws_ec2DescribePlacementGroupsResult = (output, context) => {
    let contents = {
        __type: "DescribePlacementGroupsResult",
        PlacementGroups: undefined
    };
    if (output.placementGroupSet === "") {
        contents.PlacementGroups = [];
    }
    if (output["placementGroupSet"] !== undefined &&
        output["placementGroupSet"]["item"] !== undefined) {
        const wrappedItem = output["placementGroupSet"]["item"] instanceof Array
            ? output["placementGroupSet"]["item"]
            : [output["placementGroupSet"]["item"]];
        contents.PlacementGroups = deserializeAws_ec2PlacementGroupList(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2DescribePrefixListsResult = (output, context) => {
    let contents = {
        __type: "DescribePrefixListsResult",
        NextToken: undefined,
        PrefixLists: undefined
    };
    if (output["nextToken"] !== undefined) {
        contents.NextToken = output["nextToken"];
    }
    if (output.prefixListSet === "") {
        contents.PrefixLists = [];
    }
    if (output["prefixListSet"] !== undefined &&
        output["prefixListSet"]["item"] !== undefined) {
        const wrappedItem = output["prefixListSet"]["item"] instanceof Array
            ? output["prefixListSet"]["item"]
            : [output["prefixListSet"]["item"]];
        contents.PrefixLists = deserializeAws_ec2PrefixListSet(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2DescribePrincipalIdFormatResult = (output, context) => {
    let contents = {
        __type: "DescribePrincipalIdFormatResult",
        NextToken: undefined,
        Principals: undefined
    };
    if (output["nextToken"] !== undefined) {
        contents.NextToken = output["nextToken"];
    }
    if (output.principalSet === "") {
        contents.Principals = [];
    }
    if (output["principalSet"] !== undefined &&
        output["principalSet"]["item"] !== undefined) {
        const wrappedItem = output["principalSet"]["item"] instanceof Array
            ? output["principalSet"]["item"]
            : [output["principalSet"]["item"]];
        contents.Principals = deserializeAws_ec2PrincipalIdFormatList(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2DescribePublicIpv4PoolsResult = (output, context) => {
    let contents = {
        __type: "DescribePublicIpv4PoolsResult",
        NextToken: undefined,
        PublicIpv4Pools: undefined
    };
    if (output["nextToken"] !== undefined) {
        contents.NextToken = output["nextToken"];
    }
    if (output.publicIpv4PoolSet === "") {
        contents.PublicIpv4Pools = [];
    }
    if (output["publicIpv4PoolSet"] !== undefined &&
        output["publicIpv4PoolSet"]["item"] !== undefined) {
        const wrappedItem = output["publicIpv4PoolSet"]["item"] instanceof Array
            ? output["publicIpv4PoolSet"]["item"]
            : [output["publicIpv4PoolSet"]["item"]];
        contents.PublicIpv4Pools = deserializeAws_ec2PublicIpv4PoolSet(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2DescribeRegionsResult = (output, context) => {
    let contents = {
        __type: "DescribeRegionsResult",
        Regions: undefined
    };
    if (output.regionInfo === "") {
        contents.Regions = [];
    }
    if (output["regionInfo"] !== undefined &&
        output["regionInfo"]["item"] !== undefined) {
        const wrappedItem = output["regionInfo"]["item"] instanceof Array
            ? output["regionInfo"]["item"]
            : [output["regionInfo"]["item"]];
        contents.Regions = deserializeAws_ec2RegionList(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2DescribeReservedInstancesListingsResult = (output, context) => {
    let contents = {
        __type: "DescribeReservedInstancesListingsResult",
        ReservedInstancesListings: undefined
    };
    if (output.reservedInstancesListingsSet === "") {
        contents.ReservedInstancesListings = [];
    }
    if (output["reservedInstancesListingsSet"] !== undefined &&
        output["reservedInstancesListingsSet"]["item"] !== undefined) {
        const wrappedItem = output["reservedInstancesListingsSet"]["item"] instanceof Array
            ? output["reservedInstancesListingsSet"]["item"]
            : [output["reservedInstancesListingsSet"]["item"]];
        contents.ReservedInstancesListings = deserializeAws_ec2ReservedInstancesListingList(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2DescribeReservedInstancesModificationsResult = (output, context) => {
    let contents = {
        __type: "DescribeReservedInstancesModificationsResult",
        NextToken: undefined,
        ReservedInstancesModifications: undefined
    };
    if (output["nextToken"] !== undefined) {
        contents.NextToken = output["nextToken"];
    }
    if (output.reservedInstancesModificationsSet === "") {
        contents.ReservedInstancesModifications = [];
    }
    if (output["reservedInstancesModificationsSet"] !== undefined &&
        output["reservedInstancesModificationsSet"]["item"] !== undefined) {
        const wrappedItem = output["reservedInstancesModificationsSet"]["item"] instanceof Array
            ? output["reservedInstancesModificationsSet"]["item"]
            : [output["reservedInstancesModificationsSet"]["item"]];
        contents.ReservedInstancesModifications = deserializeAws_ec2ReservedInstancesModificationList(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2DescribeReservedInstancesOfferingsResult = (output, context) => {
    let contents = {
        __type: "DescribeReservedInstancesOfferingsResult",
        NextToken: undefined,
        ReservedInstancesOfferings: undefined
    };
    if (output["nextToken"] !== undefined) {
        contents.NextToken = output["nextToken"];
    }
    if (output.reservedInstancesOfferingsSet === "") {
        contents.ReservedInstancesOfferings = [];
    }
    if (output["reservedInstancesOfferingsSet"] !== undefined &&
        output["reservedInstancesOfferingsSet"]["item"] !== undefined) {
        const wrappedItem = output["reservedInstancesOfferingsSet"]["item"] instanceof Array
            ? output["reservedInstancesOfferingsSet"]["item"]
            : [output["reservedInstancesOfferingsSet"]["item"]];
        contents.ReservedInstancesOfferings = deserializeAws_ec2ReservedInstancesOfferingList(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2DescribeReservedInstancesResult = (output, context) => {
    let contents = {
        __type: "DescribeReservedInstancesResult",
        ReservedInstances: undefined
    };
    if (output.reservedInstancesSet === "") {
        contents.ReservedInstances = [];
    }
    if (output["reservedInstancesSet"] !== undefined &&
        output["reservedInstancesSet"]["item"] !== undefined) {
        const wrappedItem = output["reservedInstancesSet"]["item"] instanceof Array
            ? output["reservedInstancesSet"]["item"]
            : [output["reservedInstancesSet"]["item"]];
        contents.ReservedInstances = deserializeAws_ec2ReservedInstancesList(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2DescribeRouteTablesResult = (output, context) => {
    let contents = {
        __type: "DescribeRouteTablesResult",
        NextToken: undefined,
        RouteTables: undefined
    };
    if (output["nextToken"] !== undefined) {
        contents.NextToken = output["nextToken"];
    }
    if (output.routeTableSet === "") {
        contents.RouteTables = [];
    }
    if (output["routeTableSet"] !== undefined &&
        output["routeTableSet"]["item"] !== undefined) {
        const wrappedItem = output["routeTableSet"]["item"] instanceof Array
            ? output["routeTableSet"]["item"]
            : [output["routeTableSet"]["item"]];
        contents.RouteTables = deserializeAws_ec2RouteTableList(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2DescribeScheduledInstanceAvailabilityResult = (output, context) => {
    let contents = {
        __type: "DescribeScheduledInstanceAvailabilityResult",
        NextToken: undefined,
        ScheduledInstanceAvailabilitySet: undefined
    };
    if (output["nextToken"] !== undefined) {
        contents.NextToken = output["nextToken"];
    }
    if (output.scheduledInstanceAvailabilitySet === "") {
        contents.ScheduledInstanceAvailabilitySet = [];
    }
    if (output["scheduledInstanceAvailabilitySet"] !== undefined &&
        output["scheduledInstanceAvailabilitySet"]["item"] !== undefined) {
        const wrappedItem = output["scheduledInstanceAvailabilitySet"]["item"] instanceof Array
            ? output["scheduledInstanceAvailabilitySet"]["item"]
            : [output["scheduledInstanceAvailabilitySet"]["item"]];
        contents.ScheduledInstanceAvailabilitySet = deserializeAws_ec2ScheduledInstanceAvailabilitySet(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2DescribeScheduledInstancesResult = (output, context) => {
    let contents = {
        __type: "DescribeScheduledInstancesResult",
        NextToken: undefined,
        ScheduledInstanceSet: undefined
    };
    if (output["nextToken"] !== undefined) {
        contents.NextToken = output["nextToken"];
    }
    if (output.scheduledInstanceSet === "") {
        contents.ScheduledInstanceSet = [];
    }
    if (output["scheduledInstanceSet"] !== undefined &&
        output["scheduledInstanceSet"]["item"] !== undefined) {
        const wrappedItem = output["scheduledInstanceSet"]["item"] instanceof Array
            ? output["scheduledInstanceSet"]["item"]
            : [output["scheduledInstanceSet"]["item"]];
        contents.ScheduledInstanceSet = deserializeAws_ec2ScheduledInstanceSet(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2DescribeSecurityGroupReferencesResult = (output, context) => {
    let contents = {
        __type: "DescribeSecurityGroupReferencesResult",
        SecurityGroupReferenceSet: undefined
    };
    if (output.securityGroupReferenceSet === "") {
        contents.SecurityGroupReferenceSet = [];
    }
    if (output["securityGroupReferenceSet"] !== undefined &&
        output["securityGroupReferenceSet"]["item"] !== undefined) {
        const wrappedItem = output["securityGroupReferenceSet"]["item"] instanceof Array
            ? output["securityGroupReferenceSet"]["item"]
            : [output["securityGroupReferenceSet"]["item"]];
        contents.SecurityGroupReferenceSet = deserializeAws_ec2SecurityGroupReferences(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2DescribeSecurityGroupsResult = (output, context) => {
    let contents = {
        __type: "DescribeSecurityGroupsResult",
        NextToken: undefined,
        SecurityGroups: undefined
    };
    if (output["nextToken"] !== undefined) {
        contents.NextToken = output["nextToken"];
    }
    if (output.securityGroupInfo === "") {
        contents.SecurityGroups = [];
    }
    if (output["securityGroupInfo"] !== undefined &&
        output["securityGroupInfo"]["item"] !== undefined) {
        const wrappedItem = output["securityGroupInfo"]["item"] instanceof Array
            ? output["securityGroupInfo"]["item"]
            : [output["securityGroupInfo"]["item"]];
        contents.SecurityGroups = deserializeAws_ec2SecurityGroupList(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2DescribeSnapshotAttributeResult = (output, context) => {
    let contents = {
        __type: "DescribeSnapshotAttributeResult",
        CreateVolumePermissions: undefined,
        ProductCodes: undefined,
        SnapshotId: undefined
    };
    if (output.createVolumePermission === "") {
        contents.CreateVolumePermissions = [];
    }
    if (output["createVolumePermission"] !== undefined &&
        output["createVolumePermission"]["item"] !== undefined) {
        const wrappedItem = output["createVolumePermission"]["item"] instanceof Array
            ? output["createVolumePermission"]["item"]
            : [output["createVolumePermission"]["item"]];
        contents.CreateVolumePermissions = deserializeAws_ec2CreateVolumePermissionList(wrappedItem, context);
    }
    if (output.productCodes === "") {
        contents.ProductCodes = [];
    }
    if (output["productCodes"] !== undefined &&
        output["productCodes"]["item"] !== undefined) {
        const wrappedItem = output["productCodes"]["item"] instanceof Array
            ? output["productCodes"]["item"]
            : [output["productCodes"]["item"]];
        contents.ProductCodes = deserializeAws_ec2ProductCodeList(wrappedItem, context);
    }
    if (output["snapshotId"] !== undefined) {
        contents.SnapshotId = output["snapshotId"];
    }
    return contents;
};
const deserializeAws_ec2DescribeSnapshotsResult = (output, context) => {
    let contents = {
        __type: "DescribeSnapshotsResult",
        NextToken: undefined,
        Snapshots: undefined
    };
    if (output["nextToken"] !== undefined) {
        contents.NextToken = output["nextToken"];
    }
    if (output.snapshotSet === "") {
        contents.Snapshots = [];
    }
    if (output["snapshotSet"] !== undefined &&
        output["snapshotSet"]["item"] !== undefined) {
        const wrappedItem = output["snapshotSet"]["item"] instanceof Array
            ? output["snapshotSet"]["item"]
            : [output["snapshotSet"]["item"]];
        contents.Snapshots = deserializeAws_ec2SnapshotList(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2DescribeSpotDatafeedSubscriptionResult = (output, context) => {
    let contents = {
        __type: "DescribeSpotDatafeedSubscriptionResult",
        SpotDatafeedSubscription: undefined
    };
    if (output["spotDatafeedSubscription"] !== undefined) {
        contents.SpotDatafeedSubscription = deserializeAws_ec2SpotDatafeedSubscription(output["spotDatafeedSubscription"], context);
    }
    return contents;
};
const deserializeAws_ec2DescribeSpotFleetInstancesResponse = (output, context) => {
    let contents = {
        __type: "DescribeSpotFleetInstancesResponse",
        ActiveInstances: undefined,
        NextToken: undefined,
        SpotFleetRequestId: undefined
    };
    if (output.activeInstanceSet === "") {
        contents.ActiveInstances = [];
    }
    if (output["activeInstanceSet"] !== undefined &&
        output["activeInstanceSet"]["item"] !== undefined) {
        const wrappedItem = output["activeInstanceSet"]["item"] instanceof Array
            ? output["activeInstanceSet"]["item"]
            : [output["activeInstanceSet"]["item"]];
        contents.ActiveInstances = deserializeAws_ec2ActiveInstanceSet(wrappedItem, context);
    }
    if (output["nextToken"] !== undefined) {
        contents.NextToken = output["nextToken"];
    }
    if (output["spotFleetRequestId"] !== undefined) {
        contents.SpotFleetRequestId = output["spotFleetRequestId"];
    }
    return contents;
};
const deserializeAws_ec2DescribeSpotFleetRequestHistoryResponse = (output, context) => {
    let contents = {
        __type: "DescribeSpotFleetRequestHistoryResponse",
        HistoryRecords: undefined,
        LastEvaluatedTime: undefined,
        NextToken: undefined,
        SpotFleetRequestId: undefined,
        StartTime: undefined
    };
    if (output.historyRecordSet === "") {
        contents.HistoryRecords = [];
    }
    if (output["historyRecordSet"] !== undefined &&
        output["historyRecordSet"]["item"] !== undefined) {
        const wrappedItem = output["historyRecordSet"]["item"] instanceof Array
            ? output["historyRecordSet"]["item"]
            : [output["historyRecordSet"]["item"]];
        contents.HistoryRecords = deserializeAws_ec2HistoryRecords(wrappedItem, context);
    }
    if (output["lastEvaluatedTime"] !== undefined) {
        contents.LastEvaluatedTime = new Date(output["lastEvaluatedTime"]);
    }
    if (output["nextToken"] !== undefined) {
        contents.NextToken = output["nextToken"];
    }
    if (output["spotFleetRequestId"] !== undefined) {
        contents.SpotFleetRequestId = output["spotFleetRequestId"];
    }
    if (output["startTime"] !== undefined) {
        contents.StartTime = new Date(output["startTime"]);
    }
    return contents;
};
const deserializeAws_ec2DescribeSpotFleetRequestsResponse = (output, context) => {
    let contents = {
        __type: "DescribeSpotFleetRequestsResponse",
        NextToken: undefined,
        SpotFleetRequestConfigs: undefined
    };
    if (output["nextToken"] !== undefined) {
        contents.NextToken = output["nextToken"];
    }
    if (output.spotFleetRequestConfigSet === "") {
        contents.SpotFleetRequestConfigs = [];
    }
    if (output["spotFleetRequestConfigSet"] !== undefined &&
        output["spotFleetRequestConfigSet"]["item"] !== undefined) {
        const wrappedItem = output["spotFleetRequestConfigSet"]["item"] instanceof Array
            ? output["spotFleetRequestConfigSet"]["item"]
            : [output["spotFleetRequestConfigSet"]["item"]];
        contents.SpotFleetRequestConfigs = deserializeAws_ec2SpotFleetRequestConfigSet(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2DescribeSpotInstanceRequestsResult = (output, context) => {
    let contents = {
        __type: "DescribeSpotInstanceRequestsResult",
        NextToken: undefined,
        SpotInstanceRequests: undefined
    };
    if (output["nextToken"] !== undefined) {
        contents.NextToken = output["nextToken"];
    }
    if (output.spotInstanceRequestSet === "") {
        contents.SpotInstanceRequests = [];
    }
    if (output["spotInstanceRequestSet"] !== undefined &&
        output["spotInstanceRequestSet"]["item"] !== undefined) {
        const wrappedItem = output["spotInstanceRequestSet"]["item"] instanceof Array
            ? output["spotInstanceRequestSet"]["item"]
            : [output["spotInstanceRequestSet"]["item"]];
        contents.SpotInstanceRequests = deserializeAws_ec2SpotInstanceRequestList(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2DescribeSpotPriceHistoryResult = (output, context) => {
    let contents = {
        __type: "DescribeSpotPriceHistoryResult",
        NextToken: undefined,
        SpotPriceHistory: undefined
    };
    if (output["nextToken"] !== undefined) {
        contents.NextToken = output["nextToken"];
    }
    if (output.spotPriceHistorySet === "") {
        contents.SpotPriceHistory = [];
    }
    if (output["spotPriceHistorySet"] !== undefined &&
        output["spotPriceHistorySet"]["item"] !== undefined) {
        const wrappedItem = output["spotPriceHistorySet"]["item"] instanceof Array
            ? output["spotPriceHistorySet"]["item"]
            : [output["spotPriceHistorySet"]["item"]];
        contents.SpotPriceHistory = deserializeAws_ec2SpotPriceHistoryList(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2DescribeStaleSecurityGroupsResult = (output, context) => {
    let contents = {
        __type: "DescribeStaleSecurityGroupsResult",
        NextToken: undefined,
        StaleSecurityGroupSet: undefined
    };
    if (output["nextToken"] !== undefined) {
        contents.NextToken = output["nextToken"];
    }
    if (output.staleSecurityGroupSet === "") {
        contents.StaleSecurityGroupSet = [];
    }
    if (output["staleSecurityGroupSet"] !== undefined &&
        output["staleSecurityGroupSet"]["item"] !== undefined) {
        const wrappedItem = output["staleSecurityGroupSet"]["item"] instanceof Array
            ? output["staleSecurityGroupSet"]["item"]
            : [output["staleSecurityGroupSet"]["item"]];
        contents.StaleSecurityGroupSet = deserializeAws_ec2StaleSecurityGroupSet(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2DescribeSubnetsResult = (output, context) => {
    let contents = {
        __type: "DescribeSubnetsResult",
        NextToken: undefined,
        Subnets: undefined
    };
    if (output["nextToken"] !== undefined) {
        contents.NextToken = output["nextToken"];
    }
    if (output.subnetSet === "") {
        contents.Subnets = [];
    }
    if (output["subnetSet"] !== undefined &&
        output["subnetSet"]["item"] !== undefined) {
        const wrappedItem = output["subnetSet"]["item"] instanceof Array
            ? output["subnetSet"]["item"]
            : [output["subnetSet"]["item"]];
        contents.Subnets = deserializeAws_ec2SubnetList(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2DescribeTagsResult = (output, context) => {
    let contents = {
        __type: "DescribeTagsResult",
        NextToken: undefined,
        Tags: undefined
    };
    if (output["nextToken"] !== undefined) {
        contents.NextToken = output["nextToken"];
    }
    if (output.tagSet === "") {
        contents.Tags = [];
    }
    if (output["tagSet"] !== undefined &&
        output["tagSet"]["item"] !== undefined) {
        const wrappedItem = output["tagSet"]["item"] instanceof Array
            ? output["tagSet"]["item"]
            : [output["tagSet"]["item"]];
        contents.Tags = deserializeAws_ec2TagDescriptionList(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2DescribeTrafficMirrorFiltersResult = (output, context) => {
    let contents = {
        __type: "DescribeTrafficMirrorFiltersResult",
        NextToken: undefined,
        TrafficMirrorFilters: undefined
    };
    if (output["nextToken"] !== undefined) {
        contents.NextToken = output["nextToken"];
    }
    if (output.trafficMirrorFilterSet === "") {
        contents.TrafficMirrorFilters = [];
    }
    if (output["trafficMirrorFilterSet"] !== undefined &&
        output["trafficMirrorFilterSet"]["item"] !== undefined) {
        const wrappedItem = output["trafficMirrorFilterSet"]["item"] instanceof Array
            ? output["trafficMirrorFilterSet"]["item"]
            : [output["trafficMirrorFilterSet"]["item"]];
        contents.TrafficMirrorFilters = deserializeAws_ec2TrafficMirrorFilterSet(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2DescribeTrafficMirrorSessionsResult = (output, context) => {
    let contents = {
        __type: "DescribeTrafficMirrorSessionsResult",
        NextToken: undefined,
        TrafficMirrorSessions: undefined
    };
    if (output["nextToken"] !== undefined) {
        contents.NextToken = output["nextToken"];
    }
    if (output.trafficMirrorSessionSet === "") {
        contents.TrafficMirrorSessions = [];
    }
    if (output["trafficMirrorSessionSet"] !== undefined &&
        output["trafficMirrorSessionSet"]["item"] !== undefined) {
        const wrappedItem = output["trafficMirrorSessionSet"]["item"] instanceof Array
            ? output["trafficMirrorSessionSet"]["item"]
            : [output["trafficMirrorSessionSet"]["item"]];
        contents.TrafficMirrorSessions = deserializeAws_ec2TrafficMirrorSessionSet(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2DescribeTrafficMirrorTargetsResult = (output, context) => {
    let contents = {
        __type: "DescribeTrafficMirrorTargetsResult",
        NextToken: undefined,
        TrafficMirrorTargets: undefined
    };
    if (output["nextToken"] !== undefined) {
        contents.NextToken = output["nextToken"];
    }
    if (output.trafficMirrorTargetSet === "") {
        contents.TrafficMirrorTargets = [];
    }
    if (output["trafficMirrorTargetSet"] !== undefined &&
        output["trafficMirrorTargetSet"]["item"] !== undefined) {
        const wrappedItem = output["trafficMirrorTargetSet"]["item"] instanceof Array
            ? output["trafficMirrorTargetSet"]["item"]
            : [output["trafficMirrorTargetSet"]["item"]];
        contents.TrafficMirrorTargets = deserializeAws_ec2TrafficMirrorTargetSet(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2DescribeTransitGatewayAttachmentsResult = (output, context) => {
    let contents = {
        __type: "DescribeTransitGatewayAttachmentsResult",
        NextToken: undefined,
        TransitGatewayAttachments: undefined
    };
    if (output["nextToken"] !== undefined) {
        contents.NextToken = output["nextToken"];
    }
    if (output.transitGatewayAttachments === "") {
        contents.TransitGatewayAttachments = [];
    }
    if (output["transitGatewayAttachments"] !== undefined &&
        output["transitGatewayAttachments"]["item"] !== undefined) {
        const wrappedItem = output["transitGatewayAttachments"]["item"] instanceof Array
            ? output["transitGatewayAttachments"]["item"]
            : [output["transitGatewayAttachments"]["item"]];
        contents.TransitGatewayAttachments = deserializeAws_ec2TransitGatewayAttachmentList(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2DescribeTransitGatewayMulticastDomainsResult = (output, context) => {
    let contents = {
        __type: "DescribeTransitGatewayMulticastDomainsResult",
        NextToken: undefined,
        TransitGatewayMulticastDomains: undefined
    };
    if (output["nextToken"] !== undefined) {
        contents.NextToken = output["nextToken"];
    }
    if (output.transitGatewayMulticastDomains === "") {
        contents.TransitGatewayMulticastDomains = [];
    }
    if (output["transitGatewayMulticastDomains"] !== undefined &&
        output["transitGatewayMulticastDomains"]["item"] !== undefined) {
        const wrappedItem = output["transitGatewayMulticastDomains"]["item"] instanceof Array
            ? output["transitGatewayMulticastDomains"]["item"]
            : [output["transitGatewayMulticastDomains"]["item"]];
        contents.TransitGatewayMulticastDomains = deserializeAws_ec2TransitGatewayMulticastDomainList(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2DescribeTransitGatewayPeeringAttachmentsResult = (output, context) => {
    let contents = {
        __type: "DescribeTransitGatewayPeeringAttachmentsResult",
        NextToken: undefined,
        TransitGatewayPeeringAttachments: undefined
    };
    if (output["nextToken"] !== undefined) {
        contents.NextToken = output["nextToken"];
    }
    if (output.transitGatewayPeeringAttachments === "") {
        contents.TransitGatewayPeeringAttachments = [];
    }
    if (output["transitGatewayPeeringAttachments"] !== undefined &&
        output["transitGatewayPeeringAttachments"]["item"] !== undefined) {
        const wrappedItem = output["transitGatewayPeeringAttachments"]["item"] instanceof Array
            ? output["transitGatewayPeeringAttachments"]["item"]
            : [output["transitGatewayPeeringAttachments"]["item"]];
        contents.TransitGatewayPeeringAttachments = deserializeAws_ec2TransitGatewayPeeringAttachmentList(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2DescribeTransitGatewayRouteTablesResult = (output, context) => {
    let contents = {
        __type: "DescribeTransitGatewayRouteTablesResult",
        NextToken: undefined,
        TransitGatewayRouteTables: undefined
    };
    if (output["nextToken"] !== undefined) {
        contents.NextToken = output["nextToken"];
    }
    if (output.transitGatewayRouteTables === "") {
        contents.TransitGatewayRouteTables = [];
    }
    if (output["transitGatewayRouteTables"] !== undefined &&
        output["transitGatewayRouteTables"]["item"] !== undefined) {
        const wrappedItem = output["transitGatewayRouteTables"]["item"] instanceof Array
            ? output["transitGatewayRouteTables"]["item"]
            : [output["transitGatewayRouteTables"]["item"]];
        contents.TransitGatewayRouteTables = deserializeAws_ec2TransitGatewayRouteTableList(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2DescribeTransitGatewayVpcAttachmentsResult = (output, context) => {
    let contents = {
        __type: "DescribeTransitGatewayVpcAttachmentsResult",
        NextToken: undefined,
        TransitGatewayVpcAttachments: undefined
    };
    if (output["nextToken"] !== undefined) {
        contents.NextToken = output["nextToken"];
    }
    if (output.transitGatewayVpcAttachments === "") {
        contents.TransitGatewayVpcAttachments = [];
    }
    if (output["transitGatewayVpcAttachments"] !== undefined &&
        output["transitGatewayVpcAttachments"]["item"] !== undefined) {
        const wrappedItem = output["transitGatewayVpcAttachments"]["item"] instanceof Array
            ? output["transitGatewayVpcAttachments"]["item"]
            : [output["transitGatewayVpcAttachments"]["item"]];
        contents.TransitGatewayVpcAttachments = deserializeAws_ec2TransitGatewayVpcAttachmentList(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2DescribeTransitGatewaysResult = (output, context) => {
    let contents = {
        __type: "DescribeTransitGatewaysResult",
        NextToken: undefined,
        TransitGateways: undefined
    };
    if (output["nextToken"] !== undefined) {
        contents.NextToken = output["nextToken"];
    }
    if (output.transitGatewaySet === "") {
        contents.TransitGateways = [];
    }
    if (output["transitGatewaySet"] !== undefined &&
        output["transitGatewaySet"]["item"] !== undefined) {
        const wrappedItem = output["transitGatewaySet"]["item"] instanceof Array
            ? output["transitGatewaySet"]["item"]
            : [output["transitGatewaySet"]["item"]];
        contents.TransitGateways = deserializeAws_ec2TransitGatewayList(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2DescribeVolumeAttributeResult = (output, context) => {
    let contents = {
        __type: "DescribeVolumeAttributeResult",
        AutoEnableIO: undefined,
        ProductCodes: undefined,
        VolumeId: undefined
    };
    if (output["autoEnableIO"] !== undefined) {
        contents.AutoEnableIO = deserializeAws_ec2AttributeBooleanValue(output["autoEnableIO"], context);
    }
    if (output.productCodes === "") {
        contents.ProductCodes = [];
    }
    if (output["productCodes"] !== undefined &&
        output["productCodes"]["item"] !== undefined) {
        const wrappedItem = output["productCodes"]["item"] instanceof Array
            ? output["productCodes"]["item"]
            : [output["productCodes"]["item"]];
        contents.ProductCodes = deserializeAws_ec2ProductCodeList(wrappedItem, context);
    }
    if (output["volumeId"] !== undefined) {
        contents.VolumeId = output["volumeId"];
    }
    return contents;
};
const deserializeAws_ec2DescribeVolumeStatusResult = (output, context) => {
    let contents = {
        __type: "DescribeVolumeStatusResult",
        NextToken: undefined,
        VolumeStatuses: undefined
    };
    if (output["nextToken"] !== undefined) {
        contents.NextToken = output["nextToken"];
    }
    if (output.volumeStatusSet === "") {
        contents.VolumeStatuses = [];
    }
    if (output["volumeStatusSet"] !== undefined &&
        output["volumeStatusSet"]["item"] !== undefined) {
        const wrappedItem = output["volumeStatusSet"]["item"] instanceof Array
            ? output["volumeStatusSet"]["item"]
            : [output["volumeStatusSet"]["item"]];
        contents.VolumeStatuses = deserializeAws_ec2VolumeStatusList(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2DescribeVolumesModificationsResult = (output, context) => {
    let contents = {
        __type: "DescribeVolumesModificationsResult",
        NextToken: undefined,
        VolumesModifications: undefined
    };
    if (output["nextToken"] !== undefined) {
        contents.NextToken = output["nextToken"];
    }
    if (output.volumeModificationSet === "") {
        contents.VolumesModifications = [];
    }
    if (output["volumeModificationSet"] !== undefined &&
        output["volumeModificationSet"]["item"] !== undefined) {
        const wrappedItem = output["volumeModificationSet"]["item"] instanceof Array
            ? output["volumeModificationSet"]["item"]
            : [output["volumeModificationSet"]["item"]];
        contents.VolumesModifications = deserializeAws_ec2VolumeModificationList(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2DescribeVolumesResult = (output, context) => {
    let contents = {
        __type: "DescribeVolumesResult",
        NextToken: undefined,
        Volumes: undefined
    };
    if (output["nextToken"] !== undefined) {
        contents.NextToken = output["nextToken"];
    }
    if (output.volumeSet === "") {
        contents.Volumes = [];
    }
    if (output["volumeSet"] !== undefined &&
        output["volumeSet"]["item"] !== undefined) {
        const wrappedItem = output["volumeSet"]["item"] instanceof Array
            ? output["volumeSet"]["item"]
            : [output["volumeSet"]["item"]];
        contents.Volumes = deserializeAws_ec2VolumeList(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2DescribeVpcAttributeResult = (output, context) => {
    let contents = {
        __type: "DescribeVpcAttributeResult",
        EnableDnsHostnames: undefined,
        EnableDnsSupport: undefined,
        VpcId: undefined
    };
    if (output["enableDnsHostnames"] !== undefined) {
        contents.EnableDnsHostnames = deserializeAws_ec2AttributeBooleanValue(output["enableDnsHostnames"], context);
    }
    if (output["enableDnsSupport"] !== undefined) {
        contents.EnableDnsSupport = deserializeAws_ec2AttributeBooleanValue(output["enableDnsSupport"], context);
    }
    if (output["vpcId"] !== undefined) {
        contents.VpcId = output["vpcId"];
    }
    return contents;
};
const deserializeAws_ec2DescribeVpcClassicLinkDnsSupportResult = (output, context) => {
    let contents = {
        __type: "DescribeVpcClassicLinkDnsSupportResult",
        NextToken: undefined,
        Vpcs: undefined
    };
    if (output["nextToken"] !== undefined) {
        contents.NextToken = output["nextToken"];
    }
    if (output.vpcs === "") {
        contents.Vpcs = [];
    }
    if (output["vpcs"] !== undefined && output["vpcs"]["item"] !== undefined) {
        const wrappedItem = output["vpcs"]["item"] instanceof Array
            ? output["vpcs"]["item"]
            : [output["vpcs"]["item"]];
        contents.Vpcs = deserializeAws_ec2ClassicLinkDnsSupportList(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2DescribeVpcClassicLinkResult = (output, context) => {
    let contents = {
        __type: "DescribeVpcClassicLinkResult",
        Vpcs: undefined
    };
    if (output.vpcSet === "") {
        contents.Vpcs = [];
    }
    if (output["vpcSet"] !== undefined &&
        output["vpcSet"]["item"] !== undefined) {
        const wrappedItem = output["vpcSet"]["item"] instanceof Array
            ? output["vpcSet"]["item"]
            : [output["vpcSet"]["item"]];
        contents.Vpcs = deserializeAws_ec2VpcClassicLinkList(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2DescribeVpcEndpointConnectionNotificationsResult = (output, context) => {
    let contents = {
        __type: "DescribeVpcEndpointConnectionNotificationsResult",
        ConnectionNotificationSet: undefined,
        NextToken: undefined
    };
    if (output.connectionNotificationSet === "") {
        contents.ConnectionNotificationSet = [];
    }
    if (output["connectionNotificationSet"] !== undefined &&
        output["connectionNotificationSet"]["item"] !== undefined) {
        const wrappedItem = output["connectionNotificationSet"]["item"] instanceof Array
            ? output["connectionNotificationSet"]["item"]
            : [output["connectionNotificationSet"]["item"]];
        contents.ConnectionNotificationSet = deserializeAws_ec2ConnectionNotificationSet(wrappedItem, context);
    }
    if (output["nextToken"] !== undefined) {
        contents.NextToken = output["nextToken"];
    }
    return contents;
};
const deserializeAws_ec2DescribeVpcEndpointConnectionsResult = (output, context) => {
    let contents = {
        __type: "DescribeVpcEndpointConnectionsResult",
        NextToken: undefined,
        VpcEndpointConnections: undefined
    };
    if (output["nextToken"] !== undefined) {
        contents.NextToken = output["nextToken"];
    }
    if (output.vpcEndpointConnectionSet === "") {
        contents.VpcEndpointConnections = [];
    }
    if (output["vpcEndpointConnectionSet"] !== undefined &&
        output["vpcEndpointConnectionSet"]["item"] !== undefined) {
        const wrappedItem = output["vpcEndpointConnectionSet"]["item"] instanceof Array
            ? output["vpcEndpointConnectionSet"]["item"]
            : [output["vpcEndpointConnectionSet"]["item"]];
        contents.VpcEndpointConnections = deserializeAws_ec2VpcEndpointConnectionSet(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2DescribeVpcEndpointServiceConfigurationsResult = (output, context) => {
    let contents = {
        __type: "DescribeVpcEndpointServiceConfigurationsResult",
        NextToken: undefined,
        ServiceConfigurations: undefined
    };
    if (output["nextToken"] !== undefined) {
        contents.NextToken = output["nextToken"];
    }
    if (output.serviceConfigurationSet === "") {
        contents.ServiceConfigurations = [];
    }
    if (output["serviceConfigurationSet"] !== undefined &&
        output["serviceConfigurationSet"]["item"] !== undefined) {
        const wrappedItem = output["serviceConfigurationSet"]["item"] instanceof Array
            ? output["serviceConfigurationSet"]["item"]
            : [output["serviceConfigurationSet"]["item"]];
        contents.ServiceConfigurations = deserializeAws_ec2ServiceConfigurationSet(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2DescribeVpcEndpointServicePermissionsResult = (output, context) => {
    let contents = {
        __type: "DescribeVpcEndpointServicePermissionsResult",
        AllowedPrincipals: undefined,
        NextToken: undefined
    };
    if (output.allowedPrincipals === "") {
        contents.AllowedPrincipals = [];
    }
    if (output["allowedPrincipals"] !== undefined &&
        output["allowedPrincipals"]["item"] !== undefined) {
        const wrappedItem = output["allowedPrincipals"]["item"] instanceof Array
            ? output["allowedPrincipals"]["item"]
            : [output["allowedPrincipals"]["item"]];
        contents.AllowedPrincipals = deserializeAws_ec2AllowedPrincipalSet(wrappedItem, context);
    }
    if (output["nextToken"] !== undefined) {
        contents.NextToken = output["nextToken"];
    }
    return contents;
};
const deserializeAws_ec2DescribeVpcEndpointServicesResult = (output, context) => {
    let contents = {
        __type: "DescribeVpcEndpointServicesResult",
        NextToken: undefined,
        ServiceDetails: undefined,
        ServiceNames: undefined
    };
    if (output["nextToken"] !== undefined) {
        contents.NextToken = output["nextToken"];
    }
    if (output.serviceDetailSet === "") {
        contents.ServiceDetails = [];
    }
    if (output["serviceDetailSet"] !== undefined &&
        output["serviceDetailSet"]["item"] !== undefined) {
        const wrappedItem = output["serviceDetailSet"]["item"] instanceof Array
            ? output["serviceDetailSet"]["item"]
            : [output["serviceDetailSet"]["item"]];
        contents.ServiceDetails = deserializeAws_ec2ServiceDetailSet(wrappedItem, context);
    }
    if (output.serviceNameSet === "") {
        contents.ServiceNames = [];
    }
    if (output["serviceNameSet"] !== undefined &&
        output["serviceNameSet"]["item"] !== undefined) {
        const wrappedItem = output["serviceNameSet"]["item"] instanceof Array
            ? output["serviceNameSet"]["item"]
            : [output["serviceNameSet"]["item"]];
        contents.ServiceNames = deserializeAws_ec2ValueStringList(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2DescribeVpcEndpointsResult = (output, context) => {
    let contents = {
        __type: "DescribeVpcEndpointsResult",
        NextToken: undefined,
        VpcEndpoints: undefined
    };
    if (output["nextToken"] !== undefined) {
        contents.NextToken = output["nextToken"];
    }
    if (output.vpcEndpointSet === "") {
        contents.VpcEndpoints = [];
    }
    if (output["vpcEndpointSet"] !== undefined &&
        output["vpcEndpointSet"]["item"] !== undefined) {
        const wrappedItem = output["vpcEndpointSet"]["item"] instanceof Array
            ? output["vpcEndpointSet"]["item"]
            : [output["vpcEndpointSet"]["item"]];
        contents.VpcEndpoints = deserializeAws_ec2VpcEndpointSet(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2DescribeVpcPeeringConnectionsResult = (output, context) => {
    let contents = {
        __type: "DescribeVpcPeeringConnectionsResult",
        NextToken: undefined,
        VpcPeeringConnections: undefined
    };
    if (output["nextToken"] !== undefined) {
        contents.NextToken = output["nextToken"];
    }
    if (output.vpcPeeringConnectionSet === "") {
        contents.VpcPeeringConnections = [];
    }
    if (output["vpcPeeringConnectionSet"] !== undefined &&
        output["vpcPeeringConnectionSet"]["item"] !== undefined) {
        const wrappedItem = output["vpcPeeringConnectionSet"]["item"] instanceof Array
            ? output["vpcPeeringConnectionSet"]["item"]
            : [output["vpcPeeringConnectionSet"]["item"]];
        contents.VpcPeeringConnections = deserializeAws_ec2VpcPeeringConnectionList(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2DescribeVpcsResult = (output, context) => {
    let contents = {
        __type: "DescribeVpcsResult",
        NextToken: undefined,
        Vpcs: undefined
    };
    if (output["nextToken"] !== undefined) {
        contents.NextToken = output["nextToken"];
    }
    if (output.vpcSet === "") {
        contents.Vpcs = [];
    }
    if (output["vpcSet"] !== undefined &&
        output["vpcSet"]["item"] !== undefined) {
        const wrappedItem = output["vpcSet"]["item"] instanceof Array
            ? output["vpcSet"]["item"]
            : [output["vpcSet"]["item"]];
        contents.Vpcs = deserializeAws_ec2VpcList(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2DescribeVpnConnectionsResult = (output, context) => {
    let contents = {
        __type: "DescribeVpnConnectionsResult",
        VpnConnections: undefined
    };
    if (output.vpnConnectionSet === "") {
        contents.VpnConnections = [];
    }
    if (output["vpnConnectionSet"] !== undefined &&
        output["vpnConnectionSet"]["item"] !== undefined) {
        const wrappedItem = output["vpnConnectionSet"]["item"] instanceof Array
            ? output["vpnConnectionSet"]["item"]
            : [output["vpnConnectionSet"]["item"]];
        contents.VpnConnections = deserializeAws_ec2VpnConnectionList(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2DescribeVpnGatewaysResult = (output, context) => {
    let contents = {
        __type: "DescribeVpnGatewaysResult",
        VpnGateways: undefined
    };
    if (output.vpnGatewaySet === "") {
        contents.VpnGateways = [];
    }
    if (output["vpnGatewaySet"] !== undefined &&
        output["vpnGatewaySet"]["item"] !== undefined) {
        const wrappedItem = output["vpnGatewaySet"]["item"] instanceof Array
            ? output["vpnGatewaySet"]["item"]
            : [output["vpnGatewaySet"]["item"]];
        contents.VpnGateways = deserializeAws_ec2VpnGatewayList(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2DetachClassicLinkVpcResult = (output, context) => {
    let contents = {
        __type: "DetachClassicLinkVpcResult",
        Return: undefined
    };
    if (output["return"] !== undefined) {
        contents.Return = output["return"] == "true";
    }
    return contents;
};
const deserializeAws_ec2DhcpConfiguration = (output, context) => {
    let contents = {
        __type: "DhcpConfiguration",
        Key: undefined,
        Values: undefined
    };
    if (output["key"] !== undefined) {
        contents.Key = output["key"];
    }
    if (output.valueSet === "") {
        contents.Values = [];
    }
    if (output["valueSet"] !== undefined &&
        output["valueSet"]["item"] !== undefined) {
        const wrappedItem = output["valueSet"]["item"] instanceof Array
            ? output["valueSet"]["item"]
            : [output["valueSet"]["item"]];
        contents.Values = deserializeAws_ec2DhcpConfigurationValueList(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2DhcpConfigurationList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2DhcpConfiguration(entry, context));
    });
    return contents;
};
const deserializeAws_ec2DhcpConfigurationValueList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2AttributeValue(entry, context));
    });
    return contents;
};
const deserializeAws_ec2DhcpOptions = (output, context) => {
    let contents = {
        __type: "DhcpOptions",
        DhcpConfigurations: undefined,
        DhcpOptionsId: undefined,
        OwnerId: undefined,
        Tags: undefined
    };
    if (output.dhcpConfigurationSet === "") {
        contents.DhcpConfigurations = [];
    }
    if (output["dhcpConfigurationSet"] !== undefined &&
        output["dhcpConfigurationSet"]["item"] !== undefined) {
        const wrappedItem = output["dhcpConfigurationSet"]["item"] instanceof Array
            ? output["dhcpConfigurationSet"]["item"]
            : [output["dhcpConfigurationSet"]["item"]];
        contents.DhcpConfigurations = deserializeAws_ec2DhcpConfigurationList(wrappedItem, context);
    }
    if (output["dhcpOptionsId"] !== undefined) {
        contents.DhcpOptionsId = output["dhcpOptionsId"];
    }
    if (output["ownerId"] !== undefined) {
        contents.OwnerId = output["ownerId"];
    }
    if (output.tagSet === "") {
        contents.Tags = [];
    }
    if (output["tagSet"] !== undefined &&
        output["tagSet"]["item"] !== undefined) {
        const wrappedItem = output["tagSet"]["item"] instanceof Array
            ? output["tagSet"]["item"]
            : [output["tagSet"]["item"]];
        contents.Tags = deserializeAws_ec2TagList(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2DhcpOptionsList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2DhcpOptions(entry, context));
    });
    return contents;
};
const deserializeAws_ec2DirectoryServiceAuthentication = (output, context) => {
    let contents = {
        __type: "DirectoryServiceAuthentication",
        DirectoryId: undefined
    };
    if (output["directoryId"] !== undefined) {
        contents.DirectoryId = output["directoryId"];
    }
    return contents;
};
const deserializeAws_ec2DisableEbsEncryptionByDefaultResult = (output, context) => {
    let contents = {
        __type: "DisableEbsEncryptionByDefaultResult",
        EbsEncryptionByDefault: undefined
    };
    if (output["ebsEncryptionByDefault"] !== undefined) {
        contents.EbsEncryptionByDefault =
            output["ebsEncryptionByDefault"] == "true";
    }
    return contents;
};
const deserializeAws_ec2DisableFastSnapshotRestoreErrorItem = (output, context) => {
    let contents = {
        __type: "DisableFastSnapshotRestoreErrorItem",
        FastSnapshotRestoreStateErrors: undefined,
        SnapshotId: undefined
    };
    if (output.fastSnapshotRestoreStateErrorSet === "") {
        contents.FastSnapshotRestoreStateErrors = [];
    }
    if (output["fastSnapshotRestoreStateErrorSet"] !== undefined &&
        output["fastSnapshotRestoreStateErrorSet"]["item"] !== undefined) {
        const wrappedItem = output["fastSnapshotRestoreStateErrorSet"]["item"] instanceof Array
            ? output["fastSnapshotRestoreStateErrorSet"]["item"]
            : [output["fastSnapshotRestoreStateErrorSet"]["item"]];
        contents.FastSnapshotRestoreStateErrors = deserializeAws_ec2DisableFastSnapshotRestoreStateErrorSet(wrappedItem, context);
    }
    if (output["snapshotId"] !== undefined) {
        contents.SnapshotId = output["snapshotId"];
    }
    return contents;
};
const deserializeAws_ec2DisableFastSnapshotRestoreErrorSet = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2DisableFastSnapshotRestoreErrorItem(entry, context));
    });
    return contents;
};
const deserializeAws_ec2DisableFastSnapshotRestoreStateError = (output, context) => {
    let contents = {
        __type: "DisableFastSnapshotRestoreStateError",
        Code: undefined,
        Message: undefined
    };
    if (output["code"] !== undefined) {
        contents.Code = output["code"];
    }
    if (output["message"] !== undefined) {
        contents.Message = output["message"];
    }
    return contents;
};
const deserializeAws_ec2DisableFastSnapshotRestoreStateErrorItem = (output, context) => {
    let contents = {
        __type: "DisableFastSnapshotRestoreStateErrorItem",
        AvailabilityZone: undefined,
        Error: undefined
    };
    if (output["availabilityZone"] !== undefined) {
        contents.AvailabilityZone = output["availabilityZone"];
    }
    if (output["error"] !== undefined) {
        contents.Error = deserializeAws_ec2DisableFastSnapshotRestoreStateError(output["error"], context);
    }
    return contents;
};
const deserializeAws_ec2DisableFastSnapshotRestoreStateErrorSet = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2DisableFastSnapshotRestoreStateErrorItem(entry, context));
    });
    return contents;
};
const deserializeAws_ec2DisableFastSnapshotRestoreSuccessItem = (output, context) => {
    let contents = {
        __type: "DisableFastSnapshotRestoreSuccessItem",
        AvailabilityZone: undefined,
        DisabledTime: undefined,
        DisablingTime: undefined,
        EnabledTime: undefined,
        EnablingTime: undefined,
        OptimizingTime: undefined,
        OwnerAlias: undefined,
        OwnerId: undefined,
        SnapshotId: undefined,
        State: undefined,
        StateTransitionReason: undefined
    };
    if (output["availabilityZone"] !== undefined) {
        contents.AvailabilityZone = output["availabilityZone"];
    }
    if (output["disabledTime"] !== undefined) {
        contents.DisabledTime = new Date(output["disabledTime"]);
    }
    if (output["disablingTime"] !== undefined) {
        contents.DisablingTime = new Date(output["disablingTime"]);
    }
    if (output["enabledTime"] !== undefined) {
        contents.EnabledTime = new Date(output["enabledTime"]);
    }
    if (output["enablingTime"] !== undefined) {
        contents.EnablingTime = new Date(output["enablingTime"]);
    }
    if (output["optimizingTime"] !== undefined) {
        contents.OptimizingTime = new Date(output["optimizingTime"]);
    }
    if (output["ownerAlias"] !== undefined) {
        contents.OwnerAlias = output["ownerAlias"];
    }
    if (output["ownerId"] !== undefined) {
        contents.OwnerId = output["ownerId"];
    }
    if (output["snapshotId"] !== undefined) {
        contents.SnapshotId = output["snapshotId"];
    }
    if (output["state"] !== undefined) {
        contents.State = output["state"];
    }
    if (output["stateTransitionReason"] !== undefined) {
        contents.StateTransitionReason = output["stateTransitionReason"];
    }
    return contents;
};
const deserializeAws_ec2DisableFastSnapshotRestoreSuccessSet = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2DisableFastSnapshotRestoreSuccessItem(entry, context));
    });
    return contents;
};
const deserializeAws_ec2DisableFastSnapshotRestoresResult = (output, context) => {
    let contents = {
        __type: "DisableFastSnapshotRestoresResult",
        Successful: undefined,
        Unsuccessful: undefined
    };
    if (output.successful === "") {
        contents.Successful = [];
    }
    if (output["successful"] !== undefined &&
        output["successful"]["item"] !== undefined) {
        const wrappedItem = output["successful"]["item"] instanceof Array
            ? output["successful"]["item"]
            : [output["successful"]["item"]];
        contents.Successful = deserializeAws_ec2DisableFastSnapshotRestoreSuccessSet(wrappedItem, context);
    }
    if (output.unsuccessful === "") {
        contents.Unsuccessful = [];
    }
    if (output["unsuccessful"] !== undefined &&
        output["unsuccessful"]["item"] !== undefined) {
        const wrappedItem = output["unsuccessful"]["item"] instanceof Array
            ? output["unsuccessful"]["item"]
            : [output["unsuccessful"]["item"]];
        contents.Unsuccessful = deserializeAws_ec2DisableFastSnapshotRestoreErrorSet(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2DisableTransitGatewayRouteTablePropagationResult = (output, context) => {
    let contents = {
        __type: "DisableTransitGatewayRouteTablePropagationResult",
        Propagation: undefined
    };
    if (output["propagation"] !== undefined) {
        contents.Propagation = deserializeAws_ec2TransitGatewayPropagation(output["propagation"], context);
    }
    return contents;
};
const deserializeAws_ec2DisableVpcClassicLinkDnsSupportResult = (output, context) => {
    let contents = {
        __type: "DisableVpcClassicLinkDnsSupportResult",
        Return: undefined
    };
    if (output["return"] !== undefined) {
        contents.Return = output["return"] == "true";
    }
    return contents;
};
const deserializeAws_ec2DisableVpcClassicLinkResult = (output, context) => {
    let contents = {
        __type: "DisableVpcClassicLinkResult",
        Return: undefined
    };
    if (output["return"] !== undefined) {
        contents.Return = output["return"] == "true";
    }
    return contents;
};
const deserializeAws_ec2DisassociateClientVpnTargetNetworkResult = (output, context) => {
    let contents = {
        __type: "DisassociateClientVpnTargetNetworkResult",
        AssociationId: undefined,
        Status: undefined
    };
    if (output["associationId"] !== undefined) {
        contents.AssociationId = output["associationId"];
    }
    if (output["status"] !== undefined) {
        contents.Status = deserializeAws_ec2AssociationStatus(output["status"], context);
    }
    return contents;
};
const deserializeAws_ec2DisassociateIamInstanceProfileResult = (output, context) => {
    let contents = {
        __type: "DisassociateIamInstanceProfileResult",
        IamInstanceProfileAssociation: undefined
    };
    if (output["iamInstanceProfileAssociation"] !== undefined) {
        contents.IamInstanceProfileAssociation = deserializeAws_ec2IamInstanceProfileAssociation(output["iamInstanceProfileAssociation"], context);
    }
    return contents;
};
const deserializeAws_ec2DisassociateSubnetCidrBlockResult = (output, context) => {
    let contents = {
        __type: "DisassociateSubnetCidrBlockResult",
        Ipv6CidrBlockAssociation: undefined,
        SubnetId: undefined
    };
    if (output["ipv6CidrBlockAssociation"] !== undefined) {
        contents.Ipv6CidrBlockAssociation = deserializeAws_ec2SubnetIpv6CidrBlockAssociation(output["ipv6CidrBlockAssociation"], context);
    }
    if (output["subnetId"] !== undefined) {
        contents.SubnetId = output["subnetId"];
    }
    return contents;
};
const deserializeAws_ec2DisassociateTransitGatewayMulticastDomainResult = (output, context) => {
    let contents = {
        __type: "DisassociateTransitGatewayMulticastDomainResult",
        Associations: undefined
    };
    if (output["associations"] !== undefined) {
        contents.Associations = deserializeAws_ec2TransitGatewayMulticastDomainAssociations(output["associations"], context);
    }
    return contents;
};
const deserializeAws_ec2DisassociateTransitGatewayRouteTableResult = (output, context) => {
    let contents = {
        __type: "DisassociateTransitGatewayRouteTableResult",
        Association: undefined
    };
    if (output["association"] !== undefined) {
        contents.Association = deserializeAws_ec2TransitGatewayAssociation(output["association"], context);
    }
    return contents;
};
const deserializeAws_ec2DisassociateVpcCidrBlockResult = (output, context) => {
    let contents = {
        __type: "DisassociateVpcCidrBlockResult",
        CidrBlockAssociation: undefined,
        Ipv6CidrBlockAssociation: undefined,
        VpcId: undefined
    };
    if (output["cidrBlockAssociation"] !== undefined) {
        contents.CidrBlockAssociation = deserializeAws_ec2VpcCidrBlockAssociation(output["cidrBlockAssociation"], context);
    }
    if (output["ipv6CidrBlockAssociation"] !== undefined) {
        contents.Ipv6CidrBlockAssociation = deserializeAws_ec2VpcIpv6CidrBlockAssociation(output["ipv6CidrBlockAssociation"], context);
    }
    if (output["vpcId"] !== undefined) {
        contents.VpcId = output["vpcId"];
    }
    return contents;
};
const deserializeAws_ec2DiskImageDescription = (output, context) => {
    let contents = {
        __type: "DiskImageDescription",
        Checksum: undefined,
        Format: undefined,
        ImportManifestUrl: undefined,
        Size: undefined
    };
    if (output["checksum"] !== undefined) {
        contents.Checksum = output["checksum"];
    }
    if (output["format"] !== undefined) {
        contents.Format = output["format"];
    }
    if (output["importManifestUrl"] !== undefined) {
        contents.ImportManifestUrl = output["importManifestUrl"];
    }
    if (output["size"] !== undefined) {
        contents.Size = parseInt(output["size"]);
    }
    return contents;
};
const deserializeAws_ec2DiskImageVolumeDescription = (output, context) => {
    let contents = {
        __type: "DiskImageVolumeDescription",
        Id: undefined,
        Size: undefined
    };
    if (output["id"] !== undefined) {
        contents.Id = output["id"];
    }
    if (output["size"] !== undefined) {
        contents.Size = parseInt(output["size"]);
    }
    return contents;
};
const deserializeAws_ec2DiskInfo = (output, context) => {
    let contents = {
        __type: "DiskInfo",
        Count: undefined,
        SizeInGB: undefined,
        Type: undefined
    };
    if (output["count"] !== undefined) {
        contents.Count = parseInt(output["count"]);
    }
    if (output["sizeInGB"] !== undefined) {
        contents.SizeInGB = parseInt(output["sizeInGB"]);
    }
    if (output["type"] !== undefined) {
        contents.Type = output["type"];
    }
    return contents;
};
const deserializeAws_ec2DiskInfoList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2DiskInfo(entry, context));
    });
    return contents;
};
const deserializeAws_ec2DnsEntry = (output, context) => {
    let contents = {
        __type: "DnsEntry",
        DnsName: undefined,
        HostedZoneId: undefined
    };
    if (output["dnsName"] !== undefined) {
        contents.DnsName = output["dnsName"];
    }
    if (output["hostedZoneId"] !== undefined) {
        contents.HostedZoneId = output["hostedZoneId"];
    }
    return contents;
};
const deserializeAws_ec2DnsEntrySet = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2DnsEntry(entry, context));
    });
    return contents;
};
const deserializeAws_ec2EbsBlockDevice = (output, context) => {
    let contents = {
        __type: "EbsBlockDevice",
        DeleteOnTermination: undefined,
        Encrypted: undefined,
        Iops: undefined,
        KmsKeyId: undefined,
        SnapshotId: undefined,
        VolumeSize: undefined,
        VolumeType: undefined
    };
    if (output["deleteOnTermination"] !== undefined) {
        contents.DeleteOnTermination = output["deleteOnTermination"] == "true";
    }
    if (output["encrypted"] !== undefined) {
        contents.Encrypted = output["encrypted"] == "true";
    }
    if (output["iops"] !== undefined) {
        contents.Iops = parseInt(output["iops"]);
    }
    if (output["KmsKeyId"] !== undefined) {
        contents.KmsKeyId = output["KmsKeyId"];
    }
    if (output["snapshotId"] !== undefined) {
        contents.SnapshotId = output["snapshotId"];
    }
    if (output["volumeSize"] !== undefined) {
        contents.VolumeSize = parseInt(output["volumeSize"]);
    }
    if (output["volumeType"] !== undefined) {
        contents.VolumeType = output["volumeType"];
    }
    return contents;
};
const deserializeAws_ec2EbsInfo = (output, context) => {
    let contents = {
        __type: "EbsInfo",
        EbsOptimizedSupport: undefined,
        EncryptionSupport: undefined
    };
    if (output["ebsOptimizedSupport"] !== undefined) {
        contents.EbsOptimizedSupport = output["ebsOptimizedSupport"];
    }
    if (output["encryptionSupport"] !== undefined) {
        contents.EncryptionSupport = output["encryptionSupport"];
    }
    return contents;
};
const deserializeAws_ec2EbsInstanceBlockDevice = (output, context) => {
    let contents = {
        __type: "EbsInstanceBlockDevice",
        AttachTime: undefined,
        DeleteOnTermination: undefined,
        Status: undefined,
        VolumeId: undefined
    };
    if (output["attachTime"] !== undefined) {
        contents.AttachTime = new Date(output["attachTime"]);
    }
    if (output["deleteOnTermination"] !== undefined) {
        contents.DeleteOnTermination = output["deleteOnTermination"] == "true";
    }
    if (output["status"] !== undefined) {
        contents.Status = output["status"];
    }
    if (output["volumeId"] !== undefined) {
        contents.VolumeId = output["volumeId"];
    }
    return contents;
};
const deserializeAws_ec2EgressOnlyInternetGateway = (output, context) => {
    let contents = {
        __type: "EgressOnlyInternetGateway",
        Attachments: undefined,
        EgressOnlyInternetGatewayId: undefined,
        Tags: undefined
    };
    if (output.attachmentSet === "") {
        contents.Attachments = [];
    }
    if (output["attachmentSet"] !== undefined &&
        output["attachmentSet"]["item"] !== undefined) {
        const wrappedItem = output["attachmentSet"]["item"] instanceof Array
            ? output["attachmentSet"]["item"]
            : [output["attachmentSet"]["item"]];
        contents.Attachments = deserializeAws_ec2InternetGatewayAttachmentList(wrappedItem, context);
    }
    if (output["egressOnlyInternetGatewayId"] !== undefined) {
        contents.EgressOnlyInternetGatewayId =
            output["egressOnlyInternetGatewayId"];
    }
    if (output.tagSet === "") {
        contents.Tags = [];
    }
    if (output["tagSet"] !== undefined &&
        output["tagSet"]["item"] !== undefined) {
        const wrappedItem = output["tagSet"]["item"] instanceof Array
            ? output["tagSet"]["item"]
            : [output["tagSet"]["item"]];
        contents.Tags = deserializeAws_ec2TagList(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2EgressOnlyInternetGatewayList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2EgressOnlyInternetGateway(entry, context));
    });
    return contents;
};
const deserializeAws_ec2ElasticGpuAssociation = (output, context) => {
    let contents = {
        __type: "ElasticGpuAssociation",
        ElasticGpuAssociationId: undefined,
        ElasticGpuAssociationState: undefined,
        ElasticGpuAssociationTime: undefined,
        ElasticGpuId: undefined
    };
    if (output["elasticGpuAssociationId"] !== undefined) {
        contents.ElasticGpuAssociationId = output["elasticGpuAssociationId"];
    }
    if (output["elasticGpuAssociationState"] !== undefined) {
        contents.ElasticGpuAssociationState = output["elasticGpuAssociationState"];
    }
    if (output["elasticGpuAssociationTime"] !== undefined) {
        contents.ElasticGpuAssociationTime = output["elasticGpuAssociationTime"];
    }
    if (output["elasticGpuId"] !== undefined) {
        contents.ElasticGpuId = output["elasticGpuId"];
    }
    return contents;
};
const deserializeAws_ec2ElasticGpuAssociationList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2ElasticGpuAssociation(entry, context));
    });
    return contents;
};
const deserializeAws_ec2ElasticGpuHealth = (output, context) => {
    let contents = {
        __type: "ElasticGpuHealth",
        Status: undefined
    };
    if (output["status"] !== undefined) {
        contents.Status = output["status"];
    }
    return contents;
};
const deserializeAws_ec2ElasticGpuSet = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2ElasticGpus(entry, context));
    });
    return contents;
};
const deserializeAws_ec2ElasticGpuSpecificationResponse = (output, context) => {
    let contents = {
        __type: "ElasticGpuSpecificationResponse",
        Type: undefined
    };
    if (output["type"] !== undefined) {
        contents.Type = output["type"];
    }
    return contents;
};
const deserializeAws_ec2ElasticGpuSpecificationResponseList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2ElasticGpuSpecificationResponse(entry, context));
    });
    return contents;
};
const deserializeAws_ec2ElasticGpus = (output, context) => {
    let contents = {
        __type: "ElasticGpus",
        AvailabilityZone: undefined,
        ElasticGpuHealth: undefined,
        ElasticGpuId: undefined,
        ElasticGpuState: undefined,
        ElasticGpuType: undefined,
        InstanceId: undefined,
        Tags: undefined
    };
    if (output["availabilityZone"] !== undefined) {
        contents.AvailabilityZone = output["availabilityZone"];
    }
    if (output["elasticGpuHealth"] !== undefined) {
        contents.ElasticGpuHealth = deserializeAws_ec2ElasticGpuHealth(output["elasticGpuHealth"], context);
    }
    if (output["elasticGpuId"] !== undefined) {
        contents.ElasticGpuId = output["elasticGpuId"];
    }
    if (output["elasticGpuState"] !== undefined) {
        contents.ElasticGpuState = output["elasticGpuState"];
    }
    if (output["elasticGpuType"] !== undefined) {
        contents.ElasticGpuType = output["elasticGpuType"];
    }
    if (output["instanceId"] !== undefined) {
        contents.InstanceId = output["instanceId"];
    }
    if (output.tagSet === "") {
        contents.Tags = [];
    }
    if (output["tagSet"] !== undefined &&
        output["tagSet"]["item"] !== undefined) {
        const wrappedItem = output["tagSet"]["item"] instanceof Array
            ? output["tagSet"]["item"]
            : [output["tagSet"]["item"]];
        contents.Tags = deserializeAws_ec2TagList(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2ElasticInferenceAcceleratorAssociation = (output, context) => {
    let contents = {
        __type: "ElasticInferenceAcceleratorAssociation",
        ElasticInferenceAcceleratorArn: undefined,
        ElasticInferenceAcceleratorAssociationId: undefined,
        ElasticInferenceAcceleratorAssociationState: undefined,
        ElasticInferenceAcceleratorAssociationTime: undefined
    };
    if (output["elasticInferenceAcceleratorArn"] !== undefined) {
        contents.ElasticInferenceAcceleratorArn =
            output["elasticInferenceAcceleratorArn"];
    }
    if (output["elasticInferenceAcceleratorAssociationId"] !== undefined) {
        contents.ElasticInferenceAcceleratorAssociationId =
            output["elasticInferenceAcceleratorAssociationId"];
    }
    if (output["elasticInferenceAcceleratorAssociationState"] !== undefined) {
        contents.ElasticInferenceAcceleratorAssociationState =
            output["elasticInferenceAcceleratorAssociationState"];
    }
    if (output["elasticInferenceAcceleratorAssociationTime"] !== undefined) {
        contents.ElasticInferenceAcceleratorAssociationTime = new Date(output["elasticInferenceAcceleratorAssociationTime"]);
    }
    return contents;
};
const deserializeAws_ec2ElasticInferenceAcceleratorAssociationList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2ElasticInferenceAcceleratorAssociation(entry, context));
    });
    return contents;
};
const deserializeAws_ec2EnableEbsEncryptionByDefaultResult = (output, context) => {
    let contents = {
        __type: "EnableEbsEncryptionByDefaultResult",
        EbsEncryptionByDefault: undefined
    };
    if (output["ebsEncryptionByDefault"] !== undefined) {
        contents.EbsEncryptionByDefault =
            output["ebsEncryptionByDefault"] == "true";
    }
    return contents;
};
const deserializeAws_ec2EnableFastSnapshotRestoreErrorItem = (output, context) => {
    let contents = {
        __type: "EnableFastSnapshotRestoreErrorItem",
        FastSnapshotRestoreStateErrors: undefined,
        SnapshotId: undefined
    };
    if (output.fastSnapshotRestoreStateErrorSet === "") {
        contents.FastSnapshotRestoreStateErrors = [];
    }
    if (output["fastSnapshotRestoreStateErrorSet"] !== undefined &&
        output["fastSnapshotRestoreStateErrorSet"]["item"] !== undefined) {
        const wrappedItem = output["fastSnapshotRestoreStateErrorSet"]["item"] instanceof Array
            ? output["fastSnapshotRestoreStateErrorSet"]["item"]
            : [output["fastSnapshotRestoreStateErrorSet"]["item"]];
        contents.FastSnapshotRestoreStateErrors = deserializeAws_ec2EnableFastSnapshotRestoreStateErrorSet(wrappedItem, context);
    }
    if (output["snapshotId"] !== undefined) {
        contents.SnapshotId = output["snapshotId"];
    }
    return contents;
};
const deserializeAws_ec2EnableFastSnapshotRestoreErrorSet = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2EnableFastSnapshotRestoreErrorItem(entry, context));
    });
    return contents;
};
const deserializeAws_ec2EnableFastSnapshotRestoreStateError = (output, context) => {
    let contents = {
        __type: "EnableFastSnapshotRestoreStateError",
        Code: undefined,
        Message: undefined
    };
    if (output["code"] !== undefined) {
        contents.Code = output["code"];
    }
    if (output["message"] !== undefined) {
        contents.Message = output["message"];
    }
    return contents;
};
const deserializeAws_ec2EnableFastSnapshotRestoreStateErrorItem = (output, context) => {
    let contents = {
        __type: "EnableFastSnapshotRestoreStateErrorItem",
        AvailabilityZone: undefined,
        Error: undefined
    };
    if (output["availabilityZone"] !== undefined) {
        contents.AvailabilityZone = output["availabilityZone"];
    }
    if (output["error"] !== undefined) {
        contents.Error = deserializeAws_ec2EnableFastSnapshotRestoreStateError(output["error"], context);
    }
    return contents;
};
const deserializeAws_ec2EnableFastSnapshotRestoreStateErrorSet = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2EnableFastSnapshotRestoreStateErrorItem(entry, context));
    });
    return contents;
};
const deserializeAws_ec2EnableFastSnapshotRestoreSuccessItem = (output, context) => {
    let contents = {
        __type: "EnableFastSnapshotRestoreSuccessItem",
        AvailabilityZone: undefined,
        DisabledTime: undefined,
        DisablingTime: undefined,
        EnabledTime: undefined,
        EnablingTime: undefined,
        OptimizingTime: undefined,
        OwnerAlias: undefined,
        OwnerId: undefined,
        SnapshotId: undefined,
        State: undefined,
        StateTransitionReason: undefined
    };
    if (output["availabilityZone"] !== undefined) {
        contents.AvailabilityZone = output["availabilityZone"];
    }
    if (output["disabledTime"] !== undefined) {
        contents.DisabledTime = new Date(output["disabledTime"]);
    }
    if (output["disablingTime"] !== undefined) {
        contents.DisablingTime = new Date(output["disablingTime"]);
    }
    if (output["enabledTime"] !== undefined) {
        contents.EnabledTime = new Date(output["enabledTime"]);
    }
    if (output["enablingTime"] !== undefined) {
        contents.EnablingTime = new Date(output["enablingTime"]);
    }
    if (output["optimizingTime"] !== undefined) {
        contents.OptimizingTime = new Date(output["optimizingTime"]);
    }
    if (output["ownerAlias"] !== undefined) {
        contents.OwnerAlias = output["ownerAlias"];
    }
    if (output["ownerId"] !== undefined) {
        contents.OwnerId = output["ownerId"];
    }
    if (output["snapshotId"] !== undefined) {
        contents.SnapshotId = output["snapshotId"];
    }
    if (output["state"] !== undefined) {
        contents.State = output["state"];
    }
    if (output["stateTransitionReason"] !== undefined) {
        contents.StateTransitionReason = output["stateTransitionReason"];
    }
    return contents;
};
const deserializeAws_ec2EnableFastSnapshotRestoreSuccessSet = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2EnableFastSnapshotRestoreSuccessItem(entry, context));
    });
    return contents;
};
const deserializeAws_ec2EnableFastSnapshotRestoresResult = (output, context) => {
    let contents = {
        __type: "EnableFastSnapshotRestoresResult",
        Successful: undefined,
        Unsuccessful: undefined
    };
    if (output.successful === "") {
        contents.Successful = [];
    }
    if (output["successful"] !== undefined &&
        output["successful"]["item"] !== undefined) {
        const wrappedItem = output["successful"]["item"] instanceof Array
            ? output["successful"]["item"]
            : [output["successful"]["item"]];
        contents.Successful = deserializeAws_ec2EnableFastSnapshotRestoreSuccessSet(wrappedItem, context);
    }
    if (output.unsuccessful === "") {
        contents.Unsuccessful = [];
    }
    if (output["unsuccessful"] !== undefined &&
        output["unsuccessful"]["item"] !== undefined) {
        const wrappedItem = output["unsuccessful"]["item"] instanceof Array
            ? output["unsuccessful"]["item"]
            : [output["unsuccessful"]["item"]];
        contents.Unsuccessful = deserializeAws_ec2EnableFastSnapshotRestoreErrorSet(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2EnableTransitGatewayRouteTablePropagationResult = (output, context) => {
    let contents = {
        __type: "EnableTransitGatewayRouteTablePropagationResult",
        Propagation: undefined
    };
    if (output["propagation"] !== undefined) {
        contents.Propagation = deserializeAws_ec2TransitGatewayPropagation(output["propagation"], context);
    }
    return contents;
};
const deserializeAws_ec2EnableVpcClassicLinkDnsSupportResult = (output, context) => {
    let contents = {
        __type: "EnableVpcClassicLinkDnsSupportResult",
        Return: undefined
    };
    if (output["return"] !== undefined) {
        contents.Return = output["return"] == "true";
    }
    return contents;
};
const deserializeAws_ec2EnableVpcClassicLinkResult = (output, context) => {
    let contents = {
        __type: "EnableVpcClassicLinkResult",
        Return: undefined
    };
    if (output["return"] !== undefined) {
        contents.Return = output["return"] == "true";
    }
    return contents;
};
const deserializeAws_ec2EndpointSet = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2ClientVpnEndpoint(entry, context));
    });
    return contents;
};
const deserializeAws_ec2EventInformation = (output, context) => {
    let contents = {
        __type: "EventInformation",
        EventDescription: undefined,
        EventSubType: undefined,
        InstanceId: undefined
    };
    if (output["eventDescription"] !== undefined) {
        contents.EventDescription = output["eventDescription"];
    }
    if (output["eventSubType"] !== undefined) {
        contents.EventSubType = output["eventSubType"];
    }
    if (output["instanceId"] !== undefined) {
        contents.InstanceId = output["instanceId"];
    }
    return contents;
};
const deserializeAws_ec2ExportClientVpnClientCertificateRevocationListResult = (output, context) => {
    let contents = {
        __type: "ExportClientVpnClientCertificateRevocationListResult",
        CertificateRevocationList: undefined,
        Status: undefined
    };
    if (output["certificateRevocationList"] !== undefined) {
        contents.CertificateRevocationList = output["certificateRevocationList"];
    }
    if (output["status"] !== undefined) {
        contents.Status = deserializeAws_ec2ClientCertificateRevocationListStatus(output["status"], context);
    }
    return contents;
};
const deserializeAws_ec2ExportClientVpnClientConfigurationResult = (output, context) => {
    let contents = {
        __type: "ExportClientVpnClientConfigurationResult",
        ClientConfiguration: undefined
    };
    if (output["clientConfiguration"] !== undefined) {
        contents.ClientConfiguration = output["clientConfiguration"];
    }
    return contents;
};
const deserializeAws_ec2ExportImageResult = (output, context) => {
    let contents = {
        __type: "ExportImageResult",
        Description: undefined,
        DiskImageFormat: undefined,
        ExportImageTaskId: undefined,
        ImageId: undefined,
        Progress: undefined,
        RoleName: undefined,
        S3ExportLocation: undefined,
        Status: undefined,
        StatusMessage: undefined
    };
    if (output["description"] !== undefined) {
        contents.Description = output["description"];
    }
    if (output["diskImageFormat"] !== undefined) {
        contents.DiskImageFormat = output["diskImageFormat"];
    }
    if (output["exportImageTaskId"] !== undefined) {
        contents.ExportImageTaskId = output["exportImageTaskId"];
    }
    if (output["imageId"] !== undefined) {
        contents.ImageId = output["imageId"];
    }
    if (output["progress"] !== undefined) {
        contents.Progress = output["progress"];
    }
    if (output["roleName"] !== undefined) {
        contents.RoleName = output["roleName"];
    }
    if (output["s3ExportLocation"] !== undefined) {
        contents.S3ExportLocation = deserializeAws_ec2ExportTaskS3Location(output["s3ExportLocation"], context);
    }
    if (output["status"] !== undefined) {
        contents.Status = output["status"];
    }
    if (output["statusMessage"] !== undefined) {
        contents.StatusMessage = output["statusMessage"];
    }
    return contents;
};
const deserializeAws_ec2ExportImageTask = (output, context) => {
    let contents = {
        __type: "ExportImageTask",
        Description: undefined,
        ExportImageTaskId: undefined,
        ImageId: undefined,
        Progress: undefined,
        S3ExportLocation: undefined,
        Status: undefined,
        StatusMessage: undefined
    };
    if (output["description"] !== undefined) {
        contents.Description = output["description"];
    }
    if (output["exportImageTaskId"] !== undefined) {
        contents.ExportImageTaskId = output["exportImageTaskId"];
    }
    if (output["imageId"] !== undefined) {
        contents.ImageId = output["imageId"];
    }
    if (output["progress"] !== undefined) {
        contents.Progress = output["progress"];
    }
    if (output["s3ExportLocation"] !== undefined) {
        contents.S3ExportLocation = deserializeAws_ec2ExportTaskS3Location(output["s3ExportLocation"], context);
    }
    if (output["status"] !== undefined) {
        contents.Status = output["status"];
    }
    if (output["statusMessage"] !== undefined) {
        contents.StatusMessage = output["statusMessage"];
    }
    return contents;
};
const deserializeAws_ec2ExportImageTaskList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2ExportImageTask(entry, context));
    });
    return contents;
};
const deserializeAws_ec2ExportTask = (output, context) => {
    let contents = {
        __type: "ExportTask",
        Description: undefined,
        ExportTaskId: undefined,
        ExportToS3Task: undefined,
        InstanceExportDetails: undefined,
        State: undefined,
        StatusMessage: undefined,
        Tags: undefined
    };
    if (output["description"] !== undefined) {
        contents.Description = output["description"];
    }
    if (output["exportTaskId"] !== undefined) {
        contents.ExportTaskId = output["exportTaskId"];
    }
    if (output["exportToS3"] !== undefined) {
        contents.ExportToS3Task = deserializeAws_ec2ExportToS3Task(output["exportToS3"], context);
    }
    if (output["instanceExport"] !== undefined) {
        contents.InstanceExportDetails = deserializeAws_ec2InstanceExportDetails(output["instanceExport"], context);
    }
    if (output["state"] !== undefined) {
        contents.State = output["state"];
    }
    if (output["statusMessage"] !== undefined) {
        contents.StatusMessage = output["statusMessage"];
    }
    if (output.tagSet === "") {
        contents.Tags = [];
    }
    if (output["tagSet"] !== undefined &&
        output["tagSet"]["item"] !== undefined) {
        const wrappedItem = output["tagSet"]["item"] instanceof Array
            ? output["tagSet"]["item"]
            : [output["tagSet"]["item"]];
        contents.Tags = deserializeAws_ec2TagList(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2ExportTaskList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2ExportTask(entry, context));
    });
    return contents;
};
const deserializeAws_ec2ExportTaskS3Location = (output, context) => {
    let contents = {
        __type: "ExportTaskS3Location",
        S3Bucket: undefined,
        S3Prefix: undefined
    };
    if (output["s3Bucket"] !== undefined) {
        contents.S3Bucket = output["s3Bucket"];
    }
    if (output["s3Prefix"] !== undefined) {
        contents.S3Prefix = output["s3Prefix"];
    }
    return contents;
};
const deserializeAws_ec2ExportToS3Task = (output, context) => {
    let contents = {
        __type: "ExportToS3Task",
        ContainerFormat: undefined,
        DiskImageFormat: undefined,
        S3Bucket: undefined,
        S3Key: undefined
    };
    if (output["containerFormat"] !== undefined) {
        contents.ContainerFormat = output["containerFormat"];
    }
    if (output["diskImageFormat"] !== undefined) {
        contents.DiskImageFormat = output["diskImageFormat"];
    }
    if (output["s3Bucket"] !== undefined) {
        contents.S3Bucket = output["s3Bucket"];
    }
    if (output["s3Key"] !== undefined) {
        contents.S3Key = output["s3Key"];
    }
    return contents;
};
const deserializeAws_ec2ExportTransitGatewayRoutesResult = (output, context) => {
    let contents = {
        __type: "ExportTransitGatewayRoutesResult",
        S3Location: undefined
    };
    if (output["s3Location"] !== undefined) {
        contents.S3Location = output["s3Location"];
    }
    return contents;
};
const deserializeAws_ec2FailedQueuedPurchaseDeletion = (output, context) => {
    let contents = {
        __type: "FailedQueuedPurchaseDeletion",
        Error: undefined,
        ReservedInstancesId: undefined
    };
    if (output["error"] !== undefined) {
        contents.Error = deserializeAws_ec2DeleteQueuedReservedInstancesError(output["error"], context);
    }
    if (output["reservedInstancesId"] !== undefined) {
        contents.ReservedInstancesId = output["reservedInstancesId"];
    }
    return contents;
};
const deserializeAws_ec2FailedQueuedPurchaseDeletionSet = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2FailedQueuedPurchaseDeletion(entry, context));
    });
    return contents;
};
const deserializeAws_ec2FleetData = (output, context) => {
    let contents = {
        __type: "FleetData",
        ActivityStatus: undefined,
        ClientToken: undefined,
        CreateTime: undefined,
        Errors: undefined,
        ExcessCapacityTerminationPolicy: undefined,
        FleetId: undefined,
        FleetState: undefined,
        FulfilledCapacity: undefined,
        FulfilledOnDemandCapacity: undefined,
        Instances: undefined,
        LaunchTemplateConfigs: undefined,
        OnDemandOptions: undefined,
        ReplaceUnhealthyInstances: undefined,
        SpotOptions: undefined,
        Tags: undefined,
        TargetCapacitySpecification: undefined,
        TerminateInstancesWithExpiration: undefined,
        Type: undefined,
        ValidFrom: undefined,
        ValidUntil: undefined
    };
    if (output["activityStatus"] !== undefined) {
        contents.ActivityStatus = output["activityStatus"];
    }
    if (output["clientToken"] !== undefined) {
        contents.ClientToken = output["clientToken"];
    }
    if (output["createTime"] !== undefined) {
        contents.CreateTime = new Date(output["createTime"]);
    }
    if (output.errorSet === "") {
        contents.Errors = [];
    }
    if (output["errorSet"] !== undefined &&
        output["errorSet"]["item"] !== undefined) {
        const wrappedItem = output["errorSet"]["item"] instanceof Array
            ? output["errorSet"]["item"]
            : [output["errorSet"]["item"]];
        contents.Errors = deserializeAws_ec2DescribeFleetsErrorSet(wrappedItem, context);
    }
    if (output["excessCapacityTerminationPolicy"] !== undefined) {
        contents.ExcessCapacityTerminationPolicy =
            output["excessCapacityTerminationPolicy"];
    }
    if (output["fleetId"] !== undefined) {
        contents.FleetId = output["fleetId"];
    }
    if (output["fleetState"] !== undefined) {
        contents.FleetState = output["fleetState"];
    }
    if (output["fulfilledCapacity"] !== undefined) {
        contents.FulfilledCapacity = parseFloat(output["fulfilledCapacity"]);
    }
    if (output["fulfilledOnDemandCapacity"] !== undefined) {
        contents.FulfilledOnDemandCapacity = parseFloat(output["fulfilledOnDemandCapacity"]);
    }
    if (output.fleetInstanceSet === "") {
        contents.Instances = [];
    }
    if (output["fleetInstanceSet"] !== undefined &&
        output["fleetInstanceSet"]["item"] !== undefined) {
        const wrappedItem = output["fleetInstanceSet"]["item"] instanceof Array
            ? output["fleetInstanceSet"]["item"]
            : [output["fleetInstanceSet"]["item"]];
        contents.Instances = deserializeAws_ec2DescribeFleetsInstancesSet(wrappedItem, context);
    }
    if (output.launchTemplateConfigs === "") {
        contents.LaunchTemplateConfigs = [];
    }
    if (output["launchTemplateConfigs"] !== undefined &&
        output["launchTemplateConfigs"]["item"] !== undefined) {
        const wrappedItem = output["launchTemplateConfigs"]["item"] instanceof Array
            ? output["launchTemplateConfigs"]["item"]
            : [output["launchTemplateConfigs"]["item"]];
        contents.LaunchTemplateConfigs = deserializeAws_ec2FleetLaunchTemplateConfigList(wrappedItem, context);
    }
    if (output["onDemandOptions"] !== undefined) {
        contents.OnDemandOptions = deserializeAws_ec2OnDemandOptions(output["onDemandOptions"], context);
    }
    if (output["replaceUnhealthyInstances"] !== undefined) {
        contents.ReplaceUnhealthyInstances =
            output["replaceUnhealthyInstances"] == "true";
    }
    if (output["spotOptions"] !== undefined) {
        contents.SpotOptions = deserializeAws_ec2SpotOptions(output["spotOptions"], context);
    }
    if (output.tagSet === "") {
        contents.Tags = [];
    }
    if (output["tagSet"] !== undefined &&
        output["tagSet"]["item"] !== undefined) {
        const wrappedItem = output["tagSet"]["item"] instanceof Array
            ? output["tagSet"]["item"]
            : [output["tagSet"]["item"]];
        contents.Tags = deserializeAws_ec2TagList(wrappedItem, context);
    }
    if (output["targetCapacitySpecification"] !== undefined) {
        contents.TargetCapacitySpecification = deserializeAws_ec2TargetCapacitySpecification(output["targetCapacitySpecification"], context);
    }
    if (output["terminateInstancesWithExpiration"] !== undefined) {
        contents.TerminateInstancesWithExpiration =
            output["terminateInstancesWithExpiration"] == "true";
    }
    if (output["type"] !== undefined) {
        contents.Type = output["type"];
    }
    if (output["validFrom"] !== undefined) {
        contents.ValidFrom = new Date(output["validFrom"]);
    }
    if (output["validUntil"] !== undefined) {
        contents.ValidUntil = new Date(output["validUntil"]);
    }
    return contents;
};
const deserializeAws_ec2FleetLaunchTemplateConfig = (output, context) => {
    let contents = {
        __type: "FleetLaunchTemplateConfig",
        LaunchTemplateSpecification: undefined,
        Overrides: undefined
    };
    if (output["launchTemplateSpecification"] !== undefined) {
        contents.LaunchTemplateSpecification = deserializeAws_ec2FleetLaunchTemplateSpecification(output["launchTemplateSpecification"], context);
    }
    if (output.overrides === "") {
        contents.Overrides = [];
    }
    if (output["overrides"] !== undefined &&
        output["overrides"]["item"] !== undefined) {
        const wrappedItem = output["overrides"]["item"] instanceof Array
            ? output["overrides"]["item"]
            : [output["overrides"]["item"]];
        contents.Overrides = deserializeAws_ec2FleetLaunchTemplateOverridesList(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2FleetLaunchTemplateConfigList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2FleetLaunchTemplateConfig(entry, context));
    });
    return contents;
};
const deserializeAws_ec2FleetLaunchTemplateOverrides = (output, context) => {
    let contents = {
        __type: "FleetLaunchTemplateOverrides",
        AvailabilityZone: undefined,
        InstanceType: undefined,
        MaxPrice: undefined,
        Placement: undefined,
        Priority: undefined,
        SubnetId: undefined,
        WeightedCapacity: undefined
    };
    if (output["availabilityZone"] !== undefined) {
        contents.AvailabilityZone = output["availabilityZone"];
    }
    if (output["instanceType"] !== undefined) {
        contents.InstanceType = output["instanceType"];
    }
    if (output["maxPrice"] !== undefined) {
        contents.MaxPrice = output["maxPrice"];
    }
    if (output["placement"] !== undefined) {
        contents.Placement = deserializeAws_ec2PlacementResponse(output["placement"], context);
    }
    if (output["priority"] !== undefined) {
        contents.Priority = parseFloat(output["priority"]);
    }
    if (output["subnetId"] !== undefined) {
        contents.SubnetId = output["subnetId"];
    }
    if (output["weightedCapacity"] !== undefined) {
        contents.WeightedCapacity = parseFloat(output["weightedCapacity"]);
    }
    return contents;
};
const deserializeAws_ec2FleetLaunchTemplateOverridesList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2FleetLaunchTemplateOverrides(entry, context));
    });
    return contents;
};
const deserializeAws_ec2FleetLaunchTemplateSpecification = (output, context) => {
    let contents = {
        __type: "FleetLaunchTemplateSpecification",
        LaunchTemplateId: undefined,
        LaunchTemplateName: undefined,
        Version: undefined
    };
    if (output["launchTemplateId"] !== undefined) {
        contents.LaunchTemplateId = output["launchTemplateId"];
    }
    if (output["launchTemplateName"] !== undefined) {
        contents.LaunchTemplateName = output["launchTemplateName"];
    }
    if (output["version"] !== undefined) {
        contents.Version = output["version"];
    }
    return contents;
};
const deserializeAws_ec2FleetSet = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2FleetData(entry, context));
    });
    return contents;
};
const deserializeAws_ec2FlowLog = (output, context) => {
    let contents = {
        __type: "FlowLog",
        CreationTime: undefined,
        DeliverLogsErrorMessage: undefined,
        DeliverLogsPermissionArn: undefined,
        DeliverLogsStatus: undefined,
        FlowLogId: undefined,
        FlowLogStatus: undefined,
        LogDestination: undefined,
        LogDestinationType: undefined,
        LogFormat: undefined,
        LogGroupName: undefined,
        ResourceId: undefined,
        TrafficType: undefined
    };
    if (output["creationTime"] !== undefined) {
        contents.CreationTime = new Date(output["creationTime"]);
    }
    if (output["deliverLogsErrorMessage"] !== undefined) {
        contents.DeliverLogsErrorMessage = output["deliverLogsErrorMessage"];
    }
    if (output["deliverLogsPermissionArn"] !== undefined) {
        contents.DeliverLogsPermissionArn = output["deliverLogsPermissionArn"];
    }
    if (output["deliverLogsStatus"] !== undefined) {
        contents.DeliverLogsStatus = output["deliverLogsStatus"];
    }
    if (output["flowLogId"] !== undefined) {
        contents.FlowLogId = output["flowLogId"];
    }
    if (output["flowLogStatus"] !== undefined) {
        contents.FlowLogStatus = output["flowLogStatus"];
    }
    if (output["logDestination"] !== undefined) {
        contents.LogDestination = output["logDestination"];
    }
    if (output["logDestinationType"] !== undefined) {
        contents.LogDestinationType = output["logDestinationType"];
    }
    if (output["logFormat"] !== undefined) {
        contents.LogFormat = output["logFormat"];
    }
    if (output["logGroupName"] !== undefined) {
        contents.LogGroupName = output["logGroupName"];
    }
    if (output["resourceId"] !== undefined) {
        contents.ResourceId = output["resourceId"];
    }
    if (output["trafficType"] !== undefined) {
        contents.TrafficType = output["trafficType"];
    }
    return contents;
};
const deserializeAws_ec2FlowLogSet = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2FlowLog(entry, context));
    });
    return contents;
};
const deserializeAws_ec2FpgaDeviceInfo = (output, context) => {
    let contents = {
        __type: "FpgaDeviceInfo",
        Count: undefined,
        Manufacturer: undefined,
        MemoryInfo: undefined,
        Name: undefined
    };
    if (output["count"] !== undefined) {
        contents.Count = parseInt(output["count"]);
    }
    if (output["manufacturer"] !== undefined) {
        contents.Manufacturer = output["manufacturer"];
    }
    if (output["memoryInfo"] !== undefined) {
        contents.MemoryInfo = deserializeAws_ec2FpgaDeviceMemoryInfo(output["memoryInfo"], context);
    }
    if (output["name"] !== undefined) {
        contents.Name = output["name"];
    }
    return contents;
};
const deserializeAws_ec2FpgaDeviceInfoList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2FpgaDeviceInfo(entry, context));
    });
    return contents;
};
const deserializeAws_ec2FpgaDeviceMemoryInfo = (output, context) => {
    let contents = {
        __type: "FpgaDeviceMemoryInfo",
        SizeInMiB: undefined
    };
    if (output["sizeInMiB"] !== undefined) {
        contents.SizeInMiB = parseInt(output["sizeInMiB"]);
    }
    return contents;
};
const deserializeAws_ec2FpgaImage = (output, context) => {
    let contents = {
        __type: "FpgaImage",
        CreateTime: undefined,
        DataRetentionSupport: undefined,
        Description: undefined,
        FpgaImageGlobalId: undefined,
        FpgaImageId: undefined,
        Name: undefined,
        OwnerAlias: undefined,
        OwnerId: undefined,
        PciId: undefined,
        ProductCodes: undefined,
        Public: undefined,
        ShellVersion: undefined,
        State: undefined,
        Tags: undefined,
        UpdateTime: undefined
    };
    if (output["createTime"] !== undefined) {
        contents.CreateTime = new Date(output["createTime"]);
    }
    if (output["dataRetentionSupport"] !== undefined) {
        contents.DataRetentionSupport = output["dataRetentionSupport"] == "true";
    }
    if (output["description"] !== undefined) {
        contents.Description = output["description"];
    }
    if (output["fpgaImageGlobalId"] !== undefined) {
        contents.FpgaImageGlobalId = output["fpgaImageGlobalId"];
    }
    if (output["fpgaImageId"] !== undefined) {
        contents.FpgaImageId = output["fpgaImageId"];
    }
    if (output["name"] !== undefined) {
        contents.Name = output["name"];
    }
    if (output["ownerAlias"] !== undefined) {
        contents.OwnerAlias = output["ownerAlias"];
    }
    if (output["ownerId"] !== undefined) {
        contents.OwnerId = output["ownerId"];
    }
    if (output["pciId"] !== undefined) {
        contents.PciId = deserializeAws_ec2PciId(output["pciId"], context);
    }
    if (output.productCodes === "") {
        contents.ProductCodes = [];
    }
    if (output["productCodes"] !== undefined &&
        output["productCodes"]["item"] !== undefined) {
        const wrappedItem = output["productCodes"]["item"] instanceof Array
            ? output["productCodes"]["item"]
            : [output["productCodes"]["item"]];
        contents.ProductCodes = deserializeAws_ec2ProductCodeList(wrappedItem, context);
    }
    if (output["public"] !== undefined) {
        contents.Public = output["public"] == "true";
    }
    if (output["shellVersion"] !== undefined) {
        contents.ShellVersion = output["shellVersion"];
    }
    if (output["state"] !== undefined) {
        contents.State = deserializeAws_ec2FpgaImageState(output["state"], context);
    }
    if (output.tags === "") {
        contents.Tags = [];
    }
    if (output["tags"] !== undefined && output["tags"]["item"] !== undefined) {
        const wrappedItem = output["tags"]["item"] instanceof Array
            ? output["tags"]["item"]
            : [output["tags"]["item"]];
        contents.Tags = deserializeAws_ec2TagList(wrappedItem, context);
    }
    if (output["updateTime"] !== undefined) {
        contents.UpdateTime = new Date(output["updateTime"]);
    }
    return contents;
};
const deserializeAws_ec2FpgaImageAttribute = (output, context) => {
    let contents = {
        __type: "FpgaImageAttribute",
        Description: undefined,
        FpgaImageId: undefined,
        LoadPermissions: undefined,
        Name: undefined,
        ProductCodes: undefined
    };
    if (output["description"] !== undefined) {
        contents.Description = output["description"];
    }
    if (output["fpgaImageId"] !== undefined) {
        contents.FpgaImageId = output["fpgaImageId"];
    }
    if (output.loadPermissions === "") {
        contents.LoadPermissions = [];
    }
    if (output["loadPermissions"] !== undefined &&
        output["loadPermissions"]["item"] !== undefined) {
        const wrappedItem = output["loadPermissions"]["item"] instanceof Array
            ? output["loadPermissions"]["item"]
            : [output["loadPermissions"]["item"]];
        contents.LoadPermissions = deserializeAws_ec2LoadPermissionList(wrappedItem, context);
    }
    if (output["name"] !== undefined) {
        contents.Name = output["name"];
    }
    if (output.productCodes === "") {
        contents.ProductCodes = [];
    }
    if (output["productCodes"] !== undefined &&
        output["productCodes"]["item"] !== undefined) {
        const wrappedItem = output["productCodes"]["item"] instanceof Array
            ? output["productCodes"]["item"]
            : [output["productCodes"]["item"]];
        contents.ProductCodes = deserializeAws_ec2ProductCodeList(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2FpgaImageList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2FpgaImage(entry, context));
    });
    return contents;
};
const deserializeAws_ec2FpgaImageState = (output, context) => {
    let contents = {
        __type: "FpgaImageState",
        Code: undefined,
        Message: undefined
    };
    if (output["code"] !== undefined) {
        contents.Code = output["code"];
    }
    if (output["message"] !== undefined) {
        contents.Message = output["message"];
    }
    return contents;
};
const deserializeAws_ec2FpgaInfo = (output, context) => {
    let contents = {
        __type: "FpgaInfo",
        Fpgas: undefined,
        TotalFpgaMemoryInMiB: undefined
    };
    if (output.fpgas === "") {
        contents.Fpgas = [];
    }
    if (output["fpgas"] !== undefined && output["fpgas"]["item"] !== undefined) {
        const wrappedItem = output["fpgas"]["item"] instanceof Array
            ? output["fpgas"]["item"]
            : [output["fpgas"]["item"]];
        contents.Fpgas = deserializeAws_ec2FpgaDeviceInfoList(wrappedItem, context);
    }
    if (output["totalFpgaMemoryInMiB"] !== undefined) {
        contents.TotalFpgaMemoryInMiB = parseInt(output["totalFpgaMemoryInMiB"]);
    }
    return contents;
};
const deserializeAws_ec2GetAssociatedIpv6PoolCidrsResult = (output, context) => {
    let contents = {
        __type: "GetAssociatedIpv6PoolCidrsResult",
        Ipv6CidrAssociations: undefined,
        NextToken: undefined
    };
    if (output.ipv6CidrAssociationSet === "") {
        contents.Ipv6CidrAssociations = [];
    }
    if (output["ipv6CidrAssociationSet"] !== undefined &&
        output["ipv6CidrAssociationSet"]["item"] !== undefined) {
        const wrappedItem = output["ipv6CidrAssociationSet"]["item"] instanceof Array
            ? output["ipv6CidrAssociationSet"]["item"]
            : [output["ipv6CidrAssociationSet"]["item"]];
        contents.Ipv6CidrAssociations = deserializeAws_ec2Ipv6CidrAssociationSet(wrappedItem, context);
    }
    if (output["nextToken"] !== undefined) {
        contents.NextToken = output["nextToken"];
    }
    return contents;
};
const deserializeAws_ec2GetCapacityReservationUsageResult = (output, context) => {
    let contents = {
        __type: "GetCapacityReservationUsageResult",
        AvailableInstanceCount: undefined,
        CapacityReservationId: undefined,
        InstanceType: undefined,
        InstanceUsages: undefined,
        NextToken: undefined,
        State: undefined,
        TotalInstanceCount: undefined
    };
    if (output["availableInstanceCount"] !== undefined) {
        contents.AvailableInstanceCount = parseInt(output["availableInstanceCount"]);
    }
    if (output["capacityReservationId"] !== undefined) {
        contents.CapacityReservationId = output["capacityReservationId"];
    }
    if (output["instanceType"] !== undefined) {
        contents.InstanceType = output["instanceType"];
    }
    if (output.instanceUsageSet === "") {
        contents.InstanceUsages = [];
    }
    if (output["instanceUsageSet"] !== undefined &&
        output["instanceUsageSet"]["item"] !== undefined) {
        const wrappedItem = output["instanceUsageSet"]["item"] instanceof Array
            ? output["instanceUsageSet"]["item"]
            : [output["instanceUsageSet"]["item"]];
        contents.InstanceUsages = deserializeAws_ec2InstanceUsageSet(wrappedItem, context);
    }
    if (output["nextToken"] !== undefined) {
        contents.NextToken = output["nextToken"];
    }
    if (output["state"] !== undefined) {
        contents.State = output["state"];
    }
    if (output["totalInstanceCount"] !== undefined) {
        contents.TotalInstanceCount = parseInt(output["totalInstanceCount"]);
    }
    return contents;
};
const deserializeAws_ec2GetCoipPoolUsageResult = (output, context) => {
    let contents = {
        __type: "GetCoipPoolUsageResult",
        CoipAddressUsages: undefined,
        CoipPoolId: undefined,
        LocalGatewayRouteTableId: undefined
    };
    if (output.coipAddressUsageSet === "") {
        contents.CoipAddressUsages = [];
    }
    if (output["coipAddressUsageSet"] !== undefined &&
        output["coipAddressUsageSet"]["item"] !== undefined) {
        const wrappedItem = output["coipAddressUsageSet"]["item"] instanceof Array
            ? output["coipAddressUsageSet"]["item"]
            : [output["coipAddressUsageSet"]["item"]];
        contents.CoipAddressUsages = deserializeAws_ec2CoipAddressUsageSet(wrappedItem, context);
    }
    if (output["coipPoolId"] !== undefined) {
        contents.CoipPoolId = output["coipPoolId"];
    }
    if (output["localGatewayRouteTableId"] !== undefined) {
        contents.LocalGatewayRouteTableId = output["localGatewayRouteTableId"];
    }
    return contents;
};
const deserializeAws_ec2GetConsoleOutputResult = (output, context) => {
    let contents = {
        __type: "GetConsoleOutputResult",
        InstanceId: undefined,
        Output: undefined,
        Timestamp: undefined
    };
    if (output["instanceId"] !== undefined) {
        contents.InstanceId = output["instanceId"];
    }
    if (output["output"] !== undefined) {
        contents.Output = output["output"];
    }
    if (output["timestamp"] !== undefined) {
        contents.Timestamp = new Date(output["timestamp"]);
    }
    return contents;
};
const deserializeAws_ec2GetConsoleScreenshotResult = (output, context) => {
    let contents = {
        __type: "GetConsoleScreenshotResult",
        ImageData: undefined,
        InstanceId: undefined
    };
    if (output["imageData"] !== undefined) {
        contents.ImageData = output["imageData"];
    }
    if (output["instanceId"] !== undefined) {
        contents.InstanceId = output["instanceId"];
    }
    return contents;
};
const deserializeAws_ec2GetDefaultCreditSpecificationResult = (output, context) => {
    let contents = {
        __type: "GetDefaultCreditSpecificationResult",
        InstanceFamilyCreditSpecification: undefined
    };
    if (output["instanceFamilyCreditSpecification"] !== undefined) {
        contents.InstanceFamilyCreditSpecification = deserializeAws_ec2InstanceFamilyCreditSpecification(output["instanceFamilyCreditSpecification"], context);
    }
    return contents;
};
const deserializeAws_ec2GetEbsDefaultKmsKeyIdResult = (output, context) => {
    let contents = {
        __type: "GetEbsDefaultKmsKeyIdResult",
        KmsKeyId: undefined
    };
    if (output["kmsKeyId"] !== undefined) {
        contents.KmsKeyId = output["kmsKeyId"];
    }
    return contents;
};
const deserializeAws_ec2GetEbsEncryptionByDefaultResult = (output, context) => {
    let contents = {
        __type: "GetEbsEncryptionByDefaultResult",
        EbsEncryptionByDefault: undefined
    };
    if (output["ebsEncryptionByDefault"] !== undefined) {
        contents.EbsEncryptionByDefault =
            output["ebsEncryptionByDefault"] == "true";
    }
    return contents;
};
const deserializeAws_ec2GetHostReservationPurchasePreviewResult = (output, context) => {
    let contents = {
        __type: "GetHostReservationPurchasePreviewResult",
        CurrencyCode: undefined,
        Purchase: undefined,
        TotalHourlyPrice: undefined,
        TotalUpfrontPrice: undefined
    };
    if (output["currencyCode"] !== undefined) {
        contents.CurrencyCode = output["currencyCode"];
    }
    if (output.purchase === "") {
        contents.Purchase = [];
    }
    if (output["purchase"] !== undefined &&
        output["purchase"]["item"] !== undefined) {
        const wrappedItem = output["purchase"]["item"] instanceof Array
            ? output["purchase"]["item"]
            : [output["purchase"]["item"]];
        contents.Purchase = deserializeAws_ec2PurchaseSet(wrappedItem, context);
    }
    if (output["totalHourlyPrice"] !== undefined) {
        contents.TotalHourlyPrice = output["totalHourlyPrice"];
    }
    if (output["totalUpfrontPrice"] !== undefined) {
        contents.TotalUpfrontPrice = output["totalUpfrontPrice"];
    }
    return contents;
};
const deserializeAws_ec2GetLaunchTemplateDataResult = (output, context) => {
    let contents = {
        __type: "GetLaunchTemplateDataResult",
        LaunchTemplateData: undefined
    };
    if (output["launchTemplateData"] !== undefined) {
        contents.LaunchTemplateData = deserializeAws_ec2ResponseLaunchTemplateData(output["launchTemplateData"], context);
    }
    return contents;
};
const deserializeAws_ec2GetPasswordDataResult = (output, context) => {
    let contents = {
        __type: "GetPasswordDataResult",
        InstanceId: undefined,
        PasswordData: undefined,
        Timestamp: undefined
    };
    if (output["instanceId"] !== undefined) {
        contents.InstanceId = output["instanceId"];
    }
    if (output["passwordData"] !== undefined) {
        contents.PasswordData = output["passwordData"];
    }
    if (output["timestamp"] !== undefined) {
        contents.Timestamp = new Date(output["timestamp"]);
    }
    return contents;
};
const deserializeAws_ec2GetReservedInstancesExchangeQuoteResult = (output, context) => {
    let contents = {
        __type: "GetReservedInstancesExchangeQuoteResult",
        CurrencyCode: undefined,
        IsValidExchange: undefined,
        OutputReservedInstancesWillExpireAt: undefined,
        PaymentDue: undefined,
        ReservedInstanceValueRollup: undefined,
        ReservedInstanceValueSet: undefined,
        TargetConfigurationValueRollup: undefined,
        TargetConfigurationValueSet: undefined,
        ValidationFailureReason: undefined
    };
    if (output["currencyCode"] !== undefined) {
        contents.CurrencyCode = output["currencyCode"];
    }
    if (output["isValidExchange"] !== undefined) {
        contents.IsValidExchange = output["isValidExchange"] == "true";
    }
    if (output["outputReservedInstancesWillExpireAt"] !== undefined) {
        contents.OutputReservedInstancesWillExpireAt = new Date(output["outputReservedInstancesWillExpireAt"]);
    }
    if (output["paymentDue"] !== undefined) {
        contents.PaymentDue = output["paymentDue"];
    }
    if (output["reservedInstanceValueRollup"] !== undefined) {
        contents.ReservedInstanceValueRollup = deserializeAws_ec2ReservationValue(output["reservedInstanceValueRollup"], context);
    }
    if (output.reservedInstanceValueSet === "") {
        contents.ReservedInstanceValueSet = [];
    }
    if (output["reservedInstanceValueSet"] !== undefined &&
        output["reservedInstanceValueSet"]["item"] !== undefined) {
        const wrappedItem = output["reservedInstanceValueSet"]["item"] instanceof Array
            ? output["reservedInstanceValueSet"]["item"]
            : [output["reservedInstanceValueSet"]["item"]];
        contents.ReservedInstanceValueSet = deserializeAws_ec2ReservedInstanceReservationValueSet(wrappedItem, context);
    }
    if (output["targetConfigurationValueRollup"] !== undefined) {
        contents.TargetConfigurationValueRollup = deserializeAws_ec2ReservationValue(output["targetConfigurationValueRollup"], context);
    }
    if (output.targetConfigurationValueSet === "") {
        contents.TargetConfigurationValueSet = [];
    }
    if (output["targetConfigurationValueSet"] !== undefined &&
        output["targetConfigurationValueSet"]["item"] !== undefined) {
        const wrappedItem = output["targetConfigurationValueSet"]["item"] instanceof Array
            ? output["targetConfigurationValueSet"]["item"]
            : [output["targetConfigurationValueSet"]["item"]];
        contents.TargetConfigurationValueSet = deserializeAws_ec2TargetReservationValueSet(wrappedItem, context);
    }
    if (output["validationFailureReason"] !== undefined) {
        contents.ValidationFailureReason = output["validationFailureReason"];
    }
    return contents;
};
const deserializeAws_ec2GetTransitGatewayAttachmentPropagationsResult = (output, context) => {
    let contents = {
        __type: "GetTransitGatewayAttachmentPropagationsResult",
        NextToken: undefined,
        TransitGatewayAttachmentPropagations: undefined
    };
    if (output["nextToken"] !== undefined) {
        contents.NextToken = output["nextToken"];
    }
    if (output.transitGatewayAttachmentPropagations === "") {
        contents.TransitGatewayAttachmentPropagations = [];
    }
    if (output["transitGatewayAttachmentPropagations"] !== undefined &&
        output["transitGatewayAttachmentPropagations"]["item"] !== undefined) {
        const wrappedItem = output["transitGatewayAttachmentPropagations"]["item"] instanceof Array
            ? output["transitGatewayAttachmentPropagations"]["item"]
            : [output["transitGatewayAttachmentPropagations"]["item"]];
        contents.TransitGatewayAttachmentPropagations = deserializeAws_ec2TransitGatewayAttachmentPropagationList(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2GetTransitGatewayMulticastDomainAssociationsResult = (output, context) => {
    let contents = {
        __type: "GetTransitGatewayMulticastDomainAssociationsResult",
        MulticastDomainAssociations: undefined,
        NextToken: undefined
    };
    if (output.multicastDomainAssociations === "") {
        contents.MulticastDomainAssociations = [];
    }
    if (output["multicastDomainAssociations"] !== undefined &&
        output["multicastDomainAssociations"]["item"] !== undefined) {
        const wrappedItem = output["multicastDomainAssociations"]["item"] instanceof Array
            ? output["multicastDomainAssociations"]["item"]
            : [output["multicastDomainAssociations"]["item"]];
        contents.MulticastDomainAssociations = deserializeAws_ec2TransitGatewayMulticastDomainAssociationList(wrappedItem, context);
    }
    if (output["nextToken"] !== undefined) {
        contents.NextToken = output["nextToken"];
    }
    return contents;
};
const deserializeAws_ec2GetTransitGatewayRouteTableAssociationsResult = (output, context) => {
    let contents = {
        __type: "GetTransitGatewayRouteTableAssociationsResult",
        Associations: undefined,
        NextToken: undefined
    };
    if (output.associations === "") {
        contents.Associations = [];
    }
    if (output["associations"] !== undefined &&
        output["associations"]["item"] !== undefined) {
        const wrappedItem = output["associations"]["item"] instanceof Array
            ? output["associations"]["item"]
            : [output["associations"]["item"]];
        contents.Associations = deserializeAws_ec2TransitGatewayRouteTableAssociationList(wrappedItem, context);
    }
    if (output["nextToken"] !== undefined) {
        contents.NextToken = output["nextToken"];
    }
    return contents;
};
const deserializeAws_ec2GetTransitGatewayRouteTablePropagationsResult = (output, context) => {
    let contents = {
        __type: "GetTransitGatewayRouteTablePropagationsResult",
        NextToken: undefined,
        TransitGatewayRouteTablePropagations: undefined
    };
    if (output["nextToken"] !== undefined) {
        contents.NextToken = output["nextToken"];
    }
    if (output.transitGatewayRouteTablePropagations === "") {
        contents.TransitGatewayRouteTablePropagations = [];
    }
    if (output["transitGatewayRouteTablePropagations"] !== undefined &&
        output["transitGatewayRouteTablePropagations"]["item"] !== undefined) {
        const wrappedItem = output["transitGatewayRouteTablePropagations"]["item"] instanceof Array
            ? output["transitGatewayRouteTablePropagations"]["item"]
            : [output["transitGatewayRouteTablePropagations"]["item"]];
        contents.TransitGatewayRouteTablePropagations = deserializeAws_ec2TransitGatewayRouteTablePropagationList(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2GpuDeviceInfo = (output, context) => {
    let contents = {
        __type: "GpuDeviceInfo",
        Count: undefined,
        Manufacturer: undefined,
        MemoryInfo: undefined,
        Name: undefined
    };
    if (output["count"] !== undefined) {
        contents.Count = parseInt(output["count"]);
    }
    if (output["manufacturer"] !== undefined) {
        contents.Manufacturer = output["manufacturer"];
    }
    if (output["memoryInfo"] !== undefined) {
        contents.MemoryInfo = deserializeAws_ec2GpuDeviceMemoryInfo(output["memoryInfo"], context);
    }
    if (output["name"] !== undefined) {
        contents.Name = output["name"];
    }
    return contents;
};
const deserializeAws_ec2GpuDeviceInfoList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2GpuDeviceInfo(entry, context));
    });
    return contents;
};
const deserializeAws_ec2GpuDeviceMemoryInfo = (output, context) => {
    let contents = {
        __type: "GpuDeviceMemoryInfo",
        SizeInMiB: undefined
    };
    if (output["sizeInMiB"] !== undefined) {
        contents.SizeInMiB = parseInt(output["sizeInMiB"]);
    }
    return contents;
};
const deserializeAws_ec2GpuInfo = (output, context) => {
    let contents = {
        __type: "GpuInfo",
        Gpus: undefined,
        TotalGpuMemoryInMiB: undefined
    };
    if (output.gpus === "") {
        contents.Gpus = [];
    }
    if (output["gpus"] !== undefined && output["gpus"]["item"] !== undefined) {
        const wrappedItem = output["gpus"]["item"] instanceof Array
            ? output["gpus"]["item"]
            : [output["gpus"]["item"]];
        contents.Gpus = deserializeAws_ec2GpuDeviceInfoList(wrappedItem, context);
    }
    if (output["totalGpuMemoryInMiB"] !== undefined) {
        contents.TotalGpuMemoryInMiB = parseInt(output["totalGpuMemoryInMiB"]);
    }
    return contents;
};
const deserializeAws_ec2GroupIdStringList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(entry);
    });
    return contents;
};
const deserializeAws_ec2GroupIdentifier = (output, context) => {
    let contents = {
        __type: "GroupIdentifier",
        GroupId: undefined,
        GroupName: undefined
    };
    if (output["groupId"] !== undefined) {
        contents.GroupId = output["groupId"];
    }
    if (output["groupName"] !== undefined) {
        contents.GroupName = output["groupName"];
    }
    return contents;
};
const deserializeAws_ec2GroupIdentifierList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2GroupIdentifier(entry, context));
    });
    return contents;
};
const deserializeAws_ec2GroupIdentifierSet = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2SecurityGroupIdentifier(entry, context));
    });
    return contents;
};
const deserializeAws_ec2HibernationOptions = (output, context) => {
    let contents = {
        __type: "HibernationOptions",
        Configured: undefined
    };
    if (output["configured"] !== undefined) {
        contents.Configured = output["configured"] == "true";
    }
    return contents;
};
const deserializeAws_ec2HistoryRecord = (output, context) => {
    let contents = {
        __type: "HistoryRecord",
        EventInformation: undefined,
        EventType: undefined,
        Timestamp: undefined
    };
    if (output["eventInformation"] !== undefined) {
        contents.EventInformation = deserializeAws_ec2EventInformation(output["eventInformation"], context);
    }
    if (output["eventType"] !== undefined) {
        contents.EventType = output["eventType"];
    }
    if (output["timestamp"] !== undefined) {
        contents.Timestamp = new Date(output["timestamp"]);
    }
    return contents;
};
const deserializeAws_ec2HistoryRecordEntry = (output, context) => {
    let contents = {
        __type: "HistoryRecordEntry",
        EventInformation: undefined,
        EventType: undefined,
        Timestamp: undefined
    };
    if (output["eventInformation"] !== undefined) {
        contents.EventInformation = deserializeAws_ec2EventInformation(output["eventInformation"], context);
    }
    if (output["eventType"] !== undefined) {
        contents.EventType = output["eventType"];
    }
    if (output["timestamp"] !== undefined) {
        contents.Timestamp = new Date(output["timestamp"]);
    }
    return contents;
};
const deserializeAws_ec2HistoryRecordSet = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2HistoryRecordEntry(entry, context));
    });
    return contents;
};
const deserializeAws_ec2HistoryRecords = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2HistoryRecord(entry, context));
    });
    return contents;
};
const deserializeAws_ec2Host = (output, context) => {
    let contents = {
        __type: "Host",
        AllocationTime: undefined,
        AllowsMultipleInstanceTypes: undefined,
        AutoPlacement: undefined,
        AvailabilityZone: undefined,
        AvailabilityZoneId: undefined,
        AvailableCapacity: undefined,
        ClientToken: undefined,
        HostId: undefined,
        HostProperties: undefined,
        HostRecovery: undefined,
        HostReservationId: undefined,
        Instances: undefined,
        MemberOfServiceLinkedResourceGroup: undefined,
        OwnerId: undefined,
        ReleaseTime: undefined,
        State: undefined,
        Tags: undefined
    };
    if (output["allocationTime"] !== undefined) {
        contents.AllocationTime = new Date(output["allocationTime"]);
    }
    if (output["allowsMultipleInstanceTypes"] !== undefined) {
        contents.AllowsMultipleInstanceTypes =
            output["allowsMultipleInstanceTypes"];
    }
    if (output["autoPlacement"] !== undefined) {
        contents.AutoPlacement = output["autoPlacement"];
    }
    if (output["availabilityZone"] !== undefined) {
        contents.AvailabilityZone = output["availabilityZone"];
    }
    if (output["availabilityZoneId"] !== undefined) {
        contents.AvailabilityZoneId = output["availabilityZoneId"];
    }
    if (output["availableCapacity"] !== undefined) {
        contents.AvailableCapacity = deserializeAws_ec2AvailableCapacity(output["availableCapacity"], context);
    }
    if (output["clientToken"] !== undefined) {
        contents.ClientToken = output["clientToken"];
    }
    if (output["hostId"] !== undefined) {
        contents.HostId = output["hostId"];
    }
    if (output["hostProperties"] !== undefined) {
        contents.HostProperties = deserializeAws_ec2HostProperties(output["hostProperties"], context);
    }
    if (output["hostRecovery"] !== undefined) {
        contents.HostRecovery = output["hostRecovery"];
    }
    if (output["hostReservationId"] !== undefined) {
        contents.HostReservationId = output["hostReservationId"];
    }
    if (output.instances === "") {
        contents.Instances = [];
    }
    if (output["instances"] !== undefined &&
        output["instances"]["item"] !== undefined) {
        const wrappedItem = output["instances"]["item"] instanceof Array
            ? output["instances"]["item"]
            : [output["instances"]["item"]];
        contents.Instances = deserializeAws_ec2HostInstanceList(wrappedItem, context);
    }
    if (output["memberOfServiceLinkedResourceGroup"] !== undefined) {
        contents.MemberOfServiceLinkedResourceGroup =
            output["memberOfServiceLinkedResourceGroup"] == "true";
    }
    if (output["ownerId"] !== undefined) {
        contents.OwnerId = output["ownerId"];
    }
    if (output["releaseTime"] !== undefined) {
        contents.ReleaseTime = new Date(output["releaseTime"]);
    }
    if (output["state"] !== undefined) {
        contents.State = output["state"];
    }
    if (output.tagSet === "") {
        contents.Tags = [];
    }
    if (output["tagSet"] !== undefined &&
        output["tagSet"]["item"] !== undefined) {
        const wrappedItem = output["tagSet"]["item"] instanceof Array
            ? output["tagSet"]["item"]
            : [output["tagSet"]["item"]];
        contents.Tags = deserializeAws_ec2TagList(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2HostInstance = (output, context) => {
    let contents = {
        __type: "HostInstance",
        InstanceId: undefined,
        InstanceType: undefined,
        OwnerId: undefined
    };
    if (output["instanceId"] !== undefined) {
        contents.InstanceId = output["instanceId"];
    }
    if (output["instanceType"] !== undefined) {
        contents.InstanceType = output["instanceType"];
    }
    if (output["ownerId"] !== undefined) {
        contents.OwnerId = output["ownerId"];
    }
    return contents;
};
const deserializeAws_ec2HostInstanceList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2HostInstance(entry, context));
    });
    return contents;
};
const deserializeAws_ec2HostList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2Host(entry, context));
    });
    return contents;
};
const deserializeAws_ec2HostOffering = (output, context) => {
    let contents = {
        __type: "HostOffering",
        CurrencyCode: undefined,
        Duration: undefined,
        HourlyPrice: undefined,
        InstanceFamily: undefined,
        OfferingId: undefined,
        PaymentOption: undefined,
        UpfrontPrice: undefined
    };
    if (output["currencyCode"] !== undefined) {
        contents.CurrencyCode = output["currencyCode"];
    }
    if (output["duration"] !== undefined) {
        contents.Duration = parseInt(output["duration"]);
    }
    if (output["hourlyPrice"] !== undefined) {
        contents.HourlyPrice = output["hourlyPrice"];
    }
    if (output["instanceFamily"] !== undefined) {
        contents.InstanceFamily = output["instanceFamily"];
    }
    if (output["offeringId"] !== undefined) {
        contents.OfferingId = output["offeringId"];
    }
    if (output["paymentOption"] !== undefined) {
        contents.PaymentOption = output["paymentOption"];
    }
    if (output["upfrontPrice"] !== undefined) {
        contents.UpfrontPrice = output["upfrontPrice"];
    }
    return contents;
};
const deserializeAws_ec2HostOfferingSet = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2HostOffering(entry, context));
    });
    return contents;
};
const deserializeAws_ec2HostProperties = (output, context) => {
    let contents = {
        __type: "HostProperties",
        Cores: undefined,
        InstanceFamily: undefined,
        InstanceType: undefined,
        Sockets: undefined,
        TotalVCpus: undefined
    };
    if (output["cores"] !== undefined) {
        contents.Cores = parseInt(output["cores"]);
    }
    if (output["instanceFamily"] !== undefined) {
        contents.InstanceFamily = output["instanceFamily"];
    }
    if (output["instanceType"] !== undefined) {
        contents.InstanceType = output["instanceType"];
    }
    if (output["sockets"] !== undefined) {
        contents.Sockets = parseInt(output["sockets"]);
    }
    if (output["totalVCpus"] !== undefined) {
        contents.TotalVCpus = parseInt(output["totalVCpus"]);
    }
    return contents;
};
const deserializeAws_ec2HostReservation = (output, context) => {
    let contents = {
        __type: "HostReservation",
        Count: undefined,
        CurrencyCode: undefined,
        Duration: undefined,
        End: undefined,
        HostIdSet: undefined,
        HostReservationId: undefined,
        HourlyPrice: undefined,
        InstanceFamily: undefined,
        OfferingId: undefined,
        PaymentOption: undefined,
        Start: undefined,
        State: undefined,
        Tags: undefined,
        UpfrontPrice: undefined
    };
    if (output["count"] !== undefined) {
        contents.Count = parseInt(output["count"]);
    }
    if (output["currencyCode"] !== undefined) {
        contents.CurrencyCode = output["currencyCode"];
    }
    if (output["duration"] !== undefined) {
        contents.Duration = parseInt(output["duration"]);
    }
    if (output["end"] !== undefined) {
        contents.End = new Date(output["end"]);
    }
    if (output.hostIdSet === "") {
        contents.HostIdSet = [];
    }
    if (output["hostIdSet"] !== undefined &&
        output["hostIdSet"]["item"] !== undefined) {
        const wrappedItem = output["hostIdSet"]["item"] instanceof Array
            ? output["hostIdSet"]["item"]
            : [output["hostIdSet"]["item"]];
        contents.HostIdSet = deserializeAws_ec2ResponseHostIdSet(wrappedItem, context);
    }
    if (output["hostReservationId"] !== undefined) {
        contents.HostReservationId = output["hostReservationId"];
    }
    if (output["hourlyPrice"] !== undefined) {
        contents.HourlyPrice = output["hourlyPrice"];
    }
    if (output["instanceFamily"] !== undefined) {
        contents.InstanceFamily = output["instanceFamily"];
    }
    if (output["offeringId"] !== undefined) {
        contents.OfferingId = output["offeringId"];
    }
    if (output["paymentOption"] !== undefined) {
        contents.PaymentOption = output["paymentOption"];
    }
    if (output["start"] !== undefined) {
        contents.Start = new Date(output["start"]);
    }
    if (output["state"] !== undefined) {
        contents.State = output["state"];
    }
    if (output.tagSet === "") {
        contents.Tags = [];
    }
    if (output["tagSet"] !== undefined &&
        output["tagSet"]["item"] !== undefined) {
        const wrappedItem = output["tagSet"]["item"] instanceof Array
            ? output["tagSet"]["item"]
            : [output["tagSet"]["item"]];
        contents.Tags = deserializeAws_ec2TagList(wrappedItem, context);
    }
    if (output["upfrontPrice"] !== undefined) {
        contents.UpfrontPrice = output["upfrontPrice"];
    }
    return contents;
};
const deserializeAws_ec2HostReservationSet = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2HostReservation(entry, context));
    });
    return contents;
};
const deserializeAws_ec2IKEVersionsList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2IKEVersionsListValue(entry, context));
    });
    return contents;
};
const deserializeAws_ec2IKEVersionsListValue = (output, context) => {
    let contents = {
        __type: "IKEVersionsListValue",
        Value: undefined
    };
    if (output["value"] !== undefined) {
        contents.Value = output["value"];
    }
    return contents;
};
const deserializeAws_ec2IamInstanceProfile = (output, context) => {
    let contents = {
        __type: "IamInstanceProfile",
        Arn: undefined,
        Id: undefined
    };
    if (output["arn"] !== undefined) {
        contents.Arn = output["arn"];
    }
    if (output["id"] !== undefined) {
        contents.Id = output["id"];
    }
    return contents;
};
const deserializeAws_ec2IamInstanceProfileAssociation = (output, context) => {
    let contents = {
        __type: "IamInstanceProfileAssociation",
        AssociationId: undefined,
        IamInstanceProfile: undefined,
        InstanceId: undefined,
        State: undefined,
        Timestamp: undefined
    };
    if (output["associationId"] !== undefined) {
        contents.AssociationId = output["associationId"];
    }
    if (output["iamInstanceProfile"] !== undefined) {
        contents.IamInstanceProfile = deserializeAws_ec2IamInstanceProfile(output["iamInstanceProfile"], context);
    }
    if (output["instanceId"] !== undefined) {
        contents.InstanceId = output["instanceId"];
    }
    if (output["state"] !== undefined) {
        contents.State = output["state"];
    }
    if (output["timestamp"] !== undefined) {
        contents.Timestamp = new Date(output["timestamp"]);
    }
    return contents;
};
const deserializeAws_ec2IamInstanceProfileAssociationSet = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2IamInstanceProfileAssociation(entry, context));
    });
    return contents;
};
const deserializeAws_ec2IamInstanceProfileSpecification = (output, context) => {
    let contents = {
        __type: "IamInstanceProfileSpecification",
        Arn: undefined,
        Name: undefined
    };
    if (output["arn"] !== undefined) {
        contents.Arn = output["arn"];
    }
    if (output["name"] !== undefined) {
        contents.Name = output["name"];
    }
    return contents;
};
const deserializeAws_ec2IcmpTypeCode = (output, context) => {
    let contents = {
        __type: "IcmpTypeCode",
        Code: undefined,
        Type: undefined
    };
    if (output["code"] !== undefined) {
        contents.Code = parseInt(output["code"]);
    }
    if (output["type"] !== undefined) {
        contents.Type = parseInt(output["type"]);
    }
    return contents;
};
const deserializeAws_ec2IdFormat = (output, context) => {
    let contents = {
        __type: "IdFormat",
        Deadline: undefined,
        Resource: undefined,
        UseLongIds: undefined
    };
    if (output["deadline"] !== undefined) {
        contents.Deadline = new Date(output["deadline"]);
    }
    if (output["resource"] !== undefined) {
        contents.Resource = output["resource"];
    }
    if (output["useLongIds"] !== undefined) {
        contents.UseLongIds = output["useLongIds"] == "true";
    }
    return contents;
};
const deserializeAws_ec2IdFormatList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2IdFormat(entry, context));
    });
    return contents;
};
const deserializeAws_ec2Image = (output, context) => {
    let contents = {
        __type: "Image",
        Architecture: undefined,
        BlockDeviceMappings: undefined,
        CreationDate: undefined,
        Description: undefined,
        EnaSupport: undefined,
        Hypervisor: undefined,
        ImageId: undefined,
        ImageLocation: undefined,
        ImageOwnerAlias: undefined,
        ImageType: undefined,
        KernelId: undefined,
        Name: undefined,
        OwnerId: undefined,
        Platform: undefined,
        ProductCodes: undefined,
        Public: undefined,
        RamdiskId: undefined,
        RootDeviceName: undefined,
        RootDeviceType: undefined,
        SriovNetSupport: undefined,
        State: undefined,
        StateReason: undefined,
        Tags: undefined,
        VirtualizationType: undefined
    };
    if (output["architecture"] !== undefined) {
        contents.Architecture = output["architecture"];
    }
    if (output.blockDeviceMapping === "") {
        contents.BlockDeviceMappings = [];
    }
    if (output["blockDeviceMapping"] !== undefined &&
        output["blockDeviceMapping"]["item"] !== undefined) {
        const wrappedItem = output["blockDeviceMapping"]["item"] instanceof Array
            ? output["blockDeviceMapping"]["item"]
            : [output["blockDeviceMapping"]["item"]];
        contents.BlockDeviceMappings = deserializeAws_ec2BlockDeviceMappingList(wrappedItem, context);
    }
    if (output["creationDate"] !== undefined) {
        contents.CreationDate = output["creationDate"];
    }
    if (output["description"] !== undefined) {
        contents.Description = output["description"];
    }
    if (output["enaSupport"] !== undefined) {
        contents.EnaSupport = output["enaSupport"] == "true";
    }
    if (output["hypervisor"] !== undefined) {
        contents.Hypervisor = output["hypervisor"];
    }
    if (output["imageId"] !== undefined) {
        contents.ImageId = output["imageId"];
    }
    if (output["imageLocation"] !== undefined) {
        contents.ImageLocation = output["imageLocation"];
    }
    if (output["imageOwnerAlias"] !== undefined) {
        contents.ImageOwnerAlias = output["imageOwnerAlias"];
    }
    if (output["imageType"] !== undefined) {
        contents.ImageType = output["imageType"];
    }
    if (output["kernelId"] !== undefined) {
        contents.KernelId = output["kernelId"];
    }
    if (output["name"] !== undefined) {
        contents.Name = output["name"];
    }
    if (output["imageOwnerId"] !== undefined) {
        contents.OwnerId = output["imageOwnerId"];
    }
    if (output["platform"] !== undefined) {
        contents.Platform = output["platform"];
    }
    if (output.productCodes === "") {
        contents.ProductCodes = [];
    }
    if (output["productCodes"] !== undefined &&
        output["productCodes"]["item"] !== undefined) {
        const wrappedItem = output["productCodes"]["item"] instanceof Array
            ? output["productCodes"]["item"]
            : [output["productCodes"]["item"]];
        contents.ProductCodes = deserializeAws_ec2ProductCodeList(wrappedItem, context);
    }
    if (output["isPublic"] !== undefined) {
        contents.Public = output["isPublic"] == "true";
    }
    if (output["ramdiskId"] !== undefined) {
        contents.RamdiskId = output["ramdiskId"];
    }
    if (output["rootDeviceName"] !== undefined) {
        contents.RootDeviceName = output["rootDeviceName"];
    }
    if (output["rootDeviceType"] !== undefined) {
        contents.RootDeviceType = output["rootDeviceType"];
    }
    if (output["sriovNetSupport"] !== undefined) {
        contents.SriovNetSupport = output["sriovNetSupport"];
    }
    if (output["imageState"] !== undefined) {
        contents.State = output["imageState"];
    }
    if (output["stateReason"] !== undefined) {
        contents.StateReason = deserializeAws_ec2StateReason(output["stateReason"], context);
    }
    if (output.tagSet === "") {
        contents.Tags = [];
    }
    if (output["tagSet"] !== undefined &&
        output["tagSet"]["item"] !== undefined) {
        const wrappedItem = output["tagSet"]["item"] instanceof Array
            ? output["tagSet"]["item"]
            : [output["tagSet"]["item"]];
        contents.Tags = deserializeAws_ec2TagList(wrappedItem, context);
    }
    if (output["virtualizationType"] !== undefined) {
        contents.VirtualizationType = output["virtualizationType"];
    }
    return contents;
};
const deserializeAws_ec2ImageAttribute = (output, context) => {
    let contents = {
        __type: "ImageAttribute",
        BlockDeviceMappings: undefined,
        Description: undefined,
        ImageId: undefined,
        KernelId: undefined,
        LaunchPermissions: undefined,
        ProductCodes: undefined,
        RamdiskId: undefined,
        SriovNetSupport: undefined
    };
    if (output.blockDeviceMapping === "") {
        contents.BlockDeviceMappings = [];
    }
    if (output["blockDeviceMapping"] !== undefined &&
        output["blockDeviceMapping"]["item"] !== undefined) {
        const wrappedItem = output["blockDeviceMapping"]["item"] instanceof Array
            ? output["blockDeviceMapping"]["item"]
            : [output["blockDeviceMapping"]["item"]];
        contents.BlockDeviceMappings = deserializeAws_ec2BlockDeviceMappingList(wrappedItem, context);
    }
    if (output["description"] !== undefined) {
        contents.Description = deserializeAws_ec2AttributeValue(output["description"], context);
    }
    if (output["imageId"] !== undefined) {
        contents.ImageId = output["imageId"];
    }
    if (output["kernel"] !== undefined) {
        contents.KernelId = deserializeAws_ec2AttributeValue(output["kernel"], context);
    }
    if (output.launchPermission === "") {
        contents.LaunchPermissions = [];
    }
    if (output["launchPermission"] !== undefined &&
        output["launchPermission"]["item"] !== undefined) {
        const wrappedItem = output["launchPermission"]["item"] instanceof Array
            ? output["launchPermission"]["item"]
            : [output["launchPermission"]["item"]];
        contents.LaunchPermissions = deserializeAws_ec2LaunchPermissionList(wrappedItem, context);
    }
    if (output.productCodes === "") {
        contents.ProductCodes = [];
    }
    if (output["productCodes"] !== undefined &&
        output["productCodes"]["item"] !== undefined) {
        const wrappedItem = output["productCodes"]["item"] instanceof Array
            ? output["productCodes"]["item"]
            : [output["productCodes"]["item"]];
        contents.ProductCodes = deserializeAws_ec2ProductCodeList(wrappedItem, context);
    }
    if (output["ramdisk"] !== undefined) {
        contents.RamdiskId = deserializeAws_ec2AttributeValue(output["ramdisk"], context);
    }
    if (output["sriovNetSupport"] !== undefined) {
        contents.SriovNetSupport = deserializeAws_ec2AttributeValue(output["sriovNetSupport"], context);
    }
    return contents;
};
const deserializeAws_ec2ImageList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2Image(entry, context));
    });
    return contents;
};
const deserializeAws_ec2ImportClientVpnClientCertificateRevocationListResult = (output, context) => {
    let contents = {
        __type: "ImportClientVpnClientCertificateRevocationListResult",
        Return: undefined
    };
    if (output["return"] !== undefined) {
        contents.Return = output["return"] == "true";
    }
    return contents;
};
const deserializeAws_ec2ImportImageLicenseConfigurationResponse = (output, context) => {
    let contents = {
        __type: "ImportImageLicenseConfigurationResponse",
        LicenseConfigurationArn: undefined
    };
    if (output["licenseConfigurationArn"] !== undefined) {
        contents.LicenseConfigurationArn = output["licenseConfigurationArn"];
    }
    return contents;
};
const deserializeAws_ec2ImportImageLicenseSpecificationListResponse = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2ImportImageLicenseConfigurationResponse(entry, context));
    });
    return contents;
};
const deserializeAws_ec2ImportImageResult = (output, context) => {
    let contents = {
        __type: "ImportImageResult",
        Architecture: undefined,
        Description: undefined,
        Encrypted: undefined,
        Hypervisor: undefined,
        ImageId: undefined,
        ImportTaskId: undefined,
        KmsKeyId: undefined,
        LicenseSpecifications: undefined,
        LicenseType: undefined,
        Platform: undefined,
        Progress: undefined,
        SnapshotDetails: undefined,
        Status: undefined,
        StatusMessage: undefined
    };
    if (output["architecture"] !== undefined) {
        contents.Architecture = output["architecture"];
    }
    if (output["description"] !== undefined) {
        contents.Description = output["description"];
    }
    if (output["encrypted"] !== undefined) {
        contents.Encrypted = output["encrypted"] == "true";
    }
    if (output["hypervisor"] !== undefined) {
        contents.Hypervisor = output["hypervisor"];
    }
    if (output["imageId"] !== undefined) {
        contents.ImageId = output["imageId"];
    }
    if (output["importTaskId"] !== undefined) {
        contents.ImportTaskId = output["importTaskId"];
    }
    if (output["kmsKeyId"] !== undefined) {
        contents.KmsKeyId = output["kmsKeyId"];
    }
    if (output.licenseSpecifications === "") {
        contents.LicenseSpecifications = [];
    }
    if (output["licenseSpecifications"] !== undefined &&
        output["licenseSpecifications"]["item"] !== undefined) {
        const wrappedItem = output["licenseSpecifications"]["item"] instanceof Array
            ? output["licenseSpecifications"]["item"]
            : [output["licenseSpecifications"]["item"]];
        contents.LicenseSpecifications = deserializeAws_ec2ImportImageLicenseSpecificationListResponse(wrappedItem, context);
    }
    if (output["licenseType"] !== undefined) {
        contents.LicenseType = output["licenseType"];
    }
    if (output["platform"] !== undefined) {
        contents.Platform = output["platform"];
    }
    if (output["progress"] !== undefined) {
        contents.Progress = output["progress"];
    }
    if (output.snapshotDetailSet === "") {
        contents.SnapshotDetails = [];
    }
    if (output["snapshotDetailSet"] !== undefined &&
        output["snapshotDetailSet"]["item"] !== undefined) {
        const wrappedItem = output["snapshotDetailSet"]["item"] instanceof Array
            ? output["snapshotDetailSet"]["item"]
            : [output["snapshotDetailSet"]["item"]];
        contents.SnapshotDetails = deserializeAws_ec2SnapshotDetailList(wrappedItem, context);
    }
    if (output["status"] !== undefined) {
        contents.Status = output["status"];
    }
    if (output["statusMessage"] !== undefined) {
        contents.StatusMessage = output["statusMessage"];
    }
    return contents;
};
const deserializeAws_ec2ImportImageTask = (output, context) => {
    let contents = {
        __type: "ImportImageTask",
        Architecture: undefined,
        Description: undefined,
        Encrypted: undefined,
        Hypervisor: undefined,
        ImageId: undefined,
        ImportTaskId: undefined,
        KmsKeyId: undefined,
        LicenseSpecifications: undefined,
        LicenseType: undefined,
        Platform: undefined,
        Progress: undefined,
        SnapshotDetails: undefined,
        Status: undefined,
        StatusMessage: undefined,
        Tags: undefined
    };
    if (output["architecture"] !== undefined) {
        contents.Architecture = output["architecture"];
    }
    if (output["description"] !== undefined) {
        contents.Description = output["description"];
    }
    if (output["encrypted"] !== undefined) {
        contents.Encrypted = output["encrypted"] == "true";
    }
    if (output["hypervisor"] !== undefined) {
        contents.Hypervisor = output["hypervisor"];
    }
    if (output["imageId"] !== undefined) {
        contents.ImageId = output["imageId"];
    }
    if (output["importTaskId"] !== undefined) {
        contents.ImportTaskId = output["importTaskId"];
    }
    if (output["kmsKeyId"] !== undefined) {
        contents.KmsKeyId = output["kmsKeyId"];
    }
    if (output.licenseSpecifications === "") {
        contents.LicenseSpecifications = [];
    }
    if (output["licenseSpecifications"] !== undefined &&
        output["licenseSpecifications"]["item"] !== undefined) {
        const wrappedItem = output["licenseSpecifications"]["item"] instanceof Array
            ? output["licenseSpecifications"]["item"]
            : [output["licenseSpecifications"]["item"]];
        contents.LicenseSpecifications = deserializeAws_ec2ImportImageLicenseSpecificationListResponse(wrappedItem, context);
    }
    if (output["licenseType"] !== undefined) {
        contents.LicenseType = output["licenseType"];
    }
    if (output["platform"] !== undefined) {
        contents.Platform = output["platform"];
    }
    if (output["progress"] !== undefined) {
        contents.Progress = output["progress"];
    }
    if (output.snapshotDetailSet === "") {
        contents.SnapshotDetails = [];
    }
    if (output["snapshotDetailSet"] !== undefined &&
        output["snapshotDetailSet"]["item"] !== undefined) {
        const wrappedItem = output["snapshotDetailSet"]["item"] instanceof Array
            ? output["snapshotDetailSet"]["item"]
            : [output["snapshotDetailSet"]["item"]];
        contents.SnapshotDetails = deserializeAws_ec2SnapshotDetailList(wrappedItem, context);
    }
    if (output["status"] !== undefined) {
        contents.Status = output["status"];
    }
    if (output["statusMessage"] !== undefined) {
        contents.StatusMessage = output["statusMessage"];
    }
    if (output.tagSet === "") {
        contents.Tags = [];
    }
    if (output["tagSet"] !== undefined &&
        output["tagSet"]["item"] !== undefined) {
        const wrappedItem = output["tagSet"]["item"] instanceof Array
            ? output["tagSet"]["item"]
            : [output["tagSet"]["item"]];
        contents.Tags = deserializeAws_ec2TagList(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2ImportImageTaskList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2ImportImageTask(entry, context));
    });
    return contents;
};
const deserializeAws_ec2ImportInstanceResult = (output, context) => {
    let contents = {
        __type: "ImportInstanceResult",
        ConversionTask: undefined
    };
    if (output["conversionTask"] !== undefined) {
        contents.ConversionTask = deserializeAws_ec2ConversionTask(output["conversionTask"], context);
    }
    return contents;
};
const deserializeAws_ec2ImportInstanceTaskDetails = (output, context) => {
    let contents = {
        __type: "ImportInstanceTaskDetails",
        Description: undefined,
        InstanceId: undefined,
        Platform: undefined,
        Volumes: undefined
    };
    if (output["description"] !== undefined) {
        contents.Description = output["description"];
    }
    if (output["instanceId"] !== undefined) {
        contents.InstanceId = output["instanceId"];
    }
    if (output["platform"] !== undefined) {
        contents.Platform = output["platform"];
    }
    if (output.volumes === "") {
        contents.Volumes = [];
    }
    if (output["volumes"] !== undefined &&
        output["volumes"]["item"] !== undefined) {
        const wrappedItem = output["volumes"]["item"] instanceof Array
            ? output["volumes"]["item"]
            : [output["volumes"]["item"]];
        contents.Volumes = deserializeAws_ec2ImportInstanceVolumeDetailSet(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2ImportInstanceVolumeDetailItem = (output, context) => {
    let contents = {
        __type: "ImportInstanceVolumeDetailItem",
        AvailabilityZone: undefined,
        BytesConverted: undefined,
        Description: undefined,
        Image: undefined,
        Status: undefined,
        StatusMessage: undefined,
        Volume: undefined
    };
    if (output["availabilityZone"] !== undefined) {
        contents.AvailabilityZone = output["availabilityZone"];
    }
    if (output["bytesConverted"] !== undefined) {
        contents.BytesConverted = parseInt(output["bytesConverted"]);
    }
    if (output["description"] !== undefined) {
        contents.Description = output["description"];
    }
    if (output["image"] !== undefined) {
        contents.Image = deserializeAws_ec2DiskImageDescription(output["image"], context);
    }
    if (output["status"] !== undefined) {
        contents.Status = output["status"];
    }
    if (output["statusMessage"] !== undefined) {
        contents.StatusMessage = output["statusMessage"];
    }
    if (output["volume"] !== undefined) {
        contents.Volume = deserializeAws_ec2DiskImageVolumeDescription(output["volume"], context);
    }
    return contents;
};
const deserializeAws_ec2ImportInstanceVolumeDetailSet = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2ImportInstanceVolumeDetailItem(entry, context));
    });
    return contents;
};
const deserializeAws_ec2ImportKeyPairResult = (output, context) => {
    let contents = {
        __type: "ImportKeyPairResult",
        KeyFingerprint: undefined,
        KeyName: undefined
    };
    if (output["keyFingerprint"] !== undefined) {
        contents.KeyFingerprint = output["keyFingerprint"];
    }
    if (output["keyName"] !== undefined) {
        contents.KeyName = output["keyName"];
    }
    return contents;
};
const deserializeAws_ec2ImportSnapshotResult = (output, context) => {
    let contents = {
        __type: "ImportSnapshotResult",
        Description: undefined,
        ImportTaskId: undefined,
        SnapshotTaskDetail: undefined
    };
    if (output["description"] !== undefined) {
        contents.Description = output["description"];
    }
    if (output["importTaskId"] !== undefined) {
        contents.ImportTaskId = output["importTaskId"];
    }
    if (output["snapshotTaskDetail"] !== undefined) {
        contents.SnapshotTaskDetail = deserializeAws_ec2SnapshotTaskDetail(output["snapshotTaskDetail"], context);
    }
    return contents;
};
const deserializeAws_ec2ImportSnapshotTask = (output, context) => {
    let contents = {
        __type: "ImportSnapshotTask",
        Description: undefined,
        ImportTaskId: undefined,
        SnapshotTaskDetail: undefined,
        Tags: undefined
    };
    if (output["description"] !== undefined) {
        contents.Description = output["description"];
    }
    if (output["importTaskId"] !== undefined) {
        contents.ImportTaskId = output["importTaskId"];
    }
    if (output["snapshotTaskDetail"] !== undefined) {
        contents.SnapshotTaskDetail = deserializeAws_ec2SnapshotTaskDetail(output["snapshotTaskDetail"], context);
    }
    if (output.tagSet === "") {
        contents.Tags = [];
    }
    if (output["tagSet"] !== undefined &&
        output["tagSet"]["item"] !== undefined) {
        const wrappedItem = output["tagSet"]["item"] instanceof Array
            ? output["tagSet"]["item"]
            : [output["tagSet"]["item"]];
        contents.Tags = deserializeAws_ec2TagList(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2ImportSnapshotTaskList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2ImportSnapshotTask(entry, context));
    });
    return contents;
};
const deserializeAws_ec2ImportVolumeResult = (output, context) => {
    let contents = {
        __type: "ImportVolumeResult",
        ConversionTask: undefined
    };
    if (output["conversionTask"] !== undefined) {
        contents.ConversionTask = deserializeAws_ec2ConversionTask(output["conversionTask"], context);
    }
    return contents;
};
const deserializeAws_ec2ImportVolumeTaskDetails = (output, context) => {
    let contents = {
        __type: "ImportVolumeTaskDetails",
        AvailabilityZone: undefined,
        BytesConverted: undefined,
        Description: undefined,
        Image: undefined,
        Volume: undefined
    };
    if (output["availabilityZone"] !== undefined) {
        contents.AvailabilityZone = output["availabilityZone"];
    }
    if (output["bytesConverted"] !== undefined) {
        contents.BytesConverted = parseInt(output["bytesConverted"]);
    }
    if (output["description"] !== undefined) {
        contents.Description = output["description"];
    }
    if (output["image"] !== undefined) {
        contents.Image = deserializeAws_ec2DiskImageDescription(output["image"], context);
    }
    if (output["volume"] !== undefined) {
        contents.Volume = deserializeAws_ec2DiskImageVolumeDescription(output["volume"], context);
    }
    return contents;
};
const deserializeAws_ec2InferenceAcceleratorInfo = (output, context) => {
    let contents = {
        __type: "InferenceAcceleratorInfo",
        Accelerators: undefined
    };
    if (output.accelerators === "") {
        contents.Accelerators = [];
    }
    if (output["accelerators"] !== undefined &&
        output["accelerators"]["member"] !== undefined) {
        const wrappedItem = output["accelerators"]["member"] instanceof Array
            ? output["accelerators"]["member"]
            : [output["accelerators"]["member"]];
        contents.Accelerators = deserializeAws_ec2InferenceDeviceInfoList(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2InferenceDeviceInfo = (output, context) => {
    let contents = {
        __type: "InferenceDeviceInfo",
        Count: undefined,
        Manufacturer: undefined,
        Name: undefined
    };
    if (output["count"] !== undefined) {
        contents.Count = parseInt(output["count"]);
    }
    if (output["manufacturer"] !== undefined) {
        contents.Manufacturer = output["manufacturer"];
    }
    if (output["name"] !== undefined) {
        contents.Name = output["name"];
    }
    return contents;
};
const deserializeAws_ec2InferenceDeviceInfoList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2InferenceDeviceInfo(entry, context));
    });
    return contents;
};
const deserializeAws_ec2Instance = (output, context) => {
    let contents = {
        __type: "Instance",
        AmiLaunchIndex: undefined,
        Architecture: undefined,
        BlockDeviceMappings: undefined,
        CapacityReservationId: undefined,
        CapacityReservationSpecification: undefined,
        ClientToken: undefined,
        CpuOptions: undefined,
        EbsOptimized: undefined,
        ElasticGpuAssociations: undefined,
        ElasticInferenceAcceleratorAssociations: undefined,
        EnaSupport: undefined,
        HibernationOptions: undefined,
        Hypervisor: undefined,
        IamInstanceProfile: undefined,
        ImageId: undefined,
        InstanceId: undefined,
        InstanceLifecycle: undefined,
        InstanceType: undefined,
        KernelId: undefined,
        KeyName: undefined,
        LaunchTime: undefined,
        Licenses: undefined,
        MetadataOptions: undefined,
        Monitoring: undefined,
        NetworkInterfaces: undefined,
        OutpostArn: undefined,
        Placement: undefined,
        Platform: undefined,
        PrivateDnsName: undefined,
        PrivateIpAddress: undefined,
        ProductCodes: undefined,
        PublicDnsName: undefined,
        PublicIpAddress: undefined,
        RamdiskId: undefined,
        RootDeviceName: undefined,
        RootDeviceType: undefined,
        SecurityGroups: undefined,
        SourceDestCheck: undefined,
        SpotInstanceRequestId: undefined,
        SriovNetSupport: undefined,
        State: undefined,
        StateReason: undefined,
        StateTransitionReason: undefined,
        SubnetId: undefined,
        Tags: undefined,
        VirtualizationType: undefined,
        VpcId: undefined
    };
    if (output["amiLaunchIndex"] !== undefined) {
        contents.AmiLaunchIndex = parseInt(output["amiLaunchIndex"]);
    }
    if (output["architecture"] !== undefined) {
        contents.Architecture = output["architecture"];
    }
    if (output.blockDeviceMapping === "") {
        contents.BlockDeviceMappings = [];
    }
    if (output["blockDeviceMapping"] !== undefined &&
        output["blockDeviceMapping"]["item"] !== undefined) {
        const wrappedItem = output["blockDeviceMapping"]["item"] instanceof Array
            ? output["blockDeviceMapping"]["item"]
            : [output["blockDeviceMapping"]["item"]];
        contents.BlockDeviceMappings = deserializeAws_ec2InstanceBlockDeviceMappingList(wrappedItem, context);
    }
    if (output["capacityReservationId"] !== undefined) {
        contents.CapacityReservationId = output["capacityReservationId"];
    }
    if (output["capacityReservationSpecification"] !== undefined) {
        contents.CapacityReservationSpecification = deserializeAws_ec2CapacityReservationSpecificationResponse(output["capacityReservationSpecification"], context);
    }
    if (output["clientToken"] !== undefined) {
        contents.ClientToken = output["clientToken"];
    }
    if (output["cpuOptions"] !== undefined) {
        contents.CpuOptions = deserializeAws_ec2CpuOptions(output["cpuOptions"], context);
    }
    if (output["ebsOptimized"] !== undefined) {
        contents.EbsOptimized = output["ebsOptimized"] == "true";
    }
    if (output.elasticGpuAssociationSet === "") {
        contents.ElasticGpuAssociations = [];
    }
    if (output["elasticGpuAssociationSet"] !== undefined &&
        output["elasticGpuAssociationSet"]["item"] !== undefined) {
        const wrappedItem = output["elasticGpuAssociationSet"]["item"] instanceof Array
            ? output["elasticGpuAssociationSet"]["item"]
            : [output["elasticGpuAssociationSet"]["item"]];
        contents.ElasticGpuAssociations = deserializeAws_ec2ElasticGpuAssociationList(wrappedItem, context);
    }
    if (output.elasticInferenceAcceleratorAssociationSet === "") {
        contents.ElasticInferenceAcceleratorAssociations = [];
    }
    if (output["elasticInferenceAcceleratorAssociationSet"] !== undefined &&
        output["elasticInferenceAcceleratorAssociationSet"]["item"] !== undefined) {
        const wrappedItem = output["elasticInferenceAcceleratorAssociationSet"]["item"] instanceof
            Array
            ? output["elasticInferenceAcceleratorAssociationSet"]["item"]
            : [output["elasticInferenceAcceleratorAssociationSet"]["item"]];
        contents.ElasticInferenceAcceleratorAssociations = deserializeAws_ec2ElasticInferenceAcceleratorAssociationList(wrappedItem, context);
    }
    if (output["enaSupport"] !== undefined) {
        contents.EnaSupport = output["enaSupport"] == "true";
    }
    if (output["hibernationOptions"] !== undefined) {
        contents.HibernationOptions = deserializeAws_ec2HibernationOptions(output["hibernationOptions"], context);
    }
    if (output["hypervisor"] !== undefined) {
        contents.Hypervisor = output["hypervisor"];
    }
    if (output["iamInstanceProfile"] !== undefined) {
        contents.IamInstanceProfile = deserializeAws_ec2IamInstanceProfile(output["iamInstanceProfile"], context);
    }
    if (output["imageId"] !== undefined) {
        contents.ImageId = output["imageId"];
    }
    if (output["instanceId"] !== undefined) {
        contents.InstanceId = output["instanceId"];
    }
    if (output["instanceLifecycle"] !== undefined) {
        contents.InstanceLifecycle = output["instanceLifecycle"];
    }
    if (output["instanceType"] !== undefined) {
        contents.InstanceType = output["instanceType"];
    }
    if (output["kernelId"] !== undefined) {
        contents.KernelId = output["kernelId"];
    }
    if (output["keyName"] !== undefined) {
        contents.KeyName = output["keyName"];
    }
    if (output["launchTime"] !== undefined) {
        contents.LaunchTime = new Date(output["launchTime"]);
    }
    if (output.licenseSet === "") {
        contents.Licenses = [];
    }
    if (output["licenseSet"] !== undefined &&
        output["licenseSet"]["item"] !== undefined) {
        const wrappedItem = output["licenseSet"]["item"] instanceof Array
            ? output["licenseSet"]["item"]
            : [output["licenseSet"]["item"]];
        contents.Licenses = deserializeAws_ec2LicenseList(wrappedItem, context);
    }
    if (output["metadataOptions"] !== undefined) {
        contents.MetadataOptions = deserializeAws_ec2InstanceMetadataOptionsResponse(output["metadataOptions"], context);
    }
    if (output["monitoring"] !== undefined) {
        contents.Monitoring = deserializeAws_ec2Monitoring(output["monitoring"], context);
    }
    if (output.networkInterfaceSet === "") {
        contents.NetworkInterfaces = [];
    }
    if (output["networkInterfaceSet"] !== undefined &&
        output["networkInterfaceSet"]["item"] !== undefined) {
        const wrappedItem = output["networkInterfaceSet"]["item"] instanceof Array
            ? output["networkInterfaceSet"]["item"]
            : [output["networkInterfaceSet"]["item"]];
        contents.NetworkInterfaces = deserializeAws_ec2InstanceNetworkInterfaceList(wrappedItem, context);
    }
    if (output["outpostArn"] !== undefined) {
        contents.OutpostArn = output["outpostArn"];
    }
    if (output["placement"] !== undefined) {
        contents.Placement = deserializeAws_ec2Placement(output["placement"], context);
    }
    if (output["platform"] !== undefined) {
        contents.Platform = output["platform"];
    }
    if (output["privateDnsName"] !== undefined) {
        contents.PrivateDnsName = output["privateDnsName"];
    }
    if (output["privateIpAddress"] !== undefined) {
        contents.PrivateIpAddress = output["privateIpAddress"];
    }
    if (output.productCodes === "") {
        contents.ProductCodes = [];
    }
    if (output["productCodes"] !== undefined &&
        output["productCodes"]["item"] !== undefined) {
        const wrappedItem = output["productCodes"]["item"] instanceof Array
            ? output["productCodes"]["item"]
            : [output["productCodes"]["item"]];
        contents.ProductCodes = deserializeAws_ec2ProductCodeList(wrappedItem, context);
    }
    if (output["dnsName"] !== undefined) {
        contents.PublicDnsName = output["dnsName"];
    }
    if (output["ipAddress"] !== undefined) {
        contents.PublicIpAddress = output["ipAddress"];
    }
    if (output["ramdiskId"] !== undefined) {
        contents.RamdiskId = output["ramdiskId"];
    }
    if (output["rootDeviceName"] !== undefined) {
        contents.RootDeviceName = output["rootDeviceName"];
    }
    if (output["rootDeviceType"] !== undefined) {
        contents.RootDeviceType = output["rootDeviceType"];
    }
    if (output.groupSet === "") {
        contents.SecurityGroups = [];
    }
    if (output["groupSet"] !== undefined &&
        output["groupSet"]["item"] !== undefined) {
        const wrappedItem = output["groupSet"]["item"] instanceof Array
            ? output["groupSet"]["item"]
            : [output["groupSet"]["item"]];
        contents.SecurityGroups = deserializeAws_ec2GroupIdentifierList(wrappedItem, context);
    }
    if (output["sourceDestCheck"] !== undefined) {
        contents.SourceDestCheck = output["sourceDestCheck"] == "true";
    }
    if (output["spotInstanceRequestId"] !== undefined) {
        contents.SpotInstanceRequestId = output["spotInstanceRequestId"];
    }
    if (output["sriovNetSupport"] !== undefined) {
        contents.SriovNetSupport = output["sriovNetSupport"];
    }
    if (output["instanceState"] !== undefined) {
        contents.State = deserializeAws_ec2InstanceState(output["instanceState"], context);
    }
    if (output["stateReason"] !== undefined) {
        contents.StateReason = deserializeAws_ec2StateReason(output["stateReason"], context);
    }
    if (output["reason"] !== undefined) {
        contents.StateTransitionReason = output["reason"];
    }
    if (output["subnetId"] !== undefined) {
        contents.SubnetId = output["subnetId"];
    }
    if (output.tagSet === "") {
        contents.Tags = [];
    }
    if (output["tagSet"] !== undefined &&
        output["tagSet"]["item"] !== undefined) {
        const wrappedItem = output["tagSet"]["item"] instanceof Array
            ? output["tagSet"]["item"]
            : [output["tagSet"]["item"]];
        contents.Tags = deserializeAws_ec2TagList(wrappedItem, context);
    }
    if (output["virtualizationType"] !== undefined) {
        contents.VirtualizationType = output["virtualizationType"];
    }
    if (output["vpcId"] !== undefined) {
        contents.VpcId = output["vpcId"];
    }
    return contents;
};
const deserializeAws_ec2InstanceAttribute = (output, context) => {
    let contents = {
        __type: "InstanceAttribute",
        BlockDeviceMappings: undefined,
        DisableApiTermination: undefined,
        EbsOptimized: undefined,
        EnaSupport: undefined,
        Groups: undefined,
        InstanceId: undefined,
        InstanceInitiatedShutdownBehavior: undefined,
        InstanceType: undefined,
        KernelId: undefined,
        ProductCodes: undefined,
        RamdiskId: undefined,
        RootDeviceName: undefined,
        SourceDestCheck: undefined,
        SriovNetSupport: undefined,
        UserData: undefined
    };
    if (output.blockDeviceMapping === "") {
        contents.BlockDeviceMappings = [];
    }
    if (output["blockDeviceMapping"] !== undefined &&
        output["blockDeviceMapping"]["item"] !== undefined) {
        const wrappedItem = output["blockDeviceMapping"]["item"] instanceof Array
            ? output["blockDeviceMapping"]["item"]
            : [output["blockDeviceMapping"]["item"]];
        contents.BlockDeviceMappings = deserializeAws_ec2InstanceBlockDeviceMappingList(wrappedItem, context);
    }
    if (output["disableApiTermination"] !== undefined) {
        contents.DisableApiTermination = deserializeAws_ec2AttributeBooleanValue(output["disableApiTermination"], context);
    }
    if (output["ebsOptimized"] !== undefined) {
        contents.EbsOptimized = deserializeAws_ec2AttributeBooleanValue(output["ebsOptimized"], context);
    }
    if (output["enaSupport"] !== undefined) {
        contents.EnaSupport = deserializeAws_ec2AttributeBooleanValue(output["enaSupport"], context);
    }
    if (output.groupSet === "") {
        contents.Groups = [];
    }
    if (output["groupSet"] !== undefined &&
        output["groupSet"]["item"] !== undefined) {
        const wrappedItem = output["groupSet"]["item"] instanceof Array
            ? output["groupSet"]["item"]
            : [output["groupSet"]["item"]];
        contents.Groups = deserializeAws_ec2GroupIdentifierList(wrappedItem, context);
    }
    if (output["instanceId"] !== undefined) {
        contents.InstanceId = output["instanceId"];
    }
    if (output["instanceInitiatedShutdownBehavior"] !== undefined) {
        contents.InstanceInitiatedShutdownBehavior = deserializeAws_ec2AttributeValue(output["instanceInitiatedShutdownBehavior"], context);
    }
    if (output["instanceType"] !== undefined) {
        contents.InstanceType = deserializeAws_ec2AttributeValue(output["instanceType"], context);
    }
    if (output["kernel"] !== undefined) {
        contents.KernelId = deserializeAws_ec2AttributeValue(output["kernel"], context);
    }
    if (output.productCodes === "") {
        contents.ProductCodes = [];
    }
    if (output["productCodes"] !== undefined &&
        output["productCodes"]["item"] !== undefined) {
        const wrappedItem = output["productCodes"]["item"] instanceof Array
            ? output["productCodes"]["item"]
            : [output["productCodes"]["item"]];
        contents.ProductCodes = deserializeAws_ec2ProductCodeList(wrappedItem, context);
    }
    if (output["ramdisk"] !== undefined) {
        contents.RamdiskId = deserializeAws_ec2AttributeValue(output["ramdisk"], context);
    }
    if (output["rootDeviceName"] !== undefined) {
        contents.RootDeviceName = deserializeAws_ec2AttributeValue(output["rootDeviceName"], context);
    }
    if (output["sourceDestCheck"] !== undefined) {
        contents.SourceDestCheck = deserializeAws_ec2AttributeBooleanValue(output["sourceDestCheck"], context);
    }
    if (output["sriovNetSupport"] !== undefined) {
        contents.SriovNetSupport = deserializeAws_ec2AttributeValue(output["sriovNetSupport"], context);
    }
    if (output["userData"] !== undefined) {
        contents.UserData = deserializeAws_ec2AttributeValue(output["userData"], context);
    }
    return contents;
};
const deserializeAws_ec2InstanceBlockDeviceMapping = (output, context) => {
    let contents = {
        __type: "InstanceBlockDeviceMapping",
        DeviceName: undefined,
        Ebs: undefined
    };
    if (output["deviceName"] !== undefined) {
        contents.DeviceName = output["deviceName"];
    }
    if (output["ebs"] !== undefined) {
        contents.Ebs = deserializeAws_ec2EbsInstanceBlockDevice(output["ebs"], context);
    }
    return contents;
};
const deserializeAws_ec2InstanceBlockDeviceMappingList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2InstanceBlockDeviceMapping(entry, context));
    });
    return contents;
};
const deserializeAws_ec2InstanceCapacity = (output, context) => {
    let contents = {
        __type: "InstanceCapacity",
        AvailableCapacity: undefined,
        InstanceType: undefined,
        TotalCapacity: undefined
    };
    if (output["availableCapacity"] !== undefined) {
        contents.AvailableCapacity = parseInt(output["availableCapacity"]);
    }
    if (output["instanceType"] !== undefined) {
        contents.InstanceType = output["instanceType"];
    }
    if (output["totalCapacity"] !== undefined) {
        contents.TotalCapacity = parseInt(output["totalCapacity"]);
    }
    return contents;
};
const deserializeAws_ec2InstanceCount = (output, context) => {
    let contents = {
        __type: "InstanceCount",
        InstanceCount: undefined,
        State: undefined
    };
    if (output["instanceCount"] !== undefined) {
        contents.InstanceCount = parseInt(output["instanceCount"]);
    }
    if (output["state"] !== undefined) {
        contents.State = output["state"];
    }
    return contents;
};
const deserializeAws_ec2InstanceCountList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2InstanceCount(entry, context));
    });
    return contents;
};
const deserializeAws_ec2InstanceCreditSpecification = (output, context) => {
    let contents = {
        __type: "InstanceCreditSpecification",
        CpuCredits: undefined,
        InstanceId: undefined
    };
    if (output["cpuCredits"] !== undefined) {
        contents.CpuCredits = output["cpuCredits"];
    }
    if (output["instanceId"] !== undefined) {
        contents.InstanceId = output["instanceId"];
    }
    return contents;
};
const deserializeAws_ec2InstanceCreditSpecificationList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2InstanceCreditSpecification(entry, context));
    });
    return contents;
};
const deserializeAws_ec2InstanceExportDetails = (output, context) => {
    let contents = {
        __type: "InstanceExportDetails",
        InstanceId: undefined,
        TargetEnvironment: undefined
    };
    if (output["instanceId"] !== undefined) {
        contents.InstanceId = output["instanceId"];
    }
    if (output["targetEnvironment"] !== undefined) {
        contents.TargetEnvironment = output["targetEnvironment"];
    }
    return contents;
};
const deserializeAws_ec2InstanceFamilyCreditSpecification = (output, context) => {
    let contents = {
        __type: "InstanceFamilyCreditSpecification",
        CpuCredits: undefined,
        InstanceFamily: undefined
    };
    if (output["cpuCredits"] !== undefined) {
        contents.CpuCredits = output["cpuCredits"];
    }
    if (output["instanceFamily"] !== undefined) {
        contents.InstanceFamily = output["instanceFamily"];
    }
    return contents;
};
const deserializeAws_ec2InstanceIdSet = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(entry);
    });
    return contents;
};
const deserializeAws_ec2InstanceIdsSet = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(entry);
    });
    return contents;
};
const deserializeAws_ec2InstanceIpv6Address = (output, context) => {
    let contents = {
        __type: "InstanceIpv6Address",
        Ipv6Address: undefined
    };
    if (output["ipv6Address"] !== undefined) {
        contents.Ipv6Address = output["ipv6Address"];
    }
    return contents;
};
const deserializeAws_ec2InstanceIpv6AddressList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2InstanceIpv6Address(entry, context));
    });
    return contents;
};
const deserializeAws_ec2InstanceList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2Instance(entry, context));
    });
    return contents;
};
const deserializeAws_ec2InstanceMetadataOptionsResponse = (output, context) => {
    let contents = {
        __type: "InstanceMetadataOptionsResponse",
        HttpEndpoint: undefined,
        HttpPutResponseHopLimit: undefined,
        HttpTokens: undefined,
        State: undefined
    };
    if (output["httpEndpoint"] !== undefined) {
        contents.HttpEndpoint = output["httpEndpoint"];
    }
    if (output["httpPutResponseHopLimit"] !== undefined) {
        contents.HttpPutResponseHopLimit = parseInt(output["httpPutResponseHopLimit"]);
    }
    if (output["httpTokens"] !== undefined) {
        contents.HttpTokens = output["httpTokens"];
    }
    if (output["state"] !== undefined) {
        contents.State = output["state"];
    }
    return contents;
};
const deserializeAws_ec2InstanceMonitoring = (output, context) => {
    let contents = {
        __type: "InstanceMonitoring",
        InstanceId: undefined,
        Monitoring: undefined
    };
    if (output["instanceId"] !== undefined) {
        contents.InstanceId = output["instanceId"];
    }
    if (output["monitoring"] !== undefined) {
        contents.Monitoring = deserializeAws_ec2Monitoring(output["monitoring"], context);
    }
    return contents;
};
const deserializeAws_ec2InstanceMonitoringList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2InstanceMonitoring(entry, context));
    });
    return contents;
};
const deserializeAws_ec2InstanceNetworkInterface = (output, context) => {
    let contents = {
        __type: "InstanceNetworkInterface",
        Association: undefined,
        Attachment: undefined,
        Description: undefined,
        Groups: undefined,
        InterfaceType: undefined,
        Ipv6Addresses: undefined,
        MacAddress: undefined,
        NetworkInterfaceId: undefined,
        OwnerId: undefined,
        PrivateDnsName: undefined,
        PrivateIpAddress: undefined,
        PrivateIpAddresses: undefined,
        SourceDestCheck: undefined,
        Status: undefined,
        SubnetId: undefined,
        VpcId: undefined
    };
    if (output["association"] !== undefined) {
        contents.Association = deserializeAws_ec2InstanceNetworkInterfaceAssociation(output["association"], context);
    }
    if (output["attachment"] !== undefined) {
        contents.Attachment = deserializeAws_ec2InstanceNetworkInterfaceAttachment(output["attachment"], context);
    }
    if (output["description"] !== undefined) {
        contents.Description = output["description"];
    }
    if (output.groupSet === "") {
        contents.Groups = [];
    }
    if (output["groupSet"] !== undefined &&
        output["groupSet"]["item"] !== undefined) {
        const wrappedItem = output["groupSet"]["item"] instanceof Array
            ? output["groupSet"]["item"]
            : [output["groupSet"]["item"]];
        contents.Groups = deserializeAws_ec2GroupIdentifierList(wrappedItem, context);
    }
    if (output["interfaceType"] !== undefined) {
        contents.InterfaceType = output["interfaceType"];
    }
    if (output.ipv6AddressesSet === "") {
        contents.Ipv6Addresses = [];
    }
    if (output["ipv6AddressesSet"] !== undefined &&
        output["ipv6AddressesSet"]["item"] !== undefined) {
        const wrappedItem = output["ipv6AddressesSet"]["item"] instanceof Array
            ? output["ipv6AddressesSet"]["item"]
            : [output["ipv6AddressesSet"]["item"]];
        contents.Ipv6Addresses = deserializeAws_ec2InstanceIpv6AddressList(wrappedItem, context);
    }
    if (output["macAddress"] !== undefined) {
        contents.MacAddress = output["macAddress"];
    }
    if (output["networkInterfaceId"] !== undefined) {
        contents.NetworkInterfaceId = output["networkInterfaceId"];
    }
    if (output["ownerId"] !== undefined) {
        contents.OwnerId = output["ownerId"];
    }
    if (output["privateDnsName"] !== undefined) {
        contents.PrivateDnsName = output["privateDnsName"];
    }
    if (output["privateIpAddress"] !== undefined) {
        contents.PrivateIpAddress = output["privateIpAddress"];
    }
    if (output.privateIpAddressesSet === "") {
        contents.PrivateIpAddresses = [];
    }
    if (output["privateIpAddressesSet"] !== undefined &&
        output["privateIpAddressesSet"]["item"] !== undefined) {
        const wrappedItem = output["privateIpAddressesSet"]["item"] instanceof Array
            ? output["privateIpAddressesSet"]["item"]
            : [output["privateIpAddressesSet"]["item"]];
        contents.PrivateIpAddresses = deserializeAws_ec2InstancePrivateIpAddressList(wrappedItem, context);
    }
    if (output["sourceDestCheck"] !== undefined) {
        contents.SourceDestCheck = output["sourceDestCheck"] == "true";
    }
    if (output["status"] !== undefined) {
        contents.Status = output["status"];
    }
    if (output["subnetId"] !== undefined) {
        contents.SubnetId = output["subnetId"];
    }
    if (output["vpcId"] !== undefined) {
        contents.VpcId = output["vpcId"];
    }
    return contents;
};
const deserializeAws_ec2InstanceNetworkInterfaceAssociation = (output, context) => {
    let contents = {
        __type: "InstanceNetworkInterfaceAssociation",
        IpOwnerId: undefined,
        PublicDnsName: undefined,
        PublicIp: undefined
    };
    if (output["ipOwnerId"] !== undefined) {
        contents.IpOwnerId = output["ipOwnerId"];
    }
    if (output["publicDnsName"] !== undefined) {
        contents.PublicDnsName = output["publicDnsName"];
    }
    if (output["publicIp"] !== undefined) {
        contents.PublicIp = output["publicIp"];
    }
    return contents;
};
const deserializeAws_ec2InstanceNetworkInterfaceAttachment = (output, context) => {
    let contents = {
        __type: "InstanceNetworkInterfaceAttachment",
        AttachTime: undefined,
        AttachmentId: undefined,
        DeleteOnTermination: undefined,
        DeviceIndex: undefined,
        Status: undefined
    };
    if (output["attachTime"] !== undefined) {
        contents.AttachTime = new Date(output["attachTime"]);
    }
    if (output["attachmentId"] !== undefined) {
        contents.AttachmentId = output["attachmentId"];
    }
    if (output["deleteOnTermination"] !== undefined) {
        contents.DeleteOnTermination = output["deleteOnTermination"] == "true";
    }
    if (output["deviceIndex"] !== undefined) {
        contents.DeviceIndex = parseInt(output["deviceIndex"]);
    }
    if (output["status"] !== undefined) {
        contents.Status = output["status"];
    }
    return contents;
};
const deserializeAws_ec2InstanceNetworkInterfaceList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2InstanceNetworkInterface(entry, context));
    });
    return contents;
};
const deserializeAws_ec2InstanceNetworkInterfaceSpecification = (output, context) => {
    let contents = {
        __type: "InstanceNetworkInterfaceSpecification",
        AssociatePublicIpAddress: undefined,
        DeleteOnTermination: undefined,
        Description: undefined,
        DeviceIndex: undefined,
        Groups: undefined,
        InterfaceType: undefined,
        Ipv6AddressCount: undefined,
        Ipv6Addresses: undefined,
        NetworkInterfaceId: undefined,
        PrivateIpAddress: undefined,
        PrivateIpAddresses: undefined,
        SecondaryPrivateIpAddressCount: undefined,
        SubnetId: undefined
    };
    if (output["associatePublicIpAddress"] !== undefined) {
        contents.AssociatePublicIpAddress =
            output["associatePublicIpAddress"] == "true";
    }
    if (output["deleteOnTermination"] !== undefined) {
        contents.DeleteOnTermination = output["deleteOnTermination"] == "true";
    }
    if (output["description"] !== undefined) {
        contents.Description = output["description"];
    }
    if (output["deviceIndex"] !== undefined) {
        contents.DeviceIndex = parseInt(output["deviceIndex"]);
    }
    if (output.SecurityGroupId === "") {
        contents.Groups = [];
    }
    if (output["SecurityGroupId"] !== undefined &&
        output["SecurityGroupId"]["SecurityGroupId"] !== undefined) {
        const wrappedItem = output["SecurityGroupId"]["SecurityGroupId"] instanceof Array
            ? output["SecurityGroupId"]["SecurityGroupId"]
            : [output["SecurityGroupId"]["SecurityGroupId"]];
        contents.Groups = deserializeAws_ec2SecurityGroupIdStringList(wrappedItem, context);
    }
    if (output["InterfaceType"] !== undefined) {
        contents.InterfaceType = output["InterfaceType"];
    }
    if (output["ipv6AddressCount"] !== undefined) {
        contents.Ipv6AddressCount = parseInt(output["ipv6AddressCount"]);
    }
    if (output.ipv6AddressesSet === "") {
        contents.Ipv6Addresses = [];
    }
    if (output["ipv6AddressesSet"] !== undefined &&
        output["ipv6AddressesSet"]["item"] !== undefined) {
        const wrappedItem = output["ipv6AddressesSet"]["item"] instanceof Array
            ? output["ipv6AddressesSet"]["item"]
            : [output["ipv6AddressesSet"]["item"]];
        contents.Ipv6Addresses = deserializeAws_ec2InstanceIpv6AddressList(wrappedItem, context);
    }
    if (output["networkInterfaceId"] !== undefined) {
        contents.NetworkInterfaceId = output["networkInterfaceId"];
    }
    if (output["privateIpAddress"] !== undefined) {
        contents.PrivateIpAddress = output["privateIpAddress"];
    }
    if (output.privateIpAddressesSet === "") {
        contents.PrivateIpAddresses = [];
    }
    if (output["privateIpAddressesSet"] !== undefined &&
        output["privateIpAddressesSet"]["item"] !== undefined) {
        const wrappedItem = output["privateIpAddressesSet"]["item"] instanceof Array
            ? output["privateIpAddressesSet"]["item"]
            : [output["privateIpAddressesSet"]["item"]];
        contents.PrivateIpAddresses = deserializeAws_ec2PrivateIpAddressSpecificationList(wrappedItem, context);
    }
    if (output["secondaryPrivateIpAddressCount"] !== undefined) {
        contents.SecondaryPrivateIpAddressCount = parseInt(output["secondaryPrivateIpAddressCount"]);
    }
    if (output["subnetId"] !== undefined) {
        contents.SubnetId = output["subnetId"];
    }
    return contents;
};
const deserializeAws_ec2InstanceNetworkInterfaceSpecificationList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2InstanceNetworkInterfaceSpecification(entry, context));
    });
    return contents;
};
const deserializeAws_ec2InstancePrivateIpAddress = (output, context) => {
    let contents = {
        __type: "InstancePrivateIpAddress",
        Association: undefined,
        Primary: undefined,
        PrivateDnsName: undefined,
        PrivateIpAddress: undefined
    };
    if (output["association"] !== undefined) {
        contents.Association = deserializeAws_ec2InstanceNetworkInterfaceAssociation(output["association"], context);
    }
    if (output["primary"] !== undefined) {
        contents.Primary = output["primary"] == "true";
    }
    if (output["privateDnsName"] !== undefined) {
        contents.PrivateDnsName = output["privateDnsName"];
    }
    if (output["privateIpAddress"] !== undefined) {
        contents.PrivateIpAddress = output["privateIpAddress"];
    }
    return contents;
};
const deserializeAws_ec2InstancePrivateIpAddressList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2InstancePrivateIpAddress(entry, context));
    });
    return contents;
};
const deserializeAws_ec2InstanceState = (output, context) => {
    let contents = {
        __type: "InstanceState",
        Code: undefined,
        Name: undefined
    };
    if (output["code"] !== undefined) {
        contents.Code = parseInt(output["code"]);
    }
    if (output["name"] !== undefined) {
        contents.Name = output["name"];
    }
    return contents;
};
const deserializeAws_ec2InstanceStateChange = (output, context) => {
    let contents = {
        __type: "InstanceStateChange",
        CurrentState: undefined,
        InstanceId: undefined,
        PreviousState: undefined
    };
    if (output["currentState"] !== undefined) {
        contents.CurrentState = deserializeAws_ec2InstanceState(output["currentState"], context);
    }
    if (output["instanceId"] !== undefined) {
        contents.InstanceId = output["instanceId"];
    }
    if (output["previousState"] !== undefined) {
        contents.PreviousState = deserializeAws_ec2InstanceState(output["previousState"], context);
    }
    return contents;
};
const deserializeAws_ec2InstanceStateChangeList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2InstanceStateChange(entry, context));
    });
    return contents;
};
const deserializeAws_ec2InstanceStatus = (output, context) => {
    let contents = {
        __type: "InstanceStatus",
        AvailabilityZone: undefined,
        Events: undefined,
        InstanceId: undefined,
        InstanceState: undefined,
        InstanceStatus: undefined,
        OutpostArn: undefined,
        SystemStatus: undefined
    };
    if (output["availabilityZone"] !== undefined) {
        contents.AvailabilityZone = output["availabilityZone"];
    }
    if (output.eventsSet === "") {
        contents.Events = [];
    }
    if (output["eventsSet"] !== undefined &&
        output["eventsSet"]["item"] !== undefined) {
        const wrappedItem = output["eventsSet"]["item"] instanceof Array
            ? output["eventsSet"]["item"]
            : [output["eventsSet"]["item"]];
        contents.Events = deserializeAws_ec2InstanceStatusEventList(wrappedItem, context);
    }
    if (output["instanceId"] !== undefined) {
        contents.InstanceId = output["instanceId"];
    }
    if (output["instanceState"] !== undefined) {
        contents.InstanceState = deserializeAws_ec2InstanceState(output["instanceState"], context);
    }
    if (output["instanceStatus"] !== undefined) {
        contents.InstanceStatus = deserializeAws_ec2InstanceStatusSummary(output["instanceStatus"], context);
    }
    if (output["outpostArn"] !== undefined) {
        contents.OutpostArn = output["outpostArn"];
    }
    if (output["systemStatus"] !== undefined) {
        contents.SystemStatus = deserializeAws_ec2InstanceStatusSummary(output["systemStatus"], context);
    }
    return contents;
};
const deserializeAws_ec2InstanceStatusDetails = (output, context) => {
    let contents = {
        __type: "InstanceStatusDetails",
        ImpairedSince: undefined,
        Name: undefined,
        Status: undefined
    };
    if (output["impairedSince"] !== undefined) {
        contents.ImpairedSince = new Date(output["impairedSince"]);
    }
    if (output["name"] !== undefined) {
        contents.Name = output["name"];
    }
    if (output["status"] !== undefined) {
        contents.Status = output["status"];
    }
    return contents;
};
const deserializeAws_ec2InstanceStatusDetailsList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2InstanceStatusDetails(entry, context));
    });
    return contents;
};
const deserializeAws_ec2InstanceStatusEvent = (output, context) => {
    let contents = {
        __type: "InstanceStatusEvent",
        Code: undefined,
        Description: undefined,
        InstanceEventId: undefined,
        NotAfter: undefined,
        NotBefore: undefined,
        NotBeforeDeadline: undefined
    };
    if (output["code"] !== undefined) {
        contents.Code = output["code"];
    }
    if (output["description"] !== undefined) {
        contents.Description = output["description"];
    }
    if (output["instanceEventId"] !== undefined) {
        contents.InstanceEventId = output["instanceEventId"];
    }
    if (output["notAfter"] !== undefined) {
        contents.NotAfter = new Date(output["notAfter"]);
    }
    if (output["notBefore"] !== undefined) {
        contents.NotBefore = new Date(output["notBefore"]);
    }
    if (output["notBeforeDeadline"] !== undefined) {
        contents.NotBeforeDeadline = new Date(output["notBeforeDeadline"]);
    }
    return contents;
};
const deserializeAws_ec2InstanceStatusEventList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2InstanceStatusEvent(entry, context));
    });
    return contents;
};
const deserializeAws_ec2InstanceStatusList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2InstanceStatus(entry, context));
    });
    return contents;
};
const deserializeAws_ec2InstanceStatusSummary = (output, context) => {
    let contents = {
        __type: "InstanceStatusSummary",
        Details: undefined,
        Status: undefined
    };
    if (output.details === "") {
        contents.Details = [];
    }
    if (output["details"] !== undefined &&
        output["details"]["item"] !== undefined) {
        const wrappedItem = output["details"]["item"] instanceof Array
            ? output["details"]["item"]
            : [output["details"]["item"]];
        contents.Details = deserializeAws_ec2InstanceStatusDetailsList(wrappedItem, context);
    }
    if (output["status"] !== undefined) {
        contents.Status = output["status"];
    }
    return contents;
};
const deserializeAws_ec2InstanceStorageInfo = (output, context) => {
    let contents = {
        __type: "InstanceStorageInfo",
        Disks: undefined,
        TotalSizeInGB: undefined
    };
    if (output.disks === "") {
        contents.Disks = [];
    }
    if (output["disks"] !== undefined && output["disks"]["item"] !== undefined) {
        const wrappedItem = output["disks"]["item"] instanceof Array
            ? output["disks"]["item"]
            : [output["disks"]["item"]];
        contents.Disks = deserializeAws_ec2DiskInfoList(wrappedItem, context);
    }
    if (output["totalSizeInGB"] !== undefined) {
        contents.TotalSizeInGB = parseInt(output["totalSizeInGB"]);
    }
    return contents;
};
const deserializeAws_ec2InstanceTypeInfo = (output, context) => {
    let contents = {
        __type: "InstanceTypeInfo",
        AutoRecoverySupported: undefined,
        BareMetal: undefined,
        BurstablePerformanceSupported: undefined,
        CurrentGeneration: undefined,
        DedicatedHostsSupported: undefined,
        EbsInfo: undefined,
        FpgaInfo: undefined,
        FreeTierEligible: undefined,
        GpuInfo: undefined,
        HibernationSupported: undefined,
        Hypervisor: undefined,
        InferenceAcceleratorInfo: undefined,
        InstanceStorageInfo: undefined,
        InstanceStorageSupported: undefined,
        InstanceType: undefined,
        MemoryInfo: undefined,
        NetworkInfo: undefined,
        PlacementGroupInfo: undefined,
        ProcessorInfo: undefined,
        SupportedRootDeviceTypes: undefined,
        SupportedUsageClasses: undefined,
        VCpuInfo: undefined
    };
    if (output["autoRecoverySupported"] !== undefined) {
        contents.AutoRecoverySupported = output["autoRecoverySupported"] == "true";
    }
    if (output["bareMetal"] !== undefined) {
        contents.BareMetal = output["bareMetal"] == "true";
    }
    if (output["burstablePerformanceSupported"] !== undefined) {
        contents.BurstablePerformanceSupported =
            output["burstablePerformanceSupported"] == "true";
    }
    if (output["currentGeneration"] !== undefined) {
        contents.CurrentGeneration = output["currentGeneration"] == "true";
    }
    if (output["dedicatedHostsSupported"] !== undefined) {
        contents.DedicatedHostsSupported =
            output["dedicatedHostsSupported"] == "true";
    }
    if (output["ebsInfo"] !== undefined) {
        contents.EbsInfo = deserializeAws_ec2EbsInfo(output["ebsInfo"], context);
    }
    if (output["fpgaInfo"] !== undefined) {
        contents.FpgaInfo = deserializeAws_ec2FpgaInfo(output["fpgaInfo"], context);
    }
    if (output["freeTierEligible"] !== undefined) {
        contents.FreeTierEligible = output["freeTierEligible"] == "true";
    }
    if (output["gpuInfo"] !== undefined) {
        contents.GpuInfo = deserializeAws_ec2GpuInfo(output["gpuInfo"], context);
    }
    if (output["hibernationSupported"] !== undefined) {
        contents.HibernationSupported = output["hibernationSupported"] == "true";
    }
    if (output["hypervisor"] !== undefined) {
        contents.Hypervisor = output["hypervisor"];
    }
    if (output["inferenceAcceleratorInfo"] !== undefined) {
        contents.InferenceAcceleratorInfo = deserializeAws_ec2InferenceAcceleratorInfo(output["inferenceAcceleratorInfo"], context);
    }
    if (output["instanceStorageInfo"] !== undefined) {
        contents.InstanceStorageInfo = deserializeAws_ec2InstanceStorageInfo(output["instanceStorageInfo"], context);
    }
    if (output["instanceStorageSupported"] !== undefined) {
        contents.InstanceStorageSupported =
            output["instanceStorageSupported"] == "true";
    }
    if (output["instanceType"] !== undefined) {
        contents.InstanceType = output["instanceType"];
    }
    if (output["memoryInfo"] !== undefined) {
        contents.MemoryInfo = deserializeAws_ec2MemoryInfo(output["memoryInfo"], context);
    }
    if (output["networkInfo"] !== undefined) {
        contents.NetworkInfo = deserializeAws_ec2NetworkInfo(output["networkInfo"], context);
    }
    if (output["placementGroupInfo"] !== undefined) {
        contents.PlacementGroupInfo = deserializeAws_ec2PlacementGroupInfo(output["placementGroupInfo"], context);
    }
    if (output["processorInfo"] !== undefined) {
        contents.ProcessorInfo = deserializeAws_ec2ProcessorInfo(output["processorInfo"], context);
    }
    if (output.supportedRootDeviceTypes === "") {
        contents.SupportedRootDeviceTypes = [];
    }
    if (output["supportedRootDeviceTypes"] !== undefined &&
        output["supportedRootDeviceTypes"]["item"] !== undefined) {
        const wrappedItem = output["supportedRootDeviceTypes"]["item"] instanceof Array
            ? output["supportedRootDeviceTypes"]["item"]
            : [output["supportedRootDeviceTypes"]["item"]];
        contents.SupportedRootDeviceTypes = deserializeAws_ec2RootDeviceTypeList(wrappedItem, context);
    }
    if (output.supportedUsageClasses === "") {
        contents.SupportedUsageClasses = [];
    }
    if (output["supportedUsageClasses"] !== undefined &&
        output["supportedUsageClasses"]["item"] !== undefined) {
        const wrappedItem = output["supportedUsageClasses"]["item"] instanceof Array
            ? output["supportedUsageClasses"]["item"]
            : [output["supportedUsageClasses"]["item"]];
        contents.SupportedUsageClasses = deserializeAws_ec2UsageClassTypeList(wrappedItem, context);
    }
    if (output["vCpuInfo"] !== undefined) {
        contents.VCpuInfo = deserializeAws_ec2VCpuInfo(output["vCpuInfo"], context);
    }
    return contents;
};
const deserializeAws_ec2InstanceTypeInfoList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2InstanceTypeInfo(entry, context));
    });
    return contents;
};
const deserializeAws_ec2InstanceTypeOffering = (output, context) => {
    let contents = {
        __type: "InstanceTypeOffering",
        InstanceType: undefined,
        Location: undefined,
        LocationType: undefined
    };
    if (output["instanceType"] !== undefined) {
        contents.InstanceType = output["instanceType"];
    }
    if (output["location"] !== undefined) {
        contents.Location = output["location"];
    }
    if (output["locationType"] !== undefined) {
        contents.LocationType = output["locationType"];
    }
    return contents;
};
const deserializeAws_ec2InstanceTypeOfferingsList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2InstanceTypeOffering(entry, context));
    });
    return contents;
};
const deserializeAws_ec2InstanceUsage = (output, context) => {
    let contents = {
        __type: "InstanceUsage",
        AccountId: undefined,
        UsedInstanceCount: undefined
    };
    if (output["accountId"] !== undefined) {
        contents.AccountId = output["accountId"];
    }
    if (output["usedInstanceCount"] !== undefined) {
        contents.UsedInstanceCount = parseInt(output["usedInstanceCount"]);
    }
    return contents;
};
const deserializeAws_ec2InstanceUsageSet = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2InstanceUsage(entry, context));
    });
    return contents;
};
const deserializeAws_ec2InternetGateway = (output, context) => {
    let contents = {
        __type: "InternetGateway",
        Attachments: undefined,
        InternetGatewayId: undefined,
        OwnerId: undefined,
        Tags: undefined
    };
    if (output.attachmentSet === "") {
        contents.Attachments = [];
    }
    if (output["attachmentSet"] !== undefined &&
        output["attachmentSet"]["item"] !== undefined) {
        const wrappedItem = output["attachmentSet"]["item"] instanceof Array
            ? output["attachmentSet"]["item"]
            : [output["attachmentSet"]["item"]];
        contents.Attachments = deserializeAws_ec2InternetGatewayAttachmentList(wrappedItem, context);
    }
    if (output["internetGatewayId"] !== undefined) {
        contents.InternetGatewayId = output["internetGatewayId"];
    }
    if (output["ownerId"] !== undefined) {
        contents.OwnerId = output["ownerId"];
    }
    if (output.tagSet === "") {
        contents.Tags = [];
    }
    if (output["tagSet"] !== undefined &&
        output["tagSet"]["item"] !== undefined) {
        const wrappedItem = output["tagSet"]["item"] instanceof Array
            ? output["tagSet"]["item"]
            : [output["tagSet"]["item"]];
        contents.Tags = deserializeAws_ec2TagList(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2InternetGatewayAttachment = (output, context) => {
    let contents = {
        __type: "InternetGatewayAttachment",
        State: undefined,
        VpcId: undefined
    };
    if (output["state"] !== undefined) {
        contents.State = output["state"];
    }
    if (output["vpcId"] !== undefined) {
        contents.VpcId = output["vpcId"];
    }
    return contents;
};
const deserializeAws_ec2InternetGatewayAttachmentList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2InternetGatewayAttachment(entry, context));
    });
    return contents;
};
const deserializeAws_ec2InternetGatewayList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2InternetGateway(entry, context));
    });
    return contents;
};
const deserializeAws_ec2IpPermission = (output, context) => {
    let contents = {
        __type: "IpPermission",
        FromPort: undefined,
        IpProtocol: undefined,
        IpRanges: undefined,
        Ipv6Ranges: undefined,
        PrefixListIds: undefined,
        ToPort: undefined,
        UserIdGroupPairs: undefined
    };
    if (output["fromPort"] !== undefined) {
        contents.FromPort = parseInt(output["fromPort"]);
    }
    if (output["ipProtocol"] !== undefined) {
        contents.IpProtocol = output["ipProtocol"];
    }
    if (output.ipRanges === "") {
        contents.IpRanges = [];
    }
    if (output["ipRanges"] !== undefined &&
        output["ipRanges"]["item"] !== undefined) {
        const wrappedItem = output["ipRanges"]["item"] instanceof Array
            ? output["ipRanges"]["item"]
            : [output["ipRanges"]["item"]];
        contents.IpRanges = deserializeAws_ec2IpRangeList(wrappedItem, context);
    }
    if (output.ipv6Ranges === "") {
        contents.Ipv6Ranges = [];
    }
    if (output["ipv6Ranges"] !== undefined &&
        output["ipv6Ranges"]["item"] !== undefined) {
        const wrappedItem = output["ipv6Ranges"]["item"] instanceof Array
            ? output["ipv6Ranges"]["item"]
            : [output["ipv6Ranges"]["item"]];
        contents.Ipv6Ranges = deserializeAws_ec2Ipv6RangeList(wrappedItem, context);
    }
    if (output.prefixListIds === "") {
        contents.PrefixListIds = [];
    }
    if (output["prefixListIds"] !== undefined &&
        output["prefixListIds"]["item"] !== undefined) {
        const wrappedItem = output["prefixListIds"]["item"] instanceof Array
            ? output["prefixListIds"]["item"]
            : [output["prefixListIds"]["item"]];
        contents.PrefixListIds = deserializeAws_ec2PrefixListIdList(wrappedItem, context);
    }
    if (output["toPort"] !== undefined) {
        contents.ToPort = parseInt(output["toPort"]);
    }
    if (output.groups === "") {
        contents.UserIdGroupPairs = [];
    }
    if (output["groups"] !== undefined &&
        output["groups"]["item"] !== undefined) {
        const wrappedItem = output["groups"]["item"] instanceof Array
            ? output["groups"]["item"]
            : [output["groups"]["item"]];
        contents.UserIdGroupPairs = deserializeAws_ec2UserIdGroupPairList(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2IpPermissionList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2IpPermission(entry, context));
    });
    return contents;
};
const deserializeAws_ec2IpRange = (output, context) => {
    let contents = {
        __type: "IpRange",
        CidrIp: undefined,
        Description: undefined
    };
    if (output["cidrIp"] !== undefined) {
        contents.CidrIp = output["cidrIp"];
    }
    if (output["description"] !== undefined) {
        contents.Description = output["description"];
    }
    return contents;
};
const deserializeAws_ec2IpRangeList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2IpRange(entry, context));
    });
    return contents;
};
const deserializeAws_ec2IpRanges = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(entry);
    });
    return contents;
};
const deserializeAws_ec2Ipv6AddressList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(entry);
    });
    return contents;
};
const deserializeAws_ec2Ipv6CidrAssociation = (output, context) => {
    let contents = {
        __type: "Ipv6CidrAssociation",
        AssociatedResource: undefined,
        Ipv6Cidr: undefined
    };
    if (output["associatedResource"] !== undefined) {
        contents.AssociatedResource = output["associatedResource"];
    }
    if (output["ipv6Cidr"] !== undefined) {
        contents.Ipv6Cidr = output["ipv6Cidr"];
    }
    return contents;
};
const deserializeAws_ec2Ipv6CidrAssociationSet = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2Ipv6CidrAssociation(entry, context));
    });
    return contents;
};
const deserializeAws_ec2Ipv6CidrBlock = (output, context) => {
    let contents = {
        __type: "Ipv6CidrBlock",
        Ipv6CidrBlock: undefined
    };
    if (output["ipv6CidrBlock"] !== undefined) {
        contents.Ipv6CidrBlock = output["ipv6CidrBlock"];
    }
    return contents;
};
const deserializeAws_ec2Ipv6CidrBlockSet = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2Ipv6CidrBlock(entry, context));
    });
    return contents;
};
const deserializeAws_ec2Ipv6Pool = (output, context) => {
    let contents = {
        __type: "Ipv6Pool",
        Description: undefined,
        PoolCidrBlocks: undefined,
        PoolId: undefined,
        Tags: undefined
    };
    if (output["description"] !== undefined) {
        contents.Description = output["description"];
    }
    if (output.poolCidrBlockSet === "") {
        contents.PoolCidrBlocks = [];
    }
    if (output["poolCidrBlockSet"] !== undefined &&
        output["poolCidrBlockSet"]["item"] !== undefined) {
        const wrappedItem = output["poolCidrBlockSet"]["item"] instanceof Array
            ? output["poolCidrBlockSet"]["item"]
            : [output["poolCidrBlockSet"]["item"]];
        contents.PoolCidrBlocks = deserializeAws_ec2PoolCidrBlocksSet(wrappedItem, context);
    }
    if (output["poolId"] !== undefined) {
        contents.PoolId = output["poolId"];
    }
    if (output.tagSet === "") {
        contents.Tags = [];
    }
    if (output["tagSet"] !== undefined &&
        output["tagSet"]["item"] !== undefined) {
        const wrappedItem = output["tagSet"]["item"] instanceof Array
            ? output["tagSet"]["item"]
            : [output["tagSet"]["item"]];
        contents.Tags = deserializeAws_ec2TagList(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2Ipv6PoolSet = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2Ipv6Pool(entry, context));
    });
    return contents;
};
const deserializeAws_ec2Ipv6Range = (output, context) => {
    let contents = {
        __type: "Ipv6Range",
        CidrIpv6: undefined,
        Description: undefined
    };
    if (output["cidrIpv6"] !== undefined) {
        contents.CidrIpv6 = output["cidrIpv6"];
    }
    if (output["description"] !== undefined) {
        contents.Description = output["description"];
    }
    return contents;
};
const deserializeAws_ec2Ipv6RangeList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2Ipv6Range(entry, context));
    });
    return contents;
};
const deserializeAws_ec2KeyPair = (output, context) => {
    let contents = {
        __type: "KeyPair",
        KeyFingerprint: undefined,
        KeyMaterial: undefined,
        KeyName: undefined,
        KeyPairId: undefined
    };
    if (output["keyFingerprint"] !== undefined) {
        contents.KeyFingerprint = output["keyFingerprint"];
    }
    if (output["keyMaterial"] !== undefined) {
        contents.KeyMaterial = output["keyMaterial"];
    }
    if (output["keyName"] !== undefined) {
        contents.KeyName = output["keyName"];
    }
    if (output["keyPairId"] !== undefined) {
        contents.KeyPairId = output["keyPairId"];
    }
    return contents;
};
const deserializeAws_ec2KeyPairInfo = (output, context) => {
    let contents = {
        __type: "KeyPairInfo",
        KeyFingerprint: undefined,
        KeyName: undefined,
        KeyPairId: undefined,
        Tags: undefined
    };
    if (output["keyFingerprint"] !== undefined) {
        contents.KeyFingerprint = output["keyFingerprint"];
    }
    if (output["keyName"] !== undefined) {
        contents.KeyName = output["keyName"];
    }
    if (output["keyPairId"] !== undefined) {
        contents.KeyPairId = output["keyPairId"];
    }
    if (output.tagSet === "") {
        contents.Tags = [];
    }
    if (output["tagSet"] !== undefined &&
        output["tagSet"]["item"] !== undefined) {
        const wrappedItem = output["tagSet"]["item"] instanceof Array
            ? output["tagSet"]["item"]
            : [output["tagSet"]["item"]];
        contents.Tags = deserializeAws_ec2TagList(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2KeyPairList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2KeyPairInfo(entry, context));
    });
    return contents;
};
const deserializeAws_ec2LastError = (output, context) => {
    let contents = {
        __type: "LastError",
        Code: undefined,
        Message: undefined
    };
    if (output["code"] !== undefined) {
        contents.Code = output["code"];
    }
    if (output["message"] !== undefined) {
        contents.Message = output["message"];
    }
    return contents;
};
const deserializeAws_ec2LaunchPermission = (output, context) => {
    let contents = {
        __type: "LaunchPermission",
        Group: undefined,
        UserId: undefined
    };
    if (output["group"] !== undefined) {
        contents.Group = output["group"];
    }
    if (output["userId"] !== undefined) {
        contents.UserId = output["userId"];
    }
    return contents;
};
const deserializeAws_ec2LaunchPermissionList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2LaunchPermission(entry, context));
    });
    return contents;
};
const deserializeAws_ec2LaunchSpecification = (output, context) => {
    let contents = {
        __type: "LaunchSpecification",
        AddressingType: undefined,
        BlockDeviceMappings: undefined,
        EbsOptimized: undefined,
        IamInstanceProfile: undefined,
        ImageId: undefined,
        InstanceType: undefined,
        KernelId: undefined,
        KeyName: undefined,
        Monitoring: undefined,
        NetworkInterfaces: undefined,
        Placement: undefined,
        RamdiskId: undefined,
        SecurityGroups: undefined,
        SubnetId: undefined,
        UserData: undefined
    };
    if (output["addressingType"] !== undefined) {
        contents.AddressingType = output["addressingType"];
    }
    if (output.blockDeviceMapping === "") {
        contents.BlockDeviceMappings = [];
    }
    if (output["blockDeviceMapping"] !== undefined &&
        output["blockDeviceMapping"]["item"] !== undefined) {
        const wrappedItem = output["blockDeviceMapping"]["item"] instanceof Array
            ? output["blockDeviceMapping"]["item"]
            : [output["blockDeviceMapping"]["item"]];
        contents.BlockDeviceMappings = deserializeAws_ec2BlockDeviceMappingList(wrappedItem, context);
    }
    if (output["ebsOptimized"] !== undefined) {
        contents.EbsOptimized = output["ebsOptimized"] == "true";
    }
    if (output["iamInstanceProfile"] !== undefined) {
        contents.IamInstanceProfile = deserializeAws_ec2IamInstanceProfileSpecification(output["iamInstanceProfile"], context);
    }
    if (output["imageId"] !== undefined) {
        contents.ImageId = output["imageId"];
    }
    if (output["instanceType"] !== undefined) {
        contents.InstanceType = output["instanceType"];
    }
    if (output["kernelId"] !== undefined) {
        contents.KernelId = output["kernelId"];
    }
    if (output["keyName"] !== undefined) {
        contents.KeyName = output["keyName"];
    }
    if (output["monitoring"] !== undefined) {
        contents.Monitoring = deserializeAws_ec2RunInstancesMonitoringEnabled(output["monitoring"], context);
    }
    if (output.networkInterfaceSet === "") {
        contents.NetworkInterfaces = [];
    }
    if (output["networkInterfaceSet"] !== undefined &&
        output["networkInterfaceSet"]["item"] !== undefined) {
        const wrappedItem = output["networkInterfaceSet"]["item"] instanceof Array
            ? output["networkInterfaceSet"]["item"]
            : [output["networkInterfaceSet"]["item"]];
        contents.NetworkInterfaces = deserializeAws_ec2InstanceNetworkInterfaceSpecificationList(wrappedItem, context);
    }
    if (output["placement"] !== undefined) {
        contents.Placement = deserializeAws_ec2SpotPlacement(output["placement"], context);
    }
    if (output["ramdiskId"] !== undefined) {
        contents.RamdiskId = output["ramdiskId"];
    }
    if (output.groupSet === "") {
        contents.SecurityGroups = [];
    }
    if (output["groupSet"] !== undefined &&
        output["groupSet"]["item"] !== undefined) {
        const wrappedItem = output["groupSet"]["item"] instanceof Array
            ? output["groupSet"]["item"]
            : [output["groupSet"]["item"]];
        contents.SecurityGroups = deserializeAws_ec2GroupIdentifierList(wrappedItem, context);
    }
    if (output["subnetId"] !== undefined) {
        contents.SubnetId = output["subnetId"];
    }
    if (output["userData"] !== undefined) {
        contents.UserData = output["userData"];
    }
    return contents;
};
const deserializeAws_ec2LaunchSpecsList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2SpotFleetLaunchSpecification(entry, context));
    });
    return contents;
};
const deserializeAws_ec2LaunchTemplate = (output, context) => {
    let contents = {
        __type: "LaunchTemplate",
        CreateTime: undefined,
        CreatedBy: undefined,
        DefaultVersionNumber: undefined,
        LatestVersionNumber: undefined,
        LaunchTemplateId: undefined,
        LaunchTemplateName: undefined,
        Tags: undefined
    };
    if (output["createTime"] !== undefined) {
        contents.CreateTime = new Date(output["createTime"]);
    }
    if (output["createdBy"] !== undefined) {
        contents.CreatedBy = output["createdBy"];
    }
    if (output["defaultVersionNumber"] !== undefined) {
        contents.DefaultVersionNumber = parseInt(output["defaultVersionNumber"]);
    }
    if (output["latestVersionNumber"] !== undefined) {
        contents.LatestVersionNumber = parseInt(output["latestVersionNumber"]);
    }
    if (output["launchTemplateId"] !== undefined) {
        contents.LaunchTemplateId = output["launchTemplateId"];
    }
    if (output["launchTemplateName"] !== undefined) {
        contents.LaunchTemplateName = output["launchTemplateName"];
    }
    if (output.tagSet === "") {
        contents.Tags = [];
    }
    if (output["tagSet"] !== undefined &&
        output["tagSet"]["item"] !== undefined) {
        const wrappedItem = output["tagSet"]["item"] instanceof Array
            ? output["tagSet"]["item"]
            : [output["tagSet"]["item"]];
        contents.Tags = deserializeAws_ec2TagList(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2LaunchTemplateAndOverridesResponse = (output, context) => {
    let contents = {
        __type: "LaunchTemplateAndOverridesResponse",
        LaunchTemplateSpecification: undefined,
        Overrides: undefined
    };
    if (output["launchTemplateSpecification"] !== undefined) {
        contents.LaunchTemplateSpecification = deserializeAws_ec2FleetLaunchTemplateSpecification(output["launchTemplateSpecification"], context);
    }
    if (output["overrides"] !== undefined) {
        contents.Overrides = deserializeAws_ec2FleetLaunchTemplateOverrides(output["overrides"], context);
    }
    return contents;
};
const deserializeAws_ec2LaunchTemplateBlockDeviceMapping = (output, context) => {
    let contents = {
        __type: "LaunchTemplateBlockDeviceMapping",
        DeviceName: undefined,
        Ebs: undefined,
        NoDevice: undefined,
        VirtualName: undefined
    };
    if (output["deviceName"] !== undefined) {
        contents.DeviceName = output["deviceName"];
    }
    if (output["ebs"] !== undefined) {
        contents.Ebs = deserializeAws_ec2LaunchTemplateEbsBlockDevice(output["ebs"], context);
    }
    if (output["noDevice"] !== undefined) {
        contents.NoDevice = output["noDevice"];
    }
    if (output["virtualName"] !== undefined) {
        contents.VirtualName = output["virtualName"];
    }
    return contents;
};
const deserializeAws_ec2LaunchTemplateBlockDeviceMappingList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2LaunchTemplateBlockDeviceMapping(entry, context));
    });
    return contents;
};
const deserializeAws_ec2LaunchTemplateCapacityReservationSpecificationResponse = (output, context) => {
    let contents = {
        __type: "LaunchTemplateCapacityReservationSpecificationResponse",
        CapacityReservationPreference: undefined,
        CapacityReservationTarget: undefined
    };
    if (output["capacityReservationPreference"] !== undefined) {
        contents.CapacityReservationPreference =
            output["capacityReservationPreference"];
    }
    if (output["capacityReservationTarget"] !== undefined) {
        contents.CapacityReservationTarget = deserializeAws_ec2CapacityReservationTargetResponse(output["capacityReservationTarget"], context);
    }
    return contents;
};
const deserializeAws_ec2LaunchTemplateConfig = (output, context) => {
    let contents = {
        __type: "LaunchTemplateConfig",
        LaunchTemplateSpecification: undefined,
        Overrides: undefined
    };
    if (output["launchTemplateSpecification"] !== undefined) {
        contents.LaunchTemplateSpecification = deserializeAws_ec2FleetLaunchTemplateSpecification(output["launchTemplateSpecification"], context);
    }
    if (output.overrides === "") {
        contents.Overrides = [];
    }
    if (output["overrides"] !== undefined &&
        output["overrides"]["item"] !== undefined) {
        const wrappedItem = output["overrides"]["item"] instanceof Array
            ? output["overrides"]["item"]
            : [output["overrides"]["item"]];
        contents.Overrides = deserializeAws_ec2LaunchTemplateOverridesList(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2LaunchTemplateConfigList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2LaunchTemplateConfig(entry, context));
    });
    return contents;
};
const deserializeAws_ec2LaunchTemplateCpuOptions = (output, context) => {
    let contents = {
        __type: "LaunchTemplateCpuOptions",
        CoreCount: undefined,
        ThreadsPerCore: undefined
    };
    if (output["coreCount"] !== undefined) {
        contents.CoreCount = parseInt(output["coreCount"]);
    }
    if (output["threadsPerCore"] !== undefined) {
        contents.ThreadsPerCore = parseInt(output["threadsPerCore"]);
    }
    return contents;
};
const deserializeAws_ec2LaunchTemplateEbsBlockDevice = (output, context) => {
    let contents = {
        __type: "LaunchTemplateEbsBlockDevice",
        DeleteOnTermination: undefined,
        Encrypted: undefined,
        Iops: undefined,
        KmsKeyId: undefined,
        SnapshotId: undefined,
        VolumeSize: undefined,
        VolumeType: undefined
    };
    if (output["deleteOnTermination"] !== undefined) {
        contents.DeleteOnTermination = output["deleteOnTermination"] == "true";
    }
    if (output["encrypted"] !== undefined) {
        contents.Encrypted = output["encrypted"] == "true";
    }
    if (output["iops"] !== undefined) {
        contents.Iops = parseInt(output["iops"]);
    }
    if (output["kmsKeyId"] !== undefined) {
        contents.KmsKeyId = output["kmsKeyId"];
    }
    if (output["snapshotId"] !== undefined) {
        contents.SnapshotId = output["snapshotId"];
    }
    if (output["volumeSize"] !== undefined) {
        contents.VolumeSize = parseInt(output["volumeSize"]);
    }
    if (output["volumeType"] !== undefined) {
        contents.VolumeType = output["volumeType"];
    }
    return contents;
};
const deserializeAws_ec2LaunchTemplateElasticInferenceAcceleratorResponse = (output, context) => {
    let contents = {
        __type: "LaunchTemplateElasticInferenceAcceleratorResponse",
        Count: undefined,
        Type: undefined
    };
    if (output["count"] !== undefined) {
        contents.Count = parseInt(output["count"]);
    }
    if (output["type"] !== undefined) {
        contents.Type = output["type"];
    }
    return contents;
};
const deserializeAws_ec2LaunchTemplateElasticInferenceAcceleratorResponseList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2LaunchTemplateElasticInferenceAcceleratorResponse(entry, context));
    });
    return contents;
};
const deserializeAws_ec2LaunchTemplateHibernationOptions = (output, context) => {
    let contents = {
        __type: "LaunchTemplateHibernationOptions",
        Configured: undefined
    };
    if (output["configured"] !== undefined) {
        contents.Configured = output["configured"] == "true";
    }
    return contents;
};
const deserializeAws_ec2LaunchTemplateIamInstanceProfileSpecification = (output, context) => {
    let contents = {
        __type: "LaunchTemplateIamInstanceProfileSpecification",
        Arn: undefined,
        Name: undefined
    };
    if (output["arn"] !== undefined) {
        contents.Arn = output["arn"];
    }
    if (output["name"] !== undefined) {
        contents.Name = output["name"];
    }
    return contents;
};
const deserializeAws_ec2LaunchTemplateInstanceMarketOptions = (output, context) => {
    let contents = {
        __type: "LaunchTemplateInstanceMarketOptions",
        MarketType: undefined,
        SpotOptions: undefined
    };
    if (output["marketType"] !== undefined) {
        contents.MarketType = output["marketType"];
    }
    if (output["spotOptions"] !== undefined) {
        contents.SpotOptions = deserializeAws_ec2LaunchTemplateSpotMarketOptions(output["spotOptions"], context);
    }
    return contents;
};
const deserializeAws_ec2LaunchTemplateInstanceMetadataOptions = (output, context) => {
    let contents = {
        __type: "LaunchTemplateInstanceMetadataOptions",
        HttpEndpoint: undefined,
        HttpPutResponseHopLimit: undefined,
        HttpTokens: undefined,
        State: undefined
    };
    if (output["httpEndpoint"] !== undefined) {
        contents.HttpEndpoint = output["httpEndpoint"];
    }
    if (output["httpPutResponseHopLimit"] !== undefined) {
        contents.HttpPutResponseHopLimit = parseInt(output["httpPutResponseHopLimit"]);
    }
    if (output["httpTokens"] !== undefined) {
        contents.HttpTokens = output["httpTokens"];
    }
    if (output["state"] !== undefined) {
        contents.State = output["state"];
    }
    return contents;
};
const deserializeAws_ec2LaunchTemplateInstanceNetworkInterfaceSpecification = (output, context) => {
    let contents = {
        __type: "LaunchTemplateInstanceNetworkInterfaceSpecification",
        AssociatePublicIpAddress: undefined,
        DeleteOnTermination: undefined,
        Description: undefined,
        DeviceIndex: undefined,
        Groups: undefined,
        InterfaceType: undefined,
        Ipv6AddressCount: undefined,
        Ipv6Addresses: undefined,
        NetworkInterfaceId: undefined,
        PrivateIpAddress: undefined,
        PrivateIpAddresses: undefined,
        SecondaryPrivateIpAddressCount: undefined,
        SubnetId: undefined
    };
    if (output["associatePublicIpAddress"] !== undefined) {
        contents.AssociatePublicIpAddress =
            output["associatePublicIpAddress"] == "true";
    }
    if (output["deleteOnTermination"] !== undefined) {
        contents.DeleteOnTermination = output["deleteOnTermination"] == "true";
    }
    if (output["description"] !== undefined) {
        contents.Description = output["description"];
    }
    if (output["deviceIndex"] !== undefined) {
        contents.DeviceIndex = parseInt(output["deviceIndex"]);
    }
    if (output.groupSet === "") {
        contents.Groups = [];
    }
    if (output["groupSet"] !== undefined &&
        output["groupSet"]["groupId"] !== undefined) {
        const wrappedItem = output["groupSet"]["groupId"] instanceof Array
            ? output["groupSet"]["groupId"]
            : [output["groupSet"]["groupId"]];
        contents.Groups = deserializeAws_ec2GroupIdStringList(wrappedItem, context);
    }
    if (output["interfaceType"] !== undefined) {
        contents.InterfaceType = output["interfaceType"];
    }
    if (output["ipv6AddressCount"] !== undefined) {
        contents.Ipv6AddressCount = parseInt(output["ipv6AddressCount"]);
    }
    if (output.ipv6AddressesSet === "") {
        contents.Ipv6Addresses = [];
    }
    if (output["ipv6AddressesSet"] !== undefined &&
        output["ipv6AddressesSet"]["item"] !== undefined) {
        const wrappedItem = output["ipv6AddressesSet"]["item"] instanceof Array
            ? output["ipv6AddressesSet"]["item"]
            : [output["ipv6AddressesSet"]["item"]];
        contents.Ipv6Addresses = deserializeAws_ec2InstanceIpv6AddressList(wrappedItem, context);
    }
    if (output["networkInterfaceId"] !== undefined) {
        contents.NetworkInterfaceId = output["networkInterfaceId"];
    }
    if (output["privateIpAddress"] !== undefined) {
        contents.PrivateIpAddress = output["privateIpAddress"];
    }
    if (output.privateIpAddressesSet === "") {
        contents.PrivateIpAddresses = [];
    }
    if (output["privateIpAddressesSet"] !== undefined &&
        output["privateIpAddressesSet"]["item"] !== undefined) {
        const wrappedItem = output["privateIpAddressesSet"]["item"] instanceof Array
            ? output["privateIpAddressesSet"]["item"]
            : [output["privateIpAddressesSet"]["item"]];
        contents.PrivateIpAddresses = deserializeAws_ec2PrivateIpAddressSpecificationList(wrappedItem, context);
    }
    if (output["secondaryPrivateIpAddressCount"] !== undefined) {
        contents.SecondaryPrivateIpAddressCount = parseInt(output["secondaryPrivateIpAddressCount"]);
    }
    if (output["subnetId"] !== undefined) {
        contents.SubnetId = output["subnetId"];
    }
    return contents;
};
const deserializeAws_ec2LaunchTemplateInstanceNetworkInterfaceSpecificationList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2LaunchTemplateInstanceNetworkInterfaceSpecification(entry, context));
    });
    return contents;
};
const deserializeAws_ec2LaunchTemplateLicenseConfiguration = (output, context) => {
    let contents = {
        __type: "LaunchTemplateLicenseConfiguration",
        LicenseConfigurationArn: undefined
    };
    if (output["licenseConfigurationArn"] !== undefined) {
        contents.LicenseConfigurationArn = output["licenseConfigurationArn"];
    }
    return contents;
};
const deserializeAws_ec2LaunchTemplateLicenseList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2LaunchTemplateLicenseConfiguration(entry, context));
    });
    return contents;
};
const deserializeAws_ec2LaunchTemplateOverrides = (output, context) => {
    let contents = {
        __type: "LaunchTemplateOverrides",
        AvailabilityZone: undefined,
        InstanceType: undefined,
        Priority: undefined,
        SpotPrice: undefined,
        SubnetId: undefined,
        WeightedCapacity: undefined
    };
    if (output["availabilityZone"] !== undefined) {
        contents.AvailabilityZone = output["availabilityZone"];
    }
    if (output["instanceType"] !== undefined) {
        contents.InstanceType = output["instanceType"];
    }
    if (output["priority"] !== undefined) {
        contents.Priority = parseFloat(output["priority"]);
    }
    if (output["spotPrice"] !== undefined) {
        contents.SpotPrice = output["spotPrice"];
    }
    if (output["subnetId"] !== undefined) {
        contents.SubnetId = output["subnetId"];
    }
    if (output["weightedCapacity"] !== undefined) {
        contents.WeightedCapacity = parseFloat(output["weightedCapacity"]);
    }
    return contents;
};
const deserializeAws_ec2LaunchTemplateOverridesList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2LaunchTemplateOverrides(entry, context));
    });
    return contents;
};
const deserializeAws_ec2LaunchTemplatePlacement = (output, context) => {
    let contents = {
        __type: "LaunchTemplatePlacement",
        Affinity: undefined,
        AvailabilityZone: undefined,
        GroupName: undefined,
        HostId: undefined,
        HostResourceGroupArn: undefined,
        PartitionNumber: undefined,
        SpreadDomain: undefined,
        Tenancy: undefined
    };
    if (output["affinity"] !== undefined) {
        contents.Affinity = output["affinity"];
    }
    if (output["availabilityZone"] !== undefined) {
        contents.AvailabilityZone = output["availabilityZone"];
    }
    if (output["groupName"] !== undefined) {
        contents.GroupName = output["groupName"];
    }
    if (output["hostId"] !== undefined) {
        contents.HostId = output["hostId"];
    }
    if (output["hostResourceGroupArn"] !== undefined) {
        contents.HostResourceGroupArn = output["hostResourceGroupArn"];
    }
    if (output["partitionNumber"] !== undefined) {
        contents.PartitionNumber = parseInt(output["partitionNumber"]);
    }
    if (output["spreadDomain"] !== undefined) {
        contents.SpreadDomain = output["spreadDomain"];
    }
    if (output["tenancy"] !== undefined) {
        contents.Tenancy = output["tenancy"];
    }
    return contents;
};
const deserializeAws_ec2LaunchTemplateSet = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2LaunchTemplate(entry, context));
    });
    return contents;
};
const deserializeAws_ec2LaunchTemplateSpotMarketOptions = (output, context) => {
    let contents = {
        __type: "LaunchTemplateSpotMarketOptions",
        BlockDurationMinutes: undefined,
        InstanceInterruptionBehavior: undefined,
        MaxPrice: undefined,
        SpotInstanceType: undefined,
        ValidUntil: undefined
    };
    if (output["blockDurationMinutes"] !== undefined) {
        contents.BlockDurationMinutes = parseInt(output["blockDurationMinutes"]);
    }
    if (output["instanceInterruptionBehavior"] !== undefined) {
        contents.InstanceInterruptionBehavior =
            output["instanceInterruptionBehavior"];
    }
    if (output["maxPrice"] !== undefined) {
        contents.MaxPrice = output["maxPrice"];
    }
    if (output["spotInstanceType"] !== undefined) {
        contents.SpotInstanceType = output["spotInstanceType"];
    }
    if (output["validUntil"] !== undefined) {
        contents.ValidUntil = new Date(output["validUntil"]);
    }
    return contents;
};
const deserializeAws_ec2LaunchTemplateTagSpecification = (output, context) => {
    let contents = {
        __type: "LaunchTemplateTagSpecification",
        ResourceType: undefined,
        Tags: undefined
    };
    if (output["resourceType"] !== undefined) {
        contents.ResourceType = output["resourceType"];
    }
    if (output.tagSet === "") {
        contents.Tags = [];
    }
    if (output["tagSet"] !== undefined &&
        output["tagSet"]["item"] !== undefined) {
        const wrappedItem = output["tagSet"]["item"] instanceof Array
            ? output["tagSet"]["item"]
            : [output["tagSet"]["item"]];
        contents.Tags = deserializeAws_ec2TagList(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2LaunchTemplateTagSpecificationList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2LaunchTemplateTagSpecification(entry, context));
    });
    return contents;
};
const deserializeAws_ec2LaunchTemplateVersion = (output, context) => {
    let contents = {
        __type: "LaunchTemplateVersion",
        CreateTime: undefined,
        CreatedBy: undefined,
        DefaultVersion: undefined,
        LaunchTemplateData: undefined,
        LaunchTemplateId: undefined,
        LaunchTemplateName: undefined,
        VersionDescription: undefined,
        VersionNumber: undefined
    };
    if (output["createTime"] !== undefined) {
        contents.CreateTime = new Date(output["createTime"]);
    }
    if (output["createdBy"] !== undefined) {
        contents.CreatedBy = output["createdBy"];
    }
    if (output["defaultVersion"] !== undefined) {
        contents.DefaultVersion = output["defaultVersion"] == "true";
    }
    if (output["launchTemplateData"] !== undefined) {
        contents.LaunchTemplateData = deserializeAws_ec2ResponseLaunchTemplateData(output["launchTemplateData"], context);
    }
    if (output["launchTemplateId"] !== undefined) {
        contents.LaunchTemplateId = output["launchTemplateId"];
    }
    if (output["launchTemplateName"] !== undefined) {
        contents.LaunchTemplateName = output["launchTemplateName"];
    }
    if (output["versionDescription"] !== undefined) {
        contents.VersionDescription = output["versionDescription"];
    }
    if (output["versionNumber"] !== undefined) {
        contents.VersionNumber = parseInt(output["versionNumber"]);
    }
    return contents;
};
const deserializeAws_ec2LaunchTemplateVersionSet = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2LaunchTemplateVersion(entry, context));
    });
    return contents;
};
const deserializeAws_ec2LaunchTemplatesMonitoring = (output, context) => {
    let contents = {
        __type: "LaunchTemplatesMonitoring",
        Enabled: undefined
    };
    if (output["enabled"] !== undefined) {
        contents.Enabled = output["enabled"] == "true";
    }
    return contents;
};
const deserializeAws_ec2LicenseConfiguration = (output, context) => {
    let contents = {
        __type: "LicenseConfiguration",
        LicenseConfigurationArn: undefined
    };
    if (output["licenseConfigurationArn"] !== undefined) {
        contents.LicenseConfigurationArn = output["licenseConfigurationArn"];
    }
    return contents;
};
const deserializeAws_ec2LicenseList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2LicenseConfiguration(entry, context));
    });
    return contents;
};
const deserializeAws_ec2LoadBalancersConfig = (output, context) => {
    let contents = {
        __type: "LoadBalancersConfig",
        ClassicLoadBalancersConfig: undefined,
        TargetGroupsConfig: undefined
    };
    if (output["classicLoadBalancersConfig"] !== undefined) {
        contents.ClassicLoadBalancersConfig = deserializeAws_ec2ClassicLoadBalancersConfig(output["classicLoadBalancersConfig"], context);
    }
    if (output["targetGroupsConfig"] !== undefined) {
        contents.TargetGroupsConfig = deserializeAws_ec2TargetGroupsConfig(output["targetGroupsConfig"], context);
    }
    return contents;
};
const deserializeAws_ec2LoadPermission = (output, context) => {
    let contents = {
        __type: "LoadPermission",
        Group: undefined,
        UserId: undefined
    };
    if (output["group"] !== undefined) {
        contents.Group = output["group"];
    }
    if (output["userId"] !== undefined) {
        contents.UserId = output["userId"];
    }
    return contents;
};
const deserializeAws_ec2LoadPermissionList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2LoadPermission(entry, context));
    });
    return contents;
};
const deserializeAws_ec2LocalGateway = (output, context) => {
    let contents = {
        __type: "LocalGateway",
        LocalGatewayId: undefined,
        OutpostArn: undefined,
        OwnerId: undefined,
        State: undefined,
        Tags: undefined
    };
    if (output["localGatewayId"] !== undefined) {
        contents.LocalGatewayId = output["localGatewayId"];
    }
    if (output["outpostArn"] !== undefined) {
        contents.OutpostArn = output["outpostArn"];
    }
    if (output["ownerId"] !== undefined) {
        contents.OwnerId = output["ownerId"];
    }
    if (output["state"] !== undefined) {
        contents.State = output["state"];
    }
    if (output.tagSet === "") {
        contents.Tags = [];
    }
    if (output["tagSet"] !== undefined &&
        output["tagSet"]["item"] !== undefined) {
        const wrappedItem = output["tagSet"]["item"] instanceof Array
            ? output["tagSet"]["item"]
            : [output["tagSet"]["item"]];
        contents.Tags = deserializeAws_ec2TagList(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2LocalGatewayRoute = (output, context) => {
    let contents = {
        __type: "LocalGatewayRoute",
        DestinationCidrBlock: undefined,
        LocalGatewayRouteTableId: undefined,
        LocalGatewayVirtualInterfaceGroupId: undefined,
        State: undefined,
        Type: undefined
    };
    if (output["destinationCidrBlock"] !== undefined) {
        contents.DestinationCidrBlock = output["destinationCidrBlock"];
    }
    if (output["localGatewayRouteTableId"] !== undefined) {
        contents.LocalGatewayRouteTableId = output["localGatewayRouteTableId"];
    }
    if (output["localGatewayVirtualInterfaceGroupId"] !== undefined) {
        contents.LocalGatewayVirtualInterfaceGroupId =
            output["localGatewayVirtualInterfaceGroupId"];
    }
    if (output["state"] !== undefined) {
        contents.State = output["state"];
    }
    if (output["type"] !== undefined) {
        contents.Type = output["type"];
    }
    return contents;
};
const deserializeAws_ec2LocalGatewayRouteList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2LocalGatewayRoute(entry, context));
    });
    return contents;
};
const deserializeAws_ec2LocalGatewayRouteTable = (output, context) => {
    let contents = {
        __type: "LocalGatewayRouteTable",
        LocalGatewayId: undefined,
        LocalGatewayRouteTableId: undefined,
        OutpostArn: undefined,
        State: undefined,
        Tags: undefined
    };
    if (output["localGatewayId"] !== undefined) {
        contents.LocalGatewayId = output["localGatewayId"];
    }
    if (output["localGatewayRouteTableId"] !== undefined) {
        contents.LocalGatewayRouteTableId = output["localGatewayRouteTableId"];
    }
    if (output["outpostArn"] !== undefined) {
        contents.OutpostArn = output["outpostArn"];
    }
    if (output["state"] !== undefined) {
        contents.State = output["state"];
    }
    if (output.tagSet === "") {
        contents.Tags = [];
    }
    if (output["tagSet"] !== undefined &&
        output["tagSet"]["item"] !== undefined) {
        const wrappedItem = output["tagSet"]["item"] instanceof Array
            ? output["tagSet"]["item"]
            : [output["tagSet"]["item"]];
        contents.Tags = deserializeAws_ec2TagList(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2LocalGatewayRouteTableSet = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2LocalGatewayRouteTable(entry, context));
    });
    return contents;
};
const deserializeAws_ec2LocalGatewayRouteTableVirtualInterfaceGroupAssociation = (output, context) => {
    let contents = {
        __type: "LocalGatewayRouteTableVirtualInterfaceGroupAssociation",
        LocalGatewayId: undefined,
        LocalGatewayRouteTableId: undefined,
        LocalGatewayRouteTableVirtualInterfaceGroupAssociationId: undefined,
        LocalGatewayVirtualInterfaceGroupId: undefined,
        State: undefined,
        Tags: undefined
    };
    if (output["localGatewayId"] !== undefined) {
        contents.LocalGatewayId = output["localGatewayId"];
    }
    if (output["localGatewayRouteTableId"] !== undefined) {
        contents.LocalGatewayRouteTableId = output["localGatewayRouteTableId"];
    }
    if (output["localGatewayRouteTableVirtualInterfaceGroupAssociationId"] !==
        undefined) {
        contents.LocalGatewayRouteTableVirtualInterfaceGroupAssociationId =
            output["localGatewayRouteTableVirtualInterfaceGroupAssociationId"];
    }
    if (output["localGatewayVirtualInterfaceGroupId"] !== undefined) {
        contents.LocalGatewayVirtualInterfaceGroupId =
            output["localGatewayVirtualInterfaceGroupId"];
    }
    if (output["state"] !== undefined) {
        contents.State = output["state"];
    }
    if (output.tagSet === "") {
        contents.Tags = [];
    }
    if (output["tagSet"] !== undefined &&
        output["tagSet"]["item"] !== undefined) {
        const wrappedItem = output["tagSet"]["item"] instanceof Array
            ? output["tagSet"]["item"]
            : [output["tagSet"]["item"]];
        contents.Tags = deserializeAws_ec2TagList(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2LocalGatewayRouteTableVirtualInterfaceGroupAssociationSet = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2LocalGatewayRouteTableVirtualInterfaceGroupAssociation(entry, context));
    });
    return contents;
};
const deserializeAws_ec2LocalGatewayRouteTableVpcAssociation = (output, context) => {
    let contents = {
        __type: "LocalGatewayRouteTableVpcAssociation",
        LocalGatewayId: undefined,
        LocalGatewayRouteTableId: undefined,
        LocalGatewayRouteTableVpcAssociationId: undefined,
        State: undefined,
        Tags: undefined,
        VpcId: undefined
    };
    if (output["localGatewayId"] !== undefined) {
        contents.LocalGatewayId = output["localGatewayId"];
    }
    if (output["localGatewayRouteTableId"] !== undefined) {
        contents.LocalGatewayRouteTableId = output["localGatewayRouteTableId"];
    }
    if (output["localGatewayRouteTableVpcAssociationId"] !== undefined) {
        contents.LocalGatewayRouteTableVpcAssociationId =
            output["localGatewayRouteTableVpcAssociationId"];
    }
    if (output["state"] !== undefined) {
        contents.State = output["state"];
    }
    if (output.tagSet === "") {
        contents.Tags = [];
    }
    if (output["tagSet"] !== undefined &&
        output["tagSet"]["item"] !== undefined) {
        const wrappedItem = output["tagSet"]["item"] instanceof Array
            ? output["tagSet"]["item"]
            : [output["tagSet"]["item"]];
        contents.Tags = deserializeAws_ec2TagList(wrappedItem, context);
    }
    if (output["vpcId"] !== undefined) {
        contents.VpcId = output["vpcId"];
    }
    return contents;
};
const deserializeAws_ec2LocalGatewayRouteTableVpcAssociationSet = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2LocalGatewayRouteTableVpcAssociation(entry, context));
    });
    return contents;
};
const deserializeAws_ec2LocalGatewaySet = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2LocalGateway(entry, context));
    });
    return contents;
};
const deserializeAws_ec2LocalGatewayVirtualInterface = (output, context) => {
    let contents = {
        __type: "LocalGatewayVirtualInterface",
        LocalAddress: undefined,
        LocalBgpAsn: undefined,
        LocalGatewayId: undefined,
        LocalGatewayVirtualInterfaceId: undefined,
        PeerAddress: undefined,
        PeerBgpAsn: undefined,
        Tags: undefined,
        Vlan: undefined
    };
    if (output["localAddress"] !== undefined) {
        contents.LocalAddress = output["localAddress"];
    }
    if (output["localBgpAsn"] !== undefined) {
        contents.LocalBgpAsn = parseInt(output["localBgpAsn"]);
    }
    if (output["localGatewayId"] !== undefined) {
        contents.LocalGatewayId = output["localGatewayId"];
    }
    if (output["localGatewayVirtualInterfaceId"] !== undefined) {
        contents.LocalGatewayVirtualInterfaceId =
            output["localGatewayVirtualInterfaceId"];
    }
    if (output["peerAddress"] !== undefined) {
        contents.PeerAddress = output["peerAddress"];
    }
    if (output["peerBgpAsn"] !== undefined) {
        contents.PeerBgpAsn = parseInt(output["peerBgpAsn"]);
    }
    if (output.tagSet === "") {
        contents.Tags = [];
    }
    if (output["tagSet"] !== undefined &&
        output["tagSet"]["item"] !== undefined) {
        const wrappedItem = output["tagSet"]["item"] instanceof Array
            ? output["tagSet"]["item"]
            : [output["tagSet"]["item"]];
        contents.Tags = deserializeAws_ec2TagList(wrappedItem, context);
    }
    if (output["vlan"] !== undefined) {
        contents.Vlan = parseInt(output["vlan"]);
    }
    return contents;
};
const deserializeAws_ec2LocalGatewayVirtualInterfaceGroup = (output, context) => {
    let contents = {
        __type: "LocalGatewayVirtualInterfaceGroup",
        LocalGatewayId: undefined,
        LocalGatewayVirtualInterfaceGroupId: undefined,
        LocalGatewayVirtualInterfaceIds: undefined,
        Tags: undefined
    };
    if (output["localGatewayId"] !== undefined) {
        contents.LocalGatewayId = output["localGatewayId"];
    }
    if (output["localGatewayVirtualInterfaceGroupId"] !== undefined) {
        contents.LocalGatewayVirtualInterfaceGroupId =
            output["localGatewayVirtualInterfaceGroupId"];
    }
    if (output.localGatewayVirtualInterfaceIdSet === "") {
        contents.LocalGatewayVirtualInterfaceIds = [];
    }
    if (output["localGatewayVirtualInterfaceIdSet"] !== undefined &&
        output["localGatewayVirtualInterfaceIdSet"]["item"] !== undefined) {
        const wrappedItem = output["localGatewayVirtualInterfaceIdSet"]["item"] instanceof Array
            ? output["localGatewayVirtualInterfaceIdSet"]["item"]
            : [output["localGatewayVirtualInterfaceIdSet"]["item"]];
        contents.LocalGatewayVirtualInterfaceIds = deserializeAws_ec2LocalGatewayVirtualInterfaceIdSet(wrappedItem, context);
    }
    if (output.tagSet === "") {
        contents.Tags = [];
    }
    if (output["tagSet"] !== undefined &&
        output["tagSet"]["item"] !== undefined) {
        const wrappedItem = output["tagSet"]["item"] instanceof Array
            ? output["tagSet"]["item"]
            : [output["tagSet"]["item"]];
        contents.Tags = deserializeAws_ec2TagList(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2LocalGatewayVirtualInterfaceGroupSet = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2LocalGatewayVirtualInterfaceGroup(entry, context));
    });
    return contents;
};
const deserializeAws_ec2LocalGatewayVirtualInterfaceIdSet = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(entry);
    });
    return contents;
};
const deserializeAws_ec2LocalGatewayVirtualInterfaceSet = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2LocalGatewayVirtualInterface(entry, context));
    });
    return contents;
};
const deserializeAws_ec2MemoryInfo = (output, context) => {
    let contents = {
        __type: "MemoryInfo",
        SizeInMiB: undefined
    };
    if (output["sizeInMiB"] !== undefined) {
        contents.SizeInMiB = parseInt(output["sizeInMiB"]);
    }
    return contents;
};
const deserializeAws_ec2ModifyCapacityReservationResult = (output, context) => {
    let contents = {
        __type: "ModifyCapacityReservationResult",
        Return: undefined
    };
    if (output["return"] !== undefined) {
        contents.Return = output["return"] == "true";
    }
    return contents;
};
const deserializeAws_ec2ModifyClientVpnEndpointResult = (output, context) => {
    let contents = {
        __type: "ModifyClientVpnEndpointResult",
        Return: undefined
    };
    if (output["return"] !== undefined) {
        contents.Return = output["return"] == "true";
    }
    return contents;
};
const deserializeAws_ec2ModifyDefaultCreditSpecificationResult = (output, context) => {
    let contents = {
        __type: "ModifyDefaultCreditSpecificationResult",
        InstanceFamilyCreditSpecification: undefined
    };
    if (output["instanceFamilyCreditSpecification"] !== undefined) {
        contents.InstanceFamilyCreditSpecification = deserializeAws_ec2InstanceFamilyCreditSpecification(output["instanceFamilyCreditSpecification"], context);
    }
    return contents;
};
const deserializeAws_ec2ModifyEbsDefaultKmsKeyIdResult = (output, context) => {
    let contents = {
        __type: "ModifyEbsDefaultKmsKeyIdResult",
        KmsKeyId: undefined
    };
    if (output["kmsKeyId"] !== undefined) {
        contents.KmsKeyId = output["kmsKeyId"];
    }
    return contents;
};
const deserializeAws_ec2ModifyFleetResult = (output, context) => {
    let contents = {
        __type: "ModifyFleetResult",
        Return: undefined
    };
    if (output["return"] !== undefined) {
        contents.Return = output["return"] == "true";
    }
    return contents;
};
const deserializeAws_ec2ModifyFpgaImageAttributeResult = (output, context) => {
    let contents = {
        __type: "ModifyFpgaImageAttributeResult",
        FpgaImageAttribute: undefined
    };
    if (output["fpgaImageAttribute"] !== undefined) {
        contents.FpgaImageAttribute = deserializeAws_ec2FpgaImageAttribute(output["fpgaImageAttribute"], context);
    }
    return contents;
};
const deserializeAws_ec2ModifyHostsResult = (output, context) => {
    let contents = {
        __type: "ModifyHostsResult",
        Successful: undefined,
        Unsuccessful: undefined
    };
    if (output.successful === "") {
        contents.Successful = [];
    }
    if (output["successful"] !== undefined &&
        output["successful"]["item"] !== undefined) {
        const wrappedItem = output["successful"]["item"] instanceof Array
            ? output["successful"]["item"]
            : [output["successful"]["item"]];
        contents.Successful = deserializeAws_ec2ResponseHostIdList(wrappedItem, context);
    }
    if (output.unsuccessful === "") {
        contents.Unsuccessful = [];
    }
    if (output["unsuccessful"] !== undefined &&
        output["unsuccessful"]["item"] !== undefined) {
        const wrappedItem = output["unsuccessful"]["item"] instanceof Array
            ? output["unsuccessful"]["item"]
            : [output["unsuccessful"]["item"]];
        contents.Unsuccessful = deserializeAws_ec2UnsuccessfulItemList(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2ModifyInstanceCapacityReservationAttributesResult = (output, context) => {
    let contents = {
        __type: "ModifyInstanceCapacityReservationAttributesResult",
        Return: undefined
    };
    if (output["return"] !== undefined) {
        contents.Return = output["return"] == "true";
    }
    return contents;
};
const deserializeAws_ec2ModifyInstanceCreditSpecificationResult = (output, context) => {
    let contents = {
        __type: "ModifyInstanceCreditSpecificationResult",
        SuccessfulInstanceCreditSpecifications: undefined,
        UnsuccessfulInstanceCreditSpecifications: undefined
    };
    if (output.successfulInstanceCreditSpecificationSet === "") {
        contents.SuccessfulInstanceCreditSpecifications = [];
    }
    if (output["successfulInstanceCreditSpecificationSet"] !== undefined &&
        output["successfulInstanceCreditSpecificationSet"]["item"] !== undefined) {
        const wrappedItem = output["successfulInstanceCreditSpecificationSet"]["item"] instanceof
            Array
            ? output["successfulInstanceCreditSpecificationSet"]["item"]
            : [output["successfulInstanceCreditSpecificationSet"]["item"]];
        contents.SuccessfulInstanceCreditSpecifications = deserializeAws_ec2SuccessfulInstanceCreditSpecificationSet(wrappedItem, context);
    }
    if (output.unsuccessfulInstanceCreditSpecificationSet === "") {
        contents.UnsuccessfulInstanceCreditSpecifications = [];
    }
    if (output["unsuccessfulInstanceCreditSpecificationSet"] !== undefined &&
        output["unsuccessfulInstanceCreditSpecificationSet"]["item"] !== undefined) {
        const wrappedItem = output["unsuccessfulInstanceCreditSpecificationSet"]["item"] instanceof
            Array
            ? output["unsuccessfulInstanceCreditSpecificationSet"]["item"]
            : [output["unsuccessfulInstanceCreditSpecificationSet"]["item"]];
        contents.UnsuccessfulInstanceCreditSpecifications = deserializeAws_ec2UnsuccessfulInstanceCreditSpecificationSet(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2ModifyInstanceEventStartTimeResult = (output, context) => {
    let contents = {
        __type: "ModifyInstanceEventStartTimeResult",
        Event: undefined
    };
    if (output["event"] !== undefined) {
        contents.Event = deserializeAws_ec2InstanceStatusEvent(output["event"], context);
    }
    return contents;
};
const deserializeAws_ec2ModifyInstanceMetadataOptionsResult = (output, context) => {
    let contents = {
        __type: "ModifyInstanceMetadataOptionsResult",
        InstanceId: undefined,
        InstanceMetadataOptions: undefined
    };
    if (output["instanceId"] !== undefined) {
        contents.InstanceId = output["instanceId"];
    }
    if (output["instanceMetadataOptions"] !== undefined) {
        contents.InstanceMetadataOptions = deserializeAws_ec2InstanceMetadataOptionsResponse(output["instanceMetadataOptions"], context);
    }
    return contents;
};
const deserializeAws_ec2ModifyInstancePlacementResult = (output, context) => {
    let contents = {
        __type: "ModifyInstancePlacementResult",
        Return: undefined
    };
    if (output["return"] !== undefined) {
        contents.Return = output["return"] == "true";
    }
    return contents;
};
const deserializeAws_ec2ModifyLaunchTemplateResult = (output, context) => {
    let contents = {
        __type: "ModifyLaunchTemplateResult",
        LaunchTemplate: undefined
    };
    if (output["launchTemplate"] !== undefined) {
        contents.LaunchTemplate = deserializeAws_ec2LaunchTemplate(output["launchTemplate"], context);
    }
    return contents;
};
const deserializeAws_ec2ModifyReservedInstancesResult = (output, context) => {
    let contents = {
        __type: "ModifyReservedInstancesResult",
        ReservedInstancesModificationId: undefined
    };
    if (output["reservedInstancesModificationId"] !== undefined) {
        contents.ReservedInstancesModificationId =
            output["reservedInstancesModificationId"];
    }
    return contents;
};
const deserializeAws_ec2ModifySpotFleetRequestResponse = (output, context) => {
    let contents = {
        __type: "ModifySpotFleetRequestResponse",
        Return: undefined
    };
    if (output["return"] !== undefined) {
        contents.Return = output["return"] == "true";
    }
    return contents;
};
const deserializeAws_ec2ModifyTrafficMirrorFilterNetworkServicesResult = (output, context) => {
    let contents = {
        __type: "ModifyTrafficMirrorFilterNetworkServicesResult",
        TrafficMirrorFilter: undefined
    };
    if (output["trafficMirrorFilter"] !== undefined) {
        contents.TrafficMirrorFilter = deserializeAws_ec2TrafficMirrorFilter(output["trafficMirrorFilter"], context);
    }
    return contents;
};
const deserializeAws_ec2ModifyTrafficMirrorFilterRuleResult = (output, context) => {
    let contents = {
        __type: "ModifyTrafficMirrorFilterRuleResult",
        TrafficMirrorFilterRule: undefined
    };
    if (output["trafficMirrorFilterRule"] !== undefined) {
        contents.TrafficMirrorFilterRule = deserializeAws_ec2TrafficMirrorFilterRule(output["trafficMirrorFilterRule"], context);
    }
    return contents;
};
const deserializeAws_ec2ModifyTrafficMirrorSessionResult = (output, context) => {
    let contents = {
        __type: "ModifyTrafficMirrorSessionResult",
        TrafficMirrorSession: undefined
    };
    if (output["trafficMirrorSession"] !== undefined) {
        contents.TrafficMirrorSession = deserializeAws_ec2TrafficMirrorSession(output["trafficMirrorSession"], context);
    }
    return contents;
};
const deserializeAws_ec2ModifyTransitGatewayVpcAttachmentResult = (output, context) => {
    let contents = {
        __type: "ModifyTransitGatewayVpcAttachmentResult",
        TransitGatewayVpcAttachment: undefined
    };
    if (output["transitGatewayVpcAttachment"] !== undefined) {
        contents.TransitGatewayVpcAttachment = deserializeAws_ec2TransitGatewayVpcAttachment(output["transitGatewayVpcAttachment"], context);
    }
    return contents;
};
const deserializeAws_ec2ModifyVolumeResult = (output, context) => {
    let contents = {
        __type: "ModifyVolumeResult",
        VolumeModification: undefined
    };
    if (output["volumeModification"] !== undefined) {
        contents.VolumeModification = deserializeAws_ec2VolumeModification(output["volumeModification"], context);
    }
    return contents;
};
const deserializeAws_ec2ModifyVpcEndpointConnectionNotificationResult = (output, context) => {
    let contents = {
        __type: "ModifyVpcEndpointConnectionNotificationResult",
        ReturnValue: undefined
    };
    if (output["return"] !== undefined) {
        contents.ReturnValue = output["return"] == "true";
    }
    return contents;
};
const deserializeAws_ec2ModifyVpcEndpointResult = (output, context) => {
    let contents = {
        __type: "ModifyVpcEndpointResult",
        Return: undefined
    };
    if (output["return"] !== undefined) {
        contents.Return = output["return"] == "true";
    }
    return contents;
};
const deserializeAws_ec2ModifyVpcEndpointServiceConfigurationResult = (output, context) => {
    let contents = {
        __type: "ModifyVpcEndpointServiceConfigurationResult",
        Return: undefined
    };
    if (output["return"] !== undefined) {
        contents.Return = output["return"] == "true";
    }
    return contents;
};
const deserializeAws_ec2ModifyVpcEndpointServicePermissionsResult = (output, context) => {
    let contents = {
        __type: "ModifyVpcEndpointServicePermissionsResult",
        ReturnValue: undefined
    };
    if (output["return"] !== undefined) {
        contents.ReturnValue = output["return"] == "true";
    }
    return contents;
};
const deserializeAws_ec2ModifyVpcPeeringConnectionOptionsResult = (output, context) => {
    let contents = {
        __type: "ModifyVpcPeeringConnectionOptionsResult",
        AccepterPeeringConnectionOptions: undefined,
        RequesterPeeringConnectionOptions: undefined
    };
    if (output["accepterPeeringConnectionOptions"] !== undefined) {
        contents.AccepterPeeringConnectionOptions = deserializeAws_ec2PeeringConnectionOptions(output["accepterPeeringConnectionOptions"], context);
    }
    if (output["requesterPeeringConnectionOptions"] !== undefined) {
        contents.RequesterPeeringConnectionOptions = deserializeAws_ec2PeeringConnectionOptions(output["requesterPeeringConnectionOptions"], context);
    }
    return contents;
};
const deserializeAws_ec2ModifyVpcTenancyResult = (output, context) => {
    let contents = {
        __type: "ModifyVpcTenancyResult",
        ReturnValue: undefined
    };
    if (output["return"] !== undefined) {
        contents.ReturnValue = output["return"] == "true";
    }
    return contents;
};
const deserializeAws_ec2ModifyVpnConnectionResult = (output, context) => {
    let contents = {
        __type: "ModifyVpnConnectionResult",
        VpnConnection: undefined
    };
    if (output["vpnConnection"] !== undefined) {
        contents.VpnConnection = deserializeAws_ec2VpnConnection(output["vpnConnection"], context);
    }
    return contents;
};
const deserializeAws_ec2ModifyVpnTunnelCertificateResult = (output, context) => {
    let contents = {
        __type: "ModifyVpnTunnelCertificateResult",
        VpnConnection: undefined
    };
    if (output["vpnConnection"] !== undefined) {
        contents.VpnConnection = deserializeAws_ec2VpnConnection(output["vpnConnection"], context);
    }
    return contents;
};
const deserializeAws_ec2ModifyVpnTunnelOptionsResult = (output, context) => {
    let contents = {
        __type: "ModifyVpnTunnelOptionsResult",
        VpnConnection: undefined
    };
    if (output["vpnConnection"] !== undefined) {
        contents.VpnConnection = deserializeAws_ec2VpnConnection(output["vpnConnection"], context);
    }
    return contents;
};
const deserializeAws_ec2MonitorInstancesResult = (output, context) => {
    let contents = {
        __type: "MonitorInstancesResult",
        InstanceMonitorings: undefined
    };
    if (output.instancesSet === "") {
        contents.InstanceMonitorings = [];
    }
    if (output["instancesSet"] !== undefined &&
        output["instancesSet"]["item"] !== undefined) {
        const wrappedItem = output["instancesSet"]["item"] instanceof Array
            ? output["instancesSet"]["item"]
            : [output["instancesSet"]["item"]];
        contents.InstanceMonitorings = deserializeAws_ec2InstanceMonitoringList(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2Monitoring = (output, context) => {
    let contents = {
        __type: "Monitoring",
        State: undefined
    };
    if (output["state"] !== undefined) {
        contents.State = output["state"];
    }
    return contents;
};
const deserializeAws_ec2MoveAddressToVpcResult = (output, context) => {
    let contents = {
        __type: "MoveAddressToVpcResult",
        AllocationId: undefined,
        Status: undefined
    };
    if (output["allocationId"] !== undefined) {
        contents.AllocationId = output["allocationId"];
    }
    if (output["status"] !== undefined) {
        contents.Status = output["status"];
    }
    return contents;
};
const deserializeAws_ec2MovingAddressStatus = (output, context) => {
    let contents = {
        __type: "MovingAddressStatus",
        MoveStatus: undefined,
        PublicIp: undefined
    };
    if (output["moveStatus"] !== undefined) {
        contents.MoveStatus = output["moveStatus"];
    }
    if (output["publicIp"] !== undefined) {
        contents.PublicIp = output["publicIp"];
    }
    return contents;
};
const deserializeAws_ec2MovingAddressStatusSet = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2MovingAddressStatus(entry, context));
    });
    return contents;
};
const deserializeAws_ec2NatGateway = (output, context) => {
    let contents = {
        __type: "NatGateway",
        CreateTime: undefined,
        DeleteTime: undefined,
        FailureCode: undefined,
        FailureMessage: undefined,
        NatGatewayAddresses: undefined,
        NatGatewayId: undefined,
        ProvisionedBandwidth: undefined,
        State: undefined,
        SubnetId: undefined,
        Tags: undefined,
        VpcId: undefined
    };
    if (output["createTime"] !== undefined) {
        contents.CreateTime = new Date(output["createTime"]);
    }
    if (output["deleteTime"] !== undefined) {
        contents.DeleteTime = new Date(output["deleteTime"]);
    }
    if (output["failureCode"] !== undefined) {
        contents.FailureCode = output["failureCode"];
    }
    if (output["failureMessage"] !== undefined) {
        contents.FailureMessage = output["failureMessage"];
    }
    if (output.natGatewayAddressSet === "") {
        contents.NatGatewayAddresses = [];
    }
    if (output["natGatewayAddressSet"] !== undefined &&
        output["natGatewayAddressSet"]["item"] !== undefined) {
        const wrappedItem = output["natGatewayAddressSet"]["item"] instanceof Array
            ? output["natGatewayAddressSet"]["item"]
            : [output["natGatewayAddressSet"]["item"]];
        contents.NatGatewayAddresses = deserializeAws_ec2NatGatewayAddressList(wrappedItem, context);
    }
    if (output["natGatewayId"] !== undefined) {
        contents.NatGatewayId = output["natGatewayId"];
    }
    if (output["provisionedBandwidth"] !== undefined) {
        contents.ProvisionedBandwidth = deserializeAws_ec2ProvisionedBandwidth(output["provisionedBandwidth"], context);
    }
    if (output["state"] !== undefined) {
        contents.State = output["state"];
    }
    if (output["subnetId"] !== undefined) {
        contents.SubnetId = output["subnetId"];
    }
    if (output.tagSet === "") {
        contents.Tags = [];
    }
    if (output["tagSet"] !== undefined &&
        output["tagSet"]["item"] !== undefined) {
        const wrappedItem = output["tagSet"]["item"] instanceof Array
            ? output["tagSet"]["item"]
            : [output["tagSet"]["item"]];
        contents.Tags = deserializeAws_ec2TagList(wrappedItem, context);
    }
    if (output["vpcId"] !== undefined) {
        contents.VpcId = output["vpcId"];
    }
    return contents;
};
const deserializeAws_ec2NatGatewayAddress = (output, context) => {
    let contents = {
        __type: "NatGatewayAddress",
        AllocationId: undefined,
        NetworkInterfaceId: undefined,
        PrivateIp: undefined,
        PublicIp: undefined
    };
    if (output["allocationId"] !== undefined) {
        contents.AllocationId = output["allocationId"];
    }
    if (output["networkInterfaceId"] !== undefined) {
        contents.NetworkInterfaceId = output["networkInterfaceId"];
    }
    if (output["privateIp"] !== undefined) {
        contents.PrivateIp = output["privateIp"];
    }
    if (output["publicIp"] !== undefined) {
        contents.PublicIp = output["publicIp"];
    }
    return contents;
};
const deserializeAws_ec2NatGatewayAddressList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2NatGatewayAddress(entry, context));
    });
    return contents;
};
const deserializeAws_ec2NatGatewayList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2NatGateway(entry, context));
    });
    return contents;
};
const deserializeAws_ec2NetworkAcl = (output, context) => {
    let contents = {
        __type: "NetworkAcl",
        Associations: undefined,
        Entries: undefined,
        IsDefault: undefined,
        NetworkAclId: undefined,
        OwnerId: undefined,
        Tags: undefined,
        VpcId: undefined
    };
    if (output.associationSet === "") {
        contents.Associations = [];
    }
    if (output["associationSet"] !== undefined &&
        output["associationSet"]["item"] !== undefined) {
        const wrappedItem = output["associationSet"]["item"] instanceof Array
            ? output["associationSet"]["item"]
            : [output["associationSet"]["item"]];
        contents.Associations = deserializeAws_ec2NetworkAclAssociationList(wrappedItem, context);
    }
    if (output.entrySet === "") {
        contents.Entries = [];
    }
    if (output["entrySet"] !== undefined &&
        output["entrySet"]["item"] !== undefined) {
        const wrappedItem = output["entrySet"]["item"] instanceof Array
            ? output["entrySet"]["item"]
            : [output["entrySet"]["item"]];
        contents.Entries = deserializeAws_ec2NetworkAclEntryList(wrappedItem, context);
    }
    if (output["default"] !== undefined) {
        contents.IsDefault = output["default"] == "true";
    }
    if (output["networkAclId"] !== undefined) {
        contents.NetworkAclId = output["networkAclId"];
    }
    if (output["ownerId"] !== undefined) {
        contents.OwnerId = output["ownerId"];
    }
    if (output.tagSet === "") {
        contents.Tags = [];
    }
    if (output["tagSet"] !== undefined &&
        output["tagSet"]["item"] !== undefined) {
        const wrappedItem = output["tagSet"]["item"] instanceof Array
            ? output["tagSet"]["item"]
            : [output["tagSet"]["item"]];
        contents.Tags = deserializeAws_ec2TagList(wrappedItem, context);
    }
    if (output["vpcId"] !== undefined) {
        contents.VpcId = output["vpcId"];
    }
    return contents;
};
const deserializeAws_ec2NetworkAclAssociation = (output, context) => {
    let contents = {
        __type: "NetworkAclAssociation",
        NetworkAclAssociationId: undefined,
        NetworkAclId: undefined,
        SubnetId: undefined
    };
    if (output["networkAclAssociationId"] !== undefined) {
        contents.NetworkAclAssociationId = output["networkAclAssociationId"];
    }
    if (output["networkAclId"] !== undefined) {
        contents.NetworkAclId = output["networkAclId"];
    }
    if (output["subnetId"] !== undefined) {
        contents.SubnetId = output["subnetId"];
    }
    return contents;
};
const deserializeAws_ec2NetworkAclAssociationList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2NetworkAclAssociation(entry, context));
    });
    return contents;
};
const deserializeAws_ec2NetworkAclEntry = (output, context) => {
    let contents = {
        __type: "NetworkAclEntry",
        CidrBlock: undefined,
        Egress: undefined,
        IcmpTypeCode: undefined,
        Ipv6CidrBlock: undefined,
        PortRange: undefined,
        Protocol: undefined,
        RuleAction: undefined,
        RuleNumber: undefined
    };
    if (output["cidrBlock"] !== undefined) {
        contents.CidrBlock = output["cidrBlock"];
    }
    if (output["egress"] !== undefined) {
        contents.Egress = output["egress"] == "true";
    }
    if (output["icmpTypeCode"] !== undefined) {
        contents.IcmpTypeCode = deserializeAws_ec2IcmpTypeCode(output["icmpTypeCode"], context);
    }
    if (output["ipv6CidrBlock"] !== undefined) {
        contents.Ipv6CidrBlock = output["ipv6CidrBlock"];
    }
    if (output["portRange"] !== undefined) {
        contents.PortRange = deserializeAws_ec2PortRange(output["portRange"], context);
    }
    if (output["protocol"] !== undefined) {
        contents.Protocol = output["protocol"];
    }
    if (output["ruleAction"] !== undefined) {
        contents.RuleAction = output["ruleAction"];
    }
    if (output["ruleNumber"] !== undefined) {
        contents.RuleNumber = parseInt(output["ruleNumber"]);
    }
    return contents;
};
const deserializeAws_ec2NetworkAclEntryList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2NetworkAclEntry(entry, context));
    });
    return contents;
};
const deserializeAws_ec2NetworkAclList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2NetworkAcl(entry, context));
    });
    return contents;
};
const deserializeAws_ec2NetworkInfo = (output, context) => {
    let contents = {
        __type: "NetworkInfo",
        EnaSupport: undefined,
        Ipv4AddressesPerInterface: undefined,
        Ipv6AddressesPerInterface: undefined,
        Ipv6Supported: undefined,
        MaximumNetworkInterfaces: undefined,
        NetworkPerformance: undefined
    };
    if (output["enaSupport"] !== undefined) {
        contents.EnaSupport = output["enaSupport"];
    }
    if (output["ipv4AddressesPerInterface"] !== undefined) {
        contents.Ipv4AddressesPerInterface = parseInt(output["ipv4AddressesPerInterface"]);
    }
    if (output["ipv6AddressesPerInterface"] !== undefined) {
        contents.Ipv6AddressesPerInterface = parseInt(output["ipv6AddressesPerInterface"]);
    }
    if (output["ipv6Supported"] !== undefined) {
        contents.Ipv6Supported = output["ipv6Supported"] == "true";
    }
    if (output["maximumNetworkInterfaces"] !== undefined) {
        contents.MaximumNetworkInterfaces = parseInt(output["maximumNetworkInterfaces"]);
    }
    if (output["networkPerformance"] !== undefined) {
        contents.NetworkPerformance = output["networkPerformance"];
    }
    return contents;
};
const deserializeAws_ec2NetworkInterface = (output, context) => {
    let contents = {
        __type: "NetworkInterface",
        Association: undefined,
        Attachment: undefined,
        AvailabilityZone: undefined,
        Description: undefined,
        Groups: undefined,
        InterfaceType: undefined,
        Ipv6Addresses: undefined,
        MacAddress: undefined,
        NetworkInterfaceId: undefined,
        OutpostArn: undefined,
        OwnerId: undefined,
        PrivateDnsName: undefined,
        PrivateIpAddress: undefined,
        PrivateIpAddresses: undefined,
        RequesterId: undefined,
        RequesterManaged: undefined,
        SourceDestCheck: undefined,
        Status: undefined,
        SubnetId: undefined,
        TagSet: undefined,
        VpcId: undefined
    };
    if (output["association"] !== undefined) {
        contents.Association = deserializeAws_ec2NetworkInterfaceAssociation(output["association"], context);
    }
    if (output["attachment"] !== undefined) {
        contents.Attachment = deserializeAws_ec2NetworkInterfaceAttachment(output["attachment"], context);
    }
    if (output["availabilityZone"] !== undefined) {
        contents.AvailabilityZone = output["availabilityZone"];
    }
    if (output["description"] !== undefined) {
        contents.Description = output["description"];
    }
    if (output.groupSet === "") {
        contents.Groups = [];
    }
    if (output["groupSet"] !== undefined &&
        output["groupSet"]["item"] !== undefined) {
        const wrappedItem = output["groupSet"]["item"] instanceof Array
            ? output["groupSet"]["item"]
            : [output["groupSet"]["item"]];
        contents.Groups = deserializeAws_ec2GroupIdentifierList(wrappedItem, context);
    }
    if (output["interfaceType"] !== undefined) {
        contents.InterfaceType = output["interfaceType"];
    }
    if (output.ipv6AddressesSet === "") {
        contents.Ipv6Addresses = [];
    }
    if (output["ipv6AddressesSet"] !== undefined &&
        output["ipv6AddressesSet"]["item"] !== undefined) {
        const wrappedItem = output["ipv6AddressesSet"]["item"] instanceof Array
            ? output["ipv6AddressesSet"]["item"]
            : [output["ipv6AddressesSet"]["item"]];
        contents.Ipv6Addresses = deserializeAws_ec2NetworkInterfaceIpv6AddressesList(wrappedItem, context);
    }
    if (output["macAddress"] !== undefined) {
        contents.MacAddress = output["macAddress"];
    }
    if (output["networkInterfaceId"] !== undefined) {
        contents.NetworkInterfaceId = output["networkInterfaceId"];
    }
    if (output["outpostArn"] !== undefined) {
        contents.OutpostArn = output["outpostArn"];
    }
    if (output["ownerId"] !== undefined) {
        contents.OwnerId = output["ownerId"];
    }
    if (output["privateDnsName"] !== undefined) {
        contents.PrivateDnsName = output["privateDnsName"];
    }
    if (output["privateIpAddress"] !== undefined) {
        contents.PrivateIpAddress = output["privateIpAddress"];
    }
    if (output.privateIpAddressesSet === "") {
        contents.PrivateIpAddresses = [];
    }
    if (output["privateIpAddressesSet"] !== undefined &&
        output["privateIpAddressesSet"]["item"] !== undefined) {
        const wrappedItem = output["privateIpAddressesSet"]["item"] instanceof Array
            ? output["privateIpAddressesSet"]["item"]
            : [output["privateIpAddressesSet"]["item"]];
        contents.PrivateIpAddresses = deserializeAws_ec2NetworkInterfacePrivateIpAddressList(wrappedItem, context);
    }
    if (output["requesterId"] !== undefined) {
        contents.RequesterId = output["requesterId"];
    }
    if (output["requesterManaged"] !== undefined) {
        contents.RequesterManaged = output["requesterManaged"] == "true";
    }
    if (output["sourceDestCheck"] !== undefined) {
        contents.SourceDestCheck = output["sourceDestCheck"] == "true";
    }
    if (output["status"] !== undefined) {
        contents.Status = output["status"];
    }
    if (output["subnetId"] !== undefined) {
        contents.SubnetId = output["subnetId"];
    }
    if (output.tagSet === "") {
        contents.TagSet = [];
    }
    if (output["tagSet"] !== undefined &&
        output["tagSet"]["item"] !== undefined) {
        const wrappedItem = output["tagSet"]["item"] instanceof Array
            ? output["tagSet"]["item"]
            : [output["tagSet"]["item"]];
        contents.TagSet = deserializeAws_ec2TagList(wrappedItem, context);
    }
    if (output["vpcId"] !== undefined) {
        contents.VpcId = output["vpcId"];
    }
    return contents;
};
const deserializeAws_ec2NetworkInterfaceAssociation = (output, context) => {
    let contents = {
        __type: "NetworkInterfaceAssociation",
        AllocationId: undefined,
        AssociationId: undefined,
        IpOwnerId: undefined,
        PublicDnsName: undefined,
        PublicIp: undefined
    };
    if (output["allocationId"] !== undefined) {
        contents.AllocationId = output["allocationId"];
    }
    if (output["associationId"] !== undefined) {
        contents.AssociationId = output["associationId"];
    }
    if (output["ipOwnerId"] !== undefined) {
        contents.IpOwnerId = output["ipOwnerId"];
    }
    if (output["publicDnsName"] !== undefined) {
        contents.PublicDnsName = output["publicDnsName"];
    }
    if (output["publicIp"] !== undefined) {
        contents.PublicIp = output["publicIp"];
    }
    return contents;
};
const deserializeAws_ec2NetworkInterfaceAttachment = (output, context) => {
    let contents = {
        __type: "NetworkInterfaceAttachment",
        AttachTime: undefined,
        AttachmentId: undefined,
        DeleteOnTermination: undefined,
        DeviceIndex: undefined,
        InstanceId: undefined,
        InstanceOwnerId: undefined,
        Status: undefined
    };
    if (output["attachTime"] !== undefined) {
        contents.AttachTime = new Date(output["attachTime"]);
    }
    if (output["attachmentId"] !== undefined) {
        contents.AttachmentId = output["attachmentId"];
    }
    if (output["deleteOnTermination"] !== undefined) {
        contents.DeleteOnTermination = output["deleteOnTermination"] == "true";
    }
    if (output["deviceIndex"] !== undefined) {
        contents.DeviceIndex = parseInt(output["deviceIndex"]);
    }
    if (output["instanceId"] !== undefined) {
        contents.InstanceId = output["instanceId"];
    }
    if (output["instanceOwnerId"] !== undefined) {
        contents.InstanceOwnerId = output["instanceOwnerId"];
    }
    if (output["status"] !== undefined) {
        contents.Status = output["status"];
    }
    return contents;
};
const deserializeAws_ec2NetworkInterfaceIpv6Address = (output, context) => {
    let contents = {
        __type: "NetworkInterfaceIpv6Address",
        Ipv6Address: undefined
    };
    if (output["ipv6Address"] !== undefined) {
        contents.Ipv6Address = output["ipv6Address"];
    }
    return contents;
};
const deserializeAws_ec2NetworkInterfaceIpv6AddressesList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2NetworkInterfaceIpv6Address(entry, context));
    });
    return contents;
};
const deserializeAws_ec2NetworkInterfaceList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2NetworkInterface(entry, context));
    });
    return contents;
};
const deserializeAws_ec2NetworkInterfacePermission = (output, context) => {
    let contents = {
        __type: "NetworkInterfacePermission",
        AwsAccountId: undefined,
        AwsService: undefined,
        NetworkInterfaceId: undefined,
        NetworkInterfacePermissionId: undefined,
        Permission: undefined,
        PermissionState: undefined
    };
    if (output["awsAccountId"] !== undefined) {
        contents.AwsAccountId = output["awsAccountId"];
    }
    if (output["awsService"] !== undefined) {
        contents.AwsService = output["awsService"];
    }
    if (output["networkInterfaceId"] !== undefined) {
        contents.NetworkInterfaceId = output["networkInterfaceId"];
    }
    if (output["networkInterfacePermissionId"] !== undefined) {
        contents.NetworkInterfacePermissionId =
            output["networkInterfacePermissionId"];
    }
    if (output["permission"] !== undefined) {
        contents.Permission = output["permission"];
    }
    if (output["permissionState"] !== undefined) {
        contents.PermissionState = deserializeAws_ec2NetworkInterfacePermissionState(output["permissionState"], context);
    }
    return contents;
};
const deserializeAws_ec2NetworkInterfacePermissionList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2NetworkInterfacePermission(entry, context));
    });
    return contents;
};
const deserializeAws_ec2NetworkInterfacePermissionState = (output, context) => {
    let contents = {
        __type: "NetworkInterfacePermissionState",
        State: undefined,
        StatusMessage: undefined
    };
    if (output["state"] !== undefined) {
        contents.State = output["state"];
    }
    if (output["statusMessage"] !== undefined) {
        contents.StatusMessage = output["statusMessage"];
    }
    return contents;
};
const deserializeAws_ec2NetworkInterfacePrivateIpAddress = (output, context) => {
    let contents = {
        __type: "NetworkInterfacePrivateIpAddress",
        Association: undefined,
        Primary: undefined,
        PrivateDnsName: undefined,
        PrivateIpAddress: undefined
    };
    if (output["association"] !== undefined) {
        contents.Association = deserializeAws_ec2NetworkInterfaceAssociation(output["association"], context);
    }
    if (output["primary"] !== undefined) {
        contents.Primary = output["primary"] == "true";
    }
    if (output["privateDnsName"] !== undefined) {
        contents.PrivateDnsName = output["privateDnsName"];
    }
    if (output["privateIpAddress"] !== undefined) {
        contents.PrivateIpAddress = output["privateIpAddress"];
    }
    return contents;
};
const deserializeAws_ec2NetworkInterfacePrivateIpAddressList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2NetworkInterfacePrivateIpAddress(entry, context));
    });
    return contents;
};
const deserializeAws_ec2OccurrenceDaySet = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(parseInt(entry));
    });
    return contents;
};
const deserializeAws_ec2OnDemandOptions = (output, context) => {
    let contents = {
        __type: "OnDemandOptions",
        AllocationStrategy: undefined,
        CapacityReservationOptions: undefined,
        MaxTotalPrice: undefined,
        MinTargetCapacity: undefined,
        SingleAvailabilityZone: undefined,
        SingleInstanceType: undefined
    };
    if (output["allocationStrategy"] !== undefined) {
        contents.AllocationStrategy = output["allocationStrategy"];
    }
    if (output["capacityReservationOptions"] !== undefined) {
        contents.CapacityReservationOptions = deserializeAws_ec2CapacityReservationOptions(output["capacityReservationOptions"], context);
    }
    if (output["maxTotalPrice"] !== undefined) {
        contents.MaxTotalPrice = output["maxTotalPrice"];
    }
    if (output["minTargetCapacity"] !== undefined) {
        contents.MinTargetCapacity = parseInt(output["minTargetCapacity"]);
    }
    if (output["singleAvailabilityZone"] !== undefined) {
        contents.SingleAvailabilityZone =
            output["singleAvailabilityZone"] == "true";
    }
    if (output["singleInstanceType"] !== undefined) {
        contents.SingleInstanceType = output["singleInstanceType"] == "true";
    }
    return contents;
};
const deserializeAws_ec2PciId = (output, context) => {
    let contents = {
        __type: "PciId",
        DeviceId: undefined,
        SubsystemId: undefined,
        SubsystemVendorId: undefined,
        VendorId: undefined
    };
    if (output["DeviceId"] !== undefined) {
        contents.DeviceId = output["DeviceId"];
    }
    if (output["SubsystemId"] !== undefined) {
        contents.SubsystemId = output["SubsystemId"];
    }
    if (output["SubsystemVendorId"] !== undefined) {
        contents.SubsystemVendorId = output["SubsystemVendorId"];
    }
    if (output["VendorId"] !== undefined) {
        contents.VendorId = output["VendorId"];
    }
    return contents;
};
const deserializeAws_ec2PeeringAttachmentStatus = (output, context) => {
    let contents = {
        __type: "PeeringAttachmentStatus",
        Code: undefined,
        Message: undefined
    };
    if (output["code"] !== undefined) {
        contents.Code = output["code"];
    }
    if (output["message"] !== undefined) {
        contents.Message = output["message"];
    }
    return contents;
};
const deserializeAws_ec2PeeringConnectionOptions = (output, context) => {
    let contents = {
        __type: "PeeringConnectionOptions",
        AllowDnsResolutionFromRemoteVpc: undefined,
        AllowEgressFromLocalClassicLinkToRemoteVpc: undefined,
        AllowEgressFromLocalVpcToRemoteClassicLink: undefined
    };
    if (output["allowDnsResolutionFromRemoteVpc"] !== undefined) {
        contents.AllowDnsResolutionFromRemoteVpc =
            output["allowDnsResolutionFromRemoteVpc"] == "true";
    }
    if (output["allowEgressFromLocalClassicLinkToRemoteVpc"] !== undefined) {
        contents.AllowEgressFromLocalClassicLinkToRemoteVpc =
            output["allowEgressFromLocalClassicLinkToRemoteVpc"] == "true";
    }
    if (output["allowEgressFromLocalVpcToRemoteClassicLink"] !== undefined) {
        contents.AllowEgressFromLocalVpcToRemoteClassicLink =
            output["allowEgressFromLocalVpcToRemoteClassicLink"] == "true";
    }
    return contents;
};
const deserializeAws_ec2PeeringTgwInfo = (output, context) => {
    let contents = {
        __type: "PeeringTgwInfo",
        OwnerId: undefined,
        Region: undefined,
        TransitGatewayId: undefined
    };
    if (output["ownerId"] !== undefined) {
        contents.OwnerId = output["ownerId"];
    }
    if (output["region"] !== undefined) {
        contents.Region = output["region"];
    }
    if (output["transitGatewayId"] !== undefined) {
        contents.TransitGatewayId = output["transitGatewayId"];
    }
    return contents;
};
const deserializeAws_ec2Phase1DHGroupNumbersList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2Phase1DHGroupNumbersListValue(entry, context));
    });
    return contents;
};
const deserializeAws_ec2Phase1DHGroupNumbersListValue = (output, context) => {
    let contents = {
        __type: "Phase1DHGroupNumbersListValue",
        Value: undefined
    };
    if (output["value"] !== undefined) {
        contents.Value = parseInt(output["value"]);
    }
    return contents;
};
const deserializeAws_ec2Phase1EncryptionAlgorithmsList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2Phase1EncryptionAlgorithmsListValue(entry, context));
    });
    return contents;
};
const deserializeAws_ec2Phase1EncryptionAlgorithmsListValue = (output, context) => {
    let contents = {
        __type: "Phase1EncryptionAlgorithmsListValue",
        Value: undefined
    };
    if (output["value"] !== undefined) {
        contents.Value = output["value"];
    }
    return contents;
};
const deserializeAws_ec2Phase1IntegrityAlgorithmsList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2Phase1IntegrityAlgorithmsListValue(entry, context));
    });
    return contents;
};
const deserializeAws_ec2Phase1IntegrityAlgorithmsListValue = (output, context) => {
    let contents = {
        __type: "Phase1IntegrityAlgorithmsListValue",
        Value: undefined
    };
    if (output["value"] !== undefined) {
        contents.Value = output["value"];
    }
    return contents;
};
const deserializeAws_ec2Phase2DHGroupNumbersList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2Phase2DHGroupNumbersListValue(entry, context));
    });
    return contents;
};
const deserializeAws_ec2Phase2DHGroupNumbersListValue = (output, context) => {
    let contents = {
        __type: "Phase2DHGroupNumbersListValue",
        Value: undefined
    };
    if (output["value"] !== undefined) {
        contents.Value = parseInt(output["value"]);
    }
    return contents;
};
const deserializeAws_ec2Phase2EncryptionAlgorithmsList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2Phase2EncryptionAlgorithmsListValue(entry, context));
    });
    return contents;
};
const deserializeAws_ec2Phase2EncryptionAlgorithmsListValue = (output, context) => {
    let contents = {
        __type: "Phase2EncryptionAlgorithmsListValue",
        Value: undefined
    };
    if (output["value"] !== undefined) {
        contents.Value = output["value"];
    }
    return contents;
};
const deserializeAws_ec2Phase2IntegrityAlgorithmsList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2Phase2IntegrityAlgorithmsListValue(entry, context));
    });
    return contents;
};
const deserializeAws_ec2Phase2IntegrityAlgorithmsListValue = (output, context) => {
    let contents = {
        __type: "Phase2IntegrityAlgorithmsListValue",
        Value: undefined
    };
    if (output["value"] !== undefined) {
        contents.Value = output["value"];
    }
    return contents;
};
const deserializeAws_ec2Placement = (output, context) => {
    let contents = {
        __type: "Placement",
        Affinity: undefined,
        AvailabilityZone: undefined,
        GroupName: undefined,
        HostId: undefined,
        HostResourceGroupArn: undefined,
        PartitionNumber: undefined,
        SpreadDomain: undefined,
        Tenancy: undefined
    };
    if (output["affinity"] !== undefined) {
        contents.Affinity = output["affinity"];
    }
    if (output["availabilityZone"] !== undefined) {
        contents.AvailabilityZone = output["availabilityZone"];
    }
    if (output["groupName"] !== undefined) {
        contents.GroupName = output["groupName"];
    }
    if (output["hostId"] !== undefined) {
        contents.HostId = output["hostId"];
    }
    if (output["hostResourceGroupArn"] !== undefined) {
        contents.HostResourceGroupArn = output["hostResourceGroupArn"];
    }
    if (output["partitionNumber"] !== undefined) {
        contents.PartitionNumber = parseInt(output["partitionNumber"]);
    }
    if (output["spreadDomain"] !== undefined) {
        contents.SpreadDomain = output["spreadDomain"];
    }
    if (output["tenancy"] !== undefined) {
        contents.Tenancy = output["tenancy"];
    }
    return contents;
};
const deserializeAws_ec2PlacementGroup = (output, context) => {
    let contents = {
        __type: "PlacementGroup",
        GroupId: undefined,
        GroupName: undefined,
        PartitionCount: undefined,
        State: undefined,
        Strategy: undefined,
        Tags: undefined
    };
    if (output["groupId"] !== undefined) {
        contents.GroupId = output["groupId"];
    }
    if (output["groupName"] !== undefined) {
        contents.GroupName = output["groupName"];
    }
    if (output["partitionCount"] !== undefined) {
        contents.PartitionCount = parseInt(output["partitionCount"]);
    }
    if (output["state"] !== undefined) {
        contents.State = output["state"];
    }
    if (output["strategy"] !== undefined) {
        contents.Strategy = output["strategy"];
    }
    if (output.tagSet === "") {
        contents.Tags = [];
    }
    if (output["tagSet"] !== undefined &&
        output["tagSet"]["item"] !== undefined) {
        const wrappedItem = output["tagSet"]["item"] instanceof Array
            ? output["tagSet"]["item"]
            : [output["tagSet"]["item"]];
        contents.Tags = deserializeAws_ec2TagList(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2PlacementGroupInfo = (output, context) => {
    let contents = {
        __type: "PlacementGroupInfo",
        SupportedStrategies: undefined
    };
    if (output.supportedStrategies === "") {
        contents.SupportedStrategies = [];
    }
    if (output["supportedStrategies"] !== undefined &&
        output["supportedStrategies"]["item"] !== undefined) {
        const wrappedItem = output["supportedStrategies"]["item"] instanceof Array
            ? output["supportedStrategies"]["item"]
            : [output["supportedStrategies"]["item"]];
        contents.SupportedStrategies = deserializeAws_ec2PlacementGroupStrategyList(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2PlacementGroupList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2PlacementGroup(entry, context));
    });
    return contents;
};
const deserializeAws_ec2PlacementGroupStrategyList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(entry);
    });
    return contents;
};
const deserializeAws_ec2PlacementResponse = (output, context) => {
    let contents = {
        __type: "PlacementResponse",
        GroupName: undefined
    };
    if (output["groupName"] !== undefined) {
        contents.GroupName = output["groupName"];
    }
    return contents;
};
const deserializeAws_ec2PoolCidrBlock = (output, context) => {
    let contents = {
        __type: "PoolCidrBlock",
        Cidr: undefined
    };
    if (output["poolCidrBlock"] !== undefined) {
        contents.Cidr = output["poolCidrBlock"];
    }
    return contents;
};
const deserializeAws_ec2PoolCidrBlocksSet = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2PoolCidrBlock(entry, context));
    });
    return contents;
};
const deserializeAws_ec2PortRange = (output, context) => {
    let contents = {
        __type: "PortRange",
        From: undefined,
        To: undefined
    };
    if (output["from"] !== undefined) {
        contents.From = parseInt(output["from"]);
    }
    if (output["to"] !== undefined) {
        contents.To = parseInt(output["to"]);
    }
    return contents;
};
const deserializeAws_ec2PrefixList = (output, context) => {
    let contents = {
        __type: "PrefixList",
        Cidrs: undefined,
        PrefixListId: undefined,
        PrefixListName: undefined
    };
    if (output.cidrSet === "") {
        contents.Cidrs = [];
    }
    if (output["cidrSet"] !== undefined &&
        output["cidrSet"]["item"] !== undefined) {
        const wrappedItem = output["cidrSet"]["item"] instanceof Array
            ? output["cidrSet"]["item"]
            : [output["cidrSet"]["item"]];
        contents.Cidrs = deserializeAws_ec2ValueStringList(wrappedItem, context);
    }
    if (output["prefixListId"] !== undefined) {
        contents.PrefixListId = output["prefixListId"];
    }
    if (output["prefixListName"] !== undefined) {
        contents.PrefixListName = output["prefixListName"];
    }
    return contents;
};
const deserializeAws_ec2PrefixListId = (output, context) => {
    let contents = {
        __type: "PrefixListId",
        Description: undefined,
        PrefixListId: undefined
    };
    if (output["description"] !== undefined) {
        contents.Description = output["description"];
    }
    if (output["prefixListId"] !== undefined) {
        contents.PrefixListId = output["prefixListId"];
    }
    return contents;
};
const deserializeAws_ec2PrefixListIdList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2PrefixListId(entry, context));
    });
    return contents;
};
const deserializeAws_ec2PrefixListIdSet = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(entry);
    });
    return contents;
};
const deserializeAws_ec2PrefixListSet = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2PrefixList(entry, context));
    });
    return contents;
};
const deserializeAws_ec2PriceSchedule = (output, context) => {
    let contents = {
        __type: "PriceSchedule",
        Active: undefined,
        CurrencyCode: undefined,
        Price: undefined,
        Term: undefined
    };
    if (output["active"] !== undefined) {
        contents.Active = output["active"] == "true";
    }
    if (output["currencyCode"] !== undefined) {
        contents.CurrencyCode = output["currencyCode"];
    }
    if (output["price"] !== undefined) {
        contents.Price = parseFloat(output["price"]);
    }
    if (output["term"] !== undefined) {
        contents.Term = parseInt(output["term"]);
    }
    return contents;
};
const deserializeAws_ec2PriceScheduleList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2PriceSchedule(entry, context));
    });
    return contents;
};
const deserializeAws_ec2PricingDetail = (output, context) => {
    let contents = {
        __type: "PricingDetail",
        Count: undefined,
        Price: undefined
    };
    if (output["count"] !== undefined) {
        contents.Count = parseInt(output["count"]);
    }
    if (output["price"] !== undefined) {
        contents.Price = parseFloat(output["price"]);
    }
    return contents;
};
const deserializeAws_ec2PricingDetailsList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2PricingDetail(entry, context));
    });
    return contents;
};
const deserializeAws_ec2PrincipalIdFormat = (output, context) => {
    let contents = {
        __type: "PrincipalIdFormat",
        Arn: undefined,
        Statuses: undefined
    };
    if (output["arn"] !== undefined) {
        contents.Arn = output["arn"];
    }
    if (output.statusSet === "") {
        contents.Statuses = [];
    }
    if (output["statusSet"] !== undefined &&
        output["statusSet"]["item"] !== undefined) {
        const wrappedItem = output["statusSet"]["item"] instanceof Array
            ? output["statusSet"]["item"]
            : [output["statusSet"]["item"]];
        contents.Statuses = deserializeAws_ec2IdFormatList(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2PrincipalIdFormatList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2PrincipalIdFormat(entry, context));
    });
    return contents;
};
const deserializeAws_ec2PrivateDnsNameConfiguration = (output, context) => {
    let contents = {
        __type: "PrivateDnsNameConfiguration",
        Name: undefined,
        State: undefined,
        Type: undefined,
        Value: undefined
    };
    if (output["name"] !== undefined) {
        contents.Name = output["name"];
    }
    if (output["state"] !== undefined) {
        contents.State = output["state"];
    }
    if (output["type"] !== undefined) {
        contents.Type = output["type"];
    }
    if (output["value"] !== undefined) {
        contents.Value = output["value"];
    }
    return contents;
};
const deserializeAws_ec2PrivateIpAddressSpecification = (output, context) => {
    let contents = {
        __type: "PrivateIpAddressSpecification",
        Primary: undefined,
        PrivateIpAddress: undefined
    };
    if (output["primary"] !== undefined) {
        contents.Primary = output["primary"] == "true";
    }
    if (output["privateIpAddress"] !== undefined) {
        contents.PrivateIpAddress = output["privateIpAddress"];
    }
    return contents;
};
const deserializeAws_ec2PrivateIpAddressSpecificationList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2PrivateIpAddressSpecification(entry, context));
    });
    return contents;
};
const deserializeAws_ec2ProcessorInfo = (output, context) => {
    let contents = {
        __type: "ProcessorInfo",
        SupportedArchitectures: undefined,
        SustainedClockSpeedInGhz: undefined
    };
    if (output.supportedArchitectures === "") {
        contents.SupportedArchitectures = [];
    }
    if (output["supportedArchitectures"] !== undefined &&
        output["supportedArchitectures"]["item"] !== undefined) {
        const wrappedItem = output["supportedArchitectures"]["item"] instanceof Array
            ? output["supportedArchitectures"]["item"]
            : [output["supportedArchitectures"]["item"]];
        contents.SupportedArchitectures = deserializeAws_ec2ArchitectureTypeList(wrappedItem, context);
    }
    if (output["sustainedClockSpeedInGhz"] !== undefined) {
        contents.SustainedClockSpeedInGhz = parseFloat(output["sustainedClockSpeedInGhz"]);
    }
    return contents;
};
const deserializeAws_ec2ProductCode = (output, context) => {
    let contents = {
        __type: "ProductCode",
        ProductCodeId: undefined,
        ProductCodeType: undefined
    };
    if (output["productCode"] !== undefined) {
        contents.ProductCodeId = output["productCode"];
    }
    if (output["type"] !== undefined) {
        contents.ProductCodeType = output["type"];
    }
    return contents;
};
const deserializeAws_ec2ProductCodeList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2ProductCode(entry, context));
    });
    return contents;
};
const deserializeAws_ec2PropagatingVgw = (output, context) => {
    let contents = {
        __type: "PropagatingVgw",
        GatewayId: undefined
    };
    if (output["gatewayId"] !== undefined) {
        contents.GatewayId = output["gatewayId"];
    }
    return contents;
};
const deserializeAws_ec2PropagatingVgwList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2PropagatingVgw(entry, context));
    });
    return contents;
};
const deserializeAws_ec2ProvisionByoipCidrResult = (output, context) => {
    let contents = {
        __type: "ProvisionByoipCidrResult",
        ByoipCidr: undefined
    };
    if (output["byoipCidr"] !== undefined) {
        contents.ByoipCidr = deserializeAws_ec2ByoipCidr(output["byoipCidr"], context);
    }
    return contents;
};
const deserializeAws_ec2ProvisionedBandwidth = (output, context) => {
    let contents = {
        __type: "ProvisionedBandwidth",
        ProvisionTime: undefined,
        Provisioned: undefined,
        RequestTime: undefined,
        Requested: undefined,
        Status: undefined
    };
    if (output["provisionTime"] !== undefined) {
        contents.ProvisionTime = new Date(output["provisionTime"]);
    }
    if (output["provisioned"] !== undefined) {
        contents.Provisioned = output["provisioned"];
    }
    if (output["requestTime"] !== undefined) {
        contents.RequestTime = new Date(output["requestTime"]);
    }
    if (output["requested"] !== undefined) {
        contents.Requested = output["requested"];
    }
    if (output["status"] !== undefined) {
        contents.Status = output["status"];
    }
    return contents;
};
const deserializeAws_ec2PublicIpv4Pool = (output, context) => {
    let contents = {
        __type: "PublicIpv4Pool",
        Description: undefined,
        PoolAddressRanges: undefined,
        PoolId: undefined,
        TotalAddressCount: undefined,
        TotalAvailableAddressCount: undefined
    };
    if (output["description"] !== undefined) {
        contents.Description = output["description"];
    }
    if (output.poolAddressRangeSet === "") {
        contents.PoolAddressRanges = [];
    }
    if (output["poolAddressRangeSet"] !== undefined &&
        output["poolAddressRangeSet"]["item"] !== undefined) {
        const wrappedItem = output["poolAddressRangeSet"]["item"] instanceof Array
            ? output["poolAddressRangeSet"]["item"]
            : [output["poolAddressRangeSet"]["item"]];
        contents.PoolAddressRanges = deserializeAws_ec2PublicIpv4PoolRangeSet(wrappedItem, context);
    }
    if (output["poolId"] !== undefined) {
        contents.PoolId = output["poolId"];
    }
    if (output["totalAddressCount"] !== undefined) {
        contents.TotalAddressCount = parseInt(output["totalAddressCount"]);
    }
    if (output["totalAvailableAddressCount"] !== undefined) {
        contents.TotalAvailableAddressCount = parseInt(output["totalAvailableAddressCount"]);
    }
    return contents;
};
const deserializeAws_ec2PublicIpv4PoolRange = (output, context) => {
    let contents = {
        __type: "PublicIpv4PoolRange",
        AddressCount: undefined,
        AvailableAddressCount: undefined,
        FirstAddress: undefined,
        LastAddress: undefined
    };
    if (output["addressCount"] !== undefined) {
        contents.AddressCount = parseInt(output["addressCount"]);
    }
    if (output["availableAddressCount"] !== undefined) {
        contents.AvailableAddressCount = parseInt(output["availableAddressCount"]);
    }
    if (output["firstAddress"] !== undefined) {
        contents.FirstAddress = output["firstAddress"];
    }
    if (output["lastAddress"] !== undefined) {
        contents.LastAddress = output["lastAddress"];
    }
    return contents;
};
const deserializeAws_ec2PublicIpv4PoolRangeSet = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2PublicIpv4PoolRange(entry, context));
    });
    return contents;
};
const deserializeAws_ec2PublicIpv4PoolSet = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2PublicIpv4Pool(entry, context));
    });
    return contents;
};
const deserializeAws_ec2Purchase = (output, context) => {
    let contents = {
        __type: "Purchase",
        CurrencyCode: undefined,
        Duration: undefined,
        HostIdSet: undefined,
        HostReservationId: undefined,
        HourlyPrice: undefined,
        InstanceFamily: undefined,
        PaymentOption: undefined,
        UpfrontPrice: undefined
    };
    if (output["currencyCode"] !== undefined) {
        contents.CurrencyCode = output["currencyCode"];
    }
    if (output["duration"] !== undefined) {
        contents.Duration = parseInt(output["duration"]);
    }
    if (output.hostIdSet === "") {
        contents.HostIdSet = [];
    }
    if (output["hostIdSet"] !== undefined &&
        output["hostIdSet"]["item"] !== undefined) {
        const wrappedItem = output["hostIdSet"]["item"] instanceof Array
            ? output["hostIdSet"]["item"]
            : [output["hostIdSet"]["item"]];
        contents.HostIdSet = deserializeAws_ec2ResponseHostIdSet(wrappedItem, context);
    }
    if (output["hostReservationId"] !== undefined) {
        contents.HostReservationId = output["hostReservationId"];
    }
    if (output["hourlyPrice"] !== undefined) {
        contents.HourlyPrice = output["hourlyPrice"];
    }
    if (output["instanceFamily"] !== undefined) {
        contents.InstanceFamily = output["instanceFamily"];
    }
    if (output["paymentOption"] !== undefined) {
        contents.PaymentOption = output["paymentOption"];
    }
    if (output["upfrontPrice"] !== undefined) {
        contents.UpfrontPrice = output["upfrontPrice"];
    }
    return contents;
};
const deserializeAws_ec2PurchaseHostReservationResult = (output, context) => {
    let contents = {
        __type: "PurchaseHostReservationResult",
        ClientToken: undefined,
        CurrencyCode: undefined,
        Purchase: undefined,
        TotalHourlyPrice: undefined,
        TotalUpfrontPrice: undefined
    };
    if (output["clientToken"] !== undefined) {
        contents.ClientToken = output["clientToken"];
    }
    if (output["currencyCode"] !== undefined) {
        contents.CurrencyCode = output["currencyCode"];
    }
    if (output.purchase === "") {
        contents.Purchase = [];
    }
    if (output["purchase"] !== undefined &&
        output["purchase"]["item"] !== undefined) {
        const wrappedItem = output["purchase"]["item"] instanceof Array
            ? output["purchase"]["item"]
            : [output["purchase"]["item"]];
        contents.Purchase = deserializeAws_ec2PurchaseSet(wrappedItem, context);
    }
    if (output["totalHourlyPrice"] !== undefined) {
        contents.TotalHourlyPrice = output["totalHourlyPrice"];
    }
    if (output["totalUpfrontPrice"] !== undefined) {
        contents.TotalUpfrontPrice = output["totalUpfrontPrice"];
    }
    return contents;
};
const deserializeAws_ec2PurchaseReservedInstancesOfferingResult = (output, context) => {
    let contents = {
        __type: "PurchaseReservedInstancesOfferingResult",
        ReservedInstancesId: undefined
    };
    if (output["reservedInstancesId"] !== undefined) {
        contents.ReservedInstancesId = output["reservedInstancesId"];
    }
    return contents;
};
const deserializeAws_ec2PurchaseScheduledInstancesResult = (output, context) => {
    let contents = {
        __type: "PurchaseScheduledInstancesResult",
        ScheduledInstanceSet: undefined
    };
    if (output.scheduledInstanceSet === "") {
        contents.ScheduledInstanceSet = [];
    }
    if (output["scheduledInstanceSet"] !== undefined &&
        output["scheduledInstanceSet"]["item"] !== undefined) {
        const wrappedItem = output["scheduledInstanceSet"]["item"] instanceof Array
            ? output["scheduledInstanceSet"]["item"]
            : [output["scheduledInstanceSet"]["item"]];
        contents.ScheduledInstanceSet = deserializeAws_ec2PurchasedScheduledInstanceSet(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2PurchaseSet = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2Purchase(entry, context));
    });
    return contents;
};
const deserializeAws_ec2PurchasedScheduledInstanceSet = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2ScheduledInstance(entry, context));
    });
    return contents;
};
const deserializeAws_ec2RecurringCharge = (output, context) => {
    let contents = {
        __type: "RecurringCharge",
        Amount: undefined,
        Frequency: undefined
    };
    if (output["amount"] !== undefined) {
        contents.Amount = parseFloat(output["amount"]);
    }
    if (output["frequency"] !== undefined) {
        contents.Frequency = output["frequency"];
    }
    return contents;
};
const deserializeAws_ec2RecurringChargesList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2RecurringCharge(entry, context));
    });
    return contents;
};
const deserializeAws_ec2Region = (output, context) => {
    let contents = {
        __type: "Region",
        Endpoint: undefined,
        OptInStatus: undefined,
        RegionName: undefined
    };
    if (output["regionEndpoint"] !== undefined) {
        contents.Endpoint = output["regionEndpoint"];
    }
    if (output["optInStatus"] !== undefined) {
        contents.OptInStatus = output["optInStatus"];
    }
    if (output["regionName"] !== undefined) {
        contents.RegionName = output["regionName"];
    }
    return contents;
};
const deserializeAws_ec2RegionList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2Region(entry, context));
    });
    return contents;
};
const deserializeAws_ec2RegisterImageResult = (output, context) => {
    let contents = {
        __type: "RegisterImageResult",
        ImageId: undefined
    };
    if (output["imageId"] !== undefined) {
        contents.ImageId = output["imageId"];
    }
    return contents;
};
const deserializeAws_ec2RegisterTransitGatewayMulticastGroupMembersResult = (output, context) => {
    let contents = {
        __type: "RegisterTransitGatewayMulticastGroupMembersResult",
        RegisteredMulticastGroupMembers: undefined
    };
    if (output["registeredMulticastGroupMembers"] !== undefined) {
        contents.RegisteredMulticastGroupMembers = deserializeAws_ec2TransitGatewayMulticastRegisteredGroupMembers(output["registeredMulticastGroupMembers"], context);
    }
    return contents;
};
const deserializeAws_ec2RegisterTransitGatewayMulticastGroupSourcesResult = (output, context) => {
    let contents = {
        __type: "RegisterTransitGatewayMulticastGroupSourcesResult",
        RegisteredMulticastGroupSources: undefined
    };
    if (output["registeredMulticastGroupSources"] !== undefined) {
        contents.RegisteredMulticastGroupSources = deserializeAws_ec2TransitGatewayMulticastRegisteredGroupSources(output["registeredMulticastGroupSources"], context);
    }
    return contents;
};
const deserializeAws_ec2RejectTransitGatewayPeeringAttachmentResult = (output, context) => {
    let contents = {
        __type: "RejectTransitGatewayPeeringAttachmentResult",
        TransitGatewayPeeringAttachment: undefined
    };
    if (output["transitGatewayPeeringAttachment"] !== undefined) {
        contents.TransitGatewayPeeringAttachment = deserializeAws_ec2TransitGatewayPeeringAttachment(output["transitGatewayPeeringAttachment"], context);
    }
    return contents;
};
const deserializeAws_ec2RejectTransitGatewayVpcAttachmentResult = (output, context) => {
    let contents = {
        __type: "RejectTransitGatewayVpcAttachmentResult",
        TransitGatewayVpcAttachment: undefined
    };
    if (output["transitGatewayVpcAttachment"] !== undefined) {
        contents.TransitGatewayVpcAttachment = deserializeAws_ec2TransitGatewayVpcAttachment(output["transitGatewayVpcAttachment"], context);
    }
    return contents;
};
const deserializeAws_ec2RejectVpcEndpointConnectionsResult = (output, context) => {
    let contents = {
        __type: "RejectVpcEndpointConnectionsResult",
        Unsuccessful: undefined
    };
    if (output.unsuccessful === "") {
        contents.Unsuccessful = [];
    }
    if (output["unsuccessful"] !== undefined &&
        output["unsuccessful"]["item"] !== undefined) {
        const wrappedItem = output["unsuccessful"]["item"] instanceof Array
            ? output["unsuccessful"]["item"]
            : [output["unsuccessful"]["item"]];
        contents.Unsuccessful = deserializeAws_ec2UnsuccessfulItemSet(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2RejectVpcPeeringConnectionResult = (output, context) => {
    let contents = {
        __type: "RejectVpcPeeringConnectionResult",
        Return: undefined
    };
    if (output["return"] !== undefined) {
        contents.Return = output["return"] == "true";
    }
    return contents;
};
const deserializeAws_ec2ReleaseHostsResult = (output, context) => {
    let contents = {
        __type: "ReleaseHostsResult",
        Successful: undefined,
        Unsuccessful: undefined
    };
    if (output.successful === "") {
        contents.Successful = [];
    }
    if (output["successful"] !== undefined &&
        output["successful"]["item"] !== undefined) {
        const wrappedItem = output["successful"]["item"] instanceof Array
            ? output["successful"]["item"]
            : [output["successful"]["item"]];
        contents.Successful = deserializeAws_ec2ResponseHostIdList(wrappedItem, context);
    }
    if (output.unsuccessful === "") {
        contents.Unsuccessful = [];
    }
    if (output["unsuccessful"] !== undefined &&
        output["unsuccessful"]["item"] !== undefined) {
        const wrappedItem = output["unsuccessful"]["item"] instanceof Array
            ? output["unsuccessful"]["item"]
            : [output["unsuccessful"]["item"]];
        contents.Unsuccessful = deserializeAws_ec2UnsuccessfulItemList(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2ReplaceIamInstanceProfileAssociationResult = (output, context) => {
    let contents = {
        __type: "ReplaceIamInstanceProfileAssociationResult",
        IamInstanceProfileAssociation: undefined
    };
    if (output["iamInstanceProfileAssociation"] !== undefined) {
        contents.IamInstanceProfileAssociation = deserializeAws_ec2IamInstanceProfileAssociation(output["iamInstanceProfileAssociation"], context);
    }
    return contents;
};
const deserializeAws_ec2ReplaceNetworkAclAssociationResult = (output, context) => {
    let contents = {
        __type: "ReplaceNetworkAclAssociationResult",
        NewAssociationId: undefined
    };
    if (output["newAssociationId"] !== undefined) {
        contents.NewAssociationId = output["newAssociationId"];
    }
    return contents;
};
const deserializeAws_ec2ReplaceRouteTableAssociationResult = (output, context) => {
    let contents = {
        __type: "ReplaceRouteTableAssociationResult",
        AssociationState: undefined,
        NewAssociationId: undefined
    };
    if (output["associationState"] !== undefined) {
        contents.AssociationState = deserializeAws_ec2RouteTableAssociationState(output["associationState"], context);
    }
    if (output["newAssociationId"] !== undefined) {
        contents.NewAssociationId = output["newAssociationId"];
    }
    return contents;
};
const deserializeAws_ec2ReplaceTransitGatewayRouteResult = (output, context) => {
    let contents = {
        __type: "ReplaceTransitGatewayRouteResult",
        Route: undefined
    };
    if (output["route"] !== undefined) {
        contents.Route = deserializeAws_ec2TransitGatewayRoute(output["route"], context);
    }
    return contents;
};
const deserializeAws_ec2RequestSpotFleetResponse = (output, context) => {
    let contents = {
        __type: "RequestSpotFleetResponse",
        SpotFleetRequestId: undefined
    };
    if (output["spotFleetRequestId"] !== undefined) {
        contents.SpotFleetRequestId = output["spotFleetRequestId"];
    }
    return contents;
};
const deserializeAws_ec2RequestSpotInstancesResult = (output, context) => {
    let contents = {
        __type: "RequestSpotInstancesResult",
        SpotInstanceRequests: undefined
    };
    if (output.spotInstanceRequestSet === "") {
        contents.SpotInstanceRequests = [];
    }
    if (output["spotInstanceRequestSet"] !== undefined &&
        output["spotInstanceRequestSet"]["item"] !== undefined) {
        const wrappedItem = output["spotInstanceRequestSet"]["item"] instanceof Array
            ? output["spotInstanceRequestSet"]["item"]
            : [output["spotInstanceRequestSet"]["item"]];
        contents.SpotInstanceRequests = deserializeAws_ec2SpotInstanceRequestList(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2Reservation = (output, context) => {
    let contents = {
        __type: "Reservation",
        Groups: undefined,
        Instances: undefined,
        OwnerId: undefined,
        RequesterId: undefined,
        ReservationId: undefined
    };
    if (output.groupSet === "") {
        contents.Groups = [];
    }
    if (output["groupSet"] !== undefined &&
        output["groupSet"]["item"] !== undefined) {
        const wrappedItem = output["groupSet"]["item"] instanceof Array
            ? output["groupSet"]["item"]
            : [output["groupSet"]["item"]];
        contents.Groups = deserializeAws_ec2GroupIdentifierList(wrappedItem, context);
    }
    if (output.instancesSet === "") {
        contents.Instances = [];
    }
    if (output["instancesSet"] !== undefined &&
        output["instancesSet"]["item"] !== undefined) {
        const wrappedItem = output["instancesSet"]["item"] instanceof Array
            ? output["instancesSet"]["item"]
            : [output["instancesSet"]["item"]];
        contents.Instances = deserializeAws_ec2InstanceList(wrappedItem, context);
    }
    if (output["ownerId"] !== undefined) {
        contents.OwnerId = output["ownerId"];
    }
    if (output["requesterId"] !== undefined) {
        contents.RequesterId = output["requesterId"];
    }
    if (output["reservationId"] !== undefined) {
        contents.ReservationId = output["reservationId"];
    }
    return contents;
};
const deserializeAws_ec2ReservationList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2Reservation(entry, context));
    });
    return contents;
};
const deserializeAws_ec2ReservationValue = (output, context) => {
    let contents = {
        __type: "ReservationValue",
        HourlyPrice: undefined,
        RemainingTotalValue: undefined,
        RemainingUpfrontValue: undefined
    };
    if (output["hourlyPrice"] !== undefined) {
        contents.HourlyPrice = output["hourlyPrice"];
    }
    if (output["remainingTotalValue"] !== undefined) {
        contents.RemainingTotalValue = output["remainingTotalValue"];
    }
    if (output["remainingUpfrontValue"] !== undefined) {
        contents.RemainingUpfrontValue = output["remainingUpfrontValue"];
    }
    return contents;
};
const deserializeAws_ec2ReservedInstanceReservationValue = (output, context) => {
    let contents = {
        __type: "ReservedInstanceReservationValue",
        ReservationValue: undefined,
        ReservedInstanceId: undefined
    };
    if (output["reservationValue"] !== undefined) {
        contents.ReservationValue = deserializeAws_ec2ReservationValue(output["reservationValue"], context);
    }
    if (output["reservedInstanceId"] !== undefined) {
        contents.ReservedInstanceId = output["reservedInstanceId"];
    }
    return contents;
};
const deserializeAws_ec2ReservedInstanceReservationValueSet = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2ReservedInstanceReservationValue(entry, context));
    });
    return contents;
};
const deserializeAws_ec2ReservedInstances = (output, context) => {
    let contents = {
        __type: "ReservedInstances",
        AvailabilityZone: undefined,
        CurrencyCode: undefined,
        Duration: undefined,
        End: undefined,
        FixedPrice: undefined,
        InstanceCount: undefined,
        InstanceTenancy: undefined,
        InstanceType: undefined,
        OfferingClass: undefined,
        OfferingType: undefined,
        ProductDescription: undefined,
        RecurringCharges: undefined,
        ReservedInstancesId: undefined,
        Scope: undefined,
        Start: undefined,
        State: undefined,
        Tags: undefined,
        UsagePrice: undefined
    };
    if (output["availabilityZone"] !== undefined) {
        contents.AvailabilityZone = output["availabilityZone"];
    }
    if (output["currencyCode"] !== undefined) {
        contents.CurrencyCode = output["currencyCode"];
    }
    if (output["duration"] !== undefined) {
        contents.Duration = parseInt(output["duration"]);
    }
    if (output["end"] !== undefined) {
        contents.End = new Date(output["end"]);
    }
    if (output["fixedPrice"] !== undefined) {
        contents.FixedPrice = parseFloat(output["fixedPrice"]);
    }
    if (output["instanceCount"] !== undefined) {
        contents.InstanceCount = parseInt(output["instanceCount"]);
    }
    if (output["instanceTenancy"] !== undefined) {
        contents.InstanceTenancy = output["instanceTenancy"];
    }
    if (output["instanceType"] !== undefined) {
        contents.InstanceType = output["instanceType"];
    }
    if (output["offeringClass"] !== undefined) {
        contents.OfferingClass = output["offeringClass"];
    }
    if (output["offeringType"] !== undefined) {
        contents.OfferingType = output["offeringType"];
    }
    if (output["productDescription"] !== undefined) {
        contents.ProductDescription = output["productDescription"];
    }
    if (output.recurringCharges === "") {
        contents.RecurringCharges = [];
    }
    if (output["recurringCharges"] !== undefined &&
        output["recurringCharges"]["item"] !== undefined) {
        const wrappedItem = output["recurringCharges"]["item"] instanceof Array
            ? output["recurringCharges"]["item"]
            : [output["recurringCharges"]["item"]];
        contents.RecurringCharges = deserializeAws_ec2RecurringChargesList(wrappedItem, context);
    }
    if (output["reservedInstancesId"] !== undefined) {
        contents.ReservedInstancesId = output["reservedInstancesId"];
    }
    if (output["scope"] !== undefined) {
        contents.Scope = output["scope"];
    }
    if (output["start"] !== undefined) {
        contents.Start = new Date(output["start"]);
    }
    if (output["state"] !== undefined) {
        contents.State = output["state"];
    }
    if (output.tagSet === "") {
        contents.Tags = [];
    }
    if (output["tagSet"] !== undefined &&
        output["tagSet"]["item"] !== undefined) {
        const wrappedItem = output["tagSet"]["item"] instanceof Array
            ? output["tagSet"]["item"]
            : [output["tagSet"]["item"]];
        contents.Tags = deserializeAws_ec2TagList(wrappedItem, context);
    }
    if (output["usagePrice"] !== undefined) {
        contents.UsagePrice = parseFloat(output["usagePrice"]);
    }
    return contents;
};
const deserializeAws_ec2ReservedInstancesConfiguration = (output, context) => {
    let contents = {
        __type: "ReservedInstancesConfiguration",
        AvailabilityZone: undefined,
        InstanceCount: undefined,
        InstanceType: undefined,
        Platform: undefined,
        Scope: undefined
    };
    if (output["availabilityZone"] !== undefined) {
        contents.AvailabilityZone = output["availabilityZone"];
    }
    if (output["instanceCount"] !== undefined) {
        contents.InstanceCount = parseInt(output["instanceCount"]);
    }
    if (output["instanceType"] !== undefined) {
        contents.InstanceType = output["instanceType"];
    }
    if (output["platform"] !== undefined) {
        contents.Platform = output["platform"];
    }
    if (output["scope"] !== undefined) {
        contents.Scope = output["scope"];
    }
    return contents;
};
const deserializeAws_ec2ReservedInstancesId = (output, context) => {
    let contents = {
        __type: "ReservedInstancesId",
        ReservedInstancesId: undefined
    };
    if (output["reservedInstancesId"] !== undefined) {
        contents.ReservedInstancesId = output["reservedInstancesId"];
    }
    return contents;
};
const deserializeAws_ec2ReservedInstancesList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2ReservedInstances(entry, context));
    });
    return contents;
};
const deserializeAws_ec2ReservedInstancesListing = (output, context) => {
    let contents = {
        __type: "ReservedInstancesListing",
        ClientToken: undefined,
        CreateDate: undefined,
        InstanceCounts: undefined,
        PriceSchedules: undefined,
        ReservedInstancesId: undefined,
        ReservedInstancesListingId: undefined,
        Status: undefined,
        StatusMessage: undefined,
        Tags: undefined,
        UpdateDate: undefined
    };
    if (output["clientToken"] !== undefined) {
        contents.ClientToken = output["clientToken"];
    }
    if (output["createDate"] !== undefined) {
        contents.CreateDate = new Date(output["createDate"]);
    }
    if (output.instanceCounts === "") {
        contents.InstanceCounts = [];
    }
    if (output["instanceCounts"] !== undefined &&
        output["instanceCounts"]["item"] !== undefined) {
        const wrappedItem = output["instanceCounts"]["item"] instanceof Array
            ? output["instanceCounts"]["item"]
            : [output["instanceCounts"]["item"]];
        contents.InstanceCounts = deserializeAws_ec2InstanceCountList(wrappedItem, context);
    }
    if (output.priceSchedules === "") {
        contents.PriceSchedules = [];
    }
    if (output["priceSchedules"] !== undefined &&
        output["priceSchedules"]["item"] !== undefined) {
        const wrappedItem = output["priceSchedules"]["item"] instanceof Array
            ? output["priceSchedules"]["item"]
            : [output["priceSchedules"]["item"]];
        contents.PriceSchedules = deserializeAws_ec2PriceScheduleList(wrappedItem, context);
    }
    if (output["reservedInstancesId"] !== undefined) {
        contents.ReservedInstancesId = output["reservedInstancesId"];
    }
    if (output["reservedInstancesListingId"] !== undefined) {
        contents.ReservedInstancesListingId = output["reservedInstancesListingId"];
    }
    if (output["status"] !== undefined) {
        contents.Status = output["status"];
    }
    if (output["statusMessage"] !== undefined) {
        contents.StatusMessage = output["statusMessage"];
    }
    if (output.tagSet === "") {
        contents.Tags = [];
    }
    if (output["tagSet"] !== undefined &&
        output["tagSet"]["item"] !== undefined) {
        const wrappedItem = output["tagSet"]["item"] instanceof Array
            ? output["tagSet"]["item"]
            : [output["tagSet"]["item"]];
        contents.Tags = deserializeAws_ec2TagList(wrappedItem, context);
    }
    if (output["updateDate"] !== undefined) {
        contents.UpdateDate = new Date(output["updateDate"]);
    }
    return contents;
};
const deserializeAws_ec2ReservedInstancesListingList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2ReservedInstancesListing(entry, context));
    });
    return contents;
};
const deserializeAws_ec2ReservedInstancesModification = (output, context) => {
    let contents = {
        __type: "ReservedInstancesModification",
        ClientToken: undefined,
        CreateDate: undefined,
        EffectiveDate: undefined,
        ModificationResults: undefined,
        ReservedInstancesIds: undefined,
        ReservedInstancesModificationId: undefined,
        Status: undefined,
        StatusMessage: undefined,
        UpdateDate: undefined
    };
    if (output["clientToken"] !== undefined) {
        contents.ClientToken = output["clientToken"];
    }
    if (output["createDate"] !== undefined) {
        contents.CreateDate = new Date(output["createDate"]);
    }
    if (output["effectiveDate"] !== undefined) {
        contents.EffectiveDate = new Date(output["effectiveDate"]);
    }
    if (output.modificationResultSet === "") {
        contents.ModificationResults = [];
    }
    if (output["modificationResultSet"] !== undefined &&
        output["modificationResultSet"]["item"] !== undefined) {
        const wrappedItem = output["modificationResultSet"]["item"] instanceof Array
            ? output["modificationResultSet"]["item"]
            : [output["modificationResultSet"]["item"]];
        contents.ModificationResults = deserializeAws_ec2ReservedInstancesModificationResultList(wrappedItem, context);
    }
    if (output.reservedInstancesSet === "") {
        contents.ReservedInstancesIds = [];
    }
    if (output["reservedInstancesSet"] !== undefined &&
        output["reservedInstancesSet"]["item"] !== undefined) {
        const wrappedItem = output["reservedInstancesSet"]["item"] instanceof Array
            ? output["reservedInstancesSet"]["item"]
            : [output["reservedInstancesSet"]["item"]];
        contents.ReservedInstancesIds = deserializeAws_ec2ReservedIntancesIds(wrappedItem, context);
    }
    if (output["reservedInstancesModificationId"] !== undefined) {
        contents.ReservedInstancesModificationId =
            output["reservedInstancesModificationId"];
    }
    if (output["status"] !== undefined) {
        contents.Status = output["status"];
    }
    if (output["statusMessage"] !== undefined) {
        contents.StatusMessage = output["statusMessage"];
    }
    if (output["updateDate"] !== undefined) {
        contents.UpdateDate = new Date(output["updateDate"]);
    }
    return contents;
};
const deserializeAws_ec2ReservedInstancesModificationList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2ReservedInstancesModification(entry, context));
    });
    return contents;
};
const deserializeAws_ec2ReservedInstancesModificationResult = (output, context) => {
    let contents = {
        __type: "ReservedInstancesModificationResult",
        ReservedInstancesId: undefined,
        TargetConfiguration: undefined
    };
    if (output["reservedInstancesId"] !== undefined) {
        contents.ReservedInstancesId = output["reservedInstancesId"];
    }
    if (output["targetConfiguration"] !== undefined) {
        contents.TargetConfiguration = deserializeAws_ec2ReservedInstancesConfiguration(output["targetConfiguration"], context);
    }
    return contents;
};
const deserializeAws_ec2ReservedInstancesModificationResultList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2ReservedInstancesModificationResult(entry, context));
    });
    return contents;
};
const deserializeAws_ec2ReservedInstancesOffering = (output, context) => {
    let contents = {
        __type: "ReservedInstancesOffering",
        AvailabilityZone: undefined,
        CurrencyCode: undefined,
        Duration: undefined,
        FixedPrice: undefined,
        InstanceTenancy: undefined,
        InstanceType: undefined,
        Marketplace: undefined,
        OfferingClass: undefined,
        OfferingType: undefined,
        PricingDetails: undefined,
        ProductDescription: undefined,
        RecurringCharges: undefined,
        ReservedInstancesOfferingId: undefined,
        Scope: undefined,
        UsagePrice: undefined
    };
    if (output["availabilityZone"] !== undefined) {
        contents.AvailabilityZone = output["availabilityZone"];
    }
    if (output["currencyCode"] !== undefined) {
        contents.CurrencyCode = output["currencyCode"];
    }
    if (output["duration"] !== undefined) {
        contents.Duration = parseInt(output["duration"]);
    }
    if (output["fixedPrice"] !== undefined) {
        contents.FixedPrice = parseFloat(output["fixedPrice"]);
    }
    if (output["instanceTenancy"] !== undefined) {
        contents.InstanceTenancy = output["instanceTenancy"];
    }
    if (output["instanceType"] !== undefined) {
        contents.InstanceType = output["instanceType"];
    }
    if (output["marketplace"] !== undefined) {
        contents.Marketplace = output["marketplace"] == "true";
    }
    if (output["offeringClass"] !== undefined) {
        contents.OfferingClass = output["offeringClass"];
    }
    if (output["offeringType"] !== undefined) {
        contents.OfferingType = output["offeringType"];
    }
    if (output.pricingDetailsSet === "") {
        contents.PricingDetails = [];
    }
    if (output["pricingDetailsSet"] !== undefined &&
        output["pricingDetailsSet"]["item"] !== undefined) {
        const wrappedItem = output["pricingDetailsSet"]["item"] instanceof Array
            ? output["pricingDetailsSet"]["item"]
            : [output["pricingDetailsSet"]["item"]];
        contents.PricingDetails = deserializeAws_ec2PricingDetailsList(wrappedItem, context);
    }
    if (output["productDescription"] !== undefined) {
        contents.ProductDescription = output["productDescription"];
    }
    if (output.recurringCharges === "") {
        contents.RecurringCharges = [];
    }
    if (output["recurringCharges"] !== undefined &&
        output["recurringCharges"]["item"] !== undefined) {
        const wrappedItem = output["recurringCharges"]["item"] instanceof Array
            ? output["recurringCharges"]["item"]
            : [output["recurringCharges"]["item"]];
        contents.RecurringCharges = deserializeAws_ec2RecurringChargesList(wrappedItem, context);
    }
    if (output["reservedInstancesOfferingId"] !== undefined) {
        contents.ReservedInstancesOfferingId =
            output["reservedInstancesOfferingId"];
    }
    if (output["scope"] !== undefined) {
        contents.Scope = output["scope"];
    }
    if (output["usagePrice"] !== undefined) {
        contents.UsagePrice = parseFloat(output["usagePrice"]);
    }
    return contents;
};
const deserializeAws_ec2ReservedInstancesOfferingList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2ReservedInstancesOffering(entry, context));
    });
    return contents;
};
const deserializeAws_ec2ReservedIntancesIds = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2ReservedInstancesId(entry, context));
    });
    return contents;
};
const deserializeAws_ec2ResetEbsDefaultKmsKeyIdResult = (output, context) => {
    let contents = {
        __type: "ResetEbsDefaultKmsKeyIdResult",
        KmsKeyId: undefined
    };
    if (output["kmsKeyId"] !== undefined) {
        contents.KmsKeyId = output["kmsKeyId"];
    }
    return contents;
};
const deserializeAws_ec2ResetFpgaImageAttributeResult = (output, context) => {
    let contents = {
        __type: "ResetFpgaImageAttributeResult",
        Return: undefined
    };
    if (output["return"] !== undefined) {
        contents.Return = output["return"] == "true";
    }
    return contents;
};
const deserializeAws_ec2ResponseError = (output, context) => {
    let contents = {
        __type: "ResponseError",
        Code: undefined,
        Message: undefined
    };
    if (output["code"] !== undefined) {
        contents.Code = output["code"];
    }
    if (output["message"] !== undefined) {
        contents.Message = output["message"];
    }
    return contents;
};
const deserializeAws_ec2ResponseHostIdList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(entry);
    });
    return contents;
};
const deserializeAws_ec2ResponseHostIdSet = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(entry);
    });
    return contents;
};
const deserializeAws_ec2ResponseLaunchTemplateData = (output, context) => {
    let contents = {
        __type: "ResponseLaunchTemplateData",
        BlockDeviceMappings: undefined,
        CapacityReservationSpecification: undefined,
        CpuOptions: undefined,
        CreditSpecification: undefined,
        DisableApiTermination: undefined,
        EbsOptimized: undefined,
        ElasticGpuSpecifications: undefined,
        ElasticInferenceAccelerators: undefined,
        HibernationOptions: undefined,
        IamInstanceProfile: undefined,
        ImageId: undefined,
        InstanceInitiatedShutdownBehavior: undefined,
        InstanceMarketOptions: undefined,
        InstanceType: undefined,
        KernelId: undefined,
        KeyName: undefined,
        LicenseSpecifications: undefined,
        MetadataOptions: undefined,
        Monitoring: undefined,
        NetworkInterfaces: undefined,
        Placement: undefined,
        RamDiskId: undefined,
        SecurityGroupIds: undefined,
        SecurityGroups: undefined,
        TagSpecifications: undefined,
        UserData: undefined
    };
    if (output.blockDeviceMappingSet === "") {
        contents.BlockDeviceMappings = [];
    }
    if (output["blockDeviceMappingSet"] !== undefined &&
        output["blockDeviceMappingSet"]["item"] !== undefined) {
        const wrappedItem = output["blockDeviceMappingSet"]["item"] instanceof Array
            ? output["blockDeviceMappingSet"]["item"]
            : [output["blockDeviceMappingSet"]["item"]];
        contents.BlockDeviceMappings = deserializeAws_ec2LaunchTemplateBlockDeviceMappingList(wrappedItem, context);
    }
    if (output["capacityReservationSpecification"] !== undefined) {
        contents.CapacityReservationSpecification = deserializeAws_ec2LaunchTemplateCapacityReservationSpecificationResponse(output["capacityReservationSpecification"], context);
    }
    if (output["cpuOptions"] !== undefined) {
        contents.CpuOptions = deserializeAws_ec2LaunchTemplateCpuOptions(output["cpuOptions"], context);
    }
    if (output["creditSpecification"] !== undefined) {
        contents.CreditSpecification = deserializeAws_ec2CreditSpecification(output["creditSpecification"], context);
    }
    if (output["disableApiTermination"] !== undefined) {
        contents.DisableApiTermination = output["disableApiTermination"] == "true";
    }
    if (output["ebsOptimized"] !== undefined) {
        contents.EbsOptimized = output["ebsOptimized"] == "true";
    }
    if (output.elasticGpuSpecificationSet === "") {
        contents.ElasticGpuSpecifications = [];
    }
    if (output["elasticGpuSpecificationSet"] !== undefined &&
        output["elasticGpuSpecificationSet"]["item"] !== undefined) {
        const wrappedItem = output["elasticGpuSpecificationSet"]["item"] instanceof Array
            ? output["elasticGpuSpecificationSet"]["item"]
            : [output["elasticGpuSpecificationSet"]["item"]];
        contents.ElasticGpuSpecifications = deserializeAws_ec2ElasticGpuSpecificationResponseList(wrappedItem, context);
    }
    if (output.elasticInferenceAcceleratorSet === "") {
        contents.ElasticInferenceAccelerators = [];
    }
    if (output["elasticInferenceAcceleratorSet"] !== undefined &&
        output["elasticInferenceAcceleratorSet"]["item"] !== undefined) {
        const wrappedItem = output["elasticInferenceAcceleratorSet"]["item"] instanceof Array
            ? output["elasticInferenceAcceleratorSet"]["item"]
            : [output["elasticInferenceAcceleratorSet"]["item"]];
        contents.ElasticInferenceAccelerators = deserializeAws_ec2LaunchTemplateElasticInferenceAcceleratorResponseList(wrappedItem, context);
    }
    if (output["hibernationOptions"] !== undefined) {
        contents.HibernationOptions = deserializeAws_ec2LaunchTemplateHibernationOptions(output["hibernationOptions"], context);
    }
    if (output["iamInstanceProfile"] !== undefined) {
        contents.IamInstanceProfile = deserializeAws_ec2LaunchTemplateIamInstanceProfileSpecification(output["iamInstanceProfile"], context);
    }
    if (output["imageId"] !== undefined) {
        contents.ImageId = output["imageId"];
    }
    if (output["instanceInitiatedShutdownBehavior"] !== undefined) {
        contents.InstanceInitiatedShutdownBehavior =
            output["instanceInitiatedShutdownBehavior"];
    }
    if (output["instanceMarketOptions"] !== undefined) {
        contents.InstanceMarketOptions = deserializeAws_ec2LaunchTemplateInstanceMarketOptions(output["instanceMarketOptions"], context);
    }
    if (output["instanceType"] !== undefined) {
        contents.InstanceType = output["instanceType"];
    }
    if (output["kernelId"] !== undefined) {
        contents.KernelId = output["kernelId"];
    }
    if (output["keyName"] !== undefined) {
        contents.KeyName = output["keyName"];
    }
    if (output.licenseSet === "") {
        contents.LicenseSpecifications = [];
    }
    if (output["licenseSet"] !== undefined &&
        output["licenseSet"]["item"] !== undefined) {
        const wrappedItem = output["licenseSet"]["item"] instanceof Array
            ? output["licenseSet"]["item"]
            : [output["licenseSet"]["item"]];
        contents.LicenseSpecifications = deserializeAws_ec2LaunchTemplateLicenseList(wrappedItem, context);
    }
    if (output["metadataOptions"] !== undefined) {
        contents.MetadataOptions = deserializeAws_ec2LaunchTemplateInstanceMetadataOptions(output["metadataOptions"], context);
    }
    if (output["monitoring"] !== undefined) {
        contents.Monitoring = deserializeAws_ec2LaunchTemplatesMonitoring(output["monitoring"], context);
    }
    if (output.networkInterfaceSet === "") {
        contents.NetworkInterfaces = [];
    }
    if (output["networkInterfaceSet"] !== undefined &&
        output["networkInterfaceSet"]["item"] !== undefined) {
        const wrappedItem = output["networkInterfaceSet"]["item"] instanceof Array
            ? output["networkInterfaceSet"]["item"]
            : [output["networkInterfaceSet"]["item"]];
        contents.NetworkInterfaces = deserializeAws_ec2LaunchTemplateInstanceNetworkInterfaceSpecificationList(wrappedItem, context);
    }
    if (output["placement"] !== undefined) {
        contents.Placement = deserializeAws_ec2LaunchTemplatePlacement(output["placement"], context);
    }
    if (output["ramDiskId"] !== undefined) {
        contents.RamDiskId = output["ramDiskId"];
    }
    if (output.securityGroupIdSet === "") {
        contents.SecurityGroupIds = [];
    }
    if (output["securityGroupIdSet"] !== undefined &&
        output["securityGroupIdSet"]["item"] !== undefined) {
        const wrappedItem = output["securityGroupIdSet"]["item"] instanceof Array
            ? output["securityGroupIdSet"]["item"]
            : [output["securityGroupIdSet"]["item"]];
        contents.SecurityGroupIds = deserializeAws_ec2ValueStringList(wrappedItem, context);
    }
    if (output.securityGroupSet === "") {
        contents.SecurityGroups = [];
    }
    if (output["securityGroupSet"] !== undefined &&
        output["securityGroupSet"]["item"] !== undefined) {
        const wrappedItem = output["securityGroupSet"]["item"] instanceof Array
            ? output["securityGroupSet"]["item"]
            : [output["securityGroupSet"]["item"]];
        contents.SecurityGroups = deserializeAws_ec2ValueStringList(wrappedItem, context);
    }
    if (output.tagSpecificationSet === "") {
        contents.TagSpecifications = [];
    }
    if (output["tagSpecificationSet"] !== undefined &&
        output["tagSpecificationSet"]["item"] !== undefined) {
        const wrappedItem = output["tagSpecificationSet"]["item"] instanceof Array
            ? output["tagSpecificationSet"]["item"]
            : [output["tagSpecificationSet"]["item"]];
        contents.TagSpecifications = deserializeAws_ec2LaunchTemplateTagSpecificationList(wrappedItem, context);
    }
    if (output["userData"] !== undefined) {
        contents.UserData = output["userData"];
    }
    return contents;
};
const deserializeAws_ec2RestoreAddressToClassicResult = (output, context) => {
    let contents = {
        __type: "RestoreAddressToClassicResult",
        PublicIp: undefined,
        Status: undefined
    };
    if (output["publicIp"] !== undefined) {
        contents.PublicIp = output["publicIp"];
    }
    if (output["status"] !== undefined) {
        contents.Status = output["status"];
    }
    return contents;
};
const deserializeAws_ec2RevokeClientVpnIngressResult = (output, context) => {
    let contents = {
        __type: "RevokeClientVpnIngressResult",
        Status: undefined
    };
    if (output["status"] !== undefined) {
        contents.Status = deserializeAws_ec2ClientVpnAuthorizationRuleStatus(output["status"], context);
    }
    return contents;
};
const deserializeAws_ec2RootDeviceTypeList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(entry);
    });
    return contents;
};
const deserializeAws_ec2Route = (output, context) => {
    let contents = {
        __type: "Route",
        DestinationCidrBlock: undefined,
        DestinationIpv6CidrBlock: undefined,
        DestinationPrefixListId: undefined,
        EgressOnlyInternetGatewayId: undefined,
        GatewayId: undefined,
        InstanceId: undefined,
        InstanceOwnerId: undefined,
        LocalGatewayId: undefined,
        NatGatewayId: undefined,
        NetworkInterfaceId: undefined,
        Origin: undefined,
        State: undefined,
        TransitGatewayId: undefined,
        VpcPeeringConnectionId: undefined
    };
    if (output["destinationCidrBlock"] !== undefined) {
        contents.DestinationCidrBlock = output["destinationCidrBlock"];
    }
    if (output["destinationIpv6CidrBlock"] !== undefined) {
        contents.DestinationIpv6CidrBlock = output["destinationIpv6CidrBlock"];
    }
    if (output["destinationPrefixListId"] !== undefined) {
        contents.DestinationPrefixListId = output["destinationPrefixListId"];
    }
    if (output["egressOnlyInternetGatewayId"] !== undefined) {
        contents.EgressOnlyInternetGatewayId =
            output["egressOnlyInternetGatewayId"];
    }
    if (output["gatewayId"] !== undefined) {
        contents.GatewayId = output["gatewayId"];
    }
    if (output["instanceId"] !== undefined) {
        contents.InstanceId = output["instanceId"];
    }
    if (output["instanceOwnerId"] !== undefined) {
        contents.InstanceOwnerId = output["instanceOwnerId"];
    }
    if (output["localGatewayId"] !== undefined) {
        contents.LocalGatewayId = output["localGatewayId"];
    }
    if (output["natGatewayId"] !== undefined) {
        contents.NatGatewayId = output["natGatewayId"];
    }
    if (output["networkInterfaceId"] !== undefined) {
        contents.NetworkInterfaceId = output["networkInterfaceId"];
    }
    if (output["origin"] !== undefined) {
        contents.Origin = output["origin"];
    }
    if (output["state"] !== undefined) {
        contents.State = output["state"];
    }
    if (output["transitGatewayId"] !== undefined) {
        contents.TransitGatewayId = output["transitGatewayId"];
    }
    if (output["vpcPeeringConnectionId"] !== undefined) {
        contents.VpcPeeringConnectionId = output["vpcPeeringConnectionId"];
    }
    return contents;
};
const deserializeAws_ec2RouteList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2Route(entry, context));
    });
    return contents;
};
const deserializeAws_ec2RouteTable = (output, context) => {
    let contents = {
        __type: "RouteTable",
        Associations: undefined,
        OwnerId: undefined,
        PropagatingVgws: undefined,
        RouteTableId: undefined,
        Routes: undefined,
        Tags: undefined,
        VpcId: undefined
    };
    if (output.associationSet === "") {
        contents.Associations = [];
    }
    if (output["associationSet"] !== undefined &&
        output["associationSet"]["item"] !== undefined) {
        const wrappedItem = output["associationSet"]["item"] instanceof Array
            ? output["associationSet"]["item"]
            : [output["associationSet"]["item"]];
        contents.Associations = deserializeAws_ec2RouteTableAssociationList(wrappedItem, context);
    }
    if (output["ownerId"] !== undefined) {
        contents.OwnerId = output["ownerId"];
    }
    if (output.propagatingVgwSet === "") {
        contents.PropagatingVgws = [];
    }
    if (output["propagatingVgwSet"] !== undefined &&
        output["propagatingVgwSet"]["item"] !== undefined) {
        const wrappedItem = output["propagatingVgwSet"]["item"] instanceof Array
            ? output["propagatingVgwSet"]["item"]
            : [output["propagatingVgwSet"]["item"]];
        contents.PropagatingVgws = deserializeAws_ec2PropagatingVgwList(wrappedItem, context);
    }
    if (output["routeTableId"] !== undefined) {
        contents.RouteTableId = output["routeTableId"];
    }
    if (output.routeSet === "") {
        contents.Routes = [];
    }
    if (output["routeSet"] !== undefined &&
        output["routeSet"]["item"] !== undefined) {
        const wrappedItem = output["routeSet"]["item"] instanceof Array
            ? output["routeSet"]["item"]
            : [output["routeSet"]["item"]];
        contents.Routes = deserializeAws_ec2RouteList(wrappedItem, context);
    }
    if (output.tagSet === "") {
        contents.Tags = [];
    }
    if (output["tagSet"] !== undefined &&
        output["tagSet"]["item"] !== undefined) {
        const wrappedItem = output["tagSet"]["item"] instanceof Array
            ? output["tagSet"]["item"]
            : [output["tagSet"]["item"]];
        contents.Tags = deserializeAws_ec2TagList(wrappedItem, context);
    }
    if (output["vpcId"] !== undefined) {
        contents.VpcId = output["vpcId"];
    }
    return contents;
};
const deserializeAws_ec2RouteTableAssociation = (output, context) => {
    let contents = {
        __type: "RouteTableAssociation",
        AssociationState: undefined,
        GatewayId: undefined,
        Main: undefined,
        RouteTableAssociationId: undefined,
        RouteTableId: undefined,
        SubnetId: undefined
    };
    if (output["associationState"] !== undefined) {
        contents.AssociationState = deserializeAws_ec2RouteTableAssociationState(output["associationState"], context);
    }
    if (output["gatewayId"] !== undefined) {
        contents.GatewayId = output["gatewayId"];
    }
    if (output["main"] !== undefined) {
        contents.Main = output["main"] == "true";
    }
    if (output["routeTableAssociationId"] !== undefined) {
        contents.RouteTableAssociationId = output["routeTableAssociationId"];
    }
    if (output["routeTableId"] !== undefined) {
        contents.RouteTableId = output["routeTableId"];
    }
    if (output["subnetId"] !== undefined) {
        contents.SubnetId = output["subnetId"];
    }
    return contents;
};
const deserializeAws_ec2RouteTableAssociationList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2RouteTableAssociation(entry, context));
    });
    return contents;
};
const deserializeAws_ec2RouteTableAssociationState = (output, context) => {
    let contents = {
        __type: "RouteTableAssociationState",
        State: undefined,
        StatusMessage: undefined
    };
    if (output["state"] !== undefined) {
        contents.State = output["state"];
    }
    if (output["statusMessage"] !== undefined) {
        contents.StatusMessage = output["statusMessage"];
    }
    return contents;
};
const deserializeAws_ec2RouteTableList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2RouteTable(entry, context));
    });
    return contents;
};
const deserializeAws_ec2RunInstancesMonitoringEnabled = (output, context) => {
    let contents = {
        __type: "RunInstancesMonitoringEnabled",
        Enabled: undefined
    };
    if (output["enabled"] !== undefined) {
        contents.Enabled = output["enabled"] == "true";
    }
    return contents;
};
const deserializeAws_ec2RunScheduledInstancesResult = (output, context) => {
    let contents = {
        __type: "RunScheduledInstancesResult",
        InstanceIdSet: undefined
    };
    if (output.instanceIdSet === "") {
        contents.InstanceIdSet = [];
    }
    if (output["instanceIdSet"] !== undefined &&
        output["instanceIdSet"]["item"] !== undefined) {
        const wrappedItem = output["instanceIdSet"]["item"] instanceof Array
            ? output["instanceIdSet"]["item"]
            : [output["instanceIdSet"]["item"]];
        contents.InstanceIdSet = deserializeAws_ec2InstanceIdSet(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2S3Storage = (output, context) => {
    let contents = {
        __type: "S3Storage",
        AWSAccessKeyId: undefined,
        Bucket: undefined,
        Prefix: undefined,
        UploadPolicy: undefined,
        UploadPolicySignature: undefined
    };
    if (output["AWSAccessKeyId"] !== undefined) {
        contents.AWSAccessKeyId = output["AWSAccessKeyId"];
    }
    if (output["bucket"] !== undefined) {
        contents.Bucket = output["bucket"];
    }
    if (output["prefix"] !== undefined) {
        contents.Prefix = output["prefix"];
    }
    if (output["uploadPolicy"] !== undefined) {
        contents.UploadPolicy = context.base64Decoder(output["uploadPolicy"]);
    }
    if (output["uploadPolicySignature"] !== undefined) {
        contents.UploadPolicySignature = output["uploadPolicySignature"];
    }
    return contents;
};
const deserializeAws_ec2ScheduledInstance = (output, context) => {
    let contents = {
        __type: "ScheduledInstance",
        AvailabilityZone: undefined,
        CreateDate: undefined,
        HourlyPrice: undefined,
        InstanceCount: undefined,
        InstanceType: undefined,
        NetworkPlatform: undefined,
        NextSlotStartTime: undefined,
        Platform: undefined,
        PreviousSlotEndTime: undefined,
        Recurrence: undefined,
        ScheduledInstanceId: undefined,
        SlotDurationInHours: undefined,
        TermEndDate: undefined,
        TermStartDate: undefined,
        TotalScheduledInstanceHours: undefined
    };
    if (output["availabilityZone"] !== undefined) {
        contents.AvailabilityZone = output["availabilityZone"];
    }
    if (output["createDate"] !== undefined) {
        contents.CreateDate = new Date(output["createDate"]);
    }
    if (output["hourlyPrice"] !== undefined) {
        contents.HourlyPrice = output["hourlyPrice"];
    }
    if (output["instanceCount"] !== undefined) {
        contents.InstanceCount = parseInt(output["instanceCount"]);
    }
    if (output["instanceType"] !== undefined) {
        contents.InstanceType = output["instanceType"];
    }
    if (output["networkPlatform"] !== undefined) {
        contents.NetworkPlatform = output["networkPlatform"];
    }
    if (output["nextSlotStartTime"] !== undefined) {
        contents.NextSlotStartTime = new Date(output["nextSlotStartTime"]);
    }
    if (output["platform"] !== undefined) {
        contents.Platform = output["platform"];
    }
    if (output["previousSlotEndTime"] !== undefined) {
        contents.PreviousSlotEndTime = new Date(output["previousSlotEndTime"]);
    }
    if (output["recurrence"] !== undefined) {
        contents.Recurrence = deserializeAws_ec2ScheduledInstanceRecurrence(output["recurrence"], context);
    }
    if (output["scheduledInstanceId"] !== undefined) {
        contents.ScheduledInstanceId = output["scheduledInstanceId"];
    }
    if (output["slotDurationInHours"] !== undefined) {
        contents.SlotDurationInHours = parseInt(output["slotDurationInHours"]);
    }
    if (output["termEndDate"] !== undefined) {
        contents.TermEndDate = new Date(output["termEndDate"]);
    }
    if (output["termStartDate"] !== undefined) {
        contents.TermStartDate = new Date(output["termStartDate"]);
    }
    if (output["totalScheduledInstanceHours"] !== undefined) {
        contents.TotalScheduledInstanceHours = parseInt(output["totalScheduledInstanceHours"]);
    }
    return contents;
};
const deserializeAws_ec2ScheduledInstanceAvailability = (output, context) => {
    let contents = {
        __type: "ScheduledInstanceAvailability",
        AvailabilityZone: undefined,
        AvailableInstanceCount: undefined,
        FirstSlotStartTime: undefined,
        HourlyPrice: undefined,
        InstanceType: undefined,
        MaxTermDurationInDays: undefined,
        MinTermDurationInDays: undefined,
        NetworkPlatform: undefined,
        Platform: undefined,
        PurchaseToken: undefined,
        Recurrence: undefined,
        SlotDurationInHours: undefined,
        TotalScheduledInstanceHours: undefined
    };
    if (output["availabilityZone"] !== undefined) {
        contents.AvailabilityZone = output["availabilityZone"];
    }
    if (output["availableInstanceCount"] !== undefined) {
        contents.AvailableInstanceCount = parseInt(output["availableInstanceCount"]);
    }
    if (output["firstSlotStartTime"] !== undefined) {
        contents.FirstSlotStartTime = new Date(output["firstSlotStartTime"]);
    }
    if (output["hourlyPrice"] !== undefined) {
        contents.HourlyPrice = output["hourlyPrice"];
    }
    if (output["instanceType"] !== undefined) {
        contents.InstanceType = output["instanceType"];
    }
    if (output["maxTermDurationInDays"] !== undefined) {
        contents.MaxTermDurationInDays = parseInt(output["maxTermDurationInDays"]);
    }
    if (output["minTermDurationInDays"] !== undefined) {
        contents.MinTermDurationInDays = parseInt(output["minTermDurationInDays"]);
    }
    if (output["networkPlatform"] !== undefined) {
        contents.NetworkPlatform = output["networkPlatform"];
    }
    if (output["platform"] !== undefined) {
        contents.Platform = output["platform"];
    }
    if (output["purchaseToken"] !== undefined) {
        contents.PurchaseToken = output["purchaseToken"];
    }
    if (output["recurrence"] !== undefined) {
        contents.Recurrence = deserializeAws_ec2ScheduledInstanceRecurrence(output["recurrence"], context);
    }
    if (output["slotDurationInHours"] !== undefined) {
        contents.SlotDurationInHours = parseInt(output["slotDurationInHours"]);
    }
    if (output["totalScheduledInstanceHours"] !== undefined) {
        contents.TotalScheduledInstanceHours = parseInt(output["totalScheduledInstanceHours"]);
    }
    return contents;
};
const deserializeAws_ec2ScheduledInstanceAvailabilitySet = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2ScheduledInstanceAvailability(entry, context));
    });
    return contents;
};
const deserializeAws_ec2ScheduledInstanceRecurrence = (output, context) => {
    let contents = {
        __type: "ScheduledInstanceRecurrence",
        Frequency: undefined,
        Interval: undefined,
        OccurrenceDaySet: undefined,
        OccurrenceRelativeToEnd: undefined,
        OccurrenceUnit: undefined
    };
    if (output["frequency"] !== undefined) {
        contents.Frequency = output["frequency"];
    }
    if (output["interval"] !== undefined) {
        contents.Interval = parseInt(output["interval"]);
    }
    if (output.occurrenceDaySet === "") {
        contents.OccurrenceDaySet = [];
    }
    if (output["occurrenceDaySet"] !== undefined &&
        output["occurrenceDaySet"]["item"] !== undefined) {
        const wrappedItem = output["occurrenceDaySet"]["item"] instanceof Array
            ? output["occurrenceDaySet"]["item"]
            : [output["occurrenceDaySet"]["item"]];
        contents.OccurrenceDaySet = deserializeAws_ec2OccurrenceDaySet(wrappedItem, context);
    }
    if (output["occurrenceRelativeToEnd"] !== undefined) {
        contents.OccurrenceRelativeToEnd =
            output["occurrenceRelativeToEnd"] == "true";
    }
    if (output["occurrenceUnit"] !== undefined) {
        contents.OccurrenceUnit = output["occurrenceUnit"];
    }
    return contents;
};
const deserializeAws_ec2ScheduledInstanceSet = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2ScheduledInstance(entry, context));
    });
    return contents;
};
const deserializeAws_ec2SearchLocalGatewayRoutesResult = (output, context) => {
    let contents = {
        __type: "SearchLocalGatewayRoutesResult",
        NextToken: undefined,
        Routes: undefined
    };
    if (output["nextToken"] !== undefined) {
        contents.NextToken = output["nextToken"];
    }
    if (output.routeSet === "") {
        contents.Routes = [];
    }
    if (output["routeSet"] !== undefined &&
        output["routeSet"]["item"] !== undefined) {
        const wrappedItem = output["routeSet"]["item"] instanceof Array
            ? output["routeSet"]["item"]
            : [output["routeSet"]["item"]];
        contents.Routes = deserializeAws_ec2LocalGatewayRouteList(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2SearchTransitGatewayMulticastGroupsResult = (output, context) => {
    let contents = {
        __type: "SearchTransitGatewayMulticastGroupsResult",
        MulticastGroups: undefined,
        NextToken: undefined
    };
    if (output.multicastGroups === "") {
        contents.MulticastGroups = [];
    }
    if (output["multicastGroups"] !== undefined &&
        output["multicastGroups"]["item"] !== undefined) {
        const wrappedItem = output["multicastGroups"]["item"] instanceof Array
            ? output["multicastGroups"]["item"]
            : [output["multicastGroups"]["item"]];
        contents.MulticastGroups = deserializeAws_ec2TransitGatewayMulticastGroupList(wrappedItem, context);
    }
    if (output["nextToken"] !== undefined) {
        contents.NextToken = output["nextToken"];
    }
    return contents;
};
const deserializeAws_ec2SearchTransitGatewayRoutesResult = (output, context) => {
    let contents = {
        __type: "SearchTransitGatewayRoutesResult",
        AdditionalRoutesAvailable: undefined,
        Routes: undefined
    };
    if (output["additionalRoutesAvailable"] !== undefined) {
        contents.AdditionalRoutesAvailable =
            output["additionalRoutesAvailable"] == "true";
    }
    if (output.routeSet === "") {
        contents.Routes = [];
    }
    if (output["routeSet"] !== undefined &&
        output["routeSet"]["item"] !== undefined) {
        const wrappedItem = output["routeSet"]["item"] instanceof Array
            ? output["routeSet"]["item"]
            : [output["routeSet"]["item"]];
        contents.Routes = deserializeAws_ec2TransitGatewayRouteList(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2SecurityGroup = (output, context) => {
    let contents = {
        __type: "SecurityGroup",
        Description: undefined,
        GroupId: undefined,
        GroupName: undefined,
        IpPermissions: undefined,
        IpPermissionsEgress: undefined,
        OwnerId: undefined,
        Tags: undefined,
        VpcId: undefined
    };
    if (output["groupDescription"] !== undefined) {
        contents.Description = output["groupDescription"];
    }
    if (output["groupId"] !== undefined) {
        contents.GroupId = output["groupId"];
    }
    if (output["groupName"] !== undefined) {
        contents.GroupName = output["groupName"];
    }
    if (output.ipPermissions === "") {
        contents.IpPermissions = [];
    }
    if (output["ipPermissions"] !== undefined &&
        output["ipPermissions"]["item"] !== undefined) {
        const wrappedItem = output["ipPermissions"]["item"] instanceof Array
            ? output["ipPermissions"]["item"]
            : [output["ipPermissions"]["item"]];
        contents.IpPermissions = deserializeAws_ec2IpPermissionList(wrappedItem, context);
    }
    if (output.ipPermissionsEgress === "") {
        contents.IpPermissionsEgress = [];
    }
    if (output["ipPermissionsEgress"] !== undefined &&
        output["ipPermissionsEgress"]["item"] !== undefined) {
        const wrappedItem = output["ipPermissionsEgress"]["item"] instanceof Array
            ? output["ipPermissionsEgress"]["item"]
            : [output["ipPermissionsEgress"]["item"]];
        contents.IpPermissionsEgress = deserializeAws_ec2IpPermissionList(wrappedItem, context);
    }
    if (output["ownerId"] !== undefined) {
        contents.OwnerId = output["ownerId"];
    }
    if (output.tagSet === "") {
        contents.Tags = [];
    }
    if (output["tagSet"] !== undefined &&
        output["tagSet"]["item"] !== undefined) {
        const wrappedItem = output["tagSet"]["item"] instanceof Array
            ? output["tagSet"]["item"]
            : [output["tagSet"]["item"]];
        contents.Tags = deserializeAws_ec2TagList(wrappedItem, context);
    }
    if (output["vpcId"] !== undefined) {
        contents.VpcId = output["vpcId"];
    }
    return contents;
};
const deserializeAws_ec2SecurityGroupIdStringList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(entry);
    });
    return contents;
};
const deserializeAws_ec2SecurityGroupIdentifier = (output, context) => {
    let contents = {
        __type: "SecurityGroupIdentifier",
        GroupId: undefined,
        GroupName: undefined
    };
    if (output["groupId"] !== undefined) {
        contents.GroupId = output["groupId"];
    }
    if (output["groupName"] !== undefined) {
        contents.GroupName = output["groupName"];
    }
    return contents;
};
const deserializeAws_ec2SecurityGroupList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2SecurityGroup(entry, context));
    });
    return contents;
};
const deserializeAws_ec2SecurityGroupReference = (output, context) => {
    let contents = {
        __type: "SecurityGroupReference",
        GroupId: undefined,
        ReferencingVpcId: undefined,
        VpcPeeringConnectionId: undefined
    };
    if (output["groupId"] !== undefined) {
        contents.GroupId = output["groupId"];
    }
    if (output["referencingVpcId"] !== undefined) {
        contents.ReferencingVpcId = output["referencingVpcId"];
    }
    if (output["vpcPeeringConnectionId"] !== undefined) {
        contents.VpcPeeringConnectionId = output["vpcPeeringConnectionId"];
    }
    return contents;
};
const deserializeAws_ec2SecurityGroupReferences = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2SecurityGroupReference(entry, context));
    });
    return contents;
};
const deserializeAws_ec2ServiceConfiguration = (output, context) => {
    let contents = {
        __type: "ServiceConfiguration",
        AcceptanceRequired: undefined,
        AvailabilityZones: undefined,
        BaseEndpointDnsNames: undefined,
        ManagesVpcEndpoints: undefined,
        NetworkLoadBalancerArns: undefined,
        PrivateDnsName: undefined,
        PrivateDnsNameConfiguration: undefined,
        ServiceId: undefined,
        ServiceName: undefined,
        ServiceState: undefined,
        ServiceType: undefined,
        Tags: undefined
    };
    if (output["acceptanceRequired"] !== undefined) {
        contents.AcceptanceRequired = output["acceptanceRequired"] == "true";
    }
    if (output.availabilityZoneSet === "") {
        contents.AvailabilityZones = [];
    }
    if (output["availabilityZoneSet"] !== undefined &&
        output["availabilityZoneSet"]["item"] !== undefined) {
        const wrappedItem = output["availabilityZoneSet"]["item"] instanceof Array
            ? output["availabilityZoneSet"]["item"]
            : [output["availabilityZoneSet"]["item"]];
        contents.AvailabilityZones = deserializeAws_ec2ValueStringList(wrappedItem, context);
    }
    if (output.baseEndpointDnsNameSet === "") {
        contents.BaseEndpointDnsNames = [];
    }
    if (output["baseEndpointDnsNameSet"] !== undefined &&
        output["baseEndpointDnsNameSet"]["item"] !== undefined) {
        const wrappedItem = output["baseEndpointDnsNameSet"]["item"] instanceof Array
            ? output["baseEndpointDnsNameSet"]["item"]
            : [output["baseEndpointDnsNameSet"]["item"]];
        contents.BaseEndpointDnsNames = deserializeAws_ec2ValueStringList(wrappedItem, context);
    }
    if (output["managesVpcEndpoints"] !== undefined) {
        contents.ManagesVpcEndpoints = output["managesVpcEndpoints"] == "true";
    }
    if (output.networkLoadBalancerArnSet === "") {
        contents.NetworkLoadBalancerArns = [];
    }
    if (output["networkLoadBalancerArnSet"] !== undefined &&
        output["networkLoadBalancerArnSet"]["item"] !== undefined) {
        const wrappedItem = output["networkLoadBalancerArnSet"]["item"] instanceof Array
            ? output["networkLoadBalancerArnSet"]["item"]
            : [output["networkLoadBalancerArnSet"]["item"]];
        contents.NetworkLoadBalancerArns = deserializeAws_ec2ValueStringList(wrappedItem, context);
    }
    if (output["privateDnsName"] !== undefined) {
        contents.PrivateDnsName = output["privateDnsName"];
    }
    if (output["privateDnsNameConfiguration"] !== undefined) {
        contents.PrivateDnsNameConfiguration = deserializeAws_ec2PrivateDnsNameConfiguration(output["privateDnsNameConfiguration"], context);
    }
    if (output["serviceId"] !== undefined) {
        contents.ServiceId = output["serviceId"];
    }
    if (output["serviceName"] !== undefined) {
        contents.ServiceName = output["serviceName"];
    }
    if (output["serviceState"] !== undefined) {
        contents.ServiceState = output["serviceState"];
    }
    if (output.serviceType === "") {
        contents.ServiceType = [];
    }
    if (output["serviceType"] !== undefined &&
        output["serviceType"]["item"] !== undefined) {
        const wrappedItem = output["serviceType"]["item"] instanceof Array
            ? output["serviceType"]["item"]
            : [output["serviceType"]["item"]];
        contents.ServiceType = deserializeAws_ec2ServiceTypeDetailSet(wrappedItem, context);
    }
    if (output.tagSet === "") {
        contents.Tags = [];
    }
    if (output["tagSet"] !== undefined &&
        output["tagSet"]["item"] !== undefined) {
        const wrappedItem = output["tagSet"]["item"] instanceof Array
            ? output["tagSet"]["item"]
            : [output["tagSet"]["item"]];
        contents.Tags = deserializeAws_ec2TagList(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2ServiceConfigurationSet = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2ServiceConfiguration(entry, context));
    });
    return contents;
};
const deserializeAws_ec2ServiceDetail = (output, context) => {
    let contents = {
        __type: "ServiceDetail",
        AcceptanceRequired: undefined,
        AvailabilityZones: undefined,
        BaseEndpointDnsNames: undefined,
        ManagesVpcEndpoints: undefined,
        Owner: undefined,
        PrivateDnsName: undefined,
        PrivateDnsNameVerificationState: undefined,
        ServiceId: undefined,
        ServiceName: undefined,
        ServiceType: undefined,
        Tags: undefined,
        VpcEndpointPolicySupported: undefined
    };
    if (output["acceptanceRequired"] !== undefined) {
        contents.AcceptanceRequired = output["acceptanceRequired"] == "true";
    }
    if (output.availabilityZoneSet === "") {
        contents.AvailabilityZones = [];
    }
    if (output["availabilityZoneSet"] !== undefined &&
        output["availabilityZoneSet"]["item"] !== undefined) {
        const wrappedItem = output["availabilityZoneSet"]["item"] instanceof Array
            ? output["availabilityZoneSet"]["item"]
            : [output["availabilityZoneSet"]["item"]];
        contents.AvailabilityZones = deserializeAws_ec2ValueStringList(wrappedItem, context);
    }
    if (output.baseEndpointDnsNameSet === "") {
        contents.BaseEndpointDnsNames = [];
    }
    if (output["baseEndpointDnsNameSet"] !== undefined &&
        output["baseEndpointDnsNameSet"]["item"] !== undefined) {
        const wrappedItem = output["baseEndpointDnsNameSet"]["item"] instanceof Array
            ? output["baseEndpointDnsNameSet"]["item"]
            : [output["baseEndpointDnsNameSet"]["item"]];
        contents.BaseEndpointDnsNames = deserializeAws_ec2ValueStringList(wrappedItem, context);
    }
    if (output["managesVpcEndpoints"] !== undefined) {
        contents.ManagesVpcEndpoints = output["managesVpcEndpoints"] == "true";
    }
    if (output["owner"] !== undefined) {
        contents.Owner = output["owner"];
    }
    if (output["privateDnsName"] !== undefined) {
        contents.PrivateDnsName = output["privateDnsName"];
    }
    if (output["privateDnsNameVerificationState"] !== undefined) {
        contents.PrivateDnsNameVerificationState =
            output["privateDnsNameVerificationState"];
    }
    if (output["serviceId"] !== undefined) {
        contents.ServiceId = output["serviceId"];
    }
    if (output["serviceName"] !== undefined) {
        contents.ServiceName = output["serviceName"];
    }
    if (output.serviceType === "") {
        contents.ServiceType = [];
    }
    if (output["serviceType"] !== undefined &&
        output["serviceType"]["item"] !== undefined) {
        const wrappedItem = output["serviceType"]["item"] instanceof Array
            ? output["serviceType"]["item"]
            : [output["serviceType"]["item"]];
        contents.ServiceType = deserializeAws_ec2ServiceTypeDetailSet(wrappedItem, context);
    }
    if (output.tagSet === "") {
        contents.Tags = [];
    }
    if (output["tagSet"] !== undefined &&
        output["tagSet"]["item"] !== undefined) {
        const wrappedItem = output["tagSet"]["item"] instanceof Array
            ? output["tagSet"]["item"]
            : [output["tagSet"]["item"]];
        contents.Tags = deserializeAws_ec2TagList(wrappedItem, context);
    }
    if (output["vpcEndpointPolicySupported"] !== undefined) {
        contents.VpcEndpointPolicySupported =
            output["vpcEndpointPolicySupported"] == "true";
    }
    return contents;
};
const deserializeAws_ec2ServiceDetailSet = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2ServiceDetail(entry, context));
    });
    return contents;
};
const deserializeAws_ec2ServiceTypeDetail = (output, context) => {
    let contents = {
        __type: "ServiceTypeDetail",
        ServiceType: undefined
    };
    if (output["serviceType"] !== undefined) {
        contents.ServiceType = output["serviceType"];
    }
    return contents;
};
const deserializeAws_ec2ServiceTypeDetailSet = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2ServiceTypeDetail(entry, context));
    });
    return contents;
};
const deserializeAws_ec2Snapshot = (output, context) => {
    let contents = {
        __type: "Snapshot",
        DataEncryptionKeyId: undefined,
        Description: undefined,
        Encrypted: undefined,
        KmsKeyId: undefined,
        OwnerAlias: undefined,
        OwnerId: undefined,
        Progress: undefined,
        SnapshotId: undefined,
        StartTime: undefined,
        State: undefined,
        StateMessage: undefined,
        Tags: undefined,
        VolumeId: undefined,
        VolumeSize: undefined
    };
    if (output["dataEncryptionKeyId"] !== undefined) {
        contents.DataEncryptionKeyId = output["dataEncryptionKeyId"];
    }
    if (output["description"] !== undefined) {
        contents.Description = output["description"];
    }
    if (output["encrypted"] !== undefined) {
        contents.Encrypted = output["encrypted"] == "true";
    }
    if (output["kmsKeyId"] !== undefined) {
        contents.KmsKeyId = output["kmsKeyId"];
    }
    if (output["ownerAlias"] !== undefined) {
        contents.OwnerAlias = output["ownerAlias"];
    }
    if (output["ownerId"] !== undefined) {
        contents.OwnerId = output["ownerId"];
    }
    if (output["progress"] !== undefined) {
        contents.Progress = output["progress"];
    }
    if (output["snapshotId"] !== undefined) {
        contents.SnapshotId = output["snapshotId"];
    }
    if (output["startTime"] !== undefined) {
        contents.StartTime = new Date(output["startTime"]);
    }
    if (output["status"] !== undefined) {
        contents.State = output["status"];
    }
    if (output["statusMessage"] !== undefined) {
        contents.StateMessage = output["statusMessage"];
    }
    if (output.tagSet === "") {
        contents.Tags = [];
    }
    if (output["tagSet"] !== undefined &&
        output["tagSet"]["item"] !== undefined) {
        const wrappedItem = output["tagSet"]["item"] instanceof Array
            ? output["tagSet"]["item"]
            : [output["tagSet"]["item"]];
        contents.Tags = deserializeAws_ec2TagList(wrappedItem, context);
    }
    if (output["volumeId"] !== undefined) {
        contents.VolumeId = output["volumeId"];
    }
    if (output["volumeSize"] !== undefined) {
        contents.VolumeSize = parseInt(output["volumeSize"]);
    }
    return contents;
};
const deserializeAws_ec2SnapshotDetail = (output, context) => {
    let contents = {
        __type: "SnapshotDetail",
        Description: undefined,
        DeviceName: undefined,
        DiskImageSize: undefined,
        Format: undefined,
        Progress: undefined,
        SnapshotId: undefined,
        Status: undefined,
        StatusMessage: undefined,
        Url: undefined,
        UserBucket: undefined
    };
    if (output["description"] !== undefined) {
        contents.Description = output["description"];
    }
    if (output["deviceName"] !== undefined) {
        contents.DeviceName = output["deviceName"];
    }
    if (output["diskImageSize"] !== undefined) {
        contents.DiskImageSize = parseFloat(output["diskImageSize"]);
    }
    if (output["format"] !== undefined) {
        contents.Format = output["format"];
    }
    if (output["progress"] !== undefined) {
        contents.Progress = output["progress"];
    }
    if (output["snapshotId"] !== undefined) {
        contents.SnapshotId = output["snapshotId"];
    }
    if (output["status"] !== undefined) {
        contents.Status = output["status"];
    }
    if (output["statusMessage"] !== undefined) {
        contents.StatusMessage = output["statusMessage"];
    }
    if (output["url"] !== undefined) {
        contents.Url = output["url"];
    }
    if (output["userBucket"] !== undefined) {
        contents.UserBucket = deserializeAws_ec2UserBucketDetails(output["userBucket"], context);
    }
    return contents;
};
const deserializeAws_ec2SnapshotDetailList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2SnapshotDetail(entry, context));
    });
    return contents;
};
const deserializeAws_ec2SnapshotInfo = (output, context) => {
    let contents = {
        __type: "SnapshotInfo",
        Description: undefined,
        Encrypted: undefined,
        OwnerId: undefined,
        Progress: undefined,
        SnapshotId: undefined,
        StartTime: undefined,
        State: undefined,
        Tags: undefined,
        VolumeId: undefined,
        VolumeSize: undefined
    };
    if (output["description"] !== undefined) {
        contents.Description = output["description"];
    }
    if (output["encrypted"] !== undefined) {
        contents.Encrypted = output["encrypted"] == "true";
    }
    if (output["ownerId"] !== undefined) {
        contents.OwnerId = output["ownerId"];
    }
    if (output["progress"] !== undefined) {
        contents.Progress = output["progress"];
    }
    if (output["snapshotId"] !== undefined) {
        contents.SnapshotId = output["snapshotId"];
    }
    if (output["startTime"] !== undefined) {
        contents.StartTime = new Date(output["startTime"]);
    }
    if (output["state"] !== undefined) {
        contents.State = output["state"];
    }
    if (output.tagSet === "") {
        contents.Tags = [];
    }
    if (output["tagSet"] !== undefined &&
        output["tagSet"]["item"] !== undefined) {
        const wrappedItem = output["tagSet"]["item"] instanceof Array
            ? output["tagSet"]["item"]
            : [output["tagSet"]["item"]];
        contents.Tags = deserializeAws_ec2TagList(wrappedItem, context);
    }
    if (output["volumeId"] !== undefined) {
        contents.VolumeId = output["volumeId"];
    }
    if (output["volumeSize"] !== undefined) {
        contents.VolumeSize = parseInt(output["volumeSize"]);
    }
    return contents;
};
const deserializeAws_ec2SnapshotList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2Snapshot(entry, context));
    });
    return contents;
};
const deserializeAws_ec2SnapshotSet = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2SnapshotInfo(entry, context));
    });
    return contents;
};
const deserializeAws_ec2SnapshotTaskDetail = (output, context) => {
    let contents = {
        __type: "SnapshotTaskDetail",
        Description: undefined,
        DiskImageSize: undefined,
        Encrypted: undefined,
        Format: undefined,
        KmsKeyId: undefined,
        Progress: undefined,
        SnapshotId: undefined,
        Status: undefined,
        StatusMessage: undefined,
        Url: undefined,
        UserBucket: undefined
    };
    if (output["description"] !== undefined) {
        contents.Description = output["description"];
    }
    if (output["diskImageSize"] !== undefined) {
        contents.DiskImageSize = parseFloat(output["diskImageSize"]);
    }
    if (output["encrypted"] !== undefined) {
        contents.Encrypted = output["encrypted"] == "true";
    }
    if (output["format"] !== undefined) {
        contents.Format = output["format"];
    }
    if (output["kmsKeyId"] !== undefined) {
        contents.KmsKeyId = output["kmsKeyId"];
    }
    if (output["progress"] !== undefined) {
        contents.Progress = output["progress"];
    }
    if (output["snapshotId"] !== undefined) {
        contents.SnapshotId = output["snapshotId"];
    }
    if (output["status"] !== undefined) {
        contents.Status = output["status"];
    }
    if (output["statusMessage"] !== undefined) {
        contents.StatusMessage = output["statusMessage"];
    }
    if (output["url"] !== undefined) {
        contents.Url = output["url"];
    }
    if (output["userBucket"] !== undefined) {
        contents.UserBucket = deserializeAws_ec2UserBucketDetails(output["userBucket"], context);
    }
    return contents;
};
const deserializeAws_ec2SpotDatafeedSubscription = (output, context) => {
    let contents = {
        __type: "SpotDatafeedSubscription",
        Bucket: undefined,
        Fault: undefined,
        OwnerId: undefined,
        Prefix: undefined,
        State: undefined
    };
    if (output["bucket"] !== undefined) {
        contents.Bucket = output["bucket"];
    }
    if (output["fault"] !== undefined) {
        contents.Fault = deserializeAws_ec2SpotInstanceStateFault(output["fault"], context);
    }
    if (output["ownerId"] !== undefined) {
        contents.OwnerId = output["ownerId"];
    }
    if (output["prefix"] !== undefined) {
        contents.Prefix = output["prefix"];
    }
    if (output["state"] !== undefined) {
        contents.State = output["state"];
    }
    return contents;
};
const deserializeAws_ec2SpotFleetLaunchSpecification = (output, context) => {
    let contents = {
        __type: "SpotFleetLaunchSpecification",
        AddressingType: undefined,
        BlockDeviceMappings: undefined,
        EbsOptimized: undefined,
        IamInstanceProfile: undefined,
        ImageId: undefined,
        InstanceType: undefined,
        KernelId: undefined,
        KeyName: undefined,
        Monitoring: undefined,
        NetworkInterfaces: undefined,
        Placement: undefined,
        RamdiskId: undefined,
        SecurityGroups: undefined,
        SpotPrice: undefined,
        SubnetId: undefined,
        TagSpecifications: undefined,
        UserData: undefined,
        WeightedCapacity: undefined
    };
    if (output["addressingType"] !== undefined) {
        contents.AddressingType = output["addressingType"];
    }
    if (output.blockDeviceMapping === "") {
        contents.BlockDeviceMappings = [];
    }
    if (output["blockDeviceMapping"] !== undefined &&
        output["blockDeviceMapping"]["item"] !== undefined) {
        const wrappedItem = output["blockDeviceMapping"]["item"] instanceof Array
            ? output["blockDeviceMapping"]["item"]
            : [output["blockDeviceMapping"]["item"]];
        contents.BlockDeviceMappings = deserializeAws_ec2BlockDeviceMappingList(wrappedItem, context);
    }
    if (output["ebsOptimized"] !== undefined) {
        contents.EbsOptimized = output["ebsOptimized"] == "true";
    }
    if (output["iamInstanceProfile"] !== undefined) {
        contents.IamInstanceProfile = deserializeAws_ec2IamInstanceProfileSpecification(output["iamInstanceProfile"], context);
    }
    if (output["imageId"] !== undefined) {
        contents.ImageId = output["imageId"];
    }
    if (output["instanceType"] !== undefined) {
        contents.InstanceType = output["instanceType"];
    }
    if (output["kernelId"] !== undefined) {
        contents.KernelId = output["kernelId"];
    }
    if (output["keyName"] !== undefined) {
        contents.KeyName = output["keyName"];
    }
    if (output["monitoring"] !== undefined) {
        contents.Monitoring = deserializeAws_ec2SpotFleetMonitoring(output["monitoring"], context);
    }
    if (output.networkInterfaceSet === "") {
        contents.NetworkInterfaces = [];
    }
    if (output["networkInterfaceSet"] !== undefined &&
        output["networkInterfaceSet"]["item"] !== undefined) {
        const wrappedItem = output["networkInterfaceSet"]["item"] instanceof Array
            ? output["networkInterfaceSet"]["item"]
            : [output["networkInterfaceSet"]["item"]];
        contents.NetworkInterfaces = deserializeAws_ec2InstanceNetworkInterfaceSpecificationList(wrappedItem, context);
    }
    if (output["placement"] !== undefined) {
        contents.Placement = deserializeAws_ec2SpotPlacement(output["placement"], context);
    }
    if (output["ramdiskId"] !== undefined) {
        contents.RamdiskId = output["ramdiskId"];
    }
    if (output.groupSet === "") {
        contents.SecurityGroups = [];
    }
    if (output["groupSet"] !== undefined &&
        output["groupSet"]["item"] !== undefined) {
        const wrappedItem = output["groupSet"]["item"] instanceof Array
            ? output["groupSet"]["item"]
            : [output["groupSet"]["item"]];
        contents.SecurityGroups = deserializeAws_ec2GroupIdentifierList(wrappedItem, context);
    }
    if (output["spotPrice"] !== undefined) {
        contents.SpotPrice = output["spotPrice"];
    }
    if (output["subnetId"] !== undefined) {
        contents.SubnetId = output["subnetId"];
    }
    if (output.tagSpecificationSet === "") {
        contents.TagSpecifications = [];
    }
    if (output["tagSpecificationSet"] !== undefined &&
        output["tagSpecificationSet"]["item"] !== undefined) {
        const wrappedItem = output["tagSpecificationSet"]["item"] instanceof Array
            ? output["tagSpecificationSet"]["item"]
            : [output["tagSpecificationSet"]["item"]];
        contents.TagSpecifications = deserializeAws_ec2SpotFleetTagSpecificationList(wrappedItem, context);
    }
    if (output["userData"] !== undefined) {
        contents.UserData = output["userData"];
    }
    if (output["weightedCapacity"] !== undefined) {
        contents.WeightedCapacity = parseFloat(output["weightedCapacity"]);
    }
    return contents;
};
const deserializeAws_ec2SpotFleetMonitoring = (output, context) => {
    let contents = {
        __type: "SpotFleetMonitoring",
        Enabled: undefined
    };
    if (output["enabled"] !== undefined) {
        contents.Enabled = output["enabled"] == "true";
    }
    return contents;
};
const deserializeAws_ec2SpotFleetRequestConfig = (output, context) => {
    let contents = {
        __type: "SpotFleetRequestConfig",
        ActivityStatus: undefined,
        CreateTime: undefined,
        SpotFleetRequestConfig: undefined,
        SpotFleetRequestId: undefined,
        SpotFleetRequestState: undefined
    };
    if (output["activityStatus"] !== undefined) {
        contents.ActivityStatus = output["activityStatus"];
    }
    if (output["createTime"] !== undefined) {
        contents.CreateTime = new Date(output["createTime"]);
    }
    if (output["spotFleetRequestConfig"] !== undefined) {
        contents.SpotFleetRequestConfig = deserializeAws_ec2SpotFleetRequestConfigData(output["spotFleetRequestConfig"], context);
    }
    if (output["spotFleetRequestId"] !== undefined) {
        contents.SpotFleetRequestId = output["spotFleetRequestId"];
    }
    if (output["spotFleetRequestState"] !== undefined) {
        contents.SpotFleetRequestState = output["spotFleetRequestState"];
    }
    return contents;
};
const deserializeAws_ec2SpotFleetRequestConfigData = (output, context) => {
    let contents = {
        __type: "SpotFleetRequestConfigData",
        AllocationStrategy: undefined,
        ClientToken: undefined,
        ExcessCapacityTerminationPolicy: undefined,
        FulfilledCapacity: undefined,
        IamFleetRole: undefined,
        InstanceInterruptionBehavior: undefined,
        InstancePoolsToUseCount: undefined,
        LaunchSpecifications: undefined,
        LaunchTemplateConfigs: undefined,
        LoadBalancersConfig: undefined,
        OnDemandAllocationStrategy: undefined,
        OnDemandFulfilledCapacity: undefined,
        OnDemandMaxTotalPrice: undefined,
        OnDemandTargetCapacity: undefined,
        ReplaceUnhealthyInstances: undefined,
        SpotMaxTotalPrice: undefined,
        SpotPrice: undefined,
        TargetCapacity: undefined,
        TerminateInstancesWithExpiration: undefined,
        Type: undefined,
        ValidFrom: undefined,
        ValidUntil: undefined
    };
    if (output["allocationStrategy"] !== undefined) {
        contents.AllocationStrategy = output["allocationStrategy"];
    }
    if (output["clientToken"] !== undefined) {
        contents.ClientToken = output["clientToken"];
    }
    if (output["excessCapacityTerminationPolicy"] !== undefined) {
        contents.ExcessCapacityTerminationPolicy =
            output["excessCapacityTerminationPolicy"];
    }
    if (output["fulfilledCapacity"] !== undefined) {
        contents.FulfilledCapacity = parseFloat(output["fulfilledCapacity"]);
    }
    if (output["iamFleetRole"] !== undefined) {
        contents.IamFleetRole = output["iamFleetRole"];
    }
    if (output["instanceInterruptionBehavior"] !== undefined) {
        contents.InstanceInterruptionBehavior =
            output["instanceInterruptionBehavior"];
    }
    if (output["instancePoolsToUseCount"] !== undefined) {
        contents.InstancePoolsToUseCount = parseInt(output["instancePoolsToUseCount"]);
    }
    if (output.launchSpecifications === "") {
        contents.LaunchSpecifications = [];
    }
    if (output["launchSpecifications"] !== undefined &&
        output["launchSpecifications"]["item"] !== undefined) {
        const wrappedItem = output["launchSpecifications"]["item"] instanceof Array
            ? output["launchSpecifications"]["item"]
            : [output["launchSpecifications"]["item"]];
        contents.LaunchSpecifications = deserializeAws_ec2LaunchSpecsList(wrappedItem, context);
    }
    if (output.launchTemplateConfigs === "") {
        contents.LaunchTemplateConfigs = [];
    }
    if (output["launchTemplateConfigs"] !== undefined &&
        output["launchTemplateConfigs"]["item"] !== undefined) {
        const wrappedItem = output["launchTemplateConfigs"]["item"] instanceof Array
            ? output["launchTemplateConfigs"]["item"]
            : [output["launchTemplateConfigs"]["item"]];
        contents.LaunchTemplateConfigs = deserializeAws_ec2LaunchTemplateConfigList(wrappedItem, context);
    }
    if (output["loadBalancersConfig"] !== undefined) {
        contents.LoadBalancersConfig = deserializeAws_ec2LoadBalancersConfig(output["loadBalancersConfig"], context);
    }
    if (output["onDemandAllocationStrategy"] !== undefined) {
        contents.OnDemandAllocationStrategy = output["onDemandAllocationStrategy"];
    }
    if (output["onDemandFulfilledCapacity"] !== undefined) {
        contents.OnDemandFulfilledCapacity = parseFloat(output["onDemandFulfilledCapacity"]);
    }
    if (output["onDemandMaxTotalPrice"] !== undefined) {
        contents.OnDemandMaxTotalPrice = output["onDemandMaxTotalPrice"];
    }
    if (output["onDemandTargetCapacity"] !== undefined) {
        contents.OnDemandTargetCapacity = parseInt(output["onDemandTargetCapacity"]);
    }
    if (output["replaceUnhealthyInstances"] !== undefined) {
        contents.ReplaceUnhealthyInstances =
            output["replaceUnhealthyInstances"] == "true";
    }
    if (output["spotMaxTotalPrice"] !== undefined) {
        contents.SpotMaxTotalPrice = output["spotMaxTotalPrice"];
    }
    if (output["spotPrice"] !== undefined) {
        contents.SpotPrice = output["spotPrice"];
    }
    if (output["targetCapacity"] !== undefined) {
        contents.TargetCapacity = parseInt(output["targetCapacity"]);
    }
    if (output["terminateInstancesWithExpiration"] !== undefined) {
        contents.TerminateInstancesWithExpiration =
            output["terminateInstancesWithExpiration"] == "true";
    }
    if (output["type"] !== undefined) {
        contents.Type = output["type"];
    }
    if (output["validFrom"] !== undefined) {
        contents.ValidFrom = new Date(output["validFrom"]);
    }
    if (output["validUntil"] !== undefined) {
        contents.ValidUntil = new Date(output["validUntil"]);
    }
    return contents;
};
const deserializeAws_ec2SpotFleetRequestConfigSet = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2SpotFleetRequestConfig(entry, context));
    });
    return contents;
};
const deserializeAws_ec2SpotFleetTagSpecification = (output, context) => {
    let contents = {
        __type: "SpotFleetTagSpecification",
        ResourceType: undefined,
        Tags: undefined
    };
    if (output["resourceType"] !== undefined) {
        contents.ResourceType = output["resourceType"];
    }
    if (output.tag === "") {
        contents.Tags = [];
    }
    if (output["tag"] !== undefined && output["tag"]["item"] !== undefined) {
        const wrappedItem = output["tag"]["item"] instanceof Array
            ? output["tag"]["item"]
            : [output["tag"]["item"]];
        contents.Tags = deserializeAws_ec2TagList(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2SpotFleetTagSpecificationList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2SpotFleetTagSpecification(entry, context));
    });
    return contents;
};
const deserializeAws_ec2SpotInstanceRequest = (output, context) => {
    let contents = {
        __type: "SpotInstanceRequest",
        ActualBlockHourlyPrice: undefined,
        AvailabilityZoneGroup: undefined,
        BlockDurationMinutes: undefined,
        CreateTime: undefined,
        Fault: undefined,
        InstanceId: undefined,
        InstanceInterruptionBehavior: undefined,
        LaunchGroup: undefined,
        LaunchSpecification: undefined,
        LaunchedAvailabilityZone: undefined,
        ProductDescription: undefined,
        SpotInstanceRequestId: undefined,
        SpotPrice: undefined,
        State: undefined,
        Status: undefined,
        Tags: undefined,
        Type: undefined,
        ValidFrom: undefined,
        ValidUntil: undefined
    };
    if (output["actualBlockHourlyPrice"] !== undefined) {
        contents.ActualBlockHourlyPrice = output["actualBlockHourlyPrice"];
    }
    if (output["availabilityZoneGroup"] !== undefined) {
        contents.AvailabilityZoneGroup = output["availabilityZoneGroup"];
    }
    if (output["blockDurationMinutes"] !== undefined) {
        contents.BlockDurationMinutes = parseInt(output["blockDurationMinutes"]);
    }
    if (output["createTime"] !== undefined) {
        contents.CreateTime = new Date(output["createTime"]);
    }
    if (output["fault"] !== undefined) {
        contents.Fault = deserializeAws_ec2SpotInstanceStateFault(output["fault"], context);
    }
    if (output["instanceId"] !== undefined) {
        contents.InstanceId = output["instanceId"];
    }
    if (output["instanceInterruptionBehavior"] !== undefined) {
        contents.InstanceInterruptionBehavior =
            output["instanceInterruptionBehavior"];
    }
    if (output["launchGroup"] !== undefined) {
        contents.LaunchGroup = output["launchGroup"];
    }
    if (output["launchSpecification"] !== undefined) {
        contents.LaunchSpecification = deserializeAws_ec2LaunchSpecification(output["launchSpecification"], context);
    }
    if (output["launchedAvailabilityZone"] !== undefined) {
        contents.LaunchedAvailabilityZone = output["launchedAvailabilityZone"];
    }
    if (output["productDescription"] !== undefined) {
        contents.ProductDescription = output["productDescription"];
    }
    if (output["spotInstanceRequestId"] !== undefined) {
        contents.SpotInstanceRequestId = output["spotInstanceRequestId"];
    }
    if (output["spotPrice"] !== undefined) {
        contents.SpotPrice = output["spotPrice"];
    }
    if (output["state"] !== undefined) {
        contents.State = output["state"];
    }
    if (output["status"] !== undefined) {
        contents.Status = deserializeAws_ec2SpotInstanceStatus(output["status"], context);
    }
    if (output.tagSet === "") {
        contents.Tags = [];
    }
    if (output["tagSet"] !== undefined &&
        output["tagSet"]["item"] !== undefined) {
        const wrappedItem = output["tagSet"]["item"] instanceof Array
            ? output["tagSet"]["item"]
            : [output["tagSet"]["item"]];
        contents.Tags = deserializeAws_ec2TagList(wrappedItem, context);
    }
    if (output["type"] !== undefined) {
        contents.Type = output["type"];
    }
    if (output["validFrom"] !== undefined) {
        contents.ValidFrom = new Date(output["validFrom"]);
    }
    if (output["validUntil"] !== undefined) {
        contents.ValidUntil = new Date(output["validUntil"]);
    }
    return contents;
};
const deserializeAws_ec2SpotInstanceRequestList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2SpotInstanceRequest(entry, context));
    });
    return contents;
};
const deserializeAws_ec2SpotInstanceStateFault = (output, context) => {
    let contents = {
        __type: "SpotInstanceStateFault",
        Code: undefined,
        Message: undefined
    };
    if (output["code"] !== undefined) {
        contents.Code = output["code"];
    }
    if (output["message"] !== undefined) {
        contents.Message = output["message"];
    }
    return contents;
};
const deserializeAws_ec2SpotInstanceStatus = (output, context) => {
    let contents = {
        __type: "SpotInstanceStatus",
        Code: undefined,
        Message: undefined,
        UpdateTime: undefined
    };
    if (output["code"] !== undefined) {
        contents.Code = output["code"];
    }
    if (output["message"] !== undefined) {
        contents.Message = output["message"];
    }
    if (output["updateTime"] !== undefined) {
        contents.UpdateTime = new Date(output["updateTime"]);
    }
    return contents;
};
const deserializeAws_ec2SpotOptions = (output, context) => {
    let contents = {
        __type: "SpotOptions",
        AllocationStrategy: undefined,
        InstanceInterruptionBehavior: undefined,
        InstancePoolsToUseCount: undefined,
        MaxTotalPrice: undefined,
        MinTargetCapacity: undefined,
        SingleAvailabilityZone: undefined,
        SingleInstanceType: undefined
    };
    if (output["allocationStrategy"] !== undefined) {
        contents.AllocationStrategy = output["allocationStrategy"];
    }
    if (output["instanceInterruptionBehavior"] !== undefined) {
        contents.InstanceInterruptionBehavior =
            output["instanceInterruptionBehavior"];
    }
    if (output["instancePoolsToUseCount"] !== undefined) {
        contents.InstancePoolsToUseCount = parseInt(output["instancePoolsToUseCount"]);
    }
    if (output["maxTotalPrice"] !== undefined) {
        contents.MaxTotalPrice = output["maxTotalPrice"];
    }
    if (output["minTargetCapacity"] !== undefined) {
        contents.MinTargetCapacity = parseInt(output["minTargetCapacity"]);
    }
    if (output["singleAvailabilityZone"] !== undefined) {
        contents.SingleAvailabilityZone =
            output["singleAvailabilityZone"] == "true";
    }
    if (output["singleInstanceType"] !== undefined) {
        contents.SingleInstanceType = output["singleInstanceType"] == "true";
    }
    return contents;
};
const deserializeAws_ec2SpotPlacement = (output, context) => {
    let contents = {
        __type: "SpotPlacement",
        AvailabilityZone: undefined,
        GroupName: undefined,
        Tenancy: undefined
    };
    if (output["availabilityZone"] !== undefined) {
        contents.AvailabilityZone = output["availabilityZone"];
    }
    if (output["groupName"] !== undefined) {
        contents.GroupName = output["groupName"];
    }
    if (output["tenancy"] !== undefined) {
        contents.Tenancy = output["tenancy"];
    }
    return contents;
};
const deserializeAws_ec2SpotPrice = (output, context) => {
    let contents = {
        __type: "SpotPrice",
        AvailabilityZone: undefined,
        InstanceType: undefined,
        ProductDescription: undefined,
        SpotPrice: undefined,
        Timestamp: undefined
    };
    if (output["availabilityZone"] !== undefined) {
        contents.AvailabilityZone = output["availabilityZone"];
    }
    if (output["instanceType"] !== undefined) {
        contents.InstanceType = output["instanceType"];
    }
    if (output["productDescription"] !== undefined) {
        contents.ProductDescription = output["productDescription"];
    }
    if (output["spotPrice"] !== undefined) {
        contents.SpotPrice = output["spotPrice"];
    }
    if (output["timestamp"] !== undefined) {
        contents.Timestamp = new Date(output["timestamp"]);
    }
    return contents;
};
const deserializeAws_ec2SpotPriceHistoryList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2SpotPrice(entry, context));
    });
    return contents;
};
const deserializeAws_ec2StaleIpPermission = (output, context) => {
    let contents = {
        __type: "StaleIpPermission",
        FromPort: undefined,
        IpProtocol: undefined,
        IpRanges: undefined,
        PrefixListIds: undefined,
        ToPort: undefined,
        UserIdGroupPairs: undefined
    };
    if (output["fromPort"] !== undefined) {
        contents.FromPort = parseInt(output["fromPort"]);
    }
    if (output["ipProtocol"] !== undefined) {
        contents.IpProtocol = output["ipProtocol"];
    }
    if (output.ipRanges === "") {
        contents.IpRanges = [];
    }
    if (output["ipRanges"] !== undefined &&
        output["ipRanges"]["item"] !== undefined) {
        const wrappedItem = output["ipRanges"]["item"] instanceof Array
            ? output["ipRanges"]["item"]
            : [output["ipRanges"]["item"]];
        contents.IpRanges = deserializeAws_ec2IpRanges(wrappedItem, context);
    }
    if (output.prefixListIds === "") {
        contents.PrefixListIds = [];
    }
    if (output["prefixListIds"] !== undefined &&
        output["prefixListIds"]["item"] !== undefined) {
        const wrappedItem = output["prefixListIds"]["item"] instanceof Array
            ? output["prefixListIds"]["item"]
            : [output["prefixListIds"]["item"]];
        contents.PrefixListIds = deserializeAws_ec2PrefixListIdSet(wrappedItem, context);
    }
    if (output["toPort"] !== undefined) {
        contents.ToPort = parseInt(output["toPort"]);
    }
    if (output.groups === "") {
        contents.UserIdGroupPairs = [];
    }
    if (output["groups"] !== undefined &&
        output["groups"]["item"] !== undefined) {
        const wrappedItem = output["groups"]["item"] instanceof Array
            ? output["groups"]["item"]
            : [output["groups"]["item"]];
        contents.UserIdGroupPairs = deserializeAws_ec2UserIdGroupPairSet(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2StaleIpPermissionSet = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2StaleIpPermission(entry, context));
    });
    return contents;
};
const deserializeAws_ec2StaleSecurityGroup = (output, context) => {
    let contents = {
        __type: "StaleSecurityGroup",
        Description: undefined,
        GroupId: undefined,
        GroupName: undefined,
        StaleIpPermissions: undefined,
        StaleIpPermissionsEgress: undefined,
        VpcId: undefined
    };
    if (output["description"] !== undefined) {
        contents.Description = output["description"];
    }
    if (output["groupId"] !== undefined) {
        contents.GroupId = output["groupId"];
    }
    if (output["groupName"] !== undefined) {
        contents.GroupName = output["groupName"];
    }
    if (output.staleIpPermissions === "") {
        contents.StaleIpPermissions = [];
    }
    if (output["staleIpPermissions"] !== undefined &&
        output["staleIpPermissions"]["item"] !== undefined) {
        const wrappedItem = output["staleIpPermissions"]["item"] instanceof Array
            ? output["staleIpPermissions"]["item"]
            : [output["staleIpPermissions"]["item"]];
        contents.StaleIpPermissions = deserializeAws_ec2StaleIpPermissionSet(wrappedItem, context);
    }
    if (output.staleIpPermissionsEgress === "") {
        contents.StaleIpPermissionsEgress = [];
    }
    if (output["staleIpPermissionsEgress"] !== undefined &&
        output["staleIpPermissionsEgress"]["item"] !== undefined) {
        const wrappedItem = output["staleIpPermissionsEgress"]["item"] instanceof Array
            ? output["staleIpPermissionsEgress"]["item"]
            : [output["staleIpPermissionsEgress"]["item"]];
        contents.StaleIpPermissionsEgress = deserializeAws_ec2StaleIpPermissionSet(wrappedItem, context);
    }
    if (output["vpcId"] !== undefined) {
        contents.VpcId = output["vpcId"];
    }
    return contents;
};
const deserializeAws_ec2StaleSecurityGroupSet = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2StaleSecurityGroup(entry, context));
    });
    return contents;
};
const deserializeAws_ec2StartInstancesResult = (output, context) => {
    let contents = {
        __type: "StartInstancesResult",
        StartingInstances: undefined
    };
    if (output.instancesSet === "") {
        contents.StartingInstances = [];
    }
    if (output["instancesSet"] !== undefined &&
        output["instancesSet"]["item"] !== undefined) {
        const wrappedItem = output["instancesSet"]["item"] instanceof Array
            ? output["instancesSet"]["item"]
            : [output["instancesSet"]["item"]];
        contents.StartingInstances = deserializeAws_ec2InstanceStateChangeList(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2StartVpcEndpointServicePrivateDnsVerificationResult = (output, context) => {
    let contents = {
        __type: "StartVpcEndpointServicePrivateDnsVerificationResult",
        ReturnValue: undefined
    };
    if (output["return"] !== undefined) {
        contents.ReturnValue = output["return"] == "true";
    }
    return contents;
};
const deserializeAws_ec2StateReason = (output, context) => {
    let contents = {
        __type: "StateReason",
        Code: undefined,
        Message: undefined
    };
    if (output["code"] !== undefined) {
        contents.Code = output["code"];
    }
    if (output["message"] !== undefined) {
        contents.Message = output["message"];
    }
    return contents;
};
const deserializeAws_ec2StopInstancesResult = (output, context) => {
    let contents = {
        __type: "StopInstancesResult",
        StoppingInstances: undefined
    };
    if (output.instancesSet === "") {
        contents.StoppingInstances = [];
    }
    if (output["instancesSet"] !== undefined &&
        output["instancesSet"]["item"] !== undefined) {
        const wrappedItem = output["instancesSet"]["item"] instanceof Array
            ? output["instancesSet"]["item"]
            : [output["instancesSet"]["item"]];
        contents.StoppingInstances = deserializeAws_ec2InstanceStateChangeList(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2Storage = (output, context) => {
    let contents = {
        __type: "Storage",
        S3: undefined
    };
    if (output["S3"] !== undefined) {
        contents.S3 = deserializeAws_ec2S3Storage(output["S3"], context);
    }
    return contents;
};
const deserializeAws_ec2Subnet = (output, context) => {
    let contents = {
        __type: "Subnet",
        AssignIpv6AddressOnCreation: undefined,
        AvailabilityZone: undefined,
        AvailabilityZoneId: undefined,
        AvailableIpAddressCount: undefined,
        CidrBlock: undefined,
        DefaultForAz: undefined,
        Ipv6CidrBlockAssociationSet: undefined,
        MapPublicIpOnLaunch: undefined,
        OutpostArn: undefined,
        OwnerId: undefined,
        State: undefined,
        SubnetArn: undefined,
        SubnetId: undefined,
        Tags: undefined,
        VpcId: undefined
    };
    if (output["assignIpv6AddressOnCreation"] !== undefined) {
        contents.AssignIpv6AddressOnCreation =
            output["assignIpv6AddressOnCreation"] == "true";
    }
    if (output["availabilityZone"] !== undefined) {
        contents.AvailabilityZone = output["availabilityZone"];
    }
    if (output["availabilityZoneId"] !== undefined) {
        contents.AvailabilityZoneId = output["availabilityZoneId"];
    }
    if (output["availableIpAddressCount"] !== undefined) {
        contents.AvailableIpAddressCount = parseInt(output["availableIpAddressCount"]);
    }
    if (output["cidrBlock"] !== undefined) {
        contents.CidrBlock = output["cidrBlock"];
    }
    if (output["defaultForAz"] !== undefined) {
        contents.DefaultForAz = output["defaultForAz"] == "true";
    }
    if (output.ipv6CidrBlockAssociationSet === "") {
        contents.Ipv6CidrBlockAssociationSet = [];
    }
    if (output["ipv6CidrBlockAssociationSet"] !== undefined &&
        output["ipv6CidrBlockAssociationSet"]["item"] !== undefined) {
        const wrappedItem = output["ipv6CidrBlockAssociationSet"]["item"] instanceof Array
            ? output["ipv6CidrBlockAssociationSet"]["item"]
            : [output["ipv6CidrBlockAssociationSet"]["item"]];
        contents.Ipv6CidrBlockAssociationSet = deserializeAws_ec2SubnetIpv6CidrBlockAssociationSet(wrappedItem, context);
    }
    if (output["mapPublicIpOnLaunch"] !== undefined) {
        contents.MapPublicIpOnLaunch = output["mapPublicIpOnLaunch"] == "true";
    }
    if (output["outpostArn"] !== undefined) {
        contents.OutpostArn = output["outpostArn"];
    }
    if (output["ownerId"] !== undefined) {
        contents.OwnerId = output["ownerId"];
    }
    if (output["state"] !== undefined) {
        contents.State = output["state"];
    }
    if (output["subnetArn"] !== undefined) {
        contents.SubnetArn = output["subnetArn"];
    }
    if (output["subnetId"] !== undefined) {
        contents.SubnetId = output["subnetId"];
    }
    if (output.tagSet === "") {
        contents.Tags = [];
    }
    if (output["tagSet"] !== undefined &&
        output["tagSet"]["item"] !== undefined) {
        const wrappedItem = output["tagSet"]["item"] instanceof Array
            ? output["tagSet"]["item"]
            : [output["tagSet"]["item"]];
        contents.Tags = deserializeAws_ec2TagList(wrappedItem, context);
    }
    if (output["vpcId"] !== undefined) {
        contents.VpcId = output["vpcId"];
    }
    return contents;
};
const deserializeAws_ec2SubnetAssociation = (output, context) => {
    let contents = {
        __type: "SubnetAssociation",
        State: undefined,
        SubnetId: undefined
    };
    if (output["state"] !== undefined) {
        contents.State = output["state"];
    }
    if (output["subnetId"] !== undefined) {
        contents.SubnetId = output["subnetId"];
    }
    return contents;
};
const deserializeAws_ec2SubnetAssociationList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2SubnetAssociation(entry, context));
    });
    return contents;
};
const deserializeAws_ec2SubnetCidrBlockState = (output, context) => {
    let contents = {
        __type: "SubnetCidrBlockState",
        State: undefined,
        StatusMessage: undefined
    };
    if (output["state"] !== undefined) {
        contents.State = output["state"];
    }
    if (output["statusMessage"] !== undefined) {
        contents.StatusMessage = output["statusMessage"];
    }
    return contents;
};
const deserializeAws_ec2SubnetIpv6CidrBlockAssociation = (output, context) => {
    let contents = {
        __type: "SubnetIpv6CidrBlockAssociation",
        AssociationId: undefined,
        Ipv6CidrBlock: undefined,
        Ipv6CidrBlockState: undefined
    };
    if (output["associationId"] !== undefined) {
        contents.AssociationId = output["associationId"];
    }
    if (output["ipv6CidrBlock"] !== undefined) {
        contents.Ipv6CidrBlock = output["ipv6CidrBlock"];
    }
    if (output["ipv6CidrBlockState"] !== undefined) {
        contents.Ipv6CidrBlockState = deserializeAws_ec2SubnetCidrBlockState(output["ipv6CidrBlockState"], context);
    }
    return contents;
};
const deserializeAws_ec2SubnetIpv6CidrBlockAssociationSet = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2SubnetIpv6CidrBlockAssociation(entry, context));
    });
    return contents;
};
const deserializeAws_ec2SubnetList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2Subnet(entry, context));
    });
    return contents;
};
const deserializeAws_ec2SuccessfulInstanceCreditSpecificationItem = (output, context) => {
    let contents = {
        __type: "SuccessfulInstanceCreditSpecificationItem",
        InstanceId: undefined
    };
    if (output["instanceId"] !== undefined) {
        contents.InstanceId = output["instanceId"];
    }
    return contents;
};
const deserializeAws_ec2SuccessfulInstanceCreditSpecificationSet = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2SuccessfulInstanceCreditSpecificationItem(entry, context));
    });
    return contents;
};
const deserializeAws_ec2SuccessfulQueuedPurchaseDeletion = (output, context) => {
    let contents = {
        __type: "SuccessfulQueuedPurchaseDeletion",
        ReservedInstancesId: undefined
    };
    if (output["reservedInstancesId"] !== undefined) {
        contents.ReservedInstancesId = output["reservedInstancesId"];
    }
    return contents;
};
const deserializeAws_ec2SuccessfulQueuedPurchaseDeletionSet = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2SuccessfulQueuedPurchaseDeletion(entry, context));
    });
    return contents;
};
const deserializeAws_ec2Tag = (output, context) => {
    let contents = {
        __type: "Tag",
        Key: undefined,
        Value: undefined
    };
    if (output["key"] !== undefined) {
        contents.Key = output["key"];
    }
    if (output["value"] !== undefined) {
        contents.Value = output["value"];
    }
    return contents;
};
const deserializeAws_ec2TagDescription = (output, context) => {
    let contents = {
        __type: "TagDescription",
        Key: undefined,
        ResourceId: undefined,
        ResourceType: undefined,
        Value: undefined
    };
    if (output["key"] !== undefined) {
        contents.Key = output["key"];
    }
    if (output["resourceId"] !== undefined) {
        contents.ResourceId = output["resourceId"];
    }
    if (output["resourceType"] !== undefined) {
        contents.ResourceType = output["resourceType"];
    }
    if (output["value"] !== undefined) {
        contents.Value = output["value"];
    }
    return contents;
};
const deserializeAws_ec2TagDescriptionList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2TagDescription(entry, context));
    });
    return contents;
};
const deserializeAws_ec2TagList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2Tag(entry, context));
    });
    return contents;
};
const deserializeAws_ec2TargetCapacitySpecification = (output, context) => {
    let contents = {
        __type: "TargetCapacitySpecification",
        DefaultTargetCapacityType: undefined,
        OnDemandTargetCapacity: undefined,
        SpotTargetCapacity: undefined,
        TotalTargetCapacity: undefined
    };
    if (output["defaultTargetCapacityType"] !== undefined) {
        contents.DefaultTargetCapacityType = output["defaultTargetCapacityType"];
    }
    if (output["onDemandTargetCapacity"] !== undefined) {
        contents.OnDemandTargetCapacity = parseInt(output["onDemandTargetCapacity"]);
    }
    if (output["spotTargetCapacity"] !== undefined) {
        contents.SpotTargetCapacity = parseInt(output["spotTargetCapacity"]);
    }
    if (output["totalTargetCapacity"] !== undefined) {
        contents.TotalTargetCapacity = parseInt(output["totalTargetCapacity"]);
    }
    return contents;
};
const deserializeAws_ec2TargetConfiguration = (output, context) => {
    let contents = {
        __type: "TargetConfiguration",
        InstanceCount: undefined,
        OfferingId: undefined
    };
    if (output["instanceCount"] !== undefined) {
        contents.InstanceCount = parseInt(output["instanceCount"]);
    }
    if (output["offeringId"] !== undefined) {
        contents.OfferingId = output["offeringId"];
    }
    return contents;
};
const deserializeAws_ec2TargetGroup = (output, context) => {
    let contents = {
        __type: "TargetGroup",
        Arn: undefined
    };
    if (output["arn"] !== undefined) {
        contents.Arn = output["arn"];
    }
    return contents;
};
const deserializeAws_ec2TargetGroups = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2TargetGroup(entry, context));
    });
    return contents;
};
const deserializeAws_ec2TargetGroupsConfig = (output, context) => {
    let contents = {
        __type: "TargetGroupsConfig",
        TargetGroups: undefined
    };
    if (output.targetGroups === "") {
        contents.TargetGroups = [];
    }
    if (output["targetGroups"] !== undefined &&
        output["targetGroups"]["item"] !== undefined) {
        const wrappedItem = output["targetGroups"]["item"] instanceof Array
            ? output["targetGroups"]["item"]
            : [output["targetGroups"]["item"]];
        contents.TargetGroups = deserializeAws_ec2TargetGroups(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2TargetNetwork = (output, context) => {
    let contents = {
        __type: "TargetNetwork",
        AssociationId: undefined,
        ClientVpnEndpointId: undefined,
        SecurityGroups: undefined,
        Status: undefined,
        TargetNetworkId: undefined,
        VpcId: undefined
    };
    if (output["associationId"] !== undefined) {
        contents.AssociationId = output["associationId"];
    }
    if (output["clientVpnEndpointId"] !== undefined) {
        contents.ClientVpnEndpointId = output["clientVpnEndpointId"];
    }
    if (output.securityGroups === "") {
        contents.SecurityGroups = [];
    }
    if (output["securityGroups"] !== undefined &&
        output["securityGroups"]["item"] !== undefined) {
        const wrappedItem = output["securityGroups"]["item"] instanceof Array
            ? output["securityGroups"]["item"]
            : [output["securityGroups"]["item"]];
        contents.SecurityGroups = deserializeAws_ec2ValueStringList(wrappedItem, context);
    }
    if (output["status"] !== undefined) {
        contents.Status = deserializeAws_ec2AssociationStatus(output["status"], context);
    }
    if (output["targetNetworkId"] !== undefined) {
        contents.TargetNetworkId = output["targetNetworkId"];
    }
    if (output["vpcId"] !== undefined) {
        contents.VpcId = output["vpcId"];
    }
    return contents;
};
const deserializeAws_ec2TargetNetworkSet = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2TargetNetwork(entry, context));
    });
    return contents;
};
const deserializeAws_ec2TargetReservationValue = (output, context) => {
    let contents = {
        __type: "TargetReservationValue",
        ReservationValue: undefined,
        TargetConfiguration: undefined
    };
    if (output["reservationValue"] !== undefined) {
        contents.ReservationValue = deserializeAws_ec2ReservationValue(output["reservationValue"], context);
    }
    if (output["targetConfiguration"] !== undefined) {
        contents.TargetConfiguration = deserializeAws_ec2TargetConfiguration(output["targetConfiguration"], context);
    }
    return contents;
};
const deserializeAws_ec2TargetReservationValueSet = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2TargetReservationValue(entry, context));
    });
    return contents;
};
const deserializeAws_ec2TerminateClientVpnConnectionsResult = (output, context) => {
    let contents = {
        __type: "TerminateClientVpnConnectionsResult",
        ClientVpnEndpointId: undefined,
        ConnectionStatuses: undefined,
        Username: undefined
    };
    if (output["clientVpnEndpointId"] !== undefined) {
        contents.ClientVpnEndpointId = output["clientVpnEndpointId"];
    }
    if (output.connectionStatuses === "") {
        contents.ConnectionStatuses = [];
    }
    if (output["connectionStatuses"] !== undefined &&
        output["connectionStatuses"]["item"] !== undefined) {
        const wrappedItem = output["connectionStatuses"]["item"] instanceof Array
            ? output["connectionStatuses"]["item"]
            : [output["connectionStatuses"]["item"]];
        contents.ConnectionStatuses = deserializeAws_ec2TerminateConnectionStatusSet(wrappedItem, context);
    }
    if (output["username"] !== undefined) {
        contents.Username = output["username"];
    }
    return contents;
};
const deserializeAws_ec2TerminateConnectionStatus = (output, context) => {
    let contents = {
        __type: "TerminateConnectionStatus",
        ConnectionId: undefined,
        CurrentStatus: undefined,
        PreviousStatus: undefined
    };
    if (output["connectionId"] !== undefined) {
        contents.ConnectionId = output["connectionId"];
    }
    if (output["currentStatus"] !== undefined) {
        contents.CurrentStatus = deserializeAws_ec2ClientVpnConnectionStatus(output["currentStatus"], context);
    }
    if (output["previousStatus"] !== undefined) {
        contents.PreviousStatus = deserializeAws_ec2ClientVpnConnectionStatus(output["previousStatus"], context);
    }
    return contents;
};
const deserializeAws_ec2TerminateConnectionStatusSet = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2TerminateConnectionStatus(entry, context));
    });
    return contents;
};
const deserializeAws_ec2TerminateInstancesResult = (output, context) => {
    let contents = {
        __type: "TerminateInstancesResult",
        TerminatingInstances: undefined
    };
    if (output.instancesSet === "") {
        contents.TerminatingInstances = [];
    }
    if (output["instancesSet"] !== undefined &&
        output["instancesSet"]["item"] !== undefined) {
        const wrappedItem = output["instancesSet"]["item"] instanceof Array
            ? output["instancesSet"]["item"]
            : [output["instancesSet"]["item"]];
        contents.TerminatingInstances = deserializeAws_ec2InstanceStateChangeList(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2ThreadsPerCoreList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(parseInt(entry));
    });
    return contents;
};
const deserializeAws_ec2TrafficMirrorFilter = (output, context) => {
    let contents = {
        __type: "TrafficMirrorFilter",
        Description: undefined,
        EgressFilterRules: undefined,
        IngressFilterRules: undefined,
        NetworkServices: undefined,
        Tags: undefined,
        TrafficMirrorFilterId: undefined
    };
    if (output["description"] !== undefined) {
        contents.Description = output["description"];
    }
    if (output.egressFilterRuleSet === "") {
        contents.EgressFilterRules = [];
    }
    if (output["egressFilterRuleSet"] !== undefined &&
        output["egressFilterRuleSet"]["item"] !== undefined) {
        const wrappedItem = output["egressFilterRuleSet"]["item"] instanceof Array
            ? output["egressFilterRuleSet"]["item"]
            : [output["egressFilterRuleSet"]["item"]];
        contents.EgressFilterRules = deserializeAws_ec2TrafficMirrorFilterRuleList(wrappedItem, context);
    }
    if (output.ingressFilterRuleSet === "") {
        contents.IngressFilterRules = [];
    }
    if (output["ingressFilterRuleSet"] !== undefined &&
        output["ingressFilterRuleSet"]["item"] !== undefined) {
        const wrappedItem = output["ingressFilterRuleSet"]["item"] instanceof Array
            ? output["ingressFilterRuleSet"]["item"]
            : [output["ingressFilterRuleSet"]["item"]];
        contents.IngressFilterRules = deserializeAws_ec2TrafficMirrorFilterRuleList(wrappedItem, context);
    }
    if (output.networkServiceSet === "") {
        contents.NetworkServices = [];
    }
    if (output["networkServiceSet"] !== undefined &&
        output["networkServiceSet"]["item"] !== undefined) {
        const wrappedItem = output["networkServiceSet"]["item"] instanceof Array
            ? output["networkServiceSet"]["item"]
            : [output["networkServiceSet"]["item"]];
        contents.NetworkServices = deserializeAws_ec2TrafficMirrorNetworkServiceList(wrappedItem, context);
    }
    if (output.tagSet === "") {
        contents.Tags = [];
    }
    if (output["tagSet"] !== undefined &&
        output["tagSet"]["item"] !== undefined) {
        const wrappedItem = output["tagSet"]["item"] instanceof Array
            ? output["tagSet"]["item"]
            : [output["tagSet"]["item"]];
        contents.Tags = deserializeAws_ec2TagList(wrappedItem, context);
    }
    if (output["trafficMirrorFilterId"] !== undefined) {
        contents.TrafficMirrorFilterId = output["trafficMirrorFilterId"];
    }
    return contents;
};
const deserializeAws_ec2TrafficMirrorFilterRule = (output, context) => {
    let contents = {
        __type: "TrafficMirrorFilterRule",
        Description: undefined,
        DestinationCidrBlock: undefined,
        DestinationPortRange: undefined,
        Protocol: undefined,
        RuleAction: undefined,
        RuleNumber: undefined,
        SourceCidrBlock: undefined,
        SourcePortRange: undefined,
        TrafficDirection: undefined,
        TrafficMirrorFilterId: undefined,
        TrafficMirrorFilterRuleId: undefined
    };
    if (output["description"] !== undefined) {
        contents.Description = output["description"];
    }
    if (output["destinationCidrBlock"] !== undefined) {
        contents.DestinationCidrBlock = output["destinationCidrBlock"];
    }
    if (output["destinationPortRange"] !== undefined) {
        contents.DestinationPortRange = deserializeAws_ec2TrafficMirrorPortRange(output["destinationPortRange"], context);
    }
    if (output["protocol"] !== undefined) {
        contents.Protocol = parseInt(output["protocol"]);
    }
    if (output["ruleAction"] !== undefined) {
        contents.RuleAction = output["ruleAction"];
    }
    if (output["ruleNumber"] !== undefined) {
        contents.RuleNumber = parseInt(output["ruleNumber"]);
    }
    if (output["sourceCidrBlock"] !== undefined) {
        contents.SourceCidrBlock = output["sourceCidrBlock"];
    }
    if (output["sourcePortRange"] !== undefined) {
        contents.SourcePortRange = deserializeAws_ec2TrafficMirrorPortRange(output["sourcePortRange"], context);
    }
    if (output["trafficDirection"] !== undefined) {
        contents.TrafficDirection = output["trafficDirection"];
    }
    if (output["trafficMirrorFilterId"] !== undefined) {
        contents.TrafficMirrorFilterId = output["trafficMirrorFilterId"];
    }
    if (output["trafficMirrorFilterRuleId"] !== undefined) {
        contents.TrafficMirrorFilterRuleId = output["trafficMirrorFilterRuleId"];
    }
    return contents;
};
const deserializeAws_ec2TrafficMirrorFilterRuleList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2TrafficMirrorFilterRule(entry, context));
    });
    return contents;
};
const deserializeAws_ec2TrafficMirrorFilterSet = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2TrafficMirrorFilter(entry, context));
    });
    return contents;
};
const deserializeAws_ec2TrafficMirrorNetworkServiceList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(entry);
    });
    return contents;
};
const deserializeAws_ec2TrafficMirrorPortRange = (output, context) => {
    let contents = {
        __type: "TrafficMirrorPortRange",
        FromPort: undefined,
        ToPort: undefined
    };
    if (output["fromPort"] !== undefined) {
        contents.FromPort = parseInt(output["fromPort"]);
    }
    if (output["toPort"] !== undefined) {
        contents.ToPort = parseInt(output["toPort"]);
    }
    return contents;
};
const deserializeAws_ec2TrafficMirrorSession = (output, context) => {
    let contents = {
        __type: "TrafficMirrorSession",
        Description: undefined,
        NetworkInterfaceId: undefined,
        OwnerId: undefined,
        PacketLength: undefined,
        SessionNumber: undefined,
        Tags: undefined,
        TrafficMirrorFilterId: undefined,
        TrafficMirrorSessionId: undefined,
        TrafficMirrorTargetId: undefined,
        VirtualNetworkId: undefined
    };
    if (output["description"] !== undefined) {
        contents.Description = output["description"];
    }
    if (output["networkInterfaceId"] !== undefined) {
        contents.NetworkInterfaceId = output["networkInterfaceId"];
    }
    if (output["ownerId"] !== undefined) {
        contents.OwnerId = output["ownerId"];
    }
    if (output["packetLength"] !== undefined) {
        contents.PacketLength = parseInt(output["packetLength"]);
    }
    if (output["sessionNumber"] !== undefined) {
        contents.SessionNumber = parseInt(output["sessionNumber"]);
    }
    if (output.tagSet === "") {
        contents.Tags = [];
    }
    if (output["tagSet"] !== undefined &&
        output["tagSet"]["item"] !== undefined) {
        const wrappedItem = output["tagSet"]["item"] instanceof Array
            ? output["tagSet"]["item"]
            : [output["tagSet"]["item"]];
        contents.Tags = deserializeAws_ec2TagList(wrappedItem, context);
    }
    if (output["trafficMirrorFilterId"] !== undefined) {
        contents.TrafficMirrorFilterId = output["trafficMirrorFilterId"];
    }
    if (output["trafficMirrorSessionId"] !== undefined) {
        contents.TrafficMirrorSessionId = output["trafficMirrorSessionId"];
    }
    if (output["trafficMirrorTargetId"] !== undefined) {
        contents.TrafficMirrorTargetId = output["trafficMirrorTargetId"];
    }
    if (output["virtualNetworkId"] !== undefined) {
        contents.VirtualNetworkId = parseInt(output["virtualNetworkId"]);
    }
    return contents;
};
const deserializeAws_ec2TrafficMirrorSessionSet = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2TrafficMirrorSession(entry, context));
    });
    return contents;
};
const deserializeAws_ec2TrafficMirrorTarget = (output, context) => {
    let contents = {
        __type: "TrafficMirrorTarget",
        Description: undefined,
        NetworkInterfaceId: undefined,
        NetworkLoadBalancerArn: undefined,
        OwnerId: undefined,
        Tags: undefined,
        TrafficMirrorTargetId: undefined,
        Type: undefined
    };
    if (output["description"] !== undefined) {
        contents.Description = output["description"];
    }
    if (output["networkInterfaceId"] !== undefined) {
        contents.NetworkInterfaceId = output["networkInterfaceId"];
    }
    if (output["networkLoadBalancerArn"] !== undefined) {
        contents.NetworkLoadBalancerArn = output["networkLoadBalancerArn"];
    }
    if (output["ownerId"] !== undefined) {
        contents.OwnerId = output["ownerId"];
    }
    if (output.tagSet === "") {
        contents.Tags = [];
    }
    if (output["tagSet"] !== undefined &&
        output["tagSet"]["item"] !== undefined) {
        const wrappedItem = output["tagSet"]["item"] instanceof Array
            ? output["tagSet"]["item"]
            : [output["tagSet"]["item"]];
        contents.Tags = deserializeAws_ec2TagList(wrappedItem, context);
    }
    if (output["trafficMirrorTargetId"] !== undefined) {
        contents.TrafficMirrorTargetId = output["trafficMirrorTargetId"];
    }
    if (output["type"] !== undefined) {
        contents.Type = output["type"];
    }
    return contents;
};
const deserializeAws_ec2TrafficMirrorTargetSet = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2TrafficMirrorTarget(entry, context));
    });
    return contents;
};
const deserializeAws_ec2TransitGateway = (output, context) => {
    let contents = {
        __type: "TransitGateway",
        CreationTime: undefined,
        Description: undefined,
        Options: undefined,
        OwnerId: undefined,
        State: undefined,
        Tags: undefined,
        TransitGatewayArn: undefined,
        TransitGatewayId: undefined
    };
    if (output["creationTime"] !== undefined) {
        contents.CreationTime = new Date(output["creationTime"]);
    }
    if (output["description"] !== undefined) {
        contents.Description = output["description"];
    }
    if (output["options"] !== undefined) {
        contents.Options = deserializeAws_ec2TransitGatewayOptions(output["options"], context);
    }
    if (output["ownerId"] !== undefined) {
        contents.OwnerId = output["ownerId"];
    }
    if (output["state"] !== undefined) {
        contents.State = output["state"];
    }
    if (output.tagSet === "") {
        contents.Tags = [];
    }
    if (output["tagSet"] !== undefined &&
        output["tagSet"]["item"] !== undefined) {
        const wrappedItem = output["tagSet"]["item"] instanceof Array
            ? output["tagSet"]["item"]
            : [output["tagSet"]["item"]];
        contents.Tags = deserializeAws_ec2TagList(wrappedItem, context);
    }
    if (output["transitGatewayArn"] !== undefined) {
        contents.TransitGatewayArn = output["transitGatewayArn"];
    }
    if (output["transitGatewayId"] !== undefined) {
        contents.TransitGatewayId = output["transitGatewayId"];
    }
    return contents;
};
const deserializeAws_ec2TransitGatewayAssociation = (output, context) => {
    let contents = {
        __type: "TransitGatewayAssociation",
        ResourceId: undefined,
        ResourceType: undefined,
        State: undefined,
        TransitGatewayAttachmentId: undefined,
        TransitGatewayRouteTableId: undefined
    };
    if (output["resourceId"] !== undefined) {
        contents.ResourceId = output["resourceId"];
    }
    if (output["resourceType"] !== undefined) {
        contents.ResourceType = output["resourceType"];
    }
    if (output["state"] !== undefined) {
        contents.State = output["state"];
    }
    if (output["transitGatewayAttachmentId"] !== undefined) {
        contents.TransitGatewayAttachmentId = output["transitGatewayAttachmentId"];
    }
    if (output["transitGatewayRouteTableId"] !== undefined) {
        contents.TransitGatewayRouteTableId = output["transitGatewayRouteTableId"];
    }
    return contents;
};
const deserializeAws_ec2TransitGatewayAttachment = (output, context) => {
    let contents = {
        __type: "TransitGatewayAttachment",
        Association: undefined,
        CreationTime: undefined,
        ResourceId: undefined,
        ResourceOwnerId: undefined,
        ResourceType: undefined,
        State: undefined,
        Tags: undefined,
        TransitGatewayAttachmentId: undefined,
        TransitGatewayId: undefined,
        TransitGatewayOwnerId: undefined
    };
    if (output["association"] !== undefined) {
        contents.Association = deserializeAws_ec2TransitGatewayAttachmentAssociation(output["association"], context);
    }
    if (output["creationTime"] !== undefined) {
        contents.CreationTime = new Date(output["creationTime"]);
    }
    if (output["resourceId"] !== undefined) {
        contents.ResourceId = output["resourceId"];
    }
    if (output["resourceOwnerId"] !== undefined) {
        contents.ResourceOwnerId = output["resourceOwnerId"];
    }
    if (output["resourceType"] !== undefined) {
        contents.ResourceType = output["resourceType"];
    }
    if (output["state"] !== undefined) {
        contents.State = output["state"];
    }
    if (output.tagSet === "") {
        contents.Tags = [];
    }
    if (output["tagSet"] !== undefined &&
        output["tagSet"]["item"] !== undefined) {
        const wrappedItem = output["tagSet"]["item"] instanceof Array
            ? output["tagSet"]["item"]
            : [output["tagSet"]["item"]];
        contents.Tags = deserializeAws_ec2TagList(wrappedItem, context);
    }
    if (output["transitGatewayAttachmentId"] !== undefined) {
        contents.TransitGatewayAttachmentId = output["transitGatewayAttachmentId"];
    }
    if (output["transitGatewayId"] !== undefined) {
        contents.TransitGatewayId = output["transitGatewayId"];
    }
    if (output["transitGatewayOwnerId"] !== undefined) {
        contents.TransitGatewayOwnerId = output["transitGatewayOwnerId"];
    }
    return contents;
};
const deserializeAws_ec2TransitGatewayAttachmentAssociation = (output, context) => {
    let contents = {
        __type: "TransitGatewayAttachmentAssociation",
        State: undefined,
        TransitGatewayRouteTableId: undefined
    };
    if (output["state"] !== undefined) {
        contents.State = output["state"];
    }
    if (output["transitGatewayRouteTableId"] !== undefined) {
        contents.TransitGatewayRouteTableId = output["transitGatewayRouteTableId"];
    }
    return contents;
};
const deserializeAws_ec2TransitGatewayAttachmentList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2TransitGatewayAttachment(entry, context));
    });
    return contents;
};
const deserializeAws_ec2TransitGatewayAttachmentPropagation = (output, context) => {
    let contents = {
        __type: "TransitGatewayAttachmentPropagation",
        State: undefined,
        TransitGatewayRouteTableId: undefined
    };
    if (output["state"] !== undefined) {
        contents.State = output["state"];
    }
    if (output["transitGatewayRouteTableId"] !== undefined) {
        contents.TransitGatewayRouteTableId = output["transitGatewayRouteTableId"];
    }
    return contents;
};
const deserializeAws_ec2TransitGatewayAttachmentPropagationList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2TransitGatewayAttachmentPropagation(entry, context));
    });
    return contents;
};
const deserializeAws_ec2TransitGatewayList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2TransitGateway(entry, context));
    });
    return contents;
};
const deserializeAws_ec2TransitGatewayMulticastDeregisteredGroupMembers = (output, context) => {
    let contents = {
        __type: "TransitGatewayMulticastDeregisteredGroupMembers",
        DeregisteredNetworkInterfaceIds: undefined,
        GroupIpAddress: undefined,
        TransitGatewayMulticastDomainId: undefined
    };
    if (output.deregisteredNetworkInterfaceIds === "") {
        contents.DeregisteredNetworkInterfaceIds = [];
    }
    if (output["deregisteredNetworkInterfaceIds"] !== undefined &&
        output["deregisteredNetworkInterfaceIds"]["item"] !== undefined) {
        const wrappedItem = output["deregisteredNetworkInterfaceIds"]["item"] instanceof Array
            ? output["deregisteredNetworkInterfaceIds"]["item"]
            : [output["deregisteredNetworkInterfaceIds"]["item"]];
        contents.DeregisteredNetworkInterfaceIds = deserializeAws_ec2ValueStringList(wrappedItem, context);
    }
    if (output["groupIpAddress"] !== undefined) {
        contents.GroupIpAddress = output["groupIpAddress"];
    }
    if (output["transitGatewayMulticastDomainId"] !== undefined) {
        contents.TransitGatewayMulticastDomainId =
            output["transitGatewayMulticastDomainId"];
    }
    return contents;
};
const deserializeAws_ec2TransitGatewayMulticastDeregisteredGroupSources = (output, context) => {
    let contents = {
        __type: "TransitGatewayMulticastDeregisteredGroupSources",
        DeregisteredNetworkInterfaceIds: undefined,
        GroupIpAddress: undefined,
        TransitGatewayMulticastDomainId: undefined
    };
    if (output.deregisteredNetworkInterfaceIds === "") {
        contents.DeregisteredNetworkInterfaceIds = [];
    }
    if (output["deregisteredNetworkInterfaceIds"] !== undefined &&
        output["deregisteredNetworkInterfaceIds"]["item"] !== undefined) {
        const wrappedItem = output["deregisteredNetworkInterfaceIds"]["item"] instanceof Array
            ? output["deregisteredNetworkInterfaceIds"]["item"]
            : [output["deregisteredNetworkInterfaceIds"]["item"]];
        contents.DeregisteredNetworkInterfaceIds = deserializeAws_ec2ValueStringList(wrappedItem, context);
    }
    if (output["groupIpAddress"] !== undefined) {
        contents.GroupIpAddress = output["groupIpAddress"];
    }
    if (output["transitGatewayMulticastDomainId"] !== undefined) {
        contents.TransitGatewayMulticastDomainId =
            output["transitGatewayMulticastDomainId"];
    }
    return contents;
};
const deserializeAws_ec2TransitGatewayMulticastDomain = (output, context) => {
    let contents = {
        __type: "TransitGatewayMulticastDomain",
        CreationTime: undefined,
        State: undefined,
        Tags: undefined,
        TransitGatewayId: undefined,
        TransitGatewayMulticastDomainId: undefined
    };
    if (output["creationTime"] !== undefined) {
        contents.CreationTime = new Date(output["creationTime"]);
    }
    if (output["state"] !== undefined) {
        contents.State = output["state"];
    }
    if (output.tagSet === "") {
        contents.Tags = [];
    }
    if (output["tagSet"] !== undefined &&
        output["tagSet"]["item"] !== undefined) {
        const wrappedItem = output["tagSet"]["item"] instanceof Array
            ? output["tagSet"]["item"]
            : [output["tagSet"]["item"]];
        contents.Tags = deserializeAws_ec2TagList(wrappedItem, context);
    }
    if (output["transitGatewayId"] !== undefined) {
        contents.TransitGatewayId = output["transitGatewayId"];
    }
    if (output["transitGatewayMulticastDomainId"] !== undefined) {
        contents.TransitGatewayMulticastDomainId =
            output["transitGatewayMulticastDomainId"];
    }
    return contents;
};
const deserializeAws_ec2TransitGatewayMulticastDomainAssociation = (output, context) => {
    let contents = {
        __type: "TransitGatewayMulticastDomainAssociation",
        ResourceId: undefined,
        ResourceType: undefined,
        Subnet: undefined,
        TransitGatewayAttachmentId: undefined
    };
    if (output["resourceId"] !== undefined) {
        contents.ResourceId = output["resourceId"];
    }
    if (output["resourceType"] !== undefined) {
        contents.ResourceType = output["resourceType"];
    }
    if (output["subnet"] !== undefined) {
        contents.Subnet = deserializeAws_ec2SubnetAssociation(output["subnet"], context);
    }
    if (output["transitGatewayAttachmentId"] !== undefined) {
        contents.TransitGatewayAttachmentId = output["transitGatewayAttachmentId"];
    }
    return contents;
};
const deserializeAws_ec2TransitGatewayMulticastDomainAssociationList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2TransitGatewayMulticastDomainAssociation(entry, context));
    });
    return contents;
};
const deserializeAws_ec2TransitGatewayMulticastDomainAssociations = (output, context) => {
    let contents = {
        __type: "TransitGatewayMulticastDomainAssociations",
        ResourceId: undefined,
        ResourceType: undefined,
        Subnets: undefined,
        TransitGatewayAttachmentId: undefined,
        TransitGatewayMulticastDomainId: undefined
    };
    if (output["resourceId"] !== undefined) {
        contents.ResourceId = output["resourceId"];
    }
    if (output["resourceType"] !== undefined) {
        contents.ResourceType = output["resourceType"];
    }
    if (output.subnets === "") {
        contents.Subnets = [];
    }
    if (output["subnets"] !== undefined &&
        output["subnets"]["item"] !== undefined) {
        const wrappedItem = output["subnets"]["item"] instanceof Array
            ? output["subnets"]["item"]
            : [output["subnets"]["item"]];
        contents.Subnets = deserializeAws_ec2SubnetAssociationList(wrappedItem, context);
    }
    if (output["transitGatewayAttachmentId"] !== undefined) {
        contents.TransitGatewayAttachmentId = output["transitGatewayAttachmentId"];
    }
    if (output["transitGatewayMulticastDomainId"] !== undefined) {
        contents.TransitGatewayMulticastDomainId =
            output["transitGatewayMulticastDomainId"];
    }
    return contents;
};
const deserializeAws_ec2TransitGatewayMulticastDomainList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2TransitGatewayMulticastDomain(entry, context));
    });
    return contents;
};
const deserializeAws_ec2TransitGatewayMulticastGroup = (output, context) => {
    let contents = {
        __type: "TransitGatewayMulticastGroup",
        GroupIpAddress: undefined,
        GroupMember: undefined,
        GroupSource: undefined,
        MemberType: undefined,
        NetworkInterfaceId: undefined,
        ResourceId: undefined,
        ResourceType: undefined,
        SourceType: undefined,
        SubnetId: undefined,
        TransitGatewayAttachmentId: undefined
    };
    if (output["groupIpAddress"] !== undefined) {
        contents.GroupIpAddress = output["groupIpAddress"];
    }
    if (output["groupMember"] !== undefined) {
        contents.GroupMember = output["groupMember"] == "true";
    }
    if (output["groupSource"] !== undefined) {
        contents.GroupSource = output["groupSource"] == "true";
    }
    if (output["memberType"] !== undefined) {
        contents.MemberType = output["memberType"];
    }
    if (output["networkInterfaceId"] !== undefined) {
        contents.NetworkInterfaceId = output["networkInterfaceId"];
    }
    if (output["resourceId"] !== undefined) {
        contents.ResourceId = output["resourceId"];
    }
    if (output["resourceType"] !== undefined) {
        contents.ResourceType = output["resourceType"];
    }
    if (output["sourceType"] !== undefined) {
        contents.SourceType = output["sourceType"];
    }
    if (output["subnetId"] !== undefined) {
        contents.SubnetId = output["subnetId"];
    }
    if (output["transitGatewayAttachmentId"] !== undefined) {
        contents.TransitGatewayAttachmentId = output["transitGatewayAttachmentId"];
    }
    return contents;
};
const deserializeAws_ec2TransitGatewayMulticastGroupList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2TransitGatewayMulticastGroup(entry, context));
    });
    return contents;
};
const deserializeAws_ec2TransitGatewayMulticastRegisteredGroupMembers = (output, context) => {
    let contents = {
        __type: "TransitGatewayMulticastRegisteredGroupMembers",
        GroupIpAddress: undefined,
        RegisteredNetworkInterfaceIds: undefined,
        TransitGatewayMulticastDomainId: undefined
    };
    if (output["groupIpAddress"] !== undefined) {
        contents.GroupIpAddress = output["groupIpAddress"];
    }
    if (output.registeredNetworkInterfaceIds === "") {
        contents.RegisteredNetworkInterfaceIds = [];
    }
    if (output["registeredNetworkInterfaceIds"] !== undefined &&
        output["registeredNetworkInterfaceIds"]["item"] !== undefined) {
        const wrappedItem = output["registeredNetworkInterfaceIds"]["item"] instanceof Array
            ? output["registeredNetworkInterfaceIds"]["item"]
            : [output["registeredNetworkInterfaceIds"]["item"]];
        contents.RegisteredNetworkInterfaceIds = deserializeAws_ec2ValueStringList(wrappedItem, context);
    }
    if (output["transitGatewayMulticastDomainId"] !== undefined) {
        contents.TransitGatewayMulticastDomainId =
            output["transitGatewayMulticastDomainId"];
    }
    return contents;
};
const deserializeAws_ec2TransitGatewayMulticastRegisteredGroupSources = (output, context) => {
    let contents = {
        __type: "TransitGatewayMulticastRegisteredGroupSources",
        GroupIpAddress: undefined,
        RegisteredNetworkInterfaceIds: undefined,
        TransitGatewayMulticastDomainId: undefined
    };
    if (output["groupIpAddress"] !== undefined) {
        contents.GroupIpAddress = output["groupIpAddress"];
    }
    if (output.registeredNetworkInterfaceIds === "") {
        contents.RegisteredNetworkInterfaceIds = [];
    }
    if (output["registeredNetworkInterfaceIds"] !== undefined &&
        output["registeredNetworkInterfaceIds"]["item"] !== undefined) {
        const wrappedItem = output["registeredNetworkInterfaceIds"]["item"] instanceof Array
            ? output["registeredNetworkInterfaceIds"]["item"]
            : [output["registeredNetworkInterfaceIds"]["item"]];
        contents.RegisteredNetworkInterfaceIds = deserializeAws_ec2ValueStringList(wrappedItem, context);
    }
    if (output["transitGatewayMulticastDomainId"] !== undefined) {
        contents.TransitGatewayMulticastDomainId =
            output["transitGatewayMulticastDomainId"];
    }
    return contents;
};
const deserializeAws_ec2TransitGatewayOptions = (output, context) => {
    let contents = {
        __type: "TransitGatewayOptions",
        AmazonSideAsn: undefined,
        AssociationDefaultRouteTableId: undefined,
        AutoAcceptSharedAttachments: undefined,
        DefaultRouteTableAssociation: undefined,
        DefaultRouteTablePropagation: undefined,
        DnsSupport: undefined,
        MulticastSupport: undefined,
        PropagationDefaultRouteTableId: undefined,
        VpnEcmpSupport: undefined
    };
    if (output["amazonSideAsn"] !== undefined) {
        contents.AmazonSideAsn = parseInt(output["amazonSideAsn"]);
    }
    if (output["associationDefaultRouteTableId"] !== undefined) {
        contents.AssociationDefaultRouteTableId =
            output["associationDefaultRouteTableId"];
    }
    if (output["autoAcceptSharedAttachments"] !== undefined) {
        contents.AutoAcceptSharedAttachments =
            output["autoAcceptSharedAttachments"];
    }
    if (output["defaultRouteTableAssociation"] !== undefined) {
        contents.DefaultRouteTableAssociation =
            output["defaultRouteTableAssociation"];
    }
    if (output["defaultRouteTablePropagation"] !== undefined) {
        contents.DefaultRouteTablePropagation =
            output["defaultRouteTablePropagation"];
    }
    if (output["dnsSupport"] !== undefined) {
        contents.DnsSupport = output["dnsSupport"];
    }
    if (output["multicastSupport"] !== undefined) {
        contents.MulticastSupport = output["multicastSupport"];
    }
    if (output["propagationDefaultRouteTableId"] !== undefined) {
        contents.PropagationDefaultRouteTableId =
            output["propagationDefaultRouteTableId"];
    }
    if (output["vpnEcmpSupport"] !== undefined) {
        contents.VpnEcmpSupport = output["vpnEcmpSupport"];
    }
    return contents;
};
const deserializeAws_ec2TransitGatewayPeeringAttachment = (output, context) => {
    let contents = {
        __type: "TransitGatewayPeeringAttachment",
        AccepterTgwInfo: undefined,
        CreationTime: undefined,
        RequesterTgwInfo: undefined,
        State: undefined,
        Status: undefined,
        Tags: undefined,
        TransitGatewayAttachmentId: undefined
    };
    if (output["accepterTgwInfo"] !== undefined) {
        contents.AccepterTgwInfo = deserializeAws_ec2PeeringTgwInfo(output["accepterTgwInfo"], context);
    }
    if (output["creationTime"] !== undefined) {
        contents.CreationTime = new Date(output["creationTime"]);
    }
    if (output["requesterTgwInfo"] !== undefined) {
        contents.RequesterTgwInfo = deserializeAws_ec2PeeringTgwInfo(output["requesterTgwInfo"], context);
    }
    if (output["state"] !== undefined) {
        contents.State = output["state"];
    }
    if (output["status"] !== undefined) {
        contents.Status = deserializeAws_ec2PeeringAttachmentStatus(output["status"], context);
    }
    if (output.tagSet === "") {
        contents.Tags = [];
    }
    if (output["tagSet"] !== undefined &&
        output["tagSet"]["item"] !== undefined) {
        const wrappedItem = output["tagSet"]["item"] instanceof Array
            ? output["tagSet"]["item"]
            : [output["tagSet"]["item"]];
        contents.Tags = deserializeAws_ec2TagList(wrappedItem, context);
    }
    if (output["transitGatewayAttachmentId"] !== undefined) {
        contents.TransitGatewayAttachmentId = output["transitGatewayAttachmentId"];
    }
    return contents;
};
const deserializeAws_ec2TransitGatewayPeeringAttachmentList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2TransitGatewayPeeringAttachment(entry, context));
    });
    return contents;
};
const deserializeAws_ec2TransitGatewayPropagation = (output, context) => {
    let contents = {
        __type: "TransitGatewayPropagation",
        ResourceId: undefined,
        ResourceType: undefined,
        State: undefined,
        TransitGatewayAttachmentId: undefined,
        TransitGatewayRouteTableId: undefined
    };
    if (output["resourceId"] !== undefined) {
        contents.ResourceId = output["resourceId"];
    }
    if (output["resourceType"] !== undefined) {
        contents.ResourceType = output["resourceType"];
    }
    if (output["state"] !== undefined) {
        contents.State = output["state"];
    }
    if (output["transitGatewayAttachmentId"] !== undefined) {
        contents.TransitGatewayAttachmentId = output["transitGatewayAttachmentId"];
    }
    if (output["transitGatewayRouteTableId"] !== undefined) {
        contents.TransitGatewayRouteTableId = output["transitGatewayRouteTableId"];
    }
    return contents;
};
const deserializeAws_ec2TransitGatewayRoute = (output, context) => {
    let contents = {
        __type: "TransitGatewayRoute",
        DestinationCidrBlock: undefined,
        State: undefined,
        TransitGatewayAttachments: undefined,
        Type: undefined
    };
    if (output["destinationCidrBlock"] !== undefined) {
        contents.DestinationCidrBlock = output["destinationCidrBlock"];
    }
    if (output["state"] !== undefined) {
        contents.State = output["state"];
    }
    if (output.transitGatewayAttachments === "") {
        contents.TransitGatewayAttachments = [];
    }
    if (output["transitGatewayAttachments"] !== undefined &&
        output["transitGatewayAttachments"]["item"] !== undefined) {
        const wrappedItem = output["transitGatewayAttachments"]["item"] instanceof Array
            ? output["transitGatewayAttachments"]["item"]
            : [output["transitGatewayAttachments"]["item"]];
        contents.TransitGatewayAttachments = deserializeAws_ec2TransitGatewayRouteAttachmentList(wrappedItem, context);
    }
    if (output["type"] !== undefined) {
        contents.Type = output["type"];
    }
    return contents;
};
const deserializeAws_ec2TransitGatewayRouteAttachment = (output, context) => {
    let contents = {
        __type: "TransitGatewayRouteAttachment",
        ResourceId: undefined,
        ResourceType: undefined,
        TransitGatewayAttachmentId: undefined
    };
    if (output["resourceId"] !== undefined) {
        contents.ResourceId = output["resourceId"];
    }
    if (output["resourceType"] !== undefined) {
        contents.ResourceType = output["resourceType"];
    }
    if (output["transitGatewayAttachmentId"] !== undefined) {
        contents.TransitGatewayAttachmentId = output["transitGatewayAttachmentId"];
    }
    return contents;
};
const deserializeAws_ec2TransitGatewayRouteAttachmentList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2TransitGatewayRouteAttachment(entry, context));
    });
    return contents;
};
const deserializeAws_ec2TransitGatewayRouteList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2TransitGatewayRoute(entry, context));
    });
    return contents;
};
const deserializeAws_ec2TransitGatewayRouteTable = (output, context) => {
    let contents = {
        __type: "TransitGatewayRouteTable",
        CreationTime: undefined,
        DefaultAssociationRouteTable: undefined,
        DefaultPropagationRouteTable: undefined,
        State: undefined,
        Tags: undefined,
        TransitGatewayId: undefined,
        TransitGatewayRouteTableId: undefined
    };
    if (output["creationTime"] !== undefined) {
        contents.CreationTime = new Date(output["creationTime"]);
    }
    if (output["defaultAssociationRouteTable"] !== undefined) {
        contents.DefaultAssociationRouteTable =
            output["defaultAssociationRouteTable"] == "true";
    }
    if (output["defaultPropagationRouteTable"] !== undefined) {
        contents.DefaultPropagationRouteTable =
            output["defaultPropagationRouteTable"] == "true";
    }
    if (output["state"] !== undefined) {
        contents.State = output["state"];
    }
    if (output.tagSet === "") {
        contents.Tags = [];
    }
    if (output["tagSet"] !== undefined &&
        output["tagSet"]["item"] !== undefined) {
        const wrappedItem = output["tagSet"]["item"] instanceof Array
            ? output["tagSet"]["item"]
            : [output["tagSet"]["item"]];
        contents.Tags = deserializeAws_ec2TagList(wrappedItem, context);
    }
    if (output["transitGatewayId"] !== undefined) {
        contents.TransitGatewayId = output["transitGatewayId"];
    }
    if (output["transitGatewayRouteTableId"] !== undefined) {
        contents.TransitGatewayRouteTableId = output["transitGatewayRouteTableId"];
    }
    return contents;
};
const deserializeAws_ec2TransitGatewayRouteTableAssociation = (output, context) => {
    let contents = {
        __type: "TransitGatewayRouteTableAssociation",
        ResourceId: undefined,
        ResourceType: undefined,
        State: undefined,
        TransitGatewayAttachmentId: undefined
    };
    if (output["resourceId"] !== undefined) {
        contents.ResourceId = output["resourceId"];
    }
    if (output["resourceType"] !== undefined) {
        contents.ResourceType = output["resourceType"];
    }
    if (output["state"] !== undefined) {
        contents.State = output["state"];
    }
    if (output["transitGatewayAttachmentId"] !== undefined) {
        contents.TransitGatewayAttachmentId = output["transitGatewayAttachmentId"];
    }
    return contents;
};
const deserializeAws_ec2TransitGatewayRouteTableAssociationList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2TransitGatewayRouteTableAssociation(entry, context));
    });
    return contents;
};
const deserializeAws_ec2TransitGatewayRouteTableList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2TransitGatewayRouteTable(entry, context));
    });
    return contents;
};
const deserializeAws_ec2TransitGatewayRouteTablePropagation = (output, context) => {
    let contents = {
        __type: "TransitGatewayRouteTablePropagation",
        ResourceId: undefined,
        ResourceType: undefined,
        State: undefined,
        TransitGatewayAttachmentId: undefined
    };
    if (output["resourceId"] !== undefined) {
        contents.ResourceId = output["resourceId"];
    }
    if (output["resourceType"] !== undefined) {
        contents.ResourceType = output["resourceType"];
    }
    if (output["state"] !== undefined) {
        contents.State = output["state"];
    }
    if (output["transitGatewayAttachmentId"] !== undefined) {
        contents.TransitGatewayAttachmentId = output["transitGatewayAttachmentId"];
    }
    return contents;
};
const deserializeAws_ec2TransitGatewayRouteTablePropagationList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2TransitGatewayRouteTablePropagation(entry, context));
    });
    return contents;
};
const deserializeAws_ec2TransitGatewayVpcAttachment = (output, context) => {
    let contents = {
        __type: "TransitGatewayVpcAttachment",
        CreationTime: undefined,
        Options: undefined,
        State: undefined,
        SubnetIds: undefined,
        Tags: undefined,
        TransitGatewayAttachmentId: undefined,
        TransitGatewayId: undefined,
        VpcId: undefined,
        VpcOwnerId: undefined
    };
    if (output["creationTime"] !== undefined) {
        contents.CreationTime = new Date(output["creationTime"]);
    }
    if (output["options"] !== undefined) {
        contents.Options = deserializeAws_ec2TransitGatewayVpcAttachmentOptions(output["options"], context);
    }
    if (output["state"] !== undefined) {
        contents.State = output["state"];
    }
    if (output.subnetIds === "") {
        contents.SubnetIds = [];
    }
    if (output["subnetIds"] !== undefined &&
        output["subnetIds"]["item"] !== undefined) {
        const wrappedItem = output["subnetIds"]["item"] instanceof Array
            ? output["subnetIds"]["item"]
            : [output["subnetIds"]["item"]];
        contents.SubnetIds = deserializeAws_ec2ValueStringList(wrappedItem, context);
    }
    if (output.tagSet === "") {
        contents.Tags = [];
    }
    if (output["tagSet"] !== undefined &&
        output["tagSet"]["item"] !== undefined) {
        const wrappedItem = output["tagSet"]["item"] instanceof Array
            ? output["tagSet"]["item"]
            : [output["tagSet"]["item"]];
        contents.Tags = deserializeAws_ec2TagList(wrappedItem, context);
    }
    if (output["transitGatewayAttachmentId"] !== undefined) {
        contents.TransitGatewayAttachmentId = output["transitGatewayAttachmentId"];
    }
    if (output["transitGatewayId"] !== undefined) {
        contents.TransitGatewayId = output["transitGatewayId"];
    }
    if (output["vpcId"] !== undefined) {
        contents.VpcId = output["vpcId"];
    }
    if (output["vpcOwnerId"] !== undefined) {
        contents.VpcOwnerId = output["vpcOwnerId"];
    }
    return contents;
};
const deserializeAws_ec2TransitGatewayVpcAttachmentList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2TransitGatewayVpcAttachment(entry, context));
    });
    return contents;
};
const deserializeAws_ec2TransitGatewayVpcAttachmentOptions = (output, context) => {
    let contents = {
        __type: "TransitGatewayVpcAttachmentOptions",
        DnsSupport: undefined,
        Ipv6Support: undefined
    };
    if (output["dnsSupport"] !== undefined) {
        contents.DnsSupport = output["dnsSupport"];
    }
    if (output["ipv6Support"] !== undefined) {
        contents.Ipv6Support = output["ipv6Support"];
    }
    return contents;
};
const deserializeAws_ec2TunnelOption = (output, context) => {
    let contents = {
        __type: "TunnelOption",
        DpdTimeoutSeconds: undefined,
        IkeVersions: undefined,
        OutsideIpAddress: undefined,
        Phase1DHGroupNumbers: undefined,
        Phase1EncryptionAlgorithms: undefined,
        Phase1IntegrityAlgorithms: undefined,
        Phase1LifetimeSeconds: undefined,
        Phase2DHGroupNumbers: undefined,
        Phase2EncryptionAlgorithms: undefined,
        Phase2IntegrityAlgorithms: undefined,
        Phase2LifetimeSeconds: undefined,
        PreSharedKey: undefined,
        RekeyFuzzPercentage: undefined,
        RekeyMarginTimeSeconds: undefined,
        ReplayWindowSize: undefined,
        TunnelInsideCidr: undefined
    };
    if (output["dpdTimeoutSeconds"] !== undefined) {
        contents.DpdTimeoutSeconds = parseInt(output["dpdTimeoutSeconds"]);
    }
    if (output.ikeVersionSet === "") {
        contents.IkeVersions = [];
    }
    if (output["ikeVersionSet"] !== undefined &&
        output["ikeVersionSet"]["item"] !== undefined) {
        const wrappedItem = output["ikeVersionSet"]["item"] instanceof Array
            ? output["ikeVersionSet"]["item"]
            : [output["ikeVersionSet"]["item"]];
        contents.IkeVersions = deserializeAws_ec2IKEVersionsList(wrappedItem, context);
    }
    if (output["outsideIpAddress"] !== undefined) {
        contents.OutsideIpAddress = output["outsideIpAddress"];
    }
    if (output.phase1DHGroupNumberSet === "") {
        contents.Phase1DHGroupNumbers = [];
    }
    if (output["phase1DHGroupNumberSet"] !== undefined &&
        output["phase1DHGroupNumberSet"]["item"] !== undefined) {
        const wrappedItem = output["phase1DHGroupNumberSet"]["item"] instanceof Array
            ? output["phase1DHGroupNumberSet"]["item"]
            : [output["phase1DHGroupNumberSet"]["item"]];
        contents.Phase1DHGroupNumbers = deserializeAws_ec2Phase1DHGroupNumbersList(wrappedItem, context);
    }
    if (output.phase1EncryptionAlgorithmSet === "") {
        contents.Phase1EncryptionAlgorithms = [];
    }
    if (output["phase1EncryptionAlgorithmSet"] !== undefined &&
        output["phase1EncryptionAlgorithmSet"]["item"] !== undefined) {
        const wrappedItem = output["phase1EncryptionAlgorithmSet"]["item"] instanceof Array
            ? output["phase1EncryptionAlgorithmSet"]["item"]
            : [output["phase1EncryptionAlgorithmSet"]["item"]];
        contents.Phase1EncryptionAlgorithms = deserializeAws_ec2Phase1EncryptionAlgorithmsList(wrappedItem, context);
    }
    if (output.phase1IntegrityAlgorithmSet === "") {
        contents.Phase1IntegrityAlgorithms = [];
    }
    if (output["phase1IntegrityAlgorithmSet"] !== undefined &&
        output["phase1IntegrityAlgorithmSet"]["item"] !== undefined) {
        const wrappedItem = output["phase1IntegrityAlgorithmSet"]["item"] instanceof Array
            ? output["phase1IntegrityAlgorithmSet"]["item"]
            : [output["phase1IntegrityAlgorithmSet"]["item"]];
        contents.Phase1IntegrityAlgorithms = deserializeAws_ec2Phase1IntegrityAlgorithmsList(wrappedItem, context);
    }
    if (output["phase1LifetimeSeconds"] !== undefined) {
        contents.Phase1LifetimeSeconds = parseInt(output["phase1LifetimeSeconds"]);
    }
    if (output.phase2DHGroupNumberSet === "") {
        contents.Phase2DHGroupNumbers = [];
    }
    if (output["phase2DHGroupNumberSet"] !== undefined &&
        output["phase2DHGroupNumberSet"]["item"] !== undefined) {
        const wrappedItem = output["phase2DHGroupNumberSet"]["item"] instanceof Array
            ? output["phase2DHGroupNumberSet"]["item"]
            : [output["phase2DHGroupNumberSet"]["item"]];
        contents.Phase2DHGroupNumbers = deserializeAws_ec2Phase2DHGroupNumbersList(wrappedItem, context);
    }
    if (output.phase2EncryptionAlgorithmSet === "") {
        contents.Phase2EncryptionAlgorithms = [];
    }
    if (output["phase2EncryptionAlgorithmSet"] !== undefined &&
        output["phase2EncryptionAlgorithmSet"]["item"] !== undefined) {
        const wrappedItem = output["phase2EncryptionAlgorithmSet"]["item"] instanceof Array
            ? output["phase2EncryptionAlgorithmSet"]["item"]
            : [output["phase2EncryptionAlgorithmSet"]["item"]];
        contents.Phase2EncryptionAlgorithms = deserializeAws_ec2Phase2EncryptionAlgorithmsList(wrappedItem, context);
    }
    if (output.phase2IntegrityAlgorithmSet === "") {
        contents.Phase2IntegrityAlgorithms = [];
    }
    if (output["phase2IntegrityAlgorithmSet"] !== undefined &&
        output["phase2IntegrityAlgorithmSet"]["item"] !== undefined) {
        const wrappedItem = output["phase2IntegrityAlgorithmSet"]["item"] instanceof Array
            ? output["phase2IntegrityAlgorithmSet"]["item"]
            : [output["phase2IntegrityAlgorithmSet"]["item"]];
        contents.Phase2IntegrityAlgorithms = deserializeAws_ec2Phase2IntegrityAlgorithmsList(wrappedItem, context);
    }
    if (output["phase2LifetimeSeconds"] !== undefined) {
        contents.Phase2LifetimeSeconds = parseInt(output["phase2LifetimeSeconds"]);
    }
    if (output["preSharedKey"] !== undefined) {
        contents.PreSharedKey = output["preSharedKey"];
    }
    if (output["rekeyFuzzPercentage"] !== undefined) {
        contents.RekeyFuzzPercentage = parseInt(output["rekeyFuzzPercentage"]);
    }
    if (output["rekeyMarginTimeSeconds"] !== undefined) {
        contents.RekeyMarginTimeSeconds = parseInt(output["rekeyMarginTimeSeconds"]);
    }
    if (output["replayWindowSize"] !== undefined) {
        contents.ReplayWindowSize = parseInt(output["replayWindowSize"]);
    }
    if (output["tunnelInsideCidr"] !== undefined) {
        contents.TunnelInsideCidr = output["tunnelInsideCidr"];
    }
    return contents;
};
const deserializeAws_ec2TunnelOptionsList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2TunnelOption(entry, context));
    });
    return contents;
};
const deserializeAws_ec2UnassignIpv6AddressesResult = (output, context) => {
    let contents = {
        __type: "UnassignIpv6AddressesResult",
        NetworkInterfaceId: undefined,
        UnassignedIpv6Addresses: undefined
    };
    if (output["networkInterfaceId"] !== undefined) {
        contents.NetworkInterfaceId = output["networkInterfaceId"];
    }
    if (output.unassignedIpv6Addresses === "") {
        contents.UnassignedIpv6Addresses = [];
    }
    if (output["unassignedIpv6Addresses"] !== undefined &&
        output["unassignedIpv6Addresses"]["item"] !== undefined) {
        const wrappedItem = output["unassignedIpv6Addresses"]["item"] instanceof Array
            ? output["unassignedIpv6Addresses"]["item"]
            : [output["unassignedIpv6Addresses"]["item"]];
        contents.UnassignedIpv6Addresses = deserializeAws_ec2Ipv6AddressList(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2UnmonitorInstancesResult = (output, context) => {
    let contents = {
        __type: "UnmonitorInstancesResult",
        InstanceMonitorings: undefined
    };
    if (output.instancesSet === "") {
        contents.InstanceMonitorings = [];
    }
    if (output["instancesSet"] !== undefined &&
        output["instancesSet"]["item"] !== undefined) {
        const wrappedItem = output["instancesSet"]["item"] instanceof Array
            ? output["instancesSet"]["item"]
            : [output["instancesSet"]["item"]];
        contents.InstanceMonitorings = deserializeAws_ec2InstanceMonitoringList(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2UnsuccessfulInstanceCreditSpecificationItem = (output, context) => {
    let contents = {
        __type: "UnsuccessfulInstanceCreditSpecificationItem",
        Error: undefined,
        InstanceId: undefined
    };
    if (output["error"] !== undefined) {
        contents.Error = deserializeAws_ec2UnsuccessfulInstanceCreditSpecificationItemError(output["error"], context);
    }
    if (output["instanceId"] !== undefined) {
        contents.InstanceId = output["instanceId"];
    }
    return contents;
};
const deserializeAws_ec2UnsuccessfulInstanceCreditSpecificationItemError = (output, context) => {
    let contents = {
        __type: "UnsuccessfulInstanceCreditSpecificationItemError",
        Code: undefined,
        Message: undefined
    };
    if (output["code"] !== undefined) {
        contents.Code = output["code"];
    }
    if (output["message"] !== undefined) {
        contents.Message = output["message"];
    }
    return contents;
};
const deserializeAws_ec2UnsuccessfulInstanceCreditSpecificationSet = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2UnsuccessfulInstanceCreditSpecificationItem(entry, context));
    });
    return contents;
};
const deserializeAws_ec2UnsuccessfulItem = (output, context) => {
    let contents = {
        __type: "UnsuccessfulItem",
        Error: undefined,
        ResourceId: undefined
    };
    if (output["error"] !== undefined) {
        contents.Error = deserializeAws_ec2UnsuccessfulItemError(output["error"], context);
    }
    if (output["resourceId"] !== undefined) {
        contents.ResourceId = output["resourceId"];
    }
    return contents;
};
const deserializeAws_ec2UnsuccessfulItemError = (output, context) => {
    let contents = {
        __type: "UnsuccessfulItemError",
        Code: undefined,
        Message: undefined
    };
    if (output["code"] !== undefined) {
        contents.Code = output["code"];
    }
    if (output["message"] !== undefined) {
        contents.Message = output["message"];
    }
    return contents;
};
const deserializeAws_ec2UnsuccessfulItemList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2UnsuccessfulItem(entry, context));
    });
    return contents;
};
const deserializeAws_ec2UnsuccessfulItemSet = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2UnsuccessfulItem(entry, context));
    });
    return contents;
};
const deserializeAws_ec2UpdateSecurityGroupRuleDescriptionsEgressResult = (output, context) => {
    let contents = {
        __type: "UpdateSecurityGroupRuleDescriptionsEgressResult",
        Return: undefined
    };
    if (output["return"] !== undefined) {
        contents.Return = output["return"] == "true";
    }
    return contents;
};
const deserializeAws_ec2UpdateSecurityGroupRuleDescriptionsIngressResult = (output, context) => {
    let contents = {
        __type: "UpdateSecurityGroupRuleDescriptionsIngressResult",
        Return: undefined
    };
    if (output["return"] !== undefined) {
        contents.Return = output["return"] == "true";
    }
    return contents;
};
const deserializeAws_ec2UsageClassTypeList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(entry);
    });
    return contents;
};
const deserializeAws_ec2UserBucketDetails = (output, context) => {
    let contents = {
        __type: "UserBucketDetails",
        S3Bucket: undefined,
        S3Key: undefined
    };
    if (output["s3Bucket"] !== undefined) {
        contents.S3Bucket = output["s3Bucket"];
    }
    if (output["s3Key"] !== undefined) {
        contents.S3Key = output["s3Key"];
    }
    return contents;
};
const deserializeAws_ec2UserIdGroupPair = (output, context) => {
    let contents = {
        __type: "UserIdGroupPair",
        Description: undefined,
        GroupId: undefined,
        GroupName: undefined,
        PeeringStatus: undefined,
        UserId: undefined,
        VpcId: undefined,
        VpcPeeringConnectionId: undefined
    };
    if (output["description"] !== undefined) {
        contents.Description = output["description"];
    }
    if (output["groupId"] !== undefined) {
        contents.GroupId = output["groupId"];
    }
    if (output["groupName"] !== undefined) {
        contents.GroupName = output["groupName"];
    }
    if (output["peeringStatus"] !== undefined) {
        contents.PeeringStatus = output["peeringStatus"];
    }
    if (output["userId"] !== undefined) {
        contents.UserId = output["userId"];
    }
    if (output["vpcId"] !== undefined) {
        contents.VpcId = output["vpcId"];
    }
    if (output["vpcPeeringConnectionId"] !== undefined) {
        contents.VpcPeeringConnectionId = output["vpcPeeringConnectionId"];
    }
    return contents;
};
const deserializeAws_ec2UserIdGroupPairList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2UserIdGroupPair(entry, context));
    });
    return contents;
};
const deserializeAws_ec2UserIdGroupPairSet = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2UserIdGroupPair(entry, context));
    });
    return contents;
};
const deserializeAws_ec2VCpuInfo = (output, context) => {
    let contents = {
        __type: "VCpuInfo",
        DefaultCores: undefined,
        DefaultThreadsPerCore: undefined,
        DefaultVCpus: undefined,
        ValidCores: undefined,
        ValidThreadsPerCore: undefined
    };
    if (output["defaultCores"] !== undefined) {
        contents.DefaultCores = parseInt(output["defaultCores"]);
    }
    if (output["defaultThreadsPerCore"] !== undefined) {
        contents.DefaultThreadsPerCore = parseInt(output["defaultThreadsPerCore"]);
    }
    if (output["defaultVCpus"] !== undefined) {
        contents.DefaultVCpus = parseInt(output["defaultVCpus"]);
    }
    if (output.validCores === "") {
        contents.ValidCores = [];
    }
    if (output["validCores"] !== undefined &&
        output["validCores"]["item"] !== undefined) {
        const wrappedItem = output["validCores"]["item"] instanceof Array
            ? output["validCores"]["item"]
            : [output["validCores"]["item"]];
        contents.ValidCores = deserializeAws_ec2CoreCountList(wrappedItem, context);
    }
    if (output.validThreadsPerCore === "") {
        contents.ValidThreadsPerCore = [];
    }
    if (output["validThreadsPerCore"] !== undefined &&
        output["validThreadsPerCore"]["item"] !== undefined) {
        const wrappedItem = output["validThreadsPerCore"]["item"] instanceof Array
            ? output["validThreadsPerCore"]["item"]
            : [output["validThreadsPerCore"]["item"]];
        contents.ValidThreadsPerCore = deserializeAws_ec2ThreadsPerCoreList(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2ValueStringList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(entry);
    });
    return contents;
};
const deserializeAws_ec2VgwTelemetry = (output, context) => {
    let contents = {
        __type: "VgwTelemetry",
        AcceptedRouteCount: undefined,
        CertificateArn: undefined,
        LastStatusChange: undefined,
        OutsideIpAddress: undefined,
        Status: undefined,
        StatusMessage: undefined
    };
    if (output["acceptedRouteCount"] !== undefined) {
        contents.AcceptedRouteCount = parseInt(output["acceptedRouteCount"]);
    }
    if (output["certificateArn"] !== undefined) {
        contents.CertificateArn = output["certificateArn"];
    }
    if (output["lastStatusChange"] !== undefined) {
        contents.LastStatusChange = new Date(output["lastStatusChange"]);
    }
    if (output["outsideIpAddress"] !== undefined) {
        contents.OutsideIpAddress = output["outsideIpAddress"];
    }
    if (output["status"] !== undefined) {
        contents.Status = output["status"];
    }
    if (output["statusMessage"] !== undefined) {
        contents.StatusMessage = output["statusMessage"];
    }
    return contents;
};
const deserializeAws_ec2VgwTelemetryList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2VgwTelemetry(entry, context));
    });
    return contents;
};
const deserializeAws_ec2Volume = (output, context) => {
    let contents = {
        __type: "Volume",
        Attachments: undefined,
        AvailabilityZone: undefined,
        CreateTime: undefined,
        Encrypted: undefined,
        FastRestored: undefined,
        Iops: undefined,
        KmsKeyId: undefined,
        OutpostArn: undefined,
        Size: undefined,
        SnapshotId: undefined,
        State: undefined,
        Tags: undefined,
        VolumeId: undefined,
        VolumeType: undefined
    };
    if (output.attachmentSet === "") {
        contents.Attachments = [];
    }
    if (output["attachmentSet"] !== undefined &&
        output["attachmentSet"]["item"] !== undefined) {
        const wrappedItem = output["attachmentSet"]["item"] instanceof Array
            ? output["attachmentSet"]["item"]
            : [output["attachmentSet"]["item"]];
        contents.Attachments = deserializeAws_ec2VolumeAttachmentList(wrappedItem, context);
    }
    if (output["availabilityZone"] !== undefined) {
        contents.AvailabilityZone = output["availabilityZone"];
    }
    if (output["createTime"] !== undefined) {
        contents.CreateTime = new Date(output["createTime"]);
    }
    if (output["encrypted"] !== undefined) {
        contents.Encrypted = output["encrypted"] == "true";
    }
    if (output["fastRestored"] !== undefined) {
        contents.FastRestored = output["fastRestored"] == "true";
    }
    if (output["iops"] !== undefined) {
        contents.Iops = parseInt(output["iops"]);
    }
    if (output["kmsKeyId"] !== undefined) {
        contents.KmsKeyId = output["kmsKeyId"];
    }
    if (output["outpostArn"] !== undefined) {
        contents.OutpostArn = output["outpostArn"];
    }
    if (output["size"] !== undefined) {
        contents.Size = parseInt(output["size"]);
    }
    if (output["snapshotId"] !== undefined) {
        contents.SnapshotId = output["snapshotId"];
    }
    if (output["status"] !== undefined) {
        contents.State = output["status"];
    }
    if (output.tagSet === "") {
        contents.Tags = [];
    }
    if (output["tagSet"] !== undefined &&
        output["tagSet"]["item"] !== undefined) {
        const wrappedItem = output["tagSet"]["item"] instanceof Array
            ? output["tagSet"]["item"]
            : [output["tagSet"]["item"]];
        contents.Tags = deserializeAws_ec2TagList(wrappedItem, context);
    }
    if (output["volumeId"] !== undefined) {
        contents.VolumeId = output["volumeId"];
    }
    if (output["volumeType"] !== undefined) {
        contents.VolumeType = output["volumeType"];
    }
    return contents;
};
const deserializeAws_ec2VolumeAttachment = (output, context) => {
    let contents = {
        __type: "VolumeAttachment",
        AttachTime: undefined,
        DeleteOnTermination: undefined,
        Device: undefined,
        InstanceId: undefined,
        State: undefined,
        VolumeId: undefined
    };
    if (output["attachTime"] !== undefined) {
        contents.AttachTime = new Date(output["attachTime"]);
    }
    if (output["deleteOnTermination"] !== undefined) {
        contents.DeleteOnTermination = output["deleteOnTermination"] == "true";
    }
    if (output["device"] !== undefined) {
        contents.Device = output["device"];
    }
    if (output["instanceId"] !== undefined) {
        contents.InstanceId = output["instanceId"];
    }
    if (output["status"] !== undefined) {
        contents.State = output["status"];
    }
    if (output["volumeId"] !== undefined) {
        contents.VolumeId = output["volumeId"];
    }
    return contents;
};
const deserializeAws_ec2VolumeAttachmentList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2VolumeAttachment(entry, context));
    });
    return contents;
};
const deserializeAws_ec2VolumeList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2Volume(entry, context));
    });
    return contents;
};
const deserializeAws_ec2VolumeModification = (output, context) => {
    let contents = {
        __type: "VolumeModification",
        EndTime: undefined,
        ModificationState: undefined,
        OriginalIops: undefined,
        OriginalSize: undefined,
        OriginalVolumeType: undefined,
        Progress: undefined,
        StartTime: undefined,
        StatusMessage: undefined,
        TargetIops: undefined,
        TargetSize: undefined,
        TargetVolumeType: undefined,
        VolumeId: undefined
    };
    if (output["endTime"] !== undefined) {
        contents.EndTime = new Date(output["endTime"]);
    }
    if (output["modificationState"] !== undefined) {
        contents.ModificationState = output["modificationState"];
    }
    if (output["originalIops"] !== undefined) {
        contents.OriginalIops = parseInt(output["originalIops"]);
    }
    if (output["originalSize"] !== undefined) {
        contents.OriginalSize = parseInt(output["originalSize"]);
    }
    if (output["originalVolumeType"] !== undefined) {
        contents.OriginalVolumeType = output["originalVolumeType"];
    }
    if (output["progress"] !== undefined) {
        contents.Progress = parseInt(output["progress"]);
    }
    if (output["startTime"] !== undefined) {
        contents.StartTime = new Date(output["startTime"]);
    }
    if (output["statusMessage"] !== undefined) {
        contents.StatusMessage = output["statusMessage"];
    }
    if (output["targetIops"] !== undefined) {
        contents.TargetIops = parseInt(output["targetIops"]);
    }
    if (output["targetSize"] !== undefined) {
        contents.TargetSize = parseInt(output["targetSize"]);
    }
    if (output["targetVolumeType"] !== undefined) {
        contents.TargetVolumeType = output["targetVolumeType"];
    }
    if (output["volumeId"] !== undefined) {
        contents.VolumeId = output["volumeId"];
    }
    return contents;
};
const deserializeAws_ec2VolumeModificationList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2VolumeModification(entry, context));
    });
    return contents;
};
const deserializeAws_ec2VolumeStatusAction = (output, context) => {
    let contents = {
        __type: "VolumeStatusAction",
        Code: undefined,
        Description: undefined,
        EventId: undefined,
        EventType: undefined
    };
    if (output["code"] !== undefined) {
        contents.Code = output["code"];
    }
    if (output["description"] !== undefined) {
        contents.Description = output["description"];
    }
    if (output["eventId"] !== undefined) {
        contents.EventId = output["eventId"];
    }
    if (output["eventType"] !== undefined) {
        contents.EventType = output["eventType"];
    }
    return contents;
};
const deserializeAws_ec2VolumeStatusActionsList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2VolumeStatusAction(entry, context));
    });
    return contents;
};
const deserializeAws_ec2VolumeStatusDetails = (output, context) => {
    let contents = {
        __type: "VolumeStatusDetails",
        Name: undefined,
        Status: undefined
    };
    if (output["name"] !== undefined) {
        contents.Name = output["name"];
    }
    if (output["status"] !== undefined) {
        contents.Status = output["status"];
    }
    return contents;
};
const deserializeAws_ec2VolumeStatusDetailsList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2VolumeStatusDetails(entry, context));
    });
    return contents;
};
const deserializeAws_ec2VolumeStatusEvent = (output, context) => {
    let contents = {
        __type: "VolumeStatusEvent",
        Description: undefined,
        EventId: undefined,
        EventType: undefined,
        NotAfter: undefined,
        NotBefore: undefined
    };
    if (output["description"] !== undefined) {
        contents.Description = output["description"];
    }
    if (output["eventId"] !== undefined) {
        contents.EventId = output["eventId"];
    }
    if (output["eventType"] !== undefined) {
        contents.EventType = output["eventType"];
    }
    if (output["notAfter"] !== undefined) {
        contents.NotAfter = new Date(output["notAfter"]);
    }
    if (output["notBefore"] !== undefined) {
        contents.NotBefore = new Date(output["notBefore"]);
    }
    return contents;
};
const deserializeAws_ec2VolumeStatusEventsList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2VolumeStatusEvent(entry, context));
    });
    return contents;
};
const deserializeAws_ec2VolumeStatusInfo = (output, context) => {
    let contents = {
        __type: "VolumeStatusInfo",
        Details: undefined,
        Status: undefined
    };
    if (output.details === "") {
        contents.Details = [];
    }
    if (output["details"] !== undefined &&
        output["details"]["item"] !== undefined) {
        const wrappedItem = output["details"]["item"] instanceof Array
            ? output["details"]["item"]
            : [output["details"]["item"]];
        contents.Details = deserializeAws_ec2VolumeStatusDetailsList(wrappedItem, context);
    }
    if (output["status"] !== undefined) {
        contents.Status = output["status"];
    }
    return contents;
};
const deserializeAws_ec2VolumeStatusItem = (output, context) => {
    let contents = {
        __type: "VolumeStatusItem",
        Actions: undefined,
        AvailabilityZone: undefined,
        Events: undefined,
        OutpostArn: undefined,
        VolumeId: undefined,
        VolumeStatus: undefined
    };
    if (output.actionsSet === "") {
        contents.Actions = [];
    }
    if (output["actionsSet"] !== undefined &&
        output["actionsSet"]["item"] !== undefined) {
        const wrappedItem = output["actionsSet"]["item"] instanceof Array
            ? output["actionsSet"]["item"]
            : [output["actionsSet"]["item"]];
        contents.Actions = deserializeAws_ec2VolumeStatusActionsList(wrappedItem, context);
    }
    if (output["availabilityZone"] !== undefined) {
        contents.AvailabilityZone = output["availabilityZone"];
    }
    if (output.eventsSet === "") {
        contents.Events = [];
    }
    if (output["eventsSet"] !== undefined &&
        output["eventsSet"]["item"] !== undefined) {
        const wrappedItem = output["eventsSet"]["item"] instanceof Array
            ? output["eventsSet"]["item"]
            : [output["eventsSet"]["item"]];
        contents.Events = deserializeAws_ec2VolumeStatusEventsList(wrappedItem, context);
    }
    if (output["outpostArn"] !== undefined) {
        contents.OutpostArn = output["outpostArn"];
    }
    if (output["volumeId"] !== undefined) {
        contents.VolumeId = output["volumeId"];
    }
    if (output["volumeStatus"] !== undefined) {
        contents.VolumeStatus = deserializeAws_ec2VolumeStatusInfo(output["volumeStatus"], context);
    }
    return contents;
};
const deserializeAws_ec2VolumeStatusList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2VolumeStatusItem(entry, context));
    });
    return contents;
};
const deserializeAws_ec2Vpc = (output, context) => {
    let contents = {
        __type: "Vpc",
        CidrBlock: undefined,
        CidrBlockAssociationSet: undefined,
        DhcpOptionsId: undefined,
        InstanceTenancy: undefined,
        Ipv6CidrBlockAssociationSet: undefined,
        IsDefault: undefined,
        OwnerId: undefined,
        State: undefined,
        Tags: undefined,
        VpcId: undefined
    };
    if (output["cidrBlock"] !== undefined) {
        contents.CidrBlock = output["cidrBlock"];
    }
    if (output.cidrBlockAssociationSet === "") {
        contents.CidrBlockAssociationSet = [];
    }
    if (output["cidrBlockAssociationSet"] !== undefined &&
        output["cidrBlockAssociationSet"]["item"] !== undefined) {
        const wrappedItem = output["cidrBlockAssociationSet"]["item"] instanceof Array
            ? output["cidrBlockAssociationSet"]["item"]
            : [output["cidrBlockAssociationSet"]["item"]];
        contents.CidrBlockAssociationSet = deserializeAws_ec2VpcCidrBlockAssociationSet(wrappedItem, context);
    }
    if (output["dhcpOptionsId"] !== undefined) {
        contents.DhcpOptionsId = output["dhcpOptionsId"];
    }
    if (output["instanceTenancy"] !== undefined) {
        contents.InstanceTenancy = output["instanceTenancy"];
    }
    if (output.ipv6CidrBlockAssociationSet === "") {
        contents.Ipv6CidrBlockAssociationSet = [];
    }
    if (output["ipv6CidrBlockAssociationSet"] !== undefined &&
        output["ipv6CidrBlockAssociationSet"]["item"] !== undefined) {
        const wrappedItem = output["ipv6CidrBlockAssociationSet"]["item"] instanceof Array
            ? output["ipv6CidrBlockAssociationSet"]["item"]
            : [output["ipv6CidrBlockAssociationSet"]["item"]];
        contents.Ipv6CidrBlockAssociationSet = deserializeAws_ec2VpcIpv6CidrBlockAssociationSet(wrappedItem, context);
    }
    if (output["isDefault"] !== undefined) {
        contents.IsDefault = output["isDefault"] == "true";
    }
    if (output["ownerId"] !== undefined) {
        contents.OwnerId = output["ownerId"];
    }
    if (output["state"] !== undefined) {
        contents.State = output["state"];
    }
    if (output.tagSet === "") {
        contents.Tags = [];
    }
    if (output["tagSet"] !== undefined &&
        output["tagSet"]["item"] !== undefined) {
        const wrappedItem = output["tagSet"]["item"] instanceof Array
            ? output["tagSet"]["item"]
            : [output["tagSet"]["item"]];
        contents.Tags = deserializeAws_ec2TagList(wrappedItem, context);
    }
    if (output["vpcId"] !== undefined) {
        contents.VpcId = output["vpcId"];
    }
    return contents;
};
const deserializeAws_ec2VpcAttachment = (output, context) => {
    let contents = {
        __type: "VpcAttachment",
        State: undefined,
        VpcId: undefined
    };
    if (output["state"] !== undefined) {
        contents.State = output["state"];
    }
    if (output["vpcId"] !== undefined) {
        contents.VpcId = output["vpcId"];
    }
    return contents;
};
const deserializeAws_ec2VpcAttachmentList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2VpcAttachment(entry, context));
    });
    return contents;
};
const deserializeAws_ec2VpcCidrBlockAssociation = (output, context) => {
    let contents = {
        __type: "VpcCidrBlockAssociation",
        AssociationId: undefined,
        CidrBlock: undefined,
        CidrBlockState: undefined
    };
    if (output["associationId"] !== undefined) {
        contents.AssociationId = output["associationId"];
    }
    if (output["cidrBlock"] !== undefined) {
        contents.CidrBlock = output["cidrBlock"];
    }
    if (output["cidrBlockState"] !== undefined) {
        contents.CidrBlockState = deserializeAws_ec2VpcCidrBlockState(output["cidrBlockState"], context);
    }
    return contents;
};
const deserializeAws_ec2VpcCidrBlockAssociationSet = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2VpcCidrBlockAssociation(entry, context));
    });
    return contents;
};
const deserializeAws_ec2VpcCidrBlockState = (output, context) => {
    let contents = {
        __type: "VpcCidrBlockState",
        State: undefined,
        StatusMessage: undefined
    };
    if (output["state"] !== undefined) {
        contents.State = output["state"];
    }
    if (output["statusMessage"] !== undefined) {
        contents.StatusMessage = output["statusMessage"];
    }
    return contents;
};
const deserializeAws_ec2VpcClassicLink = (output, context) => {
    let contents = {
        __type: "VpcClassicLink",
        ClassicLinkEnabled: undefined,
        Tags: undefined,
        VpcId: undefined
    };
    if (output["classicLinkEnabled"] !== undefined) {
        contents.ClassicLinkEnabled = output["classicLinkEnabled"] == "true";
    }
    if (output.tagSet === "") {
        contents.Tags = [];
    }
    if (output["tagSet"] !== undefined &&
        output["tagSet"]["item"] !== undefined) {
        const wrappedItem = output["tagSet"]["item"] instanceof Array
            ? output["tagSet"]["item"]
            : [output["tagSet"]["item"]];
        contents.Tags = deserializeAws_ec2TagList(wrappedItem, context);
    }
    if (output["vpcId"] !== undefined) {
        contents.VpcId = output["vpcId"];
    }
    return contents;
};
const deserializeAws_ec2VpcClassicLinkList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2VpcClassicLink(entry, context));
    });
    return contents;
};
const deserializeAws_ec2VpcEndpoint = (output, context) => {
    let contents = {
        __type: "VpcEndpoint",
        CreationTimestamp: undefined,
        DnsEntries: undefined,
        Groups: undefined,
        LastError: undefined,
        NetworkInterfaceIds: undefined,
        OwnerId: undefined,
        PolicyDocument: undefined,
        PrivateDnsEnabled: undefined,
        RequesterManaged: undefined,
        RouteTableIds: undefined,
        ServiceName: undefined,
        State: undefined,
        SubnetIds: undefined,
        Tags: undefined,
        VpcEndpointId: undefined,
        VpcEndpointType: undefined,
        VpcId: undefined
    };
    if (output["creationTimestamp"] !== undefined) {
        contents.CreationTimestamp = new Date(output["creationTimestamp"]);
    }
    if (output.dnsEntrySet === "") {
        contents.DnsEntries = [];
    }
    if (output["dnsEntrySet"] !== undefined &&
        output["dnsEntrySet"]["item"] !== undefined) {
        const wrappedItem = output["dnsEntrySet"]["item"] instanceof Array
            ? output["dnsEntrySet"]["item"]
            : [output["dnsEntrySet"]["item"]];
        contents.DnsEntries = deserializeAws_ec2DnsEntrySet(wrappedItem, context);
    }
    if (output.groupSet === "") {
        contents.Groups = [];
    }
    if (output["groupSet"] !== undefined &&
        output["groupSet"]["item"] !== undefined) {
        const wrappedItem = output["groupSet"]["item"] instanceof Array
            ? output["groupSet"]["item"]
            : [output["groupSet"]["item"]];
        contents.Groups = deserializeAws_ec2GroupIdentifierSet(wrappedItem, context);
    }
    if (output["lastError"] !== undefined) {
        contents.LastError = deserializeAws_ec2LastError(output["lastError"], context);
    }
    if (output.networkInterfaceIdSet === "") {
        contents.NetworkInterfaceIds = [];
    }
    if (output["networkInterfaceIdSet"] !== undefined &&
        output["networkInterfaceIdSet"]["item"] !== undefined) {
        const wrappedItem = output["networkInterfaceIdSet"]["item"] instanceof Array
            ? output["networkInterfaceIdSet"]["item"]
            : [output["networkInterfaceIdSet"]["item"]];
        contents.NetworkInterfaceIds = deserializeAws_ec2ValueStringList(wrappedItem, context);
    }
    if (output["ownerId"] !== undefined) {
        contents.OwnerId = output["ownerId"];
    }
    if (output["policyDocument"] !== undefined) {
        contents.PolicyDocument = output["policyDocument"];
    }
    if (output["privateDnsEnabled"] !== undefined) {
        contents.PrivateDnsEnabled = output["privateDnsEnabled"] == "true";
    }
    if (output["requesterManaged"] !== undefined) {
        contents.RequesterManaged = output["requesterManaged"] == "true";
    }
    if (output.routeTableIdSet === "") {
        contents.RouteTableIds = [];
    }
    if (output["routeTableIdSet"] !== undefined &&
        output["routeTableIdSet"]["item"] !== undefined) {
        const wrappedItem = output["routeTableIdSet"]["item"] instanceof Array
            ? output["routeTableIdSet"]["item"]
            : [output["routeTableIdSet"]["item"]];
        contents.RouteTableIds = deserializeAws_ec2ValueStringList(wrappedItem, context);
    }
    if (output["serviceName"] !== undefined) {
        contents.ServiceName = output["serviceName"];
    }
    if (output["state"] !== undefined) {
        contents.State = output["state"];
    }
    if (output.subnetIdSet === "") {
        contents.SubnetIds = [];
    }
    if (output["subnetIdSet"] !== undefined &&
        output["subnetIdSet"]["item"] !== undefined) {
        const wrappedItem = output["subnetIdSet"]["item"] instanceof Array
            ? output["subnetIdSet"]["item"]
            : [output["subnetIdSet"]["item"]];
        contents.SubnetIds = deserializeAws_ec2ValueStringList(wrappedItem, context);
    }
    if (output.tagSet === "") {
        contents.Tags = [];
    }
    if (output["tagSet"] !== undefined &&
        output["tagSet"]["item"] !== undefined) {
        const wrappedItem = output["tagSet"]["item"] instanceof Array
            ? output["tagSet"]["item"]
            : [output["tagSet"]["item"]];
        contents.Tags = deserializeAws_ec2TagList(wrappedItem, context);
    }
    if (output["vpcEndpointId"] !== undefined) {
        contents.VpcEndpointId = output["vpcEndpointId"];
    }
    if (output["vpcEndpointType"] !== undefined) {
        contents.VpcEndpointType = output["vpcEndpointType"];
    }
    if (output["vpcId"] !== undefined) {
        contents.VpcId = output["vpcId"];
    }
    return contents;
};
const deserializeAws_ec2VpcEndpointConnection = (output, context) => {
    let contents = {
        __type: "VpcEndpointConnection",
        CreationTimestamp: undefined,
        DnsEntries: undefined,
        NetworkLoadBalancerArns: undefined,
        ServiceId: undefined,
        VpcEndpointId: undefined,
        VpcEndpointOwner: undefined,
        VpcEndpointState: undefined
    };
    if (output["creationTimestamp"] !== undefined) {
        contents.CreationTimestamp = new Date(output["creationTimestamp"]);
    }
    if (output.dnsEntrySet === "") {
        contents.DnsEntries = [];
    }
    if (output["dnsEntrySet"] !== undefined &&
        output["dnsEntrySet"]["item"] !== undefined) {
        const wrappedItem = output["dnsEntrySet"]["item"] instanceof Array
            ? output["dnsEntrySet"]["item"]
            : [output["dnsEntrySet"]["item"]];
        contents.DnsEntries = deserializeAws_ec2DnsEntrySet(wrappedItem, context);
    }
    if (output.networkLoadBalancerArnSet === "") {
        contents.NetworkLoadBalancerArns = [];
    }
    if (output["networkLoadBalancerArnSet"] !== undefined &&
        output["networkLoadBalancerArnSet"]["item"] !== undefined) {
        const wrappedItem = output["networkLoadBalancerArnSet"]["item"] instanceof Array
            ? output["networkLoadBalancerArnSet"]["item"]
            : [output["networkLoadBalancerArnSet"]["item"]];
        contents.NetworkLoadBalancerArns = deserializeAws_ec2ValueStringList(wrappedItem, context);
    }
    if (output["serviceId"] !== undefined) {
        contents.ServiceId = output["serviceId"];
    }
    if (output["vpcEndpointId"] !== undefined) {
        contents.VpcEndpointId = output["vpcEndpointId"];
    }
    if (output["vpcEndpointOwner"] !== undefined) {
        contents.VpcEndpointOwner = output["vpcEndpointOwner"];
    }
    if (output["vpcEndpointState"] !== undefined) {
        contents.VpcEndpointState = output["vpcEndpointState"];
    }
    return contents;
};
const deserializeAws_ec2VpcEndpointConnectionSet = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2VpcEndpointConnection(entry, context));
    });
    return contents;
};
const deserializeAws_ec2VpcEndpointSet = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2VpcEndpoint(entry, context));
    });
    return contents;
};
const deserializeAws_ec2VpcIpv6CidrBlockAssociation = (output, context) => {
    let contents = {
        __type: "VpcIpv6CidrBlockAssociation",
        AssociationId: undefined,
        Ipv6CidrBlock: undefined,
        Ipv6CidrBlockState: undefined,
        Ipv6Pool: undefined,
        NetworkBorderGroup: undefined
    };
    if (output["associationId"] !== undefined) {
        contents.AssociationId = output["associationId"];
    }
    if (output["ipv6CidrBlock"] !== undefined) {
        contents.Ipv6CidrBlock = output["ipv6CidrBlock"];
    }
    if (output["ipv6CidrBlockState"] !== undefined) {
        contents.Ipv6CidrBlockState = deserializeAws_ec2VpcCidrBlockState(output["ipv6CidrBlockState"], context);
    }
    if (output["ipv6Pool"] !== undefined) {
        contents.Ipv6Pool = output["ipv6Pool"];
    }
    if (output["networkBorderGroup"] !== undefined) {
        contents.NetworkBorderGroup = output["networkBorderGroup"];
    }
    return contents;
};
const deserializeAws_ec2VpcIpv6CidrBlockAssociationSet = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2VpcIpv6CidrBlockAssociation(entry, context));
    });
    return contents;
};
const deserializeAws_ec2VpcList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2Vpc(entry, context));
    });
    return contents;
};
const deserializeAws_ec2VpcPeeringConnection = (output, context) => {
    let contents = {
        __type: "VpcPeeringConnection",
        AccepterVpcInfo: undefined,
        ExpirationTime: undefined,
        RequesterVpcInfo: undefined,
        Status: undefined,
        Tags: undefined,
        VpcPeeringConnectionId: undefined
    };
    if (output["accepterVpcInfo"] !== undefined) {
        contents.AccepterVpcInfo = deserializeAws_ec2VpcPeeringConnectionVpcInfo(output["accepterVpcInfo"], context);
    }
    if (output["expirationTime"] !== undefined) {
        contents.ExpirationTime = new Date(output["expirationTime"]);
    }
    if (output["requesterVpcInfo"] !== undefined) {
        contents.RequesterVpcInfo = deserializeAws_ec2VpcPeeringConnectionVpcInfo(output["requesterVpcInfo"], context);
    }
    if (output["status"] !== undefined) {
        contents.Status = deserializeAws_ec2VpcPeeringConnectionStateReason(output["status"], context);
    }
    if (output.tagSet === "") {
        contents.Tags = [];
    }
    if (output["tagSet"] !== undefined &&
        output["tagSet"]["item"] !== undefined) {
        const wrappedItem = output["tagSet"]["item"] instanceof Array
            ? output["tagSet"]["item"]
            : [output["tagSet"]["item"]];
        contents.Tags = deserializeAws_ec2TagList(wrappedItem, context);
    }
    if (output["vpcPeeringConnectionId"] !== undefined) {
        contents.VpcPeeringConnectionId = output["vpcPeeringConnectionId"];
    }
    return contents;
};
const deserializeAws_ec2VpcPeeringConnectionList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2VpcPeeringConnection(entry, context));
    });
    return contents;
};
const deserializeAws_ec2VpcPeeringConnectionOptionsDescription = (output, context) => {
    let contents = {
        __type: "VpcPeeringConnectionOptionsDescription",
        AllowDnsResolutionFromRemoteVpc: undefined,
        AllowEgressFromLocalClassicLinkToRemoteVpc: undefined,
        AllowEgressFromLocalVpcToRemoteClassicLink: undefined
    };
    if (output["allowDnsResolutionFromRemoteVpc"] !== undefined) {
        contents.AllowDnsResolutionFromRemoteVpc =
            output["allowDnsResolutionFromRemoteVpc"] == "true";
    }
    if (output["allowEgressFromLocalClassicLinkToRemoteVpc"] !== undefined) {
        contents.AllowEgressFromLocalClassicLinkToRemoteVpc =
            output["allowEgressFromLocalClassicLinkToRemoteVpc"] == "true";
    }
    if (output["allowEgressFromLocalVpcToRemoteClassicLink"] !== undefined) {
        contents.AllowEgressFromLocalVpcToRemoteClassicLink =
            output["allowEgressFromLocalVpcToRemoteClassicLink"] == "true";
    }
    return contents;
};
const deserializeAws_ec2VpcPeeringConnectionStateReason = (output, context) => {
    let contents = {
        __type: "VpcPeeringConnectionStateReason",
        Code: undefined,
        Message: undefined
    };
    if (output["code"] !== undefined) {
        contents.Code = output["code"];
    }
    if (output["message"] !== undefined) {
        contents.Message = output["message"];
    }
    return contents;
};
const deserializeAws_ec2VpcPeeringConnectionVpcInfo = (output, context) => {
    let contents = {
        __type: "VpcPeeringConnectionVpcInfo",
        CidrBlock: undefined,
        CidrBlockSet: undefined,
        Ipv6CidrBlockSet: undefined,
        OwnerId: undefined,
        PeeringOptions: undefined,
        Region: undefined,
        VpcId: undefined
    };
    if (output["cidrBlock"] !== undefined) {
        contents.CidrBlock = output["cidrBlock"];
    }
    if (output.cidrBlockSet === "") {
        contents.CidrBlockSet = [];
    }
    if (output["cidrBlockSet"] !== undefined &&
        output["cidrBlockSet"]["item"] !== undefined) {
        const wrappedItem = output["cidrBlockSet"]["item"] instanceof Array
            ? output["cidrBlockSet"]["item"]
            : [output["cidrBlockSet"]["item"]];
        contents.CidrBlockSet = deserializeAws_ec2CidrBlockSet(wrappedItem, context);
    }
    if (output.ipv6CidrBlockSet === "") {
        contents.Ipv6CidrBlockSet = [];
    }
    if (output["ipv6CidrBlockSet"] !== undefined &&
        output["ipv6CidrBlockSet"]["item"] !== undefined) {
        const wrappedItem = output["ipv6CidrBlockSet"]["item"] instanceof Array
            ? output["ipv6CidrBlockSet"]["item"]
            : [output["ipv6CidrBlockSet"]["item"]];
        contents.Ipv6CidrBlockSet = deserializeAws_ec2Ipv6CidrBlockSet(wrappedItem, context);
    }
    if (output["ownerId"] !== undefined) {
        contents.OwnerId = output["ownerId"];
    }
    if (output["peeringOptions"] !== undefined) {
        contents.PeeringOptions = deserializeAws_ec2VpcPeeringConnectionOptionsDescription(output["peeringOptions"], context);
    }
    if (output["region"] !== undefined) {
        contents.Region = output["region"];
    }
    if (output["vpcId"] !== undefined) {
        contents.VpcId = output["vpcId"];
    }
    return contents;
};
const deserializeAws_ec2VpnConnection = (output, context) => {
    let contents = {
        __type: "VpnConnection",
        Category: undefined,
        CustomerGatewayConfiguration: undefined,
        CustomerGatewayId: undefined,
        Options: undefined,
        Routes: undefined,
        State: undefined,
        Tags: undefined,
        TransitGatewayId: undefined,
        Type: undefined,
        VgwTelemetry: undefined,
        VpnConnectionId: undefined,
        VpnGatewayId: undefined
    };
    if (output["category"] !== undefined) {
        contents.Category = output["category"];
    }
    if (output["customerGatewayConfiguration"] !== undefined) {
        contents.CustomerGatewayConfiguration =
            output["customerGatewayConfiguration"];
    }
    if (output["customerGatewayId"] !== undefined) {
        contents.CustomerGatewayId = output["customerGatewayId"];
    }
    if (output["options"] !== undefined) {
        contents.Options = deserializeAws_ec2VpnConnectionOptions(output["options"], context);
    }
    if (output.routes === "") {
        contents.Routes = [];
    }
    if (output["routes"] !== undefined &&
        output["routes"]["item"] !== undefined) {
        const wrappedItem = output["routes"]["item"] instanceof Array
            ? output["routes"]["item"]
            : [output["routes"]["item"]];
        contents.Routes = deserializeAws_ec2VpnStaticRouteList(wrappedItem, context);
    }
    if (output["state"] !== undefined) {
        contents.State = output["state"];
    }
    if (output.tagSet === "") {
        contents.Tags = [];
    }
    if (output["tagSet"] !== undefined &&
        output["tagSet"]["item"] !== undefined) {
        const wrappedItem = output["tagSet"]["item"] instanceof Array
            ? output["tagSet"]["item"]
            : [output["tagSet"]["item"]];
        contents.Tags = deserializeAws_ec2TagList(wrappedItem, context);
    }
    if (output["transitGatewayId"] !== undefined) {
        contents.TransitGatewayId = output["transitGatewayId"];
    }
    if (output["type"] !== undefined) {
        contents.Type = output["type"];
    }
    if (output.vgwTelemetry === "") {
        contents.VgwTelemetry = [];
    }
    if (output["vgwTelemetry"] !== undefined &&
        output["vgwTelemetry"]["item"] !== undefined) {
        const wrappedItem = output["vgwTelemetry"]["item"] instanceof Array
            ? output["vgwTelemetry"]["item"]
            : [output["vgwTelemetry"]["item"]];
        contents.VgwTelemetry = deserializeAws_ec2VgwTelemetryList(wrappedItem, context);
    }
    if (output["vpnConnectionId"] !== undefined) {
        contents.VpnConnectionId = output["vpnConnectionId"];
    }
    if (output["vpnGatewayId"] !== undefined) {
        contents.VpnGatewayId = output["vpnGatewayId"];
    }
    return contents;
};
const deserializeAws_ec2VpnConnectionList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2VpnConnection(entry, context));
    });
    return contents;
};
const deserializeAws_ec2VpnConnectionOptions = (output, context) => {
    let contents = {
        __type: "VpnConnectionOptions",
        EnableAcceleration: undefined,
        StaticRoutesOnly: undefined,
        TunnelOptions: undefined
    };
    if (output["enableAcceleration"] !== undefined) {
        contents.EnableAcceleration = output["enableAcceleration"] == "true";
    }
    if (output["staticRoutesOnly"] !== undefined) {
        contents.StaticRoutesOnly = output["staticRoutesOnly"] == "true";
    }
    if (output.tunnelOptionSet === "") {
        contents.TunnelOptions = [];
    }
    if (output["tunnelOptionSet"] !== undefined &&
        output["tunnelOptionSet"]["item"] !== undefined) {
        const wrappedItem = output["tunnelOptionSet"]["item"] instanceof Array
            ? output["tunnelOptionSet"]["item"]
            : [output["tunnelOptionSet"]["item"]];
        contents.TunnelOptions = deserializeAws_ec2TunnelOptionsList(wrappedItem, context);
    }
    return contents;
};
const deserializeAws_ec2VpnGateway = (output, context) => {
    let contents = {
        __type: "VpnGateway",
        AmazonSideAsn: undefined,
        AvailabilityZone: undefined,
        State: undefined,
        Tags: undefined,
        Type: undefined,
        VpcAttachments: undefined,
        VpnGatewayId: undefined
    };
    if (output["amazonSideAsn"] !== undefined) {
        contents.AmazonSideAsn = parseInt(output["amazonSideAsn"]);
    }
    if (output["availabilityZone"] !== undefined) {
        contents.AvailabilityZone = output["availabilityZone"];
    }
    if (output["state"] !== undefined) {
        contents.State = output["state"];
    }
    if (output.tagSet === "") {
        contents.Tags = [];
    }
    if (output["tagSet"] !== undefined &&
        output["tagSet"]["item"] !== undefined) {
        const wrappedItem = output["tagSet"]["item"] instanceof Array
            ? output["tagSet"]["item"]
            : [output["tagSet"]["item"]];
        contents.Tags = deserializeAws_ec2TagList(wrappedItem, context);
    }
    if (output["type"] !== undefined) {
        contents.Type = output["type"];
    }
    if (output.attachments === "") {
        contents.VpcAttachments = [];
    }
    if (output["attachments"] !== undefined &&
        output["attachments"]["item"] !== undefined) {
        const wrappedItem = output["attachments"]["item"] instanceof Array
            ? output["attachments"]["item"]
            : [output["attachments"]["item"]];
        contents.VpcAttachments = deserializeAws_ec2VpcAttachmentList(wrappedItem, context);
    }
    if (output["vpnGatewayId"] !== undefined) {
        contents.VpnGatewayId = output["vpnGatewayId"];
    }
    return contents;
};
const deserializeAws_ec2VpnGatewayList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2VpnGateway(entry, context));
    });
    return contents;
};
const deserializeAws_ec2VpnStaticRoute = (output, context) => {
    let contents = {
        __type: "VpnStaticRoute",
        DestinationCidrBlock: undefined,
        Source: undefined,
        State: undefined
    };
    if (output["destinationCidrBlock"] !== undefined) {
        contents.DestinationCidrBlock = output["destinationCidrBlock"];
    }
    if (output["source"] !== undefined) {
        contents.Source = output["source"];
    }
    if (output["state"] !== undefined) {
        contents.State = output["state"];
    }
    return contents;
};
const deserializeAws_ec2VpnStaticRouteList = (output, context) => {
    const contents = [];
    (output || []).map((entry) => {
        contents.push(deserializeAws_ec2VpnStaticRoute(entry, context));
    });
    return contents;
};
const deserializeAws_ec2WithdrawByoipCidrResult = (output, context) => {
    let contents = {
        __type: "WithdrawByoipCidrResult",
        ByoipCidr: undefined
    };
    if (output["byoipCidr"] !== undefined) {
        contents.ByoipCidr = deserializeAws_ec2ByoipCidr(output["byoipCidr"], context);
    }
    return contents;
};
const deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    httpHeaders: output.headers,
    requestId: output.headers["x-amzn-requestid"]
});
// Collect low-level response body stream to Uint8Array.
const collectBody = (streamBody, context) => {
    if (streamBody instanceof Uint8Array) {
        return Promise.resolve(streamBody);
    }
    return (context.streamCollector(streamBody) || Promise.resolve(new Uint8Array()));
};
// Encode Uint8Array data into string with utf-8.
const collectBodyString = (streamBody, context) => {
    return collectBody(streamBody, context).then(body => context.utf8Encoder(body));
};
const buildHttpRpcRequest = (context, headers, path, resolvedHostname, body) => {
    const contents = Object.assign(Object.assign({}, context.endpoint), { protocol: "https", method: "POST", path: path, headers: headers });
    if (resolvedHostname !== undefined) {
        contents.hostname = resolvedHostname;
    }
    if (body !== undefined) {
        contents.body = body;
    }
    return new protocol_http_1.HttpRequest(contents);
};
const decodeEscapedXML = (str) => {
    return str
        .replace(/&amp;/g, "&")
        .replace(/&apos;/g, "'")
        .replace(/&quot;/g, '"')
        .replace(/&gt;/g, ">")
        .replace(/&lt;/g, "<");
};
const parseBody = (streamBody, context) => {
    return collectBodyString(streamBody, context).then(encoded => {
        if (encoded.length) {
            const parsedObj = fast_xml_parser_1.parse(encoded, {
                attributeNamePrefix: "",
                ignoreAttributes: false,
                parseNodeValue: false,
                tagValueProcessor: (val, tagName) => decodeEscapedXML(val)
            });
            const textNodeName = "#text";
            const key = Object.keys(parsedObj)[0];
            const parsedObjToReturn = parsedObj[key];
            if (parsedObjToReturn[textNodeName]) {
                parsedObjToReturn[key] = parsedObjToReturn[textNodeName];
                delete parsedObjToReturn[textNodeName];
            }
            return parsedObjToReturn;
        }
        return {};
    });
};
const buildFormUrlencodedString = (entries) => {
    return Object.keys(entries)
        .map(key => smithy_client_1.extendedEncodeURIComponent(key) +
        "=" +
        smithy_client_1.extendedEncodeURIComponent(entries[key]))
        .join("&");
};
const loadEc2ErrorCode = (output, data) => {
    if (data.Errors.Error.Code !== undefined) {
        return data.Errors.Error.Code;
    }
    if (output.statusCode == 404) {
        return "NotFound";
    }
    return "";
};
//# sourceMappingURL=Aws_ec2.js.map