import {
  AcceptReservedNodeExchangeCommandInput,
  AcceptReservedNodeExchangeCommandOutput
} from "../commands/AcceptReservedNodeExchangeCommand";
import {
  AuthorizeClusterSecurityGroupIngressCommandInput,
  AuthorizeClusterSecurityGroupIngressCommandOutput
} from "../commands/AuthorizeClusterSecurityGroupIngressCommand";
import {
  AuthorizeSnapshotAccessCommandInput,
  AuthorizeSnapshotAccessCommandOutput
} from "../commands/AuthorizeSnapshotAccessCommand";
import {
  BatchDeleteClusterSnapshotsCommandInput,
  BatchDeleteClusterSnapshotsCommandOutput
} from "../commands/BatchDeleteClusterSnapshotsCommand";
import {
  BatchModifyClusterSnapshotsCommandInput,
  BatchModifyClusterSnapshotsCommandOutput
} from "../commands/BatchModifyClusterSnapshotsCommand";
import {
  CancelResizeCommandInput,
  CancelResizeCommandOutput
} from "../commands/CancelResizeCommand";
import {
  CopyClusterSnapshotCommandInput,
  CopyClusterSnapshotCommandOutput
} from "../commands/CopyClusterSnapshotCommand";
import {
  CreateClusterCommandInput,
  CreateClusterCommandOutput
} from "../commands/CreateClusterCommand";
import {
  CreateClusterParameterGroupCommandInput,
  CreateClusterParameterGroupCommandOutput
} from "../commands/CreateClusterParameterGroupCommand";
import {
  CreateClusterSecurityGroupCommandInput,
  CreateClusterSecurityGroupCommandOutput
} from "../commands/CreateClusterSecurityGroupCommand";
import {
  CreateClusterSnapshotCommandInput,
  CreateClusterSnapshotCommandOutput
} from "../commands/CreateClusterSnapshotCommand";
import {
  CreateClusterSubnetGroupCommandInput,
  CreateClusterSubnetGroupCommandOutput
} from "../commands/CreateClusterSubnetGroupCommand";
import {
  CreateEventSubscriptionCommandInput,
  CreateEventSubscriptionCommandOutput
} from "../commands/CreateEventSubscriptionCommand";
import {
  CreateHsmClientCertificateCommandInput,
  CreateHsmClientCertificateCommandOutput
} from "../commands/CreateHsmClientCertificateCommand";
import {
  CreateHsmConfigurationCommandInput,
  CreateHsmConfigurationCommandOutput
} from "../commands/CreateHsmConfigurationCommand";
import {
  CreateScheduledActionCommandInput,
  CreateScheduledActionCommandOutput
} from "../commands/CreateScheduledActionCommand";
import {
  CreateSnapshotCopyGrantCommandInput,
  CreateSnapshotCopyGrantCommandOutput
} from "../commands/CreateSnapshotCopyGrantCommand";
import {
  CreateSnapshotScheduleCommandInput,
  CreateSnapshotScheduleCommandOutput
} from "../commands/CreateSnapshotScheduleCommand";
import {
  CreateTagsCommandInput,
  CreateTagsCommandOutput
} from "../commands/CreateTagsCommand";
import {
  DeleteClusterCommandInput,
  DeleteClusterCommandOutput
} from "../commands/DeleteClusterCommand";
import {
  DeleteClusterParameterGroupCommandInput,
  DeleteClusterParameterGroupCommandOutput
} from "../commands/DeleteClusterParameterGroupCommand";
import {
  DeleteClusterSecurityGroupCommandInput,
  DeleteClusterSecurityGroupCommandOutput
} from "../commands/DeleteClusterSecurityGroupCommand";
import {
  DeleteClusterSnapshotCommandInput,
  DeleteClusterSnapshotCommandOutput
} from "../commands/DeleteClusterSnapshotCommand";
import {
  DeleteClusterSubnetGroupCommandInput,
  DeleteClusterSubnetGroupCommandOutput
} from "../commands/DeleteClusterSubnetGroupCommand";
import {
  DeleteEventSubscriptionCommandInput,
  DeleteEventSubscriptionCommandOutput
} from "../commands/DeleteEventSubscriptionCommand";
import {
  DeleteHsmClientCertificateCommandInput,
  DeleteHsmClientCertificateCommandOutput
} from "../commands/DeleteHsmClientCertificateCommand";
import {
  DeleteHsmConfigurationCommandInput,
  DeleteHsmConfigurationCommandOutput
} from "../commands/DeleteHsmConfigurationCommand";
import {
  DeleteScheduledActionCommandInput,
  DeleteScheduledActionCommandOutput
} from "../commands/DeleteScheduledActionCommand";
import {
  DeleteSnapshotCopyGrantCommandInput,
  DeleteSnapshotCopyGrantCommandOutput
} from "../commands/DeleteSnapshotCopyGrantCommand";
import {
  DeleteSnapshotScheduleCommandInput,
  DeleteSnapshotScheduleCommandOutput
} from "../commands/DeleteSnapshotScheduleCommand";
import {
  DeleteTagsCommandInput,
  DeleteTagsCommandOutput
} from "../commands/DeleteTagsCommand";
import {
  DescribeAccountAttributesCommandInput,
  DescribeAccountAttributesCommandOutput
} from "../commands/DescribeAccountAttributesCommand";
import {
  DescribeClusterDbRevisionsCommandInput,
  DescribeClusterDbRevisionsCommandOutput
} from "../commands/DescribeClusterDbRevisionsCommand";
import {
  DescribeClusterParameterGroupsCommandInput,
  DescribeClusterParameterGroupsCommandOutput
} from "../commands/DescribeClusterParameterGroupsCommand";
import {
  DescribeClusterParametersCommandInput,
  DescribeClusterParametersCommandOutput
} from "../commands/DescribeClusterParametersCommand";
import {
  DescribeClusterSecurityGroupsCommandInput,
  DescribeClusterSecurityGroupsCommandOutput
} from "../commands/DescribeClusterSecurityGroupsCommand";
import {
  DescribeClusterSnapshotsCommandInput,
  DescribeClusterSnapshotsCommandOutput
} from "../commands/DescribeClusterSnapshotsCommand";
import {
  DescribeClusterSubnetGroupsCommandInput,
  DescribeClusterSubnetGroupsCommandOutput
} from "../commands/DescribeClusterSubnetGroupsCommand";
import {
  DescribeClusterTracksCommandInput,
  DescribeClusterTracksCommandOutput
} from "../commands/DescribeClusterTracksCommand";
import {
  DescribeClusterVersionsCommandInput,
  DescribeClusterVersionsCommandOutput
} from "../commands/DescribeClusterVersionsCommand";
import {
  DescribeClustersCommandInput,
  DescribeClustersCommandOutput
} from "../commands/DescribeClustersCommand";
import {
  DescribeDefaultClusterParametersCommandInput,
  DescribeDefaultClusterParametersCommandOutput
} from "../commands/DescribeDefaultClusterParametersCommand";
import {
  DescribeEventCategoriesCommandInput,
  DescribeEventCategoriesCommandOutput
} from "../commands/DescribeEventCategoriesCommand";
import {
  DescribeEventSubscriptionsCommandInput,
  DescribeEventSubscriptionsCommandOutput
} from "../commands/DescribeEventSubscriptionsCommand";
import {
  DescribeEventsCommandInput,
  DescribeEventsCommandOutput
} from "../commands/DescribeEventsCommand";
import {
  DescribeHsmClientCertificatesCommandInput,
  DescribeHsmClientCertificatesCommandOutput
} from "../commands/DescribeHsmClientCertificatesCommand";
import {
  DescribeHsmConfigurationsCommandInput,
  DescribeHsmConfigurationsCommandOutput
} from "../commands/DescribeHsmConfigurationsCommand";
import {
  DescribeLoggingStatusCommandInput,
  DescribeLoggingStatusCommandOutput
} from "../commands/DescribeLoggingStatusCommand";
import {
  DescribeNodeConfigurationOptionsCommandInput,
  DescribeNodeConfigurationOptionsCommandOutput
} from "../commands/DescribeNodeConfigurationOptionsCommand";
import {
  DescribeOrderableClusterOptionsCommandInput,
  DescribeOrderableClusterOptionsCommandOutput
} from "../commands/DescribeOrderableClusterOptionsCommand";
import {
  DescribeReservedNodeOfferingsCommandInput,
  DescribeReservedNodeOfferingsCommandOutput
} from "../commands/DescribeReservedNodeOfferingsCommand";
import {
  DescribeReservedNodesCommandInput,
  DescribeReservedNodesCommandOutput
} from "../commands/DescribeReservedNodesCommand";
import {
  DescribeResizeCommandInput,
  DescribeResizeCommandOutput
} from "../commands/DescribeResizeCommand";
import {
  DescribeScheduledActionsCommandInput,
  DescribeScheduledActionsCommandOutput
} from "../commands/DescribeScheduledActionsCommand";
import {
  DescribeSnapshotCopyGrantsCommandInput,
  DescribeSnapshotCopyGrantsCommandOutput
} from "../commands/DescribeSnapshotCopyGrantsCommand";
import {
  DescribeSnapshotSchedulesCommandInput,
  DescribeSnapshotSchedulesCommandOutput
} from "../commands/DescribeSnapshotSchedulesCommand";
import {
  DescribeStorageCommandInput,
  DescribeStorageCommandOutput
} from "../commands/DescribeStorageCommand";
import {
  DescribeTableRestoreStatusCommandInput,
  DescribeTableRestoreStatusCommandOutput
} from "../commands/DescribeTableRestoreStatusCommand";
import {
  DescribeTagsCommandInput,
  DescribeTagsCommandOutput
} from "../commands/DescribeTagsCommand";
import {
  DisableLoggingCommandInput,
  DisableLoggingCommandOutput
} from "../commands/DisableLoggingCommand";
import {
  DisableSnapshotCopyCommandInput,
  DisableSnapshotCopyCommandOutput
} from "../commands/DisableSnapshotCopyCommand";
import {
  EnableLoggingCommandInput,
  EnableLoggingCommandOutput
} from "../commands/EnableLoggingCommand";
import {
  EnableSnapshotCopyCommandInput,
  EnableSnapshotCopyCommandOutput
} from "../commands/EnableSnapshotCopyCommand";
import {
  GetClusterCredentialsCommandInput,
  GetClusterCredentialsCommandOutput
} from "../commands/GetClusterCredentialsCommand";
import {
  GetReservedNodeExchangeOfferingsCommandInput,
  GetReservedNodeExchangeOfferingsCommandOutput
} from "../commands/GetReservedNodeExchangeOfferingsCommand";
import {
  ModifyClusterCommandInput,
  ModifyClusterCommandOutput
} from "../commands/ModifyClusterCommand";
import {
  ModifyClusterDbRevisionCommandInput,
  ModifyClusterDbRevisionCommandOutput
} from "../commands/ModifyClusterDbRevisionCommand";
import {
  ModifyClusterIamRolesCommandInput,
  ModifyClusterIamRolesCommandOutput
} from "../commands/ModifyClusterIamRolesCommand";
import {
  ModifyClusterMaintenanceCommandInput,
  ModifyClusterMaintenanceCommandOutput
} from "../commands/ModifyClusterMaintenanceCommand";
import {
  ModifyClusterParameterGroupCommandInput,
  ModifyClusterParameterGroupCommandOutput
} from "../commands/ModifyClusterParameterGroupCommand";
import {
  ModifyClusterSnapshotCommandInput,
  ModifyClusterSnapshotCommandOutput
} from "../commands/ModifyClusterSnapshotCommand";
import {
  ModifyClusterSnapshotScheduleCommandInput,
  ModifyClusterSnapshotScheduleCommandOutput
} from "../commands/ModifyClusterSnapshotScheduleCommand";
import {
  ModifyClusterSubnetGroupCommandInput,
  ModifyClusterSubnetGroupCommandOutput
} from "../commands/ModifyClusterSubnetGroupCommand";
import {
  ModifyEventSubscriptionCommandInput,
  ModifyEventSubscriptionCommandOutput
} from "../commands/ModifyEventSubscriptionCommand";
import {
  ModifyScheduledActionCommandInput,
  ModifyScheduledActionCommandOutput
} from "../commands/ModifyScheduledActionCommand";
import {
  ModifySnapshotCopyRetentionPeriodCommandInput,
  ModifySnapshotCopyRetentionPeriodCommandOutput
} from "../commands/ModifySnapshotCopyRetentionPeriodCommand";
import {
  ModifySnapshotScheduleCommandInput,
  ModifySnapshotScheduleCommandOutput
} from "../commands/ModifySnapshotScheduleCommand";
import {
  PurchaseReservedNodeOfferingCommandInput,
  PurchaseReservedNodeOfferingCommandOutput
} from "../commands/PurchaseReservedNodeOfferingCommand";
import {
  RebootClusterCommandInput,
  RebootClusterCommandOutput
} from "../commands/RebootClusterCommand";
import {
  ResetClusterParameterGroupCommandInput,
  ResetClusterParameterGroupCommandOutput
} from "../commands/ResetClusterParameterGroupCommand";
import {
  ResizeClusterCommandInput,
  ResizeClusterCommandOutput
} from "../commands/ResizeClusterCommand";
import {
  RestoreFromClusterSnapshotCommandInput,
  RestoreFromClusterSnapshotCommandOutput
} from "../commands/RestoreFromClusterSnapshotCommand";
import {
  RestoreTableFromClusterSnapshotCommandInput,
  RestoreTableFromClusterSnapshotCommandOutput
} from "../commands/RestoreTableFromClusterSnapshotCommand";
import {
  RevokeClusterSecurityGroupIngressCommandInput,
  RevokeClusterSecurityGroupIngressCommandOutput
} from "../commands/RevokeClusterSecurityGroupIngressCommand";
import {
  RevokeSnapshotAccessCommandInput,
  RevokeSnapshotAccessCommandOutput
} from "../commands/RevokeSnapshotAccessCommand";
import {
  RotateEncryptionKeyCommandInput,
  RotateEncryptionKeyCommandOutput
} from "../commands/RotateEncryptionKeyCommand";
import {
  AcceptReservedNodeExchangeInputMessage,
  AcceptReservedNodeExchangeOutputMessage,
  AccessToSnapshotDeniedFault,
  AccountAttribute,
  AccountAttributeList,
  AccountWithRestoreAccess,
  AttributeValueTarget,
  AuthorizationAlreadyExistsFault,
  AuthorizationNotFoundFault,
  AuthorizationQuotaExceededFault,
  AuthorizeClusterSecurityGroupIngressMessage,
  AuthorizeClusterSecurityGroupIngressResult,
  AuthorizeSnapshotAccessMessage,
  AuthorizeSnapshotAccessResult,
  AvailabilityZone,
  BatchDeleteClusterSnapshotsRequest,
  BatchDeleteClusterSnapshotsResult,
  BatchDeleteRequestSizeExceededFault,
  BatchModifyClusterSnapshotsLimitExceededFault,
  BatchModifyClusterSnapshotsMessage,
  BatchModifyClusterSnapshotsOutputMessage,
  BucketNotFoundFault,
  CancelResizeMessage,
  Cluster,
  ClusterAlreadyExistsFault,
  ClusterAssociatedToSchedule,
  ClusterCredentials,
  ClusterDbRevision,
  ClusterDbRevisionsMessage,
  ClusterIamRole,
  ClusterNode,
  ClusterNotFoundFault,
  ClusterOnLatestRevisionFault,
  ClusterParameterGroup,
  ClusterParameterGroupAlreadyExistsFault,
  ClusterParameterGroupDetails,
  ClusterParameterGroupNameMessage,
  ClusterParameterGroupNotFoundFault,
  ClusterParameterGroupQuotaExceededFault,
  ClusterParameterGroupStatus,
  ClusterParameterGroupsMessage,
  ClusterParameterStatus,
  ClusterQuotaExceededFault,
  ClusterSecurityGroup,
  ClusterSecurityGroupAlreadyExistsFault,
  ClusterSecurityGroupMembership,
  ClusterSecurityGroupMessage,
  ClusterSecurityGroupNotFoundFault,
  ClusterSecurityGroupQuotaExceededFault,
  ClusterSnapshotAlreadyExistsFault,
  ClusterSnapshotCopyStatus,
  ClusterSnapshotNotFoundFault,
  ClusterSnapshotQuotaExceededFault,
  ClusterSubnetGroup,
  ClusterSubnetGroupAlreadyExistsFault,
  ClusterSubnetGroupMessage,
  ClusterSubnetGroupNotFoundFault,
  ClusterSubnetGroupQuotaExceededFault,
  ClusterSubnetQuotaExceededFault,
  ClusterVersion,
  ClusterVersionsMessage,
  ClustersMessage,
  CopyClusterSnapshotMessage,
  CopyClusterSnapshotResult,
  CopyToRegionDisabledFault,
  CreateClusterMessage,
  CreateClusterParameterGroupMessage,
  CreateClusterParameterGroupResult,
  CreateClusterResult,
  CreateClusterSecurityGroupMessage,
  CreateClusterSecurityGroupResult,
  CreateClusterSnapshotMessage,
  CreateClusterSnapshotResult,
  CreateClusterSubnetGroupMessage,
  CreateClusterSubnetGroupResult,
  CreateEventSubscriptionMessage,
  CreateEventSubscriptionResult,
  CreateHsmClientCertificateMessage,
  CreateHsmClientCertificateResult,
  CreateHsmConfigurationMessage,
  CreateHsmConfigurationResult,
  CreateScheduledActionMessage,
  CreateSnapshotCopyGrantMessage,
  CreateSnapshotCopyGrantResult,
  CreateSnapshotScheduleMessage,
  CreateTagsMessage,
  CustomerStorageMessage,
  DataTransferProgress,
  DefaultClusterParameters,
  DeferredMaintenanceWindow,
  DeleteClusterMessage,
  DeleteClusterParameterGroupMessage,
  DeleteClusterResult,
  DeleteClusterSecurityGroupMessage,
  DeleteClusterSnapshotMessage,
  DeleteClusterSnapshotResult,
  DeleteClusterSubnetGroupMessage,
  DeleteEventSubscriptionMessage,
  DeleteHsmClientCertificateMessage,
  DeleteHsmConfigurationMessage,
  DeleteScheduledActionMessage,
  DeleteSnapshotCopyGrantMessage,
  DeleteSnapshotScheduleMessage,
  DeleteTagsMessage,
  DependentServiceRequestThrottlingFault,
  DependentServiceUnavailableFault,
  DescribeAccountAttributesMessage,
  DescribeClusterDbRevisionsMessage,
  DescribeClusterParameterGroupsMessage,
  DescribeClusterParametersMessage,
  DescribeClusterSecurityGroupsMessage,
  DescribeClusterSnapshotsMessage,
  DescribeClusterSubnetGroupsMessage,
  DescribeClusterTracksMessage,
  DescribeClusterVersionsMessage,
  DescribeClustersMessage,
  DescribeDefaultClusterParametersMessage,
  DescribeDefaultClusterParametersResult,
  DescribeEventCategoriesMessage,
  DescribeEventSubscriptionsMessage,
  DescribeEventsMessage,
  DescribeHsmClientCertificatesMessage,
  DescribeHsmConfigurationsMessage,
  DescribeLoggingStatusMessage,
  DescribeNodeConfigurationOptionsMessage,
  DescribeOrderableClusterOptionsMessage,
  DescribeReservedNodeOfferingsMessage,
  DescribeReservedNodesMessage,
  DescribeResizeMessage,
  DescribeScheduledActionsMessage,
  DescribeSnapshotCopyGrantsMessage,
  DescribeSnapshotSchedulesMessage,
  DescribeSnapshotSchedulesOutputMessage,
  DescribeTableRestoreStatusMessage,
  DescribeTagsMessage,
  DisableLoggingMessage,
  DisableSnapshotCopyMessage,
  DisableSnapshotCopyResult,
  EC2SecurityGroup,
  ElasticIpStatus,
  EnableLoggingMessage,
  EnableSnapshotCopyMessage,
  EnableSnapshotCopyResult,
  Endpoint,
  Event,
  EventCategoriesMap,
  EventCategoriesMessage,
  EventInfoMap,
  EventSubscription,
  EventSubscriptionQuotaExceededFault,
  EventSubscriptionsMessage,
  EventsMessage,
  GetClusterCredentialsMessage,
  GetReservedNodeExchangeOfferingsInputMessage,
  GetReservedNodeExchangeOfferingsOutputMessage,
  HsmClientCertificate,
  HsmClientCertificateAlreadyExistsFault,
  HsmClientCertificateMessage,
  HsmClientCertificateNotFoundFault,
  HsmClientCertificateQuotaExceededFault,
  HsmConfiguration,
  HsmConfigurationAlreadyExistsFault,
  HsmConfigurationMessage,
  HsmConfigurationNotFoundFault,
  HsmConfigurationQuotaExceededFault,
  HsmStatus,
  IPRange,
  InProgressTableRestoreQuotaExceededFault,
  IncompatibleOrderableOptions,
  InsufficientClusterCapacityFault,
  InsufficientS3BucketPolicyFault,
  InvalidClusterParameterGroupStateFault,
  InvalidClusterSecurityGroupStateFault,
  InvalidClusterSnapshotScheduleStateFault,
  InvalidClusterSnapshotStateFault,
  InvalidClusterStateFault,
  InvalidClusterSubnetGroupStateFault,
  InvalidClusterSubnetStateFault,
  InvalidClusterTrackFault,
  InvalidElasticIpFault,
  InvalidHsmClientCertificateStateFault,
  InvalidHsmConfigurationStateFault,
  InvalidReservedNodeStateFault,
  InvalidRestoreFault,
  InvalidRetentionPeriodFault,
  InvalidS3BucketNameFault,
  InvalidS3KeyPrefixFault,
  InvalidScheduleFault,
  InvalidScheduledActionFault,
  InvalidSnapshotCopyGrantStateFault,
  InvalidSubnet,
  InvalidSubscriptionStateFault,
  InvalidTableRestoreArgumentFault,
  InvalidTagFault,
  InvalidVPCNetworkStateFault,
  LimitExceededFault,
  LoggingStatus,
  MaintenanceTrack,
  ModifyClusterDbRevisionMessage,
  ModifyClusterDbRevisionResult,
  ModifyClusterIamRolesMessage,
  ModifyClusterIamRolesResult,
  ModifyClusterMaintenanceMessage,
  ModifyClusterMaintenanceResult,
  ModifyClusterMessage,
  ModifyClusterParameterGroupMessage,
  ModifyClusterResult,
  ModifyClusterSnapshotMessage,
  ModifyClusterSnapshotResult,
  ModifyClusterSnapshotScheduleMessage,
  ModifyClusterSubnetGroupMessage,
  ModifyClusterSubnetGroupResult,
  ModifyEventSubscriptionMessage,
  ModifyEventSubscriptionResult,
  ModifyScheduledActionMessage,
  ModifySnapshotCopyRetentionPeriodMessage,
  ModifySnapshotCopyRetentionPeriodResult,
  ModifySnapshotScheduleMessage,
  NodeConfigurationOption,
  NodeConfigurationOptionsFilter,
  NodeConfigurationOptionsMessage,
  NumberOfNodesPerClusterLimitExceededFault,
  NumberOfNodesQuotaExceededFault,
  OrderableClusterOption,
  OrderableClusterOptionsMessage,
  Parameter,
  PendingModifiedValues,
  PurchaseReservedNodeOfferingMessage,
  PurchaseReservedNodeOfferingResult,
  RebootClusterMessage,
  RebootClusterResult,
  RecurringCharge,
  ReservedNode,
  ReservedNodeAlreadyExistsFault,
  ReservedNodeAlreadyMigratedFault,
  ReservedNodeNotFoundFault,
  ReservedNodeOffering,
  ReservedNodeOfferingNotFoundFault,
  ReservedNodeOfferingsMessage,
  ReservedNodeQuotaExceededFault,
  ReservedNodesMessage,
  ResetClusterParameterGroupMessage,
  ResizeClusterMessage,
  ResizeClusterResult,
  ResizeInfo,
  ResizeNotFoundFault,
  ResizeProgressMessage,
  ResourceNotFoundFault,
  RestoreFromClusterSnapshotMessage,
  RestoreFromClusterSnapshotResult,
  RestoreStatus,
  RestoreTableFromClusterSnapshotMessage,
  RestoreTableFromClusterSnapshotResult,
  RevisionTarget,
  RevokeClusterSecurityGroupIngressMessage,
  RevokeClusterSecurityGroupIngressResult,
  RevokeSnapshotAccessMessage,
  RevokeSnapshotAccessResult,
  RotateEncryptionKeyMessage,
  RotateEncryptionKeyResult,
  SNSInvalidTopicFault,
  SNSNoAuthorizationFault,
  SNSTopicArnNotFoundFault,
  ScheduleDefinitionTypeUnsupportedFault,
  ScheduledAction,
  ScheduledActionAlreadyExistsFault,
  ScheduledActionFilter,
  ScheduledActionNotFoundFault,
  ScheduledActionQuotaExceededFault,
  ScheduledActionType,
  ScheduledActionTypeUnsupportedFault,
  ScheduledActionsMessage,
  Snapshot,
  SnapshotCopyAlreadyDisabledFault,
  SnapshotCopyAlreadyEnabledFault,
  SnapshotCopyDisabledFault,
  SnapshotCopyGrant,
  SnapshotCopyGrantAlreadyExistsFault,
  SnapshotCopyGrantMessage,
  SnapshotCopyGrantNotFoundFault,
  SnapshotCopyGrantQuotaExceededFault,
  SnapshotErrorMessage,
  SnapshotMessage,
  SnapshotSchedule,
  SnapshotScheduleAlreadyExistsFault,
  SnapshotScheduleNotFoundFault,
  SnapshotScheduleQuotaExceededFault,
  SnapshotScheduleUpdateInProgressFault,
  SnapshotSortingEntity,
  SourceNotFoundFault,
  Subnet,
  SubnetAlreadyInUse,
  SubscriptionAlreadyExistFault,
  SubscriptionCategoryNotFoundFault,
  SubscriptionEventIdNotFoundFault,
  SubscriptionNotFoundFault,
  SubscriptionSeverityNotFoundFault,
  SupportedOperation,
  SupportedPlatform,
  TableLimitExceededFault,
  TableRestoreNotFoundFault,
  TableRestoreStatus,
  TableRestoreStatusMessage,
  Tag,
  TagLimitExceededFault,
  TaggedResource,
  TaggedResourceListMessage,
  TrackListMessage,
  UnauthorizedOperation,
  UnknownSnapshotCopyRegionFault,
  UnsupportedOperationFault,
  UnsupportedOptionFault,
  UpdateTarget,
  VpcSecurityGroupMembership
} from "../models/index";
import {
  HttpRequest as __HttpRequest,
  HttpResponse as __HttpResponse
} from "@aws-sdk/protocol-http";
import {
  SmithyException as __SmithyException,
  extendedEncodeURIComponent as __extendedEncodeURIComponent
} from "@aws-sdk/smithy-client";
import {
  Endpoint as __Endpoint,
  HeaderBag as __HeaderBag,
  MetadataBearer as __MetadataBearer,
  ResponseMetadata as __ResponseMetadata,
  SerdeContext as __SerdeContext
} from "@aws-sdk/types";
import { parse as xmlParse } from "fast-xml-parser";

export async function serializeAws_queryAcceptReservedNodeExchangeCommand(
  input: AcceptReservedNodeExchangeCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryAcceptReservedNodeExchangeInputMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "AcceptReservedNodeExchange",
    Version: "2012-12-01"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_queryAuthorizeClusterSecurityGroupIngressCommand(
  input: AuthorizeClusterSecurityGroupIngressCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryAuthorizeClusterSecurityGroupIngressMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "AuthorizeClusterSecurityGroupIngress",
    Version: "2012-12-01"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_queryAuthorizeSnapshotAccessCommand(
  input: AuthorizeSnapshotAccessCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryAuthorizeSnapshotAccessMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "AuthorizeSnapshotAccess",
    Version: "2012-12-01"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_queryBatchDeleteClusterSnapshotsCommand(
  input: BatchDeleteClusterSnapshotsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryBatchDeleteClusterSnapshotsRequest(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "BatchDeleteClusterSnapshots",
    Version: "2012-12-01"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_queryBatchModifyClusterSnapshotsCommand(
  input: BatchModifyClusterSnapshotsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryBatchModifyClusterSnapshotsMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "BatchModifyClusterSnapshots",
    Version: "2012-12-01"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_queryCancelResizeCommand(
  input: CancelResizeCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryCancelResizeMessage(input, context);
  body = buildFormUrlencodedString({
    ...entries,
    Action: "CancelResize",
    Version: "2012-12-01"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_queryCopyClusterSnapshotCommand(
  input: CopyClusterSnapshotCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryCopyClusterSnapshotMessage(input, context);
  body = buildFormUrlencodedString({
    ...entries,
    Action: "CopyClusterSnapshot",
    Version: "2012-12-01"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_queryCreateClusterCommand(
  input: CreateClusterCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryCreateClusterMessage(input, context);
  body = buildFormUrlencodedString({
    ...entries,
    Action: "CreateCluster",
    Version: "2012-12-01"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_queryCreateClusterParameterGroupCommand(
  input: CreateClusterParameterGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryCreateClusterParameterGroupMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "CreateClusterParameterGroup",
    Version: "2012-12-01"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_queryCreateClusterSecurityGroupCommand(
  input: CreateClusterSecurityGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryCreateClusterSecurityGroupMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "CreateClusterSecurityGroup",
    Version: "2012-12-01"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_queryCreateClusterSnapshotCommand(
  input: CreateClusterSnapshotCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryCreateClusterSnapshotMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "CreateClusterSnapshot",
    Version: "2012-12-01"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_queryCreateClusterSubnetGroupCommand(
  input: CreateClusterSubnetGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryCreateClusterSubnetGroupMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "CreateClusterSubnetGroup",
    Version: "2012-12-01"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_queryCreateEventSubscriptionCommand(
  input: CreateEventSubscriptionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryCreateEventSubscriptionMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "CreateEventSubscription",
    Version: "2012-12-01"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_queryCreateHsmClientCertificateCommand(
  input: CreateHsmClientCertificateCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryCreateHsmClientCertificateMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "CreateHsmClientCertificate",
    Version: "2012-12-01"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_queryCreateHsmConfigurationCommand(
  input: CreateHsmConfigurationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryCreateHsmConfigurationMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "CreateHsmConfiguration",
    Version: "2012-12-01"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_queryCreateScheduledActionCommand(
  input: CreateScheduledActionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryCreateScheduledActionMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "CreateScheduledAction",
    Version: "2012-12-01"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_queryCreateSnapshotCopyGrantCommand(
  input: CreateSnapshotCopyGrantCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryCreateSnapshotCopyGrantMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "CreateSnapshotCopyGrant",
    Version: "2012-12-01"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_queryCreateSnapshotScheduleCommand(
  input: CreateSnapshotScheduleCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryCreateSnapshotScheduleMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "CreateSnapshotSchedule",
    Version: "2012-12-01"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_queryCreateTagsCommand(
  input: CreateTagsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryCreateTagsMessage(input, context);
  body = buildFormUrlencodedString({
    ...entries,
    Action: "CreateTags",
    Version: "2012-12-01"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_queryDeleteClusterCommand(
  input: DeleteClusterCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryDeleteClusterMessage(input, context);
  body = buildFormUrlencodedString({
    ...entries,
    Action: "DeleteCluster",
    Version: "2012-12-01"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_queryDeleteClusterParameterGroupCommand(
  input: DeleteClusterParameterGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryDeleteClusterParameterGroupMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "DeleteClusterParameterGroup",
    Version: "2012-12-01"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_queryDeleteClusterSecurityGroupCommand(
  input: DeleteClusterSecurityGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryDeleteClusterSecurityGroupMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "DeleteClusterSecurityGroup",
    Version: "2012-12-01"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_queryDeleteClusterSnapshotCommand(
  input: DeleteClusterSnapshotCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryDeleteClusterSnapshotMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "DeleteClusterSnapshot",
    Version: "2012-12-01"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_queryDeleteClusterSubnetGroupCommand(
  input: DeleteClusterSubnetGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryDeleteClusterSubnetGroupMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "DeleteClusterSubnetGroup",
    Version: "2012-12-01"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_queryDeleteEventSubscriptionCommand(
  input: DeleteEventSubscriptionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryDeleteEventSubscriptionMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "DeleteEventSubscription",
    Version: "2012-12-01"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_queryDeleteHsmClientCertificateCommand(
  input: DeleteHsmClientCertificateCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryDeleteHsmClientCertificateMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "DeleteHsmClientCertificate",
    Version: "2012-12-01"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_queryDeleteHsmConfigurationCommand(
  input: DeleteHsmConfigurationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryDeleteHsmConfigurationMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "DeleteHsmConfiguration",
    Version: "2012-12-01"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_queryDeleteScheduledActionCommand(
  input: DeleteScheduledActionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryDeleteScheduledActionMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "DeleteScheduledAction",
    Version: "2012-12-01"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_queryDeleteSnapshotCopyGrantCommand(
  input: DeleteSnapshotCopyGrantCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryDeleteSnapshotCopyGrantMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "DeleteSnapshotCopyGrant",
    Version: "2012-12-01"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_queryDeleteSnapshotScheduleCommand(
  input: DeleteSnapshotScheduleCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryDeleteSnapshotScheduleMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "DeleteSnapshotSchedule",
    Version: "2012-12-01"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_queryDeleteTagsCommand(
  input: DeleteTagsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryDeleteTagsMessage(input, context);
  body = buildFormUrlencodedString({
    ...entries,
    Action: "DeleteTags",
    Version: "2012-12-01"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_queryDescribeAccountAttributesCommand(
  input: DescribeAccountAttributesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryDescribeAccountAttributesMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "DescribeAccountAttributes",
    Version: "2012-12-01"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_queryDescribeClusterDbRevisionsCommand(
  input: DescribeClusterDbRevisionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryDescribeClusterDbRevisionsMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "DescribeClusterDbRevisions",
    Version: "2012-12-01"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_queryDescribeClusterParameterGroupsCommand(
  input: DescribeClusterParameterGroupsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryDescribeClusterParameterGroupsMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "DescribeClusterParameterGroups",
    Version: "2012-12-01"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_queryDescribeClusterParametersCommand(
  input: DescribeClusterParametersCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryDescribeClusterParametersMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "DescribeClusterParameters",
    Version: "2012-12-01"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_queryDescribeClusterSecurityGroupsCommand(
  input: DescribeClusterSecurityGroupsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryDescribeClusterSecurityGroupsMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "DescribeClusterSecurityGroups",
    Version: "2012-12-01"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_queryDescribeClusterSnapshotsCommand(
  input: DescribeClusterSnapshotsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryDescribeClusterSnapshotsMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "DescribeClusterSnapshots",
    Version: "2012-12-01"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_queryDescribeClusterSubnetGroupsCommand(
  input: DescribeClusterSubnetGroupsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryDescribeClusterSubnetGroupsMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "DescribeClusterSubnetGroups",
    Version: "2012-12-01"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_queryDescribeClusterTracksCommand(
  input: DescribeClusterTracksCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryDescribeClusterTracksMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "DescribeClusterTracks",
    Version: "2012-12-01"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_queryDescribeClusterVersionsCommand(
  input: DescribeClusterVersionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryDescribeClusterVersionsMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "DescribeClusterVersions",
    Version: "2012-12-01"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_queryDescribeClustersCommand(
  input: DescribeClustersCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryDescribeClustersMessage(input, context);
  body = buildFormUrlencodedString({
    ...entries,
    Action: "DescribeClusters",
    Version: "2012-12-01"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_queryDescribeDefaultClusterParametersCommand(
  input: DescribeDefaultClusterParametersCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryDescribeDefaultClusterParametersMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "DescribeDefaultClusterParameters",
    Version: "2012-12-01"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_queryDescribeEventCategoriesCommand(
  input: DescribeEventCategoriesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryDescribeEventCategoriesMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "DescribeEventCategories",
    Version: "2012-12-01"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_queryDescribeEventSubscriptionsCommand(
  input: DescribeEventSubscriptionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryDescribeEventSubscriptionsMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "DescribeEventSubscriptions",
    Version: "2012-12-01"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_queryDescribeEventsCommand(
  input: DescribeEventsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryDescribeEventsMessage(input, context);
  body = buildFormUrlencodedString({
    ...entries,
    Action: "DescribeEvents",
    Version: "2012-12-01"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_queryDescribeHsmClientCertificatesCommand(
  input: DescribeHsmClientCertificatesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryDescribeHsmClientCertificatesMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "DescribeHsmClientCertificates",
    Version: "2012-12-01"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_queryDescribeHsmConfigurationsCommand(
  input: DescribeHsmConfigurationsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryDescribeHsmConfigurationsMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "DescribeHsmConfigurations",
    Version: "2012-12-01"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_queryDescribeLoggingStatusCommand(
  input: DescribeLoggingStatusCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryDescribeLoggingStatusMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "DescribeLoggingStatus",
    Version: "2012-12-01"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_queryDescribeNodeConfigurationOptionsCommand(
  input: DescribeNodeConfigurationOptionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryDescribeNodeConfigurationOptionsMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "DescribeNodeConfigurationOptions",
    Version: "2012-12-01"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_queryDescribeOrderableClusterOptionsCommand(
  input: DescribeOrderableClusterOptionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryDescribeOrderableClusterOptionsMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "DescribeOrderableClusterOptions",
    Version: "2012-12-01"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_queryDescribeReservedNodeOfferingsCommand(
  input: DescribeReservedNodeOfferingsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryDescribeReservedNodeOfferingsMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "DescribeReservedNodeOfferings",
    Version: "2012-12-01"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_queryDescribeReservedNodesCommand(
  input: DescribeReservedNodesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryDescribeReservedNodesMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "DescribeReservedNodes",
    Version: "2012-12-01"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_queryDescribeResizeCommand(
  input: DescribeResizeCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryDescribeResizeMessage(input, context);
  body = buildFormUrlencodedString({
    ...entries,
    Action: "DescribeResize",
    Version: "2012-12-01"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_queryDescribeScheduledActionsCommand(
  input: DescribeScheduledActionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryDescribeScheduledActionsMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "DescribeScheduledActions",
    Version: "2012-12-01"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_queryDescribeSnapshotCopyGrantsCommand(
  input: DescribeSnapshotCopyGrantsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryDescribeSnapshotCopyGrantsMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "DescribeSnapshotCopyGrants",
    Version: "2012-12-01"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_queryDescribeSnapshotSchedulesCommand(
  input: DescribeSnapshotSchedulesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryDescribeSnapshotSchedulesMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "DescribeSnapshotSchedules",
    Version: "2012-12-01"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_queryDescribeStorageCommand(
  input: DescribeStorageCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  const body = buildFormUrlencodedString({
    Action: "DescribeStorage",
    Version: "2012-12-01"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_queryDescribeTableRestoreStatusCommand(
  input: DescribeTableRestoreStatusCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryDescribeTableRestoreStatusMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "DescribeTableRestoreStatus",
    Version: "2012-12-01"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_queryDescribeTagsCommand(
  input: DescribeTagsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryDescribeTagsMessage(input, context);
  body = buildFormUrlencodedString({
    ...entries,
    Action: "DescribeTags",
    Version: "2012-12-01"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_queryDisableLoggingCommand(
  input: DisableLoggingCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryDisableLoggingMessage(input, context);
  body = buildFormUrlencodedString({
    ...entries,
    Action: "DisableLogging",
    Version: "2012-12-01"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_queryDisableSnapshotCopyCommand(
  input: DisableSnapshotCopyCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryDisableSnapshotCopyMessage(input, context);
  body = buildFormUrlencodedString({
    ...entries,
    Action: "DisableSnapshotCopy",
    Version: "2012-12-01"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_queryEnableLoggingCommand(
  input: EnableLoggingCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryEnableLoggingMessage(input, context);
  body = buildFormUrlencodedString({
    ...entries,
    Action: "EnableLogging",
    Version: "2012-12-01"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_queryEnableSnapshotCopyCommand(
  input: EnableSnapshotCopyCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryEnableSnapshotCopyMessage(input, context);
  body = buildFormUrlencodedString({
    ...entries,
    Action: "EnableSnapshotCopy",
    Version: "2012-12-01"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_queryGetClusterCredentialsCommand(
  input: GetClusterCredentialsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryGetClusterCredentialsMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "GetClusterCredentials",
    Version: "2012-12-01"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_queryGetReservedNodeExchangeOfferingsCommand(
  input: GetReservedNodeExchangeOfferingsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryGetReservedNodeExchangeOfferingsInputMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "GetReservedNodeExchangeOfferings",
    Version: "2012-12-01"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_queryModifyClusterCommand(
  input: ModifyClusterCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryModifyClusterMessage(input, context);
  body = buildFormUrlencodedString({
    ...entries,
    Action: "ModifyCluster",
    Version: "2012-12-01"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_queryModifyClusterDbRevisionCommand(
  input: ModifyClusterDbRevisionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryModifyClusterDbRevisionMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "ModifyClusterDbRevision",
    Version: "2012-12-01"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_queryModifyClusterIamRolesCommand(
  input: ModifyClusterIamRolesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryModifyClusterIamRolesMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "ModifyClusterIamRoles",
    Version: "2012-12-01"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_queryModifyClusterMaintenanceCommand(
  input: ModifyClusterMaintenanceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryModifyClusterMaintenanceMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "ModifyClusterMaintenance",
    Version: "2012-12-01"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_queryModifyClusterParameterGroupCommand(
  input: ModifyClusterParameterGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryModifyClusterParameterGroupMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "ModifyClusterParameterGroup",
    Version: "2012-12-01"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_queryModifyClusterSnapshotCommand(
  input: ModifyClusterSnapshotCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryModifyClusterSnapshotMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "ModifyClusterSnapshot",
    Version: "2012-12-01"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_queryModifyClusterSnapshotScheduleCommand(
  input: ModifyClusterSnapshotScheduleCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryModifyClusterSnapshotScheduleMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "ModifyClusterSnapshotSchedule",
    Version: "2012-12-01"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_queryModifyClusterSubnetGroupCommand(
  input: ModifyClusterSubnetGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryModifyClusterSubnetGroupMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "ModifyClusterSubnetGroup",
    Version: "2012-12-01"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_queryModifyEventSubscriptionCommand(
  input: ModifyEventSubscriptionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryModifyEventSubscriptionMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "ModifyEventSubscription",
    Version: "2012-12-01"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_queryModifyScheduledActionCommand(
  input: ModifyScheduledActionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryModifyScheduledActionMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "ModifyScheduledAction",
    Version: "2012-12-01"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_queryModifySnapshotCopyRetentionPeriodCommand(
  input: ModifySnapshotCopyRetentionPeriodCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryModifySnapshotCopyRetentionPeriodMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "ModifySnapshotCopyRetentionPeriod",
    Version: "2012-12-01"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_queryModifySnapshotScheduleCommand(
  input: ModifySnapshotScheduleCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryModifySnapshotScheduleMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "ModifySnapshotSchedule",
    Version: "2012-12-01"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_queryPurchaseReservedNodeOfferingCommand(
  input: PurchaseReservedNodeOfferingCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryPurchaseReservedNodeOfferingMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "PurchaseReservedNodeOffering",
    Version: "2012-12-01"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_queryRebootClusterCommand(
  input: RebootClusterCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryRebootClusterMessage(input, context);
  body = buildFormUrlencodedString({
    ...entries,
    Action: "RebootCluster",
    Version: "2012-12-01"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_queryResetClusterParameterGroupCommand(
  input: ResetClusterParameterGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryResetClusterParameterGroupMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "ResetClusterParameterGroup",
    Version: "2012-12-01"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_queryResizeClusterCommand(
  input: ResizeClusterCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryResizeClusterMessage(input, context);
  body = buildFormUrlencodedString({
    ...entries,
    Action: "ResizeCluster",
    Version: "2012-12-01"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_queryRestoreFromClusterSnapshotCommand(
  input: RestoreFromClusterSnapshotCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryRestoreFromClusterSnapshotMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "RestoreFromClusterSnapshot",
    Version: "2012-12-01"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_queryRestoreTableFromClusterSnapshotCommand(
  input: RestoreTableFromClusterSnapshotCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryRestoreTableFromClusterSnapshotMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "RestoreTableFromClusterSnapshot",
    Version: "2012-12-01"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_queryRevokeClusterSecurityGroupIngressCommand(
  input: RevokeClusterSecurityGroupIngressCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryRevokeClusterSecurityGroupIngressMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "RevokeClusterSecurityGroupIngress",
    Version: "2012-12-01"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_queryRevokeSnapshotAccessCommand(
  input: RevokeSnapshotAccessCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryRevokeSnapshotAccessMessage(input, context);
  body = buildFormUrlencodedString({
    ...entries,
    Action: "RevokeSnapshotAccess",
    Version: "2012-12-01"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_queryRotateEncryptionKeyCommand(
  input: RotateEncryptionKeyCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryRotateEncryptionKeyMessage(input, context);
  body = buildFormUrlencodedString({
    ...entries,
    Action: "RotateEncryptionKey",
    Version: "2012-12-01"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function deserializeAws_queryAcceptReservedNodeExchangeCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AcceptReservedNodeExchangeCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_queryAcceptReservedNodeExchangeCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryAcceptReservedNodeExchangeOutputMessage(
    data.AcceptReservedNodeExchangeResult,
    context
  );
  const response: AcceptReservedNodeExchangeCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "AcceptReservedNodeExchangeOutputMessage",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_queryAcceptReservedNodeExchangeCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AcceptReservedNodeExchangeCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DependentServiceUnavailableFault":
    case "redshift.admin#DependentServiceUnavailableFault":
      response = await deserializeAws_queryDependentServiceUnavailableFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidReservedNodeStateFault":
    case "redshift.admin#InvalidReservedNodeStateFault":
      response = await deserializeAws_queryInvalidReservedNodeStateFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "ReservedNodeAlreadyExistsFault":
    case "redshift.admin#ReservedNodeAlreadyExistsFault":
      response = await deserializeAws_queryReservedNodeAlreadyExistsFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "ReservedNodeAlreadyMigratedFault":
    case "redshift.admin#ReservedNodeAlreadyMigratedFault":
      response = await deserializeAws_queryReservedNodeAlreadyMigratedFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "ReservedNodeNotFoundFault":
    case "redshift.admin#ReservedNodeNotFoundFault":
      response = await deserializeAws_queryReservedNodeNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "ReservedNodeOfferingNotFoundFault":
    case "redshift.admin#ReservedNodeOfferingNotFoundFault":
      response = await deserializeAws_queryReservedNodeOfferingNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "UnsupportedOperationFault":
    case "redshift.admin#UnsupportedOperationFault":
      response = await deserializeAws_queryUnsupportedOperationFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_queryAuthorizeClusterSecurityGroupIngressCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AuthorizeClusterSecurityGroupIngressCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_queryAuthorizeClusterSecurityGroupIngressCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryAuthorizeClusterSecurityGroupIngressResult(
    data.AuthorizeClusterSecurityGroupIngressResult,
    context
  );
  const response: AuthorizeClusterSecurityGroupIngressCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "AuthorizeClusterSecurityGroupIngressResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_queryAuthorizeClusterSecurityGroupIngressCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AuthorizeClusterSecurityGroupIngressCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AuthorizationAlreadyExistsFault":
    case "redshift.admin#AuthorizationAlreadyExistsFault":
      response = await deserializeAws_queryAuthorizationAlreadyExistsFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "AuthorizationQuotaExceededFault":
    case "redshift.admin#AuthorizationQuotaExceededFault":
      response = await deserializeAws_queryAuthorizationQuotaExceededFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "ClusterSecurityGroupNotFoundFault":
    case "redshift.admin#ClusterSecurityGroupNotFoundFault":
      response = await deserializeAws_queryClusterSecurityGroupNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidClusterSecurityGroupStateFault":
    case "redshift.admin#InvalidClusterSecurityGroupStateFault":
      response = await deserializeAws_queryInvalidClusterSecurityGroupStateFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_queryAuthorizeSnapshotAccessCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AuthorizeSnapshotAccessCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_queryAuthorizeSnapshotAccessCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryAuthorizeSnapshotAccessResult(
    data.AuthorizeSnapshotAccessResult,
    context
  );
  const response: AuthorizeSnapshotAccessCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "AuthorizeSnapshotAccessResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_queryAuthorizeSnapshotAccessCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AuthorizeSnapshotAccessCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AuthorizationAlreadyExistsFault":
    case "redshift.admin#AuthorizationAlreadyExistsFault":
      response = await deserializeAws_queryAuthorizationAlreadyExistsFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "AuthorizationQuotaExceededFault":
    case "redshift.admin#AuthorizationQuotaExceededFault":
      response = await deserializeAws_queryAuthorizationQuotaExceededFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "ClusterSnapshotNotFoundFault":
    case "redshift.admin#ClusterSnapshotNotFoundFault":
      response = await deserializeAws_queryClusterSnapshotNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "DependentServiceRequestThrottlingFault":
    case "redshift.admin#DependentServiceRequestThrottlingFault":
      response = await deserializeAws_queryDependentServiceRequestThrottlingFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidClusterSnapshotStateFault":
    case "redshift.admin#InvalidClusterSnapshotStateFault":
      response = await deserializeAws_queryInvalidClusterSnapshotStateFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "LimitExceededFault":
    case "redshift.admin#LimitExceededFault":
      response = await deserializeAws_queryLimitExceededFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_queryBatchDeleteClusterSnapshotsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchDeleteClusterSnapshotsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_queryBatchDeleteClusterSnapshotsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryBatchDeleteClusterSnapshotsResult(
    data.BatchDeleteClusterSnapshotsResult,
    context
  );
  const response: BatchDeleteClusterSnapshotsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "BatchDeleteClusterSnapshotsResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_queryBatchDeleteClusterSnapshotsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchDeleteClusterSnapshotsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BatchDeleteRequestSizeExceededFault":
    case "redshift.admin#BatchDeleteRequestSizeExceededFault":
      response = await deserializeAws_queryBatchDeleteRequestSizeExceededFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_queryBatchModifyClusterSnapshotsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchModifyClusterSnapshotsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_queryBatchModifyClusterSnapshotsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryBatchModifyClusterSnapshotsOutputMessage(
    data.BatchModifyClusterSnapshotsResult,
    context
  );
  const response: BatchModifyClusterSnapshotsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "BatchModifyClusterSnapshotsOutputMessage",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_queryBatchModifyClusterSnapshotsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchModifyClusterSnapshotsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BatchModifyClusterSnapshotsLimitExceededFault":
    case "redshift.admin#BatchModifyClusterSnapshotsLimitExceededFault":
      response = await deserializeAws_queryBatchModifyClusterSnapshotsLimitExceededFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidRetentionPeriodFault":
    case "redshift.admin#InvalidRetentionPeriodFault":
      response = await deserializeAws_queryInvalidRetentionPeriodFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_queryCancelResizeCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CancelResizeCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_queryCancelResizeCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryResizeProgressMessage(
    data.CancelResizeResult,
    context
  );
  const response: CancelResizeCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ResizeProgressMessage",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_queryCancelResizeCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CancelResizeCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ClusterNotFoundFault":
    case "redshift.admin#ClusterNotFoundFault":
      response = await deserializeAws_queryClusterNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidClusterStateFault":
    case "redshift.admin#InvalidClusterStateFault":
      response = await deserializeAws_queryInvalidClusterStateFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "ResizeNotFoundFault":
    case "redshift.admin#ResizeNotFoundFault":
      response = await deserializeAws_queryResizeNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "UnsupportedOperationFault":
    case "redshift.admin#UnsupportedOperationFault":
      response = await deserializeAws_queryUnsupportedOperationFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_queryCopyClusterSnapshotCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CopyClusterSnapshotCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_queryCopyClusterSnapshotCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryCopyClusterSnapshotResult(
    data.CopyClusterSnapshotResult,
    context
  );
  const response: CopyClusterSnapshotCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CopyClusterSnapshotResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_queryCopyClusterSnapshotCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CopyClusterSnapshotCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ClusterSnapshotAlreadyExistsFault":
    case "redshift.admin#ClusterSnapshotAlreadyExistsFault":
      response = await deserializeAws_queryClusterSnapshotAlreadyExistsFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "ClusterSnapshotNotFoundFault":
    case "redshift.admin#ClusterSnapshotNotFoundFault":
      response = await deserializeAws_queryClusterSnapshotNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "ClusterSnapshotQuotaExceededFault":
    case "redshift.admin#ClusterSnapshotQuotaExceededFault":
      response = await deserializeAws_queryClusterSnapshotQuotaExceededFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidClusterSnapshotStateFault":
    case "redshift.admin#InvalidClusterSnapshotStateFault":
      response = await deserializeAws_queryInvalidClusterSnapshotStateFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidRetentionPeriodFault":
    case "redshift.admin#InvalidRetentionPeriodFault":
      response = await deserializeAws_queryInvalidRetentionPeriodFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_queryCreateClusterCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateClusterCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_queryCreateClusterCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryCreateClusterResult(
    data.CreateClusterResult,
    context
  );
  const response: CreateClusterCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateClusterResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_queryCreateClusterCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateClusterCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ClusterAlreadyExistsFault":
    case "redshift.admin#ClusterAlreadyExistsFault":
      response = await deserializeAws_queryClusterAlreadyExistsFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "ClusterParameterGroupNotFoundFault":
    case "redshift.admin#ClusterParameterGroupNotFoundFault":
      response = await deserializeAws_queryClusterParameterGroupNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "ClusterQuotaExceededFault":
    case "redshift.admin#ClusterQuotaExceededFault":
      response = await deserializeAws_queryClusterQuotaExceededFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "ClusterSecurityGroupNotFoundFault":
    case "redshift.admin#ClusterSecurityGroupNotFoundFault":
      response = await deserializeAws_queryClusterSecurityGroupNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "ClusterSubnetGroupNotFoundFault":
    case "redshift.admin#ClusterSubnetGroupNotFoundFault":
      response = await deserializeAws_queryClusterSubnetGroupNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "DependentServiceRequestThrottlingFault":
    case "redshift.admin#DependentServiceRequestThrottlingFault":
      response = await deserializeAws_queryDependentServiceRequestThrottlingFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "HsmClientCertificateNotFoundFault":
    case "redshift.admin#HsmClientCertificateNotFoundFault":
      response = await deserializeAws_queryHsmClientCertificateNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "HsmConfigurationNotFoundFault":
    case "redshift.admin#HsmConfigurationNotFoundFault":
      response = await deserializeAws_queryHsmConfigurationNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "InsufficientClusterCapacityFault":
    case "redshift.admin#InsufficientClusterCapacityFault":
      response = await deserializeAws_queryInsufficientClusterCapacityFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidClusterSubnetGroupStateFault":
    case "redshift.admin#InvalidClusterSubnetGroupStateFault":
      response = await deserializeAws_queryInvalidClusterSubnetGroupStateFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidClusterTrackFault":
    case "redshift.admin#InvalidClusterTrackFault":
      response = await deserializeAws_queryInvalidClusterTrackFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidElasticIpFault":
    case "redshift.admin#InvalidElasticIpFault":
      response = await deserializeAws_queryInvalidElasticIpFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidRetentionPeriodFault":
    case "redshift.admin#InvalidRetentionPeriodFault":
      response = await deserializeAws_queryInvalidRetentionPeriodFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidSubnet":
    case "redshift.admin#InvalidSubnet":
      response = await deserializeAws_queryInvalidSubnetResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidTagFault":
    case "redshift.admin#InvalidTagFault":
      response = await deserializeAws_queryInvalidTagFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidVPCNetworkStateFault":
    case "redshift.admin#InvalidVPCNetworkStateFault":
      response = await deserializeAws_queryInvalidVPCNetworkStateFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "LimitExceededFault":
    case "redshift.admin#LimitExceededFault":
      response = await deserializeAws_queryLimitExceededFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "NumberOfNodesPerClusterLimitExceededFault":
    case "redshift.admin#NumberOfNodesPerClusterLimitExceededFault":
      response = await deserializeAws_queryNumberOfNodesPerClusterLimitExceededFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "NumberOfNodesQuotaExceededFault":
    case "redshift.admin#NumberOfNodesQuotaExceededFault":
      response = await deserializeAws_queryNumberOfNodesQuotaExceededFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "SnapshotScheduleNotFoundFault":
    case "redshift.admin#SnapshotScheduleNotFoundFault":
      response = await deserializeAws_querySnapshotScheduleNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "TagLimitExceededFault":
    case "redshift.admin#TagLimitExceededFault":
      response = await deserializeAws_queryTagLimitExceededFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "UnauthorizedOperation":
    case "redshift.admin#UnauthorizedOperation":
      response = await deserializeAws_queryUnauthorizedOperationResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_queryCreateClusterParameterGroupCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateClusterParameterGroupCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_queryCreateClusterParameterGroupCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryCreateClusterParameterGroupResult(
    data.CreateClusterParameterGroupResult,
    context
  );
  const response: CreateClusterParameterGroupCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateClusterParameterGroupResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_queryCreateClusterParameterGroupCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateClusterParameterGroupCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ClusterParameterGroupAlreadyExistsFault":
    case "redshift.admin#ClusterParameterGroupAlreadyExistsFault":
      response = await deserializeAws_queryClusterParameterGroupAlreadyExistsFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "ClusterParameterGroupQuotaExceededFault":
    case "redshift.admin#ClusterParameterGroupQuotaExceededFault":
      response = await deserializeAws_queryClusterParameterGroupQuotaExceededFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidTagFault":
    case "redshift.admin#InvalidTagFault":
      response = await deserializeAws_queryInvalidTagFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "TagLimitExceededFault":
    case "redshift.admin#TagLimitExceededFault":
      response = await deserializeAws_queryTagLimitExceededFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_queryCreateClusterSecurityGroupCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateClusterSecurityGroupCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_queryCreateClusterSecurityGroupCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryCreateClusterSecurityGroupResult(
    data.CreateClusterSecurityGroupResult,
    context
  );
  const response: CreateClusterSecurityGroupCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateClusterSecurityGroupResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_queryCreateClusterSecurityGroupCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateClusterSecurityGroupCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ClusterSecurityGroupAlreadyExistsFault":
    case "redshift.admin#ClusterSecurityGroupAlreadyExistsFault":
      response = await deserializeAws_queryClusterSecurityGroupAlreadyExistsFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "ClusterSecurityGroupQuotaExceededFault":
    case "redshift.admin#ClusterSecurityGroupQuotaExceededFault":
      response = await deserializeAws_queryClusterSecurityGroupQuotaExceededFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidTagFault":
    case "redshift.admin#InvalidTagFault":
      response = await deserializeAws_queryInvalidTagFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "TagLimitExceededFault":
    case "redshift.admin#TagLimitExceededFault":
      response = await deserializeAws_queryTagLimitExceededFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_queryCreateClusterSnapshotCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateClusterSnapshotCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_queryCreateClusterSnapshotCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryCreateClusterSnapshotResult(
    data.CreateClusterSnapshotResult,
    context
  );
  const response: CreateClusterSnapshotCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateClusterSnapshotResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_queryCreateClusterSnapshotCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateClusterSnapshotCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ClusterNotFoundFault":
    case "redshift.admin#ClusterNotFoundFault":
      response = await deserializeAws_queryClusterNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "ClusterSnapshotAlreadyExistsFault":
    case "redshift.admin#ClusterSnapshotAlreadyExistsFault":
      response = await deserializeAws_queryClusterSnapshotAlreadyExistsFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "ClusterSnapshotQuotaExceededFault":
    case "redshift.admin#ClusterSnapshotQuotaExceededFault":
      response = await deserializeAws_queryClusterSnapshotQuotaExceededFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidClusterStateFault":
    case "redshift.admin#InvalidClusterStateFault":
      response = await deserializeAws_queryInvalidClusterStateFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidRetentionPeriodFault":
    case "redshift.admin#InvalidRetentionPeriodFault":
      response = await deserializeAws_queryInvalidRetentionPeriodFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidTagFault":
    case "redshift.admin#InvalidTagFault":
      response = await deserializeAws_queryInvalidTagFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "TagLimitExceededFault":
    case "redshift.admin#TagLimitExceededFault":
      response = await deserializeAws_queryTagLimitExceededFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_queryCreateClusterSubnetGroupCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateClusterSubnetGroupCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_queryCreateClusterSubnetGroupCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryCreateClusterSubnetGroupResult(
    data.CreateClusterSubnetGroupResult,
    context
  );
  const response: CreateClusterSubnetGroupCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateClusterSubnetGroupResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_queryCreateClusterSubnetGroupCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateClusterSubnetGroupCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ClusterSubnetGroupAlreadyExistsFault":
    case "redshift.admin#ClusterSubnetGroupAlreadyExistsFault":
      response = await deserializeAws_queryClusterSubnetGroupAlreadyExistsFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "ClusterSubnetGroupQuotaExceededFault":
    case "redshift.admin#ClusterSubnetGroupQuotaExceededFault":
      response = await deserializeAws_queryClusterSubnetGroupQuotaExceededFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "ClusterSubnetQuotaExceededFault":
    case "redshift.admin#ClusterSubnetQuotaExceededFault":
      response = await deserializeAws_queryClusterSubnetQuotaExceededFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "DependentServiceRequestThrottlingFault":
    case "redshift.admin#DependentServiceRequestThrottlingFault":
      response = await deserializeAws_queryDependentServiceRequestThrottlingFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidSubnet":
    case "redshift.admin#InvalidSubnet":
      response = await deserializeAws_queryInvalidSubnetResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidTagFault":
    case "redshift.admin#InvalidTagFault":
      response = await deserializeAws_queryInvalidTagFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "TagLimitExceededFault":
    case "redshift.admin#TagLimitExceededFault":
      response = await deserializeAws_queryTagLimitExceededFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "UnauthorizedOperation":
    case "redshift.admin#UnauthorizedOperation":
      response = await deserializeAws_queryUnauthorizedOperationResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_queryCreateEventSubscriptionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateEventSubscriptionCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_queryCreateEventSubscriptionCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryCreateEventSubscriptionResult(
    data.CreateEventSubscriptionResult,
    context
  );
  const response: CreateEventSubscriptionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateEventSubscriptionResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_queryCreateEventSubscriptionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateEventSubscriptionCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "EventSubscriptionQuotaExceededFault":
    case "redshift.admin#EventSubscriptionQuotaExceededFault":
      response = await deserializeAws_queryEventSubscriptionQuotaExceededFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidTagFault":
    case "redshift.admin#InvalidTagFault":
      response = await deserializeAws_queryInvalidTagFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "SNSInvalidTopicFault":
    case "redshift.admin#SNSInvalidTopicFault":
      response = await deserializeAws_querySNSInvalidTopicFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "SNSNoAuthorizationFault":
    case "redshift.admin#SNSNoAuthorizationFault":
      response = await deserializeAws_querySNSNoAuthorizationFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "SNSTopicArnNotFoundFault":
    case "redshift.admin#SNSTopicArnNotFoundFault":
      response = await deserializeAws_querySNSTopicArnNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "SourceNotFoundFault":
    case "redshift.admin#SourceNotFoundFault":
      response = await deserializeAws_querySourceNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "SubscriptionAlreadyExistFault":
    case "redshift.admin#SubscriptionAlreadyExistFault":
      response = await deserializeAws_querySubscriptionAlreadyExistFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "SubscriptionCategoryNotFoundFault":
    case "redshift.admin#SubscriptionCategoryNotFoundFault":
      response = await deserializeAws_querySubscriptionCategoryNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "SubscriptionEventIdNotFoundFault":
    case "redshift.admin#SubscriptionEventIdNotFoundFault":
      response = await deserializeAws_querySubscriptionEventIdNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "SubscriptionSeverityNotFoundFault":
    case "redshift.admin#SubscriptionSeverityNotFoundFault":
      response = await deserializeAws_querySubscriptionSeverityNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "TagLimitExceededFault":
    case "redshift.admin#TagLimitExceededFault":
      response = await deserializeAws_queryTagLimitExceededFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_queryCreateHsmClientCertificateCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateHsmClientCertificateCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_queryCreateHsmClientCertificateCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryCreateHsmClientCertificateResult(
    data.CreateHsmClientCertificateResult,
    context
  );
  const response: CreateHsmClientCertificateCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateHsmClientCertificateResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_queryCreateHsmClientCertificateCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateHsmClientCertificateCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "HsmClientCertificateAlreadyExistsFault":
    case "redshift.admin#HsmClientCertificateAlreadyExistsFault":
      response = await deserializeAws_queryHsmClientCertificateAlreadyExistsFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "HsmClientCertificateQuotaExceededFault":
    case "redshift.admin#HsmClientCertificateQuotaExceededFault":
      response = await deserializeAws_queryHsmClientCertificateQuotaExceededFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidTagFault":
    case "redshift.admin#InvalidTagFault":
      response = await deserializeAws_queryInvalidTagFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "TagLimitExceededFault":
    case "redshift.admin#TagLimitExceededFault":
      response = await deserializeAws_queryTagLimitExceededFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_queryCreateHsmConfigurationCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateHsmConfigurationCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_queryCreateHsmConfigurationCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryCreateHsmConfigurationResult(
    data.CreateHsmConfigurationResult,
    context
  );
  const response: CreateHsmConfigurationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateHsmConfigurationResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_queryCreateHsmConfigurationCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateHsmConfigurationCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "HsmConfigurationAlreadyExistsFault":
    case "redshift.admin#HsmConfigurationAlreadyExistsFault":
      response = await deserializeAws_queryHsmConfigurationAlreadyExistsFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "HsmConfigurationQuotaExceededFault":
    case "redshift.admin#HsmConfigurationQuotaExceededFault":
      response = await deserializeAws_queryHsmConfigurationQuotaExceededFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidTagFault":
    case "redshift.admin#InvalidTagFault":
      response = await deserializeAws_queryInvalidTagFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "TagLimitExceededFault":
    case "redshift.admin#TagLimitExceededFault":
      response = await deserializeAws_queryTagLimitExceededFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_queryCreateScheduledActionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateScheduledActionCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_queryCreateScheduledActionCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryScheduledAction(
    data.CreateScheduledActionResult,
    context
  );
  const response: CreateScheduledActionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ScheduledAction",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_queryCreateScheduledActionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateScheduledActionCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidScheduleFault":
    case "redshift.admin#InvalidScheduleFault":
      response = await deserializeAws_queryInvalidScheduleFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidScheduledActionFault":
    case "redshift.admin#InvalidScheduledActionFault":
      response = await deserializeAws_queryInvalidScheduledActionFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "ScheduledActionAlreadyExistsFault":
    case "redshift.admin#ScheduledActionAlreadyExistsFault":
      response = await deserializeAws_queryScheduledActionAlreadyExistsFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "ScheduledActionQuotaExceededFault":
    case "redshift.admin#ScheduledActionQuotaExceededFault":
      response = await deserializeAws_queryScheduledActionQuotaExceededFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "ScheduledActionTypeUnsupportedFault":
    case "redshift.admin#ScheduledActionTypeUnsupportedFault":
      response = await deserializeAws_queryScheduledActionTypeUnsupportedFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "UnauthorizedOperation":
    case "redshift.admin#UnauthorizedOperation":
      response = await deserializeAws_queryUnauthorizedOperationResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_queryCreateSnapshotCopyGrantCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateSnapshotCopyGrantCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_queryCreateSnapshotCopyGrantCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryCreateSnapshotCopyGrantResult(
    data.CreateSnapshotCopyGrantResult,
    context
  );
  const response: CreateSnapshotCopyGrantCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateSnapshotCopyGrantResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_queryCreateSnapshotCopyGrantCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateSnapshotCopyGrantCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DependentServiceRequestThrottlingFault":
    case "redshift.admin#DependentServiceRequestThrottlingFault":
      response = await deserializeAws_queryDependentServiceRequestThrottlingFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidTagFault":
    case "redshift.admin#InvalidTagFault":
      response = await deserializeAws_queryInvalidTagFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "LimitExceededFault":
    case "redshift.admin#LimitExceededFault":
      response = await deserializeAws_queryLimitExceededFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "SnapshotCopyGrantAlreadyExistsFault":
    case "redshift.admin#SnapshotCopyGrantAlreadyExistsFault":
      response = await deserializeAws_querySnapshotCopyGrantAlreadyExistsFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "SnapshotCopyGrantQuotaExceededFault":
    case "redshift.admin#SnapshotCopyGrantQuotaExceededFault":
      response = await deserializeAws_querySnapshotCopyGrantQuotaExceededFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "TagLimitExceededFault":
    case "redshift.admin#TagLimitExceededFault":
      response = await deserializeAws_queryTagLimitExceededFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_queryCreateSnapshotScheduleCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateSnapshotScheduleCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_queryCreateSnapshotScheduleCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_querySnapshotSchedule(
    data.CreateSnapshotScheduleResult,
    context
  );
  const response: CreateSnapshotScheduleCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "SnapshotSchedule",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_queryCreateSnapshotScheduleCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateSnapshotScheduleCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidScheduleFault":
    case "redshift.admin#InvalidScheduleFault":
      response = await deserializeAws_queryInvalidScheduleFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "ScheduleDefinitionTypeUnsupportedFault":
    case "redshift.admin#ScheduleDefinitionTypeUnsupportedFault":
      response = await deserializeAws_queryScheduleDefinitionTypeUnsupportedFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "SnapshotScheduleAlreadyExistsFault":
    case "redshift.admin#SnapshotScheduleAlreadyExistsFault":
      response = await deserializeAws_querySnapshotScheduleAlreadyExistsFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "SnapshotScheduleQuotaExceededFault":
    case "redshift.admin#SnapshotScheduleQuotaExceededFault":
      response = await deserializeAws_querySnapshotScheduleQuotaExceededFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "TagLimitExceededFault":
    case "redshift.admin#TagLimitExceededFault":
      response = await deserializeAws_queryTagLimitExceededFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_queryCreateTagsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateTagsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_queryCreateTagsCommandError(output, context);
  }
  await collectBody(output.body, context);
  const response: CreateTagsCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
}

async function deserializeAws_queryCreateTagsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateTagsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidTagFault":
    case "redshift.admin#InvalidTagFault":
      response = await deserializeAws_queryInvalidTagFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceNotFoundFault":
    case "redshift.admin#ResourceNotFoundFault":
      response = await deserializeAws_queryResourceNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "TagLimitExceededFault":
    case "redshift.admin#TagLimitExceededFault":
      response = await deserializeAws_queryTagLimitExceededFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_queryDeleteClusterCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteClusterCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_queryDeleteClusterCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryDeleteClusterResult(
    data.DeleteClusterResult,
    context
  );
  const response: DeleteClusterCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteClusterResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_queryDeleteClusterCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteClusterCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ClusterNotFoundFault":
    case "redshift.admin#ClusterNotFoundFault":
      response = await deserializeAws_queryClusterNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "ClusterSnapshotAlreadyExistsFault":
    case "redshift.admin#ClusterSnapshotAlreadyExistsFault":
      response = await deserializeAws_queryClusterSnapshotAlreadyExistsFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "ClusterSnapshotQuotaExceededFault":
    case "redshift.admin#ClusterSnapshotQuotaExceededFault":
      response = await deserializeAws_queryClusterSnapshotQuotaExceededFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidClusterStateFault":
    case "redshift.admin#InvalidClusterStateFault":
      response = await deserializeAws_queryInvalidClusterStateFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidRetentionPeriodFault":
    case "redshift.admin#InvalidRetentionPeriodFault":
      response = await deserializeAws_queryInvalidRetentionPeriodFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_queryDeleteClusterParameterGroupCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteClusterParameterGroupCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_queryDeleteClusterParameterGroupCommandError(
      output,
      context
    );
  }
  await collectBody(output.body, context);
  const response: DeleteClusterParameterGroupCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
}

async function deserializeAws_queryDeleteClusterParameterGroupCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteClusterParameterGroupCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ClusterParameterGroupNotFoundFault":
    case "redshift.admin#ClusterParameterGroupNotFoundFault":
      response = await deserializeAws_queryClusterParameterGroupNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidClusterParameterGroupStateFault":
    case "redshift.admin#InvalidClusterParameterGroupStateFault":
      response = await deserializeAws_queryInvalidClusterParameterGroupStateFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_queryDeleteClusterSecurityGroupCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteClusterSecurityGroupCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_queryDeleteClusterSecurityGroupCommandError(
      output,
      context
    );
  }
  await collectBody(output.body, context);
  const response: DeleteClusterSecurityGroupCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
}

async function deserializeAws_queryDeleteClusterSecurityGroupCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteClusterSecurityGroupCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ClusterSecurityGroupNotFoundFault":
    case "redshift.admin#ClusterSecurityGroupNotFoundFault":
      response = await deserializeAws_queryClusterSecurityGroupNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidClusterSecurityGroupStateFault":
    case "redshift.admin#InvalidClusterSecurityGroupStateFault":
      response = await deserializeAws_queryInvalidClusterSecurityGroupStateFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_queryDeleteClusterSnapshotCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteClusterSnapshotCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_queryDeleteClusterSnapshotCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryDeleteClusterSnapshotResult(
    data.DeleteClusterSnapshotResult,
    context
  );
  const response: DeleteClusterSnapshotCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteClusterSnapshotResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_queryDeleteClusterSnapshotCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteClusterSnapshotCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ClusterSnapshotNotFoundFault":
    case "redshift.admin#ClusterSnapshotNotFoundFault":
      response = await deserializeAws_queryClusterSnapshotNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidClusterSnapshotStateFault":
    case "redshift.admin#InvalidClusterSnapshotStateFault":
      response = await deserializeAws_queryInvalidClusterSnapshotStateFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_queryDeleteClusterSubnetGroupCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteClusterSubnetGroupCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_queryDeleteClusterSubnetGroupCommandError(
      output,
      context
    );
  }
  await collectBody(output.body, context);
  const response: DeleteClusterSubnetGroupCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
}

async function deserializeAws_queryDeleteClusterSubnetGroupCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteClusterSubnetGroupCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ClusterSubnetGroupNotFoundFault":
    case "redshift.admin#ClusterSubnetGroupNotFoundFault":
      response = await deserializeAws_queryClusterSubnetGroupNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidClusterSubnetGroupStateFault":
    case "redshift.admin#InvalidClusterSubnetGroupStateFault":
      response = await deserializeAws_queryInvalidClusterSubnetGroupStateFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidClusterSubnetStateFault":
    case "redshift.admin#InvalidClusterSubnetStateFault":
      response = await deserializeAws_queryInvalidClusterSubnetStateFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_queryDeleteEventSubscriptionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteEventSubscriptionCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_queryDeleteEventSubscriptionCommandError(
      output,
      context
    );
  }
  await collectBody(output.body, context);
  const response: DeleteEventSubscriptionCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
}

async function deserializeAws_queryDeleteEventSubscriptionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteEventSubscriptionCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidSubscriptionStateFault":
    case "redshift.admin#InvalidSubscriptionStateFault":
      response = await deserializeAws_queryInvalidSubscriptionStateFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "SubscriptionNotFoundFault":
    case "redshift.admin#SubscriptionNotFoundFault":
      response = await deserializeAws_querySubscriptionNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_queryDeleteHsmClientCertificateCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteHsmClientCertificateCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_queryDeleteHsmClientCertificateCommandError(
      output,
      context
    );
  }
  await collectBody(output.body, context);
  const response: DeleteHsmClientCertificateCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
}

async function deserializeAws_queryDeleteHsmClientCertificateCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteHsmClientCertificateCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "HsmClientCertificateNotFoundFault":
    case "redshift.admin#HsmClientCertificateNotFoundFault":
      response = await deserializeAws_queryHsmClientCertificateNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidHsmClientCertificateStateFault":
    case "redshift.admin#InvalidHsmClientCertificateStateFault":
      response = await deserializeAws_queryInvalidHsmClientCertificateStateFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_queryDeleteHsmConfigurationCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteHsmConfigurationCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_queryDeleteHsmConfigurationCommandError(
      output,
      context
    );
  }
  await collectBody(output.body, context);
  const response: DeleteHsmConfigurationCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
}

async function deserializeAws_queryDeleteHsmConfigurationCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteHsmConfigurationCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "HsmConfigurationNotFoundFault":
    case "redshift.admin#HsmConfigurationNotFoundFault":
      response = await deserializeAws_queryHsmConfigurationNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidHsmConfigurationStateFault":
    case "redshift.admin#InvalidHsmConfigurationStateFault":
      response = await deserializeAws_queryInvalidHsmConfigurationStateFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_queryDeleteScheduledActionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteScheduledActionCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_queryDeleteScheduledActionCommandError(
      output,
      context
    );
  }
  await collectBody(output.body, context);
  const response: DeleteScheduledActionCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
}

async function deserializeAws_queryDeleteScheduledActionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteScheduledActionCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ScheduledActionNotFoundFault":
    case "redshift.admin#ScheduledActionNotFoundFault":
      response = await deserializeAws_queryScheduledActionNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "UnauthorizedOperation":
    case "redshift.admin#UnauthorizedOperation":
      response = await deserializeAws_queryUnauthorizedOperationResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_queryDeleteSnapshotCopyGrantCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteSnapshotCopyGrantCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_queryDeleteSnapshotCopyGrantCommandError(
      output,
      context
    );
  }
  await collectBody(output.body, context);
  const response: DeleteSnapshotCopyGrantCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
}

async function deserializeAws_queryDeleteSnapshotCopyGrantCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteSnapshotCopyGrantCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidSnapshotCopyGrantStateFault":
    case "redshift.admin#InvalidSnapshotCopyGrantStateFault":
      response = await deserializeAws_queryInvalidSnapshotCopyGrantStateFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "SnapshotCopyGrantNotFoundFault":
    case "redshift.admin#SnapshotCopyGrantNotFoundFault":
      response = await deserializeAws_querySnapshotCopyGrantNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_queryDeleteSnapshotScheduleCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteSnapshotScheduleCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_queryDeleteSnapshotScheduleCommandError(
      output,
      context
    );
  }
  await collectBody(output.body, context);
  const response: DeleteSnapshotScheduleCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
}

async function deserializeAws_queryDeleteSnapshotScheduleCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteSnapshotScheduleCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidClusterSnapshotScheduleStateFault":
    case "redshift.admin#InvalidClusterSnapshotScheduleStateFault":
      response = await deserializeAws_queryInvalidClusterSnapshotScheduleStateFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "SnapshotScheduleNotFoundFault":
    case "redshift.admin#SnapshotScheduleNotFoundFault":
      response = await deserializeAws_querySnapshotScheduleNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_queryDeleteTagsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteTagsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_queryDeleteTagsCommandError(output, context);
  }
  await collectBody(output.body, context);
  const response: DeleteTagsCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
}

async function deserializeAws_queryDeleteTagsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteTagsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidTagFault":
    case "redshift.admin#InvalidTagFault":
      response = await deserializeAws_queryInvalidTagFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceNotFoundFault":
    case "redshift.admin#ResourceNotFoundFault":
      response = await deserializeAws_queryResourceNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_queryDescribeAccountAttributesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeAccountAttributesCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_queryDescribeAccountAttributesCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryAccountAttributeList(
    data.DescribeAccountAttributesResult,
    context
  );
  const response: DescribeAccountAttributesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "AccountAttributeList",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_queryDescribeAccountAttributesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeAccountAttributesCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_queryDescribeClusterDbRevisionsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeClusterDbRevisionsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_queryDescribeClusterDbRevisionsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryClusterDbRevisionsMessage(
    data.DescribeClusterDbRevisionsResult,
    context
  );
  const response: DescribeClusterDbRevisionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ClusterDbRevisionsMessage",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_queryDescribeClusterDbRevisionsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeClusterDbRevisionsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ClusterNotFoundFault":
    case "redshift.admin#ClusterNotFoundFault":
      response = await deserializeAws_queryClusterNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidClusterStateFault":
    case "redshift.admin#InvalidClusterStateFault":
      response = await deserializeAws_queryInvalidClusterStateFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_queryDescribeClusterParameterGroupsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeClusterParameterGroupsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_queryDescribeClusterParameterGroupsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryClusterParameterGroupsMessage(
    data.DescribeClusterParameterGroupsResult,
    context
  );
  const response: DescribeClusterParameterGroupsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ClusterParameterGroupsMessage",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_queryDescribeClusterParameterGroupsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeClusterParameterGroupsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ClusterParameterGroupNotFoundFault":
    case "redshift.admin#ClusterParameterGroupNotFoundFault":
      response = await deserializeAws_queryClusterParameterGroupNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidTagFault":
    case "redshift.admin#InvalidTagFault":
      response = await deserializeAws_queryInvalidTagFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_queryDescribeClusterParametersCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeClusterParametersCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_queryDescribeClusterParametersCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryClusterParameterGroupDetails(
    data.DescribeClusterParametersResult,
    context
  );
  const response: DescribeClusterParametersCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ClusterParameterGroupDetails",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_queryDescribeClusterParametersCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeClusterParametersCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ClusterParameterGroupNotFoundFault":
    case "redshift.admin#ClusterParameterGroupNotFoundFault":
      response = await deserializeAws_queryClusterParameterGroupNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_queryDescribeClusterSecurityGroupsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeClusterSecurityGroupsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_queryDescribeClusterSecurityGroupsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryClusterSecurityGroupMessage(
    data.DescribeClusterSecurityGroupsResult,
    context
  );
  const response: DescribeClusterSecurityGroupsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ClusterSecurityGroupMessage",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_queryDescribeClusterSecurityGroupsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeClusterSecurityGroupsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ClusterSecurityGroupNotFoundFault":
    case "redshift.admin#ClusterSecurityGroupNotFoundFault":
      response = await deserializeAws_queryClusterSecurityGroupNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidTagFault":
    case "redshift.admin#InvalidTagFault":
      response = await deserializeAws_queryInvalidTagFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_queryDescribeClusterSnapshotsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeClusterSnapshotsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_queryDescribeClusterSnapshotsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_querySnapshotMessage(
    data.DescribeClusterSnapshotsResult,
    context
  );
  const response: DescribeClusterSnapshotsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "SnapshotMessage",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_queryDescribeClusterSnapshotsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeClusterSnapshotsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ClusterNotFoundFault":
    case "redshift.admin#ClusterNotFoundFault":
      response = await deserializeAws_queryClusterNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "ClusterSnapshotNotFoundFault":
    case "redshift.admin#ClusterSnapshotNotFoundFault":
      response = await deserializeAws_queryClusterSnapshotNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidTagFault":
    case "redshift.admin#InvalidTagFault":
      response = await deserializeAws_queryInvalidTagFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_queryDescribeClusterSubnetGroupsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeClusterSubnetGroupsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_queryDescribeClusterSubnetGroupsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryClusterSubnetGroupMessage(
    data.DescribeClusterSubnetGroupsResult,
    context
  );
  const response: DescribeClusterSubnetGroupsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ClusterSubnetGroupMessage",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_queryDescribeClusterSubnetGroupsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeClusterSubnetGroupsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ClusterSubnetGroupNotFoundFault":
    case "redshift.admin#ClusterSubnetGroupNotFoundFault":
      response = await deserializeAws_queryClusterSubnetGroupNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidTagFault":
    case "redshift.admin#InvalidTagFault":
      response = await deserializeAws_queryInvalidTagFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_queryDescribeClusterTracksCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeClusterTracksCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_queryDescribeClusterTracksCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryTrackListMessage(
    data.DescribeClusterTracksResult,
    context
  );
  const response: DescribeClusterTracksCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "TrackListMessage",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_queryDescribeClusterTracksCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeClusterTracksCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidClusterTrackFault":
    case "redshift.admin#InvalidClusterTrackFault":
      response = await deserializeAws_queryInvalidClusterTrackFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "UnauthorizedOperation":
    case "redshift.admin#UnauthorizedOperation":
      response = await deserializeAws_queryUnauthorizedOperationResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_queryDescribeClusterVersionsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeClusterVersionsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_queryDescribeClusterVersionsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryClusterVersionsMessage(
    data.DescribeClusterVersionsResult,
    context
  );
  const response: DescribeClusterVersionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ClusterVersionsMessage",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_queryDescribeClusterVersionsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeClusterVersionsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_queryDescribeClustersCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeClustersCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_queryDescribeClustersCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryClustersMessage(
    data.DescribeClustersResult,
    context
  );
  const response: DescribeClustersCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ClustersMessage",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_queryDescribeClustersCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeClustersCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ClusterNotFoundFault":
    case "redshift.admin#ClusterNotFoundFault":
      response = await deserializeAws_queryClusterNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidTagFault":
    case "redshift.admin#InvalidTagFault":
      response = await deserializeAws_queryInvalidTagFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_queryDescribeDefaultClusterParametersCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDefaultClusterParametersCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_queryDescribeDefaultClusterParametersCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryDescribeDefaultClusterParametersResult(
    data.DescribeDefaultClusterParametersResult,
    context
  );
  const response: DescribeDefaultClusterParametersCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeDefaultClusterParametersResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_queryDescribeDefaultClusterParametersCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDefaultClusterParametersCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_queryDescribeEventCategoriesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeEventCategoriesCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_queryDescribeEventCategoriesCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryEventCategoriesMessage(
    data.DescribeEventCategoriesResult,
    context
  );
  const response: DescribeEventCategoriesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "EventCategoriesMessage",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_queryDescribeEventCategoriesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeEventCategoriesCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_queryDescribeEventSubscriptionsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeEventSubscriptionsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_queryDescribeEventSubscriptionsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryEventSubscriptionsMessage(
    data.DescribeEventSubscriptionsResult,
    context
  );
  const response: DescribeEventSubscriptionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "EventSubscriptionsMessage",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_queryDescribeEventSubscriptionsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeEventSubscriptionsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidTagFault":
    case "redshift.admin#InvalidTagFault":
      response = await deserializeAws_queryInvalidTagFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "SubscriptionNotFoundFault":
    case "redshift.admin#SubscriptionNotFoundFault":
      response = await deserializeAws_querySubscriptionNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_queryDescribeEventsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeEventsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_queryDescribeEventsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryEventsMessage(
    data.DescribeEventsResult,
    context
  );
  const response: DescribeEventsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "EventsMessage",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_queryDescribeEventsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeEventsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_queryDescribeHsmClientCertificatesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeHsmClientCertificatesCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_queryDescribeHsmClientCertificatesCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryHsmClientCertificateMessage(
    data.DescribeHsmClientCertificatesResult,
    context
  );
  const response: DescribeHsmClientCertificatesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "HsmClientCertificateMessage",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_queryDescribeHsmClientCertificatesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeHsmClientCertificatesCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "HsmClientCertificateNotFoundFault":
    case "redshift.admin#HsmClientCertificateNotFoundFault":
      response = await deserializeAws_queryHsmClientCertificateNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidTagFault":
    case "redshift.admin#InvalidTagFault":
      response = await deserializeAws_queryInvalidTagFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_queryDescribeHsmConfigurationsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeHsmConfigurationsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_queryDescribeHsmConfigurationsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryHsmConfigurationMessage(
    data.DescribeHsmConfigurationsResult,
    context
  );
  const response: DescribeHsmConfigurationsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "HsmConfigurationMessage",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_queryDescribeHsmConfigurationsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeHsmConfigurationsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "HsmConfigurationNotFoundFault":
    case "redshift.admin#HsmConfigurationNotFoundFault":
      response = await deserializeAws_queryHsmConfigurationNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidTagFault":
    case "redshift.admin#InvalidTagFault":
      response = await deserializeAws_queryInvalidTagFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_queryDescribeLoggingStatusCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeLoggingStatusCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_queryDescribeLoggingStatusCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryLoggingStatus(
    data.DescribeLoggingStatusResult,
    context
  );
  const response: DescribeLoggingStatusCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "LoggingStatus",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_queryDescribeLoggingStatusCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeLoggingStatusCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ClusterNotFoundFault":
    case "redshift.admin#ClusterNotFoundFault":
      response = await deserializeAws_queryClusterNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_queryDescribeNodeConfigurationOptionsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeNodeConfigurationOptionsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_queryDescribeNodeConfigurationOptionsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryNodeConfigurationOptionsMessage(
    data.DescribeNodeConfigurationOptionsResult,
    context
  );
  const response: DescribeNodeConfigurationOptionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "NodeConfigurationOptionsMessage",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_queryDescribeNodeConfigurationOptionsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeNodeConfigurationOptionsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessToSnapshotDeniedFault":
    case "redshift.admin#AccessToSnapshotDeniedFault":
      response = await deserializeAws_queryAccessToSnapshotDeniedFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "ClusterNotFoundFault":
    case "redshift.admin#ClusterNotFoundFault":
      response = await deserializeAws_queryClusterNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "ClusterSnapshotNotFoundFault":
    case "redshift.admin#ClusterSnapshotNotFoundFault":
      response = await deserializeAws_queryClusterSnapshotNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidClusterSnapshotStateFault":
    case "redshift.admin#InvalidClusterSnapshotStateFault":
      response = await deserializeAws_queryInvalidClusterSnapshotStateFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_queryDescribeOrderableClusterOptionsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeOrderableClusterOptionsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_queryDescribeOrderableClusterOptionsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryOrderableClusterOptionsMessage(
    data.DescribeOrderableClusterOptionsResult,
    context
  );
  const response: DescribeOrderableClusterOptionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "OrderableClusterOptionsMessage",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_queryDescribeOrderableClusterOptionsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeOrderableClusterOptionsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_queryDescribeReservedNodeOfferingsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeReservedNodeOfferingsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_queryDescribeReservedNodeOfferingsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryReservedNodeOfferingsMessage(
    data.DescribeReservedNodeOfferingsResult,
    context
  );
  const response: DescribeReservedNodeOfferingsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ReservedNodeOfferingsMessage",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_queryDescribeReservedNodeOfferingsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeReservedNodeOfferingsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DependentServiceUnavailableFault":
    case "redshift.admin#DependentServiceUnavailableFault":
      response = await deserializeAws_queryDependentServiceUnavailableFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "ReservedNodeOfferingNotFoundFault":
    case "redshift.admin#ReservedNodeOfferingNotFoundFault":
      response = await deserializeAws_queryReservedNodeOfferingNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "UnsupportedOperationFault":
    case "redshift.admin#UnsupportedOperationFault":
      response = await deserializeAws_queryUnsupportedOperationFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_queryDescribeReservedNodesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeReservedNodesCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_queryDescribeReservedNodesCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryReservedNodesMessage(
    data.DescribeReservedNodesResult,
    context
  );
  const response: DescribeReservedNodesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ReservedNodesMessage",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_queryDescribeReservedNodesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeReservedNodesCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DependentServiceUnavailableFault":
    case "redshift.admin#DependentServiceUnavailableFault":
      response = await deserializeAws_queryDependentServiceUnavailableFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "ReservedNodeNotFoundFault":
    case "redshift.admin#ReservedNodeNotFoundFault":
      response = await deserializeAws_queryReservedNodeNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_queryDescribeResizeCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeResizeCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_queryDescribeResizeCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryResizeProgressMessage(
    data.DescribeResizeResult,
    context
  );
  const response: DescribeResizeCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ResizeProgressMessage",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_queryDescribeResizeCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeResizeCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ClusterNotFoundFault":
    case "redshift.admin#ClusterNotFoundFault":
      response = await deserializeAws_queryClusterNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "ResizeNotFoundFault":
    case "redshift.admin#ResizeNotFoundFault":
      response = await deserializeAws_queryResizeNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_queryDescribeScheduledActionsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeScheduledActionsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_queryDescribeScheduledActionsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryScheduledActionsMessage(
    data.DescribeScheduledActionsResult,
    context
  );
  const response: DescribeScheduledActionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ScheduledActionsMessage",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_queryDescribeScheduledActionsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeScheduledActionsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ScheduledActionNotFoundFault":
    case "redshift.admin#ScheduledActionNotFoundFault":
      response = await deserializeAws_queryScheduledActionNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "UnauthorizedOperation":
    case "redshift.admin#UnauthorizedOperation":
      response = await deserializeAws_queryUnauthorizedOperationResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_queryDescribeSnapshotCopyGrantsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeSnapshotCopyGrantsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_queryDescribeSnapshotCopyGrantsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_querySnapshotCopyGrantMessage(
    data.DescribeSnapshotCopyGrantsResult,
    context
  );
  const response: DescribeSnapshotCopyGrantsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "SnapshotCopyGrantMessage",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_queryDescribeSnapshotCopyGrantsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeSnapshotCopyGrantsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidTagFault":
    case "redshift.admin#InvalidTagFault":
      response = await deserializeAws_queryInvalidTagFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "SnapshotCopyGrantNotFoundFault":
    case "redshift.admin#SnapshotCopyGrantNotFoundFault":
      response = await deserializeAws_querySnapshotCopyGrantNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_queryDescribeSnapshotSchedulesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeSnapshotSchedulesCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_queryDescribeSnapshotSchedulesCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryDescribeSnapshotSchedulesOutputMessage(
    data.DescribeSnapshotSchedulesResult,
    context
  );
  const response: DescribeSnapshotSchedulesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeSnapshotSchedulesOutputMessage",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_queryDescribeSnapshotSchedulesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeSnapshotSchedulesCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_queryDescribeStorageCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeStorageCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_queryDescribeStorageCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryCustomerStorageMessage(
    data.DescribeStorageResult,
    context
  );
  const response: DescribeStorageCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CustomerStorageMessage",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_queryDescribeStorageCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeStorageCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_queryDescribeTableRestoreStatusCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeTableRestoreStatusCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_queryDescribeTableRestoreStatusCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryTableRestoreStatusMessage(
    data.DescribeTableRestoreStatusResult,
    context
  );
  const response: DescribeTableRestoreStatusCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "TableRestoreStatusMessage",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_queryDescribeTableRestoreStatusCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeTableRestoreStatusCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ClusterNotFoundFault":
    case "redshift.admin#ClusterNotFoundFault":
      response = await deserializeAws_queryClusterNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "TableRestoreNotFoundFault":
    case "redshift.admin#TableRestoreNotFoundFault":
      response = await deserializeAws_queryTableRestoreNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_queryDescribeTagsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeTagsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_queryDescribeTagsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryTaggedResourceListMessage(
    data.DescribeTagsResult,
    context
  );
  const response: DescribeTagsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "TaggedResourceListMessage",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_queryDescribeTagsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeTagsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidTagFault":
    case "redshift.admin#InvalidTagFault":
      response = await deserializeAws_queryInvalidTagFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceNotFoundFault":
    case "redshift.admin#ResourceNotFoundFault":
      response = await deserializeAws_queryResourceNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_queryDisableLoggingCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DisableLoggingCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_queryDisableLoggingCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryLoggingStatus(
    data.DisableLoggingResult,
    context
  );
  const response: DisableLoggingCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "LoggingStatus",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_queryDisableLoggingCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DisableLoggingCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ClusterNotFoundFault":
    case "redshift.admin#ClusterNotFoundFault":
      response = await deserializeAws_queryClusterNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_queryDisableSnapshotCopyCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DisableSnapshotCopyCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_queryDisableSnapshotCopyCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryDisableSnapshotCopyResult(
    data.DisableSnapshotCopyResult,
    context
  );
  const response: DisableSnapshotCopyCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DisableSnapshotCopyResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_queryDisableSnapshotCopyCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DisableSnapshotCopyCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ClusterNotFoundFault":
    case "redshift.admin#ClusterNotFoundFault":
      response = await deserializeAws_queryClusterNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidClusterStateFault":
    case "redshift.admin#InvalidClusterStateFault":
      response = await deserializeAws_queryInvalidClusterStateFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "SnapshotCopyAlreadyDisabledFault":
    case "redshift.admin#SnapshotCopyAlreadyDisabledFault":
      response = await deserializeAws_querySnapshotCopyAlreadyDisabledFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "UnauthorizedOperation":
    case "redshift.admin#UnauthorizedOperation":
      response = await deserializeAws_queryUnauthorizedOperationResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_queryEnableLoggingCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<EnableLoggingCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_queryEnableLoggingCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryLoggingStatus(
    data.EnableLoggingResult,
    context
  );
  const response: EnableLoggingCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "LoggingStatus",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_queryEnableLoggingCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<EnableLoggingCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BucketNotFoundFault":
    case "redshift.admin#BucketNotFoundFault":
      response = await deserializeAws_queryBucketNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "ClusterNotFoundFault":
    case "redshift.admin#ClusterNotFoundFault":
      response = await deserializeAws_queryClusterNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "InsufficientS3BucketPolicyFault":
    case "redshift.admin#InsufficientS3BucketPolicyFault":
      response = await deserializeAws_queryInsufficientS3BucketPolicyFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidS3BucketNameFault":
    case "redshift.admin#InvalidS3BucketNameFault":
      response = await deserializeAws_queryInvalidS3BucketNameFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidS3KeyPrefixFault":
    case "redshift.admin#InvalidS3KeyPrefixFault":
      response = await deserializeAws_queryInvalidS3KeyPrefixFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_queryEnableSnapshotCopyCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<EnableSnapshotCopyCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_queryEnableSnapshotCopyCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryEnableSnapshotCopyResult(
    data.EnableSnapshotCopyResult,
    context
  );
  const response: EnableSnapshotCopyCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "EnableSnapshotCopyResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_queryEnableSnapshotCopyCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<EnableSnapshotCopyCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ClusterNotFoundFault":
    case "redshift.admin#ClusterNotFoundFault":
      response = await deserializeAws_queryClusterNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "CopyToRegionDisabledFault":
    case "redshift.admin#CopyToRegionDisabledFault":
      response = await deserializeAws_queryCopyToRegionDisabledFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "DependentServiceRequestThrottlingFault":
    case "redshift.admin#DependentServiceRequestThrottlingFault":
      response = await deserializeAws_queryDependentServiceRequestThrottlingFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "IncompatibleOrderableOptions":
    case "redshift.admin#IncompatibleOrderableOptions":
      response = await deserializeAws_queryIncompatibleOrderableOptionsResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidClusterStateFault":
    case "redshift.admin#InvalidClusterStateFault":
      response = await deserializeAws_queryInvalidClusterStateFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidRetentionPeriodFault":
    case "redshift.admin#InvalidRetentionPeriodFault":
      response = await deserializeAws_queryInvalidRetentionPeriodFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "LimitExceededFault":
    case "redshift.admin#LimitExceededFault":
      response = await deserializeAws_queryLimitExceededFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "SnapshotCopyAlreadyEnabledFault":
    case "redshift.admin#SnapshotCopyAlreadyEnabledFault":
      response = await deserializeAws_querySnapshotCopyAlreadyEnabledFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "SnapshotCopyGrantNotFoundFault":
    case "redshift.admin#SnapshotCopyGrantNotFoundFault":
      response = await deserializeAws_querySnapshotCopyGrantNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "UnauthorizedOperation":
    case "redshift.admin#UnauthorizedOperation":
      response = await deserializeAws_queryUnauthorizedOperationResponse(
        parsedOutput,
        context
      );
      break;
    case "UnknownSnapshotCopyRegionFault":
    case "redshift.admin#UnknownSnapshotCopyRegionFault":
      response = await deserializeAws_queryUnknownSnapshotCopyRegionFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_queryGetClusterCredentialsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetClusterCredentialsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_queryGetClusterCredentialsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryClusterCredentials(
    data.GetClusterCredentialsResult,
    context
  );
  const response: GetClusterCredentialsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ClusterCredentials",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_queryGetClusterCredentialsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetClusterCredentialsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ClusterNotFoundFault":
    case "redshift.admin#ClusterNotFoundFault":
      response = await deserializeAws_queryClusterNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "UnsupportedOperationFault":
    case "redshift.admin#UnsupportedOperationFault":
      response = await deserializeAws_queryUnsupportedOperationFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_queryGetReservedNodeExchangeOfferingsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetReservedNodeExchangeOfferingsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_queryGetReservedNodeExchangeOfferingsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryGetReservedNodeExchangeOfferingsOutputMessage(
    data.GetReservedNodeExchangeOfferingsResult,
    context
  );
  const response: GetReservedNodeExchangeOfferingsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetReservedNodeExchangeOfferingsOutputMessage",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_queryGetReservedNodeExchangeOfferingsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetReservedNodeExchangeOfferingsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DependentServiceUnavailableFault":
    case "redshift.admin#DependentServiceUnavailableFault":
      response = await deserializeAws_queryDependentServiceUnavailableFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidReservedNodeStateFault":
    case "redshift.admin#InvalidReservedNodeStateFault":
      response = await deserializeAws_queryInvalidReservedNodeStateFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "ReservedNodeAlreadyMigratedFault":
    case "redshift.admin#ReservedNodeAlreadyMigratedFault":
      response = await deserializeAws_queryReservedNodeAlreadyMigratedFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "ReservedNodeNotFoundFault":
    case "redshift.admin#ReservedNodeNotFoundFault":
      response = await deserializeAws_queryReservedNodeNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "ReservedNodeOfferingNotFoundFault":
    case "redshift.admin#ReservedNodeOfferingNotFoundFault":
      response = await deserializeAws_queryReservedNodeOfferingNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "UnsupportedOperationFault":
    case "redshift.admin#UnsupportedOperationFault":
      response = await deserializeAws_queryUnsupportedOperationFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_queryModifyClusterCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyClusterCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_queryModifyClusterCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryModifyClusterResult(
    data.ModifyClusterResult,
    context
  );
  const response: ModifyClusterCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ModifyClusterResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_queryModifyClusterCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyClusterCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ClusterAlreadyExistsFault":
    case "redshift.admin#ClusterAlreadyExistsFault":
      response = await deserializeAws_queryClusterAlreadyExistsFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "ClusterNotFoundFault":
    case "redshift.admin#ClusterNotFoundFault":
      response = await deserializeAws_queryClusterNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "ClusterParameterGroupNotFoundFault":
    case "redshift.admin#ClusterParameterGroupNotFoundFault":
      response = await deserializeAws_queryClusterParameterGroupNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "ClusterSecurityGroupNotFoundFault":
    case "redshift.admin#ClusterSecurityGroupNotFoundFault":
      response = await deserializeAws_queryClusterSecurityGroupNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "DependentServiceRequestThrottlingFault":
    case "redshift.admin#DependentServiceRequestThrottlingFault":
      response = await deserializeAws_queryDependentServiceRequestThrottlingFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "HsmClientCertificateNotFoundFault":
    case "redshift.admin#HsmClientCertificateNotFoundFault":
      response = await deserializeAws_queryHsmClientCertificateNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "HsmConfigurationNotFoundFault":
    case "redshift.admin#HsmConfigurationNotFoundFault":
      response = await deserializeAws_queryHsmConfigurationNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "InsufficientClusterCapacityFault":
    case "redshift.admin#InsufficientClusterCapacityFault":
      response = await deserializeAws_queryInsufficientClusterCapacityFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidClusterSecurityGroupStateFault":
    case "redshift.admin#InvalidClusterSecurityGroupStateFault":
      response = await deserializeAws_queryInvalidClusterSecurityGroupStateFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidClusterStateFault":
    case "redshift.admin#InvalidClusterStateFault":
      response = await deserializeAws_queryInvalidClusterStateFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidClusterTrackFault":
    case "redshift.admin#InvalidClusterTrackFault":
      response = await deserializeAws_queryInvalidClusterTrackFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidElasticIpFault":
    case "redshift.admin#InvalidElasticIpFault":
      response = await deserializeAws_queryInvalidElasticIpFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidRetentionPeriodFault":
    case "redshift.admin#InvalidRetentionPeriodFault":
      response = await deserializeAws_queryInvalidRetentionPeriodFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "LimitExceededFault":
    case "redshift.admin#LimitExceededFault":
      response = await deserializeAws_queryLimitExceededFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "NumberOfNodesPerClusterLimitExceededFault":
    case "redshift.admin#NumberOfNodesPerClusterLimitExceededFault":
      response = await deserializeAws_queryNumberOfNodesPerClusterLimitExceededFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "NumberOfNodesQuotaExceededFault":
    case "redshift.admin#NumberOfNodesQuotaExceededFault":
      response = await deserializeAws_queryNumberOfNodesQuotaExceededFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "TableLimitExceededFault":
    case "redshift.admin#TableLimitExceededFault":
      response = await deserializeAws_queryTableLimitExceededFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "UnauthorizedOperation":
    case "redshift.admin#UnauthorizedOperation":
      response = await deserializeAws_queryUnauthorizedOperationResponse(
        parsedOutput,
        context
      );
      break;
    case "UnsupportedOptionFault":
    case "redshift.admin#UnsupportedOptionFault":
      response = await deserializeAws_queryUnsupportedOptionFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_queryModifyClusterDbRevisionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyClusterDbRevisionCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_queryModifyClusterDbRevisionCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryModifyClusterDbRevisionResult(
    data.ModifyClusterDbRevisionResult,
    context
  );
  const response: ModifyClusterDbRevisionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ModifyClusterDbRevisionResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_queryModifyClusterDbRevisionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyClusterDbRevisionCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ClusterNotFoundFault":
    case "redshift.admin#ClusterNotFoundFault":
      response = await deserializeAws_queryClusterNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "ClusterOnLatestRevisionFault":
    case "redshift.admin#ClusterOnLatestRevisionFault":
      response = await deserializeAws_queryClusterOnLatestRevisionFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidClusterStateFault":
    case "redshift.admin#InvalidClusterStateFault":
      response = await deserializeAws_queryInvalidClusterStateFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_queryModifyClusterIamRolesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyClusterIamRolesCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_queryModifyClusterIamRolesCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryModifyClusterIamRolesResult(
    data.ModifyClusterIamRolesResult,
    context
  );
  const response: ModifyClusterIamRolesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ModifyClusterIamRolesResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_queryModifyClusterIamRolesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyClusterIamRolesCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ClusterNotFoundFault":
    case "redshift.admin#ClusterNotFoundFault":
      response = await deserializeAws_queryClusterNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidClusterStateFault":
    case "redshift.admin#InvalidClusterStateFault":
      response = await deserializeAws_queryInvalidClusterStateFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_queryModifyClusterMaintenanceCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyClusterMaintenanceCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_queryModifyClusterMaintenanceCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryModifyClusterMaintenanceResult(
    data.ModifyClusterMaintenanceResult,
    context
  );
  const response: ModifyClusterMaintenanceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ModifyClusterMaintenanceResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_queryModifyClusterMaintenanceCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyClusterMaintenanceCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ClusterNotFoundFault":
    case "redshift.admin#ClusterNotFoundFault":
      response = await deserializeAws_queryClusterNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_queryModifyClusterParameterGroupCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyClusterParameterGroupCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_queryModifyClusterParameterGroupCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryClusterParameterGroupNameMessage(
    data.ModifyClusterParameterGroupResult,
    context
  );
  const response: ModifyClusterParameterGroupCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ClusterParameterGroupNameMessage",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_queryModifyClusterParameterGroupCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyClusterParameterGroupCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ClusterParameterGroupNotFoundFault":
    case "redshift.admin#ClusterParameterGroupNotFoundFault":
      response = await deserializeAws_queryClusterParameterGroupNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidClusterParameterGroupStateFault":
    case "redshift.admin#InvalidClusterParameterGroupStateFault":
      response = await deserializeAws_queryInvalidClusterParameterGroupStateFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_queryModifyClusterSnapshotCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyClusterSnapshotCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_queryModifyClusterSnapshotCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryModifyClusterSnapshotResult(
    data.ModifyClusterSnapshotResult,
    context
  );
  const response: ModifyClusterSnapshotCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ModifyClusterSnapshotResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_queryModifyClusterSnapshotCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyClusterSnapshotCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ClusterSnapshotNotFoundFault":
    case "redshift.admin#ClusterSnapshotNotFoundFault":
      response = await deserializeAws_queryClusterSnapshotNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidClusterSnapshotStateFault":
    case "redshift.admin#InvalidClusterSnapshotStateFault":
      response = await deserializeAws_queryInvalidClusterSnapshotStateFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidRetentionPeriodFault":
    case "redshift.admin#InvalidRetentionPeriodFault":
      response = await deserializeAws_queryInvalidRetentionPeriodFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_queryModifyClusterSnapshotScheduleCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyClusterSnapshotScheduleCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_queryModifyClusterSnapshotScheduleCommandError(
      output,
      context
    );
  }
  await collectBody(output.body, context);
  const response: ModifyClusterSnapshotScheduleCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
}

async function deserializeAws_queryModifyClusterSnapshotScheduleCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyClusterSnapshotScheduleCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ClusterNotFoundFault":
    case "redshift.admin#ClusterNotFoundFault":
      response = await deserializeAws_queryClusterNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidClusterSnapshotScheduleStateFault":
    case "redshift.admin#InvalidClusterSnapshotScheduleStateFault":
      response = await deserializeAws_queryInvalidClusterSnapshotScheduleStateFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "SnapshotScheduleNotFoundFault":
    case "redshift.admin#SnapshotScheduleNotFoundFault":
      response = await deserializeAws_querySnapshotScheduleNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_queryModifyClusterSubnetGroupCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyClusterSubnetGroupCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_queryModifyClusterSubnetGroupCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryModifyClusterSubnetGroupResult(
    data.ModifyClusterSubnetGroupResult,
    context
  );
  const response: ModifyClusterSubnetGroupCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ModifyClusterSubnetGroupResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_queryModifyClusterSubnetGroupCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyClusterSubnetGroupCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ClusterSubnetGroupNotFoundFault":
    case "redshift.admin#ClusterSubnetGroupNotFoundFault":
      response = await deserializeAws_queryClusterSubnetGroupNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "ClusterSubnetQuotaExceededFault":
    case "redshift.admin#ClusterSubnetQuotaExceededFault":
      response = await deserializeAws_queryClusterSubnetQuotaExceededFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "DependentServiceRequestThrottlingFault":
    case "redshift.admin#DependentServiceRequestThrottlingFault":
      response = await deserializeAws_queryDependentServiceRequestThrottlingFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidSubnet":
    case "redshift.admin#InvalidSubnet":
      response = await deserializeAws_queryInvalidSubnetResponse(
        parsedOutput,
        context
      );
      break;
    case "SubnetAlreadyInUse":
    case "redshift.admin#SubnetAlreadyInUse":
      response = await deserializeAws_querySubnetAlreadyInUseResponse(
        parsedOutput,
        context
      );
      break;
    case "UnauthorizedOperation":
    case "redshift.admin#UnauthorizedOperation":
      response = await deserializeAws_queryUnauthorizedOperationResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_queryModifyEventSubscriptionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyEventSubscriptionCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_queryModifyEventSubscriptionCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryModifyEventSubscriptionResult(
    data.ModifyEventSubscriptionResult,
    context
  );
  const response: ModifyEventSubscriptionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ModifyEventSubscriptionResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_queryModifyEventSubscriptionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyEventSubscriptionCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidSubscriptionStateFault":
    case "redshift.admin#InvalidSubscriptionStateFault":
      response = await deserializeAws_queryInvalidSubscriptionStateFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "SNSInvalidTopicFault":
    case "redshift.admin#SNSInvalidTopicFault":
      response = await deserializeAws_querySNSInvalidTopicFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "SNSNoAuthorizationFault":
    case "redshift.admin#SNSNoAuthorizationFault":
      response = await deserializeAws_querySNSNoAuthorizationFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "SNSTopicArnNotFoundFault":
    case "redshift.admin#SNSTopicArnNotFoundFault":
      response = await deserializeAws_querySNSTopicArnNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "SourceNotFoundFault":
    case "redshift.admin#SourceNotFoundFault":
      response = await deserializeAws_querySourceNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "SubscriptionCategoryNotFoundFault":
    case "redshift.admin#SubscriptionCategoryNotFoundFault":
      response = await deserializeAws_querySubscriptionCategoryNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "SubscriptionEventIdNotFoundFault":
    case "redshift.admin#SubscriptionEventIdNotFoundFault":
      response = await deserializeAws_querySubscriptionEventIdNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "SubscriptionNotFoundFault":
    case "redshift.admin#SubscriptionNotFoundFault":
      response = await deserializeAws_querySubscriptionNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "SubscriptionSeverityNotFoundFault":
    case "redshift.admin#SubscriptionSeverityNotFoundFault":
      response = await deserializeAws_querySubscriptionSeverityNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_queryModifyScheduledActionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyScheduledActionCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_queryModifyScheduledActionCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryScheduledAction(
    data.ModifyScheduledActionResult,
    context
  );
  const response: ModifyScheduledActionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ScheduledAction",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_queryModifyScheduledActionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyScheduledActionCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidScheduleFault":
    case "redshift.admin#InvalidScheduleFault":
      response = await deserializeAws_queryInvalidScheduleFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidScheduledActionFault":
    case "redshift.admin#InvalidScheduledActionFault":
      response = await deserializeAws_queryInvalidScheduledActionFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "ScheduledActionNotFoundFault":
    case "redshift.admin#ScheduledActionNotFoundFault":
      response = await deserializeAws_queryScheduledActionNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "ScheduledActionTypeUnsupportedFault":
    case "redshift.admin#ScheduledActionTypeUnsupportedFault":
      response = await deserializeAws_queryScheduledActionTypeUnsupportedFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "UnauthorizedOperation":
    case "redshift.admin#UnauthorizedOperation":
      response = await deserializeAws_queryUnauthorizedOperationResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_queryModifySnapshotCopyRetentionPeriodCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifySnapshotCopyRetentionPeriodCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_queryModifySnapshotCopyRetentionPeriodCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryModifySnapshotCopyRetentionPeriodResult(
    data.ModifySnapshotCopyRetentionPeriodResult,
    context
  );
  const response: ModifySnapshotCopyRetentionPeriodCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ModifySnapshotCopyRetentionPeriodResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_queryModifySnapshotCopyRetentionPeriodCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifySnapshotCopyRetentionPeriodCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ClusterNotFoundFault":
    case "redshift.admin#ClusterNotFoundFault":
      response = await deserializeAws_queryClusterNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidClusterStateFault":
    case "redshift.admin#InvalidClusterStateFault":
      response = await deserializeAws_queryInvalidClusterStateFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidRetentionPeriodFault":
    case "redshift.admin#InvalidRetentionPeriodFault":
      response = await deserializeAws_queryInvalidRetentionPeriodFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "SnapshotCopyDisabledFault":
    case "redshift.admin#SnapshotCopyDisabledFault":
      response = await deserializeAws_querySnapshotCopyDisabledFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "UnauthorizedOperation":
    case "redshift.admin#UnauthorizedOperation":
      response = await deserializeAws_queryUnauthorizedOperationResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_queryModifySnapshotScheduleCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifySnapshotScheduleCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_queryModifySnapshotScheduleCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_querySnapshotSchedule(
    data.ModifySnapshotScheduleResult,
    context
  );
  const response: ModifySnapshotScheduleCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "SnapshotSchedule",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_queryModifySnapshotScheduleCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifySnapshotScheduleCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidScheduleFault":
    case "redshift.admin#InvalidScheduleFault":
      response = await deserializeAws_queryInvalidScheduleFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "SnapshotScheduleNotFoundFault":
    case "redshift.admin#SnapshotScheduleNotFoundFault":
      response = await deserializeAws_querySnapshotScheduleNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "SnapshotScheduleUpdateInProgressFault":
    case "redshift.admin#SnapshotScheduleUpdateInProgressFault":
      response = await deserializeAws_querySnapshotScheduleUpdateInProgressFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_queryPurchaseReservedNodeOfferingCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PurchaseReservedNodeOfferingCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_queryPurchaseReservedNodeOfferingCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryPurchaseReservedNodeOfferingResult(
    data.PurchaseReservedNodeOfferingResult,
    context
  );
  const response: PurchaseReservedNodeOfferingCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "PurchaseReservedNodeOfferingResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_queryPurchaseReservedNodeOfferingCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PurchaseReservedNodeOfferingCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ReservedNodeAlreadyExistsFault":
    case "redshift.admin#ReservedNodeAlreadyExistsFault":
      response = await deserializeAws_queryReservedNodeAlreadyExistsFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "ReservedNodeOfferingNotFoundFault":
    case "redshift.admin#ReservedNodeOfferingNotFoundFault":
      response = await deserializeAws_queryReservedNodeOfferingNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "ReservedNodeQuotaExceededFault":
    case "redshift.admin#ReservedNodeQuotaExceededFault":
      response = await deserializeAws_queryReservedNodeQuotaExceededFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "UnsupportedOperationFault":
    case "redshift.admin#UnsupportedOperationFault":
      response = await deserializeAws_queryUnsupportedOperationFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_queryRebootClusterCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RebootClusterCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_queryRebootClusterCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryRebootClusterResult(
    data.RebootClusterResult,
    context
  );
  const response: RebootClusterCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "RebootClusterResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_queryRebootClusterCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RebootClusterCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ClusterNotFoundFault":
    case "redshift.admin#ClusterNotFoundFault":
      response = await deserializeAws_queryClusterNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidClusterStateFault":
    case "redshift.admin#InvalidClusterStateFault":
      response = await deserializeAws_queryInvalidClusterStateFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_queryResetClusterParameterGroupCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ResetClusterParameterGroupCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_queryResetClusterParameterGroupCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryClusterParameterGroupNameMessage(
    data.ResetClusterParameterGroupResult,
    context
  );
  const response: ResetClusterParameterGroupCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ClusterParameterGroupNameMessage",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_queryResetClusterParameterGroupCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ResetClusterParameterGroupCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ClusterParameterGroupNotFoundFault":
    case "redshift.admin#ClusterParameterGroupNotFoundFault":
      response = await deserializeAws_queryClusterParameterGroupNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidClusterParameterGroupStateFault":
    case "redshift.admin#InvalidClusterParameterGroupStateFault":
      response = await deserializeAws_queryInvalidClusterParameterGroupStateFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_queryResizeClusterCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ResizeClusterCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_queryResizeClusterCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryResizeClusterResult(
    data.ResizeClusterResult,
    context
  );
  const response: ResizeClusterCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ResizeClusterResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_queryResizeClusterCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ResizeClusterCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ClusterNotFoundFault":
    case "redshift.admin#ClusterNotFoundFault":
      response = await deserializeAws_queryClusterNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "InsufficientClusterCapacityFault":
    case "redshift.admin#InsufficientClusterCapacityFault":
      response = await deserializeAws_queryInsufficientClusterCapacityFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidClusterStateFault":
    case "redshift.admin#InvalidClusterStateFault":
      response = await deserializeAws_queryInvalidClusterStateFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "LimitExceededFault":
    case "redshift.admin#LimitExceededFault":
      response = await deserializeAws_queryLimitExceededFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "NumberOfNodesPerClusterLimitExceededFault":
    case "redshift.admin#NumberOfNodesPerClusterLimitExceededFault":
      response = await deserializeAws_queryNumberOfNodesPerClusterLimitExceededFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "NumberOfNodesQuotaExceededFault":
    case "redshift.admin#NumberOfNodesQuotaExceededFault":
      response = await deserializeAws_queryNumberOfNodesQuotaExceededFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "UnauthorizedOperation":
    case "redshift.admin#UnauthorizedOperation":
      response = await deserializeAws_queryUnauthorizedOperationResponse(
        parsedOutput,
        context
      );
      break;
    case "UnsupportedOperationFault":
    case "redshift.admin#UnsupportedOperationFault":
      response = await deserializeAws_queryUnsupportedOperationFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "UnsupportedOptionFault":
    case "redshift.admin#UnsupportedOptionFault":
      response = await deserializeAws_queryUnsupportedOptionFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_queryRestoreFromClusterSnapshotCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RestoreFromClusterSnapshotCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_queryRestoreFromClusterSnapshotCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryRestoreFromClusterSnapshotResult(
    data.RestoreFromClusterSnapshotResult,
    context
  );
  const response: RestoreFromClusterSnapshotCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "RestoreFromClusterSnapshotResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_queryRestoreFromClusterSnapshotCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RestoreFromClusterSnapshotCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessToSnapshotDeniedFault":
    case "redshift.admin#AccessToSnapshotDeniedFault":
      response = await deserializeAws_queryAccessToSnapshotDeniedFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "ClusterAlreadyExistsFault":
    case "redshift.admin#ClusterAlreadyExistsFault":
      response = await deserializeAws_queryClusterAlreadyExistsFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "ClusterParameterGroupNotFoundFault":
    case "redshift.admin#ClusterParameterGroupNotFoundFault":
      response = await deserializeAws_queryClusterParameterGroupNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "ClusterQuotaExceededFault":
    case "redshift.admin#ClusterQuotaExceededFault":
      response = await deserializeAws_queryClusterQuotaExceededFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "ClusterSecurityGroupNotFoundFault":
    case "redshift.admin#ClusterSecurityGroupNotFoundFault":
      response = await deserializeAws_queryClusterSecurityGroupNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "ClusterSnapshotNotFoundFault":
    case "redshift.admin#ClusterSnapshotNotFoundFault":
      response = await deserializeAws_queryClusterSnapshotNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "ClusterSubnetGroupNotFoundFault":
    case "redshift.admin#ClusterSubnetGroupNotFoundFault":
      response = await deserializeAws_queryClusterSubnetGroupNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "DependentServiceRequestThrottlingFault":
    case "redshift.admin#DependentServiceRequestThrottlingFault":
      response = await deserializeAws_queryDependentServiceRequestThrottlingFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "HsmClientCertificateNotFoundFault":
    case "redshift.admin#HsmClientCertificateNotFoundFault":
      response = await deserializeAws_queryHsmClientCertificateNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "HsmConfigurationNotFoundFault":
    case "redshift.admin#HsmConfigurationNotFoundFault":
      response = await deserializeAws_queryHsmConfigurationNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "InsufficientClusterCapacityFault":
    case "redshift.admin#InsufficientClusterCapacityFault":
      response = await deserializeAws_queryInsufficientClusterCapacityFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidClusterSnapshotStateFault":
    case "redshift.admin#InvalidClusterSnapshotStateFault":
      response = await deserializeAws_queryInvalidClusterSnapshotStateFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidClusterSubnetGroupStateFault":
    case "redshift.admin#InvalidClusterSubnetGroupStateFault":
      response = await deserializeAws_queryInvalidClusterSubnetGroupStateFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidClusterTrackFault":
    case "redshift.admin#InvalidClusterTrackFault":
      response = await deserializeAws_queryInvalidClusterTrackFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidElasticIpFault":
    case "redshift.admin#InvalidElasticIpFault":
      response = await deserializeAws_queryInvalidElasticIpFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidRestoreFault":
    case "redshift.admin#InvalidRestoreFault":
      response = await deserializeAws_queryInvalidRestoreFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidSubnet":
    case "redshift.admin#InvalidSubnet":
      response = await deserializeAws_queryInvalidSubnetResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidTagFault":
    case "redshift.admin#InvalidTagFault":
      response = await deserializeAws_queryInvalidTagFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidVPCNetworkStateFault":
    case "redshift.admin#InvalidVPCNetworkStateFault":
      response = await deserializeAws_queryInvalidVPCNetworkStateFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "LimitExceededFault":
    case "redshift.admin#LimitExceededFault":
      response = await deserializeAws_queryLimitExceededFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "NumberOfNodesPerClusterLimitExceededFault":
    case "redshift.admin#NumberOfNodesPerClusterLimitExceededFault":
      response = await deserializeAws_queryNumberOfNodesPerClusterLimitExceededFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "NumberOfNodesQuotaExceededFault":
    case "redshift.admin#NumberOfNodesQuotaExceededFault":
      response = await deserializeAws_queryNumberOfNodesQuotaExceededFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "SnapshotScheduleNotFoundFault":
    case "redshift.admin#SnapshotScheduleNotFoundFault":
      response = await deserializeAws_querySnapshotScheduleNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "TagLimitExceededFault":
    case "redshift.admin#TagLimitExceededFault":
      response = await deserializeAws_queryTagLimitExceededFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "UnauthorizedOperation":
    case "redshift.admin#UnauthorizedOperation":
      response = await deserializeAws_queryUnauthorizedOperationResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_queryRestoreTableFromClusterSnapshotCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RestoreTableFromClusterSnapshotCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_queryRestoreTableFromClusterSnapshotCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryRestoreTableFromClusterSnapshotResult(
    data.RestoreTableFromClusterSnapshotResult,
    context
  );
  const response: RestoreTableFromClusterSnapshotCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "RestoreTableFromClusterSnapshotResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_queryRestoreTableFromClusterSnapshotCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RestoreTableFromClusterSnapshotCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ClusterNotFoundFault":
    case "redshift.admin#ClusterNotFoundFault":
      response = await deserializeAws_queryClusterNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "ClusterSnapshotNotFoundFault":
    case "redshift.admin#ClusterSnapshotNotFoundFault":
      response = await deserializeAws_queryClusterSnapshotNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "InProgressTableRestoreQuotaExceededFault":
    case "redshift.admin#InProgressTableRestoreQuotaExceededFault":
      response = await deserializeAws_queryInProgressTableRestoreQuotaExceededFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidClusterSnapshotStateFault":
    case "redshift.admin#InvalidClusterSnapshotStateFault":
      response = await deserializeAws_queryInvalidClusterSnapshotStateFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidClusterStateFault":
    case "redshift.admin#InvalidClusterStateFault":
      response = await deserializeAws_queryInvalidClusterStateFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidTableRestoreArgumentFault":
    case "redshift.admin#InvalidTableRestoreArgumentFault":
      response = await deserializeAws_queryInvalidTableRestoreArgumentFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "UnsupportedOperationFault":
    case "redshift.admin#UnsupportedOperationFault":
      response = await deserializeAws_queryUnsupportedOperationFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_queryRevokeClusterSecurityGroupIngressCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RevokeClusterSecurityGroupIngressCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_queryRevokeClusterSecurityGroupIngressCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryRevokeClusterSecurityGroupIngressResult(
    data.RevokeClusterSecurityGroupIngressResult,
    context
  );
  const response: RevokeClusterSecurityGroupIngressCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "RevokeClusterSecurityGroupIngressResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_queryRevokeClusterSecurityGroupIngressCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RevokeClusterSecurityGroupIngressCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AuthorizationNotFoundFault":
    case "redshift.admin#AuthorizationNotFoundFault":
      response = await deserializeAws_queryAuthorizationNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "ClusterSecurityGroupNotFoundFault":
    case "redshift.admin#ClusterSecurityGroupNotFoundFault":
      response = await deserializeAws_queryClusterSecurityGroupNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidClusterSecurityGroupStateFault":
    case "redshift.admin#InvalidClusterSecurityGroupStateFault":
      response = await deserializeAws_queryInvalidClusterSecurityGroupStateFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_queryRevokeSnapshotAccessCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RevokeSnapshotAccessCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_queryRevokeSnapshotAccessCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryRevokeSnapshotAccessResult(
    data.RevokeSnapshotAccessResult,
    context
  );
  const response: RevokeSnapshotAccessCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "RevokeSnapshotAccessResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_queryRevokeSnapshotAccessCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RevokeSnapshotAccessCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessToSnapshotDeniedFault":
    case "redshift.admin#AccessToSnapshotDeniedFault":
      response = await deserializeAws_queryAccessToSnapshotDeniedFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "AuthorizationNotFoundFault":
    case "redshift.admin#AuthorizationNotFoundFault":
      response = await deserializeAws_queryAuthorizationNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "ClusterSnapshotNotFoundFault":
    case "redshift.admin#ClusterSnapshotNotFoundFault":
      response = await deserializeAws_queryClusterSnapshotNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_queryRotateEncryptionKeyCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RotateEncryptionKeyCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_queryRotateEncryptionKeyCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryRotateEncryptionKeyResult(
    data.RotateEncryptionKeyResult,
    context
  );
  const response: RotateEncryptionKeyCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "RotateEncryptionKeyResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_queryRotateEncryptionKeyCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RotateEncryptionKeyCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ClusterNotFoundFault":
    case "redshift.admin#ClusterNotFoundFault":
      response = await deserializeAws_queryClusterNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "DependentServiceRequestThrottlingFault":
    case "redshift.admin#DependentServiceRequestThrottlingFault":
      response = await deserializeAws_queryDependentServiceRequestThrottlingFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidClusterStateFault":
    case "redshift.admin#InvalidClusterStateFault":
      response = await deserializeAws_queryInvalidClusterStateFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

const deserializeAws_queryAccessToSnapshotDeniedFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<AccessToSnapshotDeniedFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryAccessToSnapshotDeniedFault(
    body.Error,
    context
  );
  const contents: AccessToSnapshotDeniedFault = {
    name: "AccessToSnapshotDeniedFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryAuthorizationAlreadyExistsFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<AuthorizationAlreadyExistsFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryAuthorizationAlreadyExistsFault(
    body.Error,
    context
  );
  const contents: AuthorizationAlreadyExistsFault = {
    name: "AuthorizationAlreadyExistsFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryAuthorizationNotFoundFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<AuthorizationNotFoundFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryAuthorizationNotFoundFault(
    body.Error,
    context
  );
  const contents: AuthorizationNotFoundFault = {
    name: "AuthorizationNotFoundFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryAuthorizationQuotaExceededFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<AuthorizationQuotaExceededFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryAuthorizationQuotaExceededFault(
    body.Error,
    context
  );
  const contents: AuthorizationQuotaExceededFault = {
    name: "AuthorizationQuotaExceededFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryBatchDeleteRequestSizeExceededFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<BatchDeleteRequestSizeExceededFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryBatchDeleteRequestSizeExceededFault(
    body.Error,
    context
  );
  const contents: BatchDeleteRequestSizeExceededFault = {
    name: "BatchDeleteRequestSizeExceededFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryBatchModifyClusterSnapshotsLimitExceededFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<BatchModifyClusterSnapshotsLimitExceededFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryBatchModifyClusterSnapshotsLimitExceededFault(
    body.Error,
    context
  );
  const contents: BatchModifyClusterSnapshotsLimitExceededFault = {
    name: "BatchModifyClusterSnapshotsLimitExceededFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryBucketNotFoundFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<BucketNotFoundFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryBucketNotFoundFault(
    body.Error,
    context
  );
  const contents: BucketNotFoundFault = {
    name: "BucketNotFoundFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryClusterAlreadyExistsFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ClusterAlreadyExistsFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryClusterAlreadyExistsFault(
    body.Error,
    context
  );
  const contents: ClusterAlreadyExistsFault = {
    name: "ClusterAlreadyExistsFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryClusterNotFoundFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ClusterNotFoundFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryClusterNotFoundFault(
    body.Error,
    context
  );
  const contents: ClusterNotFoundFault = {
    name: "ClusterNotFoundFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryClusterOnLatestRevisionFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ClusterOnLatestRevisionFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryClusterOnLatestRevisionFault(
    body.Error,
    context
  );
  const contents: ClusterOnLatestRevisionFault = {
    name: "ClusterOnLatestRevisionFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryClusterParameterGroupAlreadyExistsFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ClusterParameterGroupAlreadyExistsFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryClusterParameterGroupAlreadyExistsFault(
    body.Error,
    context
  );
  const contents: ClusterParameterGroupAlreadyExistsFault = {
    name: "ClusterParameterGroupAlreadyExistsFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryClusterParameterGroupNotFoundFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ClusterParameterGroupNotFoundFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryClusterParameterGroupNotFoundFault(
    body.Error,
    context
  );
  const contents: ClusterParameterGroupNotFoundFault = {
    name: "ClusterParameterGroupNotFoundFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryClusterParameterGroupQuotaExceededFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ClusterParameterGroupQuotaExceededFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryClusterParameterGroupQuotaExceededFault(
    body.Error,
    context
  );
  const contents: ClusterParameterGroupQuotaExceededFault = {
    name: "ClusterParameterGroupQuotaExceededFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryClusterQuotaExceededFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ClusterQuotaExceededFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryClusterQuotaExceededFault(
    body.Error,
    context
  );
  const contents: ClusterQuotaExceededFault = {
    name: "ClusterQuotaExceededFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryClusterSecurityGroupAlreadyExistsFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ClusterSecurityGroupAlreadyExistsFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryClusterSecurityGroupAlreadyExistsFault(
    body.Error,
    context
  );
  const contents: ClusterSecurityGroupAlreadyExistsFault = {
    name: "ClusterSecurityGroupAlreadyExistsFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryClusterSecurityGroupNotFoundFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ClusterSecurityGroupNotFoundFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryClusterSecurityGroupNotFoundFault(
    body.Error,
    context
  );
  const contents: ClusterSecurityGroupNotFoundFault = {
    name: "ClusterSecurityGroupNotFoundFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryClusterSecurityGroupQuotaExceededFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ClusterSecurityGroupQuotaExceededFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryClusterSecurityGroupQuotaExceededFault(
    body.Error,
    context
  );
  const contents: ClusterSecurityGroupQuotaExceededFault = {
    name: "ClusterSecurityGroupQuotaExceededFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryClusterSnapshotAlreadyExistsFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ClusterSnapshotAlreadyExistsFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryClusterSnapshotAlreadyExistsFault(
    body.Error,
    context
  );
  const contents: ClusterSnapshotAlreadyExistsFault = {
    name: "ClusterSnapshotAlreadyExistsFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryClusterSnapshotNotFoundFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ClusterSnapshotNotFoundFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryClusterSnapshotNotFoundFault(
    body.Error,
    context
  );
  const contents: ClusterSnapshotNotFoundFault = {
    name: "ClusterSnapshotNotFoundFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryClusterSnapshotQuotaExceededFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ClusterSnapshotQuotaExceededFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryClusterSnapshotQuotaExceededFault(
    body.Error,
    context
  );
  const contents: ClusterSnapshotQuotaExceededFault = {
    name: "ClusterSnapshotQuotaExceededFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryClusterSubnetGroupAlreadyExistsFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ClusterSubnetGroupAlreadyExistsFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryClusterSubnetGroupAlreadyExistsFault(
    body.Error,
    context
  );
  const contents: ClusterSubnetGroupAlreadyExistsFault = {
    name: "ClusterSubnetGroupAlreadyExistsFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryClusterSubnetGroupNotFoundFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ClusterSubnetGroupNotFoundFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryClusterSubnetGroupNotFoundFault(
    body.Error,
    context
  );
  const contents: ClusterSubnetGroupNotFoundFault = {
    name: "ClusterSubnetGroupNotFoundFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryClusterSubnetGroupQuotaExceededFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ClusterSubnetGroupQuotaExceededFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryClusterSubnetGroupQuotaExceededFault(
    body.Error,
    context
  );
  const contents: ClusterSubnetGroupQuotaExceededFault = {
    name: "ClusterSubnetGroupQuotaExceededFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryClusterSubnetQuotaExceededFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ClusterSubnetQuotaExceededFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryClusterSubnetQuotaExceededFault(
    body.Error,
    context
  );
  const contents: ClusterSubnetQuotaExceededFault = {
    name: "ClusterSubnetQuotaExceededFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryCopyToRegionDisabledFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<CopyToRegionDisabledFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryCopyToRegionDisabledFault(
    body.Error,
    context
  );
  const contents: CopyToRegionDisabledFault = {
    name: "CopyToRegionDisabledFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryDependentServiceRequestThrottlingFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<DependentServiceRequestThrottlingFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryDependentServiceRequestThrottlingFault(
    body.Error,
    context
  );
  const contents: DependentServiceRequestThrottlingFault = {
    name: "DependentServiceRequestThrottlingFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryDependentServiceUnavailableFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<DependentServiceUnavailableFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryDependentServiceUnavailableFault(
    body.Error,
    context
  );
  const contents: DependentServiceUnavailableFault = {
    name: "DependentServiceUnavailableFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryEventSubscriptionQuotaExceededFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<EventSubscriptionQuotaExceededFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryEventSubscriptionQuotaExceededFault(
    body.Error,
    context
  );
  const contents: EventSubscriptionQuotaExceededFault = {
    name: "EventSubscriptionQuotaExceededFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryHsmClientCertificateAlreadyExistsFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<HsmClientCertificateAlreadyExistsFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryHsmClientCertificateAlreadyExistsFault(
    body.Error,
    context
  );
  const contents: HsmClientCertificateAlreadyExistsFault = {
    name: "HsmClientCertificateAlreadyExistsFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryHsmClientCertificateNotFoundFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<HsmClientCertificateNotFoundFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryHsmClientCertificateNotFoundFault(
    body.Error,
    context
  );
  const contents: HsmClientCertificateNotFoundFault = {
    name: "HsmClientCertificateNotFoundFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryHsmClientCertificateQuotaExceededFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<HsmClientCertificateQuotaExceededFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryHsmClientCertificateQuotaExceededFault(
    body.Error,
    context
  );
  const contents: HsmClientCertificateQuotaExceededFault = {
    name: "HsmClientCertificateQuotaExceededFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryHsmConfigurationAlreadyExistsFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<HsmConfigurationAlreadyExistsFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryHsmConfigurationAlreadyExistsFault(
    body.Error,
    context
  );
  const contents: HsmConfigurationAlreadyExistsFault = {
    name: "HsmConfigurationAlreadyExistsFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryHsmConfigurationNotFoundFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<HsmConfigurationNotFoundFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryHsmConfigurationNotFoundFault(
    body.Error,
    context
  );
  const contents: HsmConfigurationNotFoundFault = {
    name: "HsmConfigurationNotFoundFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryHsmConfigurationQuotaExceededFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<HsmConfigurationQuotaExceededFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryHsmConfigurationQuotaExceededFault(
    body.Error,
    context
  );
  const contents: HsmConfigurationQuotaExceededFault = {
    name: "HsmConfigurationQuotaExceededFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryInProgressTableRestoreQuotaExceededFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InProgressTableRestoreQuotaExceededFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryInProgressTableRestoreQuotaExceededFault(
    body.Error,
    context
  );
  const contents: InProgressTableRestoreQuotaExceededFault = {
    name: "InProgressTableRestoreQuotaExceededFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryIncompatibleOrderableOptionsResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<IncompatibleOrderableOptions> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryIncompatibleOrderableOptions(
    body.Error,
    context
  );
  const contents: IncompatibleOrderableOptions = {
    name: "IncompatibleOrderableOptions",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryInsufficientClusterCapacityFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InsufficientClusterCapacityFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryInsufficientClusterCapacityFault(
    body.Error,
    context
  );
  const contents: InsufficientClusterCapacityFault = {
    name: "InsufficientClusterCapacityFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryInsufficientS3BucketPolicyFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InsufficientS3BucketPolicyFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryInsufficientS3BucketPolicyFault(
    body.Error,
    context
  );
  const contents: InsufficientS3BucketPolicyFault = {
    name: "InsufficientS3BucketPolicyFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryInvalidClusterParameterGroupStateFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidClusterParameterGroupStateFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryInvalidClusterParameterGroupStateFault(
    body.Error,
    context
  );
  const contents: InvalidClusterParameterGroupStateFault = {
    name: "InvalidClusterParameterGroupStateFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryInvalidClusterSecurityGroupStateFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidClusterSecurityGroupStateFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryInvalidClusterSecurityGroupStateFault(
    body.Error,
    context
  );
  const contents: InvalidClusterSecurityGroupStateFault = {
    name: "InvalidClusterSecurityGroupStateFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryInvalidClusterSnapshotScheduleStateFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidClusterSnapshotScheduleStateFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryInvalidClusterSnapshotScheduleStateFault(
    body.Error,
    context
  );
  const contents: InvalidClusterSnapshotScheduleStateFault = {
    name: "InvalidClusterSnapshotScheduleStateFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryInvalidClusterSnapshotStateFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidClusterSnapshotStateFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryInvalidClusterSnapshotStateFault(
    body.Error,
    context
  );
  const contents: InvalidClusterSnapshotStateFault = {
    name: "InvalidClusterSnapshotStateFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryInvalidClusterStateFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidClusterStateFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryInvalidClusterStateFault(
    body.Error,
    context
  );
  const contents: InvalidClusterStateFault = {
    name: "InvalidClusterStateFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryInvalidClusterSubnetGroupStateFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidClusterSubnetGroupStateFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryInvalidClusterSubnetGroupStateFault(
    body.Error,
    context
  );
  const contents: InvalidClusterSubnetGroupStateFault = {
    name: "InvalidClusterSubnetGroupStateFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryInvalidClusterSubnetStateFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidClusterSubnetStateFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryInvalidClusterSubnetStateFault(
    body.Error,
    context
  );
  const contents: InvalidClusterSubnetStateFault = {
    name: "InvalidClusterSubnetStateFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryInvalidClusterTrackFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidClusterTrackFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryInvalidClusterTrackFault(
    body.Error,
    context
  );
  const contents: InvalidClusterTrackFault = {
    name: "InvalidClusterTrackFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryInvalidElasticIpFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidElasticIpFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryInvalidElasticIpFault(
    body.Error,
    context
  );
  const contents: InvalidElasticIpFault = {
    name: "InvalidElasticIpFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryInvalidHsmClientCertificateStateFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidHsmClientCertificateStateFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryInvalidHsmClientCertificateStateFault(
    body.Error,
    context
  );
  const contents: InvalidHsmClientCertificateStateFault = {
    name: "InvalidHsmClientCertificateStateFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryInvalidHsmConfigurationStateFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidHsmConfigurationStateFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryInvalidHsmConfigurationStateFault(
    body.Error,
    context
  );
  const contents: InvalidHsmConfigurationStateFault = {
    name: "InvalidHsmConfigurationStateFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryInvalidReservedNodeStateFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidReservedNodeStateFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryInvalidReservedNodeStateFault(
    body.Error,
    context
  );
  const contents: InvalidReservedNodeStateFault = {
    name: "InvalidReservedNodeStateFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryInvalidRestoreFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidRestoreFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryInvalidRestoreFault(
    body.Error,
    context
  );
  const contents: InvalidRestoreFault = {
    name: "InvalidRestoreFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryInvalidRetentionPeriodFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidRetentionPeriodFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryInvalidRetentionPeriodFault(
    body.Error,
    context
  );
  const contents: InvalidRetentionPeriodFault = {
    name: "InvalidRetentionPeriodFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryInvalidS3BucketNameFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidS3BucketNameFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryInvalidS3BucketNameFault(
    body.Error,
    context
  );
  const contents: InvalidS3BucketNameFault = {
    name: "InvalidS3BucketNameFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryInvalidS3KeyPrefixFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidS3KeyPrefixFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryInvalidS3KeyPrefixFault(
    body.Error,
    context
  );
  const contents: InvalidS3KeyPrefixFault = {
    name: "InvalidS3KeyPrefixFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryInvalidScheduleFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidScheduleFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryInvalidScheduleFault(
    body.Error,
    context
  );
  const contents: InvalidScheduleFault = {
    name: "InvalidScheduleFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryInvalidScheduledActionFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidScheduledActionFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryInvalidScheduledActionFault(
    body.Error,
    context
  );
  const contents: InvalidScheduledActionFault = {
    name: "InvalidScheduledActionFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryInvalidSnapshotCopyGrantStateFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidSnapshotCopyGrantStateFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryInvalidSnapshotCopyGrantStateFault(
    body.Error,
    context
  );
  const contents: InvalidSnapshotCopyGrantStateFault = {
    name: "InvalidSnapshotCopyGrantStateFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryInvalidSubnetResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidSubnet> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryInvalidSubnet(
    body.Error,
    context
  );
  const contents: InvalidSubnet = {
    name: "InvalidSubnet",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryInvalidSubscriptionStateFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidSubscriptionStateFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryInvalidSubscriptionStateFault(
    body.Error,
    context
  );
  const contents: InvalidSubscriptionStateFault = {
    name: "InvalidSubscriptionStateFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryInvalidTableRestoreArgumentFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidTableRestoreArgumentFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryInvalidTableRestoreArgumentFault(
    body.Error,
    context
  );
  const contents: InvalidTableRestoreArgumentFault = {
    name: "InvalidTableRestoreArgumentFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryInvalidTagFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidTagFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryInvalidTagFault(
    body.Error,
    context
  );
  const contents: InvalidTagFault = {
    name: "InvalidTagFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryInvalidVPCNetworkStateFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidVPCNetworkStateFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryInvalidVPCNetworkStateFault(
    body.Error,
    context
  );
  const contents: InvalidVPCNetworkStateFault = {
    name: "InvalidVPCNetworkStateFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryLimitExceededFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<LimitExceededFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryLimitExceededFault(
    body.Error,
    context
  );
  const contents: LimitExceededFault = {
    name: "LimitExceededFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryNumberOfNodesPerClusterLimitExceededFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<NumberOfNodesPerClusterLimitExceededFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryNumberOfNodesPerClusterLimitExceededFault(
    body.Error,
    context
  );
  const contents: NumberOfNodesPerClusterLimitExceededFault = {
    name: "NumberOfNodesPerClusterLimitExceededFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryNumberOfNodesQuotaExceededFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<NumberOfNodesQuotaExceededFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryNumberOfNodesQuotaExceededFault(
    body.Error,
    context
  );
  const contents: NumberOfNodesQuotaExceededFault = {
    name: "NumberOfNodesQuotaExceededFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryReservedNodeAlreadyExistsFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ReservedNodeAlreadyExistsFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryReservedNodeAlreadyExistsFault(
    body.Error,
    context
  );
  const contents: ReservedNodeAlreadyExistsFault = {
    name: "ReservedNodeAlreadyExistsFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryReservedNodeAlreadyMigratedFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ReservedNodeAlreadyMigratedFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryReservedNodeAlreadyMigratedFault(
    body.Error,
    context
  );
  const contents: ReservedNodeAlreadyMigratedFault = {
    name: "ReservedNodeAlreadyMigratedFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryReservedNodeNotFoundFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ReservedNodeNotFoundFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryReservedNodeNotFoundFault(
    body.Error,
    context
  );
  const contents: ReservedNodeNotFoundFault = {
    name: "ReservedNodeNotFoundFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryReservedNodeOfferingNotFoundFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ReservedNodeOfferingNotFoundFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryReservedNodeOfferingNotFoundFault(
    body.Error,
    context
  );
  const contents: ReservedNodeOfferingNotFoundFault = {
    name: "ReservedNodeOfferingNotFoundFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryReservedNodeQuotaExceededFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ReservedNodeQuotaExceededFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryReservedNodeQuotaExceededFault(
    body.Error,
    context
  );
  const contents: ReservedNodeQuotaExceededFault = {
    name: "ReservedNodeQuotaExceededFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryResizeNotFoundFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ResizeNotFoundFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryResizeNotFoundFault(
    body.Error,
    context
  );
  const contents: ResizeNotFoundFault = {
    name: "ResizeNotFoundFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryResourceNotFoundFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ResourceNotFoundFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryResourceNotFoundFault(
    body.Error,
    context
  );
  const contents: ResourceNotFoundFault = {
    name: "ResourceNotFoundFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_querySNSInvalidTopicFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<SNSInvalidTopicFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_querySNSInvalidTopicFault(
    body.Error,
    context
  );
  const contents: SNSInvalidTopicFault = {
    name: "SNSInvalidTopicFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_querySNSNoAuthorizationFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<SNSNoAuthorizationFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_querySNSNoAuthorizationFault(
    body.Error,
    context
  );
  const contents: SNSNoAuthorizationFault = {
    name: "SNSNoAuthorizationFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_querySNSTopicArnNotFoundFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<SNSTopicArnNotFoundFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_querySNSTopicArnNotFoundFault(
    body.Error,
    context
  );
  const contents: SNSTopicArnNotFoundFault = {
    name: "SNSTopicArnNotFoundFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryScheduleDefinitionTypeUnsupportedFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ScheduleDefinitionTypeUnsupportedFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryScheduleDefinitionTypeUnsupportedFault(
    body.Error,
    context
  );
  const contents: ScheduleDefinitionTypeUnsupportedFault = {
    name: "ScheduleDefinitionTypeUnsupportedFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryScheduledActionAlreadyExistsFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ScheduledActionAlreadyExistsFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryScheduledActionAlreadyExistsFault(
    body.Error,
    context
  );
  const contents: ScheduledActionAlreadyExistsFault = {
    name: "ScheduledActionAlreadyExistsFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryScheduledActionNotFoundFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ScheduledActionNotFoundFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryScheduledActionNotFoundFault(
    body.Error,
    context
  );
  const contents: ScheduledActionNotFoundFault = {
    name: "ScheduledActionNotFoundFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryScheduledActionQuotaExceededFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ScheduledActionQuotaExceededFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryScheduledActionQuotaExceededFault(
    body.Error,
    context
  );
  const contents: ScheduledActionQuotaExceededFault = {
    name: "ScheduledActionQuotaExceededFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryScheduledActionTypeUnsupportedFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ScheduledActionTypeUnsupportedFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryScheduledActionTypeUnsupportedFault(
    body.Error,
    context
  );
  const contents: ScheduledActionTypeUnsupportedFault = {
    name: "ScheduledActionTypeUnsupportedFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_querySnapshotCopyAlreadyDisabledFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<SnapshotCopyAlreadyDisabledFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_querySnapshotCopyAlreadyDisabledFault(
    body.Error,
    context
  );
  const contents: SnapshotCopyAlreadyDisabledFault = {
    name: "SnapshotCopyAlreadyDisabledFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_querySnapshotCopyAlreadyEnabledFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<SnapshotCopyAlreadyEnabledFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_querySnapshotCopyAlreadyEnabledFault(
    body.Error,
    context
  );
  const contents: SnapshotCopyAlreadyEnabledFault = {
    name: "SnapshotCopyAlreadyEnabledFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_querySnapshotCopyDisabledFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<SnapshotCopyDisabledFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_querySnapshotCopyDisabledFault(
    body.Error,
    context
  );
  const contents: SnapshotCopyDisabledFault = {
    name: "SnapshotCopyDisabledFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_querySnapshotCopyGrantAlreadyExistsFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<SnapshotCopyGrantAlreadyExistsFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_querySnapshotCopyGrantAlreadyExistsFault(
    body.Error,
    context
  );
  const contents: SnapshotCopyGrantAlreadyExistsFault = {
    name: "SnapshotCopyGrantAlreadyExistsFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_querySnapshotCopyGrantNotFoundFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<SnapshotCopyGrantNotFoundFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_querySnapshotCopyGrantNotFoundFault(
    body.Error,
    context
  );
  const contents: SnapshotCopyGrantNotFoundFault = {
    name: "SnapshotCopyGrantNotFoundFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_querySnapshotCopyGrantQuotaExceededFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<SnapshotCopyGrantQuotaExceededFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_querySnapshotCopyGrantQuotaExceededFault(
    body.Error,
    context
  );
  const contents: SnapshotCopyGrantQuotaExceededFault = {
    name: "SnapshotCopyGrantQuotaExceededFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_querySnapshotScheduleAlreadyExistsFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<SnapshotScheduleAlreadyExistsFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_querySnapshotScheduleAlreadyExistsFault(
    body.Error,
    context
  );
  const contents: SnapshotScheduleAlreadyExistsFault = {
    name: "SnapshotScheduleAlreadyExistsFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_querySnapshotScheduleNotFoundFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<SnapshotScheduleNotFoundFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_querySnapshotScheduleNotFoundFault(
    body.Error,
    context
  );
  const contents: SnapshotScheduleNotFoundFault = {
    name: "SnapshotScheduleNotFoundFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_querySnapshotScheduleQuotaExceededFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<SnapshotScheduleQuotaExceededFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_querySnapshotScheduleQuotaExceededFault(
    body.Error,
    context
  );
  const contents: SnapshotScheduleQuotaExceededFault = {
    name: "SnapshotScheduleQuotaExceededFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_querySnapshotScheduleUpdateInProgressFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<SnapshotScheduleUpdateInProgressFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_querySnapshotScheduleUpdateInProgressFault(
    body.Error,
    context
  );
  const contents: SnapshotScheduleUpdateInProgressFault = {
    name: "SnapshotScheduleUpdateInProgressFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_querySourceNotFoundFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<SourceNotFoundFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_querySourceNotFoundFault(
    body.Error,
    context
  );
  const contents: SourceNotFoundFault = {
    name: "SourceNotFoundFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_querySubnetAlreadyInUseResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<SubnetAlreadyInUse> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_querySubnetAlreadyInUse(
    body.Error,
    context
  );
  const contents: SubnetAlreadyInUse = {
    name: "SubnetAlreadyInUse",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_querySubscriptionAlreadyExistFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<SubscriptionAlreadyExistFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_querySubscriptionAlreadyExistFault(
    body.Error,
    context
  );
  const contents: SubscriptionAlreadyExistFault = {
    name: "SubscriptionAlreadyExistFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_querySubscriptionCategoryNotFoundFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<SubscriptionCategoryNotFoundFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_querySubscriptionCategoryNotFoundFault(
    body.Error,
    context
  );
  const contents: SubscriptionCategoryNotFoundFault = {
    name: "SubscriptionCategoryNotFoundFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_querySubscriptionEventIdNotFoundFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<SubscriptionEventIdNotFoundFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_querySubscriptionEventIdNotFoundFault(
    body.Error,
    context
  );
  const contents: SubscriptionEventIdNotFoundFault = {
    name: "SubscriptionEventIdNotFoundFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_querySubscriptionNotFoundFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<SubscriptionNotFoundFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_querySubscriptionNotFoundFault(
    body.Error,
    context
  );
  const contents: SubscriptionNotFoundFault = {
    name: "SubscriptionNotFoundFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_querySubscriptionSeverityNotFoundFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<SubscriptionSeverityNotFoundFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_querySubscriptionSeverityNotFoundFault(
    body.Error,
    context
  );
  const contents: SubscriptionSeverityNotFoundFault = {
    name: "SubscriptionSeverityNotFoundFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryTableLimitExceededFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<TableLimitExceededFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryTableLimitExceededFault(
    body.Error,
    context
  );
  const contents: TableLimitExceededFault = {
    name: "TableLimitExceededFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryTableRestoreNotFoundFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<TableRestoreNotFoundFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryTableRestoreNotFoundFault(
    body.Error,
    context
  );
  const contents: TableRestoreNotFoundFault = {
    name: "TableRestoreNotFoundFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryTagLimitExceededFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<TagLimitExceededFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryTagLimitExceededFault(
    body.Error,
    context
  );
  const contents: TagLimitExceededFault = {
    name: "TagLimitExceededFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryUnauthorizedOperationResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<UnauthorizedOperation> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryUnauthorizedOperation(
    body.Error,
    context
  );
  const contents: UnauthorizedOperation = {
    name: "UnauthorizedOperation",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryUnknownSnapshotCopyRegionFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<UnknownSnapshotCopyRegionFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryUnknownSnapshotCopyRegionFault(
    body.Error,
    context
  );
  const contents: UnknownSnapshotCopyRegionFault = {
    name: "UnknownSnapshotCopyRegionFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryUnsupportedOperationFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<UnsupportedOperationFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryUnsupportedOperationFault(
    body.Error,
    context
  );
  const contents: UnsupportedOperationFault = {
    name: "UnsupportedOperationFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryUnsupportedOptionFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<UnsupportedOptionFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryUnsupportedOptionFault(
    body.Error,
    context
  );
  const contents: UnsupportedOptionFault = {
    name: "UnsupportedOptionFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const serializeAws_queryAcceptReservedNodeExchangeInputMessage = (
  input: AcceptReservedNodeExchangeInputMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.ReservedNodeId !== undefined) {
    entries["ReservedNodeId"] = input.ReservedNodeId;
  }
  if (input.TargetReservedNodeOfferingId !== undefined) {
    entries["TargetReservedNodeOfferingId"] =
      input.TargetReservedNodeOfferingId;
  }
  return entries;
};

const serializeAws_queryAttributeNameList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  (input || []).map(entry => {
    entries[`AttributeName.${counter}`] = entry;
    counter++;
  });
  return entries;
};

const serializeAws_queryAuthorizeClusterSecurityGroupIngressMessage = (
  input: AuthorizeClusterSecurityGroupIngressMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.CIDRIP !== undefined) {
    entries["CIDRIP"] = input.CIDRIP;
  }
  if (input.ClusterSecurityGroupName !== undefined) {
    entries["ClusterSecurityGroupName"] = input.ClusterSecurityGroupName;
  }
  if (input.EC2SecurityGroupName !== undefined) {
    entries["EC2SecurityGroupName"] = input.EC2SecurityGroupName;
  }
  if (input.EC2SecurityGroupOwnerId !== undefined) {
    entries["EC2SecurityGroupOwnerId"] = input.EC2SecurityGroupOwnerId;
  }
  return entries;
};

const serializeAws_queryAuthorizeSnapshotAccessMessage = (
  input: AuthorizeSnapshotAccessMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.AccountWithRestoreAccess !== undefined) {
    entries["AccountWithRestoreAccess"] = input.AccountWithRestoreAccess;
  }
  if (input.SnapshotClusterIdentifier !== undefined) {
    entries["SnapshotClusterIdentifier"] = input.SnapshotClusterIdentifier;
  }
  if (input.SnapshotIdentifier !== undefined) {
    entries["SnapshotIdentifier"] = input.SnapshotIdentifier;
  }
  return entries;
};

const serializeAws_queryBatchDeleteClusterSnapshotsRequest = (
  input: BatchDeleteClusterSnapshotsRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Identifiers !== undefined) {
    const memberEntries = serializeAws_queryDeleteClusterSnapshotMessageList(
      input.Identifiers,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `Identifiers.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  return entries;
};

const serializeAws_queryBatchModifyClusterSnapshotsMessage = (
  input: BatchModifyClusterSnapshotsMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Force !== undefined) {
    entries["Force"] = input.Force;
  }
  if (input.ManualSnapshotRetentionPeriod !== undefined) {
    entries["ManualSnapshotRetentionPeriod"] =
      input.ManualSnapshotRetentionPeriod;
  }
  if (input.SnapshotIdentifierList !== undefined) {
    const memberEntries = serializeAws_querySnapshotIdentifierList(
      input.SnapshotIdentifierList,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `SnapshotIdentifierList.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  return entries;
};

const serializeAws_queryCancelResizeMessage = (
  input: CancelResizeMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.ClusterIdentifier !== undefined) {
    entries["ClusterIdentifier"] = input.ClusterIdentifier;
  }
  return entries;
};

const serializeAws_queryClusterSecurityGroupNameList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  (input || []).map(entry => {
    entries[`ClusterSecurityGroupName.${counter}`] = entry;
    counter++;
  });
  return entries;
};

const serializeAws_queryCopyClusterSnapshotMessage = (
  input: CopyClusterSnapshotMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.ManualSnapshotRetentionPeriod !== undefined) {
    entries["ManualSnapshotRetentionPeriod"] =
      input.ManualSnapshotRetentionPeriod;
  }
  if (input.SourceSnapshotClusterIdentifier !== undefined) {
    entries["SourceSnapshotClusterIdentifier"] =
      input.SourceSnapshotClusterIdentifier;
  }
  if (input.SourceSnapshotIdentifier !== undefined) {
    entries["SourceSnapshotIdentifier"] = input.SourceSnapshotIdentifier;
  }
  if (input.TargetSnapshotIdentifier !== undefined) {
    entries["TargetSnapshotIdentifier"] = input.TargetSnapshotIdentifier;
  }
  return entries;
};

const serializeAws_queryCreateClusterMessage = (
  input: CreateClusterMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.AdditionalInfo !== undefined) {
    entries["AdditionalInfo"] = input.AdditionalInfo;
  }
  if (input.AllowVersionUpgrade !== undefined) {
    entries["AllowVersionUpgrade"] = input.AllowVersionUpgrade;
  }
  if (input.AutomatedSnapshotRetentionPeriod !== undefined) {
    entries["AutomatedSnapshotRetentionPeriod"] =
      input.AutomatedSnapshotRetentionPeriod;
  }
  if (input.AvailabilityZone !== undefined) {
    entries["AvailabilityZone"] = input.AvailabilityZone;
  }
  if (input.ClusterIdentifier !== undefined) {
    entries["ClusterIdentifier"] = input.ClusterIdentifier;
  }
  if (input.ClusterParameterGroupName !== undefined) {
    entries["ClusterParameterGroupName"] = input.ClusterParameterGroupName;
  }
  if (input.ClusterSecurityGroups !== undefined) {
    const memberEntries = serializeAws_queryClusterSecurityGroupNameList(
      input.ClusterSecurityGroups,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `ClusterSecurityGroups.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.ClusterSubnetGroupName !== undefined) {
    entries["ClusterSubnetGroupName"] = input.ClusterSubnetGroupName;
  }
  if (input.ClusterType !== undefined) {
    entries["ClusterType"] = input.ClusterType;
  }
  if (input.ClusterVersion !== undefined) {
    entries["ClusterVersion"] = input.ClusterVersion;
  }
  if (input.DBName !== undefined) {
    entries["DBName"] = input.DBName;
  }
  if (input.ElasticIp !== undefined) {
    entries["ElasticIp"] = input.ElasticIp;
  }
  if (input.Encrypted !== undefined) {
    entries["Encrypted"] = input.Encrypted;
  }
  if (input.EnhancedVpcRouting !== undefined) {
    entries["EnhancedVpcRouting"] = input.EnhancedVpcRouting;
  }
  if (input.HsmClientCertificateIdentifier !== undefined) {
    entries["HsmClientCertificateIdentifier"] =
      input.HsmClientCertificateIdentifier;
  }
  if (input.HsmConfigurationIdentifier !== undefined) {
    entries["HsmConfigurationIdentifier"] = input.HsmConfigurationIdentifier;
  }
  if (input.IamRoles !== undefined) {
    const memberEntries = serializeAws_queryIamRoleArnList(
      input.IamRoles,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `IamRoles.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.KmsKeyId !== undefined) {
    entries["KmsKeyId"] = input.KmsKeyId;
  }
  if (input.MaintenanceTrackName !== undefined) {
    entries["MaintenanceTrackName"] = input.MaintenanceTrackName;
  }
  if (input.ManualSnapshotRetentionPeriod !== undefined) {
    entries["ManualSnapshotRetentionPeriod"] =
      input.ManualSnapshotRetentionPeriod;
  }
  if (input.MasterUserPassword !== undefined) {
    entries["MasterUserPassword"] = input.MasterUserPassword;
  }
  if (input.MasterUsername !== undefined) {
    entries["MasterUsername"] = input.MasterUsername;
  }
  if (input.NodeType !== undefined) {
    entries["NodeType"] = input.NodeType;
  }
  if (input.NumberOfNodes !== undefined) {
    entries["NumberOfNodes"] = input.NumberOfNodes;
  }
  if (input.Port !== undefined) {
    entries["Port"] = input.Port;
  }
  if (input.PreferredMaintenanceWindow !== undefined) {
    entries["PreferredMaintenanceWindow"] = input.PreferredMaintenanceWindow;
  }
  if (input.PubliclyAccessible !== undefined) {
    entries["PubliclyAccessible"] = input.PubliclyAccessible;
  }
  if (input.SnapshotScheduleIdentifier !== undefined) {
    entries["SnapshotScheduleIdentifier"] = input.SnapshotScheduleIdentifier;
  }
  if (input.Tags !== undefined) {
    const memberEntries = serializeAws_queryTagList(input.Tags, context);
    Object.keys(memberEntries).forEach(key => {
      const loc = `Tags.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.VpcSecurityGroupIds !== undefined) {
    const memberEntries = serializeAws_queryVpcSecurityGroupIdList(
      input.VpcSecurityGroupIds,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `VpcSecurityGroupIds.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  return entries;
};

const serializeAws_queryCreateClusterParameterGroupMessage = (
  input: CreateClusterParameterGroupMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Description !== undefined) {
    entries["Description"] = input.Description;
  }
  if (input.ParameterGroupFamily !== undefined) {
    entries["ParameterGroupFamily"] = input.ParameterGroupFamily;
  }
  if (input.ParameterGroupName !== undefined) {
    entries["ParameterGroupName"] = input.ParameterGroupName;
  }
  if (input.Tags !== undefined) {
    const memberEntries = serializeAws_queryTagList(input.Tags, context);
    Object.keys(memberEntries).forEach(key => {
      const loc = `Tags.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  return entries;
};

const serializeAws_queryCreateClusterSecurityGroupMessage = (
  input: CreateClusterSecurityGroupMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.ClusterSecurityGroupName !== undefined) {
    entries["ClusterSecurityGroupName"] = input.ClusterSecurityGroupName;
  }
  if (input.Description !== undefined) {
    entries["Description"] = input.Description;
  }
  if (input.Tags !== undefined) {
    const memberEntries = serializeAws_queryTagList(input.Tags, context);
    Object.keys(memberEntries).forEach(key => {
      const loc = `Tags.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  return entries;
};

const serializeAws_queryCreateClusterSnapshotMessage = (
  input: CreateClusterSnapshotMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.ClusterIdentifier !== undefined) {
    entries["ClusterIdentifier"] = input.ClusterIdentifier;
  }
  if (input.ManualSnapshotRetentionPeriod !== undefined) {
    entries["ManualSnapshotRetentionPeriod"] =
      input.ManualSnapshotRetentionPeriod;
  }
  if (input.SnapshotIdentifier !== undefined) {
    entries["SnapshotIdentifier"] = input.SnapshotIdentifier;
  }
  if (input.Tags !== undefined) {
    const memberEntries = serializeAws_queryTagList(input.Tags, context);
    Object.keys(memberEntries).forEach(key => {
      const loc = `Tags.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  return entries;
};

const serializeAws_queryCreateClusterSubnetGroupMessage = (
  input: CreateClusterSubnetGroupMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.ClusterSubnetGroupName !== undefined) {
    entries["ClusterSubnetGroupName"] = input.ClusterSubnetGroupName;
  }
  if (input.Description !== undefined) {
    entries["Description"] = input.Description;
  }
  if (input.SubnetIds !== undefined) {
    const memberEntries = serializeAws_querySubnetIdentifierList(
      input.SubnetIds,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `SubnetIds.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.Tags !== undefined) {
    const memberEntries = serializeAws_queryTagList(input.Tags, context);
    Object.keys(memberEntries).forEach(key => {
      const loc = `Tags.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  return entries;
};

const serializeAws_queryCreateEventSubscriptionMessage = (
  input: CreateEventSubscriptionMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Enabled !== undefined) {
    entries["Enabled"] = input.Enabled;
  }
  if (input.EventCategories !== undefined) {
    const memberEntries = serializeAws_queryEventCategoriesList(
      input.EventCategories,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `EventCategories.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.Severity !== undefined) {
    entries["Severity"] = input.Severity;
  }
  if (input.SnsTopicArn !== undefined) {
    entries["SnsTopicArn"] = input.SnsTopicArn;
  }
  if (input.SourceIds !== undefined) {
    const memberEntries = serializeAws_querySourceIdsList(
      input.SourceIds,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `SourceIds.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.SourceType !== undefined) {
    entries["SourceType"] = input.SourceType;
  }
  if (input.SubscriptionName !== undefined) {
    entries["SubscriptionName"] = input.SubscriptionName;
  }
  if (input.Tags !== undefined) {
    const memberEntries = serializeAws_queryTagList(input.Tags, context);
    Object.keys(memberEntries).forEach(key => {
      const loc = `Tags.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  return entries;
};

const serializeAws_queryCreateHsmClientCertificateMessage = (
  input: CreateHsmClientCertificateMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.HsmClientCertificateIdentifier !== undefined) {
    entries["HsmClientCertificateIdentifier"] =
      input.HsmClientCertificateIdentifier;
  }
  if (input.Tags !== undefined) {
    const memberEntries = serializeAws_queryTagList(input.Tags, context);
    Object.keys(memberEntries).forEach(key => {
      const loc = `Tags.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  return entries;
};

const serializeAws_queryCreateHsmConfigurationMessage = (
  input: CreateHsmConfigurationMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Description !== undefined) {
    entries["Description"] = input.Description;
  }
  if (input.HsmConfigurationIdentifier !== undefined) {
    entries["HsmConfigurationIdentifier"] = input.HsmConfigurationIdentifier;
  }
  if (input.HsmIpAddress !== undefined) {
    entries["HsmIpAddress"] = input.HsmIpAddress;
  }
  if (input.HsmPartitionName !== undefined) {
    entries["HsmPartitionName"] = input.HsmPartitionName;
  }
  if (input.HsmPartitionPassword !== undefined) {
    entries["HsmPartitionPassword"] = input.HsmPartitionPassword;
  }
  if (input.HsmServerPublicCertificate !== undefined) {
    entries["HsmServerPublicCertificate"] = input.HsmServerPublicCertificate;
  }
  if (input.Tags !== undefined) {
    const memberEntries = serializeAws_queryTagList(input.Tags, context);
    Object.keys(memberEntries).forEach(key => {
      const loc = `Tags.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  return entries;
};

const serializeAws_queryCreateScheduledActionMessage = (
  input: CreateScheduledActionMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Enable !== undefined) {
    entries["Enable"] = input.Enable;
  }
  if (input.EndTime !== undefined) {
    entries["EndTime"] = input.EndTime.toISOString();
  }
  if (input.IamRole !== undefined) {
    entries["IamRole"] = input.IamRole;
  }
  if (input.Schedule !== undefined) {
    entries["Schedule"] = input.Schedule;
  }
  if (input.ScheduledActionDescription !== undefined) {
    entries["ScheduledActionDescription"] = input.ScheduledActionDescription;
  }
  if (input.ScheduledActionName !== undefined) {
    entries["ScheduledActionName"] = input.ScheduledActionName;
  }
  if (input.StartTime !== undefined) {
    entries["StartTime"] = input.StartTime.toISOString();
  }
  if (input.TargetAction !== undefined) {
    const memberEntries = serializeAws_queryScheduledActionType(
      input.TargetAction,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `TargetAction.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  return entries;
};

const serializeAws_queryCreateSnapshotCopyGrantMessage = (
  input: CreateSnapshotCopyGrantMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.KmsKeyId !== undefined) {
    entries["KmsKeyId"] = input.KmsKeyId;
  }
  if (input.SnapshotCopyGrantName !== undefined) {
    entries["SnapshotCopyGrantName"] = input.SnapshotCopyGrantName;
  }
  if (input.Tags !== undefined) {
    const memberEntries = serializeAws_queryTagList(input.Tags, context);
    Object.keys(memberEntries).forEach(key => {
      const loc = `Tags.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  return entries;
};

const serializeAws_queryCreateSnapshotScheduleMessage = (
  input: CreateSnapshotScheduleMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DryRun !== undefined) {
    entries["DryRun"] = input.DryRun;
  }
  if (input.NextInvocations !== undefined) {
    entries["NextInvocations"] = input.NextInvocations;
  }
  if (input.ScheduleDefinitions !== undefined) {
    const memberEntries = serializeAws_queryScheduleDefinitionList(
      input.ScheduleDefinitions,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `ScheduleDefinitions.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.ScheduleDescription !== undefined) {
    entries["ScheduleDescription"] = input.ScheduleDescription;
  }
  if (input.ScheduleIdentifier !== undefined) {
    entries["ScheduleIdentifier"] = input.ScheduleIdentifier;
  }
  if (input.Tags !== undefined) {
    const memberEntries = serializeAws_queryTagList(input.Tags, context);
    Object.keys(memberEntries).forEach(key => {
      const loc = `Tags.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  return entries;
};

const serializeAws_queryCreateTagsMessage = (
  input: CreateTagsMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.ResourceName !== undefined) {
    entries["ResourceName"] = input.ResourceName;
  }
  if (input.Tags !== undefined) {
    const memberEntries = serializeAws_queryTagList(input.Tags, context);
    Object.keys(memberEntries).forEach(key => {
      const loc = `Tags.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  return entries;
};

const serializeAws_queryDbGroupList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  (input || []).map(entry => {
    entries[`DbGroup.${counter}`] = entry;
    counter++;
  });
  return entries;
};

const serializeAws_queryDeleteClusterMessage = (
  input: DeleteClusterMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.ClusterIdentifier !== undefined) {
    entries["ClusterIdentifier"] = input.ClusterIdentifier;
  }
  if (input.FinalClusterSnapshotIdentifier !== undefined) {
    entries["FinalClusterSnapshotIdentifier"] =
      input.FinalClusterSnapshotIdentifier;
  }
  if (input.FinalClusterSnapshotRetentionPeriod !== undefined) {
    entries["FinalClusterSnapshotRetentionPeriod"] =
      input.FinalClusterSnapshotRetentionPeriod;
  }
  if (input.SkipFinalClusterSnapshot !== undefined) {
    entries["SkipFinalClusterSnapshot"] = input.SkipFinalClusterSnapshot;
  }
  return entries;
};

const serializeAws_queryDeleteClusterParameterGroupMessage = (
  input: DeleteClusterParameterGroupMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.ParameterGroupName !== undefined) {
    entries["ParameterGroupName"] = input.ParameterGroupName;
  }
  return entries;
};

const serializeAws_queryDeleteClusterSecurityGroupMessage = (
  input: DeleteClusterSecurityGroupMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.ClusterSecurityGroupName !== undefined) {
    entries["ClusterSecurityGroupName"] = input.ClusterSecurityGroupName;
  }
  return entries;
};

const serializeAws_queryDeleteClusterSnapshotMessage = (
  input: DeleteClusterSnapshotMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.SnapshotClusterIdentifier !== undefined) {
    entries["SnapshotClusterIdentifier"] = input.SnapshotClusterIdentifier;
  }
  if (input.SnapshotIdentifier !== undefined) {
    entries["SnapshotIdentifier"] = input.SnapshotIdentifier;
  }
  return entries;
};

const serializeAws_queryDeleteClusterSnapshotMessageList = (
  input: Array<DeleteClusterSnapshotMessage>,
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  (input || []).map(entry => {
    const memberEntries = serializeAws_queryDeleteClusterSnapshotMessage(
      entry,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      entries[`DeleteClusterSnapshotMessage.${counter}.${key}`] =
        memberEntries[key];
    });
    counter++;
  });
  return entries;
};

const serializeAws_queryDeleteClusterSubnetGroupMessage = (
  input: DeleteClusterSubnetGroupMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.ClusterSubnetGroupName !== undefined) {
    entries["ClusterSubnetGroupName"] = input.ClusterSubnetGroupName;
  }
  return entries;
};

const serializeAws_queryDeleteEventSubscriptionMessage = (
  input: DeleteEventSubscriptionMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.SubscriptionName !== undefined) {
    entries["SubscriptionName"] = input.SubscriptionName;
  }
  return entries;
};

const serializeAws_queryDeleteHsmClientCertificateMessage = (
  input: DeleteHsmClientCertificateMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.HsmClientCertificateIdentifier !== undefined) {
    entries["HsmClientCertificateIdentifier"] =
      input.HsmClientCertificateIdentifier;
  }
  return entries;
};

const serializeAws_queryDeleteHsmConfigurationMessage = (
  input: DeleteHsmConfigurationMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.HsmConfigurationIdentifier !== undefined) {
    entries["HsmConfigurationIdentifier"] = input.HsmConfigurationIdentifier;
  }
  return entries;
};

const serializeAws_queryDeleteScheduledActionMessage = (
  input: DeleteScheduledActionMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.ScheduledActionName !== undefined) {
    entries["ScheduledActionName"] = input.ScheduledActionName;
  }
  return entries;
};

const serializeAws_queryDeleteSnapshotCopyGrantMessage = (
  input: DeleteSnapshotCopyGrantMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.SnapshotCopyGrantName !== undefined) {
    entries["SnapshotCopyGrantName"] = input.SnapshotCopyGrantName;
  }
  return entries;
};

const serializeAws_queryDeleteSnapshotScheduleMessage = (
  input: DeleteSnapshotScheduleMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.ScheduleIdentifier !== undefined) {
    entries["ScheduleIdentifier"] = input.ScheduleIdentifier;
  }
  return entries;
};

const serializeAws_queryDeleteTagsMessage = (
  input: DeleteTagsMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.ResourceName !== undefined) {
    entries["ResourceName"] = input.ResourceName;
  }
  if (input.TagKeys !== undefined) {
    const memberEntries = serializeAws_queryTagKeyList(input.TagKeys, context);
    Object.keys(memberEntries).forEach(key => {
      const loc = `TagKeys.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  return entries;
};

const serializeAws_queryDescribeAccountAttributesMessage = (
  input: DescribeAccountAttributesMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.AttributeNames !== undefined) {
    const memberEntries = serializeAws_queryAttributeNameList(
      input.AttributeNames,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `AttributeNames.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  return entries;
};

const serializeAws_queryDescribeClusterDbRevisionsMessage = (
  input: DescribeClusterDbRevisionsMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.ClusterIdentifier !== undefined) {
    entries["ClusterIdentifier"] = input.ClusterIdentifier;
  }
  if (input.Marker !== undefined) {
    entries["Marker"] = input.Marker;
  }
  if (input.MaxRecords !== undefined) {
    entries["MaxRecords"] = input.MaxRecords;
  }
  return entries;
};

const serializeAws_queryDescribeClusterParameterGroupsMessage = (
  input: DescribeClusterParameterGroupsMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Marker !== undefined) {
    entries["Marker"] = input.Marker;
  }
  if (input.MaxRecords !== undefined) {
    entries["MaxRecords"] = input.MaxRecords;
  }
  if (input.ParameterGroupName !== undefined) {
    entries["ParameterGroupName"] = input.ParameterGroupName;
  }
  if (input.TagKeys !== undefined) {
    const memberEntries = serializeAws_queryTagKeyList(input.TagKeys, context);
    Object.keys(memberEntries).forEach(key => {
      const loc = `TagKeys.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.TagValues !== undefined) {
    const memberEntries = serializeAws_queryTagValueList(
      input.TagValues,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `TagValues.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  return entries;
};

const serializeAws_queryDescribeClusterParametersMessage = (
  input: DescribeClusterParametersMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Marker !== undefined) {
    entries["Marker"] = input.Marker;
  }
  if (input.MaxRecords !== undefined) {
    entries["MaxRecords"] = input.MaxRecords;
  }
  if (input.ParameterGroupName !== undefined) {
    entries["ParameterGroupName"] = input.ParameterGroupName;
  }
  if (input.Source !== undefined) {
    entries["Source"] = input.Source;
  }
  return entries;
};

const serializeAws_queryDescribeClusterSecurityGroupsMessage = (
  input: DescribeClusterSecurityGroupsMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.ClusterSecurityGroupName !== undefined) {
    entries["ClusterSecurityGroupName"] = input.ClusterSecurityGroupName;
  }
  if (input.Marker !== undefined) {
    entries["Marker"] = input.Marker;
  }
  if (input.MaxRecords !== undefined) {
    entries["MaxRecords"] = input.MaxRecords;
  }
  if (input.TagKeys !== undefined) {
    const memberEntries = serializeAws_queryTagKeyList(input.TagKeys, context);
    Object.keys(memberEntries).forEach(key => {
      const loc = `TagKeys.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.TagValues !== undefined) {
    const memberEntries = serializeAws_queryTagValueList(
      input.TagValues,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `TagValues.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  return entries;
};

const serializeAws_queryDescribeClusterSnapshotsMessage = (
  input: DescribeClusterSnapshotsMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.ClusterExists !== undefined) {
    entries["ClusterExists"] = input.ClusterExists;
  }
  if (input.ClusterIdentifier !== undefined) {
    entries["ClusterIdentifier"] = input.ClusterIdentifier;
  }
  if (input.EndTime !== undefined) {
    entries["EndTime"] = input.EndTime.toISOString();
  }
  if (input.Marker !== undefined) {
    entries["Marker"] = input.Marker;
  }
  if (input.MaxRecords !== undefined) {
    entries["MaxRecords"] = input.MaxRecords;
  }
  if (input.OwnerAccount !== undefined) {
    entries["OwnerAccount"] = input.OwnerAccount;
  }
  if (input.SnapshotIdentifier !== undefined) {
    entries["SnapshotIdentifier"] = input.SnapshotIdentifier;
  }
  if (input.SnapshotType !== undefined) {
    entries["SnapshotType"] = input.SnapshotType;
  }
  if (input.SortingEntities !== undefined) {
    const memberEntries = serializeAws_querySnapshotSortingEntityList(
      input.SortingEntities,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `SortingEntities.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.StartTime !== undefined) {
    entries["StartTime"] = input.StartTime.toISOString();
  }
  if (input.TagKeys !== undefined) {
    const memberEntries = serializeAws_queryTagKeyList(input.TagKeys, context);
    Object.keys(memberEntries).forEach(key => {
      const loc = `TagKeys.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.TagValues !== undefined) {
    const memberEntries = serializeAws_queryTagValueList(
      input.TagValues,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `TagValues.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  return entries;
};

const serializeAws_queryDescribeClusterSubnetGroupsMessage = (
  input: DescribeClusterSubnetGroupsMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.ClusterSubnetGroupName !== undefined) {
    entries["ClusterSubnetGroupName"] = input.ClusterSubnetGroupName;
  }
  if (input.Marker !== undefined) {
    entries["Marker"] = input.Marker;
  }
  if (input.MaxRecords !== undefined) {
    entries["MaxRecords"] = input.MaxRecords;
  }
  if (input.TagKeys !== undefined) {
    const memberEntries = serializeAws_queryTagKeyList(input.TagKeys, context);
    Object.keys(memberEntries).forEach(key => {
      const loc = `TagKeys.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.TagValues !== undefined) {
    const memberEntries = serializeAws_queryTagValueList(
      input.TagValues,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `TagValues.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  return entries;
};

const serializeAws_queryDescribeClusterTracksMessage = (
  input: DescribeClusterTracksMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.MaintenanceTrackName !== undefined) {
    entries["MaintenanceTrackName"] = input.MaintenanceTrackName;
  }
  if (input.Marker !== undefined) {
    entries["Marker"] = input.Marker;
  }
  if (input.MaxRecords !== undefined) {
    entries["MaxRecords"] = input.MaxRecords;
  }
  return entries;
};

const serializeAws_queryDescribeClusterVersionsMessage = (
  input: DescribeClusterVersionsMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.ClusterParameterGroupFamily !== undefined) {
    entries["ClusterParameterGroupFamily"] = input.ClusterParameterGroupFamily;
  }
  if (input.ClusterVersion !== undefined) {
    entries["ClusterVersion"] = input.ClusterVersion;
  }
  if (input.Marker !== undefined) {
    entries["Marker"] = input.Marker;
  }
  if (input.MaxRecords !== undefined) {
    entries["MaxRecords"] = input.MaxRecords;
  }
  return entries;
};

const serializeAws_queryDescribeClustersMessage = (
  input: DescribeClustersMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.ClusterIdentifier !== undefined) {
    entries["ClusterIdentifier"] = input.ClusterIdentifier;
  }
  if (input.Marker !== undefined) {
    entries["Marker"] = input.Marker;
  }
  if (input.MaxRecords !== undefined) {
    entries["MaxRecords"] = input.MaxRecords;
  }
  if (input.TagKeys !== undefined) {
    const memberEntries = serializeAws_queryTagKeyList(input.TagKeys, context);
    Object.keys(memberEntries).forEach(key => {
      const loc = `TagKeys.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.TagValues !== undefined) {
    const memberEntries = serializeAws_queryTagValueList(
      input.TagValues,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `TagValues.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  return entries;
};

const serializeAws_queryDescribeDefaultClusterParametersMessage = (
  input: DescribeDefaultClusterParametersMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Marker !== undefined) {
    entries["Marker"] = input.Marker;
  }
  if (input.MaxRecords !== undefined) {
    entries["MaxRecords"] = input.MaxRecords;
  }
  if (input.ParameterGroupFamily !== undefined) {
    entries["ParameterGroupFamily"] = input.ParameterGroupFamily;
  }
  return entries;
};

const serializeAws_queryDescribeEventCategoriesMessage = (
  input: DescribeEventCategoriesMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.SourceType !== undefined) {
    entries["SourceType"] = input.SourceType;
  }
  return entries;
};

const serializeAws_queryDescribeEventSubscriptionsMessage = (
  input: DescribeEventSubscriptionsMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Marker !== undefined) {
    entries["Marker"] = input.Marker;
  }
  if (input.MaxRecords !== undefined) {
    entries["MaxRecords"] = input.MaxRecords;
  }
  if (input.SubscriptionName !== undefined) {
    entries["SubscriptionName"] = input.SubscriptionName;
  }
  if (input.TagKeys !== undefined) {
    const memberEntries = serializeAws_queryTagKeyList(input.TagKeys, context);
    Object.keys(memberEntries).forEach(key => {
      const loc = `TagKeys.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.TagValues !== undefined) {
    const memberEntries = serializeAws_queryTagValueList(
      input.TagValues,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `TagValues.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  return entries;
};

const serializeAws_queryDescribeEventsMessage = (
  input: DescribeEventsMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Duration !== undefined) {
    entries["Duration"] = input.Duration;
  }
  if (input.EndTime !== undefined) {
    entries["EndTime"] = input.EndTime.toISOString();
  }
  if (input.Marker !== undefined) {
    entries["Marker"] = input.Marker;
  }
  if (input.MaxRecords !== undefined) {
    entries["MaxRecords"] = input.MaxRecords;
  }
  if (input.SourceIdentifier !== undefined) {
    entries["SourceIdentifier"] = input.SourceIdentifier;
  }
  if (input.SourceType !== undefined) {
    entries["SourceType"] = input.SourceType;
  }
  if (input.StartTime !== undefined) {
    entries["StartTime"] = input.StartTime.toISOString();
  }
  return entries;
};

const serializeAws_queryDescribeHsmClientCertificatesMessage = (
  input: DescribeHsmClientCertificatesMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.HsmClientCertificateIdentifier !== undefined) {
    entries["HsmClientCertificateIdentifier"] =
      input.HsmClientCertificateIdentifier;
  }
  if (input.Marker !== undefined) {
    entries["Marker"] = input.Marker;
  }
  if (input.MaxRecords !== undefined) {
    entries["MaxRecords"] = input.MaxRecords;
  }
  if (input.TagKeys !== undefined) {
    const memberEntries = serializeAws_queryTagKeyList(input.TagKeys, context);
    Object.keys(memberEntries).forEach(key => {
      const loc = `TagKeys.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.TagValues !== undefined) {
    const memberEntries = serializeAws_queryTagValueList(
      input.TagValues,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `TagValues.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  return entries;
};

const serializeAws_queryDescribeHsmConfigurationsMessage = (
  input: DescribeHsmConfigurationsMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.HsmConfigurationIdentifier !== undefined) {
    entries["HsmConfigurationIdentifier"] = input.HsmConfigurationIdentifier;
  }
  if (input.Marker !== undefined) {
    entries["Marker"] = input.Marker;
  }
  if (input.MaxRecords !== undefined) {
    entries["MaxRecords"] = input.MaxRecords;
  }
  if (input.TagKeys !== undefined) {
    const memberEntries = serializeAws_queryTagKeyList(input.TagKeys, context);
    Object.keys(memberEntries).forEach(key => {
      const loc = `TagKeys.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.TagValues !== undefined) {
    const memberEntries = serializeAws_queryTagValueList(
      input.TagValues,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `TagValues.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  return entries;
};

const serializeAws_queryDescribeLoggingStatusMessage = (
  input: DescribeLoggingStatusMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.ClusterIdentifier !== undefined) {
    entries["ClusterIdentifier"] = input.ClusterIdentifier;
  }
  return entries;
};

const serializeAws_queryDescribeNodeConfigurationOptionsMessage = (
  input: DescribeNodeConfigurationOptionsMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.ActionType !== undefined) {
    entries["ActionType"] = input.ActionType;
  }
  if (input.ClusterIdentifier !== undefined) {
    entries["ClusterIdentifier"] = input.ClusterIdentifier;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_queryNodeConfigurationOptionsFilterList(
      input.Filters,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `Filter.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.Marker !== undefined) {
    entries["Marker"] = input.Marker;
  }
  if (input.MaxRecords !== undefined) {
    entries["MaxRecords"] = input.MaxRecords;
  }
  if (input.OwnerAccount !== undefined) {
    entries["OwnerAccount"] = input.OwnerAccount;
  }
  if (input.SnapshotIdentifier !== undefined) {
    entries["SnapshotIdentifier"] = input.SnapshotIdentifier;
  }
  return entries;
};

const serializeAws_queryDescribeOrderableClusterOptionsMessage = (
  input: DescribeOrderableClusterOptionsMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.ClusterVersion !== undefined) {
    entries["ClusterVersion"] = input.ClusterVersion;
  }
  if (input.Marker !== undefined) {
    entries["Marker"] = input.Marker;
  }
  if (input.MaxRecords !== undefined) {
    entries["MaxRecords"] = input.MaxRecords;
  }
  if (input.NodeType !== undefined) {
    entries["NodeType"] = input.NodeType;
  }
  return entries;
};

const serializeAws_queryDescribeReservedNodeOfferingsMessage = (
  input: DescribeReservedNodeOfferingsMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Marker !== undefined) {
    entries["Marker"] = input.Marker;
  }
  if (input.MaxRecords !== undefined) {
    entries["MaxRecords"] = input.MaxRecords;
  }
  if (input.ReservedNodeOfferingId !== undefined) {
    entries["ReservedNodeOfferingId"] = input.ReservedNodeOfferingId;
  }
  return entries;
};

const serializeAws_queryDescribeReservedNodesMessage = (
  input: DescribeReservedNodesMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Marker !== undefined) {
    entries["Marker"] = input.Marker;
  }
  if (input.MaxRecords !== undefined) {
    entries["MaxRecords"] = input.MaxRecords;
  }
  if (input.ReservedNodeId !== undefined) {
    entries["ReservedNodeId"] = input.ReservedNodeId;
  }
  return entries;
};

const serializeAws_queryDescribeResizeMessage = (
  input: DescribeResizeMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.ClusterIdentifier !== undefined) {
    entries["ClusterIdentifier"] = input.ClusterIdentifier;
  }
  return entries;
};

const serializeAws_queryDescribeScheduledActionsMessage = (
  input: DescribeScheduledActionsMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Active !== undefined) {
    entries["Active"] = input.Active;
  }
  if (input.EndTime !== undefined) {
    entries["EndTime"] = input.EndTime.toISOString();
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_queryScheduledActionFilterList(
      input.Filters,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `Filters.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.Marker !== undefined) {
    entries["Marker"] = input.Marker;
  }
  if (input.MaxRecords !== undefined) {
    entries["MaxRecords"] = input.MaxRecords;
  }
  if (input.ScheduledActionName !== undefined) {
    entries["ScheduledActionName"] = input.ScheduledActionName;
  }
  if (input.StartTime !== undefined) {
    entries["StartTime"] = input.StartTime.toISOString();
  }
  if (input.TargetActionType !== undefined) {
    entries["TargetActionType"] = input.TargetActionType;
  }
  return entries;
};

const serializeAws_queryDescribeSnapshotCopyGrantsMessage = (
  input: DescribeSnapshotCopyGrantsMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Marker !== undefined) {
    entries["Marker"] = input.Marker;
  }
  if (input.MaxRecords !== undefined) {
    entries["MaxRecords"] = input.MaxRecords;
  }
  if (input.SnapshotCopyGrantName !== undefined) {
    entries["SnapshotCopyGrantName"] = input.SnapshotCopyGrantName;
  }
  if (input.TagKeys !== undefined) {
    const memberEntries = serializeAws_queryTagKeyList(input.TagKeys, context);
    Object.keys(memberEntries).forEach(key => {
      const loc = `TagKeys.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.TagValues !== undefined) {
    const memberEntries = serializeAws_queryTagValueList(
      input.TagValues,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `TagValues.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  return entries;
};

const serializeAws_queryDescribeSnapshotSchedulesMessage = (
  input: DescribeSnapshotSchedulesMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.ClusterIdentifier !== undefined) {
    entries["ClusterIdentifier"] = input.ClusterIdentifier;
  }
  if (input.Marker !== undefined) {
    entries["Marker"] = input.Marker;
  }
  if (input.MaxRecords !== undefined) {
    entries["MaxRecords"] = input.MaxRecords;
  }
  if (input.ScheduleIdentifier !== undefined) {
    entries["ScheduleIdentifier"] = input.ScheduleIdentifier;
  }
  if (input.TagKeys !== undefined) {
    const memberEntries = serializeAws_queryTagKeyList(input.TagKeys, context);
    Object.keys(memberEntries).forEach(key => {
      const loc = `TagKeys.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.TagValues !== undefined) {
    const memberEntries = serializeAws_queryTagValueList(
      input.TagValues,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `TagValues.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  return entries;
};

const serializeAws_queryDescribeTableRestoreStatusMessage = (
  input: DescribeTableRestoreStatusMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.ClusterIdentifier !== undefined) {
    entries["ClusterIdentifier"] = input.ClusterIdentifier;
  }
  if (input.Marker !== undefined) {
    entries["Marker"] = input.Marker;
  }
  if (input.MaxRecords !== undefined) {
    entries["MaxRecords"] = input.MaxRecords;
  }
  if (input.TableRestoreRequestId !== undefined) {
    entries["TableRestoreRequestId"] = input.TableRestoreRequestId;
  }
  return entries;
};

const serializeAws_queryDescribeTagsMessage = (
  input: DescribeTagsMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Marker !== undefined) {
    entries["Marker"] = input.Marker;
  }
  if (input.MaxRecords !== undefined) {
    entries["MaxRecords"] = input.MaxRecords;
  }
  if (input.ResourceName !== undefined) {
    entries["ResourceName"] = input.ResourceName;
  }
  if (input.ResourceType !== undefined) {
    entries["ResourceType"] = input.ResourceType;
  }
  if (input.TagKeys !== undefined) {
    const memberEntries = serializeAws_queryTagKeyList(input.TagKeys, context);
    Object.keys(memberEntries).forEach(key => {
      const loc = `TagKeys.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.TagValues !== undefined) {
    const memberEntries = serializeAws_queryTagValueList(
      input.TagValues,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `TagValues.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  return entries;
};

const serializeAws_queryDisableLoggingMessage = (
  input: DisableLoggingMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.ClusterIdentifier !== undefined) {
    entries["ClusterIdentifier"] = input.ClusterIdentifier;
  }
  return entries;
};

const serializeAws_queryDisableSnapshotCopyMessage = (
  input: DisableSnapshotCopyMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.ClusterIdentifier !== undefined) {
    entries["ClusterIdentifier"] = input.ClusterIdentifier;
  }
  return entries;
};

const serializeAws_queryEnableLoggingMessage = (
  input: EnableLoggingMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.BucketName !== undefined) {
    entries["BucketName"] = input.BucketName;
  }
  if (input.ClusterIdentifier !== undefined) {
    entries["ClusterIdentifier"] = input.ClusterIdentifier;
  }
  if (input.S3KeyPrefix !== undefined) {
    entries["S3KeyPrefix"] = input.S3KeyPrefix;
  }
  return entries;
};

const serializeAws_queryEnableSnapshotCopyMessage = (
  input: EnableSnapshotCopyMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.ClusterIdentifier !== undefined) {
    entries["ClusterIdentifier"] = input.ClusterIdentifier;
  }
  if (input.DestinationRegion !== undefined) {
    entries["DestinationRegion"] = input.DestinationRegion;
  }
  if (input.ManualSnapshotRetentionPeriod !== undefined) {
    entries["ManualSnapshotRetentionPeriod"] =
      input.ManualSnapshotRetentionPeriod;
  }
  if (input.RetentionPeriod !== undefined) {
    entries["RetentionPeriod"] = input.RetentionPeriod;
  }
  if (input.SnapshotCopyGrantName !== undefined) {
    entries["SnapshotCopyGrantName"] = input.SnapshotCopyGrantName;
  }
  return entries;
};

const serializeAws_queryEventCategoriesList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  (input || []).map(entry => {
    entries[`EventCategory.${counter}`] = entry;
    counter++;
  });
  return entries;
};

const serializeAws_queryGetClusterCredentialsMessage = (
  input: GetClusterCredentialsMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.AutoCreate !== undefined) {
    entries["AutoCreate"] = input.AutoCreate;
  }
  if (input.ClusterIdentifier !== undefined) {
    entries["ClusterIdentifier"] = input.ClusterIdentifier;
  }
  if (input.DbGroups !== undefined) {
    const memberEntries = serializeAws_queryDbGroupList(
      input.DbGroups,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `DbGroups.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.DbName !== undefined) {
    entries["DbName"] = input.DbName;
  }
  if (input.DbUser !== undefined) {
    entries["DbUser"] = input.DbUser;
  }
  if (input.DurationSeconds !== undefined) {
    entries["DurationSeconds"] = input.DurationSeconds;
  }
  return entries;
};

const serializeAws_queryGetReservedNodeExchangeOfferingsInputMessage = (
  input: GetReservedNodeExchangeOfferingsInputMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Marker !== undefined) {
    entries["Marker"] = input.Marker;
  }
  if (input.MaxRecords !== undefined) {
    entries["MaxRecords"] = input.MaxRecords;
  }
  if (input.ReservedNodeId !== undefined) {
    entries["ReservedNodeId"] = input.ReservedNodeId;
  }
  return entries;
};

const serializeAws_queryIamRoleArnList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  (input || []).map(entry => {
    entries[`IamRoleArn.${counter}`] = entry;
    counter++;
  });
  return entries;
};

const serializeAws_queryModifyClusterDbRevisionMessage = (
  input: ModifyClusterDbRevisionMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.ClusterIdentifier !== undefined) {
    entries["ClusterIdentifier"] = input.ClusterIdentifier;
  }
  if (input.RevisionTarget !== undefined) {
    entries["RevisionTarget"] = input.RevisionTarget;
  }
  return entries;
};

const serializeAws_queryModifyClusterIamRolesMessage = (
  input: ModifyClusterIamRolesMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.AddIamRoles !== undefined) {
    const memberEntries = serializeAws_queryIamRoleArnList(
      input.AddIamRoles,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `AddIamRoles.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.ClusterIdentifier !== undefined) {
    entries["ClusterIdentifier"] = input.ClusterIdentifier;
  }
  if (input.RemoveIamRoles !== undefined) {
    const memberEntries = serializeAws_queryIamRoleArnList(
      input.RemoveIamRoles,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `RemoveIamRoles.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  return entries;
};

const serializeAws_queryModifyClusterMaintenanceMessage = (
  input: ModifyClusterMaintenanceMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.ClusterIdentifier !== undefined) {
    entries["ClusterIdentifier"] = input.ClusterIdentifier;
  }
  if (input.DeferMaintenance !== undefined) {
    entries["DeferMaintenance"] = input.DeferMaintenance;
  }
  if (input.DeferMaintenanceDuration !== undefined) {
    entries["DeferMaintenanceDuration"] = input.DeferMaintenanceDuration;
  }
  if (input.DeferMaintenanceEndTime !== undefined) {
    entries[
      "DeferMaintenanceEndTime"
    ] = input.DeferMaintenanceEndTime.toISOString();
  }
  if (input.DeferMaintenanceIdentifier !== undefined) {
    entries["DeferMaintenanceIdentifier"] = input.DeferMaintenanceIdentifier;
  }
  if (input.DeferMaintenanceStartTime !== undefined) {
    entries[
      "DeferMaintenanceStartTime"
    ] = input.DeferMaintenanceStartTime.toISOString();
  }
  return entries;
};

const serializeAws_queryModifyClusterMessage = (
  input: ModifyClusterMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.AllowVersionUpgrade !== undefined) {
    entries["AllowVersionUpgrade"] = input.AllowVersionUpgrade;
  }
  if (input.AutomatedSnapshotRetentionPeriod !== undefined) {
    entries["AutomatedSnapshotRetentionPeriod"] =
      input.AutomatedSnapshotRetentionPeriod;
  }
  if (input.ClusterIdentifier !== undefined) {
    entries["ClusterIdentifier"] = input.ClusterIdentifier;
  }
  if (input.ClusterParameterGroupName !== undefined) {
    entries["ClusterParameterGroupName"] = input.ClusterParameterGroupName;
  }
  if (input.ClusterSecurityGroups !== undefined) {
    const memberEntries = serializeAws_queryClusterSecurityGroupNameList(
      input.ClusterSecurityGroups,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `ClusterSecurityGroups.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.ClusterType !== undefined) {
    entries["ClusterType"] = input.ClusterType;
  }
  if (input.ClusterVersion !== undefined) {
    entries["ClusterVersion"] = input.ClusterVersion;
  }
  if (input.ElasticIp !== undefined) {
    entries["ElasticIp"] = input.ElasticIp;
  }
  if (input.Encrypted !== undefined) {
    entries["Encrypted"] = input.Encrypted;
  }
  if (input.EnhancedVpcRouting !== undefined) {
    entries["EnhancedVpcRouting"] = input.EnhancedVpcRouting;
  }
  if (input.HsmClientCertificateIdentifier !== undefined) {
    entries["HsmClientCertificateIdentifier"] =
      input.HsmClientCertificateIdentifier;
  }
  if (input.HsmConfigurationIdentifier !== undefined) {
    entries["HsmConfigurationIdentifier"] = input.HsmConfigurationIdentifier;
  }
  if (input.KmsKeyId !== undefined) {
    entries["KmsKeyId"] = input.KmsKeyId;
  }
  if (input.MaintenanceTrackName !== undefined) {
    entries["MaintenanceTrackName"] = input.MaintenanceTrackName;
  }
  if (input.ManualSnapshotRetentionPeriod !== undefined) {
    entries["ManualSnapshotRetentionPeriod"] =
      input.ManualSnapshotRetentionPeriod;
  }
  if (input.MasterUserPassword !== undefined) {
    entries["MasterUserPassword"] = input.MasterUserPassword;
  }
  if (input.NewClusterIdentifier !== undefined) {
    entries["NewClusterIdentifier"] = input.NewClusterIdentifier;
  }
  if (input.NodeType !== undefined) {
    entries["NodeType"] = input.NodeType;
  }
  if (input.NumberOfNodes !== undefined) {
    entries["NumberOfNodes"] = input.NumberOfNodes;
  }
  if (input.PreferredMaintenanceWindow !== undefined) {
    entries["PreferredMaintenanceWindow"] = input.PreferredMaintenanceWindow;
  }
  if (input.PubliclyAccessible !== undefined) {
    entries["PubliclyAccessible"] = input.PubliclyAccessible;
  }
  if (input.VpcSecurityGroupIds !== undefined) {
    const memberEntries = serializeAws_queryVpcSecurityGroupIdList(
      input.VpcSecurityGroupIds,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `VpcSecurityGroupIds.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  return entries;
};

const serializeAws_queryModifyClusterParameterGroupMessage = (
  input: ModifyClusterParameterGroupMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.ParameterGroupName !== undefined) {
    entries["ParameterGroupName"] = input.ParameterGroupName;
  }
  if (input.Parameters !== undefined) {
    const memberEntries = serializeAws_queryParametersList(
      input.Parameters,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `Parameters.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  return entries;
};

const serializeAws_queryModifyClusterSnapshotMessage = (
  input: ModifyClusterSnapshotMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Force !== undefined) {
    entries["Force"] = input.Force;
  }
  if (input.ManualSnapshotRetentionPeriod !== undefined) {
    entries["ManualSnapshotRetentionPeriod"] =
      input.ManualSnapshotRetentionPeriod;
  }
  if (input.SnapshotIdentifier !== undefined) {
    entries["SnapshotIdentifier"] = input.SnapshotIdentifier;
  }
  return entries;
};

const serializeAws_queryModifyClusterSnapshotScheduleMessage = (
  input: ModifyClusterSnapshotScheduleMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.ClusterIdentifier !== undefined) {
    entries["ClusterIdentifier"] = input.ClusterIdentifier;
  }
  if (input.DisassociateSchedule !== undefined) {
    entries["DisassociateSchedule"] = input.DisassociateSchedule;
  }
  if (input.ScheduleIdentifier !== undefined) {
    entries["ScheduleIdentifier"] = input.ScheduleIdentifier;
  }
  return entries;
};

const serializeAws_queryModifyClusterSubnetGroupMessage = (
  input: ModifyClusterSubnetGroupMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.ClusterSubnetGroupName !== undefined) {
    entries["ClusterSubnetGroupName"] = input.ClusterSubnetGroupName;
  }
  if (input.Description !== undefined) {
    entries["Description"] = input.Description;
  }
  if (input.SubnetIds !== undefined) {
    const memberEntries = serializeAws_querySubnetIdentifierList(
      input.SubnetIds,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `SubnetIds.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  return entries;
};

const serializeAws_queryModifyEventSubscriptionMessage = (
  input: ModifyEventSubscriptionMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Enabled !== undefined) {
    entries["Enabled"] = input.Enabled;
  }
  if (input.EventCategories !== undefined) {
    const memberEntries = serializeAws_queryEventCategoriesList(
      input.EventCategories,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `EventCategories.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.Severity !== undefined) {
    entries["Severity"] = input.Severity;
  }
  if (input.SnsTopicArn !== undefined) {
    entries["SnsTopicArn"] = input.SnsTopicArn;
  }
  if (input.SourceIds !== undefined) {
    const memberEntries = serializeAws_querySourceIdsList(
      input.SourceIds,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `SourceIds.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.SourceType !== undefined) {
    entries["SourceType"] = input.SourceType;
  }
  if (input.SubscriptionName !== undefined) {
    entries["SubscriptionName"] = input.SubscriptionName;
  }
  return entries;
};

const serializeAws_queryModifyScheduledActionMessage = (
  input: ModifyScheduledActionMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Enable !== undefined) {
    entries["Enable"] = input.Enable;
  }
  if (input.EndTime !== undefined) {
    entries["EndTime"] = input.EndTime.toISOString();
  }
  if (input.IamRole !== undefined) {
    entries["IamRole"] = input.IamRole;
  }
  if (input.Schedule !== undefined) {
    entries["Schedule"] = input.Schedule;
  }
  if (input.ScheduledActionDescription !== undefined) {
    entries["ScheduledActionDescription"] = input.ScheduledActionDescription;
  }
  if (input.ScheduledActionName !== undefined) {
    entries["ScheduledActionName"] = input.ScheduledActionName;
  }
  if (input.StartTime !== undefined) {
    entries["StartTime"] = input.StartTime.toISOString();
  }
  if (input.TargetAction !== undefined) {
    const memberEntries = serializeAws_queryScheduledActionType(
      input.TargetAction,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `TargetAction.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  return entries;
};

const serializeAws_queryModifySnapshotCopyRetentionPeriodMessage = (
  input: ModifySnapshotCopyRetentionPeriodMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.ClusterIdentifier !== undefined) {
    entries["ClusterIdentifier"] = input.ClusterIdentifier;
  }
  if (input.Manual !== undefined) {
    entries["Manual"] = input.Manual;
  }
  if (input.RetentionPeriod !== undefined) {
    entries["RetentionPeriod"] = input.RetentionPeriod;
  }
  return entries;
};

const serializeAws_queryModifySnapshotScheduleMessage = (
  input: ModifySnapshotScheduleMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.ScheduleDefinitions !== undefined) {
    const memberEntries = serializeAws_queryScheduleDefinitionList(
      input.ScheduleDefinitions,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `ScheduleDefinitions.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.ScheduleIdentifier !== undefined) {
    entries["ScheduleIdentifier"] = input.ScheduleIdentifier;
  }
  return entries;
};

const serializeAws_queryNodeConfigurationOptionsFilter = (
  input: NodeConfigurationOptionsFilter,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Name !== undefined) {
    entries["Name"] = input.Name;
  }
  if (input.Operator !== undefined) {
    entries["Operator"] = input.Operator;
  }
  if (input.Values !== undefined) {
    const memberEntries = serializeAws_queryValueStringList(
      input.Values,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `Value.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  return entries;
};

const serializeAws_queryNodeConfigurationOptionsFilterList = (
  input: Array<NodeConfigurationOptionsFilter>,
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  (input || []).map(entry => {
    const memberEntries = serializeAws_queryNodeConfigurationOptionsFilter(
      entry,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      entries[`NodeConfigurationOptionsFilter.${counter}.${key}`] =
        memberEntries[key];
    });
    counter++;
  });
  return entries;
};

const serializeAws_queryParameter = (
  input: Parameter,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.AllowedValues !== undefined) {
    entries["AllowedValues"] = input.AllowedValues;
  }
  if (input.ApplyType !== undefined) {
    entries["ApplyType"] = input.ApplyType;
  }
  if (input.DataType !== undefined) {
    entries["DataType"] = input.DataType;
  }
  if (input.Description !== undefined) {
    entries["Description"] = input.Description;
  }
  if (input.IsModifiable !== undefined) {
    entries["IsModifiable"] = input.IsModifiable;
  }
  if (input.MinimumEngineVersion !== undefined) {
    entries["MinimumEngineVersion"] = input.MinimumEngineVersion;
  }
  if (input.ParameterName !== undefined) {
    entries["ParameterName"] = input.ParameterName;
  }
  if (input.ParameterValue !== undefined) {
    entries["ParameterValue"] = input.ParameterValue;
  }
  if (input.Source !== undefined) {
    entries["Source"] = input.Source;
  }
  return entries;
};

const serializeAws_queryParametersList = (
  input: Array<Parameter>,
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  (input || []).map(entry => {
    const memberEntries = serializeAws_queryParameter(entry, context);
    Object.keys(memberEntries).forEach(key => {
      entries[`Parameter.${counter}.${key}`] = memberEntries[key];
    });
    counter++;
  });
  return entries;
};

const serializeAws_queryPurchaseReservedNodeOfferingMessage = (
  input: PurchaseReservedNodeOfferingMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.NodeCount !== undefined) {
    entries["NodeCount"] = input.NodeCount;
  }
  if (input.ReservedNodeOfferingId !== undefined) {
    entries["ReservedNodeOfferingId"] = input.ReservedNodeOfferingId;
  }
  return entries;
};

const serializeAws_queryRebootClusterMessage = (
  input: RebootClusterMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.ClusterIdentifier !== undefined) {
    entries["ClusterIdentifier"] = input.ClusterIdentifier;
  }
  return entries;
};

const serializeAws_queryResetClusterParameterGroupMessage = (
  input: ResetClusterParameterGroupMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.ParameterGroupName !== undefined) {
    entries["ParameterGroupName"] = input.ParameterGroupName;
  }
  if (input.Parameters !== undefined) {
    const memberEntries = serializeAws_queryParametersList(
      input.Parameters,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `Parameters.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.ResetAllParameters !== undefined) {
    entries["ResetAllParameters"] = input.ResetAllParameters;
  }
  return entries;
};

const serializeAws_queryResizeClusterMessage = (
  input: ResizeClusterMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Classic !== undefined) {
    entries["Classic"] = input.Classic;
  }
  if (input.ClusterIdentifier !== undefined) {
    entries["ClusterIdentifier"] = input.ClusterIdentifier;
  }
  if (input.ClusterType !== undefined) {
    entries["ClusterType"] = input.ClusterType;
  }
  if (input.NodeType !== undefined) {
    entries["NodeType"] = input.NodeType;
  }
  if (input.NumberOfNodes !== undefined) {
    entries["NumberOfNodes"] = input.NumberOfNodes;
  }
  return entries;
};

const serializeAws_queryRestoreFromClusterSnapshotMessage = (
  input: RestoreFromClusterSnapshotMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.AdditionalInfo !== undefined) {
    entries["AdditionalInfo"] = input.AdditionalInfo;
  }
  if (input.AllowVersionUpgrade !== undefined) {
    entries["AllowVersionUpgrade"] = input.AllowVersionUpgrade;
  }
  if (input.AutomatedSnapshotRetentionPeriod !== undefined) {
    entries["AutomatedSnapshotRetentionPeriod"] =
      input.AutomatedSnapshotRetentionPeriod;
  }
  if (input.AvailabilityZone !== undefined) {
    entries["AvailabilityZone"] = input.AvailabilityZone;
  }
  if (input.ClusterIdentifier !== undefined) {
    entries["ClusterIdentifier"] = input.ClusterIdentifier;
  }
  if (input.ClusterParameterGroupName !== undefined) {
    entries["ClusterParameterGroupName"] = input.ClusterParameterGroupName;
  }
  if (input.ClusterSecurityGroups !== undefined) {
    const memberEntries = serializeAws_queryClusterSecurityGroupNameList(
      input.ClusterSecurityGroups,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `ClusterSecurityGroups.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.ClusterSubnetGroupName !== undefined) {
    entries["ClusterSubnetGroupName"] = input.ClusterSubnetGroupName;
  }
  if (input.ElasticIp !== undefined) {
    entries["ElasticIp"] = input.ElasticIp;
  }
  if (input.EnhancedVpcRouting !== undefined) {
    entries["EnhancedVpcRouting"] = input.EnhancedVpcRouting;
  }
  if (input.HsmClientCertificateIdentifier !== undefined) {
    entries["HsmClientCertificateIdentifier"] =
      input.HsmClientCertificateIdentifier;
  }
  if (input.HsmConfigurationIdentifier !== undefined) {
    entries["HsmConfigurationIdentifier"] = input.HsmConfigurationIdentifier;
  }
  if (input.IamRoles !== undefined) {
    const memberEntries = serializeAws_queryIamRoleArnList(
      input.IamRoles,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `IamRoles.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.KmsKeyId !== undefined) {
    entries["KmsKeyId"] = input.KmsKeyId;
  }
  if (input.MaintenanceTrackName !== undefined) {
    entries["MaintenanceTrackName"] = input.MaintenanceTrackName;
  }
  if (input.ManualSnapshotRetentionPeriod !== undefined) {
    entries["ManualSnapshotRetentionPeriod"] =
      input.ManualSnapshotRetentionPeriod;
  }
  if (input.NodeType !== undefined) {
    entries["NodeType"] = input.NodeType;
  }
  if (input.NumberOfNodes !== undefined) {
    entries["NumberOfNodes"] = input.NumberOfNodes;
  }
  if (input.OwnerAccount !== undefined) {
    entries["OwnerAccount"] = input.OwnerAccount;
  }
  if (input.Port !== undefined) {
    entries["Port"] = input.Port;
  }
  if (input.PreferredMaintenanceWindow !== undefined) {
    entries["PreferredMaintenanceWindow"] = input.PreferredMaintenanceWindow;
  }
  if (input.PubliclyAccessible !== undefined) {
    entries["PubliclyAccessible"] = input.PubliclyAccessible;
  }
  if (input.SnapshotClusterIdentifier !== undefined) {
    entries["SnapshotClusterIdentifier"] = input.SnapshotClusterIdentifier;
  }
  if (input.SnapshotIdentifier !== undefined) {
    entries["SnapshotIdentifier"] = input.SnapshotIdentifier;
  }
  if (input.SnapshotScheduleIdentifier !== undefined) {
    entries["SnapshotScheduleIdentifier"] = input.SnapshotScheduleIdentifier;
  }
  if (input.VpcSecurityGroupIds !== undefined) {
    const memberEntries = serializeAws_queryVpcSecurityGroupIdList(
      input.VpcSecurityGroupIds,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `VpcSecurityGroupIds.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  return entries;
};

const serializeAws_queryRestoreTableFromClusterSnapshotMessage = (
  input: RestoreTableFromClusterSnapshotMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.ClusterIdentifier !== undefined) {
    entries["ClusterIdentifier"] = input.ClusterIdentifier;
  }
  if (input.NewTableName !== undefined) {
    entries["NewTableName"] = input.NewTableName;
  }
  if (input.SnapshotIdentifier !== undefined) {
    entries["SnapshotIdentifier"] = input.SnapshotIdentifier;
  }
  if (input.SourceDatabaseName !== undefined) {
    entries["SourceDatabaseName"] = input.SourceDatabaseName;
  }
  if (input.SourceSchemaName !== undefined) {
    entries["SourceSchemaName"] = input.SourceSchemaName;
  }
  if (input.SourceTableName !== undefined) {
    entries["SourceTableName"] = input.SourceTableName;
  }
  if (input.TargetDatabaseName !== undefined) {
    entries["TargetDatabaseName"] = input.TargetDatabaseName;
  }
  if (input.TargetSchemaName !== undefined) {
    entries["TargetSchemaName"] = input.TargetSchemaName;
  }
  return entries;
};

const serializeAws_queryRevokeClusterSecurityGroupIngressMessage = (
  input: RevokeClusterSecurityGroupIngressMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.CIDRIP !== undefined) {
    entries["CIDRIP"] = input.CIDRIP;
  }
  if (input.ClusterSecurityGroupName !== undefined) {
    entries["ClusterSecurityGroupName"] = input.ClusterSecurityGroupName;
  }
  if (input.EC2SecurityGroupName !== undefined) {
    entries["EC2SecurityGroupName"] = input.EC2SecurityGroupName;
  }
  if (input.EC2SecurityGroupOwnerId !== undefined) {
    entries["EC2SecurityGroupOwnerId"] = input.EC2SecurityGroupOwnerId;
  }
  return entries;
};

const serializeAws_queryRevokeSnapshotAccessMessage = (
  input: RevokeSnapshotAccessMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.AccountWithRestoreAccess !== undefined) {
    entries["AccountWithRestoreAccess"] = input.AccountWithRestoreAccess;
  }
  if (input.SnapshotClusterIdentifier !== undefined) {
    entries["SnapshotClusterIdentifier"] = input.SnapshotClusterIdentifier;
  }
  if (input.SnapshotIdentifier !== undefined) {
    entries["SnapshotIdentifier"] = input.SnapshotIdentifier;
  }
  return entries;
};

const serializeAws_queryRotateEncryptionKeyMessage = (
  input: RotateEncryptionKeyMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.ClusterIdentifier !== undefined) {
    entries["ClusterIdentifier"] = input.ClusterIdentifier;
  }
  return entries;
};

const serializeAws_queryScheduleDefinitionList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  (input || []).map(entry => {
    entries[`ScheduleDefinition.${counter}`] = entry;
    counter++;
  });
  return entries;
};

const serializeAws_queryScheduledActionFilter = (
  input: ScheduledActionFilter,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Name !== undefined) {
    entries["Name"] = input.Name;
  }
  if (input.Values !== undefined) {
    const memberEntries = serializeAws_queryValueStringList(
      input.Values,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `Values.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  return entries;
};

const serializeAws_queryScheduledActionFilterList = (
  input: Array<ScheduledActionFilter>,
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  (input || []).map(entry => {
    const memberEntries = serializeAws_queryScheduledActionFilter(
      entry,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      entries[`ScheduledActionFilter.${counter}.${key}`] = memberEntries[key];
    });
    counter++;
  });
  return entries;
};

const serializeAws_queryScheduledActionType = (
  input: ScheduledActionType,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.ResizeCluster !== undefined) {
    const memberEntries = serializeAws_queryResizeClusterMessage(
      input.ResizeCluster,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `ResizeCluster.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  return entries;
};

const serializeAws_querySnapshotIdentifierList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  (input || []).map(entry => {
    entries[`String.${counter}`] = entry;
    counter++;
  });
  return entries;
};

const serializeAws_querySnapshotSortingEntity = (
  input: SnapshotSortingEntity,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Attribute !== undefined) {
    entries["Attribute"] = input.Attribute;
  }
  if (input.SortOrder !== undefined) {
    entries["SortOrder"] = input.SortOrder;
  }
  return entries;
};

const serializeAws_querySnapshotSortingEntityList = (
  input: Array<SnapshotSortingEntity>,
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  (input || []).map(entry => {
    const memberEntries = serializeAws_querySnapshotSortingEntity(
      entry,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      entries[`SnapshotSortingEntity.${counter}.${key}`] = memberEntries[key];
    });
    counter++;
  });
  return entries;
};

const serializeAws_querySourceIdsList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  (input || []).map(entry => {
    entries[`SourceId.${counter}`] = entry;
    counter++;
  });
  return entries;
};

const serializeAws_querySubnetIdentifierList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  (input || []).map(entry => {
    entries[`SubnetIdentifier.${counter}`] = entry;
    counter++;
  });
  return entries;
};

const serializeAws_queryTag = (input: Tag, context: __SerdeContext): any => {
  const entries: any = {};
  if (input.Key !== undefined) {
    entries["Key"] = input.Key;
  }
  if (input.Value !== undefined) {
    entries["Value"] = input.Value;
  }
  return entries;
};

const serializeAws_queryTagKeyList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  (input || []).map(entry => {
    entries[`TagKey.${counter}`] = entry;
    counter++;
  });
  return entries;
};

const serializeAws_queryTagList = (
  input: Array<Tag>,
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  (input || []).map(entry => {
    const memberEntries = serializeAws_queryTag(entry, context);
    Object.keys(memberEntries).forEach(key => {
      entries[`Tag.${counter}.${key}`] = memberEntries[key];
    });
    counter++;
  });
  return entries;
};

const serializeAws_queryTagValueList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  (input || []).map(entry => {
    entries[`TagValue.${counter}`] = entry;
    counter++;
  });
  return entries;
};

const serializeAws_queryValueStringList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  (input || []).map(entry => {
    entries[`item.${counter}`] = entry;
    counter++;
  });
  return entries;
};

const serializeAws_queryVpcSecurityGroupIdList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  (input || []).map(entry => {
    entries[`VpcSecurityGroupId.${counter}`] = entry;
    counter++;
  });
  return entries;
};

const deserializeAws_queryAccessToSnapshotDeniedFault = (
  output: any,
  context: __SerdeContext
): AccessToSnapshotDeniedFault => {
  let contents: any = {
    __type: "AccessToSnapshotDeniedFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message = output["message"];
  }
  return contents;
};

const deserializeAws_queryAuthorizationAlreadyExistsFault = (
  output: any,
  context: __SerdeContext
): AuthorizationAlreadyExistsFault => {
  let contents: any = {
    __type: "AuthorizationAlreadyExistsFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message = output["message"];
  }
  return contents;
};

const deserializeAws_queryAuthorizationNotFoundFault = (
  output: any,
  context: __SerdeContext
): AuthorizationNotFoundFault => {
  let contents: any = {
    __type: "AuthorizationNotFoundFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message = output["message"];
  }
  return contents;
};

const deserializeAws_queryAuthorizationQuotaExceededFault = (
  output: any,
  context: __SerdeContext
): AuthorizationQuotaExceededFault => {
  let contents: any = {
    __type: "AuthorizationQuotaExceededFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message = output["message"];
  }
  return contents;
};

const deserializeAws_queryBatchDeleteRequestSizeExceededFault = (
  output: any,
  context: __SerdeContext
): BatchDeleteRequestSizeExceededFault => {
  let contents: any = {
    __type: "BatchDeleteRequestSizeExceededFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message = output["message"];
  }
  return contents;
};

const deserializeAws_queryBatchModifyClusterSnapshotsLimitExceededFault = (
  output: any,
  context: __SerdeContext
): BatchModifyClusterSnapshotsLimitExceededFault => {
  let contents: any = {
    __type: "BatchModifyClusterSnapshotsLimitExceededFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message = output["message"];
  }
  return contents;
};

const deserializeAws_queryBucketNotFoundFault = (
  output: any,
  context: __SerdeContext
): BucketNotFoundFault => {
  let contents: any = {
    __type: "BucketNotFoundFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message = output["message"];
  }
  return contents;
};

const deserializeAws_queryClusterAlreadyExistsFault = (
  output: any,
  context: __SerdeContext
): ClusterAlreadyExistsFault => {
  let contents: any = {
    __type: "ClusterAlreadyExistsFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message = output["message"];
  }
  return contents;
};

const deserializeAws_queryClusterNotFoundFault = (
  output: any,
  context: __SerdeContext
): ClusterNotFoundFault => {
  let contents: any = {
    __type: "ClusterNotFoundFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message = output["message"];
  }
  return contents;
};

const deserializeAws_queryClusterOnLatestRevisionFault = (
  output: any,
  context: __SerdeContext
): ClusterOnLatestRevisionFault => {
  let contents: any = {
    __type: "ClusterOnLatestRevisionFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message = output["message"];
  }
  return contents;
};

const deserializeAws_queryClusterParameterGroupAlreadyExistsFault = (
  output: any,
  context: __SerdeContext
): ClusterParameterGroupAlreadyExistsFault => {
  let contents: any = {
    __type: "ClusterParameterGroupAlreadyExistsFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message = output["message"];
  }
  return contents;
};

const deserializeAws_queryClusterParameterGroupNotFoundFault = (
  output: any,
  context: __SerdeContext
): ClusterParameterGroupNotFoundFault => {
  let contents: any = {
    __type: "ClusterParameterGroupNotFoundFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message = output["message"];
  }
  return contents;
};

const deserializeAws_queryClusterParameterGroupQuotaExceededFault = (
  output: any,
  context: __SerdeContext
): ClusterParameterGroupQuotaExceededFault => {
  let contents: any = {
    __type: "ClusterParameterGroupQuotaExceededFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message = output["message"];
  }
  return contents;
};

const deserializeAws_queryClusterQuotaExceededFault = (
  output: any,
  context: __SerdeContext
): ClusterQuotaExceededFault => {
  let contents: any = {
    __type: "ClusterQuotaExceededFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message = output["message"];
  }
  return contents;
};

const deserializeAws_queryClusterSecurityGroupAlreadyExistsFault = (
  output: any,
  context: __SerdeContext
): ClusterSecurityGroupAlreadyExistsFault => {
  let contents: any = {
    __type: "ClusterSecurityGroupAlreadyExistsFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message = output["message"];
  }
  return contents;
};

const deserializeAws_queryClusterSecurityGroupNotFoundFault = (
  output: any,
  context: __SerdeContext
): ClusterSecurityGroupNotFoundFault => {
  let contents: any = {
    __type: "ClusterSecurityGroupNotFoundFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message = output["message"];
  }
  return contents;
};

const deserializeAws_queryClusterSecurityGroupQuotaExceededFault = (
  output: any,
  context: __SerdeContext
): ClusterSecurityGroupQuotaExceededFault => {
  let contents: any = {
    __type: "ClusterSecurityGroupQuotaExceededFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message = output["message"];
  }
  return contents;
};

const deserializeAws_queryClusterSnapshotAlreadyExistsFault = (
  output: any,
  context: __SerdeContext
): ClusterSnapshotAlreadyExistsFault => {
  let contents: any = {
    __type: "ClusterSnapshotAlreadyExistsFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message = output["message"];
  }
  return contents;
};

const deserializeAws_queryClusterSnapshotNotFoundFault = (
  output: any,
  context: __SerdeContext
): ClusterSnapshotNotFoundFault => {
  let contents: any = {
    __type: "ClusterSnapshotNotFoundFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message = output["message"];
  }
  return contents;
};

const deserializeAws_queryClusterSnapshotQuotaExceededFault = (
  output: any,
  context: __SerdeContext
): ClusterSnapshotQuotaExceededFault => {
  let contents: any = {
    __type: "ClusterSnapshotQuotaExceededFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message = output["message"];
  }
  return contents;
};

const deserializeAws_queryClusterSubnetGroupAlreadyExistsFault = (
  output: any,
  context: __SerdeContext
): ClusterSubnetGroupAlreadyExistsFault => {
  let contents: any = {
    __type: "ClusterSubnetGroupAlreadyExistsFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message = output["message"];
  }
  return contents;
};

const deserializeAws_queryClusterSubnetGroupNotFoundFault = (
  output: any,
  context: __SerdeContext
): ClusterSubnetGroupNotFoundFault => {
  let contents: any = {
    __type: "ClusterSubnetGroupNotFoundFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message = output["message"];
  }
  return contents;
};

const deserializeAws_queryClusterSubnetGroupQuotaExceededFault = (
  output: any,
  context: __SerdeContext
): ClusterSubnetGroupQuotaExceededFault => {
  let contents: any = {
    __type: "ClusterSubnetGroupQuotaExceededFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message = output["message"];
  }
  return contents;
};

const deserializeAws_queryClusterSubnetQuotaExceededFault = (
  output: any,
  context: __SerdeContext
): ClusterSubnetQuotaExceededFault => {
  let contents: any = {
    __type: "ClusterSubnetQuotaExceededFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message = output["message"];
  }
  return contents;
};

const deserializeAws_queryCopyToRegionDisabledFault = (
  output: any,
  context: __SerdeContext
): CopyToRegionDisabledFault => {
  let contents: any = {
    __type: "CopyToRegionDisabledFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message = output["message"];
  }
  return contents;
};

const deserializeAws_queryDependentServiceRequestThrottlingFault = (
  output: any,
  context: __SerdeContext
): DependentServiceRequestThrottlingFault => {
  let contents: any = {
    __type: "DependentServiceRequestThrottlingFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message = output["message"];
  }
  return contents;
};

const deserializeAws_queryDependentServiceUnavailableFault = (
  output: any,
  context: __SerdeContext
): DependentServiceUnavailableFault => {
  let contents: any = {
    __type: "DependentServiceUnavailableFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message = output["message"];
  }
  return contents;
};

const deserializeAws_queryEventSubscriptionQuotaExceededFault = (
  output: any,
  context: __SerdeContext
): EventSubscriptionQuotaExceededFault => {
  let contents: any = {
    __type: "EventSubscriptionQuotaExceededFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message = output["message"];
  }
  return contents;
};

const deserializeAws_queryHsmClientCertificateAlreadyExistsFault = (
  output: any,
  context: __SerdeContext
): HsmClientCertificateAlreadyExistsFault => {
  let contents: any = {
    __type: "HsmClientCertificateAlreadyExistsFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message = output["message"];
  }
  return contents;
};

const deserializeAws_queryHsmClientCertificateNotFoundFault = (
  output: any,
  context: __SerdeContext
): HsmClientCertificateNotFoundFault => {
  let contents: any = {
    __type: "HsmClientCertificateNotFoundFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message = output["message"];
  }
  return contents;
};

const deserializeAws_queryHsmClientCertificateQuotaExceededFault = (
  output: any,
  context: __SerdeContext
): HsmClientCertificateQuotaExceededFault => {
  let contents: any = {
    __type: "HsmClientCertificateQuotaExceededFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message = output["message"];
  }
  return contents;
};

const deserializeAws_queryHsmConfigurationAlreadyExistsFault = (
  output: any,
  context: __SerdeContext
): HsmConfigurationAlreadyExistsFault => {
  let contents: any = {
    __type: "HsmConfigurationAlreadyExistsFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message = output["message"];
  }
  return contents;
};

const deserializeAws_queryHsmConfigurationNotFoundFault = (
  output: any,
  context: __SerdeContext
): HsmConfigurationNotFoundFault => {
  let contents: any = {
    __type: "HsmConfigurationNotFoundFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message = output["message"];
  }
  return contents;
};

const deserializeAws_queryHsmConfigurationQuotaExceededFault = (
  output: any,
  context: __SerdeContext
): HsmConfigurationQuotaExceededFault => {
  let contents: any = {
    __type: "HsmConfigurationQuotaExceededFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message = output["message"];
  }
  return contents;
};

const deserializeAws_queryInProgressTableRestoreQuotaExceededFault = (
  output: any,
  context: __SerdeContext
): InProgressTableRestoreQuotaExceededFault => {
  let contents: any = {
    __type: "InProgressTableRestoreQuotaExceededFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message = output["message"];
  }
  return contents;
};

const deserializeAws_queryIncompatibleOrderableOptions = (
  output: any,
  context: __SerdeContext
): IncompatibleOrderableOptions => {
  let contents: any = {
    __type: "IncompatibleOrderableOptions",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message = output["message"];
  }
  return contents;
};

const deserializeAws_queryInsufficientClusterCapacityFault = (
  output: any,
  context: __SerdeContext
): InsufficientClusterCapacityFault => {
  let contents: any = {
    __type: "InsufficientClusterCapacityFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message = output["message"];
  }
  return contents;
};

const deserializeAws_queryInsufficientS3BucketPolicyFault = (
  output: any,
  context: __SerdeContext
): InsufficientS3BucketPolicyFault => {
  let contents: any = {
    __type: "InsufficientS3BucketPolicyFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message = output["message"];
  }
  return contents;
};

const deserializeAws_queryInvalidClusterParameterGroupStateFault = (
  output: any,
  context: __SerdeContext
): InvalidClusterParameterGroupStateFault => {
  let contents: any = {
    __type: "InvalidClusterParameterGroupStateFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message = output["message"];
  }
  return contents;
};

const deserializeAws_queryInvalidClusterSecurityGroupStateFault = (
  output: any,
  context: __SerdeContext
): InvalidClusterSecurityGroupStateFault => {
  let contents: any = {
    __type: "InvalidClusterSecurityGroupStateFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message = output["message"];
  }
  return contents;
};

const deserializeAws_queryInvalidClusterSnapshotScheduleStateFault = (
  output: any,
  context: __SerdeContext
): InvalidClusterSnapshotScheduleStateFault => {
  let contents: any = {
    __type: "InvalidClusterSnapshotScheduleStateFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message = output["message"];
  }
  return contents;
};

const deserializeAws_queryInvalidClusterSnapshotStateFault = (
  output: any,
  context: __SerdeContext
): InvalidClusterSnapshotStateFault => {
  let contents: any = {
    __type: "InvalidClusterSnapshotStateFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message = output["message"];
  }
  return contents;
};

const deserializeAws_queryInvalidClusterStateFault = (
  output: any,
  context: __SerdeContext
): InvalidClusterStateFault => {
  let contents: any = {
    __type: "InvalidClusterStateFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message = output["message"];
  }
  return contents;
};

const deserializeAws_queryInvalidClusterSubnetGroupStateFault = (
  output: any,
  context: __SerdeContext
): InvalidClusterSubnetGroupStateFault => {
  let contents: any = {
    __type: "InvalidClusterSubnetGroupStateFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message = output["message"];
  }
  return contents;
};

const deserializeAws_queryInvalidClusterSubnetStateFault = (
  output: any,
  context: __SerdeContext
): InvalidClusterSubnetStateFault => {
  let contents: any = {
    __type: "InvalidClusterSubnetStateFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message = output["message"];
  }
  return contents;
};

const deserializeAws_queryInvalidClusterTrackFault = (
  output: any,
  context: __SerdeContext
): InvalidClusterTrackFault => {
  let contents: any = {
    __type: "InvalidClusterTrackFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message = output["message"];
  }
  return contents;
};

const deserializeAws_queryInvalidElasticIpFault = (
  output: any,
  context: __SerdeContext
): InvalidElasticIpFault => {
  let contents: any = {
    __type: "InvalidElasticIpFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message = output["message"];
  }
  return contents;
};

const deserializeAws_queryInvalidHsmClientCertificateStateFault = (
  output: any,
  context: __SerdeContext
): InvalidHsmClientCertificateStateFault => {
  let contents: any = {
    __type: "InvalidHsmClientCertificateStateFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message = output["message"];
  }
  return contents;
};

const deserializeAws_queryInvalidHsmConfigurationStateFault = (
  output: any,
  context: __SerdeContext
): InvalidHsmConfigurationStateFault => {
  let contents: any = {
    __type: "InvalidHsmConfigurationStateFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message = output["message"];
  }
  return contents;
};

const deserializeAws_queryInvalidReservedNodeStateFault = (
  output: any,
  context: __SerdeContext
): InvalidReservedNodeStateFault => {
  let contents: any = {
    __type: "InvalidReservedNodeStateFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message = output["message"];
  }
  return contents;
};

const deserializeAws_queryInvalidRestoreFault = (
  output: any,
  context: __SerdeContext
): InvalidRestoreFault => {
  let contents: any = {
    __type: "InvalidRestoreFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message = output["message"];
  }
  return contents;
};

const deserializeAws_queryInvalidRetentionPeriodFault = (
  output: any,
  context: __SerdeContext
): InvalidRetentionPeriodFault => {
  let contents: any = {
    __type: "InvalidRetentionPeriodFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message = output["message"];
  }
  return contents;
};

const deserializeAws_queryInvalidS3BucketNameFault = (
  output: any,
  context: __SerdeContext
): InvalidS3BucketNameFault => {
  let contents: any = {
    __type: "InvalidS3BucketNameFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message = output["message"];
  }
  return contents;
};

const deserializeAws_queryInvalidS3KeyPrefixFault = (
  output: any,
  context: __SerdeContext
): InvalidS3KeyPrefixFault => {
  let contents: any = {
    __type: "InvalidS3KeyPrefixFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message = output["message"];
  }
  return contents;
};

const deserializeAws_queryInvalidScheduleFault = (
  output: any,
  context: __SerdeContext
): InvalidScheduleFault => {
  let contents: any = {
    __type: "InvalidScheduleFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message = output["message"];
  }
  return contents;
};

const deserializeAws_queryInvalidScheduledActionFault = (
  output: any,
  context: __SerdeContext
): InvalidScheduledActionFault => {
  let contents: any = {
    __type: "InvalidScheduledActionFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message = output["message"];
  }
  return contents;
};

const deserializeAws_queryInvalidSnapshotCopyGrantStateFault = (
  output: any,
  context: __SerdeContext
): InvalidSnapshotCopyGrantStateFault => {
  let contents: any = {
    __type: "InvalidSnapshotCopyGrantStateFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message = output["message"];
  }
  return contents;
};

const deserializeAws_queryInvalidSubnet = (
  output: any,
  context: __SerdeContext
): InvalidSubnet => {
  let contents: any = {
    __type: "InvalidSubnet",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message = output["message"];
  }
  return contents;
};

const deserializeAws_queryInvalidSubscriptionStateFault = (
  output: any,
  context: __SerdeContext
): InvalidSubscriptionStateFault => {
  let contents: any = {
    __type: "InvalidSubscriptionStateFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message = output["message"];
  }
  return contents;
};

const deserializeAws_queryInvalidTableRestoreArgumentFault = (
  output: any,
  context: __SerdeContext
): InvalidTableRestoreArgumentFault => {
  let contents: any = {
    __type: "InvalidTableRestoreArgumentFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message = output["message"];
  }
  return contents;
};

const deserializeAws_queryInvalidTagFault = (
  output: any,
  context: __SerdeContext
): InvalidTagFault => {
  let contents: any = {
    __type: "InvalidTagFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message = output["message"];
  }
  return contents;
};

const deserializeAws_queryInvalidVPCNetworkStateFault = (
  output: any,
  context: __SerdeContext
): InvalidVPCNetworkStateFault => {
  let contents: any = {
    __type: "InvalidVPCNetworkStateFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message = output["message"];
  }
  return contents;
};

const deserializeAws_queryLimitExceededFault = (
  output: any,
  context: __SerdeContext
): LimitExceededFault => {
  let contents: any = {
    __type: "LimitExceededFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message = output["message"];
  }
  return contents;
};

const deserializeAws_queryNumberOfNodesPerClusterLimitExceededFault = (
  output: any,
  context: __SerdeContext
): NumberOfNodesPerClusterLimitExceededFault => {
  let contents: any = {
    __type: "NumberOfNodesPerClusterLimitExceededFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message = output["message"];
  }
  return contents;
};

const deserializeAws_queryNumberOfNodesQuotaExceededFault = (
  output: any,
  context: __SerdeContext
): NumberOfNodesQuotaExceededFault => {
  let contents: any = {
    __type: "NumberOfNodesQuotaExceededFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message = output["message"];
  }
  return contents;
};

const deserializeAws_queryReservedNodeAlreadyExistsFault = (
  output: any,
  context: __SerdeContext
): ReservedNodeAlreadyExistsFault => {
  let contents: any = {
    __type: "ReservedNodeAlreadyExistsFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message = output["message"];
  }
  return contents;
};

const deserializeAws_queryReservedNodeAlreadyMigratedFault = (
  output: any,
  context: __SerdeContext
): ReservedNodeAlreadyMigratedFault => {
  let contents: any = {
    __type: "ReservedNodeAlreadyMigratedFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message = output["message"];
  }
  return contents;
};

const deserializeAws_queryReservedNodeNotFoundFault = (
  output: any,
  context: __SerdeContext
): ReservedNodeNotFoundFault => {
  let contents: any = {
    __type: "ReservedNodeNotFoundFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message = output["message"];
  }
  return contents;
};

const deserializeAws_queryReservedNodeOfferingNotFoundFault = (
  output: any,
  context: __SerdeContext
): ReservedNodeOfferingNotFoundFault => {
  let contents: any = {
    __type: "ReservedNodeOfferingNotFoundFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message = output["message"];
  }
  return contents;
};

const deserializeAws_queryReservedNodeQuotaExceededFault = (
  output: any,
  context: __SerdeContext
): ReservedNodeQuotaExceededFault => {
  let contents: any = {
    __type: "ReservedNodeQuotaExceededFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message = output["message"];
  }
  return contents;
};

const deserializeAws_queryResizeNotFoundFault = (
  output: any,
  context: __SerdeContext
): ResizeNotFoundFault => {
  let contents: any = {
    __type: "ResizeNotFoundFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message = output["message"];
  }
  return contents;
};

const deserializeAws_queryResourceNotFoundFault = (
  output: any,
  context: __SerdeContext
): ResourceNotFoundFault => {
  let contents: any = {
    __type: "ResourceNotFoundFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message = output["message"];
  }
  return contents;
};

const deserializeAws_querySNSInvalidTopicFault = (
  output: any,
  context: __SerdeContext
): SNSInvalidTopicFault => {
  let contents: any = {
    __type: "SNSInvalidTopicFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message = output["message"];
  }
  return contents;
};

const deserializeAws_querySNSNoAuthorizationFault = (
  output: any,
  context: __SerdeContext
): SNSNoAuthorizationFault => {
  let contents: any = {
    __type: "SNSNoAuthorizationFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message = output["message"];
  }
  return contents;
};

const deserializeAws_querySNSTopicArnNotFoundFault = (
  output: any,
  context: __SerdeContext
): SNSTopicArnNotFoundFault => {
  let contents: any = {
    __type: "SNSTopicArnNotFoundFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message = output["message"];
  }
  return contents;
};

const deserializeAws_queryScheduleDefinitionTypeUnsupportedFault = (
  output: any,
  context: __SerdeContext
): ScheduleDefinitionTypeUnsupportedFault => {
  let contents: any = {
    __type: "ScheduleDefinitionTypeUnsupportedFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message = output["message"];
  }
  return contents;
};

const deserializeAws_queryScheduledActionAlreadyExistsFault = (
  output: any,
  context: __SerdeContext
): ScheduledActionAlreadyExistsFault => {
  let contents: any = {
    __type: "ScheduledActionAlreadyExistsFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message = output["message"];
  }
  return contents;
};

const deserializeAws_queryScheduledActionNotFoundFault = (
  output: any,
  context: __SerdeContext
): ScheduledActionNotFoundFault => {
  let contents: any = {
    __type: "ScheduledActionNotFoundFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message = output["message"];
  }
  return contents;
};

const deserializeAws_queryScheduledActionQuotaExceededFault = (
  output: any,
  context: __SerdeContext
): ScheduledActionQuotaExceededFault => {
  let contents: any = {
    __type: "ScheduledActionQuotaExceededFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message = output["message"];
  }
  return contents;
};

const deserializeAws_queryScheduledActionTypeUnsupportedFault = (
  output: any,
  context: __SerdeContext
): ScheduledActionTypeUnsupportedFault => {
  let contents: any = {
    __type: "ScheduledActionTypeUnsupportedFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message = output["message"];
  }
  return contents;
};

const deserializeAws_querySnapshotCopyAlreadyDisabledFault = (
  output: any,
  context: __SerdeContext
): SnapshotCopyAlreadyDisabledFault => {
  let contents: any = {
    __type: "SnapshotCopyAlreadyDisabledFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message = output["message"];
  }
  return contents;
};

const deserializeAws_querySnapshotCopyAlreadyEnabledFault = (
  output: any,
  context: __SerdeContext
): SnapshotCopyAlreadyEnabledFault => {
  let contents: any = {
    __type: "SnapshotCopyAlreadyEnabledFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message = output["message"];
  }
  return contents;
};

const deserializeAws_querySnapshotCopyDisabledFault = (
  output: any,
  context: __SerdeContext
): SnapshotCopyDisabledFault => {
  let contents: any = {
    __type: "SnapshotCopyDisabledFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message = output["message"];
  }
  return contents;
};

const deserializeAws_querySnapshotCopyGrantAlreadyExistsFault = (
  output: any,
  context: __SerdeContext
): SnapshotCopyGrantAlreadyExistsFault => {
  let contents: any = {
    __type: "SnapshotCopyGrantAlreadyExistsFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message = output["message"];
  }
  return contents;
};

const deserializeAws_querySnapshotCopyGrantNotFoundFault = (
  output: any,
  context: __SerdeContext
): SnapshotCopyGrantNotFoundFault => {
  let contents: any = {
    __type: "SnapshotCopyGrantNotFoundFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message = output["message"];
  }
  return contents;
};

const deserializeAws_querySnapshotCopyGrantQuotaExceededFault = (
  output: any,
  context: __SerdeContext
): SnapshotCopyGrantQuotaExceededFault => {
  let contents: any = {
    __type: "SnapshotCopyGrantQuotaExceededFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message = output["message"];
  }
  return contents;
};

const deserializeAws_querySnapshotScheduleAlreadyExistsFault = (
  output: any,
  context: __SerdeContext
): SnapshotScheduleAlreadyExistsFault => {
  let contents: any = {
    __type: "SnapshotScheduleAlreadyExistsFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message = output["message"];
  }
  return contents;
};

const deserializeAws_querySnapshotScheduleNotFoundFault = (
  output: any,
  context: __SerdeContext
): SnapshotScheduleNotFoundFault => {
  let contents: any = {
    __type: "SnapshotScheduleNotFoundFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message = output["message"];
  }
  return contents;
};

const deserializeAws_querySnapshotScheduleQuotaExceededFault = (
  output: any,
  context: __SerdeContext
): SnapshotScheduleQuotaExceededFault => {
  let contents: any = {
    __type: "SnapshotScheduleQuotaExceededFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message = output["message"];
  }
  return contents;
};

const deserializeAws_querySnapshotScheduleUpdateInProgressFault = (
  output: any,
  context: __SerdeContext
): SnapshotScheduleUpdateInProgressFault => {
  let contents: any = {
    __type: "SnapshotScheduleUpdateInProgressFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message = output["message"];
  }
  return contents;
};

const deserializeAws_querySourceNotFoundFault = (
  output: any,
  context: __SerdeContext
): SourceNotFoundFault => {
  let contents: any = {
    __type: "SourceNotFoundFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message = output["message"];
  }
  return contents;
};

const deserializeAws_querySubnetAlreadyInUse = (
  output: any,
  context: __SerdeContext
): SubnetAlreadyInUse => {
  let contents: any = {
    __type: "SubnetAlreadyInUse",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message = output["message"];
  }
  return contents;
};

const deserializeAws_querySubscriptionAlreadyExistFault = (
  output: any,
  context: __SerdeContext
): SubscriptionAlreadyExistFault => {
  let contents: any = {
    __type: "SubscriptionAlreadyExistFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message = output["message"];
  }
  return contents;
};

const deserializeAws_querySubscriptionCategoryNotFoundFault = (
  output: any,
  context: __SerdeContext
): SubscriptionCategoryNotFoundFault => {
  let contents: any = {
    __type: "SubscriptionCategoryNotFoundFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message = output["message"];
  }
  return contents;
};

const deserializeAws_querySubscriptionEventIdNotFoundFault = (
  output: any,
  context: __SerdeContext
): SubscriptionEventIdNotFoundFault => {
  let contents: any = {
    __type: "SubscriptionEventIdNotFoundFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message = output["message"];
  }
  return contents;
};

const deserializeAws_querySubscriptionNotFoundFault = (
  output: any,
  context: __SerdeContext
): SubscriptionNotFoundFault => {
  let contents: any = {
    __type: "SubscriptionNotFoundFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message = output["message"];
  }
  return contents;
};

const deserializeAws_querySubscriptionSeverityNotFoundFault = (
  output: any,
  context: __SerdeContext
): SubscriptionSeverityNotFoundFault => {
  let contents: any = {
    __type: "SubscriptionSeverityNotFoundFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message = output["message"];
  }
  return contents;
};

const deserializeAws_queryTableLimitExceededFault = (
  output: any,
  context: __SerdeContext
): TableLimitExceededFault => {
  let contents: any = {
    __type: "TableLimitExceededFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message = output["message"];
  }
  return contents;
};

const deserializeAws_queryTableRestoreNotFoundFault = (
  output: any,
  context: __SerdeContext
): TableRestoreNotFoundFault => {
  let contents: any = {
    __type: "TableRestoreNotFoundFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message = output["message"];
  }
  return contents;
};

const deserializeAws_queryTagLimitExceededFault = (
  output: any,
  context: __SerdeContext
): TagLimitExceededFault => {
  let contents: any = {
    __type: "TagLimitExceededFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message = output["message"];
  }
  return contents;
};

const deserializeAws_queryUnauthorizedOperation = (
  output: any,
  context: __SerdeContext
): UnauthorizedOperation => {
  let contents: any = {
    __type: "UnauthorizedOperation",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message = output["message"];
  }
  return contents;
};

const deserializeAws_queryUnknownSnapshotCopyRegionFault = (
  output: any,
  context: __SerdeContext
): UnknownSnapshotCopyRegionFault => {
  let contents: any = {
    __type: "UnknownSnapshotCopyRegionFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message = output["message"];
  }
  return contents;
};

const deserializeAws_queryUnsupportedOperationFault = (
  output: any,
  context: __SerdeContext
): UnsupportedOperationFault => {
  let contents: any = {
    __type: "UnsupportedOperationFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message = output["message"];
  }
  return contents;
};

const deserializeAws_queryUnsupportedOptionFault = (
  output: any,
  context: __SerdeContext
): UnsupportedOptionFault => {
  let contents: any = {
    __type: "UnsupportedOptionFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message = output["message"];
  }
  return contents;
};

const deserializeAws_queryAcceptReservedNodeExchangeOutputMessage = (
  output: any,
  context: __SerdeContext
): AcceptReservedNodeExchangeOutputMessage => {
  let contents: any = {
    __type: "AcceptReservedNodeExchangeOutputMessage",
    ExchangedReservedNode: undefined
  };
  if (output["ExchangedReservedNode"] !== undefined) {
    contents.ExchangedReservedNode = deserializeAws_queryReservedNode(
      output["ExchangedReservedNode"],
      context
    );
  }
  return contents;
};

const deserializeAws_queryAccountAttribute = (
  output: any,
  context: __SerdeContext
): AccountAttribute => {
  let contents: any = {
    __type: "AccountAttribute",
    AttributeName: undefined,
    AttributeValues: undefined
  };
  if (output["AttributeName"] !== undefined) {
    contents.AttributeName = output["AttributeName"];
  }
  if (output.AttributeValues === "") {
    contents.AttributeValues = [];
  }
  if (
    output["AttributeValues"] !== undefined &&
    output["AttributeValues"]["AttributeValueTarget"] !== undefined
  ) {
    const wrappedItem =
      output["AttributeValues"]["AttributeValueTarget"] instanceof Array
        ? output["AttributeValues"]["AttributeValueTarget"]
        : [output["AttributeValues"]["AttributeValueTarget"]];
    contents.AttributeValues = deserializeAws_queryAttributeValueList(
      wrappedItem,
      context
    );
  }
  return contents;
};

const deserializeAws_queryAccountAttributeList = (
  output: any,
  context: __SerdeContext
): AccountAttributeList => {
  let contents: any = {
    __type: "AccountAttributeList",
    AccountAttributes: undefined
  };
  if (output.AccountAttributes === "") {
    contents.AccountAttributes = [];
  }
  if (
    output["AccountAttributes"] !== undefined &&
    output["AccountAttributes"]["AccountAttribute"] !== undefined
  ) {
    const wrappedItem =
      output["AccountAttributes"]["AccountAttribute"] instanceof Array
        ? output["AccountAttributes"]["AccountAttribute"]
        : [output["AccountAttributes"]["AccountAttribute"]];
    contents.AccountAttributes = deserializeAws_queryAttributeList(
      wrappedItem,
      context
    );
  }
  return contents;
};

const deserializeAws_queryAccountWithRestoreAccess = (
  output: any,
  context: __SerdeContext
): AccountWithRestoreAccess => {
  let contents: any = {
    __type: "AccountWithRestoreAccess",
    AccountAlias: undefined,
    AccountId: undefined
  };
  if (output["AccountAlias"] !== undefined) {
    contents.AccountAlias = output["AccountAlias"];
  }
  if (output["AccountId"] !== undefined) {
    contents.AccountId = output["AccountId"];
  }
  return contents;
};

const deserializeAws_queryAccountsWithRestoreAccessList = (
  output: any,
  context: __SerdeContext
): Array<AccountWithRestoreAccess> => {
  return (output || []).map((entry: any) =>
    deserializeAws_queryAccountWithRestoreAccess(entry, context)
  );
};

const deserializeAws_queryAssociatedClusterList = (
  output: any,
  context: __SerdeContext
): Array<ClusterAssociatedToSchedule> => {
  return (output || []).map((entry: any) =>
    deserializeAws_queryClusterAssociatedToSchedule(entry, context)
  );
};

const deserializeAws_queryAttributeList = (
  output: any,
  context: __SerdeContext
): Array<AccountAttribute> => {
  return (output || []).map((entry: any) =>
    deserializeAws_queryAccountAttribute(entry, context)
  );
};

const deserializeAws_queryAttributeValueList = (
  output: any,
  context: __SerdeContext
): Array<AttributeValueTarget> => {
  return (output || []).map((entry: any) =>
    deserializeAws_queryAttributeValueTarget(entry, context)
  );
};

const deserializeAws_queryAttributeValueTarget = (
  output: any,
  context: __SerdeContext
): AttributeValueTarget => {
  let contents: any = {
    __type: "AttributeValueTarget",
    AttributeValue: undefined
  };
  if (output["AttributeValue"] !== undefined) {
    contents.AttributeValue = output["AttributeValue"];
  }
  return contents;
};

const deserializeAws_queryAuthorizeClusterSecurityGroupIngressResult = (
  output: any,
  context: __SerdeContext
): AuthorizeClusterSecurityGroupIngressResult => {
  let contents: any = {
    __type: "AuthorizeClusterSecurityGroupIngressResult",
    ClusterSecurityGroup: undefined
  };
  if (output["ClusterSecurityGroup"] !== undefined) {
    contents.ClusterSecurityGroup = deserializeAws_queryClusterSecurityGroup(
      output["ClusterSecurityGroup"],
      context
    );
  }
  return contents;
};

const deserializeAws_queryAuthorizeSnapshotAccessResult = (
  output: any,
  context: __SerdeContext
): AuthorizeSnapshotAccessResult => {
  let contents: any = {
    __type: "AuthorizeSnapshotAccessResult",
    Snapshot: undefined
  };
  if (output["Snapshot"] !== undefined) {
    contents.Snapshot = deserializeAws_querySnapshot(
      output["Snapshot"],
      context
    );
  }
  return contents;
};

const deserializeAws_queryAvailabilityZone = (
  output: any,
  context: __SerdeContext
): AvailabilityZone => {
  let contents: any = {
    __type: "AvailabilityZone",
    Name: undefined,
    SupportedPlatforms: undefined
  };
  if (output["Name"] !== undefined) {
    contents.Name = output["Name"];
  }
  if (output.SupportedPlatforms === "") {
    contents.SupportedPlatforms = [];
  }
  if (
    output["SupportedPlatforms"] !== undefined &&
    output["SupportedPlatforms"]["SupportedPlatform"] !== undefined
  ) {
    const wrappedItem =
      output["SupportedPlatforms"]["SupportedPlatform"] instanceof Array
        ? output["SupportedPlatforms"]["SupportedPlatform"]
        : [output["SupportedPlatforms"]["SupportedPlatform"]];
    contents.SupportedPlatforms = deserializeAws_querySupportedPlatformsList(
      wrappedItem,
      context
    );
  }
  return contents;
};

const deserializeAws_queryAvailabilityZoneList = (
  output: any,
  context: __SerdeContext
): Array<AvailabilityZone> => {
  return (output || []).map((entry: any) =>
    deserializeAws_queryAvailabilityZone(entry, context)
  );
};

const deserializeAws_queryBatchDeleteClusterSnapshotsResult = (
  output: any,
  context: __SerdeContext
): BatchDeleteClusterSnapshotsResult => {
  let contents: any = {
    __type: "BatchDeleteClusterSnapshotsResult",
    Errors: undefined,
    Resources: undefined
  };
  if (output.Errors === "") {
    contents.Errors = [];
  }
  if (
    output["Errors"] !== undefined &&
    output["Errors"]["SnapshotErrorMessage"] !== undefined
  ) {
    const wrappedItem =
      output["Errors"]["SnapshotErrorMessage"] instanceof Array
        ? output["Errors"]["SnapshotErrorMessage"]
        : [output["Errors"]["SnapshotErrorMessage"]];
    contents.Errors = deserializeAws_queryBatchSnapshotOperationErrorList(
      wrappedItem,
      context
    );
  }
  if (output.Resources === "") {
    contents.Resources = [];
  }
  if (
    output["Resources"] !== undefined &&
    output["Resources"]["String"] !== undefined
  ) {
    const wrappedItem =
      output["Resources"]["String"] instanceof Array
        ? output["Resources"]["String"]
        : [output["Resources"]["String"]];
    contents.Resources = deserializeAws_querySnapshotIdentifierList(
      wrappedItem,
      context
    );
  }
  return contents;
};

const deserializeAws_queryBatchModifyClusterSnapshotsOutputMessage = (
  output: any,
  context: __SerdeContext
): BatchModifyClusterSnapshotsOutputMessage => {
  let contents: any = {
    __type: "BatchModifyClusterSnapshotsOutputMessage",
    Errors: undefined,
    Resources: undefined
  };
  if (output.Errors === "") {
    contents.Errors = [];
  }
  if (
    output["Errors"] !== undefined &&
    output["Errors"]["SnapshotErrorMessage"] !== undefined
  ) {
    const wrappedItem =
      output["Errors"]["SnapshotErrorMessage"] instanceof Array
        ? output["Errors"]["SnapshotErrorMessage"]
        : [output["Errors"]["SnapshotErrorMessage"]];
    contents.Errors = deserializeAws_queryBatchSnapshotOperationErrors(
      wrappedItem,
      context
    );
  }
  if (output.Resources === "") {
    contents.Resources = [];
  }
  if (
    output["Resources"] !== undefined &&
    output["Resources"]["String"] !== undefined
  ) {
    const wrappedItem =
      output["Resources"]["String"] instanceof Array
        ? output["Resources"]["String"]
        : [output["Resources"]["String"]];
    contents.Resources = deserializeAws_querySnapshotIdentifierList(
      wrappedItem,
      context
    );
  }
  return contents;
};

const deserializeAws_queryBatchSnapshotOperationErrorList = (
  output: any,
  context: __SerdeContext
): Array<SnapshotErrorMessage> => {
  return (output || []).map((entry: any) =>
    deserializeAws_querySnapshotErrorMessage(entry, context)
  );
};

const deserializeAws_queryBatchSnapshotOperationErrors = (
  output: any,
  context: __SerdeContext
): Array<SnapshotErrorMessage> => {
  return (output || []).map((entry: any) =>
    deserializeAws_querySnapshotErrorMessage(entry, context)
  );
};

const deserializeAws_queryCluster = (
  output: any,
  context: __SerdeContext
): Cluster => {
  let contents: any = {
    __type: "Cluster",
    AllowVersionUpgrade: undefined,
    AutomatedSnapshotRetentionPeriod: undefined,
    AvailabilityZone: undefined,
    ClusterAvailabilityStatus: undefined,
    ClusterCreateTime: undefined,
    ClusterIdentifier: undefined,
    ClusterNodes: undefined,
    ClusterParameterGroups: undefined,
    ClusterPublicKey: undefined,
    ClusterRevisionNumber: undefined,
    ClusterSecurityGroups: undefined,
    ClusterSnapshotCopyStatus: undefined,
    ClusterStatus: undefined,
    ClusterSubnetGroupName: undefined,
    ClusterVersion: undefined,
    DBName: undefined,
    DataTransferProgress: undefined,
    DeferredMaintenanceWindows: undefined,
    ElasticIpStatus: undefined,
    ElasticResizeNumberOfNodeOptions: undefined,
    Encrypted: undefined,
    Endpoint: undefined,
    EnhancedVpcRouting: undefined,
    ExpectedNextSnapshotScheduleTime: undefined,
    ExpectedNextSnapshotScheduleTimeStatus: undefined,
    HsmStatus: undefined,
    IamRoles: undefined,
    KmsKeyId: undefined,
    MaintenanceTrackName: undefined,
    ManualSnapshotRetentionPeriod: undefined,
    MasterUsername: undefined,
    ModifyStatus: undefined,
    NextMaintenanceWindowStartTime: undefined,
    NodeType: undefined,
    NumberOfNodes: undefined,
    PendingActions: undefined,
    PendingModifiedValues: undefined,
    PreferredMaintenanceWindow: undefined,
    PubliclyAccessible: undefined,
    ResizeInfo: undefined,
    RestoreStatus: undefined,
    SnapshotScheduleIdentifier: undefined,
    SnapshotScheduleState: undefined,
    Tags: undefined,
    VpcId: undefined,
    VpcSecurityGroups: undefined
  };
  if (output["AllowVersionUpgrade"] !== undefined) {
    contents.AllowVersionUpgrade = output["AllowVersionUpgrade"] == "true";
  }
  if (output["AutomatedSnapshotRetentionPeriod"] !== undefined) {
    contents.AutomatedSnapshotRetentionPeriod = parseInt(
      output["AutomatedSnapshotRetentionPeriod"]
    );
  }
  if (output["AvailabilityZone"] !== undefined) {
    contents.AvailabilityZone = output["AvailabilityZone"];
  }
  if (output["ClusterAvailabilityStatus"] !== undefined) {
    contents.ClusterAvailabilityStatus = output["ClusterAvailabilityStatus"];
  }
  if (output["ClusterCreateTime"] !== undefined) {
    contents.ClusterCreateTime = new Date(output["ClusterCreateTime"]);
  }
  if (output["ClusterIdentifier"] !== undefined) {
    contents.ClusterIdentifier = output["ClusterIdentifier"];
  }
  if (output.ClusterNodes === "") {
    contents.ClusterNodes = [];
  }
  if (
    output["ClusterNodes"] !== undefined &&
    output["ClusterNodes"]["member"] !== undefined
  ) {
    const wrappedItem =
      output["ClusterNodes"]["member"] instanceof Array
        ? output["ClusterNodes"]["member"]
        : [output["ClusterNodes"]["member"]];
    contents.ClusterNodes = deserializeAws_queryClusterNodesList(
      wrappedItem,
      context
    );
  }
  if (output.ClusterParameterGroups === "") {
    contents.ClusterParameterGroups = [];
  }
  if (
    output["ClusterParameterGroups"] !== undefined &&
    output["ClusterParameterGroups"]["ClusterParameterGroup"] !== undefined
  ) {
    const wrappedItem =
      output["ClusterParameterGroups"]["ClusterParameterGroup"] instanceof Array
        ? output["ClusterParameterGroups"]["ClusterParameterGroup"]
        : [output["ClusterParameterGroups"]["ClusterParameterGroup"]];
    contents.ClusterParameterGroups = deserializeAws_queryClusterParameterGroupStatusList(
      wrappedItem,
      context
    );
  }
  if (output["ClusterPublicKey"] !== undefined) {
    contents.ClusterPublicKey = output["ClusterPublicKey"];
  }
  if (output["ClusterRevisionNumber"] !== undefined) {
    contents.ClusterRevisionNumber = output["ClusterRevisionNumber"];
  }
  if (output.ClusterSecurityGroups === "") {
    contents.ClusterSecurityGroups = [];
  }
  if (
    output["ClusterSecurityGroups"] !== undefined &&
    output["ClusterSecurityGroups"]["ClusterSecurityGroup"] !== undefined
  ) {
    const wrappedItem =
      output["ClusterSecurityGroups"]["ClusterSecurityGroup"] instanceof Array
        ? output["ClusterSecurityGroups"]["ClusterSecurityGroup"]
        : [output["ClusterSecurityGroups"]["ClusterSecurityGroup"]];
    contents.ClusterSecurityGroups = deserializeAws_queryClusterSecurityGroupMembershipList(
      wrappedItem,
      context
    );
  }
  if (output["ClusterSnapshotCopyStatus"] !== undefined) {
    contents.ClusterSnapshotCopyStatus = deserializeAws_queryClusterSnapshotCopyStatus(
      output["ClusterSnapshotCopyStatus"],
      context
    );
  }
  if (output["ClusterStatus"] !== undefined) {
    contents.ClusterStatus = output["ClusterStatus"];
  }
  if (output["ClusterSubnetGroupName"] !== undefined) {
    contents.ClusterSubnetGroupName = output["ClusterSubnetGroupName"];
  }
  if (output["ClusterVersion"] !== undefined) {
    contents.ClusterVersion = output["ClusterVersion"];
  }
  if (output["DBName"] !== undefined) {
    contents.DBName = output["DBName"];
  }
  if (output["DataTransferProgress"] !== undefined) {
    contents.DataTransferProgress = deserializeAws_queryDataTransferProgress(
      output["DataTransferProgress"],
      context
    );
  }
  if (output.DeferredMaintenanceWindows === "") {
    contents.DeferredMaintenanceWindows = [];
  }
  if (
    output["DeferredMaintenanceWindows"] !== undefined &&
    output["DeferredMaintenanceWindows"]["DeferredMaintenanceWindow"] !==
      undefined
  ) {
    const wrappedItem =
      output["DeferredMaintenanceWindows"][
        "DeferredMaintenanceWindow"
      ] instanceof Array
        ? output["DeferredMaintenanceWindows"]["DeferredMaintenanceWindow"]
        : [output["DeferredMaintenanceWindows"]["DeferredMaintenanceWindow"]];
    contents.DeferredMaintenanceWindows = deserializeAws_queryDeferredMaintenanceWindowsList(
      wrappedItem,
      context
    );
  }
  if (output["ElasticIpStatus"] !== undefined) {
    contents.ElasticIpStatus = deserializeAws_queryElasticIpStatus(
      output["ElasticIpStatus"],
      context
    );
  }
  if (output["ElasticResizeNumberOfNodeOptions"] !== undefined) {
    contents.ElasticResizeNumberOfNodeOptions =
      output["ElasticResizeNumberOfNodeOptions"];
  }
  if (output["Encrypted"] !== undefined) {
    contents.Encrypted = output["Encrypted"] == "true";
  }
  if (output["Endpoint"] !== undefined) {
    contents.Endpoint = deserializeAws_queryEndpoint(
      output["Endpoint"],
      context
    );
  }
  if (output["EnhancedVpcRouting"] !== undefined) {
    contents.EnhancedVpcRouting = output["EnhancedVpcRouting"] == "true";
  }
  if (output["ExpectedNextSnapshotScheduleTime"] !== undefined) {
    contents.ExpectedNextSnapshotScheduleTime = new Date(
      output["ExpectedNextSnapshotScheduleTime"]
    );
  }
  if (output["ExpectedNextSnapshotScheduleTimeStatus"] !== undefined) {
    contents.ExpectedNextSnapshotScheduleTimeStatus =
      output["ExpectedNextSnapshotScheduleTimeStatus"];
  }
  if (output["HsmStatus"] !== undefined) {
    contents.HsmStatus = deserializeAws_queryHsmStatus(
      output["HsmStatus"],
      context
    );
  }
  if (output.IamRoles === "") {
    contents.IamRoles = [];
  }
  if (
    output["IamRoles"] !== undefined &&
    output["IamRoles"]["ClusterIamRole"] !== undefined
  ) {
    const wrappedItem =
      output["IamRoles"]["ClusterIamRole"] instanceof Array
        ? output["IamRoles"]["ClusterIamRole"]
        : [output["IamRoles"]["ClusterIamRole"]];
    contents.IamRoles = deserializeAws_queryClusterIamRoleList(
      wrappedItem,
      context
    );
  }
  if (output["KmsKeyId"] !== undefined) {
    contents.KmsKeyId = output["KmsKeyId"];
  }
  if (output["MaintenanceTrackName"] !== undefined) {
    contents.MaintenanceTrackName = output["MaintenanceTrackName"];
  }
  if (output["ManualSnapshotRetentionPeriod"] !== undefined) {
    contents.ManualSnapshotRetentionPeriod = parseInt(
      output["ManualSnapshotRetentionPeriod"]
    );
  }
  if (output["MasterUsername"] !== undefined) {
    contents.MasterUsername = output["MasterUsername"];
  }
  if (output["ModifyStatus"] !== undefined) {
    contents.ModifyStatus = output["ModifyStatus"];
  }
  if (output["NextMaintenanceWindowStartTime"] !== undefined) {
    contents.NextMaintenanceWindowStartTime = new Date(
      output["NextMaintenanceWindowStartTime"]
    );
  }
  if (output["NodeType"] !== undefined) {
    contents.NodeType = output["NodeType"];
  }
  if (output["NumberOfNodes"] !== undefined) {
    contents.NumberOfNodes = parseInt(output["NumberOfNodes"]);
  }
  if (output.PendingActions === "") {
    contents.PendingActions = [];
  }
  if (
    output["PendingActions"] !== undefined &&
    output["PendingActions"]["member"] !== undefined
  ) {
    const wrappedItem =
      output["PendingActions"]["member"] instanceof Array
        ? output["PendingActions"]["member"]
        : [output["PendingActions"]["member"]];
    contents.PendingActions = deserializeAws_queryPendingActionsList(
      wrappedItem,
      context
    );
  }
  if (output["PendingModifiedValues"] !== undefined) {
    contents.PendingModifiedValues = deserializeAws_queryPendingModifiedValues(
      output["PendingModifiedValues"],
      context
    );
  }
  if (output["PreferredMaintenanceWindow"] !== undefined) {
    contents.PreferredMaintenanceWindow = output["PreferredMaintenanceWindow"];
  }
  if (output["PubliclyAccessible"] !== undefined) {
    contents.PubliclyAccessible = output["PubliclyAccessible"] == "true";
  }
  if (output["ResizeInfo"] !== undefined) {
    contents.ResizeInfo = deserializeAws_queryResizeInfo(
      output["ResizeInfo"],
      context
    );
  }
  if (output["RestoreStatus"] !== undefined) {
    contents.RestoreStatus = deserializeAws_queryRestoreStatus(
      output["RestoreStatus"],
      context
    );
  }
  if (output["SnapshotScheduleIdentifier"] !== undefined) {
    contents.SnapshotScheduleIdentifier = output["SnapshotScheduleIdentifier"];
  }
  if (output["SnapshotScheduleState"] !== undefined) {
    contents.SnapshotScheduleState = output["SnapshotScheduleState"];
  }
  if (output.Tags === "") {
    contents.Tags = [];
  }
  if (output["Tags"] !== undefined && output["Tags"]["Tag"] !== undefined) {
    const wrappedItem =
      output["Tags"]["Tag"] instanceof Array
        ? output["Tags"]["Tag"]
        : [output["Tags"]["Tag"]];
    contents.Tags = deserializeAws_queryTagList(wrappedItem, context);
  }
  if (output["VpcId"] !== undefined) {
    contents.VpcId = output["VpcId"];
  }
  if (output.VpcSecurityGroups === "") {
    contents.VpcSecurityGroups = [];
  }
  if (
    output["VpcSecurityGroups"] !== undefined &&
    output["VpcSecurityGroups"]["VpcSecurityGroup"] !== undefined
  ) {
    const wrappedItem =
      output["VpcSecurityGroups"]["VpcSecurityGroup"] instanceof Array
        ? output["VpcSecurityGroups"]["VpcSecurityGroup"]
        : [output["VpcSecurityGroups"]["VpcSecurityGroup"]];
    contents.VpcSecurityGroups = deserializeAws_queryVpcSecurityGroupMembershipList(
      wrappedItem,
      context
    );
  }
  return contents;
};

const deserializeAws_queryClusterAssociatedToSchedule = (
  output: any,
  context: __SerdeContext
): ClusterAssociatedToSchedule => {
  let contents: any = {
    __type: "ClusterAssociatedToSchedule",
    ClusterIdentifier: undefined,
    ScheduleAssociationState: undefined
  };
  if (output["ClusterIdentifier"] !== undefined) {
    contents.ClusterIdentifier = output["ClusterIdentifier"];
  }
  if (output["ScheduleAssociationState"] !== undefined) {
    contents.ScheduleAssociationState = output["ScheduleAssociationState"];
  }
  return contents;
};

const deserializeAws_queryClusterCredentials = (
  output: any,
  context: __SerdeContext
): ClusterCredentials => {
  let contents: any = {
    __type: "ClusterCredentials",
    DbPassword: undefined,
    DbUser: undefined,
    Expiration: undefined
  };
  if (output["DbPassword"] !== undefined) {
    contents.DbPassword = output["DbPassword"];
  }
  if (output["DbUser"] !== undefined) {
    contents.DbUser = output["DbUser"];
  }
  if (output["Expiration"] !== undefined) {
    contents.Expiration = new Date(output["Expiration"]);
  }
  return contents;
};

const deserializeAws_queryClusterDbRevision = (
  output: any,
  context: __SerdeContext
): ClusterDbRevision => {
  let contents: any = {
    __type: "ClusterDbRevision",
    ClusterIdentifier: undefined,
    CurrentDatabaseRevision: undefined,
    DatabaseRevisionReleaseDate: undefined,
    RevisionTargets: undefined
  };
  if (output["ClusterIdentifier"] !== undefined) {
    contents.ClusterIdentifier = output["ClusterIdentifier"];
  }
  if (output["CurrentDatabaseRevision"] !== undefined) {
    contents.CurrentDatabaseRevision = output["CurrentDatabaseRevision"];
  }
  if (output["DatabaseRevisionReleaseDate"] !== undefined) {
    contents.DatabaseRevisionReleaseDate = new Date(
      output["DatabaseRevisionReleaseDate"]
    );
  }
  if (output.RevisionTargets === "") {
    contents.RevisionTargets = [];
  }
  if (
    output["RevisionTargets"] !== undefined &&
    output["RevisionTargets"]["RevisionTarget"] !== undefined
  ) {
    const wrappedItem =
      output["RevisionTargets"]["RevisionTarget"] instanceof Array
        ? output["RevisionTargets"]["RevisionTarget"]
        : [output["RevisionTargets"]["RevisionTarget"]];
    contents.RevisionTargets = deserializeAws_queryRevisionTargetsList(
      wrappedItem,
      context
    );
  }
  return contents;
};

const deserializeAws_queryClusterDbRevisionsList = (
  output: any,
  context: __SerdeContext
): Array<ClusterDbRevision> => {
  return (output || []).map((entry: any) =>
    deserializeAws_queryClusterDbRevision(entry, context)
  );
};

const deserializeAws_queryClusterDbRevisionsMessage = (
  output: any,
  context: __SerdeContext
): ClusterDbRevisionsMessage => {
  let contents: any = {
    __type: "ClusterDbRevisionsMessage",
    ClusterDbRevisions: undefined,
    Marker: undefined
  };
  if (output.ClusterDbRevisions === "") {
    contents.ClusterDbRevisions = [];
  }
  if (
    output["ClusterDbRevisions"] !== undefined &&
    output["ClusterDbRevisions"]["ClusterDbRevision"] !== undefined
  ) {
    const wrappedItem =
      output["ClusterDbRevisions"]["ClusterDbRevision"] instanceof Array
        ? output["ClusterDbRevisions"]["ClusterDbRevision"]
        : [output["ClusterDbRevisions"]["ClusterDbRevision"]];
    contents.ClusterDbRevisions = deserializeAws_queryClusterDbRevisionsList(
      wrappedItem,
      context
    );
  }
  if (output["Marker"] !== undefined) {
    contents.Marker = output["Marker"];
  }
  return contents;
};

const deserializeAws_queryClusterIamRole = (
  output: any,
  context: __SerdeContext
): ClusterIamRole => {
  let contents: any = {
    __type: "ClusterIamRole",
    ApplyStatus: undefined,
    IamRoleArn: undefined
  };
  if (output["ApplyStatus"] !== undefined) {
    contents.ApplyStatus = output["ApplyStatus"];
  }
  if (output["IamRoleArn"] !== undefined) {
    contents.IamRoleArn = output["IamRoleArn"];
  }
  return contents;
};

const deserializeAws_queryClusterIamRoleList = (
  output: any,
  context: __SerdeContext
): Array<ClusterIamRole> => {
  return (output || []).map((entry: any) =>
    deserializeAws_queryClusterIamRole(entry, context)
  );
};

const deserializeAws_queryClusterList = (
  output: any,
  context: __SerdeContext
): Array<Cluster> => {
  return (output || []).map((entry: any) =>
    deserializeAws_queryCluster(entry, context)
  );
};

const deserializeAws_queryClusterNode = (
  output: any,
  context: __SerdeContext
): ClusterNode => {
  let contents: any = {
    __type: "ClusterNode",
    NodeRole: undefined,
    PrivateIPAddress: undefined,
    PublicIPAddress: undefined
  };
  if (output["NodeRole"] !== undefined) {
    contents.NodeRole = output["NodeRole"];
  }
  if (output["PrivateIPAddress"] !== undefined) {
    contents.PrivateIPAddress = output["PrivateIPAddress"];
  }
  if (output["PublicIPAddress"] !== undefined) {
    contents.PublicIPAddress = output["PublicIPAddress"];
  }
  return contents;
};

const deserializeAws_queryClusterNodesList = (
  output: any,
  context: __SerdeContext
): Array<ClusterNode> => {
  return (output || []).map((entry: any) =>
    deserializeAws_queryClusterNode(entry, context)
  );
};

const deserializeAws_queryClusterParameterGroup = (
  output: any,
  context: __SerdeContext
): ClusterParameterGroup => {
  let contents: any = {
    __type: "ClusterParameterGroup",
    Description: undefined,
    ParameterGroupFamily: undefined,
    ParameterGroupName: undefined,
    Tags: undefined
  };
  if (output["Description"] !== undefined) {
    contents.Description = output["Description"];
  }
  if (output["ParameterGroupFamily"] !== undefined) {
    contents.ParameterGroupFamily = output["ParameterGroupFamily"];
  }
  if (output["ParameterGroupName"] !== undefined) {
    contents.ParameterGroupName = output["ParameterGroupName"];
  }
  if (output.Tags === "") {
    contents.Tags = [];
  }
  if (output["Tags"] !== undefined && output["Tags"]["Tag"] !== undefined) {
    const wrappedItem =
      output["Tags"]["Tag"] instanceof Array
        ? output["Tags"]["Tag"]
        : [output["Tags"]["Tag"]];
    contents.Tags = deserializeAws_queryTagList(wrappedItem, context);
  }
  return contents;
};

const deserializeAws_queryClusterParameterGroupDetails = (
  output: any,
  context: __SerdeContext
): ClusterParameterGroupDetails => {
  let contents: any = {
    __type: "ClusterParameterGroupDetails",
    Marker: undefined,
    Parameters: undefined
  };
  if (output["Marker"] !== undefined) {
    contents.Marker = output["Marker"];
  }
  if (output.Parameters === "") {
    contents.Parameters = [];
  }
  if (
    output["Parameters"] !== undefined &&
    output["Parameters"]["Parameter"] !== undefined
  ) {
    const wrappedItem =
      output["Parameters"]["Parameter"] instanceof Array
        ? output["Parameters"]["Parameter"]
        : [output["Parameters"]["Parameter"]];
    contents.Parameters = deserializeAws_queryParametersList(
      wrappedItem,
      context
    );
  }
  return contents;
};

const deserializeAws_queryClusterParameterGroupNameMessage = (
  output: any,
  context: __SerdeContext
): ClusterParameterGroupNameMessage => {
  let contents: any = {
    __type: "ClusterParameterGroupNameMessage",
    ParameterGroupName: undefined,
    ParameterGroupStatus: undefined
  };
  if (output["ParameterGroupName"] !== undefined) {
    contents.ParameterGroupName = output["ParameterGroupName"];
  }
  if (output["ParameterGroupStatus"] !== undefined) {
    contents.ParameterGroupStatus = output["ParameterGroupStatus"];
  }
  return contents;
};

const deserializeAws_queryClusterParameterGroupStatus = (
  output: any,
  context: __SerdeContext
): ClusterParameterGroupStatus => {
  let contents: any = {
    __type: "ClusterParameterGroupStatus",
    ClusterParameterStatusList: undefined,
    ParameterApplyStatus: undefined,
    ParameterGroupName: undefined
  };
  if (output.ClusterParameterStatusList === "") {
    contents.ClusterParameterStatusList = [];
  }
  if (
    output["ClusterParameterStatusList"] !== undefined &&
    output["ClusterParameterStatusList"]["member"] !== undefined
  ) {
    const wrappedItem =
      output["ClusterParameterStatusList"]["member"] instanceof Array
        ? output["ClusterParameterStatusList"]["member"]
        : [output["ClusterParameterStatusList"]["member"]];
    contents.ClusterParameterStatusList = deserializeAws_queryClusterParameterStatusList(
      wrappedItem,
      context
    );
  }
  if (output["ParameterApplyStatus"] !== undefined) {
    contents.ParameterApplyStatus = output["ParameterApplyStatus"];
  }
  if (output["ParameterGroupName"] !== undefined) {
    contents.ParameterGroupName = output["ParameterGroupName"];
  }
  return contents;
};

const deserializeAws_queryClusterParameterGroupStatusList = (
  output: any,
  context: __SerdeContext
): Array<ClusterParameterGroupStatus> => {
  return (output || []).map((entry: any) =>
    deserializeAws_queryClusterParameterGroupStatus(entry, context)
  );
};

const deserializeAws_queryClusterParameterGroupsMessage = (
  output: any,
  context: __SerdeContext
): ClusterParameterGroupsMessage => {
  let contents: any = {
    __type: "ClusterParameterGroupsMessage",
    Marker: undefined,
    ParameterGroups: undefined
  };
  if (output["Marker"] !== undefined) {
    contents.Marker = output["Marker"];
  }
  if (output.ParameterGroups === "") {
    contents.ParameterGroups = [];
  }
  if (
    output["ParameterGroups"] !== undefined &&
    output["ParameterGroups"]["ClusterParameterGroup"] !== undefined
  ) {
    const wrappedItem =
      output["ParameterGroups"]["ClusterParameterGroup"] instanceof Array
        ? output["ParameterGroups"]["ClusterParameterGroup"]
        : [output["ParameterGroups"]["ClusterParameterGroup"]];
    contents.ParameterGroups = deserializeAws_queryParameterGroupList(
      wrappedItem,
      context
    );
  }
  return contents;
};

const deserializeAws_queryClusterParameterStatus = (
  output: any,
  context: __SerdeContext
): ClusterParameterStatus => {
  let contents: any = {
    __type: "ClusterParameterStatus",
    ParameterApplyErrorDescription: undefined,
    ParameterApplyStatus: undefined,
    ParameterName: undefined
  };
  if (output["ParameterApplyErrorDescription"] !== undefined) {
    contents.ParameterApplyErrorDescription =
      output["ParameterApplyErrorDescription"];
  }
  if (output["ParameterApplyStatus"] !== undefined) {
    contents.ParameterApplyStatus = output["ParameterApplyStatus"];
  }
  if (output["ParameterName"] !== undefined) {
    contents.ParameterName = output["ParameterName"];
  }
  return contents;
};

const deserializeAws_queryClusterParameterStatusList = (
  output: any,
  context: __SerdeContext
): Array<ClusterParameterStatus> => {
  return (output || []).map((entry: any) =>
    deserializeAws_queryClusterParameterStatus(entry, context)
  );
};

const deserializeAws_queryClusterSecurityGroup = (
  output: any,
  context: __SerdeContext
): ClusterSecurityGroup => {
  let contents: any = {
    __type: "ClusterSecurityGroup",
    ClusterSecurityGroupName: undefined,
    Description: undefined,
    EC2SecurityGroups: undefined,
    IPRanges: undefined,
    Tags: undefined
  };
  if (output["ClusterSecurityGroupName"] !== undefined) {
    contents.ClusterSecurityGroupName = output["ClusterSecurityGroupName"];
  }
  if (output["Description"] !== undefined) {
    contents.Description = output["Description"];
  }
  if (output.EC2SecurityGroups === "") {
    contents.EC2SecurityGroups = [];
  }
  if (
    output["EC2SecurityGroups"] !== undefined &&
    output["EC2SecurityGroups"]["EC2SecurityGroup"] !== undefined
  ) {
    const wrappedItem =
      output["EC2SecurityGroups"]["EC2SecurityGroup"] instanceof Array
        ? output["EC2SecurityGroups"]["EC2SecurityGroup"]
        : [output["EC2SecurityGroups"]["EC2SecurityGroup"]];
    contents.EC2SecurityGroups = deserializeAws_queryEC2SecurityGroupList(
      wrappedItem,
      context
    );
  }
  if (output.IPRanges === "") {
    contents.IPRanges = [];
  }
  if (
    output["IPRanges"] !== undefined &&
    output["IPRanges"]["IPRange"] !== undefined
  ) {
    const wrappedItem =
      output["IPRanges"]["IPRange"] instanceof Array
        ? output["IPRanges"]["IPRange"]
        : [output["IPRanges"]["IPRange"]];
    contents.IPRanges = deserializeAws_queryIPRangeList(wrappedItem, context);
  }
  if (output.Tags === "") {
    contents.Tags = [];
  }
  if (output["Tags"] !== undefined && output["Tags"]["Tag"] !== undefined) {
    const wrappedItem =
      output["Tags"]["Tag"] instanceof Array
        ? output["Tags"]["Tag"]
        : [output["Tags"]["Tag"]];
    contents.Tags = deserializeAws_queryTagList(wrappedItem, context);
  }
  return contents;
};

const deserializeAws_queryClusterSecurityGroupMembership = (
  output: any,
  context: __SerdeContext
): ClusterSecurityGroupMembership => {
  let contents: any = {
    __type: "ClusterSecurityGroupMembership",
    ClusterSecurityGroupName: undefined,
    Status: undefined
  };
  if (output["ClusterSecurityGroupName"] !== undefined) {
    contents.ClusterSecurityGroupName = output["ClusterSecurityGroupName"];
  }
  if (output["Status"] !== undefined) {
    contents.Status = output["Status"];
  }
  return contents;
};

const deserializeAws_queryClusterSecurityGroupMembershipList = (
  output: any,
  context: __SerdeContext
): Array<ClusterSecurityGroupMembership> => {
  return (output || []).map((entry: any) =>
    deserializeAws_queryClusterSecurityGroupMembership(entry, context)
  );
};

const deserializeAws_queryClusterSecurityGroupMessage = (
  output: any,
  context: __SerdeContext
): ClusterSecurityGroupMessage => {
  let contents: any = {
    __type: "ClusterSecurityGroupMessage",
    ClusterSecurityGroups: undefined,
    Marker: undefined
  };
  if (output.ClusterSecurityGroups === "") {
    contents.ClusterSecurityGroups = [];
  }
  if (
    output["ClusterSecurityGroups"] !== undefined &&
    output["ClusterSecurityGroups"]["ClusterSecurityGroup"] !== undefined
  ) {
    const wrappedItem =
      output["ClusterSecurityGroups"]["ClusterSecurityGroup"] instanceof Array
        ? output["ClusterSecurityGroups"]["ClusterSecurityGroup"]
        : [output["ClusterSecurityGroups"]["ClusterSecurityGroup"]];
    contents.ClusterSecurityGroups = deserializeAws_queryClusterSecurityGroups(
      wrappedItem,
      context
    );
  }
  if (output["Marker"] !== undefined) {
    contents.Marker = output["Marker"];
  }
  return contents;
};

const deserializeAws_queryClusterSecurityGroups = (
  output: any,
  context: __SerdeContext
): Array<ClusterSecurityGroup> => {
  return (output || []).map((entry: any) =>
    deserializeAws_queryClusterSecurityGroup(entry, context)
  );
};

const deserializeAws_queryClusterSnapshotCopyStatus = (
  output: any,
  context: __SerdeContext
): ClusterSnapshotCopyStatus => {
  let contents: any = {
    __type: "ClusterSnapshotCopyStatus",
    DestinationRegion: undefined,
    ManualSnapshotRetentionPeriod: undefined,
    RetentionPeriod: undefined,
    SnapshotCopyGrantName: undefined
  };
  if (output["DestinationRegion"] !== undefined) {
    contents.DestinationRegion = output["DestinationRegion"];
  }
  if (output["ManualSnapshotRetentionPeriod"] !== undefined) {
    contents.ManualSnapshotRetentionPeriod = parseInt(
      output["ManualSnapshotRetentionPeriod"]
    );
  }
  if (output["RetentionPeriod"] !== undefined) {
    contents.RetentionPeriod = parseInt(output["RetentionPeriod"]);
  }
  if (output["SnapshotCopyGrantName"] !== undefined) {
    contents.SnapshotCopyGrantName = output["SnapshotCopyGrantName"];
  }
  return contents;
};

const deserializeAws_queryClusterSubnetGroup = (
  output: any,
  context: __SerdeContext
): ClusterSubnetGroup => {
  let contents: any = {
    __type: "ClusterSubnetGroup",
    ClusterSubnetGroupName: undefined,
    Description: undefined,
    SubnetGroupStatus: undefined,
    Subnets: undefined,
    Tags: undefined,
    VpcId: undefined
  };
  if (output["ClusterSubnetGroupName"] !== undefined) {
    contents.ClusterSubnetGroupName = output["ClusterSubnetGroupName"];
  }
  if (output["Description"] !== undefined) {
    contents.Description = output["Description"];
  }
  if (output["SubnetGroupStatus"] !== undefined) {
    contents.SubnetGroupStatus = output["SubnetGroupStatus"];
  }
  if (output.Subnets === "") {
    contents.Subnets = [];
  }
  if (
    output["Subnets"] !== undefined &&
    output["Subnets"]["Subnet"] !== undefined
  ) {
    const wrappedItem =
      output["Subnets"]["Subnet"] instanceof Array
        ? output["Subnets"]["Subnet"]
        : [output["Subnets"]["Subnet"]];
    contents.Subnets = deserializeAws_querySubnetList(wrappedItem, context);
  }
  if (output.Tags === "") {
    contents.Tags = [];
  }
  if (output["Tags"] !== undefined && output["Tags"]["Tag"] !== undefined) {
    const wrappedItem =
      output["Tags"]["Tag"] instanceof Array
        ? output["Tags"]["Tag"]
        : [output["Tags"]["Tag"]];
    contents.Tags = deserializeAws_queryTagList(wrappedItem, context);
  }
  if (output["VpcId"] !== undefined) {
    contents.VpcId = output["VpcId"];
  }
  return contents;
};

const deserializeAws_queryClusterSubnetGroupMessage = (
  output: any,
  context: __SerdeContext
): ClusterSubnetGroupMessage => {
  let contents: any = {
    __type: "ClusterSubnetGroupMessage",
    ClusterSubnetGroups: undefined,
    Marker: undefined
  };
  if (output.ClusterSubnetGroups === "") {
    contents.ClusterSubnetGroups = [];
  }
  if (
    output["ClusterSubnetGroups"] !== undefined &&
    output["ClusterSubnetGroups"]["ClusterSubnetGroup"] !== undefined
  ) {
    const wrappedItem =
      output["ClusterSubnetGroups"]["ClusterSubnetGroup"] instanceof Array
        ? output["ClusterSubnetGroups"]["ClusterSubnetGroup"]
        : [output["ClusterSubnetGroups"]["ClusterSubnetGroup"]];
    contents.ClusterSubnetGroups = deserializeAws_queryClusterSubnetGroups(
      wrappedItem,
      context
    );
  }
  if (output["Marker"] !== undefined) {
    contents.Marker = output["Marker"];
  }
  return contents;
};

const deserializeAws_queryClusterSubnetGroups = (
  output: any,
  context: __SerdeContext
): Array<ClusterSubnetGroup> => {
  return (output || []).map((entry: any) =>
    deserializeAws_queryClusterSubnetGroup(entry, context)
  );
};

const deserializeAws_queryClusterVersion = (
  output: any,
  context: __SerdeContext
): ClusterVersion => {
  let contents: any = {
    __type: "ClusterVersion",
    ClusterParameterGroupFamily: undefined,
    ClusterVersion: undefined,
    Description: undefined
  };
  if (output["ClusterParameterGroupFamily"] !== undefined) {
    contents.ClusterParameterGroupFamily =
      output["ClusterParameterGroupFamily"];
  }
  if (output["ClusterVersion"] !== undefined) {
    contents.ClusterVersion = output["ClusterVersion"];
  }
  if (output["Description"] !== undefined) {
    contents.Description = output["Description"];
  }
  return contents;
};

const deserializeAws_queryClusterVersionList = (
  output: any,
  context: __SerdeContext
): Array<ClusterVersion> => {
  return (output || []).map((entry: any) =>
    deserializeAws_queryClusterVersion(entry, context)
  );
};

const deserializeAws_queryClusterVersionsMessage = (
  output: any,
  context: __SerdeContext
): ClusterVersionsMessage => {
  let contents: any = {
    __type: "ClusterVersionsMessage",
    ClusterVersions: undefined,
    Marker: undefined
  };
  if (output.ClusterVersions === "") {
    contents.ClusterVersions = [];
  }
  if (
    output["ClusterVersions"] !== undefined &&
    output["ClusterVersions"]["ClusterVersion"] !== undefined
  ) {
    const wrappedItem =
      output["ClusterVersions"]["ClusterVersion"] instanceof Array
        ? output["ClusterVersions"]["ClusterVersion"]
        : [output["ClusterVersions"]["ClusterVersion"]];
    contents.ClusterVersions = deserializeAws_queryClusterVersionList(
      wrappedItem,
      context
    );
  }
  if (output["Marker"] !== undefined) {
    contents.Marker = output["Marker"];
  }
  return contents;
};

const deserializeAws_queryClustersMessage = (
  output: any,
  context: __SerdeContext
): ClustersMessage => {
  let contents: any = {
    __type: "ClustersMessage",
    Clusters: undefined,
    Marker: undefined
  };
  if (output.Clusters === "") {
    contents.Clusters = [];
  }
  if (
    output["Clusters"] !== undefined &&
    output["Clusters"]["Cluster"] !== undefined
  ) {
    const wrappedItem =
      output["Clusters"]["Cluster"] instanceof Array
        ? output["Clusters"]["Cluster"]
        : [output["Clusters"]["Cluster"]];
    contents.Clusters = deserializeAws_queryClusterList(wrappedItem, context);
  }
  if (output["Marker"] !== undefined) {
    contents.Marker = output["Marker"];
  }
  return contents;
};

const deserializeAws_queryCopyClusterSnapshotResult = (
  output: any,
  context: __SerdeContext
): CopyClusterSnapshotResult => {
  let contents: any = {
    __type: "CopyClusterSnapshotResult",
    Snapshot: undefined
  };
  if (output["Snapshot"] !== undefined) {
    contents.Snapshot = deserializeAws_querySnapshot(
      output["Snapshot"],
      context
    );
  }
  return contents;
};

const deserializeAws_queryCreateClusterParameterGroupResult = (
  output: any,
  context: __SerdeContext
): CreateClusterParameterGroupResult => {
  let contents: any = {
    __type: "CreateClusterParameterGroupResult",
    ClusterParameterGroup: undefined
  };
  if (output["ClusterParameterGroup"] !== undefined) {
    contents.ClusterParameterGroup = deserializeAws_queryClusterParameterGroup(
      output["ClusterParameterGroup"],
      context
    );
  }
  return contents;
};

const deserializeAws_queryCreateClusterResult = (
  output: any,
  context: __SerdeContext
): CreateClusterResult => {
  let contents: any = {
    __type: "CreateClusterResult",
    Cluster: undefined
  };
  if (output["Cluster"] !== undefined) {
    contents.Cluster = deserializeAws_queryCluster(output["Cluster"], context);
  }
  return contents;
};

const deserializeAws_queryCreateClusterSecurityGroupResult = (
  output: any,
  context: __SerdeContext
): CreateClusterSecurityGroupResult => {
  let contents: any = {
    __type: "CreateClusterSecurityGroupResult",
    ClusterSecurityGroup: undefined
  };
  if (output["ClusterSecurityGroup"] !== undefined) {
    contents.ClusterSecurityGroup = deserializeAws_queryClusterSecurityGroup(
      output["ClusterSecurityGroup"],
      context
    );
  }
  return contents;
};

const deserializeAws_queryCreateClusterSnapshotResult = (
  output: any,
  context: __SerdeContext
): CreateClusterSnapshotResult => {
  let contents: any = {
    __type: "CreateClusterSnapshotResult",
    Snapshot: undefined
  };
  if (output["Snapshot"] !== undefined) {
    contents.Snapshot = deserializeAws_querySnapshot(
      output["Snapshot"],
      context
    );
  }
  return contents;
};

const deserializeAws_queryCreateClusterSubnetGroupResult = (
  output: any,
  context: __SerdeContext
): CreateClusterSubnetGroupResult => {
  let contents: any = {
    __type: "CreateClusterSubnetGroupResult",
    ClusterSubnetGroup: undefined
  };
  if (output["ClusterSubnetGroup"] !== undefined) {
    contents.ClusterSubnetGroup = deserializeAws_queryClusterSubnetGroup(
      output["ClusterSubnetGroup"],
      context
    );
  }
  return contents;
};

const deserializeAws_queryCreateEventSubscriptionResult = (
  output: any,
  context: __SerdeContext
): CreateEventSubscriptionResult => {
  let contents: any = {
    __type: "CreateEventSubscriptionResult",
    EventSubscription: undefined
  };
  if (output["EventSubscription"] !== undefined) {
    contents.EventSubscription = deserializeAws_queryEventSubscription(
      output["EventSubscription"],
      context
    );
  }
  return contents;
};

const deserializeAws_queryCreateHsmClientCertificateResult = (
  output: any,
  context: __SerdeContext
): CreateHsmClientCertificateResult => {
  let contents: any = {
    __type: "CreateHsmClientCertificateResult",
    HsmClientCertificate: undefined
  };
  if (output["HsmClientCertificate"] !== undefined) {
    contents.HsmClientCertificate = deserializeAws_queryHsmClientCertificate(
      output["HsmClientCertificate"],
      context
    );
  }
  return contents;
};

const deserializeAws_queryCreateHsmConfigurationResult = (
  output: any,
  context: __SerdeContext
): CreateHsmConfigurationResult => {
  let contents: any = {
    __type: "CreateHsmConfigurationResult",
    HsmConfiguration: undefined
  };
  if (output["HsmConfiguration"] !== undefined) {
    contents.HsmConfiguration = deserializeAws_queryHsmConfiguration(
      output["HsmConfiguration"],
      context
    );
  }
  return contents;
};

const deserializeAws_queryCreateSnapshotCopyGrantResult = (
  output: any,
  context: __SerdeContext
): CreateSnapshotCopyGrantResult => {
  let contents: any = {
    __type: "CreateSnapshotCopyGrantResult",
    SnapshotCopyGrant: undefined
  };
  if (output["SnapshotCopyGrant"] !== undefined) {
    contents.SnapshotCopyGrant = deserializeAws_querySnapshotCopyGrant(
      output["SnapshotCopyGrant"],
      context
    );
  }
  return contents;
};

const deserializeAws_queryCustomerStorageMessage = (
  output: any,
  context: __SerdeContext
): CustomerStorageMessage => {
  let contents: any = {
    __type: "CustomerStorageMessage",
    TotalBackupSizeInMegaBytes: undefined,
    TotalProvisionedStorageInMegaBytes: undefined
  };
  if (output["TotalBackupSizeInMegaBytes"] !== undefined) {
    contents.TotalBackupSizeInMegaBytes = parseFloat(
      output["TotalBackupSizeInMegaBytes"]
    );
  }
  if (output["TotalProvisionedStorageInMegaBytes"] !== undefined) {
    contents.TotalProvisionedStorageInMegaBytes = parseFloat(
      output["TotalProvisionedStorageInMegaBytes"]
    );
  }
  return contents;
};

const deserializeAws_queryDataTransferProgress = (
  output: any,
  context: __SerdeContext
): DataTransferProgress => {
  let contents: any = {
    __type: "DataTransferProgress",
    CurrentRateInMegaBytesPerSecond: undefined,
    DataTransferredInMegaBytes: undefined,
    ElapsedTimeInSeconds: undefined,
    EstimatedTimeToCompletionInSeconds: undefined,
    Status: undefined,
    TotalDataInMegaBytes: undefined
  };
  if (output["CurrentRateInMegaBytesPerSecond"] !== undefined) {
    contents.CurrentRateInMegaBytesPerSecond = parseFloat(
      output["CurrentRateInMegaBytesPerSecond"]
    );
  }
  if (output["DataTransferredInMegaBytes"] !== undefined) {
    contents.DataTransferredInMegaBytes = parseInt(
      output["DataTransferredInMegaBytes"]
    );
  }
  if (output["ElapsedTimeInSeconds"] !== undefined) {
    contents.ElapsedTimeInSeconds = parseInt(output["ElapsedTimeInSeconds"]);
  }
  if (output["EstimatedTimeToCompletionInSeconds"] !== undefined) {
    contents.EstimatedTimeToCompletionInSeconds = parseInt(
      output["EstimatedTimeToCompletionInSeconds"]
    );
  }
  if (output["Status"] !== undefined) {
    contents.Status = output["Status"];
  }
  if (output["TotalDataInMegaBytes"] !== undefined) {
    contents.TotalDataInMegaBytes = parseInt(output["TotalDataInMegaBytes"]);
  }
  return contents;
};

const deserializeAws_queryDefaultClusterParameters = (
  output: any,
  context: __SerdeContext
): DefaultClusterParameters => {
  let contents: any = {
    __type: "DefaultClusterParameters",
    Marker: undefined,
    ParameterGroupFamily: undefined,
    Parameters: undefined
  };
  if (output["Marker"] !== undefined) {
    contents.Marker = output["Marker"];
  }
  if (output["ParameterGroupFamily"] !== undefined) {
    contents.ParameterGroupFamily = output["ParameterGroupFamily"];
  }
  if (output.Parameters === "") {
    contents.Parameters = [];
  }
  if (
    output["Parameters"] !== undefined &&
    output["Parameters"]["Parameter"] !== undefined
  ) {
    const wrappedItem =
      output["Parameters"]["Parameter"] instanceof Array
        ? output["Parameters"]["Parameter"]
        : [output["Parameters"]["Parameter"]];
    contents.Parameters = deserializeAws_queryParametersList(
      wrappedItem,
      context
    );
  }
  return contents;
};

const deserializeAws_queryDeferredMaintenanceWindow = (
  output: any,
  context: __SerdeContext
): DeferredMaintenanceWindow => {
  let contents: any = {
    __type: "DeferredMaintenanceWindow",
    DeferMaintenanceEndTime: undefined,
    DeferMaintenanceIdentifier: undefined,
    DeferMaintenanceStartTime: undefined
  };
  if (output["DeferMaintenanceEndTime"] !== undefined) {
    contents.DeferMaintenanceEndTime = new Date(
      output["DeferMaintenanceEndTime"]
    );
  }
  if (output["DeferMaintenanceIdentifier"] !== undefined) {
    contents.DeferMaintenanceIdentifier = output["DeferMaintenanceIdentifier"];
  }
  if (output["DeferMaintenanceStartTime"] !== undefined) {
    contents.DeferMaintenanceStartTime = new Date(
      output["DeferMaintenanceStartTime"]
    );
  }
  return contents;
};

const deserializeAws_queryDeferredMaintenanceWindowsList = (
  output: any,
  context: __SerdeContext
): Array<DeferredMaintenanceWindow> => {
  return (output || []).map((entry: any) =>
    deserializeAws_queryDeferredMaintenanceWindow(entry, context)
  );
};

const deserializeAws_queryDeleteClusterResult = (
  output: any,
  context: __SerdeContext
): DeleteClusterResult => {
  let contents: any = {
    __type: "DeleteClusterResult",
    Cluster: undefined
  };
  if (output["Cluster"] !== undefined) {
    contents.Cluster = deserializeAws_queryCluster(output["Cluster"], context);
  }
  return contents;
};

const deserializeAws_queryDeleteClusterSnapshotResult = (
  output: any,
  context: __SerdeContext
): DeleteClusterSnapshotResult => {
  let contents: any = {
    __type: "DeleteClusterSnapshotResult",
    Snapshot: undefined
  };
  if (output["Snapshot"] !== undefined) {
    contents.Snapshot = deserializeAws_querySnapshot(
      output["Snapshot"],
      context
    );
  }
  return contents;
};

const deserializeAws_queryDescribeDefaultClusterParametersResult = (
  output: any,
  context: __SerdeContext
): DescribeDefaultClusterParametersResult => {
  let contents: any = {
    __type: "DescribeDefaultClusterParametersResult",
    DefaultClusterParameters: undefined
  };
  if (output["DefaultClusterParameters"] !== undefined) {
    contents.DefaultClusterParameters = deserializeAws_queryDefaultClusterParameters(
      output["DefaultClusterParameters"],
      context
    );
  }
  return contents;
};

const deserializeAws_queryDescribeSnapshotSchedulesOutputMessage = (
  output: any,
  context: __SerdeContext
): DescribeSnapshotSchedulesOutputMessage => {
  let contents: any = {
    __type: "DescribeSnapshotSchedulesOutputMessage",
    Marker: undefined,
    SnapshotSchedules: undefined
  };
  if (output["Marker"] !== undefined) {
    contents.Marker = output["Marker"];
  }
  if (output.SnapshotSchedules === "") {
    contents.SnapshotSchedules = [];
  }
  if (
    output["SnapshotSchedules"] !== undefined &&
    output["SnapshotSchedules"]["SnapshotSchedule"] !== undefined
  ) {
    const wrappedItem =
      output["SnapshotSchedules"]["SnapshotSchedule"] instanceof Array
        ? output["SnapshotSchedules"]["SnapshotSchedule"]
        : [output["SnapshotSchedules"]["SnapshotSchedule"]];
    contents.SnapshotSchedules = deserializeAws_querySnapshotScheduleList(
      wrappedItem,
      context
    );
  }
  return contents;
};

const deserializeAws_queryDisableSnapshotCopyResult = (
  output: any,
  context: __SerdeContext
): DisableSnapshotCopyResult => {
  let contents: any = {
    __type: "DisableSnapshotCopyResult",
    Cluster: undefined
  };
  if (output["Cluster"] !== undefined) {
    contents.Cluster = deserializeAws_queryCluster(output["Cluster"], context);
  }
  return contents;
};

const deserializeAws_queryEC2SecurityGroup = (
  output: any,
  context: __SerdeContext
): EC2SecurityGroup => {
  let contents: any = {
    __type: "EC2SecurityGroup",
    EC2SecurityGroupName: undefined,
    EC2SecurityGroupOwnerId: undefined,
    Status: undefined,
    Tags: undefined
  };
  if (output["EC2SecurityGroupName"] !== undefined) {
    contents.EC2SecurityGroupName = output["EC2SecurityGroupName"];
  }
  if (output["EC2SecurityGroupOwnerId"] !== undefined) {
    contents.EC2SecurityGroupOwnerId = output["EC2SecurityGroupOwnerId"];
  }
  if (output["Status"] !== undefined) {
    contents.Status = output["Status"];
  }
  if (output.Tags === "") {
    contents.Tags = [];
  }
  if (output["Tags"] !== undefined && output["Tags"]["Tag"] !== undefined) {
    const wrappedItem =
      output["Tags"]["Tag"] instanceof Array
        ? output["Tags"]["Tag"]
        : [output["Tags"]["Tag"]];
    contents.Tags = deserializeAws_queryTagList(wrappedItem, context);
  }
  return contents;
};

const deserializeAws_queryEC2SecurityGroupList = (
  output: any,
  context: __SerdeContext
): Array<EC2SecurityGroup> => {
  return (output || []).map((entry: any) =>
    deserializeAws_queryEC2SecurityGroup(entry, context)
  );
};

const deserializeAws_queryElasticIpStatus = (
  output: any,
  context: __SerdeContext
): ElasticIpStatus => {
  let contents: any = {
    __type: "ElasticIpStatus",
    ElasticIp: undefined,
    Status: undefined
  };
  if (output["ElasticIp"] !== undefined) {
    contents.ElasticIp = output["ElasticIp"];
  }
  if (output["Status"] !== undefined) {
    contents.Status = output["Status"];
  }
  return contents;
};

const deserializeAws_queryEligibleTracksToUpdateList = (
  output: any,
  context: __SerdeContext
): Array<UpdateTarget> => {
  return (output || []).map((entry: any) =>
    deserializeAws_queryUpdateTarget(entry, context)
  );
};

const deserializeAws_queryEnableSnapshotCopyResult = (
  output: any,
  context: __SerdeContext
): EnableSnapshotCopyResult => {
  let contents: any = {
    __type: "EnableSnapshotCopyResult",
    Cluster: undefined
  };
  if (output["Cluster"] !== undefined) {
    contents.Cluster = deserializeAws_queryCluster(output["Cluster"], context);
  }
  return contents;
};

const deserializeAws_queryEndpoint = (
  output: any,
  context: __SerdeContext
): Endpoint => {
  let contents: any = {
    __type: "Endpoint",
    Address: undefined,
    Port: undefined
  };
  if (output["Address"] !== undefined) {
    contents.Address = output["Address"];
  }
  if (output["Port"] !== undefined) {
    contents.Port = parseInt(output["Port"]);
  }
  return contents;
};

const deserializeAws_queryEvent = (
  output: any,
  context: __SerdeContext
): Event => {
  let contents: any = {
    __type: "Event",
    Date: undefined,
    EventCategories: undefined,
    EventId: undefined,
    Message: undefined,
    Severity: undefined,
    SourceIdentifier: undefined,
    SourceType: undefined
  };
  if (output["Date"] !== undefined) {
    contents.Date = new Date(output["Date"]);
  }
  if (output.EventCategories === "") {
    contents.EventCategories = [];
  }
  if (
    output["EventCategories"] !== undefined &&
    output["EventCategories"]["EventCategory"] !== undefined
  ) {
    const wrappedItem =
      output["EventCategories"]["EventCategory"] instanceof Array
        ? output["EventCategories"]["EventCategory"]
        : [output["EventCategories"]["EventCategory"]];
    contents.EventCategories = deserializeAws_queryEventCategoriesList(
      wrappedItem,
      context
    );
  }
  if (output["EventId"] !== undefined) {
    contents.EventId = output["EventId"];
  }
  if (output["Message"] !== undefined) {
    contents.Message = output["Message"];
  }
  if (output["Severity"] !== undefined) {
    contents.Severity = output["Severity"];
  }
  if (output["SourceIdentifier"] !== undefined) {
    contents.SourceIdentifier = output["SourceIdentifier"];
  }
  if (output["SourceType"] !== undefined) {
    contents.SourceType = output["SourceType"];
  }
  return contents;
};

const deserializeAws_queryEventCategoriesList = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_queryEventCategoriesMap = (
  output: any,
  context: __SerdeContext
): EventCategoriesMap => {
  let contents: any = {
    __type: "EventCategoriesMap",
    Events: undefined,
    SourceType: undefined
  };
  if (output.Events === "") {
    contents.Events = [];
  }
  if (
    output["Events"] !== undefined &&
    output["Events"]["EventInfoMap"] !== undefined
  ) {
    const wrappedItem =
      output["Events"]["EventInfoMap"] instanceof Array
        ? output["Events"]["EventInfoMap"]
        : [output["Events"]["EventInfoMap"]];
    contents.Events = deserializeAws_queryEventInfoMapList(
      wrappedItem,
      context
    );
  }
  if (output["SourceType"] !== undefined) {
    contents.SourceType = output["SourceType"];
  }
  return contents;
};

const deserializeAws_queryEventCategoriesMapList = (
  output: any,
  context: __SerdeContext
): Array<EventCategoriesMap> => {
  return (output || []).map((entry: any) =>
    deserializeAws_queryEventCategoriesMap(entry, context)
  );
};

const deserializeAws_queryEventCategoriesMessage = (
  output: any,
  context: __SerdeContext
): EventCategoriesMessage => {
  let contents: any = {
    __type: "EventCategoriesMessage",
    EventCategoriesMapList: undefined
  };
  if (output.EventCategoriesMapList === "") {
    contents.EventCategoriesMapList = [];
  }
  if (
    output["EventCategoriesMapList"] !== undefined &&
    output["EventCategoriesMapList"]["EventCategoriesMap"] !== undefined
  ) {
    const wrappedItem =
      output["EventCategoriesMapList"]["EventCategoriesMap"] instanceof Array
        ? output["EventCategoriesMapList"]["EventCategoriesMap"]
        : [output["EventCategoriesMapList"]["EventCategoriesMap"]];
    contents.EventCategoriesMapList = deserializeAws_queryEventCategoriesMapList(
      wrappedItem,
      context
    );
  }
  return contents;
};

const deserializeAws_queryEventInfoMap = (
  output: any,
  context: __SerdeContext
): EventInfoMap => {
  let contents: any = {
    __type: "EventInfoMap",
    EventCategories: undefined,
    EventDescription: undefined,
    EventId: undefined,
    Severity: undefined
  };
  if (output.EventCategories === "") {
    contents.EventCategories = [];
  }
  if (
    output["EventCategories"] !== undefined &&
    output["EventCategories"]["EventCategory"] !== undefined
  ) {
    const wrappedItem =
      output["EventCategories"]["EventCategory"] instanceof Array
        ? output["EventCategories"]["EventCategory"]
        : [output["EventCategories"]["EventCategory"]];
    contents.EventCategories = deserializeAws_queryEventCategoriesList(
      wrappedItem,
      context
    );
  }
  if (output["EventDescription"] !== undefined) {
    contents.EventDescription = output["EventDescription"];
  }
  if (output["EventId"] !== undefined) {
    contents.EventId = output["EventId"];
  }
  if (output["Severity"] !== undefined) {
    contents.Severity = output["Severity"];
  }
  return contents;
};

const deserializeAws_queryEventInfoMapList = (
  output: any,
  context: __SerdeContext
): Array<EventInfoMap> => {
  return (output || []).map((entry: any) =>
    deserializeAws_queryEventInfoMap(entry, context)
  );
};

const deserializeAws_queryEventList = (
  output: any,
  context: __SerdeContext
): Array<Event> => {
  return (output || []).map((entry: any) =>
    deserializeAws_queryEvent(entry, context)
  );
};

const deserializeAws_queryEventSubscription = (
  output: any,
  context: __SerdeContext
): EventSubscription => {
  let contents: any = {
    __type: "EventSubscription",
    CustSubscriptionId: undefined,
    CustomerAwsId: undefined,
    Enabled: undefined,
    EventCategoriesList: undefined,
    Severity: undefined,
    SnsTopicArn: undefined,
    SourceIdsList: undefined,
    SourceType: undefined,
    Status: undefined,
    SubscriptionCreationTime: undefined,
    Tags: undefined
  };
  if (output["CustSubscriptionId"] !== undefined) {
    contents.CustSubscriptionId = output["CustSubscriptionId"];
  }
  if (output["CustomerAwsId"] !== undefined) {
    contents.CustomerAwsId = output["CustomerAwsId"];
  }
  if (output["Enabled"] !== undefined) {
    contents.Enabled = output["Enabled"] == "true";
  }
  if (output.EventCategoriesList === "") {
    contents.EventCategoriesList = [];
  }
  if (
    output["EventCategoriesList"] !== undefined &&
    output["EventCategoriesList"]["EventCategory"] !== undefined
  ) {
    const wrappedItem =
      output["EventCategoriesList"]["EventCategory"] instanceof Array
        ? output["EventCategoriesList"]["EventCategory"]
        : [output["EventCategoriesList"]["EventCategory"]];
    contents.EventCategoriesList = deserializeAws_queryEventCategoriesList(
      wrappedItem,
      context
    );
  }
  if (output["Severity"] !== undefined) {
    contents.Severity = output["Severity"];
  }
  if (output["SnsTopicArn"] !== undefined) {
    contents.SnsTopicArn = output["SnsTopicArn"];
  }
  if (output.SourceIdsList === "") {
    contents.SourceIdsList = [];
  }
  if (
    output["SourceIdsList"] !== undefined &&
    output["SourceIdsList"]["SourceId"] !== undefined
  ) {
    const wrappedItem =
      output["SourceIdsList"]["SourceId"] instanceof Array
        ? output["SourceIdsList"]["SourceId"]
        : [output["SourceIdsList"]["SourceId"]];
    contents.SourceIdsList = deserializeAws_querySourceIdsList(
      wrappedItem,
      context
    );
  }
  if (output["SourceType"] !== undefined) {
    contents.SourceType = output["SourceType"];
  }
  if (output["Status"] !== undefined) {
    contents.Status = output["Status"];
  }
  if (output["SubscriptionCreationTime"] !== undefined) {
    contents.SubscriptionCreationTime = new Date(
      output["SubscriptionCreationTime"]
    );
  }
  if (output.Tags === "") {
    contents.Tags = [];
  }
  if (output["Tags"] !== undefined && output["Tags"]["Tag"] !== undefined) {
    const wrappedItem =
      output["Tags"]["Tag"] instanceof Array
        ? output["Tags"]["Tag"]
        : [output["Tags"]["Tag"]];
    contents.Tags = deserializeAws_queryTagList(wrappedItem, context);
  }
  return contents;
};

const deserializeAws_queryEventSubscriptionsList = (
  output: any,
  context: __SerdeContext
): Array<EventSubscription> => {
  return (output || []).map((entry: any) =>
    deserializeAws_queryEventSubscription(entry, context)
  );
};

const deserializeAws_queryEventSubscriptionsMessage = (
  output: any,
  context: __SerdeContext
): EventSubscriptionsMessage => {
  let contents: any = {
    __type: "EventSubscriptionsMessage",
    EventSubscriptionsList: undefined,
    Marker: undefined
  };
  if (output.EventSubscriptionsList === "") {
    contents.EventSubscriptionsList = [];
  }
  if (
    output["EventSubscriptionsList"] !== undefined &&
    output["EventSubscriptionsList"]["EventSubscription"] !== undefined
  ) {
    const wrappedItem =
      output["EventSubscriptionsList"]["EventSubscription"] instanceof Array
        ? output["EventSubscriptionsList"]["EventSubscription"]
        : [output["EventSubscriptionsList"]["EventSubscription"]];
    contents.EventSubscriptionsList = deserializeAws_queryEventSubscriptionsList(
      wrappedItem,
      context
    );
  }
  if (output["Marker"] !== undefined) {
    contents.Marker = output["Marker"];
  }
  return contents;
};

const deserializeAws_queryEventsMessage = (
  output: any,
  context: __SerdeContext
): EventsMessage => {
  let contents: any = {
    __type: "EventsMessage",
    Events: undefined,
    Marker: undefined
  };
  if (output.Events === "") {
    contents.Events = [];
  }
  if (
    output["Events"] !== undefined &&
    output["Events"]["Event"] !== undefined
  ) {
    const wrappedItem =
      output["Events"]["Event"] instanceof Array
        ? output["Events"]["Event"]
        : [output["Events"]["Event"]];
    contents.Events = deserializeAws_queryEventList(wrappedItem, context);
  }
  if (output["Marker"] !== undefined) {
    contents.Marker = output["Marker"];
  }
  return contents;
};

const deserializeAws_queryGetReservedNodeExchangeOfferingsOutputMessage = (
  output: any,
  context: __SerdeContext
): GetReservedNodeExchangeOfferingsOutputMessage => {
  let contents: any = {
    __type: "GetReservedNodeExchangeOfferingsOutputMessage",
    Marker: undefined,
    ReservedNodeOfferings: undefined
  };
  if (output["Marker"] !== undefined) {
    contents.Marker = output["Marker"];
  }
  if (output.ReservedNodeOfferings === "") {
    contents.ReservedNodeOfferings = [];
  }
  if (
    output["ReservedNodeOfferings"] !== undefined &&
    output["ReservedNodeOfferings"]["ReservedNodeOffering"] !== undefined
  ) {
    const wrappedItem =
      output["ReservedNodeOfferings"]["ReservedNodeOffering"] instanceof Array
        ? output["ReservedNodeOfferings"]["ReservedNodeOffering"]
        : [output["ReservedNodeOfferings"]["ReservedNodeOffering"]];
    contents.ReservedNodeOfferings = deserializeAws_queryReservedNodeOfferingList(
      wrappedItem,
      context
    );
  }
  return contents;
};

const deserializeAws_queryHsmClientCertificate = (
  output: any,
  context: __SerdeContext
): HsmClientCertificate => {
  let contents: any = {
    __type: "HsmClientCertificate",
    HsmClientCertificateIdentifier: undefined,
    HsmClientCertificatePublicKey: undefined,
    Tags: undefined
  };
  if (output["HsmClientCertificateIdentifier"] !== undefined) {
    contents.HsmClientCertificateIdentifier =
      output["HsmClientCertificateIdentifier"];
  }
  if (output["HsmClientCertificatePublicKey"] !== undefined) {
    contents.HsmClientCertificatePublicKey =
      output["HsmClientCertificatePublicKey"];
  }
  if (output.Tags === "") {
    contents.Tags = [];
  }
  if (output["Tags"] !== undefined && output["Tags"]["Tag"] !== undefined) {
    const wrappedItem =
      output["Tags"]["Tag"] instanceof Array
        ? output["Tags"]["Tag"]
        : [output["Tags"]["Tag"]];
    contents.Tags = deserializeAws_queryTagList(wrappedItem, context);
  }
  return contents;
};

const deserializeAws_queryHsmClientCertificateList = (
  output: any,
  context: __SerdeContext
): Array<HsmClientCertificate> => {
  return (output || []).map((entry: any) =>
    deserializeAws_queryHsmClientCertificate(entry, context)
  );
};

const deserializeAws_queryHsmClientCertificateMessage = (
  output: any,
  context: __SerdeContext
): HsmClientCertificateMessage => {
  let contents: any = {
    __type: "HsmClientCertificateMessage",
    HsmClientCertificates: undefined,
    Marker: undefined
  };
  if (output.HsmClientCertificates === "") {
    contents.HsmClientCertificates = [];
  }
  if (
    output["HsmClientCertificates"] !== undefined &&
    output["HsmClientCertificates"]["HsmClientCertificate"] !== undefined
  ) {
    const wrappedItem =
      output["HsmClientCertificates"]["HsmClientCertificate"] instanceof Array
        ? output["HsmClientCertificates"]["HsmClientCertificate"]
        : [output["HsmClientCertificates"]["HsmClientCertificate"]];
    contents.HsmClientCertificates = deserializeAws_queryHsmClientCertificateList(
      wrappedItem,
      context
    );
  }
  if (output["Marker"] !== undefined) {
    contents.Marker = output["Marker"];
  }
  return contents;
};

const deserializeAws_queryHsmConfiguration = (
  output: any,
  context: __SerdeContext
): HsmConfiguration => {
  let contents: any = {
    __type: "HsmConfiguration",
    Description: undefined,
    HsmConfigurationIdentifier: undefined,
    HsmIpAddress: undefined,
    HsmPartitionName: undefined,
    Tags: undefined
  };
  if (output["Description"] !== undefined) {
    contents.Description = output["Description"];
  }
  if (output["HsmConfigurationIdentifier"] !== undefined) {
    contents.HsmConfigurationIdentifier = output["HsmConfigurationIdentifier"];
  }
  if (output["HsmIpAddress"] !== undefined) {
    contents.HsmIpAddress = output["HsmIpAddress"];
  }
  if (output["HsmPartitionName"] !== undefined) {
    contents.HsmPartitionName = output["HsmPartitionName"];
  }
  if (output.Tags === "") {
    contents.Tags = [];
  }
  if (output["Tags"] !== undefined && output["Tags"]["Tag"] !== undefined) {
    const wrappedItem =
      output["Tags"]["Tag"] instanceof Array
        ? output["Tags"]["Tag"]
        : [output["Tags"]["Tag"]];
    contents.Tags = deserializeAws_queryTagList(wrappedItem, context);
  }
  return contents;
};

const deserializeAws_queryHsmConfigurationList = (
  output: any,
  context: __SerdeContext
): Array<HsmConfiguration> => {
  return (output || []).map((entry: any) =>
    deserializeAws_queryHsmConfiguration(entry, context)
  );
};

const deserializeAws_queryHsmConfigurationMessage = (
  output: any,
  context: __SerdeContext
): HsmConfigurationMessage => {
  let contents: any = {
    __type: "HsmConfigurationMessage",
    HsmConfigurations: undefined,
    Marker: undefined
  };
  if (output.HsmConfigurations === "") {
    contents.HsmConfigurations = [];
  }
  if (
    output["HsmConfigurations"] !== undefined &&
    output["HsmConfigurations"]["HsmConfiguration"] !== undefined
  ) {
    const wrappedItem =
      output["HsmConfigurations"]["HsmConfiguration"] instanceof Array
        ? output["HsmConfigurations"]["HsmConfiguration"]
        : [output["HsmConfigurations"]["HsmConfiguration"]];
    contents.HsmConfigurations = deserializeAws_queryHsmConfigurationList(
      wrappedItem,
      context
    );
  }
  if (output["Marker"] !== undefined) {
    contents.Marker = output["Marker"];
  }
  return contents;
};

const deserializeAws_queryHsmStatus = (
  output: any,
  context: __SerdeContext
): HsmStatus => {
  let contents: any = {
    __type: "HsmStatus",
    HsmClientCertificateIdentifier: undefined,
    HsmConfigurationIdentifier: undefined,
    Status: undefined
  };
  if (output["HsmClientCertificateIdentifier"] !== undefined) {
    contents.HsmClientCertificateIdentifier =
      output["HsmClientCertificateIdentifier"];
  }
  if (output["HsmConfigurationIdentifier"] !== undefined) {
    contents.HsmConfigurationIdentifier = output["HsmConfigurationIdentifier"];
  }
  if (output["Status"] !== undefined) {
    contents.Status = output["Status"];
  }
  return contents;
};

const deserializeAws_queryIPRange = (
  output: any,
  context: __SerdeContext
): IPRange => {
  let contents: any = {
    __type: "IPRange",
    CIDRIP: undefined,
    Status: undefined,
    Tags: undefined
  };
  if (output["CIDRIP"] !== undefined) {
    contents.CIDRIP = output["CIDRIP"];
  }
  if (output["Status"] !== undefined) {
    contents.Status = output["Status"];
  }
  if (output.Tags === "") {
    contents.Tags = [];
  }
  if (output["Tags"] !== undefined && output["Tags"]["Tag"] !== undefined) {
    const wrappedItem =
      output["Tags"]["Tag"] instanceof Array
        ? output["Tags"]["Tag"]
        : [output["Tags"]["Tag"]];
    contents.Tags = deserializeAws_queryTagList(wrappedItem, context);
  }
  return contents;
};

const deserializeAws_queryIPRangeList = (
  output: any,
  context: __SerdeContext
): Array<IPRange> => {
  return (output || []).map((entry: any) =>
    deserializeAws_queryIPRange(entry, context)
  );
};

const deserializeAws_queryImportTablesCompleted = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_queryImportTablesInProgress = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_queryImportTablesNotStarted = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_queryLoggingStatus = (
  output: any,
  context: __SerdeContext
): LoggingStatus => {
  let contents: any = {
    __type: "LoggingStatus",
    BucketName: undefined,
    LastFailureMessage: undefined,
    LastFailureTime: undefined,
    LastSuccessfulDeliveryTime: undefined,
    LoggingEnabled: undefined,
    S3KeyPrefix: undefined
  };
  if (output["BucketName"] !== undefined) {
    contents.BucketName = output["BucketName"];
  }
  if (output["LastFailureMessage"] !== undefined) {
    contents.LastFailureMessage = output["LastFailureMessage"];
  }
  if (output["LastFailureTime"] !== undefined) {
    contents.LastFailureTime = new Date(output["LastFailureTime"]);
  }
  if (output["LastSuccessfulDeliveryTime"] !== undefined) {
    contents.LastSuccessfulDeliveryTime = new Date(
      output["LastSuccessfulDeliveryTime"]
    );
  }
  if (output["LoggingEnabled"] !== undefined) {
    contents.LoggingEnabled = output["LoggingEnabled"] == "true";
  }
  if (output["S3KeyPrefix"] !== undefined) {
    contents.S3KeyPrefix = output["S3KeyPrefix"];
  }
  return contents;
};

const deserializeAws_queryMaintenanceTrack = (
  output: any,
  context: __SerdeContext
): MaintenanceTrack => {
  let contents: any = {
    __type: "MaintenanceTrack",
    DatabaseVersion: undefined,
    MaintenanceTrackName: undefined,
    UpdateTargets: undefined
  };
  if (output["DatabaseVersion"] !== undefined) {
    contents.DatabaseVersion = output["DatabaseVersion"];
  }
  if (output["MaintenanceTrackName"] !== undefined) {
    contents.MaintenanceTrackName = output["MaintenanceTrackName"];
  }
  if (output.UpdateTargets === "") {
    contents.UpdateTargets = [];
  }
  if (
    output["UpdateTargets"] !== undefined &&
    output["UpdateTargets"]["UpdateTarget"] !== undefined
  ) {
    const wrappedItem =
      output["UpdateTargets"]["UpdateTarget"] instanceof Array
        ? output["UpdateTargets"]["UpdateTarget"]
        : [output["UpdateTargets"]["UpdateTarget"]];
    contents.UpdateTargets = deserializeAws_queryEligibleTracksToUpdateList(
      wrappedItem,
      context
    );
  }
  return contents;
};

const deserializeAws_queryModifyClusterDbRevisionResult = (
  output: any,
  context: __SerdeContext
): ModifyClusterDbRevisionResult => {
  let contents: any = {
    __type: "ModifyClusterDbRevisionResult",
    Cluster: undefined
  };
  if (output["Cluster"] !== undefined) {
    contents.Cluster = deserializeAws_queryCluster(output["Cluster"], context);
  }
  return contents;
};

const deserializeAws_queryModifyClusterIamRolesResult = (
  output: any,
  context: __SerdeContext
): ModifyClusterIamRolesResult => {
  let contents: any = {
    __type: "ModifyClusterIamRolesResult",
    Cluster: undefined
  };
  if (output["Cluster"] !== undefined) {
    contents.Cluster = deserializeAws_queryCluster(output["Cluster"], context);
  }
  return contents;
};

const deserializeAws_queryModifyClusterMaintenanceResult = (
  output: any,
  context: __SerdeContext
): ModifyClusterMaintenanceResult => {
  let contents: any = {
    __type: "ModifyClusterMaintenanceResult",
    Cluster: undefined
  };
  if (output["Cluster"] !== undefined) {
    contents.Cluster = deserializeAws_queryCluster(output["Cluster"], context);
  }
  return contents;
};

const deserializeAws_queryModifyClusterResult = (
  output: any,
  context: __SerdeContext
): ModifyClusterResult => {
  let contents: any = {
    __type: "ModifyClusterResult",
    Cluster: undefined
  };
  if (output["Cluster"] !== undefined) {
    contents.Cluster = deserializeAws_queryCluster(output["Cluster"], context);
  }
  return contents;
};

const deserializeAws_queryModifyClusterSnapshotResult = (
  output: any,
  context: __SerdeContext
): ModifyClusterSnapshotResult => {
  let contents: any = {
    __type: "ModifyClusterSnapshotResult",
    Snapshot: undefined
  };
  if (output["Snapshot"] !== undefined) {
    contents.Snapshot = deserializeAws_querySnapshot(
      output["Snapshot"],
      context
    );
  }
  return contents;
};

const deserializeAws_queryModifyClusterSubnetGroupResult = (
  output: any,
  context: __SerdeContext
): ModifyClusterSubnetGroupResult => {
  let contents: any = {
    __type: "ModifyClusterSubnetGroupResult",
    ClusterSubnetGroup: undefined
  };
  if (output["ClusterSubnetGroup"] !== undefined) {
    contents.ClusterSubnetGroup = deserializeAws_queryClusterSubnetGroup(
      output["ClusterSubnetGroup"],
      context
    );
  }
  return contents;
};

const deserializeAws_queryModifyEventSubscriptionResult = (
  output: any,
  context: __SerdeContext
): ModifyEventSubscriptionResult => {
  let contents: any = {
    __type: "ModifyEventSubscriptionResult",
    EventSubscription: undefined
  };
  if (output["EventSubscription"] !== undefined) {
    contents.EventSubscription = deserializeAws_queryEventSubscription(
      output["EventSubscription"],
      context
    );
  }
  return contents;
};

const deserializeAws_queryModifySnapshotCopyRetentionPeriodResult = (
  output: any,
  context: __SerdeContext
): ModifySnapshotCopyRetentionPeriodResult => {
  let contents: any = {
    __type: "ModifySnapshotCopyRetentionPeriodResult",
    Cluster: undefined
  };
  if (output["Cluster"] !== undefined) {
    contents.Cluster = deserializeAws_queryCluster(output["Cluster"], context);
  }
  return contents;
};

const deserializeAws_queryNodeConfigurationOption = (
  output: any,
  context: __SerdeContext
): NodeConfigurationOption => {
  let contents: any = {
    __type: "NodeConfigurationOption",
    EstimatedDiskUtilizationPercent: undefined,
    Mode: undefined,
    NodeType: undefined,
    NumberOfNodes: undefined
  };
  if (output["EstimatedDiskUtilizationPercent"] !== undefined) {
    contents.EstimatedDiskUtilizationPercent = parseFloat(
      output["EstimatedDiskUtilizationPercent"]
    );
  }
  if (output["Mode"] !== undefined) {
    contents.Mode = output["Mode"];
  }
  if (output["NodeType"] !== undefined) {
    contents.NodeType = output["NodeType"];
  }
  if (output["NumberOfNodes"] !== undefined) {
    contents.NumberOfNodes = parseInt(output["NumberOfNodes"]);
  }
  return contents;
};

const deserializeAws_queryNodeConfigurationOptionList = (
  output: any,
  context: __SerdeContext
): Array<NodeConfigurationOption> => {
  return (output || []).map((entry: any) =>
    deserializeAws_queryNodeConfigurationOption(entry, context)
  );
};

const deserializeAws_queryNodeConfigurationOptionsMessage = (
  output: any,
  context: __SerdeContext
): NodeConfigurationOptionsMessage => {
  let contents: any = {
    __type: "NodeConfigurationOptionsMessage",
    Marker: undefined,
    NodeConfigurationOptionList: undefined
  };
  if (output["Marker"] !== undefined) {
    contents.Marker = output["Marker"];
  }
  if (output.NodeConfigurationOptionList === "") {
    contents.NodeConfigurationOptionList = [];
  }
  if (
    output["NodeConfigurationOptionList"] !== undefined &&
    output["NodeConfigurationOptionList"]["NodeConfigurationOption"] !==
      undefined
  ) {
    const wrappedItem =
      output["NodeConfigurationOptionList"][
        "NodeConfigurationOption"
      ] instanceof Array
        ? output["NodeConfigurationOptionList"]["NodeConfigurationOption"]
        : [output["NodeConfigurationOptionList"]["NodeConfigurationOption"]];
    contents.NodeConfigurationOptionList = deserializeAws_queryNodeConfigurationOptionList(
      wrappedItem,
      context
    );
  }
  return contents;
};

const deserializeAws_queryOrderableClusterOption = (
  output: any,
  context: __SerdeContext
): OrderableClusterOption => {
  let contents: any = {
    __type: "OrderableClusterOption",
    AvailabilityZones: undefined,
    ClusterType: undefined,
    ClusterVersion: undefined,
    NodeType: undefined
  };
  if (output.AvailabilityZones === "") {
    contents.AvailabilityZones = [];
  }
  if (
    output["AvailabilityZones"] !== undefined &&
    output["AvailabilityZones"]["AvailabilityZone"] !== undefined
  ) {
    const wrappedItem =
      output["AvailabilityZones"]["AvailabilityZone"] instanceof Array
        ? output["AvailabilityZones"]["AvailabilityZone"]
        : [output["AvailabilityZones"]["AvailabilityZone"]];
    contents.AvailabilityZones = deserializeAws_queryAvailabilityZoneList(
      wrappedItem,
      context
    );
  }
  if (output["ClusterType"] !== undefined) {
    contents.ClusterType = output["ClusterType"];
  }
  if (output["ClusterVersion"] !== undefined) {
    contents.ClusterVersion = output["ClusterVersion"];
  }
  if (output["NodeType"] !== undefined) {
    contents.NodeType = output["NodeType"];
  }
  return contents;
};

const deserializeAws_queryOrderableClusterOptionsList = (
  output: any,
  context: __SerdeContext
): Array<OrderableClusterOption> => {
  return (output || []).map((entry: any) =>
    deserializeAws_queryOrderableClusterOption(entry, context)
  );
};

const deserializeAws_queryOrderableClusterOptionsMessage = (
  output: any,
  context: __SerdeContext
): OrderableClusterOptionsMessage => {
  let contents: any = {
    __type: "OrderableClusterOptionsMessage",
    Marker: undefined,
    OrderableClusterOptions: undefined
  };
  if (output["Marker"] !== undefined) {
    contents.Marker = output["Marker"];
  }
  if (output.OrderableClusterOptions === "") {
    contents.OrderableClusterOptions = [];
  }
  if (
    output["OrderableClusterOptions"] !== undefined &&
    output["OrderableClusterOptions"]["OrderableClusterOption"] !== undefined
  ) {
    const wrappedItem =
      output["OrderableClusterOptions"]["OrderableClusterOption"] instanceof
      Array
        ? output["OrderableClusterOptions"]["OrderableClusterOption"]
        : [output["OrderableClusterOptions"]["OrderableClusterOption"]];
    contents.OrderableClusterOptions = deserializeAws_queryOrderableClusterOptionsList(
      wrappedItem,
      context
    );
  }
  return contents;
};

const deserializeAws_queryParameter = (
  output: any,
  context: __SerdeContext
): Parameter => {
  let contents: any = {
    __type: "Parameter",
    AllowedValues: undefined,
    ApplyType: undefined,
    DataType: undefined,
    Description: undefined,
    IsModifiable: undefined,
    MinimumEngineVersion: undefined,
    ParameterName: undefined,
    ParameterValue: undefined,
    Source: undefined
  };
  if (output["AllowedValues"] !== undefined) {
    contents.AllowedValues = output["AllowedValues"];
  }
  if (output["ApplyType"] !== undefined) {
    contents.ApplyType = output["ApplyType"];
  }
  if (output["DataType"] !== undefined) {
    contents.DataType = output["DataType"];
  }
  if (output["Description"] !== undefined) {
    contents.Description = output["Description"];
  }
  if (output["IsModifiable"] !== undefined) {
    contents.IsModifiable = output["IsModifiable"] == "true";
  }
  if (output["MinimumEngineVersion"] !== undefined) {
    contents.MinimumEngineVersion = output["MinimumEngineVersion"];
  }
  if (output["ParameterName"] !== undefined) {
    contents.ParameterName = output["ParameterName"];
  }
  if (output["ParameterValue"] !== undefined) {
    contents.ParameterValue = output["ParameterValue"];
  }
  if (output["Source"] !== undefined) {
    contents.Source = output["Source"];
  }
  return contents;
};

const deserializeAws_queryParameterGroupList = (
  output: any,
  context: __SerdeContext
): Array<ClusterParameterGroup> => {
  return (output || []).map((entry: any) =>
    deserializeAws_queryClusterParameterGroup(entry, context)
  );
};

const deserializeAws_queryParametersList = (
  output: any,
  context: __SerdeContext
): Array<Parameter> => {
  return (output || []).map((entry: any) =>
    deserializeAws_queryParameter(entry, context)
  );
};

const deserializeAws_queryPendingActionsList = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_queryPendingModifiedValues = (
  output: any,
  context: __SerdeContext
): PendingModifiedValues => {
  let contents: any = {
    __type: "PendingModifiedValues",
    AutomatedSnapshotRetentionPeriod: undefined,
    ClusterIdentifier: undefined,
    ClusterType: undefined,
    ClusterVersion: undefined,
    EncryptionType: undefined,
    EnhancedVpcRouting: undefined,
    MaintenanceTrackName: undefined,
    MasterUserPassword: undefined,
    NodeType: undefined,
    NumberOfNodes: undefined,
    PubliclyAccessible: undefined
  };
  if (output["AutomatedSnapshotRetentionPeriod"] !== undefined) {
    contents.AutomatedSnapshotRetentionPeriod = parseInt(
      output["AutomatedSnapshotRetentionPeriod"]
    );
  }
  if (output["ClusterIdentifier"] !== undefined) {
    contents.ClusterIdentifier = output["ClusterIdentifier"];
  }
  if (output["ClusterType"] !== undefined) {
    contents.ClusterType = output["ClusterType"];
  }
  if (output["ClusterVersion"] !== undefined) {
    contents.ClusterVersion = output["ClusterVersion"];
  }
  if (output["EncryptionType"] !== undefined) {
    contents.EncryptionType = output["EncryptionType"];
  }
  if (output["EnhancedVpcRouting"] !== undefined) {
    contents.EnhancedVpcRouting = output["EnhancedVpcRouting"] == "true";
  }
  if (output["MaintenanceTrackName"] !== undefined) {
    contents.MaintenanceTrackName = output["MaintenanceTrackName"];
  }
  if (output["MasterUserPassword"] !== undefined) {
    contents.MasterUserPassword = output["MasterUserPassword"];
  }
  if (output["NodeType"] !== undefined) {
    contents.NodeType = output["NodeType"];
  }
  if (output["NumberOfNodes"] !== undefined) {
    contents.NumberOfNodes = parseInt(output["NumberOfNodes"]);
  }
  if (output["PubliclyAccessible"] !== undefined) {
    contents.PubliclyAccessible = output["PubliclyAccessible"] == "true";
  }
  return contents;
};

const deserializeAws_queryPurchaseReservedNodeOfferingResult = (
  output: any,
  context: __SerdeContext
): PurchaseReservedNodeOfferingResult => {
  let contents: any = {
    __type: "PurchaseReservedNodeOfferingResult",
    ReservedNode: undefined
  };
  if (output["ReservedNode"] !== undefined) {
    contents.ReservedNode = deserializeAws_queryReservedNode(
      output["ReservedNode"],
      context
    );
  }
  return contents;
};

const deserializeAws_queryRebootClusterResult = (
  output: any,
  context: __SerdeContext
): RebootClusterResult => {
  let contents: any = {
    __type: "RebootClusterResult",
    Cluster: undefined
  };
  if (output["Cluster"] !== undefined) {
    contents.Cluster = deserializeAws_queryCluster(output["Cluster"], context);
  }
  return contents;
};

const deserializeAws_queryRecurringCharge = (
  output: any,
  context: __SerdeContext
): RecurringCharge => {
  let contents: any = {
    __type: "RecurringCharge",
    RecurringChargeAmount: undefined,
    RecurringChargeFrequency: undefined
  };
  if (output["RecurringChargeAmount"] !== undefined) {
    contents.RecurringChargeAmount = parseFloat(
      output["RecurringChargeAmount"]
    );
  }
  if (output["RecurringChargeFrequency"] !== undefined) {
    contents.RecurringChargeFrequency = output["RecurringChargeFrequency"];
  }
  return contents;
};

const deserializeAws_queryRecurringChargeList = (
  output: any,
  context: __SerdeContext
): Array<RecurringCharge> => {
  return (output || []).map((entry: any) =>
    deserializeAws_queryRecurringCharge(entry, context)
  );
};

const deserializeAws_queryReservedNode = (
  output: any,
  context: __SerdeContext
): ReservedNode => {
  let contents: any = {
    __type: "ReservedNode",
    CurrencyCode: undefined,
    Duration: undefined,
    FixedPrice: undefined,
    NodeCount: undefined,
    NodeType: undefined,
    OfferingType: undefined,
    RecurringCharges: undefined,
    ReservedNodeId: undefined,
    ReservedNodeOfferingId: undefined,
    ReservedNodeOfferingType: undefined,
    StartTime: undefined,
    State: undefined,
    UsagePrice: undefined
  };
  if (output["CurrencyCode"] !== undefined) {
    contents.CurrencyCode = output["CurrencyCode"];
  }
  if (output["Duration"] !== undefined) {
    contents.Duration = parseInt(output["Duration"]);
  }
  if (output["FixedPrice"] !== undefined) {
    contents.FixedPrice = parseFloat(output["FixedPrice"]);
  }
  if (output["NodeCount"] !== undefined) {
    contents.NodeCount = parseInt(output["NodeCount"]);
  }
  if (output["NodeType"] !== undefined) {
    contents.NodeType = output["NodeType"];
  }
  if (output["OfferingType"] !== undefined) {
    contents.OfferingType = output["OfferingType"];
  }
  if (output.RecurringCharges === "") {
    contents.RecurringCharges = [];
  }
  if (
    output["RecurringCharges"] !== undefined &&
    output["RecurringCharges"]["RecurringCharge"] !== undefined
  ) {
    const wrappedItem =
      output["RecurringCharges"]["RecurringCharge"] instanceof Array
        ? output["RecurringCharges"]["RecurringCharge"]
        : [output["RecurringCharges"]["RecurringCharge"]];
    contents.RecurringCharges = deserializeAws_queryRecurringChargeList(
      wrappedItem,
      context
    );
  }
  if (output["ReservedNodeId"] !== undefined) {
    contents.ReservedNodeId = output["ReservedNodeId"];
  }
  if (output["ReservedNodeOfferingId"] !== undefined) {
    contents.ReservedNodeOfferingId = output["ReservedNodeOfferingId"];
  }
  if (output["ReservedNodeOfferingType"] !== undefined) {
    contents.ReservedNodeOfferingType = output["ReservedNodeOfferingType"];
  }
  if (output["StartTime"] !== undefined) {
    contents.StartTime = new Date(output["StartTime"]);
  }
  if (output["State"] !== undefined) {
    contents.State = output["State"];
  }
  if (output["UsagePrice"] !== undefined) {
    contents.UsagePrice = parseFloat(output["UsagePrice"]);
  }
  return contents;
};

const deserializeAws_queryReservedNodeList = (
  output: any,
  context: __SerdeContext
): Array<ReservedNode> => {
  return (output || []).map((entry: any) =>
    deserializeAws_queryReservedNode(entry, context)
  );
};

const deserializeAws_queryReservedNodeOffering = (
  output: any,
  context: __SerdeContext
): ReservedNodeOffering => {
  let contents: any = {
    __type: "ReservedNodeOffering",
    CurrencyCode: undefined,
    Duration: undefined,
    FixedPrice: undefined,
    NodeType: undefined,
    OfferingType: undefined,
    RecurringCharges: undefined,
    ReservedNodeOfferingId: undefined,
    ReservedNodeOfferingType: undefined,
    UsagePrice: undefined
  };
  if (output["CurrencyCode"] !== undefined) {
    contents.CurrencyCode = output["CurrencyCode"];
  }
  if (output["Duration"] !== undefined) {
    contents.Duration = parseInt(output["Duration"]);
  }
  if (output["FixedPrice"] !== undefined) {
    contents.FixedPrice = parseFloat(output["FixedPrice"]);
  }
  if (output["NodeType"] !== undefined) {
    contents.NodeType = output["NodeType"];
  }
  if (output["OfferingType"] !== undefined) {
    contents.OfferingType = output["OfferingType"];
  }
  if (output.RecurringCharges === "") {
    contents.RecurringCharges = [];
  }
  if (
    output["RecurringCharges"] !== undefined &&
    output["RecurringCharges"]["RecurringCharge"] !== undefined
  ) {
    const wrappedItem =
      output["RecurringCharges"]["RecurringCharge"] instanceof Array
        ? output["RecurringCharges"]["RecurringCharge"]
        : [output["RecurringCharges"]["RecurringCharge"]];
    contents.RecurringCharges = deserializeAws_queryRecurringChargeList(
      wrappedItem,
      context
    );
  }
  if (output["ReservedNodeOfferingId"] !== undefined) {
    contents.ReservedNodeOfferingId = output["ReservedNodeOfferingId"];
  }
  if (output["ReservedNodeOfferingType"] !== undefined) {
    contents.ReservedNodeOfferingType = output["ReservedNodeOfferingType"];
  }
  if (output["UsagePrice"] !== undefined) {
    contents.UsagePrice = parseFloat(output["UsagePrice"]);
  }
  return contents;
};

const deserializeAws_queryReservedNodeOfferingList = (
  output: any,
  context: __SerdeContext
): Array<ReservedNodeOffering> => {
  return (output || []).map((entry: any) =>
    deserializeAws_queryReservedNodeOffering(entry, context)
  );
};

const deserializeAws_queryReservedNodeOfferingsMessage = (
  output: any,
  context: __SerdeContext
): ReservedNodeOfferingsMessage => {
  let contents: any = {
    __type: "ReservedNodeOfferingsMessage",
    Marker: undefined,
    ReservedNodeOfferings: undefined
  };
  if (output["Marker"] !== undefined) {
    contents.Marker = output["Marker"];
  }
  if (output.ReservedNodeOfferings === "") {
    contents.ReservedNodeOfferings = [];
  }
  if (
    output["ReservedNodeOfferings"] !== undefined &&
    output["ReservedNodeOfferings"]["ReservedNodeOffering"] !== undefined
  ) {
    const wrappedItem =
      output["ReservedNodeOfferings"]["ReservedNodeOffering"] instanceof Array
        ? output["ReservedNodeOfferings"]["ReservedNodeOffering"]
        : [output["ReservedNodeOfferings"]["ReservedNodeOffering"]];
    contents.ReservedNodeOfferings = deserializeAws_queryReservedNodeOfferingList(
      wrappedItem,
      context
    );
  }
  return contents;
};

const deserializeAws_queryReservedNodesMessage = (
  output: any,
  context: __SerdeContext
): ReservedNodesMessage => {
  let contents: any = {
    __type: "ReservedNodesMessage",
    Marker: undefined,
    ReservedNodes: undefined
  };
  if (output["Marker"] !== undefined) {
    contents.Marker = output["Marker"];
  }
  if (output.ReservedNodes === "") {
    contents.ReservedNodes = [];
  }
  if (
    output["ReservedNodes"] !== undefined &&
    output["ReservedNodes"]["ReservedNode"] !== undefined
  ) {
    const wrappedItem =
      output["ReservedNodes"]["ReservedNode"] instanceof Array
        ? output["ReservedNodes"]["ReservedNode"]
        : [output["ReservedNodes"]["ReservedNode"]];
    contents.ReservedNodes = deserializeAws_queryReservedNodeList(
      wrappedItem,
      context
    );
  }
  return contents;
};

const deserializeAws_queryResizeClusterMessage = (
  output: any,
  context: __SerdeContext
): ResizeClusterMessage => {
  let contents: any = {
    __type: "ResizeClusterMessage",
    Classic: undefined,
    ClusterIdentifier: undefined,
    ClusterType: undefined,
    NodeType: undefined,
    NumberOfNodes: undefined
  };
  if (output["Classic"] !== undefined) {
    contents.Classic = output["Classic"] == "true";
  }
  if (output["ClusterIdentifier"] !== undefined) {
    contents.ClusterIdentifier = output["ClusterIdentifier"];
  }
  if (output["ClusterType"] !== undefined) {
    contents.ClusterType = output["ClusterType"];
  }
  if (output["NodeType"] !== undefined) {
    contents.NodeType = output["NodeType"];
  }
  if (output["NumberOfNodes"] !== undefined) {
    contents.NumberOfNodes = parseInt(output["NumberOfNodes"]);
  }
  return contents;
};

const deserializeAws_queryResizeClusterResult = (
  output: any,
  context: __SerdeContext
): ResizeClusterResult => {
  let contents: any = {
    __type: "ResizeClusterResult",
    Cluster: undefined
  };
  if (output["Cluster"] !== undefined) {
    contents.Cluster = deserializeAws_queryCluster(output["Cluster"], context);
  }
  return contents;
};

const deserializeAws_queryResizeInfo = (
  output: any,
  context: __SerdeContext
): ResizeInfo => {
  let contents: any = {
    __type: "ResizeInfo",
    AllowCancelResize: undefined,
    ResizeType: undefined
  };
  if (output["AllowCancelResize"] !== undefined) {
    contents.AllowCancelResize = output["AllowCancelResize"] == "true";
  }
  if (output["ResizeType"] !== undefined) {
    contents.ResizeType = output["ResizeType"];
  }
  return contents;
};

const deserializeAws_queryResizeProgressMessage = (
  output: any,
  context: __SerdeContext
): ResizeProgressMessage => {
  let contents: any = {
    __type: "ResizeProgressMessage",
    AvgResizeRateInMegaBytesPerSecond: undefined,
    DataTransferProgressPercent: undefined,
    ElapsedTimeInSeconds: undefined,
    EstimatedTimeToCompletionInSeconds: undefined,
    ImportTablesCompleted: undefined,
    ImportTablesInProgress: undefined,
    ImportTablesNotStarted: undefined,
    Message: undefined,
    ProgressInMegaBytes: undefined,
    ResizeType: undefined,
    Status: undefined,
    TargetClusterType: undefined,
    TargetEncryptionType: undefined,
    TargetNodeType: undefined,
    TargetNumberOfNodes: undefined,
    TotalResizeDataInMegaBytes: undefined
  };
  if (output["AvgResizeRateInMegaBytesPerSecond"] !== undefined) {
    contents.AvgResizeRateInMegaBytesPerSecond = parseFloat(
      output["AvgResizeRateInMegaBytesPerSecond"]
    );
  }
  if (output["DataTransferProgressPercent"] !== undefined) {
    contents.DataTransferProgressPercent = parseFloat(
      output["DataTransferProgressPercent"]
    );
  }
  if (output["ElapsedTimeInSeconds"] !== undefined) {
    contents.ElapsedTimeInSeconds = parseInt(output["ElapsedTimeInSeconds"]);
  }
  if (output["EstimatedTimeToCompletionInSeconds"] !== undefined) {
    contents.EstimatedTimeToCompletionInSeconds = parseInt(
      output["EstimatedTimeToCompletionInSeconds"]
    );
  }
  if (output.ImportTablesCompleted === "") {
    contents.ImportTablesCompleted = [];
  }
  if (
    output["ImportTablesCompleted"] !== undefined &&
    output["ImportTablesCompleted"]["member"] !== undefined
  ) {
    const wrappedItem =
      output["ImportTablesCompleted"]["member"] instanceof Array
        ? output["ImportTablesCompleted"]["member"]
        : [output["ImportTablesCompleted"]["member"]];
    contents.ImportTablesCompleted = deserializeAws_queryImportTablesCompleted(
      wrappedItem,
      context
    );
  }
  if (output.ImportTablesInProgress === "") {
    contents.ImportTablesInProgress = [];
  }
  if (
    output["ImportTablesInProgress"] !== undefined &&
    output["ImportTablesInProgress"]["member"] !== undefined
  ) {
    const wrappedItem =
      output["ImportTablesInProgress"]["member"] instanceof Array
        ? output["ImportTablesInProgress"]["member"]
        : [output["ImportTablesInProgress"]["member"]];
    contents.ImportTablesInProgress = deserializeAws_queryImportTablesInProgress(
      wrappedItem,
      context
    );
  }
  if (output.ImportTablesNotStarted === "") {
    contents.ImportTablesNotStarted = [];
  }
  if (
    output["ImportTablesNotStarted"] !== undefined &&
    output["ImportTablesNotStarted"]["member"] !== undefined
  ) {
    const wrappedItem =
      output["ImportTablesNotStarted"]["member"] instanceof Array
        ? output["ImportTablesNotStarted"]["member"]
        : [output["ImportTablesNotStarted"]["member"]];
    contents.ImportTablesNotStarted = deserializeAws_queryImportTablesNotStarted(
      wrappedItem,
      context
    );
  }
  if (output["Message"] !== undefined) {
    contents.Message = output["Message"];
  }
  if (output["ProgressInMegaBytes"] !== undefined) {
    contents.ProgressInMegaBytes = parseInt(output["ProgressInMegaBytes"]);
  }
  if (output["ResizeType"] !== undefined) {
    contents.ResizeType = output["ResizeType"];
  }
  if (output["Status"] !== undefined) {
    contents.Status = output["Status"];
  }
  if (output["TargetClusterType"] !== undefined) {
    contents.TargetClusterType = output["TargetClusterType"];
  }
  if (output["TargetEncryptionType"] !== undefined) {
    contents.TargetEncryptionType = output["TargetEncryptionType"];
  }
  if (output["TargetNodeType"] !== undefined) {
    contents.TargetNodeType = output["TargetNodeType"];
  }
  if (output["TargetNumberOfNodes"] !== undefined) {
    contents.TargetNumberOfNodes = parseInt(output["TargetNumberOfNodes"]);
  }
  if (output["TotalResizeDataInMegaBytes"] !== undefined) {
    contents.TotalResizeDataInMegaBytes = parseInt(
      output["TotalResizeDataInMegaBytes"]
    );
  }
  return contents;
};

const deserializeAws_queryRestorableNodeTypeList = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_queryRestoreFromClusterSnapshotResult = (
  output: any,
  context: __SerdeContext
): RestoreFromClusterSnapshotResult => {
  let contents: any = {
    __type: "RestoreFromClusterSnapshotResult",
    Cluster: undefined
  };
  if (output["Cluster"] !== undefined) {
    contents.Cluster = deserializeAws_queryCluster(output["Cluster"], context);
  }
  return contents;
};

const deserializeAws_queryRestoreStatus = (
  output: any,
  context: __SerdeContext
): RestoreStatus => {
  let contents: any = {
    __type: "RestoreStatus",
    CurrentRestoreRateInMegaBytesPerSecond: undefined,
    ElapsedTimeInSeconds: undefined,
    EstimatedTimeToCompletionInSeconds: undefined,
    ProgressInMegaBytes: undefined,
    SnapshotSizeInMegaBytes: undefined,
    Status: undefined
  };
  if (output["CurrentRestoreRateInMegaBytesPerSecond"] !== undefined) {
    contents.CurrentRestoreRateInMegaBytesPerSecond = parseFloat(
      output["CurrentRestoreRateInMegaBytesPerSecond"]
    );
  }
  if (output["ElapsedTimeInSeconds"] !== undefined) {
    contents.ElapsedTimeInSeconds = parseInt(output["ElapsedTimeInSeconds"]);
  }
  if (output["EstimatedTimeToCompletionInSeconds"] !== undefined) {
    contents.EstimatedTimeToCompletionInSeconds = parseInt(
      output["EstimatedTimeToCompletionInSeconds"]
    );
  }
  if (output["ProgressInMegaBytes"] !== undefined) {
    contents.ProgressInMegaBytes = parseInt(output["ProgressInMegaBytes"]);
  }
  if (output["SnapshotSizeInMegaBytes"] !== undefined) {
    contents.SnapshotSizeInMegaBytes = parseInt(
      output["SnapshotSizeInMegaBytes"]
    );
  }
  if (output["Status"] !== undefined) {
    contents.Status = output["Status"];
  }
  return contents;
};

const deserializeAws_queryRestoreTableFromClusterSnapshotResult = (
  output: any,
  context: __SerdeContext
): RestoreTableFromClusterSnapshotResult => {
  let contents: any = {
    __type: "RestoreTableFromClusterSnapshotResult",
    TableRestoreStatus: undefined
  };
  if (output["TableRestoreStatus"] !== undefined) {
    contents.TableRestoreStatus = deserializeAws_queryTableRestoreStatus(
      output["TableRestoreStatus"],
      context
    );
  }
  return contents;
};

const deserializeAws_queryRevisionTarget = (
  output: any,
  context: __SerdeContext
): RevisionTarget => {
  let contents: any = {
    __type: "RevisionTarget",
    DatabaseRevision: undefined,
    DatabaseRevisionReleaseDate: undefined,
    Description: undefined
  };
  if (output["DatabaseRevision"] !== undefined) {
    contents.DatabaseRevision = output["DatabaseRevision"];
  }
  if (output["DatabaseRevisionReleaseDate"] !== undefined) {
    contents.DatabaseRevisionReleaseDate = new Date(
      output["DatabaseRevisionReleaseDate"]
    );
  }
  if (output["Description"] !== undefined) {
    contents.Description = output["Description"];
  }
  return contents;
};

const deserializeAws_queryRevisionTargetsList = (
  output: any,
  context: __SerdeContext
): Array<RevisionTarget> => {
  return (output || []).map((entry: any) =>
    deserializeAws_queryRevisionTarget(entry, context)
  );
};

const deserializeAws_queryRevokeClusterSecurityGroupIngressResult = (
  output: any,
  context: __SerdeContext
): RevokeClusterSecurityGroupIngressResult => {
  let contents: any = {
    __type: "RevokeClusterSecurityGroupIngressResult",
    ClusterSecurityGroup: undefined
  };
  if (output["ClusterSecurityGroup"] !== undefined) {
    contents.ClusterSecurityGroup = deserializeAws_queryClusterSecurityGroup(
      output["ClusterSecurityGroup"],
      context
    );
  }
  return contents;
};

const deserializeAws_queryRevokeSnapshotAccessResult = (
  output: any,
  context: __SerdeContext
): RevokeSnapshotAccessResult => {
  let contents: any = {
    __type: "RevokeSnapshotAccessResult",
    Snapshot: undefined
  };
  if (output["Snapshot"] !== undefined) {
    contents.Snapshot = deserializeAws_querySnapshot(
      output["Snapshot"],
      context
    );
  }
  return contents;
};

const deserializeAws_queryRotateEncryptionKeyResult = (
  output: any,
  context: __SerdeContext
): RotateEncryptionKeyResult => {
  let contents: any = {
    __type: "RotateEncryptionKeyResult",
    Cluster: undefined
  };
  if (output["Cluster"] !== undefined) {
    contents.Cluster = deserializeAws_queryCluster(output["Cluster"], context);
  }
  return contents;
};

const deserializeAws_queryScheduleDefinitionList = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_queryScheduledAction = (
  output: any,
  context: __SerdeContext
): ScheduledAction => {
  let contents: any = {
    __type: "ScheduledAction",
    EndTime: undefined,
    IamRole: undefined,
    NextInvocations: undefined,
    Schedule: undefined,
    ScheduledActionDescription: undefined,
    ScheduledActionName: undefined,
    StartTime: undefined,
    State: undefined,
    TargetAction: undefined
  };
  if (output["EndTime"] !== undefined) {
    contents.EndTime = new Date(output["EndTime"]);
  }
  if (output["IamRole"] !== undefined) {
    contents.IamRole = output["IamRole"];
  }
  if (output.NextInvocations === "") {
    contents.NextInvocations = [];
  }
  if (
    output["NextInvocations"] !== undefined &&
    output["NextInvocations"]["ScheduledActionTime"] !== undefined
  ) {
    const wrappedItem =
      output["NextInvocations"]["ScheduledActionTime"] instanceof Array
        ? output["NextInvocations"]["ScheduledActionTime"]
        : [output["NextInvocations"]["ScheduledActionTime"]];
    contents.NextInvocations = deserializeAws_queryScheduledActionTimeList(
      wrappedItem,
      context
    );
  }
  if (output["Schedule"] !== undefined) {
    contents.Schedule = output["Schedule"];
  }
  if (output["ScheduledActionDescription"] !== undefined) {
    contents.ScheduledActionDescription = output["ScheduledActionDescription"];
  }
  if (output["ScheduledActionName"] !== undefined) {
    contents.ScheduledActionName = output["ScheduledActionName"];
  }
  if (output["StartTime"] !== undefined) {
    contents.StartTime = new Date(output["StartTime"]);
  }
  if (output["State"] !== undefined) {
    contents.State = output["State"];
  }
  if (output["TargetAction"] !== undefined) {
    contents.TargetAction = deserializeAws_queryScheduledActionType(
      output["TargetAction"],
      context
    );
  }
  return contents;
};

const deserializeAws_queryScheduledActionList = (
  output: any,
  context: __SerdeContext
): Array<ScheduledAction> => {
  return (output || []).map((entry: any) =>
    deserializeAws_queryScheduledAction(entry, context)
  );
};

const deserializeAws_queryScheduledActionTimeList = (
  output: any,
  context: __SerdeContext
): Array<Date> => {
  return (output || []).map((entry: any) => new Date(entry));
};

const deserializeAws_queryScheduledActionType = (
  output: any,
  context: __SerdeContext
): ScheduledActionType => {
  let contents: any = {
    __type: "ScheduledActionType",
    ResizeCluster: undefined
  };
  if (output["ResizeCluster"] !== undefined) {
    contents.ResizeCluster = deserializeAws_queryResizeClusterMessage(
      output["ResizeCluster"],
      context
    );
  }
  return contents;
};

const deserializeAws_queryScheduledActionsMessage = (
  output: any,
  context: __SerdeContext
): ScheduledActionsMessage => {
  let contents: any = {
    __type: "ScheduledActionsMessage",
    Marker: undefined,
    ScheduledActions: undefined
  };
  if (output["Marker"] !== undefined) {
    contents.Marker = output["Marker"];
  }
  if (output.ScheduledActions === "") {
    contents.ScheduledActions = [];
  }
  if (
    output["ScheduledActions"] !== undefined &&
    output["ScheduledActions"]["ScheduledAction"] !== undefined
  ) {
    const wrappedItem =
      output["ScheduledActions"]["ScheduledAction"] instanceof Array
        ? output["ScheduledActions"]["ScheduledAction"]
        : [output["ScheduledActions"]["ScheduledAction"]];
    contents.ScheduledActions = deserializeAws_queryScheduledActionList(
      wrappedItem,
      context
    );
  }
  return contents;
};

const deserializeAws_queryScheduledSnapshotTimeList = (
  output: any,
  context: __SerdeContext
): Array<Date> => {
  return (output || []).map((entry: any) => new Date(entry));
};

const deserializeAws_querySnapshot = (
  output: any,
  context: __SerdeContext
): Snapshot => {
  let contents: any = {
    __type: "Snapshot",
    AccountsWithRestoreAccess: undefined,
    ActualIncrementalBackupSizeInMegaBytes: undefined,
    AvailabilityZone: undefined,
    BackupProgressInMegaBytes: undefined,
    ClusterCreateTime: undefined,
    ClusterIdentifier: undefined,
    ClusterVersion: undefined,
    CurrentBackupRateInMegaBytesPerSecond: undefined,
    DBName: undefined,
    ElapsedTimeInSeconds: undefined,
    Encrypted: undefined,
    EncryptedWithHSM: undefined,
    EnhancedVpcRouting: undefined,
    EstimatedSecondsToCompletion: undefined,
    KmsKeyId: undefined,
    MaintenanceTrackName: undefined,
    ManualSnapshotRemainingDays: undefined,
    ManualSnapshotRetentionPeriod: undefined,
    MasterUsername: undefined,
    NodeType: undefined,
    NumberOfNodes: undefined,
    OwnerAccount: undefined,
    Port: undefined,
    RestorableNodeTypes: undefined,
    SnapshotCreateTime: undefined,
    SnapshotIdentifier: undefined,
    SnapshotRetentionStartTime: undefined,
    SnapshotType: undefined,
    SourceRegion: undefined,
    Status: undefined,
    Tags: undefined,
    TotalBackupSizeInMegaBytes: undefined,
    VpcId: undefined
  };
  if (output.AccountsWithRestoreAccess === "") {
    contents.AccountsWithRestoreAccess = [];
  }
  if (
    output["AccountsWithRestoreAccess"] !== undefined &&
    output["AccountsWithRestoreAccess"]["AccountWithRestoreAccess"] !==
      undefined
  ) {
    const wrappedItem =
      output["AccountsWithRestoreAccess"]["AccountWithRestoreAccess"] instanceof
      Array
        ? output["AccountsWithRestoreAccess"]["AccountWithRestoreAccess"]
        : [output["AccountsWithRestoreAccess"]["AccountWithRestoreAccess"]];
    contents.AccountsWithRestoreAccess = deserializeAws_queryAccountsWithRestoreAccessList(
      wrappedItem,
      context
    );
  }
  if (output["ActualIncrementalBackupSizeInMegaBytes"] !== undefined) {
    contents.ActualIncrementalBackupSizeInMegaBytes = parseFloat(
      output["ActualIncrementalBackupSizeInMegaBytes"]
    );
  }
  if (output["AvailabilityZone"] !== undefined) {
    contents.AvailabilityZone = output["AvailabilityZone"];
  }
  if (output["BackupProgressInMegaBytes"] !== undefined) {
    contents.BackupProgressInMegaBytes = parseFloat(
      output["BackupProgressInMegaBytes"]
    );
  }
  if (output["ClusterCreateTime"] !== undefined) {
    contents.ClusterCreateTime = new Date(output["ClusterCreateTime"]);
  }
  if (output["ClusterIdentifier"] !== undefined) {
    contents.ClusterIdentifier = output["ClusterIdentifier"];
  }
  if (output["ClusterVersion"] !== undefined) {
    contents.ClusterVersion = output["ClusterVersion"];
  }
  if (output["CurrentBackupRateInMegaBytesPerSecond"] !== undefined) {
    contents.CurrentBackupRateInMegaBytesPerSecond = parseFloat(
      output["CurrentBackupRateInMegaBytesPerSecond"]
    );
  }
  if (output["DBName"] !== undefined) {
    contents.DBName = output["DBName"];
  }
  if (output["ElapsedTimeInSeconds"] !== undefined) {
    contents.ElapsedTimeInSeconds = parseInt(output["ElapsedTimeInSeconds"]);
  }
  if (output["Encrypted"] !== undefined) {
    contents.Encrypted = output["Encrypted"] == "true";
  }
  if (output["EncryptedWithHSM"] !== undefined) {
    contents.EncryptedWithHSM = output["EncryptedWithHSM"] == "true";
  }
  if (output["EnhancedVpcRouting"] !== undefined) {
    contents.EnhancedVpcRouting = output["EnhancedVpcRouting"] == "true";
  }
  if (output["EstimatedSecondsToCompletion"] !== undefined) {
    contents.EstimatedSecondsToCompletion = parseInt(
      output["EstimatedSecondsToCompletion"]
    );
  }
  if (output["KmsKeyId"] !== undefined) {
    contents.KmsKeyId = output["KmsKeyId"];
  }
  if (output["MaintenanceTrackName"] !== undefined) {
    contents.MaintenanceTrackName = output["MaintenanceTrackName"];
  }
  if (output["ManualSnapshotRemainingDays"] !== undefined) {
    contents.ManualSnapshotRemainingDays = parseInt(
      output["ManualSnapshotRemainingDays"]
    );
  }
  if (output["ManualSnapshotRetentionPeriod"] !== undefined) {
    contents.ManualSnapshotRetentionPeriod = parseInt(
      output["ManualSnapshotRetentionPeriod"]
    );
  }
  if (output["MasterUsername"] !== undefined) {
    contents.MasterUsername = output["MasterUsername"];
  }
  if (output["NodeType"] !== undefined) {
    contents.NodeType = output["NodeType"];
  }
  if (output["NumberOfNodes"] !== undefined) {
    contents.NumberOfNodes = parseInt(output["NumberOfNodes"]);
  }
  if (output["OwnerAccount"] !== undefined) {
    contents.OwnerAccount = output["OwnerAccount"];
  }
  if (output["Port"] !== undefined) {
    contents.Port = parseInt(output["Port"]);
  }
  if (output.RestorableNodeTypes === "") {
    contents.RestorableNodeTypes = [];
  }
  if (
    output["RestorableNodeTypes"] !== undefined &&
    output["RestorableNodeTypes"]["NodeType"] !== undefined
  ) {
    const wrappedItem =
      output["RestorableNodeTypes"]["NodeType"] instanceof Array
        ? output["RestorableNodeTypes"]["NodeType"]
        : [output["RestorableNodeTypes"]["NodeType"]];
    contents.RestorableNodeTypes = deserializeAws_queryRestorableNodeTypeList(
      wrappedItem,
      context
    );
  }
  if (output["SnapshotCreateTime"] !== undefined) {
    contents.SnapshotCreateTime = new Date(output["SnapshotCreateTime"]);
  }
  if (output["SnapshotIdentifier"] !== undefined) {
    contents.SnapshotIdentifier = output["SnapshotIdentifier"];
  }
  if (output["SnapshotRetentionStartTime"] !== undefined) {
    contents.SnapshotRetentionStartTime = new Date(
      output["SnapshotRetentionStartTime"]
    );
  }
  if (output["SnapshotType"] !== undefined) {
    contents.SnapshotType = output["SnapshotType"];
  }
  if (output["SourceRegion"] !== undefined) {
    contents.SourceRegion = output["SourceRegion"];
  }
  if (output["Status"] !== undefined) {
    contents.Status = output["Status"];
  }
  if (output.Tags === "") {
    contents.Tags = [];
  }
  if (output["Tags"] !== undefined && output["Tags"]["Tag"] !== undefined) {
    const wrappedItem =
      output["Tags"]["Tag"] instanceof Array
        ? output["Tags"]["Tag"]
        : [output["Tags"]["Tag"]];
    contents.Tags = deserializeAws_queryTagList(wrappedItem, context);
  }
  if (output["TotalBackupSizeInMegaBytes"] !== undefined) {
    contents.TotalBackupSizeInMegaBytes = parseFloat(
      output["TotalBackupSizeInMegaBytes"]
    );
  }
  if (output["VpcId"] !== undefined) {
    contents.VpcId = output["VpcId"];
  }
  return contents;
};

const deserializeAws_querySnapshotCopyGrant = (
  output: any,
  context: __SerdeContext
): SnapshotCopyGrant => {
  let contents: any = {
    __type: "SnapshotCopyGrant",
    KmsKeyId: undefined,
    SnapshotCopyGrantName: undefined,
    Tags: undefined
  };
  if (output["KmsKeyId"] !== undefined) {
    contents.KmsKeyId = output["KmsKeyId"];
  }
  if (output["SnapshotCopyGrantName"] !== undefined) {
    contents.SnapshotCopyGrantName = output["SnapshotCopyGrantName"];
  }
  if (output.Tags === "") {
    contents.Tags = [];
  }
  if (output["Tags"] !== undefined && output["Tags"]["Tag"] !== undefined) {
    const wrappedItem =
      output["Tags"]["Tag"] instanceof Array
        ? output["Tags"]["Tag"]
        : [output["Tags"]["Tag"]];
    contents.Tags = deserializeAws_queryTagList(wrappedItem, context);
  }
  return contents;
};

const deserializeAws_querySnapshotCopyGrantList = (
  output: any,
  context: __SerdeContext
): Array<SnapshotCopyGrant> => {
  return (output || []).map((entry: any) =>
    deserializeAws_querySnapshotCopyGrant(entry, context)
  );
};

const deserializeAws_querySnapshotCopyGrantMessage = (
  output: any,
  context: __SerdeContext
): SnapshotCopyGrantMessage => {
  let contents: any = {
    __type: "SnapshotCopyGrantMessage",
    Marker: undefined,
    SnapshotCopyGrants: undefined
  };
  if (output["Marker"] !== undefined) {
    contents.Marker = output["Marker"];
  }
  if (output.SnapshotCopyGrants === "") {
    contents.SnapshotCopyGrants = [];
  }
  if (
    output["SnapshotCopyGrants"] !== undefined &&
    output["SnapshotCopyGrants"]["SnapshotCopyGrant"] !== undefined
  ) {
    const wrappedItem =
      output["SnapshotCopyGrants"]["SnapshotCopyGrant"] instanceof Array
        ? output["SnapshotCopyGrants"]["SnapshotCopyGrant"]
        : [output["SnapshotCopyGrants"]["SnapshotCopyGrant"]];
    contents.SnapshotCopyGrants = deserializeAws_querySnapshotCopyGrantList(
      wrappedItem,
      context
    );
  }
  return contents;
};

const deserializeAws_querySnapshotErrorMessage = (
  output: any,
  context: __SerdeContext
): SnapshotErrorMessage => {
  let contents: any = {
    __type: "SnapshotErrorMessage",
    FailureCode: undefined,
    FailureReason: undefined,
    SnapshotClusterIdentifier: undefined,
    SnapshotIdentifier: undefined
  };
  if (output["FailureCode"] !== undefined) {
    contents.FailureCode = output["FailureCode"];
  }
  if (output["FailureReason"] !== undefined) {
    contents.FailureReason = output["FailureReason"];
  }
  if (output["SnapshotClusterIdentifier"] !== undefined) {
    contents.SnapshotClusterIdentifier = output["SnapshotClusterIdentifier"];
  }
  if (output["SnapshotIdentifier"] !== undefined) {
    contents.SnapshotIdentifier = output["SnapshotIdentifier"];
  }
  return contents;
};

const deserializeAws_querySnapshotIdentifierList = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_querySnapshotList = (
  output: any,
  context: __SerdeContext
): Array<Snapshot> => {
  return (output || []).map((entry: any) =>
    deserializeAws_querySnapshot(entry, context)
  );
};

const deserializeAws_querySnapshotMessage = (
  output: any,
  context: __SerdeContext
): SnapshotMessage => {
  let contents: any = {
    __type: "SnapshotMessage",
    Marker: undefined,
    Snapshots: undefined
  };
  if (output["Marker"] !== undefined) {
    contents.Marker = output["Marker"];
  }
  if (output.Snapshots === "") {
    contents.Snapshots = [];
  }
  if (
    output["Snapshots"] !== undefined &&
    output["Snapshots"]["Snapshot"] !== undefined
  ) {
    const wrappedItem =
      output["Snapshots"]["Snapshot"] instanceof Array
        ? output["Snapshots"]["Snapshot"]
        : [output["Snapshots"]["Snapshot"]];
    contents.Snapshots = deserializeAws_querySnapshotList(wrappedItem, context);
  }
  return contents;
};

const deserializeAws_querySnapshotSchedule = (
  output: any,
  context: __SerdeContext
): SnapshotSchedule => {
  let contents: any = {
    __type: "SnapshotSchedule",
    AssociatedClusterCount: undefined,
    AssociatedClusters: undefined,
    NextInvocations: undefined,
    ScheduleDefinitions: undefined,
    ScheduleDescription: undefined,
    ScheduleIdentifier: undefined,
    Tags: undefined
  };
  if (output["AssociatedClusterCount"] !== undefined) {
    contents.AssociatedClusterCount = parseInt(
      output["AssociatedClusterCount"]
    );
  }
  if (output.AssociatedClusters === "") {
    contents.AssociatedClusters = [];
  }
  if (
    output["AssociatedClusters"] !== undefined &&
    output["AssociatedClusters"]["ClusterAssociatedToSchedule"] !== undefined
  ) {
    const wrappedItem =
      output["AssociatedClusters"]["ClusterAssociatedToSchedule"] instanceof
      Array
        ? output["AssociatedClusters"]["ClusterAssociatedToSchedule"]
        : [output["AssociatedClusters"]["ClusterAssociatedToSchedule"]];
    contents.AssociatedClusters = deserializeAws_queryAssociatedClusterList(
      wrappedItem,
      context
    );
  }
  if (output.NextInvocations === "") {
    contents.NextInvocations = [];
  }
  if (
    output["NextInvocations"] !== undefined &&
    output["NextInvocations"]["SnapshotTime"] !== undefined
  ) {
    const wrappedItem =
      output["NextInvocations"]["SnapshotTime"] instanceof Array
        ? output["NextInvocations"]["SnapshotTime"]
        : [output["NextInvocations"]["SnapshotTime"]];
    contents.NextInvocations = deserializeAws_queryScheduledSnapshotTimeList(
      wrappedItem,
      context
    );
  }
  if (output.ScheduleDefinitions === "") {
    contents.ScheduleDefinitions = [];
  }
  if (
    output["ScheduleDefinitions"] !== undefined &&
    output["ScheduleDefinitions"]["ScheduleDefinition"] !== undefined
  ) {
    const wrappedItem =
      output["ScheduleDefinitions"]["ScheduleDefinition"] instanceof Array
        ? output["ScheduleDefinitions"]["ScheduleDefinition"]
        : [output["ScheduleDefinitions"]["ScheduleDefinition"]];
    contents.ScheduleDefinitions = deserializeAws_queryScheduleDefinitionList(
      wrappedItem,
      context
    );
  }
  if (output["ScheduleDescription"] !== undefined) {
    contents.ScheduleDescription = output["ScheduleDescription"];
  }
  if (output["ScheduleIdentifier"] !== undefined) {
    contents.ScheduleIdentifier = output["ScheduleIdentifier"];
  }
  if (output.Tags === "") {
    contents.Tags = [];
  }
  if (output["Tags"] !== undefined && output["Tags"]["Tag"] !== undefined) {
    const wrappedItem =
      output["Tags"]["Tag"] instanceof Array
        ? output["Tags"]["Tag"]
        : [output["Tags"]["Tag"]];
    contents.Tags = deserializeAws_queryTagList(wrappedItem, context);
  }
  return contents;
};

const deserializeAws_querySnapshotScheduleList = (
  output: any,
  context: __SerdeContext
): Array<SnapshotSchedule> => {
  return (output || []).map((entry: any) =>
    deserializeAws_querySnapshotSchedule(entry, context)
  );
};

const deserializeAws_querySourceIdsList = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_querySubnet = (
  output: any,
  context: __SerdeContext
): Subnet => {
  let contents: any = {
    __type: "Subnet",
    SubnetAvailabilityZone: undefined,
    SubnetIdentifier: undefined,
    SubnetStatus: undefined
  };
  if (output["SubnetAvailabilityZone"] !== undefined) {
    contents.SubnetAvailabilityZone = deserializeAws_queryAvailabilityZone(
      output["SubnetAvailabilityZone"],
      context
    );
  }
  if (output["SubnetIdentifier"] !== undefined) {
    contents.SubnetIdentifier = output["SubnetIdentifier"];
  }
  if (output["SubnetStatus"] !== undefined) {
    contents.SubnetStatus = output["SubnetStatus"];
  }
  return contents;
};

const deserializeAws_querySubnetList = (
  output: any,
  context: __SerdeContext
): Array<Subnet> => {
  return (output || []).map((entry: any) =>
    deserializeAws_querySubnet(entry, context)
  );
};

const deserializeAws_querySupportedOperation = (
  output: any,
  context: __SerdeContext
): SupportedOperation => {
  let contents: any = {
    __type: "SupportedOperation",
    OperationName: undefined
  };
  if (output["OperationName"] !== undefined) {
    contents.OperationName = output["OperationName"];
  }
  return contents;
};

const deserializeAws_querySupportedOperationList = (
  output: any,
  context: __SerdeContext
): Array<SupportedOperation> => {
  return (output || []).map((entry: any) =>
    deserializeAws_querySupportedOperation(entry, context)
  );
};

const deserializeAws_querySupportedPlatform = (
  output: any,
  context: __SerdeContext
): SupportedPlatform => {
  let contents: any = {
    __type: "SupportedPlatform",
    Name: undefined
  };
  if (output["Name"] !== undefined) {
    contents.Name = output["Name"];
  }
  return contents;
};

const deserializeAws_querySupportedPlatformsList = (
  output: any,
  context: __SerdeContext
): Array<SupportedPlatform> => {
  return (output || []).map((entry: any) =>
    deserializeAws_querySupportedPlatform(entry, context)
  );
};

const deserializeAws_queryTableRestoreStatus = (
  output: any,
  context: __SerdeContext
): TableRestoreStatus => {
  let contents: any = {
    __type: "TableRestoreStatus",
    ClusterIdentifier: undefined,
    Message: undefined,
    NewTableName: undefined,
    ProgressInMegaBytes: undefined,
    RequestTime: undefined,
    SnapshotIdentifier: undefined,
    SourceDatabaseName: undefined,
    SourceSchemaName: undefined,
    SourceTableName: undefined,
    Status: undefined,
    TableRestoreRequestId: undefined,
    TargetDatabaseName: undefined,
    TargetSchemaName: undefined,
    TotalDataInMegaBytes: undefined
  };
  if (output["ClusterIdentifier"] !== undefined) {
    contents.ClusterIdentifier = output["ClusterIdentifier"];
  }
  if (output["Message"] !== undefined) {
    contents.Message = output["Message"];
  }
  if (output["NewTableName"] !== undefined) {
    contents.NewTableName = output["NewTableName"];
  }
  if (output["ProgressInMegaBytes"] !== undefined) {
    contents.ProgressInMegaBytes = parseInt(output["ProgressInMegaBytes"]);
  }
  if (output["RequestTime"] !== undefined) {
    contents.RequestTime = new Date(output["RequestTime"]);
  }
  if (output["SnapshotIdentifier"] !== undefined) {
    contents.SnapshotIdentifier = output["SnapshotIdentifier"];
  }
  if (output["SourceDatabaseName"] !== undefined) {
    contents.SourceDatabaseName = output["SourceDatabaseName"];
  }
  if (output["SourceSchemaName"] !== undefined) {
    contents.SourceSchemaName = output["SourceSchemaName"];
  }
  if (output["SourceTableName"] !== undefined) {
    contents.SourceTableName = output["SourceTableName"];
  }
  if (output["Status"] !== undefined) {
    contents.Status = output["Status"];
  }
  if (output["TableRestoreRequestId"] !== undefined) {
    contents.TableRestoreRequestId = output["TableRestoreRequestId"];
  }
  if (output["TargetDatabaseName"] !== undefined) {
    contents.TargetDatabaseName = output["TargetDatabaseName"];
  }
  if (output["TargetSchemaName"] !== undefined) {
    contents.TargetSchemaName = output["TargetSchemaName"];
  }
  if (output["TotalDataInMegaBytes"] !== undefined) {
    contents.TotalDataInMegaBytes = parseInt(output["TotalDataInMegaBytes"]);
  }
  return contents;
};

const deserializeAws_queryTableRestoreStatusList = (
  output: any,
  context: __SerdeContext
): Array<TableRestoreStatus> => {
  return (output || []).map((entry: any) =>
    deserializeAws_queryTableRestoreStatus(entry, context)
  );
};

const deserializeAws_queryTableRestoreStatusMessage = (
  output: any,
  context: __SerdeContext
): TableRestoreStatusMessage => {
  let contents: any = {
    __type: "TableRestoreStatusMessage",
    Marker: undefined,
    TableRestoreStatusDetails: undefined
  };
  if (output["Marker"] !== undefined) {
    contents.Marker = output["Marker"];
  }
  if (output.TableRestoreStatusDetails === "") {
    contents.TableRestoreStatusDetails = [];
  }
  if (
    output["TableRestoreStatusDetails"] !== undefined &&
    output["TableRestoreStatusDetails"]["TableRestoreStatus"] !== undefined
  ) {
    const wrappedItem =
      output["TableRestoreStatusDetails"]["TableRestoreStatus"] instanceof Array
        ? output["TableRestoreStatusDetails"]["TableRestoreStatus"]
        : [output["TableRestoreStatusDetails"]["TableRestoreStatus"]];
    contents.TableRestoreStatusDetails = deserializeAws_queryTableRestoreStatusList(
      wrappedItem,
      context
    );
  }
  return contents;
};

const deserializeAws_queryTag = (output: any, context: __SerdeContext): Tag => {
  let contents: any = {
    __type: "Tag",
    Key: undefined,
    Value: undefined
  };
  if (output["Key"] !== undefined) {
    contents.Key = output["Key"];
  }
  if (output["Value"] !== undefined) {
    contents.Value = output["Value"];
  }
  return contents;
};

const deserializeAws_queryTagList = (
  output: any,
  context: __SerdeContext
): Array<Tag> => {
  return (output || []).map((entry: any) =>
    deserializeAws_queryTag(entry, context)
  );
};

const deserializeAws_queryTaggedResource = (
  output: any,
  context: __SerdeContext
): TaggedResource => {
  let contents: any = {
    __type: "TaggedResource",
    ResourceName: undefined,
    ResourceType: undefined,
    Tag: undefined
  };
  if (output["ResourceName"] !== undefined) {
    contents.ResourceName = output["ResourceName"];
  }
  if (output["ResourceType"] !== undefined) {
    contents.ResourceType = output["ResourceType"];
  }
  if (output["Tag"] !== undefined) {
    contents.Tag = deserializeAws_queryTag(output["Tag"], context);
  }
  return contents;
};

const deserializeAws_queryTaggedResourceList = (
  output: any,
  context: __SerdeContext
): Array<TaggedResource> => {
  return (output || []).map((entry: any) =>
    deserializeAws_queryTaggedResource(entry, context)
  );
};

const deserializeAws_queryTaggedResourceListMessage = (
  output: any,
  context: __SerdeContext
): TaggedResourceListMessage => {
  let contents: any = {
    __type: "TaggedResourceListMessage",
    Marker: undefined,
    TaggedResources: undefined
  };
  if (output["Marker"] !== undefined) {
    contents.Marker = output["Marker"];
  }
  if (output.TaggedResources === "") {
    contents.TaggedResources = [];
  }
  if (
    output["TaggedResources"] !== undefined &&
    output["TaggedResources"]["TaggedResource"] !== undefined
  ) {
    const wrappedItem =
      output["TaggedResources"]["TaggedResource"] instanceof Array
        ? output["TaggedResources"]["TaggedResource"]
        : [output["TaggedResources"]["TaggedResource"]];
    contents.TaggedResources = deserializeAws_queryTaggedResourceList(
      wrappedItem,
      context
    );
  }
  return contents;
};

const deserializeAws_queryTrackList = (
  output: any,
  context: __SerdeContext
): Array<MaintenanceTrack> => {
  return (output || []).map((entry: any) =>
    deserializeAws_queryMaintenanceTrack(entry, context)
  );
};

const deserializeAws_queryTrackListMessage = (
  output: any,
  context: __SerdeContext
): TrackListMessage => {
  let contents: any = {
    __type: "TrackListMessage",
    MaintenanceTracks: undefined,
    Marker: undefined
  };
  if (output.MaintenanceTracks === "") {
    contents.MaintenanceTracks = [];
  }
  if (
    output["MaintenanceTracks"] !== undefined &&
    output["MaintenanceTracks"]["MaintenanceTrack"] !== undefined
  ) {
    const wrappedItem =
      output["MaintenanceTracks"]["MaintenanceTrack"] instanceof Array
        ? output["MaintenanceTracks"]["MaintenanceTrack"]
        : [output["MaintenanceTracks"]["MaintenanceTrack"]];
    contents.MaintenanceTracks = deserializeAws_queryTrackList(
      wrappedItem,
      context
    );
  }
  if (output["Marker"] !== undefined) {
    contents.Marker = output["Marker"];
  }
  return contents;
};

const deserializeAws_queryUpdateTarget = (
  output: any,
  context: __SerdeContext
): UpdateTarget => {
  let contents: any = {
    __type: "UpdateTarget",
    DatabaseVersion: undefined,
    MaintenanceTrackName: undefined,
    SupportedOperations: undefined
  };
  if (output["DatabaseVersion"] !== undefined) {
    contents.DatabaseVersion = output["DatabaseVersion"];
  }
  if (output["MaintenanceTrackName"] !== undefined) {
    contents.MaintenanceTrackName = output["MaintenanceTrackName"];
  }
  if (output.SupportedOperations === "") {
    contents.SupportedOperations = [];
  }
  if (
    output["SupportedOperations"] !== undefined &&
    output["SupportedOperations"]["SupportedOperation"] !== undefined
  ) {
    const wrappedItem =
      output["SupportedOperations"]["SupportedOperation"] instanceof Array
        ? output["SupportedOperations"]["SupportedOperation"]
        : [output["SupportedOperations"]["SupportedOperation"]];
    contents.SupportedOperations = deserializeAws_querySupportedOperationList(
      wrappedItem,
      context
    );
  }
  return contents;
};

const deserializeAws_queryVpcSecurityGroupMembership = (
  output: any,
  context: __SerdeContext
): VpcSecurityGroupMembership => {
  let contents: any = {
    __type: "VpcSecurityGroupMembership",
    Status: undefined,
    VpcSecurityGroupId: undefined
  };
  if (output["Status"] !== undefined) {
    contents.Status = output["Status"];
  }
  if (output["VpcSecurityGroupId"] !== undefined) {
    contents.VpcSecurityGroupId = output["VpcSecurityGroupId"];
  }
  return contents;
};

const deserializeAws_queryVpcSecurityGroupMembershipList = (
  output: any,
  context: __SerdeContext
): Array<VpcSecurityGroupMembership> => {
  return (output || []).map((entry: any) =>
    deserializeAws_queryVpcSecurityGroupMembership(entry, context)
  );
};

const deserializeMetadata = (output: __HttpResponse): __ResponseMetadata => ({
  httpStatusCode: output.statusCode,
  httpHeaders: output.headers,
  requestId: output.headers["x-amzn-requestid"]
});

// Collect low-level response body stream to Uint8Array.
const collectBody = (
  streamBody: any,
  context: __SerdeContext
): Promise<Uint8Array> => {
  if (streamBody instanceof Uint8Array) {
    return Promise.resolve(streamBody);
  }
  return (
    context.streamCollector(streamBody) || Promise.resolve(new Uint8Array())
  );
};

// Encode Uint8Array data into string with utf-8.
const collectBodyString = (
  streamBody: any,
  context: __SerdeContext
): Promise<string> => {
  return collectBody(streamBody, context).then(body =>
    context.utf8Encoder(body)
  );
};

const buildHttpRpcRequest = (
  context: __SerdeContext,
  headers: __HeaderBag,
  path: string,
  resolvedHostname: string | undefined,
  body: any
): __HttpRequest => {
  const contents: any = {
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: path,
    headers: headers
  };
  if (resolvedHostname !== undefined) {
    contents.hostname = resolvedHostname;
  }
  if (body !== undefined) {
    contents.body = body;
  }
  return new __HttpRequest(contents);
};

const parseBody = (streamBody: any, context: __SerdeContext): any => {
  return collectBodyString(streamBody, context).then(encoded => {
    if (encoded.length) {
      const parsedObj = xmlParse(encoded, {
        attributeNamePrefix: "",
        ignoreAttributes: false,
        parseNodeValue: false
      });
      return parsedObj[Object.keys(parsedObj)[0]];
    }
    return {};
  });
};

const buildFormUrlencodedString = (entries: any): string => {
  return Object.keys(entries)
    .map(
      key =>
        __extendedEncodeURIComponent(key) +
        "=" +
        __extendedEncodeURIComponent(entries[key])
    )
    .join("&");
};

const loadQueryErrorCode = (output: __HttpResponse, data: any): string => {
  if (data.Error.Code !== undefined) {
    return data.Error.Code;
  }
  if (output.statusCode == 404) {
    return "NotFound";
  }
  return "";
};
