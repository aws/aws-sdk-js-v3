import {
  AssociateApprovalRuleTemplateWithRepositoryCommandInput,
  AssociateApprovalRuleTemplateWithRepositoryCommandOutput
} from "../commands/AssociateApprovalRuleTemplateWithRepositoryCommand";
import {
  BatchAssociateApprovalRuleTemplateWithRepositoriesCommandInput,
  BatchAssociateApprovalRuleTemplateWithRepositoriesCommandOutput
} from "../commands/BatchAssociateApprovalRuleTemplateWithRepositoriesCommand";
import {
  BatchDescribeMergeConflictsCommandInput,
  BatchDescribeMergeConflictsCommandOutput
} from "../commands/BatchDescribeMergeConflictsCommand";
import {
  BatchDisassociateApprovalRuleTemplateFromRepositoriesCommandInput,
  BatchDisassociateApprovalRuleTemplateFromRepositoriesCommandOutput
} from "../commands/BatchDisassociateApprovalRuleTemplateFromRepositoriesCommand";
import {
  BatchGetCommitsCommandInput,
  BatchGetCommitsCommandOutput
} from "../commands/BatchGetCommitsCommand";
import {
  BatchGetRepositoriesCommandInput,
  BatchGetRepositoriesCommandOutput
} from "../commands/BatchGetRepositoriesCommand";
import {
  CreateApprovalRuleTemplateCommandInput,
  CreateApprovalRuleTemplateCommandOutput
} from "../commands/CreateApprovalRuleTemplateCommand";
import {
  CreateBranchCommandInput,
  CreateBranchCommandOutput
} from "../commands/CreateBranchCommand";
import {
  CreateCommitCommandInput,
  CreateCommitCommandOutput
} from "../commands/CreateCommitCommand";
import {
  CreatePullRequestApprovalRuleCommandInput,
  CreatePullRequestApprovalRuleCommandOutput
} from "../commands/CreatePullRequestApprovalRuleCommand";
import {
  CreatePullRequestCommandInput,
  CreatePullRequestCommandOutput
} from "../commands/CreatePullRequestCommand";
import {
  CreateRepositoryCommandInput,
  CreateRepositoryCommandOutput
} from "../commands/CreateRepositoryCommand";
import {
  CreateUnreferencedMergeCommitCommandInput,
  CreateUnreferencedMergeCommitCommandOutput
} from "../commands/CreateUnreferencedMergeCommitCommand";
import {
  DeleteApprovalRuleTemplateCommandInput,
  DeleteApprovalRuleTemplateCommandOutput
} from "../commands/DeleteApprovalRuleTemplateCommand";
import {
  DeleteBranchCommandInput,
  DeleteBranchCommandOutput
} from "../commands/DeleteBranchCommand";
import {
  DeleteCommentContentCommandInput,
  DeleteCommentContentCommandOutput
} from "../commands/DeleteCommentContentCommand";
import {
  DeleteFileCommandInput,
  DeleteFileCommandOutput
} from "../commands/DeleteFileCommand";
import {
  DeletePullRequestApprovalRuleCommandInput,
  DeletePullRequestApprovalRuleCommandOutput
} from "../commands/DeletePullRequestApprovalRuleCommand";
import {
  DeleteRepositoryCommandInput,
  DeleteRepositoryCommandOutput
} from "../commands/DeleteRepositoryCommand";
import {
  DescribeMergeConflictsCommandInput,
  DescribeMergeConflictsCommandOutput
} from "../commands/DescribeMergeConflictsCommand";
import {
  DescribePullRequestEventsCommandInput,
  DescribePullRequestEventsCommandOutput
} from "../commands/DescribePullRequestEventsCommand";
import {
  DisassociateApprovalRuleTemplateFromRepositoryCommandInput,
  DisassociateApprovalRuleTemplateFromRepositoryCommandOutput
} from "../commands/DisassociateApprovalRuleTemplateFromRepositoryCommand";
import {
  EvaluatePullRequestApprovalRulesCommandInput,
  EvaluatePullRequestApprovalRulesCommandOutput
} from "../commands/EvaluatePullRequestApprovalRulesCommand";
import {
  GetApprovalRuleTemplateCommandInput,
  GetApprovalRuleTemplateCommandOutput
} from "../commands/GetApprovalRuleTemplateCommand";
import {
  GetBlobCommandInput,
  GetBlobCommandOutput
} from "../commands/GetBlobCommand";
import {
  GetBranchCommandInput,
  GetBranchCommandOutput
} from "../commands/GetBranchCommand";
import {
  GetCommentCommandInput,
  GetCommentCommandOutput
} from "../commands/GetCommentCommand";
import {
  GetCommentsForComparedCommitCommandInput,
  GetCommentsForComparedCommitCommandOutput
} from "../commands/GetCommentsForComparedCommitCommand";
import {
  GetCommentsForPullRequestCommandInput,
  GetCommentsForPullRequestCommandOutput
} from "../commands/GetCommentsForPullRequestCommand";
import {
  GetCommitCommandInput,
  GetCommitCommandOutput
} from "../commands/GetCommitCommand";
import {
  GetDifferencesCommandInput,
  GetDifferencesCommandOutput
} from "../commands/GetDifferencesCommand";
import {
  GetFileCommandInput,
  GetFileCommandOutput
} from "../commands/GetFileCommand";
import {
  GetFolderCommandInput,
  GetFolderCommandOutput
} from "../commands/GetFolderCommand";
import {
  GetMergeCommitCommandInput,
  GetMergeCommitCommandOutput
} from "../commands/GetMergeCommitCommand";
import {
  GetMergeConflictsCommandInput,
  GetMergeConflictsCommandOutput
} from "../commands/GetMergeConflictsCommand";
import {
  GetMergeOptionsCommandInput,
  GetMergeOptionsCommandOutput
} from "../commands/GetMergeOptionsCommand";
import {
  GetPullRequestApprovalStatesCommandInput,
  GetPullRequestApprovalStatesCommandOutput
} from "../commands/GetPullRequestApprovalStatesCommand";
import {
  GetPullRequestCommandInput,
  GetPullRequestCommandOutput
} from "../commands/GetPullRequestCommand";
import {
  GetPullRequestOverrideStateCommandInput,
  GetPullRequestOverrideStateCommandOutput
} from "../commands/GetPullRequestOverrideStateCommand";
import {
  GetRepositoryCommandInput,
  GetRepositoryCommandOutput
} from "../commands/GetRepositoryCommand";
import {
  GetRepositoryTriggersCommandInput,
  GetRepositoryTriggersCommandOutput
} from "../commands/GetRepositoryTriggersCommand";
import {
  ListApprovalRuleTemplatesCommandInput,
  ListApprovalRuleTemplatesCommandOutput
} from "../commands/ListApprovalRuleTemplatesCommand";
import {
  ListAssociatedApprovalRuleTemplatesForRepositoryCommandInput,
  ListAssociatedApprovalRuleTemplatesForRepositoryCommandOutput
} from "../commands/ListAssociatedApprovalRuleTemplatesForRepositoryCommand";
import {
  ListBranchesCommandInput,
  ListBranchesCommandOutput
} from "../commands/ListBranchesCommand";
import {
  ListPullRequestsCommandInput,
  ListPullRequestsCommandOutput
} from "../commands/ListPullRequestsCommand";
import {
  ListRepositoriesCommandInput,
  ListRepositoriesCommandOutput
} from "../commands/ListRepositoriesCommand";
import {
  ListRepositoriesForApprovalRuleTemplateCommandInput,
  ListRepositoriesForApprovalRuleTemplateCommandOutput
} from "../commands/ListRepositoriesForApprovalRuleTemplateCommand";
import {
  ListTagsForResourceCommandInput,
  ListTagsForResourceCommandOutput
} from "../commands/ListTagsForResourceCommand";
import {
  MergeBranchesByFastForwardCommandInput,
  MergeBranchesByFastForwardCommandOutput
} from "../commands/MergeBranchesByFastForwardCommand";
import {
  MergeBranchesBySquashCommandInput,
  MergeBranchesBySquashCommandOutput
} from "../commands/MergeBranchesBySquashCommand";
import {
  MergeBranchesByThreeWayCommandInput,
  MergeBranchesByThreeWayCommandOutput
} from "../commands/MergeBranchesByThreeWayCommand";
import {
  MergePullRequestByFastForwardCommandInput,
  MergePullRequestByFastForwardCommandOutput
} from "../commands/MergePullRequestByFastForwardCommand";
import {
  MergePullRequestBySquashCommandInput,
  MergePullRequestBySquashCommandOutput
} from "../commands/MergePullRequestBySquashCommand";
import {
  MergePullRequestByThreeWayCommandInput,
  MergePullRequestByThreeWayCommandOutput
} from "../commands/MergePullRequestByThreeWayCommand";
import {
  OverridePullRequestApprovalRulesCommandInput,
  OverridePullRequestApprovalRulesCommandOutput
} from "../commands/OverridePullRequestApprovalRulesCommand";
import {
  PostCommentForComparedCommitCommandInput,
  PostCommentForComparedCommitCommandOutput
} from "../commands/PostCommentForComparedCommitCommand";
import {
  PostCommentForPullRequestCommandInput,
  PostCommentForPullRequestCommandOutput
} from "../commands/PostCommentForPullRequestCommand";
import {
  PostCommentReplyCommandInput,
  PostCommentReplyCommandOutput
} from "../commands/PostCommentReplyCommand";
import {
  PutFileCommandInput,
  PutFileCommandOutput
} from "../commands/PutFileCommand";
import {
  PutRepositoryTriggersCommandInput,
  PutRepositoryTriggersCommandOutput
} from "../commands/PutRepositoryTriggersCommand";
import {
  TagResourceCommandInput,
  TagResourceCommandOutput
} from "../commands/TagResourceCommand";
import {
  TestRepositoryTriggersCommandInput,
  TestRepositoryTriggersCommandOutput
} from "../commands/TestRepositoryTriggersCommand";
import {
  UntagResourceCommandInput,
  UntagResourceCommandOutput
} from "../commands/UntagResourceCommand";
import {
  UpdateApprovalRuleTemplateContentCommandInput,
  UpdateApprovalRuleTemplateContentCommandOutput
} from "../commands/UpdateApprovalRuleTemplateContentCommand";
import {
  UpdateApprovalRuleTemplateDescriptionCommandInput,
  UpdateApprovalRuleTemplateDescriptionCommandOutput
} from "../commands/UpdateApprovalRuleTemplateDescriptionCommand";
import {
  UpdateApprovalRuleTemplateNameCommandInput,
  UpdateApprovalRuleTemplateNameCommandOutput
} from "../commands/UpdateApprovalRuleTemplateNameCommand";
import {
  UpdateCommentCommandInput,
  UpdateCommentCommandOutput
} from "../commands/UpdateCommentCommand";
import {
  UpdateDefaultBranchCommandInput,
  UpdateDefaultBranchCommandOutput
} from "../commands/UpdateDefaultBranchCommand";
import {
  UpdatePullRequestApprovalRuleContentCommandInput,
  UpdatePullRequestApprovalRuleContentCommandOutput
} from "../commands/UpdatePullRequestApprovalRuleContentCommand";
import {
  UpdatePullRequestApprovalStateCommandInput,
  UpdatePullRequestApprovalStateCommandOutput
} from "../commands/UpdatePullRequestApprovalStateCommand";
import {
  UpdatePullRequestDescriptionCommandInput,
  UpdatePullRequestDescriptionCommandOutput
} from "../commands/UpdatePullRequestDescriptionCommand";
import {
  UpdatePullRequestStatusCommandInput,
  UpdatePullRequestStatusCommandOutput
} from "../commands/UpdatePullRequestStatusCommand";
import {
  UpdatePullRequestTitleCommandInput,
  UpdatePullRequestTitleCommandOutput
} from "../commands/UpdatePullRequestTitleCommand";
import {
  UpdateRepositoryDescriptionCommandInput,
  UpdateRepositoryDescriptionCommandOutput
} from "../commands/UpdateRepositoryDescriptionCommand";
import {
  UpdateRepositoryNameCommandInput,
  UpdateRepositoryNameCommandOutput
} from "../commands/UpdateRepositoryNameCommand";
import {
  ActorDoesNotExistException,
  Approval,
  ApprovalRule,
  ApprovalRuleContentRequiredException,
  ApprovalRuleDoesNotExistException,
  ApprovalRuleEventMetadata,
  ApprovalRuleNameAlreadyExistsException,
  ApprovalRuleNameRequiredException,
  ApprovalRuleOverriddenEventMetadata,
  ApprovalRuleTemplate,
  ApprovalRuleTemplateContentRequiredException,
  ApprovalRuleTemplateDoesNotExistException,
  ApprovalRuleTemplateInUseException,
  ApprovalRuleTemplateNameAlreadyExistsException,
  ApprovalRuleTemplateNameRequiredException,
  ApprovalStateChangedEventMetadata,
  ApprovalStateRequiredException,
  AssociateApprovalRuleTemplateWithRepositoryInput,
  AuthorDoesNotExistException,
  BatchAssociateApprovalRuleTemplateWithRepositoriesError,
  BatchAssociateApprovalRuleTemplateWithRepositoriesInput,
  BatchAssociateApprovalRuleTemplateWithRepositoriesOutput,
  BatchDescribeMergeConflictsError,
  BatchDescribeMergeConflictsInput,
  BatchDescribeMergeConflictsOutput,
  BatchDisassociateApprovalRuleTemplateFromRepositoriesError,
  BatchDisassociateApprovalRuleTemplateFromRepositoriesInput,
  BatchDisassociateApprovalRuleTemplateFromRepositoriesOutput,
  BatchGetCommitsError,
  BatchGetCommitsInput,
  BatchGetCommitsOutput,
  BatchGetRepositoriesInput,
  BatchGetRepositoriesOutput,
  BeforeCommitIdAndAfterCommitIdAreSameException,
  BlobIdDoesNotExistException,
  BlobIdRequiredException,
  BlobMetadata,
  BranchDoesNotExistException,
  BranchInfo,
  BranchNameExistsException,
  BranchNameIsTagNameException,
  BranchNameRequiredException,
  CannotDeleteApprovalRuleFromTemplateException,
  CannotModifyApprovalRuleFromTemplateException,
  ClientRequestTokenRequiredException,
  Comment,
  CommentContentRequiredException,
  CommentContentSizeLimitExceededException,
  CommentDeletedException,
  CommentDoesNotExistException,
  CommentIdRequiredException,
  CommentNotCreatedByCallerException,
  CommentsForComparedCommit,
  CommentsForPullRequest,
  Commit,
  CommitDoesNotExistException,
  CommitIdDoesNotExistException,
  CommitIdRequiredException,
  CommitIdsLimitExceededException,
  CommitIdsListRequiredException,
  CommitMessageLengthExceededException,
  CommitRequiredException,
  ConcurrentReferenceUpdateException,
  Conflict,
  ConflictMetadata,
  ConflictResolution,
  CreateApprovalRuleTemplateInput,
  CreateApprovalRuleTemplateOutput,
  CreateBranchInput,
  CreateCommitInput,
  CreateCommitOutput,
  CreatePullRequestApprovalRuleInput,
  CreatePullRequestApprovalRuleOutput,
  CreatePullRequestInput,
  CreatePullRequestOutput,
  CreateRepositoryInput,
  CreateRepositoryOutput,
  CreateUnreferencedMergeCommitInput,
  CreateUnreferencedMergeCommitOutput,
  DefaultBranchCannotBeDeletedException,
  DeleteApprovalRuleTemplateInput,
  DeleteApprovalRuleTemplateOutput,
  DeleteBranchInput,
  DeleteBranchOutput,
  DeleteCommentContentInput,
  DeleteCommentContentOutput,
  DeleteFileEntry,
  DeleteFileInput,
  DeleteFileOutput,
  DeletePullRequestApprovalRuleInput,
  DeletePullRequestApprovalRuleOutput,
  DeleteRepositoryInput,
  DeleteRepositoryOutput,
  DescribeMergeConflictsInput,
  DescribeMergeConflictsOutput,
  DescribePullRequestEventsInput,
  DescribePullRequestEventsOutput,
  Difference,
  DirectoryNameConflictsWithFileNameException,
  DisassociateApprovalRuleTemplateFromRepositoryInput,
  EncryptionIntegrityChecksFailedException,
  EncryptionKeyAccessDeniedException,
  EncryptionKeyDisabledException,
  EncryptionKeyNotFoundException,
  EncryptionKeyUnavailableException,
  EvaluatePullRequestApprovalRulesInput,
  EvaluatePullRequestApprovalRulesOutput,
  Evaluation,
  File,
  FileContentAndSourceFileSpecifiedException,
  FileContentRequiredException,
  FileContentSizeLimitExceededException,
  FileDoesNotExistException,
  FileEntryRequiredException,
  FileMetadata,
  FileModeRequiredException,
  FileModes,
  FileNameConflictsWithDirectoryNameException,
  FilePathConflictsWithSubmodulePathException,
  FileSizes,
  FileTooLargeException,
  Folder,
  FolderContentSizeLimitExceededException,
  FolderDoesNotExistException,
  GetApprovalRuleTemplateInput,
  GetApprovalRuleTemplateOutput,
  GetBlobInput,
  GetBlobOutput,
  GetBranchInput,
  GetBranchOutput,
  GetCommentInput,
  GetCommentOutput,
  GetCommentsForComparedCommitInput,
  GetCommentsForComparedCommitOutput,
  GetCommentsForPullRequestInput,
  GetCommentsForPullRequestOutput,
  GetCommitInput,
  GetCommitOutput,
  GetDifferencesInput,
  GetDifferencesOutput,
  GetFileInput,
  GetFileOutput,
  GetFolderInput,
  GetFolderOutput,
  GetMergeCommitInput,
  GetMergeCommitOutput,
  GetMergeConflictsInput,
  GetMergeConflictsOutput,
  GetMergeOptionsInput,
  GetMergeOptionsOutput,
  GetPullRequestApprovalStatesInput,
  GetPullRequestApprovalStatesOutput,
  GetPullRequestInput,
  GetPullRequestOutput,
  GetPullRequestOverrideStateInput,
  GetPullRequestOverrideStateOutput,
  GetRepositoryInput,
  GetRepositoryOutput,
  GetRepositoryTriggersInput,
  GetRepositoryTriggersOutput,
  IdempotencyParameterMismatchException,
  InvalidActorArnException,
  InvalidApprovalRuleContentException,
  InvalidApprovalRuleNameException,
  InvalidApprovalRuleTemplateContentException,
  InvalidApprovalRuleTemplateDescriptionException,
  InvalidApprovalRuleTemplateNameException,
  InvalidApprovalStateException,
  InvalidAuthorArnException,
  InvalidBlobIdException,
  InvalidBranchNameException,
  InvalidClientRequestTokenException,
  InvalidCommentIdException,
  InvalidCommitException,
  InvalidCommitIdException,
  InvalidConflictDetailLevelException,
  InvalidConflictResolutionException,
  InvalidConflictResolutionStrategyException,
  InvalidContinuationTokenException,
  InvalidDeletionParameterException,
  InvalidDescriptionException,
  InvalidDestinationCommitSpecifierException,
  InvalidEmailException,
  InvalidFileLocationException,
  InvalidFileModeException,
  InvalidFilePositionException,
  InvalidMaxConflictFilesException,
  InvalidMaxMergeHunksException,
  InvalidMaxResultsException,
  InvalidMergeOptionException,
  InvalidOrderException,
  InvalidOverrideStatusException,
  InvalidParentCommitIdException,
  InvalidPathException,
  InvalidPullRequestEventTypeException,
  InvalidPullRequestIdException,
  InvalidPullRequestStatusException,
  InvalidPullRequestStatusUpdateException,
  InvalidReferenceNameException,
  InvalidRelativeFileVersionEnumException,
  InvalidReplacementContentException,
  InvalidReplacementTypeException,
  InvalidRepositoryDescriptionException,
  InvalidRepositoryNameException,
  InvalidRepositoryTriggerBranchNameException,
  InvalidRepositoryTriggerCustomDataException,
  InvalidRepositoryTriggerDestinationArnException,
  InvalidRepositoryTriggerEventsException,
  InvalidRepositoryTriggerNameException,
  InvalidRepositoryTriggerRegionException,
  InvalidResourceArnException,
  InvalidRevisionIdException,
  InvalidRuleContentSha256Exception,
  InvalidSortByException,
  InvalidSourceCommitSpecifierException,
  InvalidSystemTagUsageException,
  InvalidTagKeysListException,
  InvalidTagsMapException,
  InvalidTargetBranchException,
  InvalidTargetException,
  InvalidTargetsException,
  InvalidTitleException,
  IsBinaryFile,
  ListApprovalRuleTemplatesInput,
  ListApprovalRuleTemplatesOutput,
  ListAssociatedApprovalRuleTemplatesForRepositoryInput,
  ListAssociatedApprovalRuleTemplatesForRepositoryOutput,
  ListBranchesInput,
  ListBranchesOutput,
  ListPullRequestsInput,
  ListPullRequestsOutput,
  ListRepositoriesForApprovalRuleTemplateInput,
  ListRepositoriesForApprovalRuleTemplateOutput,
  ListRepositoriesInput,
  ListRepositoriesOutput,
  ListTagsForResourceInput,
  ListTagsForResourceOutput,
  Location,
  ManualMergeRequiredException,
  MaximumBranchesExceededException,
  MaximumConflictResolutionEntriesExceededException,
  MaximumFileContentToLoadExceededException,
  MaximumFileEntriesExceededException,
  MaximumItemsToCompareExceededException,
  MaximumNumberOfApprovalsExceededException,
  MaximumOpenPullRequestsExceededException,
  MaximumRepositoryNamesExceededException,
  MaximumRepositoryTriggersExceededException,
  MaximumRuleTemplatesAssociatedWithRepositoryException,
  MergeBranchesByFastForwardInput,
  MergeBranchesByFastForwardOutput,
  MergeBranchesBySquashInput,
  MergeBranchesBySquashOutput,
  MergeBranchesByThreeWayInput,
  MergeBranchesByThreeWayOutput,
  MergeHunk,
  MergeHunkDetail,
  MergeMetadata,
  MergeOperations,
  MergeOptionRequiredException,
  MergeOptionTypeEnum,
  MergePullRequestByFastForwardInput,
  MergePullRequestByFastForwardOutput,
  MergePullRequestBySquashInput,
  MergePullRequestBySquashOutput,
  MergePullRequestByThreeWayInput,
  MergePullRequestByThreeWayOutput,
  MultipleConflictResolutionEntriesException,
  MultipleRepositoriesInPullRequestException,
  NameLengthExceededException,
  NoChangeException,
  NumberOfRuleTemplatesExceededException,
  NumberOfRulesExceededException,
  ObjectTypes,
  OriginApprovalRuleTemplate,
  OverrideAlreadySetException,
  OverridePullRequestApprovalRulesInput,
  OverrideStatusRequiredException,
  ParentCommitDoesNotExistException,
  ParentCommitIdOutdatedException,
  ParentCommitIdRequiredException,
  PathDoesNotExistException,
  PathRequiredException,
  PostCommentForComparedCommitInput,
  PostCommentForComparedCommitOutput,
  PostCommentForPullRequestInput,
  PostCommentForPullRequestOutput,
  PostCommentReplyInput,
  PostCommentReplyOutput,
  PullRequest,
  PullRequestAlreadyClosedException,
  PullRequestApprovalRulesNotSatisfiedException,
  PullRequestCannotBeApprovedByAuthorException,
  PullRequestCreatedEventMetadata,
  PullRequestDoesNotExistException,
  PullRequestEvent,
  PullRequestIdRequiredException,
  PullRequestMergedStateChangedEventMetadata,
  PullRequestSourceReferenceUpdatedEventMetadata,
  PullRequestStatusChangedEventMetadata,
  PullRequestStatusRequiredException,
  PullRequestTarget,
  PutFileEntry,
  PutFileEntryConflictException,
  PutFileInput,
  PutFileOutput,
  PutRepositoryTriggersInput,
  PutRepositoryTriggersOutput,
  ReferenceDoesNotExistException,
  ReferenceNameRequiredException,
  ReferenceTypeNotSupportedException,
  ReplaceContentEntry,
  ReplacementContentRequiredException,
  ReplacementTypeRequiredException,
  RepositoryDoesNotExistException,
  RepositoryLimitExceededException,
  RepositoryMetadata,
  RepositoryNameExistsException,
  RepositoryNameIdPair,
  RepositoryNameRequiredException,
  RepositoryNamesRequiredException,
  RepositoryNotAssociatedWithPullRequestException,
  RepositoryTrigger,
  RepositoryTriggerBranchNameListRequiredException,
  RepositoryTriggerDestinationArnRequiredException,
  RepositoryTriggerEventEnum,
  RepositoryTriggerEventsListRequiredException,
  RepositoryTriggerExecutionFailure,
  RepositoryTriggerNameRequiredException,
  RepositoryTriggersListRequiredException,
  ResourceArnRequiredException,
  RestrictedSourceFileException,
  RevisionIdRequiredException,
  RevisionNotCurrentException,
  SameFileContentException,
  SamePathRequestException,
  SetFileModeEntry,
  SourceAndDestinationAreSameException,
  SourceFileOrContentRequiredException,
  SourceFileSpecifier,
  SubModule,
  SymbolicLink,
  TagKeysListRequiredException,
  TagPolicyException,
  TagResourceInput,
  TagsMapRequiredException,
  Target,
  TargetRequiredException,
  TargetsRequiredException,
  TestRepositoryTriggersInput,
  TestRepositoryTriggersOutput,
  TipOfSourceReferenceIsDifferentException,
  TipsDivergenceExceededException,
  TitleRequiredException,
  TooManyTagsException,
  UntagResourceInput,
  UpdateApprovalRuleTemplateContentInput,
  UpdateApprovalRuleTemplateContentOutput,
  UpdateApprovalRuleTemplateDescriptionInput,
  UpdateApprovalRuleTemplateDescriptionOutput,
  UpdateApprovalRuleTemplateNameInput,
  UpdateApprovalRuleTemplateNameOutput,
  UpdateCommentInput,
  UpdateCommentOutput,
  UpdateDefaultBranchInput,
  UpdatePullRequestApprovalRuleContentInput,
  UpdatePullRequestApprovalRuleContentOutput,
  UpdatePullRequestApprovalStateInput,
  UpdatePullRequestDescriptionInput,
  UpdatePullRequestDescriptionOutput,
  UpdatePullRequestStatusInput,
  UpdatePullRequestStatusOutput,
  UpdatePullRequestTitleInput,
  UpdatePullRequestTitleOutput,
  UpdateRepositoryDescriptionInput,
  UpdateRepositoryNameInput,
  UserInfo
} from "../models/index";
import {
  HttpRequest as __HttpRequest,
  HttpResponse as __HttpResponse
} from "@aws-sdk/protocol-http";
import { SmithyException as __SmithyException } from "@aws-sdk/smithy-client";
import {
  Endpoint as __Endpoint,
  HeaderBag as __HeaderBag,
  MetadataBearer as __MetadataBearer,
  ResponseMetadata as __ResponseMetadata,
  SerdeContext as __SerdeContext
} from "@aws-sdk/types";
import { v4 as generateIdempotencyToken } from "uuid";

export async function serializeAws_json1_1AssociateApprovalRuleTemplateWithRepositoryCommand(
  input: AssociateApprovalRuleTemplateWithRepositoryCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] =
    "CodeCommit_20150413.AssociateApprovalRuleTemplateWithRepository";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1AssociateApprovalRuleTemplateWithRepositoryInput(
      input,
      context
    )
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1BatchAssociateApprovalRuleTemplateWithRepositoriesCommand(
  input: BatchAssociateApprovalRuleTemplateWithRepositoriesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] =
    "CodeCommit_20150413.BatchAssociateApprovalRuleTemplateWithRepositories";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1BatchAssociateApprovalRuleTemplateWithRepositoriesInput(
      input,
      context
    )
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1BatchDescribeMergeConflictsCommand(
  input: BatchDescribeMergeConflictsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "CodeCommit_20150413.BatchDescribeMergeConflicts";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1BatchDescribeMergeConflictsInput(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1BatchDisassociateApprovalRuleTemplateFromRepositoriesCommand(
  input: BatchDisassociateApprovalRuleTemplateFromRepositoriesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] =
    "CodeCommit_20150413.BatchDisassociateApprovalRuleTemplateFromRepositories";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1BatchDisassociateApprovalRuleTemplateFromRepositoriesInput(
      input,
      context
    )
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1BatchGetCommitsCommand(
  input: BatchGetCommitsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "CodeCommit_20150413.BatchGetCommits";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1BatchGetCommitsInput(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1BatchGetRepositoriesCommand(
  input: BatchGetRepositoriesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "CodeCommit_20150413.BatchGetRepositories";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1BatchGetRepositoriesInput(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1CreateApprovalRuleTemplateCommand(
  input: CreateApprovalRuleTemplateCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "CodeCommit_20150413.CreateApprovalRuleTemplate";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1CreateApprovalRuleTemplateInput(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1CreateBranchCommand(
  input: CreateBranchCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "CodeCommit_20150413.CreateBranch";
  let body: any;
  body = JSON.stringify(serializeAws_json1_1CreateBranchInput(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1CreateCommitCommand(
  input: CreateCommitCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "CodeCommit_20150413.CreateCommit";
  let body: any;
  body = JSON.stringify(serializeAws_json1_1CreateCommitInput(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1CreatePullRequestCommand(
  input: CreatePullRequestCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "CodeCommit_20150413.CreatePullRequest";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1CreatePullRequestInput(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1CreatePullRequestApprovalRuleCommand(
  input: CreatePullRequestApprovalRuleCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "CodeCommit_20150413.CreatePullRequestApprovalRule";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1CreatePullRequestApprovalRuleInput(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1CreateRepositoryCommand(
  input: CreateRepositoryCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "CodeCommit_20150413.CreateRepository";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1CreateRepositoryInput(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1CreateUnreferencedMergeCommitCommand(
  input: CreateUnreferencedMergeCommitCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "CodeCommit_20150413.CreateUnreferencedMergeCommit";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1CreateUnreferencedMergeCommitInput(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DeleteApprovalRuleTemplateCommand(
  input: DeleteApprovalRuleTemplateCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "CodeCommit_20150413.DeleteApprovalRuleTemplate";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DeleteApprovalRuleTemplateInput(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DeleteBranchCommand(
  input: DeleteBranchCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "CodeCommit_20150413.DeleteBranch";
  let body: any;
  body = JSON.stringify(serializeAws_json1_1DeleteBranchInput(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DeleteCommentContentCommand(
  input: DeleteCommentContentCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "CodeCommit_20150413.DeleteCommentContent";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DeleteCommentContentInput(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DeleteFileCommand(
  input: DeleteFileCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "CodeCommit_20150413.DeleteFile";
  let body: any;
  body = JSON.stringify(serializeAws_json1_1DeleteFileInput(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DeletePullRequestApprovalRuleCommand(
  input: DeletePullRequestApprovalRuleCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "CodeCommit_20150413.DeletePullRequestApprovalRule";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DeletePullRequestApprovalRuleInput(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DeleteRepositoryCommand(
  input: DeleteRepositoryCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "CodeCommit_20150413.DeleteRepository";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DeleteRepositoryInput(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DescribeMergeConflictsCommand(
  input: DescribeMergeConflictsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "CodeCommit_20150413.DescribeMergeConflicts";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeMergeConflictsInput(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DescribePullRequestEventsCommand(
  input: DescribePullRequestEventsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "CodeCommit_20150413.DescribePullRequestEvents";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribePullRequestEventsInput(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DisassociateApprovalRuleTemplateFromRepositoryCommand(
  input: DisassociateApprovalRuleTemplateFromRepositoryCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] =
    "CodeCommit_20150413.DisassociateApprovalRuleTemplateFromRepository";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DisassociateApprovalRuleTemplateFromRepositoryInput(
      input,
      context
    )
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1EvaluatePullRequestApprovalRulesCommand(
  input: EvaluatePullRequestApprovalRulesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] =
    "CodeCommit_20150413.EvaluatePullRequestApprovalRules";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1EvaluatePullRequestApprovalRulesInput(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1GetApprovalRuleTemplateCommand(
  input: GetApprovalRuleTemplateCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "CodeCommit_20150413.GetApprovalRuleTemplate";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1GetApprovalRuleTemplateInput(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1GetBlobCommand(
  input: GetBlobCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "CodeCommit_20150413.GetBlob";
  let body: any;
  body = JSON.stringify(serializeAws_json1_1GetBlobInput(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1GetBranchCommand(
  input: GetBranchCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "CodeCommit_20150413.GetBranch";
  let body: any;
  body = JSON.stringify(serializeAws_json1_1GetBranchInput(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1GetCommentCommand(
  input: GetCommentCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "CodeCommit_20150413.GetComment";
  let body: any;
  body = JSON.stringify(serializeAws_json1_1GetCommentInput(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1GetCommentsForComparedCommitCommand(
  input: GetCommentsForComparedCommitCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "CodeCommit_20150413.GetCommentsForComparedCommit";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1GetCommentsForComparedCommitInput(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1GetCommentsForPullRequestCommand(
  input: GetCommentsForPullRequestCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "CodeCommit_20150413.GetCommentsForPullRequest";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1GetCommentsForPullRequestInput(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1GetCommitCommand(
  input: GetCommitCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "CodeCommit_20150413.GetCommit";
  let body: any;
  body = JSON.stringify(serializeAws_json1_1GetCommitInput(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1GetDifferencesCommand(
  input: GetDifferencesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "CodeCommit_20150413.GetDifferences";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1GetDifferencesInput(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1GetFileCommand(
  input: GetFileCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "CodeCommit_20150413.GetFile";
  let body: any;
  body = JSON.stringify(serializeAws_json1_1GetFileInput(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1GetFolderCommand(
  input: GetFolderCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "CodeCommit_20150413.GetFolder";
  let body: any;
  body = JSON.stringify(serializeAws_json1_1GetFolderInput(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1GetMergeCommitCommand(
  input: GetMergeCommitCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "CodeCommit_20150413.GetMergeCommit";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1GetMergeCommitInput(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1GetMergeConflictsCommand(
  input: GetMergeConflictsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "CodeCommit_20150413.GetMergeConflicts";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1GetMergeConflictsInput(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1GetMergeOptionsCommand(
  input: GetMergeOptionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "CodeCommit_20150413.GetMergeOptions";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1GetMergeOptionsInput(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1GetPullRequestCommand(
  input: GetPullRequestCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "CodeCommit_20150413.GetPullRequest";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1GetPullRequestInput(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1GetPullRequestApprovalStatesCommand(
  input: GetPullRequestApprovalStatesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "CodeCommit_20150413.GetPullRequestApprovalStates";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1GetPullRequestApprovalStatesInput(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1GetPullRequestOverrideStateCommand(
  input: GetPullRequestOverrideStateCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "CodeCommit_20150413.GetPullRequestOverrideState";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1GetPullRequestOverrideStateInput(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1GetRepositoryCommand(
  input: GetRepositoryCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "CodeCommit_20150413.GetRepository";
  let body: any;
  body = JSON.stringify(serializeAws_json1_1GetRepositoryInput(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1GetRepositoryTriggersCommand(
  input: GetRepositoryTriggersCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "CodeCommit_20150413.GetRepositoryTriggers";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1GetRepositoryTriggersInput(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1ListApprovalRuleTemplatesCommand(
  input: ListApprovalRuleTemplatesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "CodeCommit_20150413.ListApprovalRuleTemplates";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1ListApprovalRuleTemplatesInput(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1ListAssociatedApprovalRuleTemplatesForRepositoryCommand(
  input: ListAssociatedApprovalRuleTemplatesForRepositoryCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] =
    "CodeCommit_20150413.ListAssociatedApprovalRuleTemplatesForRepository";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1ListAssociatedApprovalRuleTemplatesForRepositoryInput(
      input,
      context
    )
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1ListBranchesCommand(
  input: ListBranchesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "CodeCommit_20150413.ListBranches";
  let body: any;
  body = JSON.stringify(serializeAws_json1_1ListBranchesInput(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1ListPullRequestsCommand(
  input: ListPullRequestsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "CodeCommit_20150413.ListPullRequests";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1ListPullRequestsInput(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1ListRepositoriesCommand(
  input: ListRepositoriesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "CodeCommit_20150413.ListRepositories";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1ListRepositoriesInput(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1ListRepositoriesForApprovalRuleTemplateCommand(
  input: ListRepositoriesForApprovalRuleTemplateCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] =
    "CodeCommit_20150413.ListRepositoriesForApprovalRuleTemplate";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1ListRepositoriesForApprovalRuleTemplateInput(
      input,
      context
    )
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1ListTagsForResourceCommand(
  input: ListTagsForResourceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "CodeCommit_20150413.ListTagsForResource";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1ListTagsForResourceInput(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1MergeBranchesByFastForwardCommand(
  input: MergeBranchesByFastForwardCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "CodeCommit_20150413.MergeBranchesByFastForward";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1MergeBranchesByFastForwardInput(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1MergeBranchesBySquashCommand(
  input: MergeBranchesBySquashCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "CodeCommit_20150413.MergeBranchesBySquash";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1MergeBranchesBySquashInput(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1MergeBranchesByThreeWayCommand(
  input: MergeBranchesByThreeWayCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "CodeCommit_20150413.MergeBranchesByThreeWay";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1MergeBranchesByThreeWayInput(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1MergePullRequestByFastForwardCommand(
  input: MergePullRequestByFastForwardCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "CodeCommit_20150413.MergePullRequestByFastForward";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1MergePullRequestByFastForwardInput(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1MergePullRequestBySquashCommand(
  input: MergePullRequestBySquashCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "CodeCommit_20150413.MergePullRequestBySquash";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1MergePullRequestBySquashInput(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1MergePullRequestByThreeWayCommand(
  input: MergePullRequestByThreeWayCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "CodeCommit_20150413.MergePullRequestByThreeWay";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1MergePullRequestByThreeWayInput(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1OverridePullRequestApprovalRulesCommand(
  input: OverridePullRequestApprovalRulesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] =
    "CodeCommit_20150413.OverridePullRequestApprovalRules";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1OverridePullRequestApprovalRulesInput(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1PostCommentForComparedCommitCommand(
  input: PostCommentForComparedCommitCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "CodeCommit_20150413.PostCommentForComparedCommit";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1PostCommentForComparedCommitInput(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1PostCommentForPullRequestCommand(
  input: PostCommentForPullRequestCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "CodeCommit_20150413.PostCommentForPullRequest";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1PostCommentForPullRequestInput(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1PostCommentReplyCommand(
  input: PostCommentReplyCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "CodeCommit_20150413.PostCommentReply";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1PostCommentReplyInput(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1PutFileCommand(
  input: PutFileCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "CodeCommit_20150413.PutFile";
  let body: any;
  body = JSON.stringify(serializeAws_json1_1PutFileInput(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1PutRepositoryTriggersCommand(
  input: PutRepositoryTriggersCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "CodeCommit_20150413.PutRepositoryTriggers";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1PutRepositoryTriggersInput(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1TagResourceCommand(
  input: TagResourceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "CodeCommit_20150413.TagResource";
  let body: any;
  body = JSON.stringify(serializeAws_json1_1TagResourceInput(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1TestRepositoryTriggersCommand(
  input: TestRepositoryTriggersCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "CodeCommit_20150413.TestRepositoryTriggers";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1TestRepositoryTriggersInput(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1UntagResourceCommand(
  input: UntagResourceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "CodeCommit_20150413.UntagResource";
  let body: any;
  body = JSON.stringify(serializeAws_json1_1UntagResourceInput(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1UpdateApprovalRuleTemplateContentCommand(
  input: UpdateApprovalRuleTemplateContentCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] =
    "CodeCommit_20150413.UpdateApprovalRuleTemplateContent";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1UpdateApprovalRuleTemplateContentInput(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1UpdateApprovalRuleTemplateDescriptionCommand(
  input: UpdateApprovalRuleTemplateDescriptionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] =
    "CodeCommit_20150413.UpdateApprovalRuleTemplateDescription";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1UpdateApprovalRuleTemplateDescriptionInput(
      input,
      context
    )
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1UpdateApprovalRuleTemplateNameCommand(
  input: UpdateApprovalRuleTemplateNameCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] =
    "CodeCommit_20150413.UpdateApprovalRuleTemplateName";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1UpdateApprovalRuleTemplateNameInput(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1UpdateCommentCommand(
  input: UpdateCommentCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "CodeCommit_20150413.UpdateComment";
  let body: any;
  body = JSON.stringify(serializeAws_json1_1UpdateCommentInput(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1UpdateDefaultBranchCommand(
  input: UpdateDefaultBranchCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "CodeCommit_20150413.UpdateDefaultBranch";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1UpdateDefaultBranchInput(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1UpdatePullRequestApprovalRuleContentCommand(
  input: UpdatePullRequestApprovalRuleContentCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] =
    "CodeCommit_20150413.UpdatePullRequestApprovalRuleContent";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1UpdatePullRequestApprovalRuleContentInput(
      input,
      context
    )
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1UpdatePullRequestApprovalStateCommand(
  input: UpdatePullRequestApprovalStateCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] =
    "CodeCommit_20150413.UpdatePullRequestApprovalState";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1UpdatePullRequestApprovalStateInput(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1UpdatePullRequestDescriptionCommand(
  input: UpdatePullRequestDescriptionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "CodeCommit_20150413.UpdatePullRequestDescription";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1UpdatePullRequestDescriptionInput(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1UpdatePullRequestStatusCommand(
  input: UpdatePullRequestStatusCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "CodeCommit_20150413.UpdatePullRequestStatus";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1UpdatePullRequestStatusInput(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1UpdatePullRequestTitleCommand(
  input: UpdatePullRequestTitleCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "CodeCommit_20150413.UpdatePullRequestTitle";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1UpdatePullRequestTitleInput(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1UpdateRepositoryDescriptionCommand(
  input: UpdateRepositoryDescriptionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "CodeCommit_20150413.UpdateRepositoryDescription";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1UpdateRepositoryDescriptionInput(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1UpdateRepositoryNameCommand(
  input: UpdateRepositoryNameCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "CodeCommit_20150413.UpdateRepositoryName";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1UpdateRepositoryNameInput(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function deserializeAws_json1_1AssociateApprovalRuleTemplateWithRepositoryCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AssociateApprovalRuleTemplateWithRepositoryCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1AssociateApprovalRuleTemplateWithRepositoryCommandError(
      output,
      context
    );
  }
  await collectBody(output.body, context);
  const response: AssociateApprovalRuleTemplateWithRepositoryCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1AssociateApprovalRuleTemplateWithRepositoryCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AssociateApprovalRuleTemplateWithRepositoryCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ApprovalRuleTemplateDoesNotExistException":
    case "com.amazonaws.codecommit#ApprovalRuleTemplateDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1ApprovalRuleTemplateDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ApprovalRuleTemplateNameRequiredException":
    case "com.amazonaws.codecommit#ApprovalRuleTemplateNameRequiredException":
      response = {
        ...(await deserializeAws_json1_1ApprovalRuleTemplateNameRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionIntegrityChecksFailedException":
    case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionIntegrityChecksFailedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyAccessDeniedException":
    case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyAccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyDisabledException":
    case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyDisabledExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyNotFoundException":
    case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyUnavailableException":
    case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyUnavailableExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidApprovalRuleTemplateNameException":
    case "com.amazonaws.codecommit#InvalidApprovalRuleTemplateNameException":
      response = {
        ...(await deserializeAws_json1_1InvalidApprovalRuleTemplateNameExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRepositoryNameException":
    case "com.amazonaws.codecommit#InvalidRepositoryNameException":
      response = {
        ...(await deserializeAws_json1_1InvalidRepositoryNameExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MaximumRuleTemplatesAssociatedWithRepositoryException":
    case "com.amazonaws.codecommit#MaximumRuleTemplatesAssociatedWithRepositoryException":
      response = {
        ...(await deserializeAws_json1_1MaximumRuleTemplatesAssociatedWithRepositoryExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryDoesNotExistException":
    case "com.amazonaws.codecommit#RepositoryDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1RepositoryDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryNameRequiredException":
    case "com.amazonaws.codecommit#RepositoryNameRequiredException":
      response = {
        ...(await deserializeAws_json1_1RepositoryNameRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1BatchAssociateApprovalRuleTemplateWithRepositoriesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchAssociateApprovalRuleTemplateWithRepositoriesCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1BatchAssociateApprovalRuleTemplateWithRepositoriesCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1BatchAssociateApprovalRuleTemplateWithRepositoriesOutput(
    data,
    context
  );
  const response: BatchAssociateApprovalRuleTemplateWithRepositoriesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "BatchAssociateApprovalRuleTemplateWithRepositoriesOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1BatchAssociateApprovalRuleTemplateWithRepositoriesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchAssociateApprovalRuleTemplateWithRepositoriesCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ApprovalRuleTemplateDoesNotExistException":
    case "com.amazonaws.codecommit#ApprovalRuleTemplateDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1ApprovalRuleTemplateDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ApprovalRuleTemplateNameRequiredException":
    case "com.amazonaws.codecommit#ApprovalRuleTemplateNameRequiredException":
      response = {
        ...(await deserializeAws_json1_1ApprovalRuleTemplateNameRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionIntegrityChecksFailedException":
    case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionIntegrityChecksFailedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyAccessDeniedException":
    case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyAccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyDisabledException":
    case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyDisabledExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyNotFoundException":
    case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyUnavailableException":
    case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyUnavailableExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidApprovalRuleTemplateNameException":
    case "com.amazonaws.codecommit#InvalidApprovalRuleTemplateNameException":
      response = {
        ...(await deserializeAws_json1_1InvalidApprovalRuleTemplateNameExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MaximumRepositoryNamesExceededException":
    case "com.amazonaws.codecommit#MaximumRepositoryNamesExceededException":
      response = {
        ...(await deserializeAws_json1_1MaximumRepositoryNamesExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryNamesRequiredException":
    case "com.amazonaws.codecommit#RepositoryNamesRequiredException":
      response = {
        ...(await deserializeAws_json1_1RepositoryNamesRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1BatchDescribeMergeConflictsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchDescribeMergeConflictsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1BatchDescribeMergeConflictsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1BatchDescribeMergeConflictsOutput(
    data,
    context
  );
  const response: BatchDescribeMergeConflictsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "BatchDescribeMergeConflictsOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1BatchDescribeMergeConflictsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchDescribeMergeConflictsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "CommitDoesNotExistException":
    case "com.amazonaws.codecommit#CommitDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1CommitDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "CommitRequiredException":
    case "com.amazonaws.codecommit#CommitRequiredException":
      response = {
        ...(await deserializeAws_json1_1CommitRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionIntegrityChecksFailedException":
    case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionIntegrityChecksFailedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyAccessDeniedException":
    case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyAccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyDisabledException":
    case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyDisabledExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyNotFoundException":
    case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyUnavailableException":
    case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyUnavailableExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidCommitException":
    case "com.amazonaws.codecommit#InvalidCommitException":
      response = {
        ...(await deserializeAws_json1_1InvalidCommitExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidConflictDetailLevelException":
    case "com.amazonaws.codecommit#InvalidConflictDetailLevelException":
      response = {
        ...(await deserializeAws_json1_1InvalidConflictDetailLevelExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidConflictResolutionStrategyException":
    case "com.amazonaws.codecommit#InvalidConflictResolutionStrategyException":
      response = {
        ...(await deserializeAws_json1_1InvalidConflictResolutionStrategyExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidContinuationTokenException":
    case "com.amazonaws.codecommit#InvalidContinuationTokenException":
      response = {
        ...(await deserializeAws_json1_1InvalidContinuationTokenExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidMaxConflictFilesException":
    case "com.amazonaws.codecommit#InvalidMaxConflictFilesException":
      response = {
        ...(await deserializeAws_json1_1InvalidMaxConflictFilesExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidMaxMergeHunksException":
    case "com.amazonaws.codecommit#InvalidMaxMergeHunksException":
      response = {
        ...(await deserializeAws_json1_1InvalidMaxMergeHunksExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidMergeOptionException":
    case "com.amazonaws.codecommit#InvalidMergeOptionException":
      response = {
        ...(await deserializeAws_json1_1InvalidMergeOptionExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRepositoryNameException":
    case "com.amazonaws.codecommit#InvalidRepositoryNameException":
      response = {
        ...(await deserializeAws_json1_1InvalidRepositoryNameExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MaximumFileContentToLoadExceededException":
    case "com.amazonaws.codecommit#MaximumFileContentToLoadExceededException":
      response = {
        ...(await deserializeAws_json1_1MaximumFileContentToLoadExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MaximumItemsToCompareExceededException":
    case "com.amazonaws.codecommit#MaximumItemsToCompareExceededException":
      response = {
        ...(await deserializeAws_json1_1MaximumItemsToCompareExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MergeOptionRequiredException":
    case "com.amazonaws.codecommit#MergeOptionRequiredException":
      response = {
        ...(await deserializeAws_json1_1MergeOptionRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryDoesNotExistException":
    case "com.amazonaws.codecommit#RepositoryDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1RepositoryDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryNameRequiredException":
    case "com.amazonaws.codecommit#RepositoryNameRequiredException":
      response = {
        ...(await deserializeAws_json1_1RepositoryNameRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TipsDivergenceExceededException":
    case "com.amazonaws.codecommit#TipsDivergenceExceededException":
      response = {
        ...(await deserializeAws_json1_1TipsDivergenceExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1BatchDisassociateApprovalRuleTemplateFromRepositoriesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchDisassociateApprovalRuleTemplateFromRepositoriesCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1BatchDisassociateApprovalRuleTemplateFromRepositoriesCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1BatchDisassociateApprovalRuleTemplateFromRepositoriesOutput(
    data,
    context
  );
  const response: BatchDisassociateApprovalRuleTemplateFromRepositoriesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "BatchDisassociateApprovalRuleTemplateFromRepositoriesOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1BatchDisassociateApprovalRuleTemplateFromRepositoriesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchDisassociateApprovalRuleTemplateFromRepositoriesCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ApprovalRuleTemplateDoesNotExistException":
    case "com.amazonaws.codecommit#ApprovalRuleTemplateDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1ApprovalRuleTemplateDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ApprovalRuleTemplateNameRequiredException":
    case "com.amazonaws.codecommit#ApprovalRuleTemplateNameRequiredException":
      response = {
        ...(await deserializeAws_json1_1ApprovalRuleTemplateNameRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionIntegrityChecksFailedException":
    case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionIntegrityChecksFailedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyAccessDeniedException":
    case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyAccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyDisabledException":
    case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyDisabledExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyNotFoundException":
    case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyUnavailableException":
    case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyUnavailableExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidApprovalRuleTemplateNameException":
    case "com.amazonaws.codecommit#InvalidApprovalRuleTemplateNameException":
      response = {
        ...(await deserializeAws_json1_1InvalidApprovalRuleTemplateNameExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MaximumRepositoryNamesExceededException":
    case "com.amazonaws.codecommit#MaximumRepositoryNamesExceededException":
      response = {
        ...(await deserializeAws_json1_1MaximumRepositoryNamesExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryNamesRequiredException":
    case "com.amazonaws.codecommit#RepositoryNamesRequiredException":
      response = {
        ...(await deserializeAws_json1_1RepositoryNamesRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1BatchGetCommitsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchGetCommitsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1BatchGetCommitsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1BatchGetCommitsOutput(data, context);
  const response: BatchGetCommitsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "BatchGetCommitsOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1BatchGetCommitsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchGetCommitsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "CommitIdsLimitExceededException":
    case "com.amazonaws.codecommit#CommitIdsLimitExceededException":
      response = {
        ...(await deserializeAws_json1_1CommitIdsLimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "CommitIdsListRequiredException":
    case "com.amazonaws.codecommit#CommitIdsListRequiredException":
      response = {
        ...(await deserializeAws_json1_1CommitIdsListRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionIntegrityChecksFailedException":
    case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionIntegrityChecksFailedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyAccessDeniedException":
    case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyAccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyDisabledException":
    case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyDisabledExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyNotFoundException":
    case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyUnavailableException":
    case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyUnavailableExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRepositoryNameException":
    case "com.amazonaws.codecommit#InvalidRepositoryNameException":
      response = {
        ...(await deserializeAws_json1_1InvalidRepositoryNameExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryDoesNotExistException":
    case "com.amazonaws.codecommit#RepositoryDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1RepositoryDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryNameRequiredException":
    case "com.amazonaws.codecommit#RepositoryNameRequiredException":
      response = {
        ...(await deserializeAws_json1_1RepositoryNameRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1BatchGetRepositoriesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchGetRepositoriesCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1BatchGetRepositoriesCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1BatchGetRepositoriesOutput(data, context);
  const response: BatchGetRepositoriesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "BatchGetRepositoriesOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1BatchGetRepositoriesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchGetRepositoriesCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EncryptionIntegrityChecksFailedException":
    case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionIntegrityChecksFailedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyAccessDeniedException":
    case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyAccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyDisabledException":
    case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyDisabledExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyNotFoundException":
    case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyUnavailableException":
    case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyUnavailableExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRepositoryNameException":
    case "com.amazonaws.codecommit#InvalidRepositoryNameException":
      response = {
        ...(await deserializeAws_json1_1InvalidRepositoryNameExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MaximumRepositoryNamesExceededException":
    case "com.amazonaws.codecommit#MaximumRepositoryNamesExceededException":
      response = {
        ...(await deserializeAws_json1_1MaximumRepositoryNamesExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryNamesRequiredException":
    case "com.amazonaws.codecommit#RepositoryNamesRequiredException":
      response = {
        ...(await deserializeAws_json1_1RepositoryNamesRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreateApprovalRuleTemplateCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateApprovalRuleTemplateCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateApprovalRuleTemplateCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateApprovalRuleTemplateOutput(
    data,
    context
  );
  const response: CreateApprovalRuleTemplateCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateApprovalRuleTemplateOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateApprovalRuleTemplateCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateApprovalRuleTemplateCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ApprovalRuleTemplateContentRequiredException":
    case "com.amazonaws.codecommit#ApprovalRuleTemplateContentRequiredException":
      response = {
        ...(await deserializeAws_json1_1ApprovalRuleTemplateContentRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ApprovalRuleTemplateNameAlreadyExistsException":
    case "com.amazonaws.codecommit#ApprovalRuleTemplateNameAlreadyExistsException":
      response = {
        ...(await deserializeAws_json1_1ApprovalRuleTemplateNameAlreadyExistsExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ApprovalRuleTemplateNameRequiredException":
    case "com.amazonaws.codecommit#ApprovalRuleTemplateNameRequiredException":
      response = {
        ...(await deserializeAws_json1_1ApprovalRuleTemplateNameRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidApprovalRuleTemplateContentException":
    case "com.amazonaws.codecommit#InvalidApprovalRuleTemplateContentException":
      response = {
        ...(await deserializeAws_json1_1InvalidApprovalRuleTemplateContentExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidApprovalRuleTemplateDescriptionException":
    case "com.amazonaws.codecommit#InvalidApprovalRuleTemplateDescriptionException":
      response = {
        ...(await deserializeAws_json1_1InvalidApprovalRuleTemplateDescriptionExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidApprovalRuleTemplateNameException":
    case "com.amazonaws.codecommit#InvalidApprovalRuleTemplateNameException":
      response = {
        ...(await deserializeAws_json1_1InvalidApprovalRuleTemplateNameExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NumberOfRuleTemplatesExceededException":
    case "com.amazonaws.codecommit#NumberOfRuleTemplatesExceededException":
      response = {
        ...(await deserializeAws_json1_1NumberOfRuleTemplatesExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreateBranchCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateBranchCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateBranchCommandError(output, context);
  }
  await collectBody(output.body, context);
  const response: CreateBranchCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateBranchCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateBranchCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "BranchNameExistsException":
    case "com.amazonaws.codecommit#BranchNameExistsException":
      response = {
        ...(await deserializeAws_json1_1BranchNameExistsExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "BranchNameRequiredException":
    case "com.amazonaws.codecommit#BranchNameRequiredException":
      response = {
        ...(await deserializeAws_json1_1BranchNameRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "CommitDoesNotExistException":
    case "com.amazonaws.codecommit#CommitDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1CommitDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "CommitIdRequiredException":
    case "com.amazonaws.codecommit#CommitIdRequiredException":
      response = {
        ...(await deserializeAws_json1_1CommitIdRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionIntegrityChecksFailedException":
    case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionIntegrityChecksFailedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyAccessDeniedException":
    case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyAccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyDisabledException":
    case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyDisabledExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyNotFoundException":
    case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyUnavailableException":
    case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyUnavailableExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidBranchNameException":
    case "com.amazonaws.codecommit#InvalidBranchNameException":
      response = {
        ...(await deserializeAws_json1_1InvalidBranchNameExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidCommitIdException":
    case "com.amazonaws.codecommit#InvalidCommitIdException":
      response = {
        ...(await deserializeAws_json1_1InvalidCommitIdExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRepositoryNameException":
    case "com.amazonaws.codecommit#InvalidRepositoryNameException":
      response = {
        ...(await deserializeAws_json1_1InvalidRepositoryNameExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryDoesNotExistException":
    case "com.amazonaws.codecommit#RepositoryDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1RepositoryDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryNameRequiredException":
    case "com.amazonaws.codecommit#RepositoryNameRequiredException":
      response = {
        ...(await deserializeAws_json1_1RepositoryNameRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreateCommitCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateCommitCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateCommitCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateCommitOutput(data, context);
  const response: CreateCommitCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateCommitOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateCommitCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateCommitCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "BranchDoesNotExistException":
    case "com.amazonaws.codecommit#BranchDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1BranchDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "BranchNameIsTagNameException":
    case "com.amazonaws.codecommit#BranchNameIsTagNameException":
      response = {
        ...(await deserializeAws_json1_1BranchNameIsTagNameExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "BranchNameRequiredException":
    case "com.amazonaws.codecommit#BranchNameRequiredException":
      response = {
        ...(await deserializeAws_json1_1BranchNameRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "CommitMessageLengthExceededException":
    case "com.amazonaws.codecommit#CommitMessageLengthExceededException":
      response = {
        ...(await deserializeAws_json1_1CommitMessageLengthExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DirectoryNameConflictsWithFileNameException":
    case "com.amazonaws.codecommit#DirectoryNameConflictsWithFileNameException":
      response = {
        ...(await deserializeAws_json1_1DirectoryNameConflictsWithFileNameExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionIntegrityChecksFailedException":
    case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionIntegrityChecksFailedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyAccessDeniedException":
    case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyAccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyDisabledException":
    case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyDisabledExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyNotFoundException":
    case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyUnavailableException":
    case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyUnavailableExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "FileContentAndSourceFileSpecifiedException":
    case "com.amazonaws.codecommit#FileContentAndSourceFileSpecifiedException":
      response = {
        ...(await deserializeAws_json1_1FileContentAndSourceFileSpecifiedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "FileContentSizeLimitExceededException":
    case "com.amazonaws.codecommit#FileContentSizeLimitExceededException":
      response = {
        ...(await deserializeAws_json1_1FileContentSizeLimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "FileDoesNotExistException":
    case "com.amazonaws.codecommit#FileDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1FileDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "FileEntryRequiredException":
    case "com.amazonaws.codecommit#FileEntryRequiredException":
      response = {
        ...(await deserializeAws_json1_1FileEntryRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "FileModeRequiredException":
    case "com.amazonaws.codecommit#FileModeRequiredException":
      response = {
        ...(await deserializeAws_json1_1FileModeRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "FileNameConflictsWithDirectoryNameException":
    case "com.amazonaws.codecommit#FileNameConflictsWithDirectoryNameException":
      response = {
        ...(await deserializeAws_json1_1FileNameConflictsWithDirectoryNameExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "FilePathConflictsWithSubmodulePathException":
    case "com.amazonaws.codecommit#FilePathConflictsWithSubmodulePathException":
      response = {
        ...(await deserializeAws_json1_1FilePathConflictsWithSubmodulePathExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "FolderContentSizeLimitExceededException":
    case "com.amazonaws.codecommit#FolderContentSizeLimitExceededException":
      response = {
        ...(await deserializeAws_json1_1FolderContentSizeLimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidBranchNameException":
    case "com.amazonaws.codecommit#InvalidBranchNameException":
      response = {
        ...(await deserializeAws_json1_1InvalidBranchNameExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDeletionParameterException":
    case "com.amazonaws.codecommit#InvalidDeletionParameterException":
      response = {
        ...(await deserializeAws_json1_1InvalidDeletionParameterExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidEmailException":
    case "com.amazonaws.codecommit#InvalidEmailException":
      response = {
        ...(await deserializeAws_json1_1InvalidEmailExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidFileModeException":
    case "com.amazonaws.codecommit#InvalidFileModeException":
      response = {
        ...(await deserializeAws_json1_1InvalidFileModeExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidParentCommitIdException":
    case "com.amazonaws.codecommit#InvalidParentCommitIdException":
      response = {
        ...(await deserializeAws_json1_1InvalidParentCommitIdExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidPathException":
    case "com.amazonaws.codecommit#InvalidPathException":
      response = {
        ...(await deserializeAws_json1_1InvalidPathExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRepositoryNameException":
    case "com.amazonaws.codecommit#InvalidRepositoryNameException":
      response = {
        ...(await deserializeAws_json1_1InvalidRepositoryNameExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MaximumFileEntriesExceededException":
    case "com.amazonaws.codecommit#MaximumFileEntriesExceededException":
      response = {
        ...(await deserializeAws_json1_1MaximumFileEntriesExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NameLengthExceededException":
    case "com.amazonaws.codecommit#NameLengthExceededException":
      response = {
        ...(await deserializeAws_json1_1NameLengthExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NoChangeException":
    case "com.amazonaws.codecommit#NoChangeException":
      response = {
        ...(await deserializeAws_json1_1NoChangeExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ParentCommitDoesNotExistException":
    case "com.amazonaws.codecommit#ParentCommitDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1ParentCommitDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ParentCommitIdOutdatedException":
    case "com.amazonaws.codecommit#ParentCommitIdOutdatedException":
      response = {
        ...(await deserializeAws_json1_1ParentCommitIdOutdatedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ParentCommitIdRequiredException":
    case "com.amazonaws.codecommit#ParentCommitIdRequiredException":
      response = {
        ...(await deserializeAws_json1_1ParentCommitIdRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "PathRequiredException":
    case "com.amazonaws.codecommit#PathRequiredException":
      response = {
        ...(await deserializeAws_json1_1PathRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "PutFileEntryConflictException":
    case "com.amazonaws.codecommit#PutFileEntryConflictException":
      response = {
        ...(await deserializeAws_json1_1PutFileEntryConflictExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryDoesNotExistException":
    case "com.amazonaws.codecommit#RepositoryDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1RepositoryDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryNameRequiredException":
    case "com.amazonaws.codecommit#RepositoryNameRequiredException":
      response = {
        ...(await deserializeAws_json1_1RepositoryNameRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RestrictedSourceFileException":
    case "com.amazonaws.codecommit#RestrictedSourceFileException":
      response = {
        ...(await deserializeAws_json1_1RestrictedSourceFileExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "SamePathRequestException":
    case "com.amazonaws.codecommit#SamePathRequestException":
      response = {
        ...(await deserializeAws_json1_1SamePathRequestExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "SourceFileOrContentRequiredException":
    case "com.amazonaws.codecommit#SourceFileOrContentRequiredException":
      response = {
        ...(await deserializeAws_json1_1SourceFileOrContentRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreatePullRequestCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreatePullRequestCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreatePullRequestCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreatePullRequestOutput(data, context);
  const response: CreatePullRequestCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreatePullRequestOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreatePullRequestCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreatePullRequestCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ClientRequestTokenRequiredException":
    case "com.amazonaws.codecommit#ClientRequestTokenRequiredException":
      response = {
        ...(await deserializeAws_json1_1ClientRequestTokenRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionIntegrityChecksFailedException":
    case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionIntegrityChecksFailedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyAccessDeniedException":
    case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyAccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyDisabledException":
    case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyDisabledExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyNotFoundException":
    case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyUnavailableException":
    case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyUnavailableExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "IdempotencyParameterMismatchException":
    case "com.amazonaws.codecommit#IdempotencyParameterMismatchException":
      response = {
        ...(await deserializeAws_json1_1IdempotencyParameterMismatchExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidClientRequestTokenException":
    case "com.amazonaws.codecommit#InvalidClientRequestTokenException":
      response = {
        ...(await deserializeAws_json1_1InvalidClientRequestTokenExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDescriptionException":
    case "com.amazonaws.codecommit#InvalidDescriptionException":
      response = {
        ...(await deserializeAws_json1_1InvalidDescriptionExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidReferenceNameException":
    case "com.amazonaws.codecommit#InvalidReferenceNameException":
      response = {
        ...(await deserializeAws_json1_1InvalidReferenceNameExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRepositoryNameException":
    case "com.amazonaws.codecommit#InvalidRepositoryNameException":
      response = {
        ...(await deserializeAws_json1_1InvalidRepositoryNameExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidTargetException":
    case "com.amazonaws.codecommit#InvalidTargetException":
      response = {
        ...(await deserializeAws_json1_1InvalidTargetExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidTargetsException":
    case "com.amazonaws.codecommit#InvalidTargetsException":
      response = {
        ...(await deserializeAws_json1_1InvalidTargetsExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidTitleException":
    case "com.amazonaws.codecommit#InvalidTitleException":
      response = {
        ...(await deserializeAws_json1_1InvalidTitleExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MaximumOpenPullRequestsExceededException":
    case "com.amazonaws.codecommit#MaximumOpenPullRequestsExceededException":
      response = {
        ...(await deserializeAws_json1_1MaximumOpenPullRequestsExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MultipleRepositoriesInPullRequestException":
    case "com.amazonaws.codecommit#MultipleRepositoriesInPullRequestException":
      response = {
        ...(await deserializeAws_json1_1MultipleRepositoriesInPullRequestExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ReferenceDoesNotExistException":
    case "com.amazonaws.codecommit#ReferenceDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1ReferenceDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ReferenceNameRequiredException":
    case "com.amazonaws.codecommit#ReferenceNameRequiredException":
      response = {
        ...(await deserializeAws_json1_1ReferenceNameRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ReferenceTypeNotSupportedException":
    case "com.amazonaws.codecommit#ReferenceTypeNotSupportedException":
      response = {
        ...(await deserializeAws_json1_1ReferenceTypeNotSupportedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryDoesNotExistException":
    case "com.amazonaws.codecommit#RepositoryDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1RepositoryDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryNameRequiredException":
    case "com.amazonaws.codecommit#RepositoryNameRequiredException":
      response = {
        ...(await deserializeAws_json1_1RepositoryNameRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "SourceAndDestinationAreSameException":
    case "com.amazonaws.codecommit#SourceAndDestinationAreSameException":
      response = {
        ...(await deserializeAws_json1_1SourceAndDestinationAreSameExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TargetRequiredException":
    case "com.amazonaws.codecommit#TargetRequiredException":
      response = {
        ...(await deserializeAws_json1_1TargetRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TargetsRequiredException":
    case "com.amazonaws.codecommit#TargetsRequiredException":
      response = {
        ...(await deserializeAws_json1_1TargetsRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TitleRequiredException":
    case "com.amazonaws.codecommit#TitleRequiredException":
      response = {
        ...(await deserializeAws_json1_1TitleRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreatePullRequestApprovalRuleCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreatePullRequestApprovalRuleCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreatePullRequestApprovalRuleCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreatePullRequestApprovalRuleOutput(
    data,
    context
  );
  const response: CreatePullRequestApprovalRuleCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreatePullRequestApprovalRuleOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreatePullRequestApprovalRuleCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreatePullRequestApprovalRuleCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ApprovalRuleContentRequiredException":
    case "com.amazonaws.codecommit#ApprovalRuleContentRequiredException":
      response = {
        ...(await deserializeAws_json1_1ApprovalRuleContentRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ApprovalRuleNameAlreadyExistsException":
    case "com.amazonaws.codecommit#ApprovalRuleNameAlreadyExistsException":
      response = {
        ...(await deserializeAws_json1_1ApprovalRuleNameAlreadyExistsExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ApprovalRuleNameRequiredException":
    case "com.amazonaws.codecommit#ApprovalRuleNameRequiredException":
      response = {
        ...(await deserializeAws_json1_1ApprovalRuleNameRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionIntegrityChecksFailedException":
    case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionIntegrityChecksFailedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyAccessDeniedException":
    case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyAccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyDisabledException":
    case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyDisabledExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyNotFoundException":
    case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyUnavailableException":
    case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyUnavailableExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidApprovalRuleContentException":
    case "com.amazonaws.codecommit#InvalidApprovalRuleContentException":
      response = {
        ...(await deserializeAws_json1_1InvalidApprovalRuleContentExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidApprovalRuleNameException":
    case "com.amazonaws.codecommit#InvalidApprovalRuleNameException":
      response = {
        ...(await deserializeAws_json1_1InvalidApprovalRuleNameExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidPullRequestIdException":
    case "com.amazonaws.codecommit#InvalidPullRequestIdException":
      response = {
        ...(await deserializeAws_json1_1InvalidPullRequestIdExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NumberOfRulesExceededException":
    case "com.amazonaws.codecommit#NumberOfRulesExceededException":
      response = {
        ...(await deserializeAws_json1_1NumberOfRulesExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "PullRequestAlreadyClosedException":
    case "com.amazonaws.codecommit#PullRequestAlreadyClosedException":
      response = {
        ...(await deserializeAws_json1_1PullRequestAlreadyClosedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "PullRequestDoesNotExistException":
    case "com.amazonaws.codecommit#PullRequestDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1PullRequestDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "PullRequestIdRequiredException":
    case "com.amazonaws.codecommit#PullRequestIdRequiredException":
      response = {
        ...(await deserializeAws_json1_1PullRequestIdRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreateRepositoryCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateRepositoryCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateRepositoryCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateRepositoryOutput(data, context);
  const response: CreateRepositoryCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateRepositoryOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateRepositoryCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateRepositoryCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EncryptionIntegrityChecksFailedException":
    case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionIntegrityChecksFailedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyAccessDeniedException":
    case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyAccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyDisabledException":
    case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyDisabledExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyNotFoundException":
    case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyUnavailableException":
    case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyUnavailableExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRepositoryDescriptionException":
    case "com.amazonaws.codecommit#InvalidRepositoryDescriptionException":
      response = {
        ...(await deserializeAws_json1_1InvalidRepositoryDescriptionExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRepositoryNameException":
    case "com.amazonaws.codecommit#InvalidRepositoryNameException":
      response = {
        ...(await deserializeAws_json1_1InvalidRepositoryNameExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidSystemTagUsageException":
    case "com.amazonaws.codecommit#InvalidSystemTagUsageException":
      response = {
        ...(await deserializeAws_json1_1InvalidSystemTagUsageExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidTagsMapException":
    case "com.amazonaws.codecommit#InvalidTagsMapException":
      response = {
        ...(await deserializeAws_json1_1InvalidTagsMapExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryLimitExceededException":
    case "com.amazonaws.codecommit#RepositoryLimitExceededException":
      response = {
        ...(await deserializeAws_json1_1RepositoryLimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryNameExistsException":
    case "com.amazonaws.codecommit#RepositoryNameExistsException":
      response = {
        ...(await deserializeAws_json1_1RepositoryNameExistsExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryNameRequiredException":
    case "com.amazonaws.codecommit#RepositoryNameRequiredException":
      response = {
        ...(await deserializeAws_json1_1RepositoryNameRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TagPolicyException":
    case "com.amazonaws.codecommit#TagPolicyException":
      response = {
        ...(await deserializeAws_json1_1TagPolicyExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyTagsException":
    case "com.amazonaws.codecommit#TooManyTagsException":
      response = {
        ...(await deserializeAws_json1_1TooManyTagsExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreateUnreferencedMergeCommitCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateUnreferencedMergeCommitCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateUnreferencedMergeCommitCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateUnreferencedMergeCommitOutput(
    data,
    context
  );
  const response: CreateUnreferencedMergeCommitCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateUnreferencedMergeCommitOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateUnreferencedMergeCommitCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateUnreferencedMergeCommitCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "CommitDoesNotExistException":
    case "com.amazonaws.codecommit#CommitDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1CommitDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "CommitMessageLengthExceededException":
    case "com.amazonaws.codecommit#CommitMessageLengthExceededException":
      response = {
        ...(await deserializeAws_json1_1CommitMessageLengthExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "CommitRequiredException":
    case "com.amazonaws.codecommit#CommitRequiredException":
      response = {
        ...(await deserializeAws_json1_1CommitRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ConcurrentReferenceUpdateException":
    case "com.amazonaws.codecommit#ConcurrentReferenceUpdateException":
      response = {
        ...(await deserializeAws_json1_1ConcurrentReferenceUpdateExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionIntegrityChecksFailedException":
    case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionIntegrityChecksFailedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyAccessDeniedException":
    case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyAccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyDisabledException":
    case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyDisabledExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyNotFoundException":
    case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyUnavailableException":
    case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyUnavailableExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "FileContentSizeLimitExceededException":
    case "com.amazonaws.codecommit#FileContentSizeLimitExceededException":
      response = {
        ...(await deserializeAws_json1_1FileContentSizeLimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "FileModeRequiredException":
    case "com.amazonaws.codecommit#FileModeRequiredException":
      response = {
        ...(await deserializeAws_json1_1FileModeRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "FolderContentSizeLimitExceededException":
    case "com.amazonaws.codecommit#FolderContentSizeLimitExceededException":
      response = {
        ...(await deserializeAws_json1_1FolderContentSizeLimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidCommitException":
    case "com.amazonaws.codecommit#InvalidCommitException":
      response = {
        ...(await deserializeAws_json1_1InvalidCommitExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidConflictDetailLevelException":
    case "com.amazonaws.codecommit#InvalidConflictDetailLevelException":
      response = {
        ...(await deserializeAws_json1_1InvalidConflictDetailLevelExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidConflictResolutionException":
    case "com.amazonaws.codecommit#InvalidConflictResolutionException":
      response = {
        ...(await deserializeAws_json1_1InvalidConflictResolutionExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidConflictResolutionStrategyException":
    case "com.amazonaws.codecommit#InvalidConflictResolutionStrategyException":
      response = {
        ...(await deserializeAws_json1_1InvalidConflictResolutionStrategyExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidEmailException":
    case "com.amazonaws.codecommit#InvalidEmailException":
      response = {
        ...(await deserializeAws_json1_1InvalidEmailExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidFileModeException":
    case "com.amazonaws.codecommit#InvalidFileModeException":
      response = {
        ...(await deserializeAws_json1_1InvalidFileModeExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidMergeOptionException":
    case "com.amazonaws.codecommit#InvalidMergeOptionException":
      response = {
        ...(await deserializeAws_json1_1InvalidMergeOptionExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidPathException":
    case "com.amazonaws.codecommit#InvalidPathException":
      response = {
        ...(await deserializeAws_json1_1InvalidPathExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidReplacementContentException":
    case "com.amazonaws.codecommit#InvalidReplacementContentException":
      response = {
        ...(await deserializeAws_json1_1InvalidReplacementContentExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidReplacementTypeException":
    case "com.amazonaws.codecommit#InvalidReplacementTypeException":
      response = {
        ...(await deserializeAws_json1_1InvalidReplacementTypeExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRepositoryNameException":
    case "com.amazonaws.codecommit#InvalidRepositoryNameException":
      response = {
        ...(await deserializeAws_json1_1InvalidRepositoryNameExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ManualMergeRequiredException":
    case "com.amazonaws.codecommit#ManualMergeRequiredException":
      response = {
        ...(await deserializeAws_json1_1ManualMergeRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MaximumConflictResolutionEntriesExceededException":
    case "com.amazonaws.codecommit#MaximumConflictResolutionEntriesExceededException":
      response = {
        ...(await deserializeAws_json1_1MaximumConflictResolutionEntriesExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MaximumFileContentToLoadExceededException":
    case "com.amazonaws.codecommit#MaximumFileContentToLoadExceededException":
      response = {
        ...(await deserializeAws_json1_1MaximumFileContentToLoadExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MaximumItemsToCompareExceededException":
    case "com.amazonaws.codecommit#MaximumItemsToCompareExceededException":
      response = {
        ...(await deserializeAws_json1_1MaximumItemsToCompareExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MergeOptionRequiredException":
    case "com.amazonaws.codecommit#MergeOptionRequiredException":
      response = {
        ...(await deserializeAws_json1_1MergeOptionRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MultipleConflictResolutionEntriesException":
    case "com.amazonaws.codecommit#MultipleConflictResolutionEntriesException":
      response = {
        ...(await deserializeAws_json1_1MultipleConflictResolutionEntriesExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NameLengthExceededException":
    case "com.amazonaws.codecommit#NameLengthExceededException":
      response = {
        ...(await deserializeAws_json1_1NameLengthExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "PathRequiredException":
    case "com.amazonaws.codecommit#PathRequiredException":
      response = {
        ...(await deserializeAws_json1_1PathRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ReplacementContentRequiredException":
    case "com.amazonaws.codecommit#ReplacementContentRequiredException":
      response = {
        ...(await deserializeAws_json1_1ReplacementContentRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ReplacementTypeRequiredException":
    case "com.amazonaws.codecommit#ReplacementTypeRequiredException":
      response = {
        ...(await deserializeAws_json1_1ReplacementTypeRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryDoesNotExistException":
    case "com.amazonaws.codecommit#RepositoryDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1RepositoryDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryNameRequiredException":
    case "com.amazonaws.codecommit#RepositoryNameRequiredException":
      response = {
        ...(await deserializeAws_json1_1RepositoryNameRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TipsDivergenceExceededException":
    case "com.amazonaws.codecommit#TipsDivergenceExceededException":
      response = {
        ...(await deserializeAws_json1_1TipsDivergenceExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeleteApprovalRuleTemplateCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteApprovalRuleTemplateCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteApprovalRuleTemplateCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteApprovalRuleTemplateOutput(
    data,
    context
  );
  const response: DeleteApprovalRuleTemplateCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteApprovalRuleTemplateOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteApprovalRuleTemplateCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteApprovalRuleTemplateCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ApprovalRuleTemplateInUseException":
    case "com.amazonaws.codecommit#ApprovalRuleTemplateInUseException":
      response = {
        ...(await deserializeAws_json1_1ApprovalRuleTemplateInUseExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ApprovalRuleTemplateNameRequiredException":
    case "com.amazonaws.codecommit#ApprovalRuleTemplateNameRequiredException":
      response = {
        ...(await deserializeAws_json1_1ApprovalRuleTemplateNameRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidApprovalRuleTemplateNameException":
    case "com.amazonaws.codecommit#InvalidApprovalRuleTemplateNameException":
      response = {
        ...(await deserializeAws_json1_1InvalidApprovalRuleTemplateNameExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeleteBranchCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteBranchCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteBranchCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteBranchOutput(data, context);
  const response: DeleteBranchCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteBranchOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteBranchCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteBranchCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "BranchNameRequiredException":
    case "com.amazonaws.codecommit#BranchNameRequiredException":
      response = {
        ...(await deserializeAws_json1_1BranchNameRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DefaultBranchCannotBeDeletedException":
    case "com.amazonaws.codecommit#DefaultBranchCannotBeDeletedException":
      response = {
        ...(await deserializeAws_json1_1DefaultBranchCannotBeDeletedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionIntegrityChecksFailedException":
    case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionIntegrityChecksFailedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyAccessDeniedException":
    case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyAccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyDisabledException":
    case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyDisabledExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyNotFoundException":
    case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyUnavailableException":
    case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyUnavailableExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidBranchNameException":
    case "com.amazonaws.codecommit#InvalidBranchNameException":
      response = {
        ...(await deserializeAws_json1_1InvalidBranchNameExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRepositoryNameException":
    case "com.amazonaws.codecommit#InvalidRepositoryNameException":
      response = {
        ...(await deserializeAws_json1_1InvalidRepositoryNameExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryDoesNotExistException":
    case "com.amazonaws.codecommit#RepositoryDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1RepositoryDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryNameRequiredException":
    case "com.amazonaws.codecommit#RepositoryNameRequiredException":
      response = {
        ...(await deserializeAws_json1_1RepositoryNameRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeleteCommentContentCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteCommentContentCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteCommentContentCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteCommentContentOutput(data, context);
  const response: DeleteCommentContentCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteCommentContentOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteCommentContentCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteCommentContentCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "CommentDeletedException":
    case "com.amazonaws.codecommit#CommentDeletedException":
      response = {
        ...(await deserializeAws_json1_1CommentDeletedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "CommentDoesNotExistException":
    case "com.amazonaws.codecommit#CommentDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1CommentDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "CommentIdRequiredException":
    case "com.amazonaws.codecommit#CommentIdRequiredException":
      response = {
        ...(await deserializeAws_json1_1CommentIdRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidCommentIdException":
    case "com.amazonaws.codecommit#InvalidCommentIdException":
      response = {
        ...(await deserializeAws_json1_1InvalidCommentIdExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeleteFileCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteFileCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteFileCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteFileOutput(data, context);
  const response: DeleteFileCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteFileOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteFileCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteFileCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "BranchDoesNotExistException":
    case "com.amazonaws.codecommit#BranchDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1BranchDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "BranchNameIsTagNameException":
    case "com.amazonaws.codecommit#BranchNameIsTagNameException":
      response = {
        ...(await deserializeAws_json1_1BranchNameIsTagNameExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "BranchNameRequiredException":
    case "com.amazonaws.codecommit#BranchNameRequiredException":
      response = {
        ...(await deserializeAws_json1_1BranchNameRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "CommitMessageLengthExceededException":
    case "com.amazonaws.codecommit#CommitMessageLengthExceededException":
      response = {
        ...(await deserializeAws_json1_1CommitMessageLengthExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionIntegrityChecksFailedException":
    case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionIntegrityChecksFailedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyAccessDeniedException":
    case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyAccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyDisabledException":
    case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyDisabledExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyNotFoundException":
    case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyUnavailableException":
    case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyUnavailableExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "FileDoesNotExistException":
    case "com.amazonaws.codecommit#FileDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1FileDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidBranchNameException":
    case "com.amazonaws.codecommit#InvalidBranchNameException":
      response = {
        ...(await deserializeAws_json1_1InvalidBranchNameExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidEmailException":
    case "com.amazonaws.codecommit#InvalidEmailException":
      response = {
        ...(await deserializeAws_json1_1InvalidEmailExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidParentCommitIdException":
    case "com.amazonaws.codecommit#InvalidParentCommitIdException":
      response = {
        ...(await deserializeAws_json1_1InvalidParentCommitIdExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidPathException":
    case "com.amazonaws.codecommit#InvalidPathException":
      response = {
        ...(await deserializeAws_json1_1InvalidPathExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRepositoryNameException":
    case "com.amazonaws.codecommit#InvalidRepositoryNameException":
      response = {
        ...(await deserializeAws_json1_1InvalidRepositoryNameExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NameLengthExceededException":
    case "com.amazonaws.codecommit#NameLengthExceededException":
      response = {
        ...(await deserializeAws_json1_1NameLengthExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ParentCommitDoesNotExistException":
    case "com.amazonaws.codecommit#ParentCommitDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1ParentCommitDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ParentCommitIdOutdatedException":
    case "com.amazonaws.codecommit#ParentCommitIdOutdatedException":
      response = {
        ...(await deserializeAws_json1_1ParentCommitIdOutdatedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ParentCommitIdRequiredException":
    case "com.amazonaws.codecommit#ParentCommitIdRequiredException":
      response = {
        ...(await deserializeAws_json1_1ParentCommitIdRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "PathRequiredException":
    case "com.amazonaws.codecommit#PathRequiredException":
      response = {
        ...(await deserializeAws_json1_1PathRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryDoesNotExistException":
    case "com.amazonaws.codecommit#RepositoryDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1RepositoryDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryNameRequiredException":
    case "com.amazonaws.codecommit#RepositoryNameRequiredException":
      response = {
        ...(await deserializeAws_json1_1RepositoryNameRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeletePullRequestApprovalRuleCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeletePullRequestApprovalRuleCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeletePullRequestApprovalRuleCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeletePullRequestApprovalRuleOutput(
    data,
    context
  );
  const response: DeletePullRequestApprovalRuleCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeletePullRequestApprovalRuleOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeletePullRequestApprovalRuleCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeletePullRequestApprovalRuleCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ApprovalRuleNameRequiredException":
    case "com.amazonaws.codecommit#ApprovalRuleNameRequiredException":
      response = {
        ...(await deserializeAws_json1_1ApprovalRuleNameRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "CannotDeleteApprovalRuleFromTemplateException":
    case "com.amazonaws.codecommit#CannotDeleteApprovalRuleFromTemplateException":
      response = {
        ...(await deserializeAws_json1_1CannotDeleteApprovalRuleFromTemplateExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionIntegrityChecksFailedException":
    case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionIntegrityChecksFailedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyAccessDeniedException":
    case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyAccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyDisabledException":
    case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyDisabledExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyNotFoundException":
    case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyUnavailableException":
    case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyUnavailableExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidApprovalRuleNameException":
    case "com.amazonaws.codecommit#InvalidApprovalRuleNameException":
      response = {
        ...(await deserializeAws_json1_1InvalidApprovalRuleNameExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidPullRequestIdException":
    case "com.amazonaws.codecommit#InvalidPullRequestIdException":
      response = {
        ...(await deserializeAws_json1_1InvalidPullRequestIdExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "PullRequestAlreadyClosedException":
    case "com.amazonaws.codecommit#PullRequestAlreadyClosedException":
      response = {
        ...(await deserializeAws_json1_1PullRequestAlreadyClosedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "PullRequestDoesNotExistException":
    case "com.amazonaws.codecommit#PullRequestDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1PullRequestDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "PullRequestIdRequiredException":
    case "com.amazonaws.codecommit#PullRequestIdRequiredException":
      response = {
        ...(await deserializeAws_json1_1PullRequestIdRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeleteRepositoryCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteRepositoryCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteRepositoryCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteRepositoryOutput(data, context);
  const response: DeleteRepositoryCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteRepositoryOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteRepositoryCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteRepositoryCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EncryptionIntegrityChecksFailedException":
    case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionIntegrityChecksFailedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyAccessDeniedException":
    case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyAccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyDisabledException":
    case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyDisabledExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyNotFoundException":
    case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyUnavailableException":
    case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyUnavailableExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRepositoryNameException":
    case "com.amazonaws.codecommit#InvalidRepositoryNameException":
      response = {
        ...(await deserializeAws_json1_1InvalidRepositoryNameExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryNameRequiredException":
    case "com.amazonaws.codecommit#RepositoryNameRequiredException":
      response = {
        ...(await deserializeAws_json1_1RepositoryNameRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeMergeConflictsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeMergeConflictsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeMergeConflictsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeMergeConflictsOutput(data, context);
  const response: DescribeMergeConflictsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeMergeConflictsOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeMergeConflictsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeMergeConflictsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "CommitDoesNotExistException":
    case "com.amazonaws.codecommit#CommitDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1CommitDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "CommitRequiredException":
    case "com.amazonaws.codecommit#CommitRequiredException":
      response = {
        ...(await deserializeAws_json1_1CommitRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionIntegrityChecksFailedException":
    case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionIntegrityChecksFailedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyAccessDeniedException":
    case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyAccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyDisabledException":
    case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyDisabledExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyNotFoundException":
    case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyUnavailableException":
    case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyUnavailableExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "FileDoesNotExistException":
    case "com.amazonaws.codecommit#FileDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1FileDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidCommitException":
    case "com.amazonaws.codecommit#InvalidCommitException":
      response = {
        ...(await deserializeAws_json1_1InvalidCommitExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidConflictDetailLevelException":
    case "com.amazonaws.codecommit#InvalidConflictDetailLevelException":
      response = {
        ...(await deserializeAws_json1_1InvalidConflictDetailLevelExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidConflictResolutionStrategyException":
    case "com.amazonaws.codecommit#InvalidConflictResolutionStrategyException":
      response = {
        ...(await deserializeAws_json1_1InvalidConflictResolutionStrategyExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidContinuationTokenException":
    case "com.amazonaws.codecommit#InvalidContinuationTokenException":
      response = {
        ...(await deserializeAws_json1_1InvalidContinuationTokenExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidMaxMergeHunksException":
    case "com.amazonaws.codecommit#InvalidMaxMergeHunksException":
      response = {
        ...(await deserializeAws_json1_1InvalidMaxMergeHunksExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidMergeOptionException":
    case "com.amazonaws.codecommit#InvalidMergeOptionException":
      response = {
        ...(await deserializeAws_json1_1InvalidMergeOptionExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidPathException":
    case "com.amazonaws.codecommit#InvalidPathException":
      response = {
        ...(await deserializeAws_json1_1InvalidPathExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRepositoryNameException":
    case "com.amazonaws.codecommit#InvalidRepositoryNameException":
      response = {
        ...(await deserializeAws_json1_1InvalidRepositoryNameExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MaximumFileContentToLoadExceededException":
    case "com.amazonaws.codecommit#MaximumFileContentToLoadExceededException":
      response = {
        ...(await deserializeAws_json1_1MaximumFileContentToLoadExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MaximumItemsToCompareExceededException":
    case "com.amazonaws.codecommit#MaximumItemsToCompareExceededException":
      response = {
        ...(await deserializeAws_json1_1MaximumItemsToCompareExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MergeOptionRequiredException":
    case "com.amazonaws.codecommit#MergeOptionRequiredException":
      response = {
        ...(await deserializeAws_json1_1MergeOptionRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "PathRequiredException":
    case "com.amazonaws.codecommit#PathRequiredException":
      response = {
        ...(await deserializeAws_json1_1PathRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryDoesNotExistException":
    case "com.amazonaws.codecommit#RepositoryDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1RepositoryDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryNameRequiredException":
    case "com.amazonaws.codecommit#RepositoryNameRequiredException":
      response = {
        ...(await deserializeAws_json1_1RepositoryNameRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TipsDivergenceExceededException":
    case "com.amazonaws.codecommit#TipsDivergenceExceededException":
      response = {
        ...(await deserializeAws_json1_1TipsDivergenceExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribePullRequestEventsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribePullRequestEventsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribePullRequestEventsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribePullRequestEventsOutput(
    data,
    context
  );
  const response: DescribePullRequestEventsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribePullRequestEventsOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribePullRequestEventsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribePullRequestEventsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ActorDoesNotExistException":
    case "com.amazonaws.codecommit#ActorDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1ActorDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionIntegrityChecksFailedException":
    case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionIntegrityChecksFailedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyAccessDeniedException":
    case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyAccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyDisabledException":
    case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyDisabledExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyNotFoundException":
    case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyUnavailableException":
    case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyUnavailableExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidActorArnException":
    case "com.amazonaws.codecommit#InvalidActorArnException":
      response = {
        ...(await deserializeAws_json1_1InvalidActorArnExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidContinuationTokenException":
    case "com.amazonaws.codecommit#InvalidContinuationTokenException":
      response = {
        ...(await deserializeAws_json1_1InvalidContinuationTokenExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidMaxResultsException":
    case "com.amazonaws.codecommit#InvalidMaxResultsException":
      response = {
        ...(await deserializeAws_json1_1InvalidMaxResultsExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidPullRequestEventTypeException":
    case "com.amazonaws.codecommit#InvalidPullRequestEventTypeException":
      response = {
        ...(await deserializeAws_json1_1InvalidPullRequestEventTypeExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidPullRequestIdException":
    case "com.amazonaws.codecommit#InvalidPullRequestIdException":
      response = {
        ...(await deserializeAws_json1_1InvalidPullRequestIdExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "PullRequestDoesNotExistException":
    case "com.amazonaws.codecommit#PullRequestDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1PullRequestDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "PullRequestIdRequiredException":
    case "com.amazonaws.codecommit#PullRequestIdRequiredException":
      response = {
        ...(await deserializeAws_json1_1PullRequestIdRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DisassociateApprovalRuleTemplateFromRepositoryCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DisassociateApprovalRuleTemplateFromRepositoryCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DisassociateApprovalRuleTemplateFromRepositoryCommandError(
      output,
      context
    );
  }
  await collectBody(output.body, context);
  const response: DisassociateApprovalRuleTemplateFromRepositoryCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DisassociateApprovalRuleTemplateFromRepositoryCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DisassociateApprovalRuleTemplateFromRepositoryCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ApprovalRuleTemplateDoesNotExistException":
    case "com.amazonaws.codecommit#ApprovalRuleTemplateDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1ApprovalRuleTemplateDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ApprovalRuleTemplateNameRequiredException":
    case "com.amazonaws.codecommit#ApprovalRuleTemplateNameRequiredException":
      response = {
        ...(await deserializeAws_json1_1ApprovalRuleTemplateNameRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionIntegrityChecksFailedException":
    case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionIntegrityChecksFailedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyAccessDeniedException":
    case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyAccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyDisabledException":
    case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyDisabledExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyNotFoundException":
    case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyUnavailableException":
    case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyUnavailableExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidApprovalRuleTemplateNameException":
    case "com.amazonaws.codecommit#InvalidApprovalRuleTemplateNameException":
      response = {
        ...(await deserializeAws_json1_1InvalidApprovalRuleTemplateNameExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRepositoryNameException":
    case "com.amazonaws.codecommit#InvalidRepositoryNameException":
      response = {
        ...(await deserializeAws_json1_1InvalidRepositoryNameExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryDoesNotExistException":
    case "com.amazonaws.codecommit#RepositoryDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1RepositoryDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryNameRequiredException":
    case "com.amazonaws.codecommit#RepositoryNameRequiredException":
      response = {
        ...(await deserializeAws_json1_1RepositoryNameRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1EvaluatePullRequestApprovalRulesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<EvaluatePullRequestApprovalRulesCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1EvaluatePullRequestApprovalRulesCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1EvaluatePullRequestApprovalRulesOutput(
    data,
    context
  );
  const response: EvaluatePullRequestApprovalRulesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "EvaluatePullRequestApprovalRulesOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1EvaluatePullRequestApprovalRulesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<EvaluatePullRequestApprovalRulesCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EncryptionIntegrityChecksFailedException":
    case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionIntegrityChecksFailedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyAccessDeniedException":
    case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyAccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyDisabledException":
    case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyDisabledExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyNotFoundException":
    case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyUnavailableException":
    case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyUnavailableExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidPullRequestIdException":
    case "com.amazonaws.codecommit#InvalidPullRequestIdException":
      response = {
        ...(await deserializeAws_json1_1InvalidPullRequestIdExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRevisionIdException":
    case "com.amazonaws.codecommit#InvalidRevisionIdException":
      response = {
        ...(await deserializeAws_json1_1InvalidRevisionIdExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "PullRequestDoesNotExistException":
    case "com.amazonaws.codecommit#PullRequestDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1PullRequestDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "PullRequestIdRequiredException":
    case "com.amazonaws.codecommit#PullRequestIdRequiredException":
      response = {
        ...(await deserializeAws_json1_1PullRequestIdRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RevisionIdRequiredException":
    case "com.amazonaws.codecommit#RevisionIdRequiredException":
      response = {
        ...(await deserializeAws_json1_1RevisionIdRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RevisionNotCurrentException":
    case "com.amazonaws.codecommit#RevisionNotCurrentException":
      response = {
        ...(await deserializeAws_json1_1RevisionNotCurrentExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetApprovalRuleTemplateCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetApprovalRuleTemplateCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetApprovalRuleTemplateCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetApprovalRuleTemplateOutput(data, context);
  const response: GetApprovalRuleTemplateCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetApprovalRuleTemplateOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetApprovalRuleTemplateCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetApprovalRuleTemplateCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ApprovalRuleTemplateDoesNotExistException":
    case "com.amazonaws.codecommit#ApprovalRuleTemplateDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1ApprovalRuleTemplateDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ApprovalRuleTemplateNameRequiredException":
    case "com.amazonaws.codecommit#ApprovalRuleTemplateNameRequiredException":
      response = {
        ...(await deserializeAws_json1_1ApprovalRuleTemplateNameRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidApprovalRuleTemplateNameException":
    case "com.amazonaws.codecommit#InvalidApprovalRuleTemplateNameException":
      response = {
        ...(await deserializeAws_json1_1InvalidApprovalRuleTemplateNameExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetBlobCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetBlobCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetBlobCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetBlobOutput(data, context);
  const response: GetBlobCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetBlobOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetBlobCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetBlobCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "BlobIdDoesNotExistException":
    case "com.amazonaws.codecommit#BlobIdDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1BlobIdDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "BlobIdRequiredException":
    case "com.amazonaws.codecommit#BlobIdRequiredException":
      response = {
        ...(await deserializeAws_json1_1BlobIdRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionIntegrityChecksFailedException":
    case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionIntegrityChecksFailedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyAccessDeniedException":
    case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyAccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyDisabledException":
    case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyDisabledExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyNotFoundException":
    case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyUnavailableException":
    case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyUnavailableExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "FileTooLargeException":
    case "com.amazonaws.codecommit#FileTooLargeException":
      response = {
        ...(await deserializeAws_json1_1FileTooLargeExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidBlobIdException":
    case "com.amazonaws.codecommit#InvalidBlobIdException":
      response = {
        ...(await deserializeAws_json1_1InvalidBlobIdExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRepositoryNameException":
    case "com.amazonaws.codecommit#InvalidRepositoryNameException":
      response = {
        ...(await deserializeAws_json1_1InvalidRepositoryNameExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryDoesNotExistException":
    case "com.amazonaws.codecommit#RepositoryDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1RepositoryDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryNameRequiredException":
    case "com.amazonaws.codecommit#RepositoryNameRequiredException":
      response = {
        ...(await deserializeAws_json1_1RepositoryNameRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetBranchCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetBranchCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetBranchCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetBranchOutput(data, context);
  const response: GetBranchCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetBranchOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetBranchCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetBranchCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "BranchDoesNotExistException":
    case "com.amazonaws.codecommit#BranchDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1BranchDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "BranchNameRequiredException":
    case "com.amazonaws.codecommit#BranchNameRequiredException":
      response = {
        ...(await deserializeAws_json1_1BranchNameRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionIntegrityChecksFailedException":
    case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionIntegrityChecksFailedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyAccessDeniedException":
    case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyAccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyDisabledException":
    case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyDisabledExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyNotFoundException":
    case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyUnavailableException":
    case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyUnavailableExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidBranchNameException":
    case "com.amazonaws.codecommit#InvalidBranchNameException":
      response = {
        ...(await deserializeAws_json1_1InvalidBranchNameExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRepositoryNameException":
    case "com.amazonaws.codecommit#InvalidRepositoryNameException":
      response = {
        ...(await deserializeAws_json1_1InvalidRepositoryNameExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryDoesNotExistException":
    case "com.amazonaws.codecommit#RepositoryDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1RepositoryDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryNameRequiredException":
    case "com.amazonaws.codecommit#RepositoryNameRequiredException":
      response = {
        ...(await deserializeAws_json1_1RepositoryNameRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetCommentCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetCommentCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetCommentCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetCommentOutput(data, context);
  const response: GetCommentCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetCommentOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetCommentCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetCommentCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "CommentDeletedException":
    case "com.amazonaws.codecommit#CommentDeletedException":
      response = {
        ...(await deserializeAws_json1_1CommentDeletedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "CommentDoesNotExistException":
    case "com.amazonaws.codecommit#CommentDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1CommentDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "CommentIdRequiredException":
    case "com.amazonaws.codecommit#CommentIdRequiredException":
      response = {
        ...(await deserializeAws_json1_1CommentIdRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidCommentIdException":
    case "com.amazonaws.codecommit#InvalidCommentIdException":
      response = {
        ...(await deserializeAws_json1_1InvalidCommentIdExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetCommentsForComparedCommitCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetCommentsForComparedCommitCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetCommentsForComparedCommitCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetCommentsForComparedCommitOutput(
    data,
    context
  );
  const response: GetCommentsForComparedCommitCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetCommentsForComparedCommitOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetCommentsForComparedCommitCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetCommentsForComparedCommitCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "CommitDoesNotExistException":
    case "com.amazonaws.codecommit#CommitDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1CommitDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "CommitIdRequiredException":
    case "com.amazonaws.codecommit#CommitIdRequiredException":
      response = {
        ...(await deserializeAws_json1_1CommitIdRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionIntegrityChecksFailedException":
    case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionIntegrityChecksFailedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyAccessDeniedException":
    case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyAccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyDisabledException":
    case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyDisabledExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyNotFoundException":
    case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyUnavailableException":
    case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyUnavailableExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidCommitIdException":
    case "com.amazonaws.codecommit#InvalidCommitIdException":
      response = {
        ...(await deserializeAws_json1_1InvalidCommitIdExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidContinuationTokenException":
    case "com.amazonaws.codecommit#InvalidContinuationTokenException":
      response = {
        ...(await deserializeAws_json1_1InvalidContinuationTokenExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidMaxResultsException":
    case "com.amazonaws.codecommit#InvalidMaxResultsException":
      response = {
        ...(await deserializeAws_json1_1InvalidMaxResultsExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRepositoryNameException":
    case "com.amazonaws.codecommit#InvalidRepositoryNameException":
      response = {
        ...(await deserializeAws_json1_1InvalidRepositoryNameExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryDoesNotExistException":
    case "com.amazonaws.codecommit#RepositoryDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1RepositoryDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryNameRequiredException":
    case "com.amazonaws.codecommit#RepositoryNameRequiredException":
      response = {
        ...(await deserializeAws_json1_1RepositoryNameRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetCommentsForPullRequestCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetCommentsForPullRequestCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetCommentsForPullRequestCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetCommentsForPullRequestOutput(
    data,
    context
  );
  const response: GetCommentsForPullRequestCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetCommentsForPullRequestOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetCommentsForPullRequestCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetCommentsForPullRequestCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "CommitDoesNotExistException":
    case "com.amazonaws.codecommit#CommitDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1CommitDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "CommitIdRequiredException":
    case "com.amazonaws.codecommit#CommitIdRequiredException":
      response = {
        ...(await deserializeAws_json1_1CommitIdRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionIntegrityChecksFailedException":
    case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionIntegrityChecksFailedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyAccessDeniedException":
    case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyAccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyDisabledException":
    case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyDisabledExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyNotFoundException":
    case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyUnavailableException":
    case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyUnavailableExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidCommitIdException":
    case "com.amazonaws.codecommit#InvalidCommitIdException":
      response = {
        ...(await deserializeAws_json1_1InvalidCommitIdExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidContinuationTokenException":
    case "com.amazonaws.codecommit#InvalidContinuationTokenException":
      response = {
        ...(await deserializeAws_json1_1InvalidContinuationTokenExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidMaxResultsException":
    case "com.amazonaws.codecommit#InvalidMaxResultsException":
      response = {
        ...(await deserializeAws_json1_1InvalidMaxResultsExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidPullRequestIdException":
    case "com.amazonaws.codecommit#InvalidPullRequestIdException":
      response = {
        ...(await deserializeAws_json1_1InvalidPullRequestIdExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRepositoryNameException":
    case "com.amazonaws.codecommit#InvalidRepositoryNameException":
      response = {
        ...(await deserializeAws_json1_1InvalidRepositoryNameExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "PullRequestDoesNotExistException":
    case "com.amazonaws.codecommit#PullRequestDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1PullRequestDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "PullRequestIdRequiredException":
    case "com.amazonaws.codecommit#PullRequestIdRequiredException":
      response = {
        ...(await deserializeAws_json1_1PullRequestIdRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryDoesNotExistException":
    case "com.amazonaws.codecommit#RepositoryDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1RepositoryDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryNameRequiredException":
    case "com.amazonaws.codecommit#RepositoryNameRequiredException":
      response = {
        ...(await deserializeAws_json1_1RepositoryNameRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryNotAssociatedWithPullRequestException":
    case "com.amazonaws.codecommit#RepositoryNotAssociatedWithPullRequestException":
      response = {
        ...(await deserializeAws_json1_1RepositoryNotAssociatedWithPullRequestExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetCommitCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetCommitCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetCommitCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetCommitOutput(data, context);
  const response: GetCommitCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetCommitOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetCommitCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetCommitCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "CommitIdDoesNotExistException":
    case "com.amazonaws.codecommit#CommitIdDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1CommitIdDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "CommitIdRequiredException":
    case "com.amazonaws.codecommit#CommitIdRequiredException":
      response = {
        ...(await deserializeAws_json1_1CommitIdRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionIntegrityChecksFailedException":
    case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionIntegrityChecksFailedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyAccessDeniedException":
    case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyAccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyDisabledException":
    case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyDisabledExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyNotFoundException":
    case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyUnavailableException":
    case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyUnavailableExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidCommitIdException":
    case "com.amazonaws.codecommit#InvalidCommitIdException":
      response = {
        ...(await deserializeAws_json1_1InvalidCommitIdExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRepositoryNameException":
    case "com.amazonaws.codecommit#InvalidRepositoryNameException":
      response = {
        ...(await deserializeAws_json1_1InvalidRepositoryNameExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryDoesNotExistException":
    case "com.amazonaws.codecommit#RepositoryDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1RepositoryDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryNameRequiredException":
    case "com.amazonaws.codecommit#RepositoryNameRequiredException":
      response = {
        ...(await deserializeAws_json1_1RepositoryNameRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetDifferencesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetDifferencesCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetDifferencesCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetDifferencesOutput(data, context);
  const response: GetDifferencesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetDifferencesOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetDifferencesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetDifferencesCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "CommitDoesNotExistException":
    case "com.amazonaws.codecommit#CommitDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1CommitDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "CommitRequiredException":
    case "com.amazonaws.codecommit#CommitRequiredException":
      response = {
        ...(await deserializeAws_json1_1CommitRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionIntegrityChecksFailedException":
    case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionIntegrityChecksFailedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyAccessDeniedException":
    case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyAccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyDisabledException":
    case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyDisabledExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyNotFoundException":
    case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyUnavailableException":
    case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyUnavailableExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidCommitException":
    case "com.amazonaws.codecommit#InvalidCommitException":
      response = {
        ...(await deserializeAws_json1_1InvalidCommitExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidCommitIdException":
    case "com.amazonaws.codecommit#InvalidCommitIdException":
      response = {
        ...(await deserializeAws_json1_1InvalidCommitIdExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidContinuationTokenException":
    case "com.amazonaws.codecommit#InvalidContinuationTokenException":
      response = {
        ...(await deserializeAws_json1_1InvalidContinuationTokenExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidMaxResultsException":
    case "com.amazonaws.codecommit#InvalidMaxResultsException":
      response = {
        ...(await deserializeAws_json1_1InvalidMaxResultsExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidPathException":
    case "com.amazonaws.codecommit#InvalidPathException":
      response = {
        ...(await deserializeAws_json1_1InvalidPathExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRepositoryNameException":
    case "com.amazonaws.codecommit#InvalidRepositoryNameException":
      response = {
        ...(await deserializeAws_json1_1InvalidRepositoryNameExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "PathDoesNotExistException":
    case "com.amazonaws.codecommit#PathDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1PathDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryDoesNotExistException":
    case "com.amazonaws.codecommit#RepositoryDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1RepositoryDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryNameRequiredException":
    case "com.amazonaws.codecommit#RepositoryNameRequiredException":
      response = {
        ...(await deserializeAws_json1_1RepositoryNameRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetFileCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetFileCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetFileCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetFileOutput(data, context);
  const response: GetFileCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetFileOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetFileCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetFileCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "CommitDoesNotExistException":
    case "com.amazonaws.codecommit#CommitDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1CommitDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionIntegrityChecksFailedException":
    case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionIntegrityChecksFailedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyAccessDeniedException":
    case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyAccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyDisabledException":
    case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyDisabledExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyNotFoundException":
    case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyUnavailableException":
    case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyUnavailableExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "FileDoesNotExistException":
    case "com.amazonaws.codecommit#FileDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1FileDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "FileTooLargeException":
    case "com.amazonaws.codecommit#FileTooLargeException":
      response = {
        ...(await deserializeAws_json1_1FileTooLargeExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidCommitException":
    case "com.amazonaws.codecommit#InvalidCommitException":
      response = {
        ...(await deserializeAws_json1_1InvalidCommitExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidPathException":
    case "com.amazonaws.codecommit#InvalidPathException":
      response = {
        ...(await deserializeAws_json1_1InvalidPathExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRepositoryNameException":
    case "com.amazonaws.codecommit#InvalidRepositoryNameException":
      response = {
        ...(await deserializeAws_json1_1InvalidRepositoryNameExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "PathRequiredException":
    case "com.amazonaws.codecommit#PathRequiredException":
      response = {
        ...(await deserializeAws_json1_1PathRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryDoesNotExistException":
    case "com.amazonaws.codecommit#RepositoryDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1RepositoryDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryNameRequiredException":
    case "com.amazonaws.codecommit#RepositoryNameRequiredException":
      response = {
        ...(await deserializeAws_json1_1RepositoryNameRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetFolderCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetFolderCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetFolderCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetFolderOutput(data, context);
  const response: GetFolderCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetFolderOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetFolderCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetFolderCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "CommitDoesNotExistException":
    case "com.amazonaws.codecommit#CommitDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1CommitDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionIntegrityChecksFailedException":
    case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionIntegrityChecksFailedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyAccessDeniedException":
    case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyAccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyDisabledException":
    case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyDisabledExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyNotFoundException":
    case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyUnavailableException":
    case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyUnavailableExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "FolderDoesNotExistException":
    case "com.amazonaws.codecommit#FolderDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1FolderDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidCommitException":
    case "com.amazonaws.codecommit#InvalidCommitException":
      response = {
        ...(await deserializeAws_json1_1InvalidCommitExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidPathException":
    case "com.amazonaws.codecommit#InvalidPathException":
      response = {
        ...(await deserializeAws_json1_1InvalidPathExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRepositoryNameException":
    case "com.amazonaws.codecommit#InvalidRepositoryNameException":
      response = {
        ...(await deserializeAws_json1_1InvalidRepositoryNameExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "PathRequiredException":
    case "com.amazonaws.codecommit#PathRequiredException":
      response = {
        ...(await deserializeAws_json1_1PathRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryDoesNotExistException":
    case "com.amazonaws.codecommit#RepositoryDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1RepositoryDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryNameRequiredException":
    case "com.amazonaws.codecommit#RepositoryNameRequiredException":
      response = {
        ...(await deserializeAws_json1_1RepositoryNameRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetMergeCommitCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetMergeCommitCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetMergeCommitCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetMergeCommitOutput(data, context);
  const response: GetMergeCommitCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetMergeCommitOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetMergeCommitCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetMergeCommitCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "CommitDoesNotExistException":
    case "com.amazonaws.codecommit#CommitDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1CommitDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "CommitRequiredException":
    case "com.amazonaws.codecommit#CommitRequiredException":
      response = {
        ...(await deserializeAws_json1_1CommitRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionIntegrityChecksFailedException":
    case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionIntegrityChecksFailedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyAccessDeniedException":
    case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyAccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyDisabledException":
    case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyDisabledExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyNotFoundException":
    case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyUnavailableException":
    case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyUnavailableExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidCommitException":
    case "com.amazonaws.codecommit#InvalidCommitException":
      response = {
        ...(await deserializeAws_json1_1InvalidCommitExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidConflictDetailLevelException":
    case "com.amazonaws.codecommit#InvalidConflictDetailLevelException":
      response = {
        ...(await deserializeAws_json1_1InvalidConflictDetailLevelExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidConflictResolutionStrategyException":
    case "com.amazonaws.codecommit#InvalidConflictResolutionStrategyException":
      response = {
        ...(await deserializeAws_json1_1InvalidConflictResolutionStrategyExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRepositoryNameException":
    case "com.amazonaws.codecommit#InvalidRepositoryNameException":
      response = {
        ...(await deserializeAws_json1_1InvalidRepositoryNameExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryDoesNotExistException":
    case "com.amazonaws.codecommit#RepositoryDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1RepositoryDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryNameRequiredException":
    case "com.amazonaws.codecommit#RepositoryNameRequiredException":
      response = {
        ...(await deserializeAws_json1_1RepositoryNameRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetMergeConflictsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetMergeConflictsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetMergeConflictsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetMergeConflictsOutput(data, context);
  const response: GetMergeConflictsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetMergeConflictsOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetMergeConflictsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetMergeConflictsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "CommitDoesNotExistException":
    case "com.amazonaws.codecommit#CommitDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1CommitDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "CommitRequiredException":
    case "com.amazonaws.codecommit#CommitRequiredException":
      response = {
        ...(await deserializeAws_json1_1CommitRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionIntegrityChecksFailedException":
    case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionIntegrityChecksFailedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyAccessDeniedException":
    case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyAccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyDisabledException":
    case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyDisabledExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyNotFoundException":
    case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyUnavailableException":
    case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyUnavailableExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidCommitException":
    case "com.amazonaws.codecommit#InvalidCommitException":
      response = {
        ...(await deserializeAws_json1_1InvalidCommitExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidConflictDetailLevelException":
    case "com.amazonaws.codecommit#InvalidConflictDetailLevelException":
      response = {
        ...(await deserializeAws_json1_1InvalidConflictDetailLevelExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidConflictResolutionStrategyException":
    case "com.amazonaws.codecommit#InvalidConflictResolutionStrategyException":
      response = {
        ...(await deserializeAws_json1_1InvalidConflictResolutionStrategyExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidContinuationTokenException":
    case "com.amazonaws.codecommit#InvalidContinuationTokenException":
      response = {
        ...(await deserializeAws_json1_1InvalidContinuationTokenExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDestinationCommitSpecifierException":
    case "com.amazonaws.codecommit#InvalidDestinationCommitSpecifierException":
      response = {
        ...(await deserializeAws_json1_1InvalidDestinationCommitSpecifierExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidMaxConflictFilesException":
    case "com.amazonaws.codecommit#InvalidMaxConflictFilesException":
      response = {
        ...(await deserializeAws_json1_1InvalidMaxConflictFilesExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidMergeOptionException":
    case "com.amazonaws.codecommit#InvalidMergeOptionException":
      response = {
        ...(await deserializeAws_json1_1InvalidMergeOptionExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRepositoryNameException":
    case "com.amazonaws.codecommit#InvalidRepositoryNameException":
      response = {
        ...(await deserializeAws_json1_1InvalidRepositoryNameExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidSourceCommitSpecifierException":
    case "com.amazonaws.codecommit#InvalidSourceCommitSpecifierException":
      response = {
        ...(await deserializeAws_json1_1InvalidSourceCommitSpecifierExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MaximumFileContentToLoadExceededException":
    case "com.amazonaws.codecommit#MaximumFileContentToLoadExceededException":
      response = {
        ...(await deserializeAws_json1_1MaximumFileContentToLoadExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MaximumItemsToCompareExceededException":
    case "com.amazonaws.codecommit#MaximumItemsToCompareExceededException":
      response = {
        ...(await deserializeAws_json1_1MaximumItemsToCompareExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MergeOptionRequiredException":
    case "com.amazonaws.codecommit#MergeOptionRequiredException":
      response = {
        ...(await deserializeAws_json1_1MergeOptionRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryDoesNotExistException":
    case "com.amazonaws.codecommit#RepositoryDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1RepositoryDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryNameRequiredException":
    case "com.amazonaws.codecommit#RepositoryNameRequiredException":
      response = {
        ...(await deserializeAws_json1_1RepositoryNameRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TipsDivergenceExceededException":
    case "com.amazonaws.codecommit#TipsDivergenceExceededException":
      response = {
        ...(await deserializeAws_json1_1TipsDivergenceExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetMergeOptionsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetMergeOptionsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetMergeOptionsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetMergeOptionsOutput(data, context);
  const response: GetMergeOptionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetMergeOptionsOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetMergeOptionsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetMergeOptionsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "CommitDoesNotExistException":
    case "com.amazonaws.codecommit#CommitDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1CommitDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "CommitRequiredException":
    case "com.amazonaws.codecommit#CommitRequiredException":
      response = {
        ...(await deserializeAws_json1_1CommitRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionIntegrityChecksFailedException":
    case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionIntegrityChecksFailedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyAccessDeniedException":
    case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyAccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyDisabledException":
    case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyDisabledExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyNotFoundException":
    case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyUnavailableException":
    case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyUnavailableExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidCommitException":
    case "com.amazonaws.codecommit#InvalidCommitException":
      response = {
        ...(await deserializeAws_json1_1InvalidCommitExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidConflictDetailLevelException":
    case "com.amazonaws.codecommit#InvalidConflictDetailLevelException":
      response = {
        ...(await deserializeAws_json1_1InvalidConflictDetailLevelExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidConflictResolutionStrategyException":
    case "com.amazonaws.codecommit#InvalidConflictResolutionStrategyException":
      response = {
        ...(await deserializeAws_json1_1InvalidConflictResolutionStrategyExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRepositoryNameException":
    case "com.amazonaws.codecommit#InvalidRepositoryNameException":
      response = {
        ...(await deserializeAws_json1_1InvalidRepositoryNameExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MaximumFileContentToLoadExceededException":
    case "com.amazonaws.codecommit#MaximumFileContentToLoadExceededException":
      response = {
        ...(await deserializeAws_json1_1MaximumFileContentToLoadExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MaximumItemsToCompareExceededException":
    case "com.amazonaws.codecommit#MaximumItemsToCompareExceededException":
      response = {
        ...(await deserializeAws_json1_1MaximumItemsToCompareExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryDoesNotExistException":
    case "com.amazonaws.codecommit#RepositoryDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1RepositoryDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryNameRequiredException":
    case "com.amazonaws.codecommit#RepositoryNameRequiredException":
      response = {
        ...(await deserializeAws_json1_1RepositoryNameRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TipsDivergenceExceededException":
    case "com.amazonaws.codecommit#TipsDivergenceExceededException":
      response = {
        ...(await deserializeAws_json1_1TipsDivergenceExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetPullRequestCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetPullRequestCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetPullRequestCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetPullRequestOutput(data, context);
  const response: GetPullRequestCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetPullRequestOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetPullRequestCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetPullRequestCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EncryptionIntegrityChecksFailedException":
    case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionIntegrityChecksFailedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyAccessDeniedException":
    case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyAccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyDisabledException":
    case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyDisabledExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyNotFoundException":
    case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyUnavailableException":
    case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyUnavailableExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidPullRequestIdException":
    case "com.amazonaws.codecommit#InvalidPullRequestIdException":
      response = {
        ...(await deserializeAws_json1_1InvalidPullRequestIdExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "PullRequestDoesNotExistException":
    case "com.amazonaws.codecommit#PullRequestDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1PullRequestDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "PullRequestIdRequiredException":
    case "com.amazonaws.codecommit#PullRequestIdRequiredException":
      response = {
        ...(await deserializeAws_json1_1PullRequestIdRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetPullRequestApprovalStatesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetPullRequestApprovalStatesCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetPullRequestApprovalStatesCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetPullRequestApprovalStatesOutput(
    data,
    context
  );
  const response: GetPullRequestApprovalStatesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetPullRequestApprovalStatesOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetPullRequestApprovalStatesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetPullRequestApprovalStatesCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EncryptionIntegrityChecksFailedException":
    case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionIntegrityChecksFailedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyAccessDeniedException":
    case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyAccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyDisabledException":
    case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyDisabledExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyNotFoundException":
    case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyUnavailableException":
    case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyUnavailableExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidPullRequestIdException":
    case "com.amazonaws.codecommit#InvalidPullRequestIdException":
      response = {
        ...(await deserializeAws_json1_1InvalidPullRequestIdExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRevisionIdException":
    case "com.amazonaws.codecommit#InvalidRevisionIdException":
      response = {
        ...(await deserializeAws_json1_1InvalidRevisionIdExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "PullRequestDoesNotExistException":
    case "com.amazonaws.codecommit#PullRequestDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1PullRequestDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "PullRequestIdRequiredException":
    case "com.amazonaws.codecommit#PullRequestIdRequiredException":
      response = {
        ...(await deserializeAws_json1_1PullRequestIdRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RevisionIdRequiredException":
    case "com.amazonaws.codecommit#RevisionIdRequiredException":
      response = {
        ...(await deserializeAws_json1_1RevisionIdRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetPullRequestOverrideStateCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetPullRequestOverrideStateCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetPullRequestOverrideStateCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetPullRequestOverrideStateOutput(
    data,
    context
  );
  const response: GetPullRequestOverrideStateCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetPullRequestOverrideStateOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetPullRequestOverrideStateCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetPullRequestOverrideStateCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EncryptionIntegrityChecksFailedException":
    case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionIntegrityChecksFailedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyAccessDeniedException":
    case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyAccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyDisabledException":
    case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyDisabledExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyNotFoundException":
    case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyUnavailableException":
    case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyUnavailableExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidPullRequestIdException":
    case "com.amazonaws.codecommit#InvalidPullRequestIdException":
      response = {
        ...(await deserializeAws_json1_1InvalidPullRequestIdExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRevisionIdException":
    case "com.amazonaws.codecommit#InvalidRevisionIdException":
      response = {
        ...(await deserializeAws_json1_1InvalidRevisionIdExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "PullRequestDoesNotExistException":
    case "com.amazonaws.codecommit#PullRequestDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1PullRequestDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "PullRequestIdRequiredException":
    case "com.amazonaws.codecommit#PullRequestIdRequiredException":
      response = {
        ...(await deserializeAws_json1_1PullRequestIdRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RevisionIdRequiredException":
    case "com.amazonaws.codecommit#RevisionIdRequiredException":
      response = {
        ...(await deserializeAws_json1_1RevisionIdRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetRepositoryCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetRepositoryCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetRepositoryCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetRepositoryOutput(data, context);
  const response: GetRepositoryCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetRepositoryOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetRepositoryCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetRepositoryCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EncryptionIntegrityChecksFailedException":
    case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionIntegrityChecksFailedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyAccessDeniedException":
    case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyAccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyDisabledException":
    case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyDisabledExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyNotFoundException":
    case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyUnavailableException":
    case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyUnavailableExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRepositoryNameException":
    case "com.amazonaws.codecommit#InvalidRepositoryNameException":
      response = {
        ...(await deserializeAws_json1_1InvalidRepositoryNameExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryDoesNotExistException":
    case "com.amazonaws.codecommit#RepositoryDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1RepositoryDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryNameRequiredException":
    case "com.amazonaws.codecommit#RepositoryNameRequiredException":
      response = {
        ...(await deserializeAws_json1_1RepositoryNameRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetRepositoryTriggersCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetRepositoryTriggersCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetRepositoryTriggersCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetRepositoryTriggersOutput(data, context);
  const response: GetRepositoryTriggersCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetRepositoryTriggersOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetRepositoryTriggersCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetRepositoryTriggersCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EncryptionIntegrityChecksFailedException":
    case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionIntegrityChecksFailedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyAccessDeniedException":
    case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyAccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyDisabledException":
    case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyDisabledExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyNotFoundException":
    case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyUnavailableException":
    case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyUnavailableExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRepositoryNameException":
    case "com.amazonaws.codecommit#InvalidRepositoryNameException":
      response = {
        ...(await deserializeAws_json1_1InvalidRepositoryNameExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryDoesNotExistException":
    case "com.amazonaws.codecommit#RepositoryDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1RepositoryDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryNameRequiredException":
    case "com.amazonaws.codecommit#RepositoryNameRequiredException":
      response = {
        ...(await deserializeAws_json1_1RepositoryNameRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ListApprovalRuleTemplatesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListApprovalRuleTemplatesCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListApprovalRuleTemplatesCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListApprovalRuleTemplatesOutput(
    data,
    context
  );
  const response: ListApprovalRuleTemplatesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListApprovalRuleTemplatesOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListApprovalRuleTemplatesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListApprovalRuleTemplatesCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InvalidContinuationTokenException":
    case "com.amazonaws.codecommit#InvalidContinuationTokenException":
      response = {
        ...(await deserializeAws_json1_1InvalidContinuationTokenExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidMaxResultsException":
    case "com.amazonaws.codecommit#InvalidMaxResultsException":
      response = {
        ...(await deserializeAws_json1_1InvalidMaxResultsExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ListAssociatedApprovalRuleTemplatesForRepositoryCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListAssociatedApprovalRuleTemplatesForRepositoryCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListAssociatedApprovalRuleTemplatesForRepositoryCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListAssociatedApprovalRuleTemplatesForRepositoryOutput(
    data,
    context
  );
  const response: ListAssociatedApprovalRuleTemplatesForRepositoryCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListAssociatedApprovalRuleTemplatesForRepositoryOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListAssociatedApprovalRuleTemplatesForRepositoryCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListAssociatedApprovalRuleTemplatesForRepositoryCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EncryptionIntegrityChecksFailedException":
    case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionIntegrityChecksFailedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyAccessDeniedException":
    case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyAccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyDisabledException":
    case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyDisabledExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyNotFoundException":
    case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyUnavailableException":
    case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyUnavailableExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidContinuationTokenException":
    case "com.amazonaws.codecommit#InvalidContinuationTokenException":
      response = {
        ...(await deserializeAws_json1_1InvalidContinuationTokenExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidMaxResultsException":
    case "com.amazonaws.codecommit#InvalidMaxResultsException":
      response = {
        ...(await deserializeAws_json1_1InvalidMaxResultsExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRepositoryNameException":
    case "com.amazonaws.codecommit#InvalidRepositoryNameException":
      response = {
        ...(await deserializeAws_json1_1InvalidRepositoryNameExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryDoesNotExistException":
    case "com.amazonaws.codecommit#RepositoryDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1RepositoryDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryNameRequiredException":
    case "com.amazonaws.codecommit#RepositoryNameRequiredException":
      response = {
        ...(await deserializeAws_json1_1RepositoryNameRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ListBranchesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListBranchesCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListBranchesCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListBranchesOutput(data, context);
  const response: ListBranchesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListBranchesOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListBranchesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListBranchesCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EncryptionIntegrityChecksFailedException":
    case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionIntegrityChecksFailedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyAccessDeniedException":
    case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyAccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyDisabledException":
    case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyDisabledExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyNotFoundException":
    case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyUnavailableException":
    case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyUnavailableExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidContinuationTokenException":
    case "com.amazonaws.codecommit#InvalidContinuationTokenException":
      response = {
        ...(await deserializeAws_json1_1InvalidContinuationTokenExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRepositoryNameException":
    case "com.amazonaws.codecommit#InvalidRepositoryNameException":
      response = {
        ...(await deserializeAws_json1_1InvalidRepositoryNameExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryDoesNotExistException":
    case "com.amazonaws.codecommit#RepositoryDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1RepositoryDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryNameRequiredException":
    case "com.amazonaws.codecommit#RepositoryNameRequiredException":
      response = {
        ...(await deserializeAws_json1_1RepositoryNameRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ListPullRequestsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListPullRequestsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListPullRequestsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListPullRequestsOutput(data, context);
  const response: ListPullRequestsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListPullRequestsOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListPullRequestsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListPullRequestsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "AuthorDoesNotExistException":
    case "com.amazonaws.codecommit#AuthorDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1AuthorDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionIntegrityChecksFailedException":
    case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionIntegrityChecksFailedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyAccessDeniedException":
    case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyAccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyDisabledException":
    case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyDisabledExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyNotFoundException":
    case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyUnavailableException":
    case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyUnavailableExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidAuthorArnException":
    case "com.amazonaws.codecommit#InvalidAuthorArnException":
      response = {
        ...(await deserializeAws_json1_1InvalidAuthorArnExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidContinuationTokenException":
    case "com.amazonaws.codecommit#InvalidContinuationTokenException":
      response = {
        ...(await deserializeAws_json1_1InvalidContinuationTokenExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidMaxResultsException":
    case "com.amazonaws.codecommit#InvalidMaxResultsException":
      response = {
        ...(await deserializeAws_json1_1InvalidMaxResultsExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidPullRequestStatusException":
    case "com.amazonaws.codecommit#InvalidPullRequestStatusException":
      response = {
        ...(await deserializeAws_json1_1InvalidPullRequestStatusExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRepositoryNameException":
    case "com.amazonaws.codecommit#InvalidRepositoryNameException":
      response = {
        ...(await deserializeAws_json1_1InvalidRepositoryNameExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryDoesNotExistException":
    case "com.amazonaws.codecommit#RepositoryDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1RepositoryDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryNameRequiredException":
    case "com.amazonaws.codecommit#RepositoryNameRequiredException":
      response = {
        ...(await deserializeAws_json1_1RepositoryNameRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ListRepositoriesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListRepositoriesCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListRepositoriesCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListRepositoriesOutput(data, context);
  const response: ListRepositoriesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListRepositoriesOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListRepositoriesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListRepositoriesCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InvalidContinuationTokenException":
    case "com.amazonaws.codecommit#InvalidContinuationTokenException":
      response = {
        ...(await deserializeAws_json1_1InvalidContinuationTokenExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidOrderException":
    case "com.amazonaws.codecommit#InvalidOrderException":
      response = {
        ...(await deserializeAws_json1_1InvalidOrderExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidSortByException":
    case "com.amazonaws.codecommit#InvalidSortByException":
      response = {
        ...(await deserializeAws_json1_1InvalidSortByExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ListRepositoriesForApprovalRuleTemplateCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListRepositoriesForApprovalRuleTemplateCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListRepositoriesForApprovalRuleTemplateCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListRepositoriesForApprovalRuleTemplateOutput(
    data,
    context
  );
  const response: ListRepositoriesForApprovalRuleTemplateCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListRepositoriesForApprovalRuleTemplateOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListRepositoriesForApprovalRuleTemplateCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListRepositoriesForApprovalRuleTemplateCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ApprovalRuleTemplateDoesNotExistException":
    case "com.amazonaws.codecommit#ApprovalRuleTemplateDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1ApprovalRuleTemplateDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ApprovalRuleTemplateNameRequiredException":
    case "com.amazonaws.codecommit#ApprovalRuleTemplateNameRequiredException":
      response = {
        ...(await deserializeAws_json1_1ApprovalRuleTemplateNameRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionIntegrityChecksFailedException":
    case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionIntegrityChecksFailedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyAccessDeniedException":
    case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyAccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyDisabledException":
    case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyDisabledExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyNotFoundException":
    case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyUnavailableException":
    case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyUnavailableExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidApprovalRuleTemplateNameException":
    case "com.amazonaws.codecommit#InvalidApprovalRuleTemplateNameException":
      response = {
        ...(await deserializeAws_json1_1InvalidApprovalRuleTemplateNameExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidContinuationTokenException":
    case "com.amazonaws.codecommit#InvalidContinuationTokenException":
      response = {
        ...(await deserializeAws_json1_1InvalidContinuationTokenExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidMaxResultsException":
    case "com.amazonaws.codecommit#InvalidMaxResultsException":
      response = {
        ...(await deserializeAws_json1_1InvalidMaxResultsExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ListTagsForResourceCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTagsForResourceCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListTagsForResourceCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListTagsForResourceOutput(data, context);
  const response: ListTagsForResourceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListTagsForResourceOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListTagsForResourceCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTagsForResourceCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InvalidRepositoryNameException":
    case "com.amazonaws.codecommit#InvalidRepositoryNameException":
      response = {
        ...(await deserializeAws_json1_1InvalidRepositoryNameExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidResourceArnException":
    case "com.amazonaws.codecommit#InvalidResourceArnException":
      response = {
        ...(await deserializeAws_json1_1InvalidResourceArnExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryDoesNotExistException":
    case "com.amazonaws.codecommit#RepositoryDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1RepositoryDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceArnRequiredException":
    case "com.amazonaws.codecommit#ResourceArnRequiredException":
      response = {
        ...(await deserializeAws_json1_1ResourceArnRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1MergeBranchesByFastForwardCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<MergeBranchesByFastForwardCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1MergeBranchesByFastForwardCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1MergeBranchesByFastForwardOutput(
    data,
    context
  );
  const response: MergeBranchesByFastForwardCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "MergeBranchesByFastForwardOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1MergeBranchesByFastForwardCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<MergeBranchesByFastForwardCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "BranchDoesNotExistException":
    case "com.amazonaws.codecommit#BranchDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1BranchDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "BranchNameIsTagNameException":
    case "com.amazonaws.codecommit#BranchNameIsTagNameException":
      response = {
        ...(await deserializeAws_json1_1BranchNameIsTagNameExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "BranchNameRequiredException":
    case "com.amazonaws.codecommit#BranchNameRequiredException":
      response = {
        ...(await deserializeAws_json1_1BranchNameRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "CommitDoesNotExistException":
    case "com.amazonaws.codecommit#CommitDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1CommitDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "CommitRequiredException":
    case "com.amazonaws.codecommit#CommitRequiredException":
      response = {
        ...(await deserializeAws_json1_1CommitRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ConcurrentReferenceUpdateException":
    case "com.amazonaws.codecommit#ConcurrentReferenceUpdateException":
      response = {
        ...(await deserializeAws_json1_1ConcurrentReferenceUpdateExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionIntegrityChecksFailedException":
    case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionIntegrityChecksFailedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyAccessDeniedException":
    case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyAccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyDisabledException":
    case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyDisabledExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyNotFoundException":
    case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyUnavailableException":
    case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyUnavailableExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidBranchNameException":
    case "com.amazonaws.codecommit#InvalidBranchNameException":
      response = {
        ...(await deserializeAws_json1_1InvalidBranchNameExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidCommitException":
    case "com.amazonaws.codecommit#InvalidCommitException":
      response = {
        ...(await deserializeAws_json1_1InvalidCommitExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRepositoryNameException":
    case "com.amazonaws.codecommit#InvalidRepositoryNameException":
      response = {
        ...(await deserializeAws_json1_1InvalidRepositoryNameExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidTargetBranchException":
    case "com.amazonaws.codecommit#InvalidTargetBranchException":
      response = {
        ...(await deserializeAws_json1_1InvalidTargetBranchExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ManualMergeRequiredException":
    case "com.amazonaws.codecommit#ManualMergeRequiredException":
      response = {
        ...(await deserializeAws_json1_1ManualMergeRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryDoesNotExistException":
    case "com.amazonaws.codecommit#RepositoryDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1RepositoryDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryNameRequiredException":
    case "com.amazonaws.codecommit#RepositoryNameRequiredException":
      response = {
        ...(await deserializeAws_json1_1RepositoryNameRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TipsDivergenceExceededException":
    case "com.amazonaws.codecommit#TipsDivergenceExceededException":
      response = {
        ...(await deserializeAws_json1_1TipsDivergenceExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1MergeBranchesBySquashCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<MergeBranchesBySquashCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1MergeBranchesBySquashCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1MergeBranchesBySquashOutput(data, context);
  const response: MergeBranchesBySquashCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "MergeBranchesBySquashOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1MergeBranchesBySquashCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<MergeBranchesBySquashCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "BranchDoesNotExistException":
    case "com.amazonaws.codecommit#BranchDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1BranchDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "BranchNameIsTagNameException":
    case "com.amazonaws.codecommit#BranchNameIsTagNameException":
      response = {
        ...(await deserializeAws_json1_1BranchNameIsTagNameExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "BranchNameRequiredException":
    case "com.amazonaws.codecommit#BranchNameRequiredException":
      response = {
        ...(await deserializeAws_json1_1BranchNameRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "CommitDoesNotExistException":
    case "com.amazonaws.codecommit#CommitDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1CommitDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "CommitMessageLengthExceededException":
    case "com.amazonaws.codecommit#CommitMessageLengthExceededException":
      response = {
        ...(await deserializeAws_json1_1CommitMessageLengthExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "CommitRequiredException":
    case "com.amazonaws.codecommit#CommitRequiredException":
      response = {
        ...(await deserializeAws_json1_1CommitRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ConcurrentReferenceUpdateException":
    case "com.amazonaws.codecommit#ConcurrentReferenceUpdateException":
      response = {
        ...(await deserializeAws_json1_1ConcurrentReferenceUpdateExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionIntegrityChecksFailedException":
    case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionIntegrityChecksFailedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyAccessDeniedException":
    case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyAccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyDisabledException":
    case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyDisabledExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyNotFoundException":
    case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyUnavailableException":
    case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyUnavailableExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "FileContentSizeLimitExceededException":
    case "com.amazonaws.codecommit#FileContentSizeLimitExceededException":
      response = {
        ...(await deserializeAws_json1_1FileContentSizeLimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "FileModeRequiredException":
    case "com.amazonaws.codecommit#FileModeRequiredException":
      response = {
        ...(await deserializeAws_json1_1FileModeRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "FolderContentSizeLimitExceededException":
    case "com.amazonaws.codecommit#FolderContentSizeLimitExceededException":
      response = {
        ...(await deserializeAws_json1_1FolderContentSizeLimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidBranchNameException":
    case "com.amazonaws.codecommit#InvalidBranchNameException":
      response = {
        ...(await deserializeAws_json1_1InvalidBranchNameExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidCommitException":
    case "com.amazonaws.codecommit#InvalidCommitException":
      response = {
        ...(await deserializeAws_json1_1InvalidCommitExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidConflictDetailLevelException":
    case "com.amazonaws.codecommit#InvalidConflictDetailLevelException":
      response = {
        ...(await deserializeAws_json1_1InvalidConflictDetailLevelExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidConflictResolutionException":
    case "com.amazonaws.codecommit#InvalidConflictResolutionException":
      response = {
        ...(await deserializeAws_json1_1InvalidConflictResolutionExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidConflictResolutionStrategyException":
    case "com.amazonaws.codecommit#InvalidConflictResolutionStrategyException":
      response = {
        ...(await deserializeAws_json1_1InvalidConflictResolutionStrategyExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidEmailException":
    case "com.amazonaws.codecommit#InvalidEmailException":
      response = {
        ...(await deserializeAws_json1_1InvalidEmailExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidFileModeException":
    case "com.amazonaws.codecommit#InvalidFileModeException":
      response = {
        ...(await deserializeAws_json1_1InvalidFileModeExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidPathException":
    case "com.amazonaws.codecommit#InvalidPathException":
      response = {
        ...(await deserializeAws_json1_1InvalidPathExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidReplacementContentException":
    case "com.amazonaws.codecommit#InvalidReplacementContentException":
      response = {
        ...(await deserializeAws_json1_1InvalidReplacementContentExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidReplacementTypeException":
    case "com.amazonaws.codecommit#InvalidReplacementTypeException":
      response = {
        ...(await deserializeAws_json1_1InvalidReplacementTypeExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRepositoryNameException":
    case "com.amazonaws.codecommit#InvalidRepositoryNameException":
      response = {
        ...(await deserializeAws_json1_1InvalidRepositoryNameExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidTargetBranchException":
    case "com.amazonaws.codecommit#InvalidTargetBranchException":
      response = {
        ...(await deserializeAws_json1_1InvalidTargetBranchExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ManualMergeRequiredException":
    case "com.amazonaws.codecommit#ManualMergeRequiredException":
      response = {
        ...(await deserializeAws_json1_1ManualMergeRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MaximumConflictResolutionEntriesExceededException":
    case "com.amazonaws.codecommit#MaximumConflictResolutionEntriesExceededException":
      response = {
        ...(await deserializeAws_json1_1MaximumConflictResolutionEntriesExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MaximumFileContentToLoadExceededException":
    case "com.amazonaws.codecommit#MaximumFileContentToLoadExceededException":
      response = {
        ...(await deserializeAws_json1_1MaximumFileContentToLoadExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MaximumItemsToCompareExceededException":
    case "com.amazonaws.codecommit#MaximumItemsToCompareExceededException":
      response = {
        ...(await deserializeAws_json1_1MaximumItemsToCompareExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MultipleConflictResolutionEntriesException":
    case "com.amazonaws.codecommit#MultipleConflictResolutionEntriesException":
      response = {
        ...(await deserializeAws_json1_1MultipleConflictResolutionEntriesExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NameLengthExceededException":
    case "com.amazonaws.codecommit#NameLengthExceededException":
      response = {
        ...(await deserializeAws_json1_1NameLengthExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "PathRequiredException":
    case "com.amazonaws.codecommit#PathRequiredException":
      response = {
        ...(await deserializeAws_json1_1PathRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ReplacementContentRequiredException":
    case "com.amazonaws.codecommit#ReplacementContentRequiredException":
      response = {
        ...(await deserializeAws_json1_1ReplacementContentRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ReplacementTypeRequiredException":
    case "com.amazonaws.codecommit#ReplacementTypeRequiredException":
      response = {
        ...(await deserializeAws_json1_1ReplacementTypeRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryDoesNotExistException":
    case "com.amazonaws.codecommit#RepositoryDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1RepositoryDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryNameRequiredException":
    case "com.amazonaws.codecommit#RepositoryNameRequiredException":
      response = {
        ...(await deserializeAws_json1_1RepositoryNameRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TipsDivergenceExceededException":
    case "com.amazonaws.codecommit#TipsDivergenceExceededException":
      response = {
        ...(await deserializeAws_json1_1TipsDivergenceExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1MergeBranchesByThreeWayCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<MergeBranchesByThreeWayCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1MergeBranchesByThreeWayCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1MergeBranchesByThreeWayOutput(data, context);
  const response: MergeBranchesByThreeWayCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "MergeBranchesByThreeWayOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1MergeBranchesByThreeWayCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<MergeBranchesByThreeWayCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "BranchDoesNotExistException":
    case "com.amazonaws.codecommit#BranchDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1BranchDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "BranchNameIsTagNameException":
    case "com.amazonaws.codecommit#BranchNameIsTagNameException":
      response = {
        ...(await deserializeAws_json1_1BranchNameIsTagNameExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "BranchNameRequiredException":
    case "com.amazonaws.codecommit#BranchNameRequiredException":
      response = {
        ...(await deserializeAws_json1_1BranchNameRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "CommitDoesNotExistException":
    case "com.amazonaws.codecommit#CommitDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1CommitDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "CommitMessageLengthExceededException":
    case "com.amazonaws.codecommit#CommitMessageLengthExceededException":
      response = {
        ...(await deserializeAws_json1_1CommitMessageLengthExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "CommitRequiredException":
    case "com.amazonaws.codecommit#CommitRequiredException":
      response = {
        ...(await deserializeAws_json1_1CommitRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ConcurrentReferenceUpdateException":
    case "com.amazonaws.codecommit#ConcurrentReferenceUpdateException":
      response = {
        ...(await deserializeAws_json1_1ConcurrentReferenceUpdateExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionIntegrityChecksFailedException":
    case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionIntegrityChecksFailedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyAccessDeniedException":
    case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyAccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyDisabledException":
    case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyDisabledExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyNotFoundException":
    case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyUnavailableException":
    case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyUnavailableExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "FileContentSizeLimitExceededException":
    case "com.amazonaws.codecommit#FileContentSizeLimitExceededException":
      response = {
        ...(await deserializeAws_json1_1FileContentSizeLimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "FileModeRequiredException":
    case "com.amazonaws.codecommit#FileModeRequiredException":
      response = {
        ...(await deserializeAws_json1_1FileModeRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "FolderContentSizeLimitExceededException":
    case "com.amazonaws.codecommit#FolderContentSizeLimitExceededException":
      response = {
        ...(await deserializeAws_json1_1FolderContentSizeLimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidBranchNameException":
    case "com.amazonaws.codecommit#InvalidBranchNameException":
      response = {
        ...(await deserializeAws_json1_1InvalidBranchNameExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidCommitException":
    case "com.amazonaws.codecommit#InvalidCommitException":
      response = {
        ...(await deserializeAws_json1_1InvalidCommitExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidConflictDetailLevelException":
    case "com.amazonaws.codecommit#InvalidConflictDetailLevelException":
      response = {
        ...(await deserializeAws_json1_1InvalidConflictDetailLevelExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidConflictResolutionException":
    case "com.amazonaws.codecommit#InvalidConflictResolutionException":
      response = {
        ...(await deserializeAws_json1_1InvalidConflictResolutionExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidConflictResolutionStrategyException":
    case "com.amazonaws.codecommit#InvalidConflictResolutionStrategyException":
      response = {
        ...(await deserializeAws_json1_1InvalidConflictResolutionStrategyExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidEmailException":
    case "com.amazonaws.codecommit#InvalidEmailException":
      response = {
        ...(await deserializeAws_json1_1InvalidEmailExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidFileModeException":
    case "com.amazonaws.codecommit#InvalidFileModeException":
      response = {
        ...(await deserializeAws_json1_1InvalidFileModeExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidPathException":
    case "com.amazonaws.codecommit#InvalidPathException":
      response = {
        ...(await deserializeAws_json1_1InvalidPathExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidReplacementContentException":
    case "com.amazonaws.codecommit#InvalidReplacementContentException":
      response = {
        ...(await deserializeAws_json1_1InvalidReplacementContentExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidReplacementTypeException":
    case "com.amazonaws.codecommit#InvalidReplacementTypeException":
      response = {
        ...(await deserializeAws_json1_1InvalidReplacementTypeExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRepositoryNameException":
    case "com.amazonaws.codecommit#InvalidRepositoryNameException":
      response = {
        ...(await deserializeAws_json1_1InvalidRepositoryNameExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidTargetBranchException":
    case "com.amazonaws.codecommit#InvalidTargetBranchException":
      response = {
        ...(await deserializeAws_json1_1InvalidTargetBranchExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ManualMergeRequiredException":
    case "com.amazonaws.codecommit#ManualMergeRequiredException":
      response = {
        ...(await deserializeAws_json1_1ManualMergeRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MaximumConflictResolutionEntriesExceededException":
    case "com.amazonaws.codecommit#MaximumConflictResolutionEntriesExceededException":
      response = {
        ...(await deserializeAws_json1_1MaximumConflictResolutionEntriesExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MaximumFileContentToLoadExceededException":
    case "com.amazonaws.codecommit#MaximumFileContentToLoadExceededException":
      response = {
        ...(await deserializeAws_json1_1MaximumFileContentToLoadExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MaximumItemsToCompareExceededException":
    case "com.amazonaws.codecommit#MaximumItemsToCompareExceededException":
      response = {
        ...(await deserializeAws_json1_1MaximumItemsToCompareExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MultipleConflictResolutionEntriesException":
    case "com.amazonaws.codecommit#MultipleConflictResolutionEntriesException":
      response = {
        ...(await deserializeAws_json1_1MultipleConflictResolutionEntriesExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NameLengthExceededException":
    case "com.amazonaws.codecommit#NameLengthExceededException":
      response = {
        ...(await deserializeAws_json1_1NameLengthExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "PathRequiredException":
    case "com.amazonaws.codecommit#PathRequiredException":
      response = {
        ...(await deserializeAws_json1_1PathRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ReplacementContentRequiredException":
    case "com.amazonaws.codecommit#ReplacementContentRequiredException":
      response = {
        ...(await deserializeAws_json1_1ReplacementContentRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ReplacementTypeRequiredException":
    case "com.amazonaws.codecommit#ReplacementTypeRequiredException":
      response = {
        ...(await deserializeAws_json1_1ReplacementTypeRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryDoesNotExistException":
    case "com.amazonaws.codecommit#RepositoryDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1RepositoryDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryNameRequiredException":
    case "com.amazonaws.codecommit#RepositoryNameRequiredException":
      response = {
        ...(await deserializeAws_json1_1RepositoryNameRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TipsDivergenceExceededException":
    case "com.amazonaws.codecommit#TipsDivergenceExceededException":
      response = {
        ...(await deserializeAws_json1_1TipsDivergenceExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1MergePullRequestByFastForwardCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<MergePullRequestByFastForwardCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1MergePullRequestByFastForwardCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1MergePullRequestByFastForwardOutput(
    data,
    context
  );
  const response: MergePullRequestByFastForwardCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "MergePullRequestByFastForwardOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1MergePullRequestByFastForwardCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<MergePullRequestByFastForwardCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ConcurrentReferenceUpdateException":
    case "com.amazonaws.codecommit#ConcurrentReferenceUpdateException":
      response = {
        ...(await deserializeAws_json1_1ConcurrentReferenceUpdateExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionIntegrityChecksFailedException":
    case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionIntegrityChecksFailedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyAccessDeniedException":
    case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyAccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyDisabledException":
    case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyDisabledExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyNotFoundException":
    case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyUnavailableException":
    case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyUnavailableExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidCommitIdException":
    case "com.amazonaws.codecommit#InvalidCommitIdException":
      response = {
        ...(await deserializeAws_json1_1InvalidCommitIdExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidPullRequestIdException":
    case "com.amazonaws.codecommit#InvalidPullRequestIdException":
      response = {
        ...(await deserializeAws_json1_1InvalidPullRequestIdExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRepositoryNameException":
    case "com.amazonaws.codecommit#InvalidRepositoryNameException":
      response = {
        ...(await deserializeAws_json1_1InvalidRepositoryNameExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ManualMergeRequiredException":
    case "com.amazonaws.codecommit#ManualMergeRequiredException":
      response = {
        ...(await deserializeAws_json1_1ManualMergeRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "PullRequestAlreadyClosedException":
    case "com.amazonaws.codecommit#PullRequestAlreadyClosedException":
      response = {
        ...(await deserializeAws_json1_1PullRequestAlreadyClosedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "PullRequestApprovalRulesNotSatisfiedException":
    case "com.amazonaws.codecommit#PullRequestApprovalRulesNotSatisfiedException":
      response = {
        ...(await deserializeAws_json1_1PullRequestApprovalRulesNotSatisfiedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "PullRequestDoesNotExistException":
    case "com.amazonaws.codecommit#PullRequestDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1PullRequestDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "PullRequestIdRequiredException":
    case "com.amazonaws.codecommit#PullRequestIdRequiredException":
      response = {
        ...(await deserializeAws_json1_1PullRequestIdRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ReferenceDoesNotExistException":
    case "com.amazonaws.codecommit#ReferenceDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1ReferenceDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryDoesNotExistException":
    case "com.amazonaws.codecommit#RepositoryDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1RepositoryDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryNameRequiredException":
    case "com.amazonaws.codecommit#RepositoryNameRequiredException":
      response = {
        ...(await deserializeAws_json1_1RepositoryNameRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryNotAssociatedWithPullRequestException":
    case "com.amazonaws.codecommit#RepositoryNotAssociatedWithPullRequestException":
      response = {
        ...(await deserializeAws_json1_1RepositoryNotAssociatedWithPullRequestExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TipOfSourceReferenceIsDifferentException":
    case "com.amazonaws.codecommit#TipOfSourceReferenceIsDifferentException":
      response = {
        ...(await deserializeAws_json1_1TipOfSourceReferenceIsDifferentExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1MergePullRequestBySquashCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<MergePullRequestBySquashCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1MergePullRequestBySquashCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1MergePullRequestBySquashOutput(
    data,
    context
  );
  const response: MergePullRequestBySquashCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "MergePullRequestBySquashOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1MergePullRequestBySquashCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<MergePullRequestBySquashCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "CommitMessageLengthExceededException":
    case "com.amazonaws.codecommit#CommitMessageLengthExceededException":
      response = {
        ...(await deserializeAws_json1_1CommitMessageLengthExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ConcurrentReferenceUpdateException":
    case "com.amazonaws.codecommit#ConcurrentReferenceUpdateException":
      response = {
        ...(await deserializeAws_json1_1ConcurrentReferenceUpdateExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionIntegrityChecksFailedException":
    case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionIntegrityChecksFailedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyAccessDeniedException":
    case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyAccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyDisabledException":
    case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyDisabledExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyNotFoundException":
    case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyUnavailableException":
    case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyUnavailableExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "FileContentSizeLimitExceededException":
    case "com.amazonaws.codecommit#FileContentSizeLimitExceededException":
      response = {
        ...(await deserializeAws_json1_1FileContentSizeLimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "FolderContentSizeLimitExceededException":
    case "com.amazonaws.codecommit#FolderContentSizeLimitExceededException":
      response = {
        ...(await deserializeAws_json1_1FolderContentSizeLimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidCommitIdException":
    case "com.amazonaws.codecommit#InvalidCommitIdException":
      response = {
        ...(await deserializeAws_json1_1InvalidCommitIdExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidConflictDetailLevelException":
    case "com.amazonaws.codecommit#InvalidConflictDetailLevelException":
      response = {
        ...(await deserializeAws_json1_1InvalidConflictDetailLevelExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidConflictResolutionException":
    case "com.amazonaws.codecommit#InvalidConflictResolutionException":
      response = {
        ...(await deserializeAws_json1_1InvalidConflictResolutionExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidConflictResolutionStrategyException":
    case "com.amazonaws.codecommit#InvalidConflictResolutionStrategyException":
      response = {
        ...(await deserializeAws_json1_1InvalidConflictResolutionStrategyExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidEmailException":
    case "com.amazonaws.codecommit#InvalidEmailException":
      response = {
        ...(await deserializeAws_json1_1InvalidEmailExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidFileModeException":
    case "com.amazonaws.codecommit#InvalidFileModeException":
      response = {
        ...(await deserializeAws_json1_1InvalidFileModeExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidPathException":
    case "com.amazonaws.codecommit#InvalidPathException":
      response = {
        ...(await deserializeAws_json1_1InvalidPathExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidPullRequestIdException":
    case "com.amazonaws.codecommit#InvalidPullRequestIdException":
      response = {
        ...(await deserializeAws_json1_1InvalidPullRequestIdExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidReplacementContentException":
    case "com.amazonaws.codecommit#InvalidReplacementContentException":
      response = {
        ...(await deserializeAws_json1_1InvalidReplacementContentExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidReplacementTypeException":
    case "com.amazonaws.codecommit#InvalidReplacementTypeException":
      response = {
        ...(await deserializeAws_json1_1InvalidReplacementTypeExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRepositoryNameException":
    case "com.amazonaws.codecommit#InvalidRepositoryNameException":
      response = {
        ...(await deserializeAws_json1_1InvalidRepositoryNameExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ManualMergeRequiredException":
    case "com.amazonaws.codecommit#ManualMergeRequiredException":
      response = {
        ...(await deserializeAws_json1_1ManualMergeRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MaximumConflictResolutionEntriesExceededException":
    case "com.amazonaws.codecommit#MaximumConflictResolutionEntriesExceededException":
      response = {
        ...(await deserializeAws_json1_1MaximumConflictResolutionEntriesExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MaximumFileContentToLoadExceededException":
    case "com.amazonaws.codecommit#MaximumFileContentToLoadExceededException":
      response = {
        ...(await deserializeAws_json1_1MaximumFileContentToLoadExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MaximumItemsToCompareExceededException":
    case "com.amazonaws.codecommit#MaximumItemsToCompareExceededException":
      response = {
        ...(await deserializeAws_json1_1MaximumItemsToCompareExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MultipleConflictResolutionEntriesException":
    case "com.amazonaws.codecommit#MultipleConflictResolutionEntriesException":
      response = {
        ...(await deserializeAws_json1_1MultipleConflictResolutionEntriesExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NameLengthExceededException":
    case "com.amazonaws.codecommit#NameLengthExceededException":
      response = {
        ...(await deserializeAws_json1_1NameLengthExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "PathRequiredException":
    case "com.amazonaws.codecommit#PathRequiredException":
      response = {
        ...(await deserializeAws_json1_1PathRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "PullRequestAlreadyClosedException":
    case "com.amazonaws.codecommit#PullRequestAlreadyClosedException":
      response = {
        ...(await deserializeAws_json1_1PullRequestAlreadyClosedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "PullRequestApprovalRulesNotSatisfiedException":
    case "com.amazonaws.codecommit#PullRequestApprovalRulesNotSatisfiedException":
      response = {
        ...(await deserializeAws_json1_1PullRequestApprovalRulesNotSatisfiedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "PullRequestDoesNotExistException":
    case "com.amazonaws.codecommit#PullRequestDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1PullRequestDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "PullRequestIdRequiredException":
    case "com.amazonaws.codecommit#PullRequestIdRequiredException":
      response = {
        ...(await deserializeAws_json1_1PullRequestIdRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ReplacementContentRequiredException":
    case "com.amazonaws.codecommit#ReplacementContentRequiredException":
      response = {
        ...(await deserializeAws_json1_1ReplacementContentRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ReplacementTypeRequiredException":
    case "com.amazonaws.codecommit#ReplacementTypeRequiredException":
      response = {
        ...(await deserializeAws_json1_1ReplacementTypeRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryDoesNotExistException":
    case "com.amazonaws.codecommit#RepositoryDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1RepositoryDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryNameRequiredException":
    case "com.amazonaws.codecommit#RepositoryNameRequiredException":
      response = {
        ...(await deserializeAws_json1_1RepositoryNameRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryNotAssociatedWithPullRequestException":
    case "com.amazonaws.codecommit#RepositoryNotAssociatedWithPullRequestException":
      response = {
        ...(await deserializeAws_json1_1RepositoryNotAssociatedWithPullRequestExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TipOfSourceReferenceIsDifferentException":
    case "com.amazonaws.codecommit#TipOfSourceReferenceIsDifferentException":
      response = {
        ...(await deserializeAws_json1_1TipOfSourceReferenceIsDifferentExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TipsDivergenceExceededException":
    case "com.amazonaws.codecommit#TipsDivergenceExceededException":
      response = {
        ...(await deserializeAws_json1_1TipsDivergenceExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1MergePullRequestByThreeWayCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<MergePullRequestByThreeWayCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1MergePullRequestByThreeWayCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1MergePullRequestByThreeWayOutput(
    data,
    context
  );
  const response: MergePullRequestByThreeWayCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "MergePullRequestByThreeWayOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1MergePullRequestByThreeWayCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<MergePullRequestByThreeWayCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "CommitMessageLengthExceededException":
    case "com.amazonaws.codecommit#CommitMessageLengthExceededException":
      response = {
        ...(await deserializeAws_json1_1CommitMessageLengthExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ConcurrentReferenceUpdateException":
    case "com.amazonaws.codecommit#ConcurrentReferenceUpdateException":
      response = {
        ...(await deserializeAws_json1_1ConcurrentReferenceUpdateExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionIntegrityChecksFailedException":
    case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionIntegrityChecksFailedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyAccessDeniedException":
    case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyAccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyDisabledException":
    case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyDisabledExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyNotFoundException":
    case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyUnavailableException":
    case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyUnavailableExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "FileContentSizeLimitExceededException":
    case "com.amazonaws.codecommit#FileContentSizeLimitExceededException":
      response = {
        ...(await deserializeAws_json1_1FileContentSizeLimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "FolderContentSizeLimitExceededException":
    case "com.amazonaws.codecommit#FolderContentSizeLimitExceededException":
      response = {
        ...(await deserializeAws_json1_1FolderContentSizeLimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidCommitIdException":
    case "com.amazonaws.codecommit#InvalidCommitIdException":
      response = {
        ...(await deserializeAws_json1_1InvalidCommitIdExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidConflictDetailLevelException":
    case "com.amazonaws.codecommit#InvalidConflictDetailLevelException":
      response = {
        ...(await deserializeAws_json1_1InvalidConflictDetailLevelExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidConflictResolutionException":
    case "com.amazonaws.codecommit#InvalidConflictResolutionException":
      response = {
        ...(await deserializeAws_json1_1InvalidConflictResolutionExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidConflictResolutionStrategyException":
    case "com.amazonaws.codecommit#InvalidConflictResolutionStrategyException":
      response = {
        ...(await deserializeAws_json1_1InvalidConflictResolutionStrategyExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidEmailException":
    case "com.amazonaws.codecommit#InvalidEmailException":
      response = {
        ...(await deserializeAws_json1_1InvalidEmailExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidFileModeException":
    case "com.amazonaws.codecommit#InvalidFileModeException":
      response = {
        ...(await deserializeAws_json1_1InvalidFileModeExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidPathException":
    case "com.amazonaws.codecommit#InvalidPathException":
      response = {
        ...(await deserializeAws_json1_1InvalidPathExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidPullRequestIdException":
    case "com.amazonaws.codecommit#InvalidPullRequestIdException":
      response = {
        ...(await deserializeAws_json1_1InvalidPullRequestIdExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidReplacementContentException":
    case "com.amazonaws.codecommit#InvalidReplacementContentException":
      response = {
        ...(await deserializeAws_json1_1InvalidReplacementContentExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidReplacementTypeException":
    case "com.amazonaws.codecommit#InvalidReplacementTypeException":
      response = {
        ...(await deserializeAws_json1_1InvalidReplacementTypeExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRepositoryNameException":
    case "com.amazonaws.codecommit#InvalidRepositoryNameException":
      response = {
        ...(await deserializeAws_json1_1InvalidRepositoryNameExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ManualMergeRequiredException":
    case "com.amazonaws.codecommit#ManualMergeRequiredException":
      response = {
        ...(await deserializeAws_json1_1ManualMergeRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MaximumConflictResolutionEntriesExceededException":
    case "com.amazonaws.codecommit#MaximumConflictResolutionEntriesExceededException":
      response = {
        ...(await deserializeAws_json1_1MaximumConflictResolutionEntriesExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MaximumFileContentToLoadExceededException":
    case "com.amazonaws.codecommit#MaximumFileContentToLoadExceededException":
      response = {
        ...(await deserializeAws_json1_1MaximumFileContentToLoadExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MaximumItemsToCompareExceededException":
    case "com.amazonaws.codecommit#MaximumItemsToCompareExceededException":
      response = {
        ...(await deserializeAws_json1_1MaximumItemsToCompareExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MultipleConflictResolutionEntriesException":
    case "com.amazonaws.codecommit#MultipleConflictResolutionEntriesException":
      response = {
        ...(await deserializeAws_json1_1MultipleConflictResolutionEntriesExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NameLengthExceededException":
    case "com.amazonaws.codecommit#NameLengthExceededException":
      response = {
        ...(await deserializeAws_json1_1NameLengthExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "PathRequiredException":
    case "com.amazonaws.codecommit#PathRequiredException":
      response = {
        ...(await deserializeAws_json1_1PathRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "PullRequestAlreadyClosedException":
    case "com.amazonaws.codecommit#PullRequestAlreadyClosedException":
      response = {
        ...(await deserializeAws_json1_1PullRequestAlreadyClosedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "PullRequestApprovalRulesNotSatisfiedException":
    case "com.amazonaws.codecommit#PullRequestApprovalRulesNotSatisfiedException":
      response = {
        ...(await deserializeAws_json1_1PullRequestApprovalRulesNotSatisfiedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "PullRequestDoesNotExistException":
    case "com.amazonaws.codecommit#PullRequestDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1PullRequestDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "PullRequestIdRequiredException":
    case "com.amazonaws.codecommit#PullRequestIdRequiredException":
      response = {
        ...(await deserializeAws_json1_1PullRequestIdRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ReplacementContentRequiredException":
    case "com.amazonaws.codecommit#ReplacementContentRequiredException":
      response = {
        ...(await deserializeAws_json1_1ReplacementContentRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ReplacementTypeRequiredException":
    case "com.amazonaws.codecommit#ReplacementTypeRequiredException":
      response = {
        ...(await deserializeAws_json1_1ReplacementTypeRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryDoesNotExistException":
    case "com.amazonaws.codecommit#RepositoryDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1RepositoryDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryNameRequiredException":
    case "com.amazonaws.codecommit#RepositoryNameRequiredException":
      response = {
        ...(await deserializeAws_json1_1RepositoryNameRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryNotAssociatedWithPullRequestException":
    case "com.amazonaws.codecommit#RepositoryNotAssociatedWithPullRequestException":
      response = {
        ...(await deserializeAws_json1_1RepositoryNotAssociatedWithPullRequestExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TipOfSourceReferenceIsDifferentException":
    case "com.amazonaws.codecommit#TipOfSourceReferenceIsDifferentException":
      response = {
        ...(await deserializeAws_json1_1TipOfSourceReferenceIsDifferentExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TipsDivergenceExceededException":
    case "com.amazonaws.codecommit#TipsDivergenceExceededException":
      response = {
        ...(await deserializeAws_json1_1TipsDivergenceExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1OverridePullRequestApprovalRulesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<OverridePullRequestApprovalRulesCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1OverridePullRequestApprovalRulesCommandError(
      output,
      context
    );
  }
  await collectBody(output.body, context);
  const response: OverridePullRequestApprovalRulesCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1OverridePullRequestApprovalRulesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<OverridePullRequestApprovalRulesCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EncryptionIntegrityChecksFailedException":
    case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionIntegrityChecksFailedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyAccessDeniedException":
    case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyAccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyDisabledException":
    case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyDisabledExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyNotFoundException":
    case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyUnavailableException":
    case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyUnavailableExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidOverrideStatusException":
    case "com.amazonaws.codecommit#InvalidOverrideStatusException":
      response = {
        ...(await deserializeAws_json1_1InvalidOverrideStatusExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidPullRequestIdException":
    case "com.amazonaws.codecommit#InvalidPullRequestIdException":
      response = {
        ...(await deserializeAws_json1_1InvalidPullRequestIdExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRevisionIdException":
    case "com.amazonaws.codecommit#InvalidRevisionIdException":
      response = {
        ...(await deserializeAws_json1_1InvalidRevisionIdExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OverrideAlreadySetException":
    case "com.amazonaws.codecommit#OverrideAlreadySetException":
      response = {
        ...(await deserializeAws_json1_1OverrideAlreadySetExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OverrideStatusRequiredException":
    case "com.amazonaws.codecommit#OverrideStatusRequiredException":
      response = {
        ...(await deserializeAws_json1_1OverrideStatusRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "PullRequestAlreadyClosedException":
    case "com.amazonaws.codecommit#PullRequestAlreadyClosedException":
      response = {
        ...(await deserializeAws_json1_1PullRequestAlreadyClosedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "PullRequestDoesNotExistException":
    case "com.amazonaws.codecommit#PullRequestDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1PullRequestDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "PullRequestIdRequiredException":
    case "com.amazonaws.codecommit#PullRequestIdRequiredException":
      response = {
        ...(await deserializeAws_json1_1PullRequestIdRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RevisionIdRequiredException":
    case "com.amazonaws.codecommit#RevisionIdRequiredException":
      response = {
        ...(await deserializeAws_json1_1RevisionIdRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RevisionNotCurrentException":
    case "com.amazonaws.codecommit#RevisionNotCurrentException":
      response = {
        ...(await deserializeAws_json1_1RevisionNotCurrentExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1PostCommentForComparedCommitCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PostCommentForComparedCommitCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1PostCommentForComparedCommitCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1PostCommentForComparedCommitOutput(
    data,
    context
  );
  const response: PostCommentForComparedCommitCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "PostCommentForComparedCommitOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1PostCommentForComparedCommitCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PostCommentForComparedCommitCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "BeforeCommitIdAndAfterCommitIdAreSameException":
    case "com.amazonaws.codecommit#BeforeCommitIdAndAfterCommitIdAreSameException":
      response = {
        ...(await deserializeAws_json1_1BeforeCommitIdAndAfterCommitIdAreSameExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ClientRequestTokenRequiredException":
    case "com.amazonaws.codecommit#ClientRequestTokenRequiredException":
      response = {
        ...(await deserializeAws_json1_1ClientRequestTokenRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "CommentContentRequiredException":
    case "com.amazonaws.codecommit#CommentContentRequiredException":
      response = {
        ...(await deserializeAws_json1_1CommentContentRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "CommentContentSizeLimitExceededException":
    case "com.amazonaws.codecommit#CommentContentSizeLimitExceededException":
      response = {
        ...(await deserializeAws_json1_1CommentContentSizeLimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "CommitDoesNotExistException":
    case "com.amazonaws.codecommit#CommitDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1CommitDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "CommitIdRequiredException":
    case "com.amazonaws.codecommit#CommitIdRequiredException":
      response = {
        ...(await deserializeAws_json1_1CommitIdRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionIntegrityChecksFailedException":
    case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionIntegrityChecksFailedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyAccessDeniedException":
    case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyAccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyDisabledException":
    case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyDisabledExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyNotFoundException":
    case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyUnavailableException":
    case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyUnavailableExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "IdempotencyParameterMismatchException":
    case "com.amazonaws.codecommit#IdempotencyParameterMismatchException":
      response = {
        ...(await deserializeAws_json1_1IdempotencyParameterMismatchExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidClientRequestTokenException":
    case "com.amazonaws.codecommit#InvalidClientRequestTokenException":
      response = {
        ...(await deserializeAws_json1_1InvalidClientRequestTokenExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidCommitIdException":
    case "com.amazonaws.codecommit#InvalidCommitIdException":
      response = {
        ...(await deserializeAws_json1_1InvalidCommitIdExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidFileLocationException":
    case "com.amazonaws.codecommit#InvalidFileLocationException":
      response = {
        ...(await deserializeAws_json1_1InvalidFileLocationExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidFilePositionException":
    case "com.amazonaws.codecommit#InvalidFilePositionException":
      response = {
        ...(await deserializeAws_json1_1InvalidFilePositionExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidPathException":
    case "com.amazonaws.codecommit#InvalidPathException":
      response = {
        ...(await deserializeAws_json1_1InvalidPathExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRelativeFileVersionEnumException":
    case "com.amazonaws.codecommit#InvalidRelativeFileVersionEnumException":
      response = {
        ...(await deserializeAws_json1_1InvalidRelativeFileVersionEnumExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRepositoryNameException":
    case "com.amazonaws.codecommit#InvalidRepositoryNameException":
      response = {
        ...(await deserializeAws_json1_1InvalidRepositoryNameExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "PathDoesNotExistException":
    case "com.amazonaws.codecommit#PathDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1PathDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "PathRequiredException":
    case "com.amazonaws.codecommit#PathRequiredException":
      response = {
        ...(await deserializeAws_json1_1PathRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryDoesNotExistException":
    case "com.amazonaws.codecommit#RepositoryDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1RepositoryDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryNameRequiredException":
    case "com.amazonaws.codecommit#RepositoryNameRequiredException":
      response = {
        ...(await deserializeAws_json1_1RepositoryNameRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1PostCommentForPullRequestCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PostCommentForPullRequestCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1PostCommentForPullRequestCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1PostCommentForPullRequestOutput(
    data,
    context
  );
  const response: PostCommentForPullRequestCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "PostCommentForPullRequestOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1PostCommentForPullRequestCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PostCommentForPullRequestCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "BeforeCommitIdAndAfterCommitIdAreSameException":
    case "com.amazonaws.codecommit#BeforeCommitIdAndAfterCommitIdAreSameException":
      response = {
        ...(await deserializeAws_json1_1BeforeCommitIdAndAfterCommitIdAreSameExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ClientRequestTokenRequiredException":
    case "com.amazonaws.codecommit#ClientRequestTokenRequiredException":
      response = {
        ...(await deserializeAws_json1_1ClientRequestTokenRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "CommentContentRequiredException":
    case "com.amazonaws.codecommit#CommentContentRequiredException":
      response = {
        ...(await deserializeAws_json1_1CommentContentRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "CommentContentSizeLimitExceededException":
    case "com.amazonaws.codecommit#CommentContentSizeLimitExceededException":
      response = {
        ...(await deserializeAws_json1_1CommentContentSizeLimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "CommitDoesNotExistException":
    case "com.amazonaws.codecommit#CommitDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1CommitDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "CommitIdRequiredException":
    case "com.amazonaws.codecommit#CommitIdRequiredException":
      response = {
        ...(await deserializeAws_json1_1CommitIdRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionIntegrityChecksFailedException":
    case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionIntegrityChecksFailedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyAccessDeniedException":
    case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyAccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyDisabledException":
    case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyDisabledExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyNotFoundException":
    case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyUnavailableException":
    case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyUnavailableExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "IdempotencyParameterMismatchException":
    case "com.amazonaws.codecommit#IdempotencyParameterMismatchException":
      response = {
        ...(await deserializeAws_json1_1IdempotencyParameterMismatchExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidClientRequestTokenException":
    case "com.amazonaws.codecommit#InvalidClientRequestTokenException":
      response = {
        ...(await deserializeAws_json1_1InvalidClientRequestTokenExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidCommitIdException":
    case "com.amazonaws.codecommit#InvalidCommitIdException":
      response = {
        ...(await deserializeAws_json1_1InvalidCommitIdExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidFileLocationException":
    case "com.amazonaws.codecommit#InvalidFileLocationException":
      response = {
        ...(await deserializeAws_json1_1InvalidFileLocationExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidFilePositionException":
    case "com.amazonaws.codecommit#InvalidFilePositionException":
      response = {
        ...(await deserializeAws_json1_1InvalidFilePositionExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidPathException":
    case "com.amazonaws.codecommit#InvalidPathException":
      response = {
        ...(await deserializeAws_json1_1InvalidPathExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidPullRequestIdException":
    case "com.amazonaws.codecommit#InvalidPullRequestIdException":
      response = {
        ...(await deserializeAws_json1_1InvalidPullRequestIdExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRelativeFileVersionEnumException":
    case "com.amazonaws.codecommit#InvalidRelativeFileVersionEnumException":
      response = {
        ...(await deserializeAws_json1_1InvalidRelativeFileVersionEnumExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRepositoryNameException":
    case "com.amazonaws.codecommit#InvalidRepositoryNameException":
      response = {
        ...(await deserializeAws_json1_1InvalidRepositoryNameExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "PathDoesNotExistException":
    case "com.amazonaws.codecommit#PathDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1PathDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "PathRequiredException":
    case "com.amazonaws.codecommit#PathRequiredException":
      response = {
        ...(await deserializeAws_json1_1PathRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "PullRequestDoesNotExistException":
    case "com.amazonaws.codecommit#PullRequestDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1PullRequestDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "PullRequestIdRequiredException":
    case "com.amazonaws.codecommit#PullRequestIdRequiredException":
      response = {
        ...(await deserializeAws_json1_1PullRequestIdRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryDoesNotExistException":
    case "com.amazonaws.codecommit#RepositoryDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1RepositoryDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryNameRequiredException":
    case "com.amazonaws.codecommit#RepositoryNameRequiredException":
      response = {
        ...(await deserializeAws_json1_1RepositoryNameRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryNotAssociatedWithPullRequestException":
    case "com.amazonaws.codecommit#RepositoryNotAssociatedWithPullRequestException":
      response = {
        ...(await deserializeAws_json1_1RepositoryNotAssociatedWithPullRequestExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1PostCommentReplyCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PostCommentReplyCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1PostCommentReplyCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1PostCommentReplyOutput(data, context);
  const response: PostCommentReplyCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "PostCommentReplyOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1PostCommentReplyCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PostCommentReplyCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ClientRequestTokenRequiredException":
    case "com.amazonaws.codecommit#ClientRequestTokenRequiredException":
      response = {
        ...(await deserializeAws_json1_1ClientRequestTokenRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "CommentContentRequiredException":
    case "com.amazonaws.codecommit#CommentContentRequiredException":
      response = {
        ...(await deserializeAws_json1_1CommentContentRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "CommentContentSizeLimitExceededException":
    case "com.amazonaws.codecommit#CommentContentSizeLimitExceededException":
      response = {
        ...(await deserializeAws_json1_1CommentContentSizeLimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "CommentDoesNotExistException":
    case "com.amazonaws.codecommit#CommentDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1CommentDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "CommentIdRequiredException":
    case "com.amazonaws.codecommit#CommentIdRequiredException":
      response = {
        ...(await deserializeAws_json1_1CommentIdRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "IdempotencyParameterMismatchException":
    case "com.amazonaws.codecommit#IdempotencyParameterMismatchException":
      response = {
        ...(await deserializeAws_json1_1IdempotencyParameterMismatchExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidClientRequestTokenException":
    case "com.amazonaws.codecommit#InvalidClientRequestTokenException":
      response = {
        ...(await deserializeAws_json1_1InvalidClientRequestTokenExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidCommentIdException":
    case "com.amazonaws.codecommit#InvalidCommentIdException":
      response = {
        ...(await deserializeAws_json1_1InvalidCommentIdExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1PutFileCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutFileCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1PutFileCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1PutFileOutput(data, context);
  const response: PutFileCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "PutFileOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1PutFileCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutFileCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "BranchDoesNotExistException":
    case "com.amazonaws.codecommit#BranchDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1BranchDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "BranchNameIsTagNameException":
    case "com.amazonaws.codecommit#BranchNameIsTagNameException":
      response = {
        ...(await deserializeAws_json1_1BranchNameIsTagNameExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "BranchNameRequiredException":
    case "com.amazonaws.codecommit#BranchNameRequiredException":
      response = {
        ...(await deserializeAws_json1_1BranchNameRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "CommitMessageLengthExceededException":
    case "com.amazonaws.codecommit#CommitMessageLengthExceededException":
      response = {
        ...(await deserializeAws_json1_1CommitMessageLengthExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DirectoryNameConflictsWithFileNameException":
    case "com.amazonaws.codecommit#DirectoryNameConflictsWithFileNameException":
      response = {
        ...(await deserializeAws_json1_1DirectoryNameConflictsWithFileNameExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionIntegrityChecksFailedException":
    case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionIntegrityChecksFailedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyAccessDeniedException":
    case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyAccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyDisabledException":
    case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyDisabledExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyNotFoundException":
    case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyUnavailableException":
    case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyUnavailableExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "FileContentRequiredException":
    case "com.amazonaws.codecommit#FileContentRequiredException":
      response = {
        ...(await deserializeAws_json1_1FileContentRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "FileContentSizeLimitExceededException":
    case "com.amazonaws.codecommit#FileContentSizeLimitExceededException":
      response = {
        ...(await deserializeAws_json1_1FileContentSizeLimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "FileNameConflictsWithDirectoryNameException":
    case "com.amazonaws.codecommit#FileNameConflictsWithDirectoryNameException":
      response = {
        ...(await deserializeAws_json1_1FileNameConflictsWithDirectoryNameExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "FilePathConflictsWithSubmodulePathException":
    case "com.amazonaws.codecommit#FilePathConflictsWithSubmodulePathException":
      response = {
        ...(await deserializeAws_json1_1FilePathConflictsWithSubmodulePathExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "FolderContentSizeLimitExceededException":
    case "com.amazonaws.codecommit#FolderContentSizeLimitExceededException":
      response = {
        ...(await deserializeAws_json1_1FolderContentSizeLimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidBranchNameException":
    case "com.amazonaws.codecommit#InvalidBranchNameException":
      response = {
        ...(await deserializeAws_json1_1InvalidBranchNameExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDeletionParameterException":
    case "com.amazonaws.codecommit#InvalidDeletionParameterException":
      response = {
        ...(await deserializeAws_json1_1InvalidDeletionParameterExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidEmailException":
    case "com.amazonaws.codecommit#InvalidEmailException":
      response = {
        ...(await deserializeAws_json1_1InvalidEmailExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidFileModeException":
    case "com.amazonaws.codecommit#InvalidFileModeException":
      response = {
        ...(await deserializeAws_json1_1InvalidFileModeExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidParentCommitIdException":
    case "com.amazonaws.codecommit#InvalidParentCommitIdException":
      response = {
        ...(await deserializeAws_json1_1InvalidParentCommitIdExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidPathException":
    case "com.amazonaws.codecommit#InvalidPathException":
      response = {
        ...(await deserializeAws_json1_1InvalidPathExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRepositoryNameException":
    case "com.amazonaws.codecommit#InvalidRepositoryNameException":
      response = {
        ...(await deserializeAws_json1_1InvalidRepositoryNameExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NameLengthExceededException":
    case "com.amazonaws.codecommit#NameLengthExceededException":
      response = {
        ...(await deserializeAws_json1_1NameLengthExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ParentCommitDoesNotExistException":
    case "com.amazonaws.codecommit#ParentCommitDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1ParentCommitDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ParentCommitIdOutdatedException":
    case "com.amazonaws.codecommit#ParentCommitIdOutdatedException":
      response = {
        ...(await deserializeAws_json1_1ParentCommitIdOutdatedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ParentCommitIdRequiredException":
    case "com.amazonaws.codecommit#ParentCommitIdRequiredException":
      response = {
        ...(await deserializeAws_json1_1ParentCommitIdRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "PathRequiredException":
    case "com.amazonaws.codecommit#PathRequiredException":
      response = {
        ...(await deserializeAws_json1_1PathRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryDoesNotExistException":
    case "com.amazonaws.codecommit#RepositoryDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1RepositoryDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryNameRequiredException":
    case "com.amazonaws.codecommit#RepositoryNameRequiredException":
      response = {
        ...(await deserializeAws_json1_1RepositoryNameRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "SameFileContentException":
    case "com.amazonaws.codecommit#SameFileContentException":
      response = {
        ...(await deserializeAws_json1_1SameFileContentExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1PutRepositoryTriggersCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutRepositoryTriggersCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1PutRepositoryTriggersCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1PutRepositoryTriggersOutput(data, context);
  const response: PutRepositoryTriggersCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "PutRepositoryTriggersOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1PutRepositoryTriggersCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutRepositoryTriggersCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EncryptionIntegrityChecksFailedException":
    case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionIntegrityChecksFailedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyAccessDeniedException":
    case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyAccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyDisabledException":
    case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyDisabledExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyNotFoundException":
    case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyUnavailableException":
    case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyUnavailableExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRepositoryNameException":
    case "com.amazonaws.codecommit#InvalidRepositoryNameException":
      response = {
        ...(await deserializeAws_json1_1InvalidRepositoryNameExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRepositoryTriggerBranchNameException":
    case "com.amazonaws.codecommit#InvalidRepositoryTriggerBranchNameException":
      response = {
        ...(await deserializeAws_json1_1InvalidRepositoryTriggerBranchNameExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRepositoryTriggerCustomDataException":
    case "com.amazonaws.codecommit#InvalidRepositoryTriggerCustomDataException":
      response = {
        ...(await deserializeAws_json1_1InvalidRepositoryTriggerCustomDataExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRepositoryTriggerDestinationArnException":
    case "com.amazonaws.codecommit#InvalidRepositoryTriggerDestinationArnException":
      response = {
        ...(await deserializeAws_json1_1InvalidRepositoryTriggerDestinationArnExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRepositoryTriggerEventsException":
    case "com.amazonaws.codecommit#InvalidRepositoryTriggerEventsException":
      response = {
        ...(await deserializeAws_json1_1InvalidRepositoryTriggerEventsExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRepositoryTriggerNameException":
    case "com.amazonaws.codecommit#InvalidRepositoryTriggerNameException":
      response = {
        ...(await deserializeAws_json1_1InvalidRepositoryTriggerNameExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRepositoryTriggerRegionException":
    case "com.amazonaws.codecommit#InvalidRepositoryTriggerRegionException":
      response = {
        ...(await deserializeAws_json1_1InvalidRepositoryTriggerRegionExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MaximumBranchesExceededException":
    case "com.amazonaws.codecommit#MaximumBranchesExceededException":
      response = {
        ...(await deserializeAws_json1_1MaximumBranchesExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MaximumRepositoryTriggersExceededException":
    case "com.amazonaws.codecommit#MaximumRepositoryTriggersExceededException":
      response = {
        ...(await deserializeAws_json1_1MaximumRepositoryTriggersExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryDoesNotExistException":
    case "com.amazonaws.codecommit#RepositoryDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1RepositoryDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryNameRequiredException":
    case "com.amazonaws.codecommit#RepositoryNameRequiredException":
      response = {
        ...(await deserializeAws_json1_1RepositoryNameRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryTriggerBranchNameListRequiredException":
    case "com.amazonaws.codecommit#RepositoryTriggerBranchNameListRequiredException":
      response = {
        ...(await deserializeAws_json1_1RepositoryTriggerBranchNameListRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryTriggerDestinationArnRequiredException":
    case "com.amazonaws.codecommit#RepositoryTriggerDestinationArnRequiredException":
      response = {
        ...(await deserializeAws_json1_1RepositoryTriggerDestinationArnRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryTriggerEventsListRequiredException":
    case "com.amazonaws.codecommit#RepositoryTriggerEventsListRequiredException":
      response = {
        ...(await deserializeAws_json1_1RepositoryTriggerEventsListRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryTriggerNameRequiredException":
    case "com.amazonaws.codecommit#RepositoryTriggerNameRequiredException":
      response = {
        ...(await deserializeAws_json1_1RepositoryTriggerNameRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryTriggersListRequiredException":
    case "com.amazonaws.codecommit#RepositoryTriggersListRequiredException":
      response = {
        ...(await deserializeAws_json1_1RepositoryTriggersListRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1TagResourceCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<TagResourceCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1TagResourceCommandError(output, context);
  }
  await collectBody(output.body, context);
  const response: TagResourceCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1TagResourceCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<TagResourceCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InvalidRepositoryNameException":
    case "com.amazonaws.codecommit#InvalidRepositoryNameException":
      response = {
        ...(await deserializeAws_json1_1InvalidRepositoryNameExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidResourceArnException":
    case "com.amazonaws.codecommit#InvalidResourceArnException":
      response = {
        ...(await deserializeAws_json1_1InvalidResourceArnExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidSystemTagUsageException":
    case "com.amazonaws.codecommit#InvalidSystemTagUsageException":
      response = {
        ...(await deserializeAws_json1_1InvalidSystemTagUsageExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidTagsMapException":
    case "com.amazonaws.codecommit#InvalidTagsMapException":
      response = {
        ...(await deserializeAws_json1_1InvalidTagsMapExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryDoesNotExistException":
    case "com.amazonaws.codecommit#RepositoryDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1RepositoryDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceArnRequiredException":
    case "com.amazonaws.codecommit#ResourceArnRequiredException":
      response = {
        ...(await deserializeAws_json1_1ResourceArnRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TagPolicyException":
    case "com.amazonaws.codecommit#TagPolicyException":
      response = {
        ...(await deserializeAws_json1_1TagPolicyExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TagsMapRequiredException":
    case "com.amazonaws.codecommit#TagsMapRequiredException":
      response = {
        ...(await deserializeAws_json1_1TagsMapRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyTagsException":
    case "com.amazonaws.codecommit#TooManyTagsException":
      response = {
        ...(await deserializeAws_json1_1TooManyTagsExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1TestRepositoryTriggersCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<TestRepositoryTriggersCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1TestRepositoryTriggersCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1TestRepositoryTriggersOutput(data, context);
  const response: TestRepositoryTriggersCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "TestRepositoryTriggersOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1TestRepositoryTriggersCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<TestRepositoryTriggersCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EncryptionIntegrityChecksFailedException":
    case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionIntegrityChecksFailedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyAccessDeniedException":
    case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyAccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyDisabledException":
    case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyDisabledExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyNotFoundException":
    case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyUnavailableException":
    case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyUnavailableExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRepositoryNameException":
    case "com.amazonaws.codecommit#InvalidRepositoryNameException":
      response = {
        ...(await deserializeAws_json1_1InvalidRepositoryNameExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRepositoryTriggerBranchNameException":
    case "com.amazonaws.codecommit#InvalidRepositoryTriggerBranchNameException":
      response = {
        ...(await deserializeAws_json1_1InvalidRepositoryTriggerBranchNameExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRepositoryTriggerCustomDataException":
    case "com.amazonaws.codecommit#InvalidRepositoryTriggerCustomDataException":
      response = {
        ...(await deserializeAws_json1_1InvalidRepositoryTriggerCustomDataExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRepositoryTriggerDestinationArnException":
    case "com.amazonaws.codecommit#InvalidRepositoryTriggerDestinationArnException":
      response = {
        ...(await deserializeAws_json1_1InvalidRepositoryTriggerDestinationArnExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRepositoryTriggerEventsException":
    case "com.amazonaws.codecommit#InvalidRepositoryTriggerEventsException":
      response = {
        ...(await deserializeAws_json1_1InvalidRepositoryTriggerEventsExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRepositoryTriggerNameException":
    case "com.amazonaws.codecommit#InvalidRepositoryTriggerNameException":
      response = {
        ...(await deserializeAws_json1_1InvalidRepositoryTriggerNameExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRepositoryTriggerRegionException":
    case "com.amazonaws.codecommit#InvalidRepositoryTriggerRegionException":
      response = {
        ...(await deserializeAws_json1_1InvalidRepositoryTriggerRegionExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MaximumBranchesExceededException":
    case "com.amazonaws.codecommit#MaximumBranchesExceededException":
      response = {
        ...(await deserializeAws_json1_1MaximumBranchesExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MaximumRepositoryTriggersExceededException":
    case "com.amazonaws.codecommit#MaximumRepositoryTriggersExceededException":
      response = {
        ...(await deserializeAws_json1_1MaximumRepositoryTriggersExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryDoesNotExistException":
    case "com.amazonaws.codecommit#RepositoryDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1RepositoryDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryNameRequiredException":
    case "com.amazonaws.codecommit#RepositoryNameRequiredException":
      response = {
        ...(await deserializeAws_json1_1RepositoryNameRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryTriggerBranchNameListRequiredException":
    case "com.amazonaws.codecommit#RepositoryTriggerBranchNameListRequiredException":
      response = {
        ...(await deserializeAws_json1_1RepositoryTriggerBranchNameListRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryTriggerDestinationArnRequiredException":
    case "com.amazonaws.codecommit#RepositoryTriggerDestinationArnRequiredException":
      response = {
        ...(await deserializeAws_json1_1RepositoryTriggerDestinationArnRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryTriggerEventsListRequiredException":
    case "com.amazonaws.codecommit#RepositoryTriggerEventsListRequiredException":
      response = {
        ...(await deserializeAws_json1_1RepositoryTriggerEventsListRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryTriggerNameRequiredException":
    case "com.amazonaws.codecommit#RepositoryTriggerNameRequiredException":
      response = {
        ...(await deserializeAws_json1_1RepositoryTriggerNameRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryTriggersListRequiredException":
    case "com.amazonaws.codecommit#RepositoryTriggersListRequiredException":
      response = {
        ...(await deserializeAws_json1_1RepositoryTriggersListRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1UntagResourceCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UntagResourceCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UntagResourceCommandError(output, context);
  }
  await collectBody(output.body, context);
  const response: UntagResourceCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1UntagResourceCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UntagResourceCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InvalidRepositoryNameException":
    case "com.amazonaws.codecommit#InvalidRepositoryNameException":
      response = {
        ...(await deserializeAws_json1_1InvalidRepositoryNameExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidResourceArnException":
    case "com.amazonaws.codecommit#InvalidResourceArnException":
      response = {
        ...(await deserializeAws_json1_1InvalidResourceArnExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidSystemTagUsageException":
    case "com.amazonaws.codecommit#InvalidSystemTagUsageException":
      response = {
        ...(await deserializeAws_json1_1InvalidSystemTagUsageExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidTagKeysListException":
    case "com.amazonaws.codecommit#InvalidTagKeysListException":
      response = {
        ...(await deserializeAws_json1_1InvalidTagKeysListExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryDoesNotExistException":
    case "com.amazonaws.codecommit#RepositoryDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1RepositoryDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceArnRequiredException":
    case "com.amazonaws.codecommit#ResourceArnRequiredException":
      response = {
        ...(await deserializeAws_json1_1ResourceArnRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TagKeysListRequiredException":
    case "com.amazonaws.codecommit#TagKeysListRequiredException":
      response = {
        ...(await deserializeAws_json1_1TagKeysListRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TagPolicyException":
    case "com.amazonaws.codecommit#TagPolicyException":
      response = {
        ...(await deserializeAws_json1_1TagPolicyExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyTagsException":
    case "com.amazonaws.codecommit#TooManyTagsException":
      response = {
        ...(await deserializeAws_json1_1TooManyTagsExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1UpdateApprovalRuleTemplateContentCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateApprovalRuleTemplateContentCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateApprovalRuleTemplateContentCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdateApprovalRuleTemplateContentOutput(
    data,
    context
  );
  const response: UpdateApprovalRuleTemplateContentCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateApprovalRuleTemplateContentOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1UpdateApprovalRuleTemplateContentCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateApprovalRuleTemplateContentCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ApprovalRuleTemplateContentRequiredException":
    case "com.amazonaws.codecommit#ApprovalRuleTemplateContentRequiredException":
      response = {
        ...(await deserializeAws_json1_1ApprovalRuleTemplateContentRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ApprovalRuleTemplateDoesNotExistException":
    case "com.amazonaws.codecommit#ApprovalRuleTemplateDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1ApprovalRuleTemplateDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ApprovalRuleTemplateNameRequiredException":
    case "com.amazonaws.codecommit#ApprovalRuleTemplateNameRequiredException":
      response = {
        ...(await deserializeAws_json1_1ApprovalRuleTemplateNameRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidApprovalRuleTemplateContentException":
    case "com.amazonaws.codecommit#InvalidApprovalRuleTemplateContentException":
      response = {
        ...(await deserializeAws_json1_1InvalidApprovalRuleTemplateContentExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidApprovalRuleTemplateNameException":
    case "com.amazonaws.codecommit#InvalidApprovalRuleTemplateNameException":
      response = {
        ...(await deserializeAws_json1_1InvalidApprovalRuleTemplateNameExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRuleContentSha256Exception":
    case "com.amazonaws.codecommit#InvalidRuleContentSha256Exception":
      response = {
        ...(await deserializeAws_json1_1InvalidRuleContentSha256ExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1UpdateApprovalRuleTemplateDescriptionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateApprovalRuleTemplateDescriptionCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateApprovalRuleTemplateDescriptionCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdateApprovalRuleTemplateDescriptionOutput(
    data,
    context
  );
  const response: UpdateApprovalRuleTemplateDescriptionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateApprovalRuleTemplateDescriptionOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1UpdateApprovalRuleTemplateDescriptionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateApprovalRuleTemplateDescriptionCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ApprovalRuleTemplateDoesNotExistException":
    case "com.amazonaws.codecommit#ApprovalRuleTemplateDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1ApprovalRuleTemplateDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ApprovalRuleTemplateNameRequiredException":
    case "com.amazonaws.codecommit#ApprovalRuleTemplateNameRequiredException":
      response = {
        ...(await deserializeAws_json1_1ApprovalRuleTemplateNameRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidApprovalRuleTemplateDescriptionException":
    case "com.amazonaws.codecommit#InvalidApprovalRuleTemplateDescriptionException":
      response = {
        ...(await deserializeAws_json1_1InvalidApprovalRuleTemplateDescriptionExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidApprovalRuleTemplateNameException":
    case "com.amazonaws.codecommit#InvalidApprovalRuleTemplateNameException":
      response = {
        ...(await deserializeAws_json1_1InvalidApprovalRuleTemplateNameExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1UpdateApprovalRuleTemplateNameCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateApprovalRuleTemplateNameCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateApprovalRuleTemplateNameCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdateApprovalRuleTemplateNameOutput(
    data,
    context
  );
  const response: UpdateApprovalRuleTemplateNameCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateApprovalRuleTemplateNameOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1UpdateApprovalRuleTemplateNameCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateApprovalRuleTemplateNameCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ApprovalRuleTemplateDoesNotExistException":
    case "com.amazonaws.codecommit#ApprovalRuleTemplateDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1ApprovalRuleTemplateDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ApprovalRuleTemplateNameAlreadyExistsException":
    case "com.amazonaws.codecommit#ApprovalRuleTemplateNameAlreadyExistsException":
      response = {
        ...(await deserializeAws_json1_1ApprovalRuleTemplateNameAlreadyExistsExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ApprovalRuleTemplateNameRequiredException":
    case "com.amazonaws.codecommit#ApprovalRuleTemplateNameRequiredException":
      response = {
        ...(await deserializeAws_json1_1ApprovalRuleTemplateNameRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidApprovalRuleTemplateNameException":
    case "com.amazonaws.codecommit#InvalidApprovalRuleTemplateNameException":
      response = {
        ...(await deserializeAws_json1_1InvalidApprovalRuleTemplateNameExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1UpdateCommentCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateCommentCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateCommentCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdateCommentOutput(data, context);
  const response: UpdateCommentCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateCommentOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1UpdateCommentCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateCommentCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "CommentContentRequiredException":
    case "com.amazonaws.codecommit#CommentContentRequiredException":
      response = {
        ...(await deserializeAws_json1_1CommentContentRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "CommentContentSizeLimitExceededException":
    case "com.amazonaws.codecommit#CommentContentSizeLimitExceededException":
      response = {
        ...(await deserializeAws_json1_1CommentContentSizeLimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "CommentDeletedException":
    case "com.amazonaws.codecommit#CommentDeletedException":
      response = {
        ...(await deserializeAws_json1_1CommentDeletedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "CommentDoesNotExistException":
    case "com.amazonaws.codecommit#CommentDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1CommentDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "CommentIdRequiredException":
    case "com.amazonaws.codecommit#CommentIdRequiredException":
      response = {
        ...(await deserializeAws_json1_1CommentIdRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "CommentNotCreatedByCallerException":
    case "com.amazonaws.codecommit#CommentNotCreatedByCallerException":
      response = {
        ...(await deserializeAws_json1_1CommentNotCreatedByCallerExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidCommentIdException":
    case "com.amazonaws.codecommit#InvalidCommentIdException":
      response = {
        ...(await deserializeAws_json1_1InvalidCommentIdExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1UpdateDefaultBranchCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateDefaultBranchCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateDefaultBranchCommandError(
      output,
      context
    );
  }
  await collectBody(output.body, context);
  const response: UpdateDefaultBranchCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1UpdateDefaultBranchCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateDefaultBranchCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "BranchDoesNotExistException":
    case "com.amazonaws.codecommit#BranchDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1BranchDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "BranchNameRequiredException":
    case "com.amazonaws.codecommit#BranchNameRequiredException":
      response = {
        ...(await deserializeAws_json1_1BranchNameRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionIntegrityChecksFailedException":
    case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionIntegrityChecksFailedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyAccessDeniedException":
    case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyAccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyDisabledException":
    case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyDisabledExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyNotFoundException":
    case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyUnavailableException":
    case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyUnavailableExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidBranchNameException":
    case "com.amazonaws.codecommit#InvalidBranchNameException":
      response = {
        ...(await deserializeAws_json1_1InvalidBranchNameExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRepositoryNameException":
    case "com.amazonaws.codecommit#InvalidRepositoryNameException":
      response = {
        ...(await deserializeAws_json1_1InvalidRepositoryNameExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryDoesNotExistException":
    case "com.amazonaws.codecommit#RepositoryDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1RepositoryDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryNameRequiredException":
    case "com.amazonaws.codecommit#RepositoryNameRequiredException":
      response = {
        ...(await deserializeAws_json1_1RepositoryNameRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1UpdatePullRequestApprovalRuleContentCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdatePullRequestApprovalRuleContentCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdatePullRequestApprovalRuleContentCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdatePullRequestApprovalRuleContentOutput(
    data,
    context
  );
  const response: UpdatePullRequestApprovalRuleContentCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdatePullRequestApprovalRuleContentOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1UpdatePullRequestApprovalRuleContentCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdatePullRequestApprovalRuleContentCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ApprovalRuleContentRequiredException":
    case "com.amazonaws.codecommit#ApprovalRuleContentRequiredException":
      response = {
        ...(await deserializeAws_json1_1ApprovalRuleContentRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ApprovalRuleDoesNotExistException":
    case "com.amazonaws.codecommit#ApprovalRuleDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1ApprovalRuleDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ApprovalRuleNameRequiredException":
    case "com.amazonaws.codecommit#ApprovalRuleNameRequiredException":
      response = {
        ...(await deserializeAws_json1_1ApprovalRuleNameRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "CannotModifyApprovalRuleFromTemplateException":
    case "com.amazonaws.codecommit#CannotModifyApprovalRuleFromTemplateException":
      response = {
        ...(await deserializeAws_json1_1CannotModifyApprovalRuleFromTemplateExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionIntegrityChecksFailedException":
    case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionIntegrityChecksFailedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyAccessDeniedException":
    case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyAccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyDisabledException":
    case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyDisabledExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyNotFoundException":
    case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyUnavailableException":
    case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyUnavailableExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidApprovalRuleContentException":
    case "com.amazonaws.codecommit#InvalidApprovalRuleContentException":
      response = {
        ...(await deserializeAws_json1_1InvalidApprovalRuleContentExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidApprovalRuleNameException":
    case "com.amazonaws.codecommit#InvalidApprovalRuleNameException":
      response = {
        ...(await deserializeAws_json1_1InvalidApprovalRuleNameExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidPullRequestIdException":
    case "com.amazonaws.codecommit#InvalidPullRequestIdException":
      response = {
        ...(await deserializeAws_json1_1InvalidPullRequestIdExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRuleContentSha256Exception":
    case "com.amazonaws.codecommit#InvalidRuleContentSha256Exception":
      response = {
        ...(await deserializeAws_json1_1InvalidRuleContentSha256ExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "PullRequestAlreadyClosedException":
    case "com.amazonaws.codecommit#PullRequestAlreadyClosedException":
      response = {
        ...(await deserializeAws_json1_1PullRequestAlreadyClosedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "PullRequestDoesNotExistException":
    case "com.amazonaws.codecommit#PullRequestDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1PullRequestDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "PullRequestIdRequiredException":
    case "com.amazonaws.codecommit#PullRequestIdRequiredException":
      response = {
        ...(await deserializeAws_json1_1PullRequestIdRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1UpdatePullRequestApprovalStateCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdatePullRequestApprovalStateCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdatePullRequestApprovalStateCommandError(
      output,
      context
    );
  }
  await collectBody(output.body, context);
  const response: UpdatePullRequestApprovalStateCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1UpdatePullRequestApprovalStateCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdatePullRequestApprovalStateCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ApprovalStateRequiredException":
    case "com.amazonaws.codecommit#ApprovalStateRequiredException":
      response = {
        ...(await deserializeAws_json1_1ApprovalStateRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionIntegrityChecksFailedException":
    case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionIntegrityChecksFailedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyAccessDeniedException":
    case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyAccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyDisabledException":
    case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyDisabledExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyNotFoundException":
    case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyUnavailableException":
    case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyUnavailableExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidApprovalStateException":
    case "com.amazonaws.codecommit#InvalidApprovalStateException":
      response = {
        ...(await deserializeAws_json1_1InvalidApprovalStateExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidPullRequestIdException":
    case "com.amazonaws.codecommit#InvalidPullRequestIdException":
      response = {
        ...(await deserializeAws_json1_1InvalidPullRequestIdExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRevisionIdException":
    case "com.amazonaws.codecommit#InvalidRevisionIdException":
      response = {
        ...(await deserializeAws_json1_1InvalidRevisionIdExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MaximumNumberOfApprovalsExceededException":
    case "com.amazonaws.codecommit#MaximumNumberOfApprovalsExceededException":
      response = {
        ...(await deserializeAws_json1_1MaximumNumberOfApprovalsExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "PullRequestAlreadyClosedException":
    case "com.amazonaws.codecommit#PullRequestAlreadyClosedException":
      response = {
        ...(await deserializeAws_json1_1PullRequestAlreadyClosedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "PullRequestCannotBeApprovedByAuthorException":
    case "com.amazonaws.codecommit#PullRequestCannotBeApprovedByAuthorException":
      response = {
        ...(await deserializeAws_json1_1PullRequestCannotBeApprovedByAuthorExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "PullRequestDoesNotExistException":
    case "com.amazonaws.codecommit#PullRequestDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1PullRequestDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "PullRequestIdRequiredException":
    case "com.amazonaws.codecommit#PullRequestIdRequiredException":
      response = {
        ...(await deserializeAws_json1_1PullRequestIdRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RevisionIdRequiredException":
    case "com.amazonaws.codecommit#RevisionIdRequiredException":
      response = {
        ...(await deserializeAws_json1_1RevisionIdRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RevisionNotCurrentException":
    case "com.amazonaws.codecommit#RevisionNotCurrentException":
      response = {
        ...(await deserializeAws_json1_1RevisionNotCurrentExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1UpdatePullRequestDescriptionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdatePullRequestDescriptionCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdatePullRequestDescriptionCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdatePullRequestDescriptionOutput(
    data,
    context
  );
  const response: UpdatePullRequestDescriptionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdatePullRequestDescriptionOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1UpdatePullRequestDescriptionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdatePullRequestDescriptionCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InvalidDescriptionException":
    case "com.amazonaws.codecommit#InvalidDescriptionException":
      response = {
        ...(await deserializeAws_json1_1InvalidDescriptionExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidPullRequestIdException":
    case "com.amazonaws.codecommit#InvalidPullRequestIdException":
      response = {
        ...(await deserializeAws_json1_1InvalidPullRequestIdExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "PullRequestAlreadyClosedException":
    case "com.amazonaws.codecommit#PullRequestAlreadyClosedException":
      response = {
        ...(await deserializeAws_json1_1PullRequestAlreadyClosedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "PullRequestDoesNotExistException":
    case "com.amazonaws.codecommit#PullRequestDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1PullRequestDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "PullRequestIdRequiredException":
    case "com.amazonaws.codecommit#PullRequestIdRequiredException":
      response = {
        ...(await deserializeAws_json1_1PullRequestIdRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1UpdatePullRequestStatusCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdatePullRequestStatusCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdatePullRequestStatusCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdatePullRequestStatusOutput(data, context);
  const response: UpdatePullRequestStatusCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdatePullRequestStatusOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1UpdatePullRequestStatusCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdatePullRequestStatusCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EncryptionIntegrityChecksFailedException":
    case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionIntegrityChecksFailedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyAccessDeniedException":
    case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyAccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyDisabledException":
    case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyDisabledExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyNotFoundException":
    case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyUnavailableException":
    case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyUnavailableExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidPullRequestIdException":
    case "com.amazonaws.codecommit#InvalidPullRequestIdException":
      response = {
        ...(await deserializeAws_json1_1InvalidPullRequestIdExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidPullRequestStatusException":
    case "com.amazonaws.codecommit#InvalidPullRequestStatusException":
      response = {
        ...(await deserializeAws_json1_1InvalidPullRequestStatusExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidPullRequestStatusUpdateException":
    case "com.amazonaws.codecommit#InvalidPullRequestStatusUpdateException":
      response = {
        ...(await deserializeAws_json1_1InvalidPullRequestStatusUpdateExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "PullRequestDoesNotExistException":
    case "com.amazonaws.codecommit#PullRequestDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1PullRequestDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "PullRequestIdRequiredException":
    case "com.amazonaws.codecommit#PullRequestIdRequiredException":
      response = {
        ...(await deserializeAws_json1_1PullRequestIdRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "PullRequestStatusRequiredException":
    case "com.amazonaws.codecommit#PullRequestStatusRequiredException":
      response = {
        ...(await deserializeAws_json1_1PullRequestStatusRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1UpdatePullRequestTitleCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdatePullRequestTitleCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdatePullRequestTitleCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdatePullRequestTitleOutput(data, context);
  const response: UpdatePullRequestTitleCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdatePullRequestTitleOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1UpdatePullRequestTitleCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdatePullRequestTitleCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InvalidPullRequestIdException":
    case "com.amazonaws.codecommit#InvalidPullRequestIdException":
      response = {
        ...(await deserializeAws_json1_1InvalidPullRequestIdExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidTitleException":
    case "com.amazonaws.codecommit#InvalidTitleException":
      response = {
        ...(await deserializeAws_json1_1InvalidTitleExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "PullRequestAlreadyClosedException":
    case "com.amazonaws.codecommit#PullRequestAlreadyClosedException":
      response = {
        ...(await deserializeAws_json1_1PullRequestAlreadyClosedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "PullRequestDoesNotExistException":
    case "com.amazonaws.codecommit#PullRequestDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1PullRequestDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "PullRequestIdRequiredException":
    case "com.amazonaws.codecommit#PullRequestIdRequiredException":
      response = {
        ...(await deserializeAws_json1_1PullRequestIdRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TitleRequiredException":
    case "com.amazonaws.codecommit#TitleRequiredException":
      response = {
        ...(await deserializeAws_json1_1TitleRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1UpdateRepositoryDescriptionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateRepositoryDescriptionCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateRepositoryDescriptionCommandError(
      output,
      context
    );
  }
  await collectBody(output.body, context);
  const response: UpdateRepositoryDescriptionCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1UpdateRepositoryDescriptionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateRepositoryDescriptionCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EncryptionIntegrityChecksFailedException":
    case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionIntegrityChecksFailedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyAccessDeniedException":
    case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyAccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyDisabledException":
    case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyDisabledExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyNotFoundException":
    case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EncryptionKeyUnavailableException":
    case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
      response = {
        ...(await deserializeAws_json1_1EncryptionKeyUnavailableExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRepositoryDescriptionException":
    case "com.amazonaws.codecommit#InvalidRepositoryDescriptionException":
      response = {
        ...(await deserializeAws_json1_1InvalidRepositoryDescriptionExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRepositoryNameException":
    case "com.amazonaws.codecommit#InvalidRepositoryNameException":
      response = {
        ...(await deserializeAws_json1_1InvalidRepositoryNameExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryDoesNotExistException":
    case "com.amazonaws.codecommit#RepositoryDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1RepositoryDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryNameRequiredException":
    case "com.amazonaws.codecommit#RepositoryNameRequiredException":
      response = {
        ...(await deserializeAws_json1_1RepositoryNameRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1UpdateRepositoryNameCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateRepositoryNameCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateRepositoryNameCommandError(
      output,
      context
    );
  }
  await collectBody(output.body, context);
  const response: UpdateRepositoryNameCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1UpdateRepositoryNameCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateRepositoryNameCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InvalidRepositoryNameException":
    case "com.amazonaws.codecommit#InvalidRepositoryNameException":
      response = {
        ...(await deserializeAws_json1_1InvalidRepositoryNameExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryDoesNotExistException":
    case "com.amazonaws.codecommit#RepositoryDoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1RepositoryDoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryNameExistsException":
    case "com.amazonaws.codecommit#RepositoryNameExistsException":
      response = {
        ...(await deserializeAws_json1_1RepositoryNameExistsExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RepositoryNameRequiredException":
    case "com.amazonaws.codecommit#RepositoryNameRequiredException":
      response = {
        ...(await deserializeAws_json1_1RepositoryNameRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

const deserializeAws_json1_1ActorDoesNotExistExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ActorDoesNotExistException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1ActorDoesNotExistException(
    body,
    context
  );
  const contents: ActorDoesNotExistException = {
    name: "ActorDoesNotExistException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1ApprovalRuleContentRequiredExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ApprovalRuleContentRequiredException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1ApprovalRuleContentRequiredException(
    body,
    context
  );
  const contents: ApprovalRuleContentRequiredException = {
    name: "ApprovalRuleContentRequiredException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1ApprovalRuleDoesNotExistExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ApprovalRuleDoesNotExistException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1ApprovalRuleDoesNotExistException(
    body,
    context
  );
  const contents: ApprovalRuleDoesNotExistException = {
    name: "ApprovalRuleDoesNotExistException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1ApprovalRuleNameAlreadyExistsExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ApprovalRuleNameAlreadyExistsException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1ApprovalRuleNameAlreadyExistsException(
    body,
    context
  );
  const contents: ApprovalRuleNameAlreadyExistsException = {
    name: "ApprovalRuleNameAlreadyExistsException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1ApprovalRuleNameRequiredExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ApprovalRuleNameRequiredException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1ApprovalRuleNameRequiredException(
    body,
    context
  );
  const contents: ApprovalRuleNameRequiredException = {
    name: "ApprovalRuleNameRequiredException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1ApprovalRuleTemplateContentRequiredExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ApprovalRuleTemplateContentRequiredException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1ApprovalRuleTemplateContentRequiredException(
    body,
    context
  );
  const contents: ApprovalRuleTemplateContentRequiredException = {
    name: "ApprovalRuleTemplateContentRequiredException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1ApprovalRuleTemplateDoesNotExistExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ApprovalRuleTemplateDoesNotExistException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1ApprovalRuleTemplateDoesNotExistException(
    body,
    context
  );
  const contents: ApprovalRuleTemplateDoesNotExistException = {
    name: "ApprovalRuleTemplateDoesNotExistException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1ApprovalRuleTemplateInUseExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ApprovalRuleTemplateInUseException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1ApprovalRuleTemplateInUseException(
    body,
    context
  );
  const contents: ApprovalRuleTemplateInUseException = {
    name: "ApprovalRuleTemplateInUseException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1ApprovalRuleTemplateNameAlreadyExistsExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ApprovalRuleTemplateNameAlreadyExistsException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1ApprovalRuleTemplateNameAlreadyExistsException(
    body,
    context
  );
  const contents: ApprovalRuleTemplateNameAlreadyExistsException = {
    name: "ApprovalRuleTemplateNameAlreadyExistsException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1ApprovalRuleTemplateNameRequiredExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ApprovalRuleTemplateNameRequiredException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1ApprovalRuleTemplateNameRequiredException(
    body,
    context
  );
  const contents: ApprovalRuleTemplateNameRequiredException = {
    name: "ApprovalRuleTemplateNameRequiredException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1ApprovalStateRequiredExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ApprovalStateRequiredException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1ApprovalStateRequiredException(
    body,
    context
  );
  const contents: ApprovalStateRequiredException = {
    name: "ApprovalStateRequiredException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1AuthorDoesNotExistExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<AuthorDoesNotExistException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1AuthorDoesNotExistException(
    body,
    context
  );
  const contents: AuthorDoesNotExistException = {
    name: "AuthorDoesNotExistException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1BeforeCommitIdAndAfterCommitIdAreSameExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<BeforeCommitIdAndAfterCommitIdAreSameException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1BeforeCommitIdAndAfterCommitIdAreSameException(
    body,
    context
  );
  const contents: BeforeCommitIdAndAfterCommitIdAreSameException = {
    name: "BeforeCommitIdAndAfterCommitIdAreSameException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1BlobIdDoesNotExistExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<BlobIdDoesNotExistException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1BlobIdDoesNotExistException(
    body,
    context
  );
  const contents: BlobIdDoesNotExistException = {
    name: "BlobIdDoesNotExistException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1BlobIdRequiredExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<BlobIdRequiredException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1BlobIdRequiredException(
    body,
    context
  );
  const contents: BlobIdRequiredException = {
    name: "BlobIdRequiredException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1BranchDoesNotExistExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<BranchDoesNotExistException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1BranchDoesNotExistException(
    body,
    context
  );
  const contents: BranchDoesNotExistException = {
    name: "BranchDoesNotExistException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1BranchNameExistsExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<BranchNameExistsException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1BranchNameExistsException(
    body,
    context
  );
  const contents: BranchNameExistsException = {
    name: "BranchNameExistsException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1BranchNameIsTagNameExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<BranchNameIsTagNameException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1BranchNameIsTagNameException(
    body,
    context
  );
  const contents: BranchNameIsTagNameException = {
    name: "BranchNameIsTagNameException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1BranchNameRequiredExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<BranchNameRequiredException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1BranchNameRequiredException(
    body,
    context
  );
  const contents: BranchNameRequiredException = {
    name: "BranchNameRequiredException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1CannotDeleteApprovalRuleFromTemplateExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<CannotDeleteApprovalRuleFromTemplateException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1CannotDeleteApprovalRuleFromTemplateException(
    body,
    context
  );
  const contents: CannotDeleteApprovalRuleFromTemplateException = {
    name: "CannotDeleteApprovalRuleFromTemplateException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1CannotModifyApprovalRuleFromTemplateExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<CannotModifyApprovalRuleFromTemplateException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1CannotModifyApprovalRuleFromTemplateException(
    body,
    context
  );
  const contents: CannotModifyApprovalRuleFromTemplateException = {
    name: "CannotModifyApprovalRuleFromTemplateException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1ClientRequestTokenRequiredExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ClientRequestTokenRequiredException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1ClientRequestTokenRequiredException(
    body,
    context
  );
  const contents: ClientRequestTokenRequiredException = {
    name: "ClientRequestTokenRequiredException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1CommentContentRequiredExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<CommentContentRequiredException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1CommentContentRequiredException(
    body,
    context
  );
  const contents: CommentContentRequiredException = {
    name: "CommentContentRequiredException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1CommentContentSizeLimitExceededExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<CommentContentSizeLimitExceededException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1CommentContentSizeLimitExceededException(
    body,
    context
  );
  const contents: CommentContentSizeLimitExceededException = {
    name: "CommentContentSizeLimitExceededException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1CommentDeletedExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<CommentDeletedException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1CommentDeletedException(
    body,
    context
  );
  const contents: CommentDeletedException = {
    name: "CommentDeletedException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1CommentDoesNotExistExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<CommentDoesNotExistException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1CommentDoesNotExistException(
    body,
    context
  );
  const contents: CommentDoesNotExistException = {
    name: "CommentDoesNotExistException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1CommentIdRequiredExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<CommentIdRequiredException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1CommentIdRequiredException(
    body,
    context
  );
  const contents: CommentIdRequiredException = {
    name: "CommentIdRequiredException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1CommentNotCreatedByCallerExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<CommentNotCreatedByCallerException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1CommentNotCreatedByCallerException(
    body,
    context
  );
  const contents: CommentNotCreatedByCallerException = {
    name: "CommentNotCreatedByCallerException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1CommitDoesNotExistExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<CommitDoesNotExistException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1CommitDoesNotExistException(
    body,
    context
  );
  const contents: CommitDoesNotExistException = {
    name: "CommitDoesNotExistException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1CommitIdDoesNotExistExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<CommitIdDoesNotExistException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1CommitIdDoesNotExistException(
    body,
    context
  );
  const contents: CommitIdDoesNotExistException = {
    name: "CommitIdDoesNotExistException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1CommitIdRequiredExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<CommitIdRequiredException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1CommitIdRequiredException(
    body,
    context
  );
  const contents: CommitIdRequiredException = {
    name: "CommitIdRequiredException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1CommitIdsLimitExceededExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<CommitIdsLimitExceededException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1CommitIdsLimitExceededException(
    body,
    context
  );
  const contents: CommitIdsLimitExceededException = {
    name: "CommitIdsLimitExceededException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1CommitIdsListRequiredExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<CommitIdsListRequiredException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1CommitIdsListRequiredException(
    body,
    context
  );
  const contents: CommitIdsListRequiredException = {
    name: "CommitIdsListRequiredException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1CommitMessageLengthExceededExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<CommitMessageLengthExceededException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1CommitMessageLengthExceededException(
    body,
    context
  );
  const contents: CommitMessageLengthExceededException = {
    name: "CommitMessageLengthExceededException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1CommitRequiredExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<CommitRequiredException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1CommitRequiredException(
    body,
    context
  );
  const contents: CommitRequiredException = {
    name: "CommitRequiredException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1ConcurrentReferenceUpdateExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ConcurrentReferenceUpdateException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1ConcurrentReferenceUpdateException(
    body,
    context
  );
  const contents: ConcurrentReferenceUpdateException = {
    name: "ConcurrentReferenceUpdateException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1DefaultBranchCannotBeDeletedExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<DefaultBranchCannotBeDeletedException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1DefaultBranchCannotBeDeletedException(
    body,
    context
  );
  const contents: DefaultBranchCannotBeDeletedException = {
    name: "DefaultBranchCannotBeDeletedException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1DirectoryNameConflictsWithFileNameExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<DirectoryNameConflictsWithFileNameException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1DirectoryNameConflictsWithFileNameException(
    body,
    context
  );
  const contents: DirectoryNameConflictsWithFileNameException = {
    name: "DirectoryNameConflictsWithFileNameException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1EncryptionIntegrityChecksFailedExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<EncryptionIntegrityChecksFailedException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1EncryptionIntegrityChecksFailedException(
    body,
    context
  );
  const contents: EncryptionIntegrityChecksFailedException = {
    name: "EncryptionIntegrityChecksFailedException",
    $fault: "server",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1EncryptionKeyAccessDeniedExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<EncryptionKeyAccessDeniedException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1EncryptionKeyAccessDeniedException(
    body,
    context
  );
  const contents: EncryptionKeyAccessDeniedException = {
    name: "EncryptionKeyAccessDeniedException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1EncryptionKeyDisabledExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<EncryptionKeyDisabledException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1EncryptionKeyDisabledException(
    body,
    context
  );
  const contents: EncryptionKeyDisabledException = {
    name: "EncryptionKeyDisabledException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1EncryptionKeyNotFoundExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<EncryptionKeyNotFoundException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1EncryptionKeyNotFoundException(
    body,
    context
  );
  const contents: EncryptionKeyNotFoundException = {
    name: "EncryptionKeyNotFoundException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1EncryptionKeyUnavailableExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<EncryptionKeyUnavailableException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1EncryptionKeyUnavailableException(
    body,
    context
  );
  const contents: EncryptionKeyUnavailableException = {
    name: "EncryptionKeyUnavailableException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1FileContentAndSourceFileSpecifiedExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<FileContentAndSourceFileSpecifiedException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1FileContentAndSourceFileSpecifiedException(
    body,
    context
  );
  const contents: FileContentAndSourceFileSpecifiedException = {
    name: "FileContentAndSourceFileSpecifiedException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1FileContentRequiredExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<FileContentRequiredException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1FileContentRequiredException(
    body,
    context
  );
  const contents: FileContentRequiredException = {
    name: "FileContentRequiredException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1FileContentSizeLimitExceededExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<FileContentSizeLimitExceededException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1FileContentSizeLimitExceededException(
    body,
    context
  );
  const contents: FileContentSizeLimitExceededException = {
    name: "FileContentSizeLimitExceededException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1FileDoesNotExistExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<FileDoesNotExistException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1FileDoesNotExistException(
    body,
    context
  );
  const contents: FileDoesNotExistException = {
    name: "FileDoesNotExistException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1FileEntryRequiredExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<FileEntryRequiredException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1FileEntryRequiredException(
    body,
    context
  );
  const contents: FileEntryRequiredException = {
    name: "FileEntryRequiredException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1FileModeRequiredExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<FileModeRequiredException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1FileModeRequiredException(
    body,
    context
  );
  const contents: FileModeRequiredException = {
    name: "FileModeRequiredException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1FileNameConflictsWithDirectoryNameExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<FileNameConflictsWithDirectoryNameException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1FileNameConflictsWithDirectoryNameException(
    body,
    context
  );
  const contents: FileNameConflictsWithDirectoryNameException = {
    name: "FileNameConflictsWithDirectoryNameException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1FilePathConflictsWithSubmodulePathExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<FilePathConflictsWithSubmodulePathException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1FilePathConflictsWithSubmodulePathException(
    body,
    context
  );
  const contents: FilePathConflictsWithSubmodulePathException = {
    name: "FilePathConflictsWithSubmodulePathException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1FileTooLargeExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<FileTooLargeException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1FileTooLargeException(
    body,
    context
  );
  const contents: FileTooLargeException = {
    name: "FileTooLargeException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1FolderContentSizeLimitExceededExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<FolderContentSizeLimitExceededException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1FolderContentSizeLimitExceededException(
    body,
    context
  );
  const contents: FolderContentSizeLimitExceededException = {
    name: "FolderContentSizeLimitExceededException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1FolderDoesNotExistExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<FolderDoesNotExistException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1FolderDoesNotExistException(
    body,
    context
  );
  const contents: FolderDoesNotExistException = {
    name: "FolderDoesNotExistException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1IdempotencyParameterMismatchExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<IdempotencyParameterMismatchException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1IdempotencyParameterMismatchException(
    body,
    context
  );
  const contents: IdempotencyParameterMismatchException = {
    name: "IdempotencyParameterMismatchException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidActorArnExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidActorArnException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidActorArnException(
    body,
    context
  );
  const contents: InvalidActorArnException = {
    name: "InvalidActorArnException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidApprovalRuleContentExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidApprovalRuleContentException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidApprovalRuleContentException(
    body,
    context
  );
  const contents: InvalidApprovalRuleContentException = {
    name: "InvalidApprovalRuleContentException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidApprovalRuleNameExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidApprovalRuleNameException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidApprovalRuleNameException(
    body,
    context
  );
  const contents: InvalidApprovalRuleNameException = {
    name: "InvalidApprovalRuleNameException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidApprovalRuleTemplateContentExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidApprovalRuleTemplateContentException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidApprovalRuleTemplateContentException(
    body,
    context
  );
  const contents: InvalidApprovalRuleTemplateContentException = {
    name: "InvalidApprovalRuleTemplateContentException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidApprovalRuleTemplateDescriptionExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidApprovalRuleTemplateDescriptionException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidApprovalRuleTemplateDescriptionException(
    body,
    context
  );
  const contents: InvalidApprovalRuleTemplateDescriptionException = {
    name: "InvalidApprovalRuleTemplateDescriptionException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidApprovalRuleTemplateNameExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidApprovalRuleTemplateNameException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidApprovalRuleTemplateNameException(
    body,
    context
  );
  const contents: InvalidApprovalRuleTemplateNameException = {
    name: "InvalidApprovalRuleTemplateNameException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidApprovalStateExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidApprovalStateException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidApprovalStateException(
    body,
    context
  );
  const contents: InvalidApprovalStateException = {
    name: "InvalidApprovalStateException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidAuthorArnExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidAuthorArnException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidAuthorArnException(
    body,
    context
  );
  const contents: InvalidAuthorArnException = {
    name: "InvalidAuthorArnException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidBlobIdExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidBlobIdException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidBlobIdException(
    body,
    context
  );
  const contents: InvalidBlobIdException = {
    name: "InvalidBlobIdException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidBranchNameExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidBranchNameException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidBranchNameException(
    body,
    context
  );
  const contents: InvalidBranchNameException = {
    name: "InvalidBranchNameException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidClientRequestTokenExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidClientRequestTokenException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidClientRequestTokenException(
    body,
    context
  );
  const contents: InvalidClientRequestTokenException = {
    name: "InvalidClientRequestTokenException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidCommentIdExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidCommentIdException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidCommentIdException(
    body,
    context
  );
  const contents: InvalidCommentIdException = {
    name: "InvalidCommentIdException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidCommitExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidCommitException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidCommitException(
    body,
    context
  );
  const contents: InvalidCommitException = {
    name: "InvalidCommitException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidCommitIdExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidCommitIdException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidCommitIdException(
    body,
    context
  );
  const contents: InvalidCommitIdException = {
    name: "InvalidCommitIdException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidConflictDetailLevelExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidConflictDetailLevelException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidConflictDetailLevelException(
    body,
    context
  );
  const contents: InvalidConflictDetailLevelException = {
    name: "InvalidConflictDetailLevelException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidConflictResolutionExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidConflictResolutionException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidConflictResolutionException(
    body,
    context
  );
  const contents: InvalidConflictResolutionException = {
    name: "InvalidConflictResolutionException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidConflictResolutionStrategyExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidConflictResolutionStrategyException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidConflictResolutionStrategyException(
    body,
    context
  );
  const contents: InvalidConflictResolutionStrategyException = {
    name: "InvalidConflictResolutionStrategyException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidContinuationTokenExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidContinuationTokenException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidContinuationTokenException(
    body,
    context
  );
  const contents: InvalidContinuationTokenException = {
    name: "InvalidContinuationTokenException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidDeletionParameterExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidDeletionParameterException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidDeletionParameterException(
    body,
    context
  );
  const contents: InvalidDeletionParameterException = {
    name: "InvalidDeletionParameterException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidDescriptionExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidDescriptionException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidDescriptionException(
    body,
    context
  );
  const contents: InvalidDescriptionException = {
    name: "InvalidDescriptionException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidDestinationCommitSpecifierExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidDestinationCommitSpecifierException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidDestinationCommitSpecifierException(
    body,
    context
  );
  const contents: InvalidDestinationCommitSpecifierException = {
    name: "InvalidDestinationCommitSpecifierException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidEmailExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidEmailException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidEmailException(
    body,
    context
  );
  const contents: InvalidEmailException = {
    name: "InvalidEmailException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidFileLocationExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidFileLocationException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidFileLocationException(
    body,
    context
  );
  const contents: InvalidFileLocationException = {
    name: "InvalidFileLocationException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidFileModeExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidFileModeException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidFileModeException(
    body,
    context
  );
  const contents: InvalidFileModeException = {
    name: "InvalidFileModeException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidFilePositionExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidFilePositionException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidFilePositionException(
    body,
    context
  );
  const contents: InvalidFilePositionException = {
    name: "InvalidFilePositionException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidMaxConflictFilesExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidMaxConflictFilesException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidMaxConflictFilesException(
    body,
    context
  );
  const contents: InvalidMaxConflictFilesException = {
    name: "InvalidMaxConflictFilesException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidMaxMergeHunksExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidMaxMergeHunksException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidMaxMergeHunksException(
    body,
    context
  );
  const contents: InvalidMaxMergeHunksException = {
    name: "InvalidMaxMergeHunksException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidMaxResultsExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidMaxResultsException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidMaxResultsException(
    body,
    context
  );
  const contents: InvalidMaxResultsException = {
    name: "InvalidMaxResultsException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidMergeOptionExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidMergeOptionException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidMergeOptionException(
    body,
    context
  );
  const contents: InvalidMergeOptionException = {
    name: "InvalidMergeOptionException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidOrderExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidOrderException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidOrderException(
    body,
    context
  );
  const contents: InvalidOrderException = {
    name: "InvalidOrderException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidOverrideStatusExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidOverrideStatusException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidOverrideStatusException(
    body,
    context
  );
  const contents: InvalidOverrideStatusException = {
    name: "InvalidOverrideStatusException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidParentCommitIdExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidParentCommitIdException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidParentCommitIdException(
    body,
    context
  );
  const contents: InvalidParentCommitIdException = {
    name: "InvalidParentCommitIdException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidPathExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidPathException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidPathException(
    body,
    context
  );
  const contents: InvalidPathException = {
    name: "InvalidPathException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidPullRequestEventTypeExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidPullRequestEventTypeException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidPullRequestEventTypeException(
    body,
    context
  );
  const contents: InvalidPullRequestEventTypeException = {
    name: "InvalidPullRequestEventTypeException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidPullRequestIdExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidPullRequestIdException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidPullRequestIdException(
    body,
    context
  );
  const contents: InvalidPullRequestIdException = {
    name: "InvalidPullRequestIdException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidPullRequestStatusExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidPullRequestStatusException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidPullRequestStatusException(
    body,
    context
  );
  const contents: InvalidPullRequestStatusException = {
    name: "InvalidPullRequestStatusException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidPullRequestStatusUpdateExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidPullRequestStatusUpdateException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidPullRequestStatusUpdateException(
    body,
    context
  );
  const contents: InvalidPullRequestStatusUpdateException = {
    name: "InvalidPullRequestStatusUpdateException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidReferenceNameExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidReferenceNameException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidReferenceNameException(
    body,
    context
  );
  const contents: InvalidReferenceNameException = {
    name: "InvalidReferenceNameException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidRelativeFileVersionEnumExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidRelativeFileVersionEnumException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidRelativeFileVersionEnumException(
    body,
    context
  );
  const contents: InvalidRelativeFileVersionEnumException = {
    name: "InvalidRelativeFileVersionEnumException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidReplacementContentExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidReplacementContentException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidReplacementContentException(
    body,
    context
  );
  const contents: InvalidReplacementContentException = {
    name: "InvalidReplacementContentException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidReplacementTypeExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidReplacementTypeException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidReplacementTypeException(
    body,
    context
  );
  const contents: InvalidReplacementTypeException = {
    name: "InvalidReplacementTypeException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidRepositoryDescriptionExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidRepositoryDescriptionException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidRepositoryDescriptionException(
    body,
    context
  );
  const contents: InvalidRepositoryDescriptionException = {
    name: "InvalidRepositoryDescriptionException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidRepositoryNameExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidRepositoryNameException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidRepositoryNameException(
    body,
    context
  );
  const contents: InvalidRepositoryNameException = {
    name: "InvalidRepositoryNameException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidRepositoryTriggerBranchNameExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidRepositoryTriggerBranchNameException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidRepositoryTriggerBranchNameException(
    body,
    context
  );
  const contents: InvalidRepositoryTriggerBranchNameException = {
    name: "InvalidRepositoryTriggerBranchNameException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidRepositoryTriggerCustomDataExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidRepositoryTriggerCustomDataException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidRepositoryTriggerCustomDataException(
    body,
    context
  );
  const contents: InvalidRepositoryTriggerCustomDataException = {
    name: "InvalidRepositoryTriggerCustomDataException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidRepositoryTriggerDestinationArnExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidRepositoryTriggerDestinationArnException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidRepositoryTriggerDestinationArnException(
    body,
    context
  );
  const contents: InvalidRepositoryTriggerDestinationArnException = {
    name: "InvalidRepositoryTriggerDestinationArnException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidRepositoryTriggerEventsExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidRepositoryTriggerEventsException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidRepositoryTriggerEventsException(
    body,
    context
  );
  const contents: InvalidRepositoryTriggerEventsException = {
    name: "InvalidRepositoryTriggerEventsException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidRepositoryTriggerNameExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidRepositoryTriggerNameException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidRepositoryTriggerNameException(
    body,
    context
  );
  const contents: InvalidRepositoryTriggerNameException = {
    name: "InvalidRepositoryTriggerNameException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidRepositoryTriggerRegionExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidRepositoryTriggerRegionException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidRepositoryTriggerRegionException(
    body,
    context
  );
  const contents: InvalidRepositoryTriggerRegionException = {
    name: "InvalidRepositoryTriggerRegionException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidResourceArnExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidResourceArnException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidResourceArnException(
    body,
    context
  );
  const contents: InvalidResourceArnException = {
    name: "InvalidResourceArnException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidRevisionIdExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidRevisionIdException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidRevisionIdException(
    body,
    context
  );
  const contents: InvalidRevisionIdException = {
    name: "InvalidRevisionIdException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidRuleContentSha256ExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidRuleContentSha256Exception> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidRuleContentSha256Exception(
    body,
    context
  );
  const contents: InvalidRuleContentSha256Exception = {
    name: "InvalidRuleContentSha256Exception",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidSortByExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidSortByException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidSortByException(
    body,
    context
  );
  const contents: InvalidSortByException = {
    name: "InvalidSortByException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidSourceCommitSpecifierExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidSourceCommitSpecifierException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidSourceCommitSpecifierException(
    body,
    context
  );
  const contents: InvalidSourceCommitSpecifierException = {
    name: "InvalidSourceCommitSpecifierException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidSystemTagUsageExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidSystemTagUsageException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidSystemTagUsageException(
    body,
    context
  );
  const contents: InvalidSystemTagUsageException = {
    name: "InvalidSystemTagUsageException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidTagKeysListExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidTagKeysListException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidTagKeysListException(
    body,
    context
  );
  const contents: InvalidTagKeysListException = {
    name: "InvalidTagKeysListException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidTagsMapExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidTagsMapException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidTagsMapException(
    body,
    context
  );
  const contents: InvalidTagsMapException = {
    name: "InvalidTagsMapException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidTargetBranchExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidTargetBranchException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidTargetBranchException(
    body,
    context
  );
  const contents: InvalidTargetBranchException = {
    name: "InvalidTargetBranchException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidTargetExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidTargetException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidTargetException(
    body,
    context
  );
  const contents: InvalidTargetException = {
    name: "InvalidTargetException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidTargetsExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidTargetsException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidTargetsException(
    body,
    context
  );
  const contents: InvalidTargetsException = {
    name: "InvalidTargetsException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidTitleExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidTitleException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidTitleException(
    body,
    context
  );
  const contents: InvalidTitleException = {
    name: "InvalidTitleException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1ManualMergeRequiredExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ManualMergeRequiredException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1ManualMergeRequiredException(
    body,
    context
  );
  const contents: ManualMergeRequiredException = {
    name: "ManualMergeRequiredException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1MaximumBranchesExceededExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<MaximumBranchesExceededException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1MaximumBranchesExceededException(
    body,
    context
  );
  const contents: MaximumBranchesExceededException = {
    name: "MaximumBranchesExceededException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1MaximumConflictResolutionEntriesExceededExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<MaximumConflictResolutionEntriesExceededException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1MaximumConflictResolutionEntriesExceededException(
    body,
    context
  );
  const contents: MaximumConflictResolutionEntriesExceededException = {
    name: "MaximumConflictResolutionEntriesExceededException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1MaximumFileContentToLoadExceededExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<MaximumFileContentToLoadExceededException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1MaximumFileContentToLoadExceededException(
    body,
    context
  );
  const contents: MaximumFileContentToLoadExceededException = {
    name: "MaximumFileContentToLoadExceededException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1MaximumFileEntriesExceededExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<MaximumFileEntriesExceededException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1MaximumFileEntriesExceededException(
    body,
    context
  );
  const contents: MaximumFileEntriesExceededException = {
    name: "MaximumFileEntriesExceededException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1MaximumItemsToCompareExceededExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<MaximumItemsToCompareExceededException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1MaximumItemsToCompareExceededException(
    body,
    context
  );
  const contents: MaximumItemsToCompareExceededException = {
    name: "MaximumItemsToCompareExceededException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1MaximumNumberOfApprovalsExceededExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<MaximumNumberOfApprovalsExceededException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1MaximumNumberOfApprovalsExceededException(
    body,
    context
  );
  const contents: MaximumNumberOfApprovalsExceededException = {
    name: "MaximumNumberOfApprovalsExceededException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1MaximumOpenPullRequestsExceededExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<MaximumOpenPullRequestsExceededException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1MaximumOpenPullRequestsExceededException(
    body,
    context
  );
  const contents: MaximumOpenPullRequestsExceededException = {
    name: "MaximumOpenPullRequestsExceededException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1MaximumRepositoryNamesExceededExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<MaximumRepositoryNamesExceededException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1MaximumRepositoryNamesExceededException(
    body,
    context
  );
  const contents: MaximumRepositoryNamesExceededException = {
    name: "MaximumRepositoryNamesExceededException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1MaximumRepositoryTriggersExceededExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<MaximumRepositoryTriggersExceededException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1MaximumRepositoryTriggersExceededException(
    body,
    context
  );
  const contents: MaximumRepositoryTriggersExceededException = {
    name: "MaximumRepositoryTriggersExceededException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1MaximumRuleTemplatesAssociatedWithRepositoryExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<MaximumRuleTemplatesAssociatedWithRepositoryException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1MaximumRuleTemplatesAssociatedWithRepositoryException(
    body,
    context
  );
  const contents: MaximumRuleTemplatesAssociatedWithRepositoryException = {
    name: "MaximumRuleTemplatesAssociatedWithRepositoryException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1MergeOptionRequiredExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<MergeOptionRequiredException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1MergeOptionRequiredException(
    body,
    context
  );
  const contents: MergeOptionRequiredException = {
    name: "MergeOptionRequiredException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1MultipleConflictResolutionEntriesExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<MultipleConflictResolutionEntriesException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1MultipleConflictResolutionEntriesException(
    body,
    context
  );
  const contents: MultipleConflictResolutionEntriesException = {
    name: "MultipleConflictResolutionEntriesException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1MultipleRepositoriesInPullRequestExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<MultipleRepositoriesInPullRequestException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1MultipleRepositoriesInPullRequestException(
    body,
    context
  );
  const contents: MultipleRepositoriesInPullRequestException = {
    name: "MultipleRepositoriesInPullRequestException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1NameLengthExceededExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<NameLengthExceededException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1NameLengthExceededException(
    body,
    context
  );
  const contents: NameLengthExceededException = {
    name: "NameLengthExceededException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1NoChangeExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<NoChangeException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1NoChangeException(
    body,
    context
  );
  const contents: NoChangeException = {
    name: "NoChangeException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1NumberOfRuleTemplatesExceededExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<NumberOfRuleTemplatesExceededException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1NumberOfRuleTemplatesExceededException(
    body,
    context
  );
  const contents: NumberOfRuleTemplatesExceededException = {
    name: "NumberOfRuleTemplatesExceededException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1NumberOfRulesExceededExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<NumberOfRulesExceededException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1NumberOfRulesExceededException(
    body,
    context
  );
  const contents: NumberOfRulesExceededException = {
    name: "NumberOfRulesExceededException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1OverrideAlreadySetExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<OverrideAlreadySetException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1OverrideAlreadySetException(
    body,
    context
  );
  const contents: OverrideAlreadySetException = {
    name: "OverrideAlreadySetException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1OverrideStatusRequiredExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<OverrideStatusRequiredException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1OverrideStatusRequiredException(
    body,
    context
  );
  const contents: OverrideStatusRequiredException = {
    name: "OverrideStatusRequiredException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1ParentCommitDoesNotExistExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ParentCommitDoesNotExistException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1ParentCommitDoesNotExistException(
    body,
    context
  );
  const contents: ParentCommitDoesNotExistException = {
    name: "ParentCommitDoesNotExistException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1ParentCommitIdOutdatedExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ParentCommitIdOutdatedException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1ParentCommitIdOutdatedException(
    body,
    context
  );
  const contents: ParentCommitIdOutdatedException = {
    name: "ParentCommitIdOutdatedException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1ParentCommitIdRequiredExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ParentCommitIdRequiredException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1ParentCommitIdRequiredException(
    body,
    context
  );
  const contents: ParentCommitIdRequiredException = {
    name: "ParentCommitIdRequiredException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1PathDoesNotExistExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<PathDoesNotExistException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1PathDoesNotExistException(
    body,
    context
  );
  const contents: PathDoesNotExistException = {
    name: "PathDoesNotExistException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1PathRequiredExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<PathRequiredException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1PathRequiredException(
    body,
    context
  );
  const contents: PathRequiredException = {
    name: "PathRequiredException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1PullRequestAlreadyClosedExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<PullRequestAlreadyClosedException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1PullRequestAlreadyClosedException(
    body,
    context
  );
  const contents: PullRequestAlreadyClosedException = {
    name: "PullRequestAlreadyClosedException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1PullRequestApprovalRulesNotSatisfiedExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<PullRequestApprovalRulesNotSatisfiedException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1PullRequestApprovalRulesNotSatisfiedException(
    body,
    context
  );
  const contents: PullRequestApprovalRulesNotSatisfiedException = {
    name: "PullRequestApprovalRulesNotSatisfiedException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1PullRequestCannotBeApprovedByAuthorExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<PullRequestCannotBeApprovedByAuthorException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1PullRequestCannotBeApprovedByAuthorException(
    body,
    context
  );
  const contents: PullRequestCannotBeApprovedByAuthorException = {
    name: "PullRequestCannotBeApprovedByAuthorException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1PullRequestDoesNotExistExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<PullRequestDoesNotExistException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1PullRequestDoesNotExistException(
    body,
    context
  );
  const contents: PullRequestDoesNotExistException = {
    name: "PullRequestDoesNotExistException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1PullRequestIdRequiredExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<PullRequestIdRequiredException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1PullRequestIdRequiredException(
    body,
    context
  );
  const contents: PullRequestIdRequiredException = {
    name: "PullRequestIdRequiredException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1PullRequestStatusRequiredExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<PullRequestStatusRequiredException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1PullRequestStatusRequiredException(
    body,
    context
  );
  const contents: PullRequestStatusRequiredException = {
    name: "PullRequestStatusRequiredException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1PutFileEntryConflictExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<PutFileEntryConflictException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1PutFileEntryConflictException(
    body,
    context
  );
  const contents: PutFileEntryConflictException = {
    name: "PutFileEntryConflictException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1ReferenceDoesNotExistExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ReferenceDoesNotExistException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1ReferenceDoesNotExistException(
    body,
    context
  );
  const contents: ReferenceDoesNotExistException = {
    name: "ReferenceDoesNotExistException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1ReferenceNameRequiredExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ReferenceNameRequiredException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1ReferenceNameRequiredException(
    body,
    context
  );
  const contents: ReferenceNameRequiredException = {
    name: "ReferenceNameRequiredException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1ReferenceTypeNotSupportedExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ReferenceTypeNotSupportedException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1ReferenceTypeNotSupportedException(
    body,
    context
  );
  const contents: ReferenceTypeNotSupportedException = {
    name: "ReferenceTypeNotSupportedException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1ReplacementContentRequiredExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ReplacementContentRequiredException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1ReplacementContentRequiredException(
    body,
    context
  );
  const contents: ReplacementContentRequiredException = {
    name: "ReplacementContentRequiredException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1ReplacementTypeRequiredExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ReplacementTypeRequiredException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1ReplacementTypeRequiredException(
    body,
    context
  );
  const contents: ReplacementTypeRequiredException = {
    name: "ReplacementTypeRequiredException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1RepositoryDoesNotExistExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<RepositoryDoesNotExistException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1RepositoryDoesNotExistException(
    body,
    context
  );
  const contents: RepositoryDoesNotExistException = {
    name: "RepositoryDoesNotExistException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1RepositoryLimitExceededExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<RepositoryLimitExceededException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1RepositoryLimitExceededException(
    body,
    context
  );
  const contents: RepositoryLimitExceededException = {
    name: "RepositoryLimitExceededException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1RepositoryNameExistsExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<RepositoryNameExistsException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1RepositoryNameExistsException(
    body,
    context
  );
  const contents: RepositoryNameExistsException = {
    name: "RepositoryNameExistsException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1RepositoryNameRequiredExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<RepositoryNameRequiredException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1RepositoryNameRequiredException(
    body,
    context
  );
  const contents: RepositoryNameRequiredException = {
    name: "RepositoryNameRequiredException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1RepositoryNamesRequiredExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<RepositoryNamesRequiredException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1RepositoryNamesRequiredException(
    body,
    context
  );
  const contents: RepositoryNamesRequiredException = {
    name: "RepositoryNamesRequiredException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1RepositoryNotAssociatedWithPullRequestExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<RepositoryNotAssociatedWithPullRequestException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1RepositoryNotAssociatedWithPullRequestException(
    body,
    context
  );
  const contents: RepositoryNotAssociatedWithPullRequestException = {
    name: "RepositoryNotAssociatedWithPullRequestException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1RepositoryTriggerBranchNameListRequiredExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<RepositoryTriggerBranchNameListRequiredException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1RepositoryTriggerBranchNameListRequiredException(
    body,
    context
  );
  const contents: RepositoryTriggerBranchNameListRequiredException = {
    name: "RepositoryTriggerBranchNameListRequiredException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1RepositoryTriggerDestinationArnRequiredExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<RepositoryTriggerDestinationArnRequiredException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1RepositoryTriggerDestinationArnRequiredException(
    body,
    context
  );
  const contents: RepositoryTriggerDestinationArnRequiredException = {
    name: "RepositoryTriggerDestinationArnRequiredException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1RepositoryTriggerEventsListRequiredExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<RepositoryTriggerEventsListRequiredException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1RepositoryTriggerEventsListRequiredException(
    body,
    context
  );
  const contents: RepositoryTriggerEventsListRequiredException = {
    name: "RepositoryTriggerEventsListRequiredException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1RepositoryTriggerNameRequiredExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<RepositoryTriggerNameRequiredException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1RepositoryTriggerNameRequiredException(
    body,
    context
  );
  const contents: RepositoryTriggerNameRequiredException = {
    name: "RepositoryTriggerNameRequiredException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1RepositoryTriggersListRequiredExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<RepositoryTriggersListRequiredException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1RepositoryTriggersListRequiredException(
    body,
    context
  );
  const contents: RepositoryTriggersListRequiredException = {
    name: "RepositoryTriggersListRequiredException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1ResourceArnRequiredExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ResourceArnRequiredException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1ResourceArnRequiredException(
    body,
    context
  );
  const contents: ResourceArnRequiredException = {
    name: "ResourceArnRequiredException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1RestrictedSourceFileExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<RestrictedSourceFileException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1RestrictedSourceFileException(
    body,
    context
  );
  const contents: RestrictedSourceFileException = {
    name: "RestrictedSourceFileException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1RevisionIdRequiredExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<RevisionIdRequiredException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1RevisionIdRequiredException(
    body,
    context
  );
  const contents: RevisionIdRequiredException = {
    name: "RevisionIdRequiredException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1RevisionNotCurrentExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<RevisionNotCurrentException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1RevisionNotCurrentException(
    body,
    context
  );
  const contents: RevisionNotCurrentException = {
    name: "RevisionNotCurrentException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1SameFileContentExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<SameFileContentException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1SameFileContentException(
    body,
    context
  );
  const contents: SameFileContentException = {
    name: "SameFileContentException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1SamePathRequestExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<SamePathRequestException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1SamePathRequestException(
    body,
    context
  );
  const contents: SamePathRequestException = {
    name: "SamePathRequestException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1SourceAndDestinationAreSameExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<SourceAndDestinationAreSameException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1SourceAndDestinationAreSameException(
    body,
    context
  );
  const contents: SourceAndDestinationAreSameException = {
    name: "SourceAndDestinationAreSameException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1SourceFileOrContentRequiredExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<SourceFileOrContentRequiredException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1SourceFileOrContentRequiredException(
    body,
    context
  );
  const contents: SourceFileOrContentRequiredException = {
    name: "SourceFileOrContentRequiredException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1TagKeysListRequiredExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<TagKeysListRequiredException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1TagKeysListRequiredException(
    body,
    context
  );
  const contents: TagKeysListRequiredException = {
    name: "TagKeysListRequiredException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1TagPolicyExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<TagPolicyException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1TagPolicyException(
    body,
    context
  );
  const contents: TagPolicyException = {
    name: "TagPolicyException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1TagsMapRequiredExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<TagsMapRequiredException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1TagsMapRequiredException(
    body,
    context
  );
  const contents: TagsMapRequiredException = {
    name: "TagsMapRequiredException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1TargetRequiredExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<TargetRequiredException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1TargetRequiredException(
    body,
    context
  );
  const contents: TargetRequiredException = {
    name: "TargetRequiredException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1TargetsRequiredExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<TargetsRequiredException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1TargetsRequiredException(
    body,
    context
  );
  const contents: TargetsRequiredException = {
    name: "TargetsRequiredException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1TipOfSourceReferenceIsDifferentExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<TipOfSourceReferenceIsDifferentException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1TipOfSourceReferenceIsDifferentException(
    body,
    context
  );
  const contents: TipOfSourceReferenceIsDifferentException = {
    name: "TipOfSourceReferenceIsDifferentException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1TipsDivergenceExceededExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<TipsDivergenceExceededException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1TipsDivergenceExceededException(
    body,
    context
  );
  const contents: TipsDivergenceExceededException = {
    name: "TipsDivergenceExceededException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1TitleRequiredExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<TitleRequiredException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1TitleRequiredException(
    body,
    context
  );
  const contents: TitleRequiredException = {
    name: "TitleRequiredException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1TooManyTagsExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<TooManyTagsException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1TooManyTagsException(
    body,
    context
  );
  const contents: TooManyTagsException = {
    name: "TooManyTagsException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const serializeAws_json1_1AssociateApprovalRuleTemplateWithRepositoryInput = (
  input: AssociateApprovalRuleTemplateWithRepositoryInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.approvalRuleTemplateName !== undefined) {
    bodyParams["approvalRuleTemplateName"] = input.approvalRuleTemplateName;
  }
  if (input.repositoryName !== undefined) {
    bodyParams["repositoryName"] = input.repositoryName;
  }
  return bodyParams;
};

const serializeAws_json1_1BatchAssociateApprovalRuleTemplateWithRepositoriesInput = (
  input: BatchAssociateApprovalRuleTemplateWithRepositoriesInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.approvalRuleTemplateName !== undefined) {
    bodyParams["approvalRuleTemplateName"] = input.approvalRuleTemplateName;
  }
  if (input.repositoryNames !== undefined) {
    bodyParams["repositoryNames"] = serializeAws_json1_1RepositoryNameList(
      input.repositoryNames,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1BatchDescribeMergeConflictsInput = (
  input: BatchDescribeMergeConflictsInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.conflictDetailLevel !== undefined) {
    bodyParams["conflictDetailLevel"] = input.conflictDetailLevel;
  }
  if (input.conflictResolutionStrategy !== undefined) {
    bodyParams["conflictResolutionStrategy"] = input.conflictResolutionStrategy;
  }
  if (input.destinationCommitSpecifier !== undefined) {
    bodyParams["destinationCommitSpecifier"] = input.destinationCommitSpecifier;
  }
  if (input.filePaths !== undefined) {
    bodyParams["filePaths"] = serializeAws_json1_1FilePaths(
      input.filePaths,
      context
    );
  }
  if (input.maxConflictFiles !== undefined) {
    bodyParams["maxConflictFiles"] = input.maxConflictFiles;
  }
  if (input.maxMergeHunks !== undefined) {
    bodyParams["maxMergeHunks"] = input.maxMergeHunks;
  }
  if (input.mergeOption !== undefined) {
    bodyParams["mergeOption"] = input.mergeOption;
  }
  if (input.nextToken !== undefined) {
    bodyParams["nextToken"] = input.nextToken;
  }
  if (input.repositoryName !== undefined) {
    bodyParams["repositoryName"] = input.repositoryName;
  }
  if (input.sourceCommitSpecifier !== undefined) {
    bodyParams["sourceCommitSpecifier"] = input.sourceCommitSpecifier;
  }
  return bodyParams;
};

const serializeAws_json1_1BatchDisassociateApprovalRuleTemplateFromRepositoriesInput = (
  input: BatchDisassociateApprovalRuleTemplateFromRepositoriesInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.approvalRuleTemplateName !== undefined) {
    bodyParams["approvalRuleTemplateName"] = input.approvalRuleTemplateName;
  }
  if (input.repositoryNames !== undefined) {
    bodyParams["repositoryNames"] = serializeAws_json1_1RepositoryNameList(
      input.repositoryNames,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1BatchGetCommitsInput = (
  input: BatchGetCommitsInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.commitIds !== undefined) {
    bodyParams["commitIds"] = serializeAws_json1_1CommitIdsInputList(
      input.commitIds,
      context
    );
  }
  if (input.repositoryName !== undefined) {
    bodyParams["repositoryName"] = input.repositoryName;
  }
  return bodyParams;
};

const serializeAws_json1_1BatchGetRepositoriesInput = (
  input: BatchGetRepositoriesInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.repositoryNames !== undefined) {
    bodyParams["repositoryNames"] = serializeAws_json1_1RepositoryNameList(
      input.repositoryNames,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1BranchNameList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry => entry);
};

const serializeAws_json1_1CommitIdsInputList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry => entry);
};

const serializeAws_json1_1ConflictResolution = (
  input: ConflictResolution,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.deleteFiles !== undefined) {
    bodyParams["deleteFiles"] = serializeAws_json1_1DeleteFileEntries(
      input.deleteFiles,
      context
    );
  }
  if (input.replaceContents !== undefined) {
    bodyParams["replaceContents"] = serializeAws_json1_1ReplaceContentEntries(
      input.replaceContents,
      context
    );
  }
  if (input.setFileModes !== undefined) {
    bodyParams["setFileModes"] = serializeAws_json1_1SetFileModeEntries(
      input.setFileModes,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1CreateApprovalRuleTemplateInput = (
  input: CreateApprovalRuleTemplateInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.approvalRuleTemplateContent !== undefined) {
    bodyParams["approvalRuleTemplateContent"] =
      input.approvalRuleTemplateContent;
  }
  if (input.approvalRuleTemplateDescription !== undefined) {
    bodyParams["approvalRuleTemplateDescription"] =
      input.approvalRuleTemplateDescription;
  }
  if (input.approvalRuleTemplateName !== undefined) {
    bodyParams["approvalRuleTemplateName"] = input.approvalRuleTemplateName;
  }
  return bodyParams;
};

const serializeAws_json1_1CreateBranchInput = (
  input: CreateBranchInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.branchName !== undefined) {
    bodyParams["branchName"] = input.branchName;
  }
  if (input.commitId !== undefined) {
    bodyParams["commitId"] = input.commitId;
  }
  if (input.repositoryName !== undefined) {
    bodyParams["repositoryName"] = input.repositoryName;
  }
  return bodyParams;
};

const serializeAws_json1_1CreateCommitInput = (
  input: CreateCommitInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.authorName !== undefined) {
    bodyParams["authorName"] = input.authorName;
  }
  if (input.branchName !== undefined) {
    bodyParams["branchName"] = input.branchName;
  }
  if (input.commitMessage !== undefined) {
    bodyParams["commitMessage"] = input.commitMessage;
  }
  if (input.deleteFiles !== undefined) {
    bodyParams["deleteFiles"] = serializeAws_json1_1DeleteFileEntries(
      input.deleteFiles,
      context
    );
  }
  if (input.email !== undefined) {
    bodyParams["email"] = input.email;
  }
  if (input.keepEmptyFolders !== undefined) {
    bodyParams["keepEmptyFolders"] = input.keepEmptyFolders;
  }
  if (input.parentCommitId !== undefined) {
    bodyParams["parentCommitId"] = input.parentCommitId;
  }
  if (input.putFiles !== undefined) {
    bodyParams["putFiles"] = serializeAws_json1_1PutFileEntries(
      input.putFiles,
      context
    );
  }
  if (input.repositoryName !== undefined) {
    bodyParams["repositoryName"] = input.repositoryName;
  }
  if (input.setFileModes !== undefined) {
    bodyParams["setFileModes"] = serializeAws_json1_1SetFileModeEntries(
      input.setFileModes,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1CreatePullRequestApprovalRuleInput = (
  input: CreatePullRequestApprovalRuleInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.approvalRuleContent !== undefined) {
    bodyParams["approvalRuleContent"] = input.approvalRuleContent;
  }
  if (input.approvalRuleName !== undefined) {
    bodyParams["approvalRuleName"] = input.approvalRuleName;
  }
  if (input.pullRequestId !== undefined) {
    bodyParams["pullRequestId"] = input.pullRequestId;
  }
  return bodyParams;
};

const serializeAws_json1_1CreatePullRequestInput = (
  input: CreatePullRequestInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.clientRequestToken === undefined) {
    input.clientRequestToken = generateIdempotencyToken();
  }
  if (input.clientRequestToken !== undefined) {
    bodyParams["clientRequestToken"] = input.clientRequestToken;
  }
  if (input.description !== undefined) {
    bodyParams["description"] = input.description;
  }
  if (input.targets !== undefined) {
    bodyParams["targets"] = serializeAws_json1_1TargetList(
      input.targets,
      context
    );
  }
  if (input.title !== undefined) {
    bodyParams["title"] = input.title;
  }
  return bodyParams;
};

const serializeAws_json1_1CreateRepositoryInput = (
  input: CreateRepositoryInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.repositoryDescription !== undefined) {
    bodyParams["repositoryDescription"] = input.repositoryDescription;
  }
  if (input.repositoryName !== undefined) {
    bodyParams["repositoryName"] = input.repositoryName;
  }
  if (input.tags !== undefined) {
    bodyParams["tags"] = serializeAws_json1_1TagsMap(input.tags, context);
  }
  return bodyParams;
};

const serializeAws_json1_1CreateUnreferencedMergeCommitInput = (
  input: CreateUnreferencedMergeCommitInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.authorName !== undefined) {
    bodyParams["authorName"] = input.authorName;
  }
  if (input.commitMessage !== undefined) {
    bodyParams["commitMessage"] = input.commitMessage;
  }
  if (input.conflictDetailLevel !== undefined) {
    bodyParams["conflictDetailLevel"] = input.conflictDetailLevel;
  }
  if (input.conflictResolution !== undefined) {
    bodyParams["conflictResolution"] = serializeAws_json1_1ConflictResolution(
      input.conflictResolution,
      context
    );
  }
  if (input.conflictResolutionStrategy !== undefined) {
    bodyParams["conflictResolutionStrategy"] = input.conflictResolutionStrategy;
  }
  if (input.destinationCommitSpecifier !== undefined) {
    bodyParams["destinationCommitSpecifier"] = input.destinationCommitSpecifier;
  }
  if (input.email !== undefined) {
    bodyParams["email"] = input.email;
  }
  if (input.keepEmptyFolders !== undefined) {
    bodyParams["keepEmptyFolders"] = input.keepEmptyFolders;
  }
  if (input.mergeOption !== undefined) {
    bodyParams["mergeOption"] = input.mergeOption;
  }
  if (input.repositoryName !== undefined) {
    bodyParams["repositoryName"] = input.repositoryName;
  }
  if (input.sourceCommitSpecifier !== undefined) {
    bodyParams["sourceCommitSpecifier"] = input.sourceCommitSpecifier;
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteApprovalRuleTemplateInput = (
  input: DeleteApprovalRuleTemplateInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.approvalRuleTemplateName !== undefined) {
    bodyParams["approvalRuleTemplateName"] = input.approvalRuleTemplateName;
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteBranchInput = (
  input: DeleteBranchInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.branchName !== undefined) {
    bodyParams["branchName"] = input.branchName;
  }
  if (input.repositoryName !== undefined) {
    bodyParams["repositoryName"] = input.repositoryName;
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteCommentContentInput = (
  input: DeleteCommentContentInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.commentId !== undefined) {
    bodyParams["commentId"] = input.commentId;
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteFileEntries = (
  input: Array<DeleteFileEntry>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry =>
    serializeAws_json1_1DeleteFileEntry(entry, context)
  );
};

const serializeAws_json1_1DeleteFileEntry = (
  input: DeleteFileEntry,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.filePath !== undefined) {
    bodyParams["filePath"] = input.filePath;
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteFileInput = (
  input: DeleteFileInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.branchName !== undefined) {
    bodyParams["branchName"] = input.branchName;
  }
  if (input.commitMessage !== undefined) {
    bodyParams["commitMessage"] = input.commitMessage;
  }
  if (input.email !== undefined) {
    bodyParams["email"] = input.email;
  }
  if (input.filePath !== undefined) {
    bodyParams["filePath"] = input.filePath;
  }
  if (input.keepEmptyFolders !== undefined) {
    bodyParams["keepEmptyFolders"] = input.keepEmptyFolders;
  }
  if (input.name !== undefined) {
    bodyParams["name"] = input.name;
  }
  if (input.parentCommitId !== undefined) {
    bodyParams["parentCommitId"] = input.parentCommitId;
  }
  if (input.repositoryName !== undefined) {
    bodyParams["repositoryName"] = input.repositoryName;
  }
  return bodyParams;
};

const serializeAws_json1_1DeletePullRequestApprovalRuleInput = (
  input: DeletePullRequestApprovalRuleInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.approvalRuleName !== undefined) {
    bodyParams["approvalRuleName"] = input.approvalRuleName;
  }
  if (input.pullRequestId !== undefined) {
    bodyParams["pullRequestId"] = input.pullRequestId;
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteRepositoryInput = (
  input: DeleteRepositoryInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.repositoryName !== undefined) {
    bodyParams["repositoryName"] = input.repositoryName;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeMergeConflictsInput = (
  input: DescribeMergeConflictsInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.conflictDetailLevel !== undefined) {
    bodyParams["conflictDetailLevel"] = input.conflictDetailLevel;
  }
  if (input.conflictResolutionStrategy !== undefined) {
    bodyParams["conflictResolutionStrategy"] = input.conflictResolutionStrategy;
  }
  if (input.destinationCommitSpecifier !== undefined) {
    bodyParams["destinationCommitSpecifier"] = input.destinationCommitSpecifier;
  }
  if (input.filePath !== undefined) {
    bodyParams["filePath"] = input.filePath;
  }
  if (input.maxMergeHunks !== undefined) {
    bodyParams["maxMergeHunks"] = input.maxMergeHunks;
  }
  if (input.mergeOption !== undefined) {
    bodyParams["mergeOption"] = input.mergeOption;
  }
  if (input.nextToken !== undefined) {
    bodyParams["nextToken"] = input.nextToken;
  }
  if (input.repositoryName !== undefined) {
    bodyParams["repositoryName"] = input.repositoryName;
  }
  if (input.sourceCommitSpecifier !== undefined) {
    bodyParams["sourceCommitSpecifier"] = input.sourceCommitSpecifier;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribePullRequestEventsInput = (
  input: DescribePullRequestEventsInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.actorArn !== undefined) {
    bodyParams["actorArn"] = input.actorArn;
  }
  if (input.maxResults !== undefined) {
    bodyParams["maxResults"] = input.maxResults;
  }
  if (input.nextToken !== undefined) {
    bodyParams["nextToken"] = input.nextToken;
  }
  if (input.pullRequestEventType !== undefined) {
    bodyParams["pullRequestEventType"] = input.pullRequestEventType;
  }
  if (input.pullRequestId !== undefined) {
    bodyParams["pullRequestId"] = input.pullRequestId;
  }
  return bodyParams;
};

const serializeAws_json1_1DisassociateApprovalRuleTemplateFromRepositoryInput = (
  input: DisassociateApprovalRuleTemplateFromRepositoryInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.approvalRuleTemplateName !== undefined) {
    bodyParams["approvalRuleTemplateName"] = input.approvalRuleTemplateName;
  }
  if (input.repositoryName !== undefined) {
    bodyParams["repositoryName"] = input.repositoryName;
  }
  return bodyParams;
};

const serializeAws_json1_1EvaluatePullRequestApprovalRulesInput = (
  input: EvaluatePullRequestApprovalRulesInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.pullRequestId !== undefined) {
    bodyParams["pullRequestId"] = input.pullRequestId;
  }
  if (input.revisionId !== undefined) {
    bodyParams["revisionId"] = input.revisionId;
  }
  return bodyParams;
};

const serializeAws_json1_1FilePaths = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry => entry);
};

const serializeAws_json1_1GetApprovalRuleTemplateInput = (
  input: GetApprovalRuleTemplateInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.approvalRuleTemplateName !== undefined) {
    bodyParams["approvalRuleTemplateName"] = input.approvalRuleTemplateName;
  }
  return bodyParams;
};

const serializeAws_json1_1GetBlobInput = (
  input: GetBlobInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.blobId !== undefined) {
    bodyParams["blobId"] = input.blobId;
  }
  if (input.repositoryName !== undefined) {
    bodyParams["repositoryName"] = input.repositoryName;
  }
  return bodyParams;
};

const serializeAws_json1_1GetBranchInput = (
  input: GetBranchInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.branchName !== undefined) {
    bodyParams["branchName"] = input.branchName;
  }
  if (input.repositoryName !== undefined) {
    bodyParams["repositoryName"] = input.repositoryName;
  }
  return bodyParams;
};

const serializeAws_json1_1GetCommentInput = (
  input: GetCommentInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.commentId !== undefined) {
    bodyParams["commentId"] = input.commentId;
  }
  return bodyParams;
};

const serializeAws_json1_1GetCommentsForComparedCommitInput = (
  input: GetCommentsForComparedCommitInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.afterCommitId !== undefined) {
    bodyParams["afterCommitId"] = input.afterCommitId;
  }
  if (input.beforeCommitId !== undefined) {
    bodyParams["beforeCommitId"] = input.beforeCommitId;
  }
  if (input.maxResults !== undefined) {
    bodyParams["maxResults"] = input.maxResults;
  }
  if (input.nextToken !== undefined) {
    bodyParams["nextToken"] = input.nextToken;
  }
  if (input.repositoryName !== undefined) {
    bodyParams["repositoryName"] = input.repositoryName;
  }
  return bodyParams;
};

const serializeAws_json1_1GetCommentsForPullRequestInput = (
  input: GetCommentsForPullRequestInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.afterCommitId !== undefined) {
    bodyParams["afterCommitId"] = input.afterCommitId;
  }
  if (input.beforeCommitId !== undefined) {
    bodyParams["beforeCommitId"] = input.beforeCommitId;
  }
  if (input.maxResults !== undefined) {
    bodyParams["maxResults"] = input.maxResults;
  }
  if (input.nextToken !== undefined) {
    bodyParams["nextToken"] = input.nextToken;
  }
  if (input.pullRequestId !== undefined) {
    bodyParams["pullRequestId"] = input.pullRequestId;
  }
  if (input.repositoryName !== undefined) {
    bodyParams["repositoryName"] = input.repositoryName;
  }
  return bodyParams;
};

const serializeAws_json1_1GetCommitInput = (
  input: GetCommitInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.commitId !== undefined) {
    bodyParams["commitId"] = input.commitId;
  }
  if (input.repositoryName !== undefined) {
    bodyParams["repositoryName"] = input.repositoryName;
  }
  return bodyParams;
};

const serializeAws_json1_1GetDifferencesInput = (
  input: GetDifferencesInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  if (input.afterCommitSpecifier !== undefined) {
    bodyParams["afterCommitSpecifier"] = input.afterCommitSpecifier;
  }
  if (input.afterPath !== undefined) {
    bodyParams["afterPath"] = input.afterPath;
  }
  if (input.beforeCommitSpecifier !== undefined) {
    bodyParams["beforeCommitSpecifier"] = input.beforeCommitSpecifier;
  }
  if (input.beforePath !== undefined) {
    bodyParams["beforePath"] = input.beforePath;
  }
  if (input.repositoryName !== undefined) {
    bodyParams["repositoryName"] = input.repositoryName;
  }
  return bodyParams;
};

const serializeAws_json1_1GetFileInput = (
  input: GetFileInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.commitSpecifier !== undefined) {
    bodyParams["commitSpecifier"] = input.commitSpecifier;
  }
  if (input.filePath !== undefined) {
    bodyParams["filePath"] = input.filePath;
  }
  if (input.repositoryName !== undefined) {
    bodyParams["repositoryName"] = input.repositoryName;
  }
  return bodyParams;
};

const serializeAws_json1_1GetFolderInput = (
  input: GetFolderInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.commitSpecifier !== undefined) {
    bodyParams["commitSpecifier"] = input.commitSpecifier;
  }
  if (input.folderPath !== undefined) {
    bodyParams["folderPath"] = input.folderPath;
  }
  if (input.repositoryName !== undefined) {
    bodyParams["repositoryName"] = input.repositoryName;
  }
  return bodyParams;
};

const serializeAws_json1_1GetMergeCommitInput = (
  input: GetMergeCommitInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.conflictDetailLevel !== undefined) {
    bodyParams["conflictDetailLevel"] = input.conflictDetailLevel;
  }
  if (input.conflictResolutionStrategy !== undefined) {
    bodyParams["conflictResolutionStrategy"] = input.conflictResolutionStrategy;
  }
  if (input.destinationCommitSpecifier !== undefined) {
    bodyParams["destinationCommitSpecifier"] = input.destinationCommitSpecifier;
  }
  if (input.repositoryName !== undefined) {
    bodyParams["repositoryName"] = input.repositoryName;
  }
  if (input.sourceCommitSpecifier !== undefined) {
    bodyParams["sourceCommitSpecifier"] = input.sourceCommitSpecifier;
  }
  return bodyParams;
};

const serializeAws_json1_1GetMergeConflictsInput = (
  input: GetMergeConflictsInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.conflictDetailLevel !== undefined) {
    bodyParams["conflictDetailLevel"] = input.conflictDetailLevel;
  }
  if (input.conflictResolutionStrategy !== undefined) {
    bodyParams["conflictResolutionStrategy"] = input.conflictResolutionStrategy;
  }
  if (input.destinationCommitSpecifier !== undefined) {
    bodyParams["destinationCommitSpecifier"] = input.destinationCommitSpecifier;
  }
  if (input.maxConflictFiles !== undefined) {
    bodyParams["maxConflictFiles"] = input.maxConflictFiles;
  }
  if (input.mergeOption !== undefined) {
    bodyParams["mergeOption"] = input.mergeOption;
  }
  if (input.nextToken !== undefined) {
    bodyParams["nextToken"] = input.nextToken;
  }
  if (input.repositoryName !== undefined) {
    bodyParams["repositoryName"] = input.repositoryName;
  }
  if (input.sourceCommitSpecifier !== undefined) {
    bodyParams["sourceCommitSpecifier"] = input.sourceCommitSpecifier;
  }
  return bodyParams;
};

const serializeAws_json1_1GetMergeOptionsInput = (
  input: GetMergeOptionsInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.conflictDetailLevel !== undefined) {
    bodyParams["conflictDetailLevel"] = input.conflictDetailLevel;
  }
  if (input.conflictResolutionStrategy !== undefined) {
    bodyParams["conflictResolutionStrategy"] = input.conflictResolutionStrategy;
  }
  if (input.destinationCommitSpecifier !== undefined) {
    bodyParams["destinationCommitSpecifier"] = input.destinationCommitSpecifier;
  }
  if (input.repositoryName !== undefined) {
    bodyParams["repositoryName"] = input.repositoryName;
  }
  if (input.sourceCommitSpecifier !== undefined) {
    bodyParams["sourceCommitSpecifier"] = input.sourceCommitSpecifier;
  }
  return bodyParams;
};

const serializeAws_json1_1GetPullRequestApprovalStatesInput = (
  input: GetPullRequestApprovalStatesInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.pullRequestId !== undefined) {
    bodyParams["pullRequestId"] = input.pullRequestId;
  }
  if (input.revisionId !== undefined) {
    bodyParams["revisionId"] = input.revisionId;
  }
  return bodyParams;
};

const serializeAws_json1_1GetPullRequestInput = (
  input: GetPullRequestInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.pullRequestId !== undefined) {
    bodyParams["pullRequestId"] = input.pullRequestId;
  }
  return bodyParams;
};

const serializeAws_json1_1GetPullRequestOverrideStateInput = (
  input: GetPullRequestOverrideStateInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.pullRequestId !== undefined) {
    bodyParams["pullRequestId"] = input.pullRequestId;
  }
  if (input.revisionId !== undefined) {
    bodyParams["revisionId"] = input.revisionId;
  }
  return bodyParams;
};

const serializeAws_json1_1GetRepositoryInput = (
  input: GetRepositoryInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.repositoryName !== undefined) {
    bodyParams["repositoryName"] = input.repositoryName;
  }
  return bodyParams;
};

const serializeAws_json1_1GetRepositoryTriggersInput = (
  input: GetRepositoryTriggersInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.repositoryName !== undefined) {
    bodyParams["repositoryName"] = input.repositoryName;
  }
  return bodyParams;
};

const serializeAws_json1_1ListApprovalRuleTemplatesInput = (
  input: ListApprovalRuleTemplatesInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.maxResults !== undefined) {
    bodyParams["maxResults"] = input.maxResults;
  }
  if (input.nextToken !== undefined) {
    bodyParams["nextToken"] = input.nextToken;
  }
  return bodyParams;
};

const serializeAws_json1_1ListAssociatedApprovalRuleTemplatesForRepositoryInput = (
  input: ListAssociatedApprovalRuleTemplatesForRepositoryInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.maxResults !== undefined) {
    bodyParams["maxResults"] = input.maxResults;
  }
  if (input.nextToken !== undefined) {
    bodyParams["nextToken"] = input.nextToken;
  }
  if (input.repositoryName !== undefined) {
    bodyParams["repositoryName"] = input.repositoryName;
  }
  return bodyParams;
};

const serializeAws_json1_1ListBranchesInput = (
  input: ListBranchesInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.nextToken !== undefined) {
    bodyParams["nextToken"] = input.nextToken;
  }
  if (input.repositoryName !== undefined) {
    bodyParams["repositoryName"] = input.repositoryName;
  }
  return bodyParams;
};

const serializeAws_json1_1ListPullRequestsInput = (
  input: ListPullRequestsInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.authorArn !== undefined) {
    bodyParams["authorArn"] = input.authorArn;
  }
  if (input.maxResults !== undefined) {
    bodyParams["maxResults"] = input.maxResults;
  }
  if (input.nextToken !== undefined) {
    bodyParams["nextToken"] = input.nextToken;
  }
  if (input.pullRequestStatus !== undefined) {
    bodyParams["pullRequestStatus"] = input.pullRequestStatus;
  }
  if (input.repositoryName !== undefined) {
    bodyParams["repositoryName"] = input.repositoryName;
  }
  return bodyParams;
};

const serializeAws_json1_1ListRepositoriesForApprovalRuleTemplateInput = (
  input: ListRepositoriesForApprovalRuleTemplateInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.approvalRuleTemplateName !== undefined) {
    bodyParams["approvalRuleTemplateName"] = input.approvalRuleTemplateName;
  }
  if (input.maxResults !== undefined) {
    bodyParams["maxResults"] = input.maxResults;
  }
  if (input.nextToken !== undefined) {
    bodyParams["nextToken"] = input.nextToken;
  }
  return bodyParams;
};

const serializeAws_json1_1ListRepositoriesInput = (
  input: ListRepositoriesInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.nextToken !== undefined) {
    bodyParams["nextToken"] = input.nextToken;
  }
  if (input.order !== undefined) {
    bodyParams["order"] = input.order;
  }
  if (input.sortBy !== undefined) {
    bodyParams["sortBy"] = input.sortBy;
  }
  return bodyParams;
};

const serializeAws_json1_1ListTagsForResourceInput = (
  input: ListTagsForResourceInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.nextToken !== undefined) {
    bodyParams["nextToken"] = input.nextToken;
  }
  if (input.resourceArn !== undefined) {
    bodyParams["resourceArn"] = input.resourceArn;
  }
  return bodyParams;
};

const serializeAws_json1_1Location = (
  input: Location,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.filePath !== undefined) {
    bodyParams["filePath"] = input.filePath;
  }
  if (input.filePosition !== undefined) {
    bodyParams["filePosition"] = input.filePosition;
  }
  if (input.relativeFileVersion !== undefined) {
    bodyParams["relativeFileVersion"] = input.relativeFileVersion;
  }
  return bodyParams;
};

const serializeAws_json1_1MergeBranchesByFastForwardInput = (
  input: MergeBranchesByFastForwardInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.destinationCommitSpecifier !== undefined) {
    bodyParams["destinationCommitSpecifier"] = input.destinationCommitSpecifier;
  }
  if (input.repositoryName !== undefined) {
    bodyParams["repositoryName"] = input.repositoryName;
  }
  if (input.sourceCommitSpecifier !== undefined) {
    bodyParams["sourceCommitSpecifier"] = input.sourceCommitSpecifier;
  }
  if (input.targetBranch !== undefined) {
    bodyParams["targetBranch"] = input.targetBranch;
  }
  return bodyParams;
};

const serializeAws_json1_1MergeBranchesBySquashInput = (
  input: MergeBranchesBySquashInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.authorName !== undefined) {
    bodyParams["authorName"] = input.authorName;
  }
  if (input.commitMessage !== undefined) {
    bodyParams["commitMessage"] = input.commitMessage;
  }
  if (input.conflictDetailLevel !== undefined) {
    bodyParams["conflictDetailLevel"] = input.conflictDetailLevel;
  }
  if (input.conflictResolution !== undefined) {
    bodyParams["conflictResolution"] = serializeAws_json1_1ConflictResolution(
      input.conflictResolution,
      context
    );
  }
  if (input.conflictResolutionStrategy !== undefined) {
    bodyParams["conflictResolutionStrategy"] = input.conflictResolutionStrategy;
  }
  if (input.destinationCommitSpecifier !== undefined) {
    bodyParams["destinationCommitSpecifier"] = input.destinationCommitSpecifier;
  }
  if (input.email !== undefined) {
    bodyParams["email"] = input.email;
  }
  if (input.keepEmptyFolders !== undefined) {
    bodyParams["keepEmptyFolders"] = input.keepEmptyFolders;
  }
  if (input.repositoryName !== undefined) {
    bodyParams["repositoryName"] = input.repositoryName;
  }
  if (input.sourceCommitSpecifier !== undefined) {
    bodyParams["sourceCommitSpecifier"] = input.sourceCommitSpecifier;
  }
  if (input.targetBranch !== undefined) {
    bodyParams["targetBranch"] = input.targetBranch;
  }
  return bodyParams;
};

const serializeAws_json1_1MergeBranchesByThreeWayInput = (
  input: MergeBranchesByThreeWayInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.authorName !== undefined) {
    bodyParams["authorName"] = input.authorName;
  }
  if (input.commitMessage !== undefined) {
    bodyParams["commitMessage"] = input.commitMessage;
  }
  if (input.conflictDetailLevel !== undefined) {
    bodyParams["conflictDetailLevel"] = input.conflictDetailLevel;
  }
  if (input.conflictResolution !== undefined) {
    bodyParams["conflictResolution"] = serializeAws_json1_1ConflictResolution(
      input.conflictResolution,
      context
    );
  }
  if (input.conflictResolutionStrategy !== undefined) {
    bodyParams["conflictResolutionStrategy"] = input.conflictResolutionStrategy;
  }
  if (input.destinationCommitSpecifier !== undefined) {
    bodyParams["destinationCommitSpecifier"] = input.destinationCommitSpecifier;
  }
  if (input.email !== undefined) {
    bodyParams["email"] = input.email;
  }
  if (input.keepEmptyFolders !== undefined) {
    bodyParams["keepEmptyFolders"] = input.keepEmptyFolders;
  }
  if (input.repositoryName !== undefined) {
    bodyParams["repositoryName"] = input.repositoryName;
  }
  if (input.sourceCommitSpecifier !== undefined) {
    bodyParams["sourceCommitSpecifier"] = input.sourceCommitSpecifier;
  }
  if (input.targetBranch !== undefined) {
    bodyParams["targetBranch"] = input.targetBranch;
  }
  return bodyParams;
};

const serializeAws_json1_1MergePullRequestByFastForwardInput = (
  input: MergePullRequestByFastForwardInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.pullRequestId !== undefined) {
    bodyParams["pullRequestId"] = input.pullRequestId;
  }
  if (input.repositoryName !== undefined) {
    bodyParams["repositoryName"] = input.repositoryName;
  }
  if (input.sourceCommitId !== undefined) {
    bodyParams["sourceCommitId"] = input.sourceCommitId;
  }
  return bodyParams;
};

const serializeAws_json1_1MergePullRequestBySquashInput = (
  input: MergePullRequestBySquashInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.authorName !== undefined) {
    bodyParams["authorName"] = input.authorName;
  }
  if (input.commitMessage !== undefined) {
    bodyParams["commitMessage"] = input.commitMessage;
  }
  if (input.conflictDetailLevel !== undefined) {
    bodyParams["conflictDetailLevel"] = input.conflictDetailLevel;
  }
  if (input.conflictResolution !== undefined) {
    bodyParams["conflictResolution"] = serializeAws_json1_1ConflictResolution(
      input.conflictResolution,
      context
    );
  }
  if (input.conflictResolutionStrategy !== undefined) {
    bodyParams["conflictResolutionStrategy"] = input.conflictResolutionStrategy;
  }
  if (input.email !== undefined) {
    bodyParams["email"] = input.email;
  }
  if (input.keepEmptyFolders !== undefined) {
    bodyParams["keepEmptyFolders"] = input.keepEmptyFolders;
  }
  if (input.pullRequestId !== undefined) {
    bodyParams["pullRequestId"] = input.pullRequestId;
  }
  if (input.repositoryName !== undefined) {
    bodyParams["repositoryName"] = input.repositoryName;
  }
  if (input.sourceCommitId !== undefined) {
    bodyParams["sourceCommitId"] = input.sourceCommitId;
  }
  return bodyParams;
};

const serializeAws_json1_1MergePullRequestByThreeWayInput = (
  input: MergePullRequestByThreeWayInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.authorName !== undefined) {
    bodyParams["authorName"] = input.authorName;
  }
  if (input.commitMessage !== undefined) {
    bodyParams["commitMessage"] = input.commitMessage;
  }
  if (input.conflictDetailLevel !== undefined) {
    bodyParams["conflictDetailLevel"] = input.conflictDetailLevel;
  }
  if (input.conflictResolution !== undefined) {
    bodyParams["conflictResolution"] = serializeAws_json1_1ConflictResolution(
      input.conflictResolution,
      context
    );
  }
  if (input.conflictResolutionStrategy !== undefined) {
    bodyParams["conflictResolutionStrategy"] = input.conflictResolutionStrategy;
  }
  if (input.email !== undefined) {
    bodyParams["email"] = input.email;
  }
  if (input.keepEmptyFolders !== undefined) {
    bodyParams["keepEmptyFolders"] = input.keepEmptyFolders;
  }
  if (input.pullRequestId !== undefined) {
    bodyParams["pullRequestId"] = input.pullRequestId;
  }
  if (input.repositoryName !== undefined) {
    bodyParams["repositoryName"] = input.repositoryName;
  }
  if (input.sourceCommitId !== undefined) {
    bodyParams["sourceCommitId"] = input.sourceCommitId;
  }
  return bodyParams;
};

const serializeAws_json1_1OverridePullRequestApprovalRulesInput = (
  input: OverridePullRequestApprovalRulesInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.overrideStatus !== undefined) {
    bodyParams["overrideStatus"] = input.overrideStatus;
  }
  if (input.pullRequestId !== undefined) {
    bodyParams["pullRequestId"] = input.pullRequestId;
  }
  if (input.revisionId !== undefined) {
    bodyParams["revisionId"] = input.revisionId;
  }
  return bodyParams;
};

const serializeAws_json1_1PostCommentForComparedCommitInput = (
  input: PostCommentForComparedCommitInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.afterCommitId !== undefined) {
    bodyParams["afterCommitId"] = input.afterCommitId;
  }
  if (input.beforeCommitId !== undefined) {
    bodyParams["beforeCommitId"] = input.beforeCommitId;
  }
  if (input.clientRequestToken === undefined) {
    input.clientRequestToken = generateIdempotencyToken();
  }
  if (input.clientRequestToken !== undefined) {
    bodyParams["clientRequestToken"] = input.clientRequestToken;
  }
  if (input.content !== undefined) {
    bodyParams["content"] = input.content;
  }
  if (input.location !== undefined) {
    bodyParams["location"] = serializeAws_json1_1Location(
      input.location,
      context
    );
  }
  if (input.repositoryName !== undefined) {
    bodyParams["repositoryName"] = input.repositoryName;
  }
  return bodyParams;
};

const serializeAws_json1_1PostCommentForPullRequestInput = (
  input: PostCommentForPullRequestInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.afterCommitId !== undefined) {
    bodyParams["afterCommitId"] = input.afterCommitId;
  }
  if (input.beforeCommitId !== undefined) {
    bodyParams["beforeCommitId"] = input.beforeCommitId;
  }
  if (input.clientRequestToken === undefined) {
    input.clientRequestToken = generateIdempotencyToken();
  }
  if (input.clientRequestToken !== undefined) {
    bodyParams["clientRequestToken"] = input.clientRequestToken;
  }
  if (input.content !== undefined) {
    bodyParams["content"] = input.content;
  }
  if (input.location !== undefined) {
    bodyParams["location"] = serializeAws_json1_1Location(
      input.location,
      context
    );
  }
  if (input.pullRequestId !== undefined) {
    bodyParams["pullRequestId"] = input.pullRequestId;
  }
  if (input.repositoryName !== undefined) {
    bodyParams["repositoryName"] = input.repositoryName;
  }
  return bodyParams;
};

const serializeAws_json1_1PostCommentReplyInput = (
  input: PostCommentReplyInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.clientRequestToken === undefined) {
    input.clientRequestToken = generateIdempotencyToken();
  }
  if (input.clientRequestToken !== undefined) {
    bodyParams["clientRequestToken"] = input.clientRequestToken;
  }
  if (input.content !== undefined) {
    bodyParams["content"] = input.content;
  }
  if (input.inReplyTo !== undefined) {
    bodyParams["inReplyTo"] = input.inReplyTo;
  }
  return bodyParams;
};

const serializeAws_json1_1PutFileEntries = (
  input: Array<PutFileEntry>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry =>
    serializeAws_json1_1PutFileEntry(entry, context)
  );
};

const serializeAws_json1_1PutFileEntry = (
  input: PutFileEntry,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.fileContent !== undefined) {
    bodyParams["fileContent"] = context.base64Encoder(input.fileContent);
  }
  if (input.fileMode !== undefined) {
    bodyParams["fileMode"] = input.fileMode;
  }
  if (input.filePath !== undefined) {
    bodyParams["filePath"] = input.filePath;
  }
  if (input.sourceFile !== undefined) {
    bodyParams["sourceFile"] = serializeAws_json1_1SourceFileSpecifier(
      input.sourceFile,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1PutFileInput = (
  input: PutFileInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.branchName !== undefined) {
    bodyParams["branchName"] = input.branchName;
  }
  if (input.commitMessage !== undefined) {
    bodyParams["commitMessage"] = input.commitMessage;
  }
  if (input.email !== undefined) {
    bodyParams["email"] = input.email;
  }
  if (input.fileContent !== undefined) {
    bodyParams["fileContent"] = context.base64Encoder(input.fileContent);
  }
  if (input.fileMode !== undefined) {
    bodyParams["fileMode"] = input.fileMode;
  }
  if (input.filePath !== undefined) {
    bodyParams["filePath"] = input.filePath;
  }
  if (input.name !== undefined) {
    bodyParams["name"] = input.name;
  }
  if (input.parentCommitId !== undefined) {
    bodyParams["parentCommitId"] = input.parentCommitId;
  }
  if (input.repositoryName !== undefined) {
    bodyParams["repositoryName"] = input.repositoryName;
  }
  return bodyParams;
};

const serializeAws_json1_1PutRepositoryTriggersInput = (
  input: PutRepositoryTriggersInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.repositoryName !== undefined) {
    bodyParams["repositoryName"] = input.repositoryName;
  }
  if (input.triggers !== undefined) {
    bodyParams["triggers"] = serializeAws_json1_1RepositoryTriggersList(
      input.triggers,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1ReplaceContentEntries = (
  input: Array<ReplaceContentEntry>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry =>
    serializeAws_json1_1ReplaceContentEntry(entry, context)
  );
};

const serializeAws_json1_1ReplaceContentEntry = (
  input: ReplaceContentEntry,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.content !== undefined) {
    bodyParams["content"] = context.base64Encoder(input.content);
  }
  if (input.fileMode !== undefined) {
    bodyParams["fileMode"] = input.fileMode;
  }
  if (input.filePath !== undefined) {
    bodyParams["filePath"] = input.filePath;
  }
  if (input.replacementType !== undefined) {
    bodyParams["replacementType"] = input.replacementType;
  }
  return bodyParams;
};

const serializeAws_json1_1RepositoryNameList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry => entry);
};

const serializeAws_json1_1RepositoryTrigger = (
  input: RepositoryTrigger,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.branches !== undefined) {
    bodyParams["branches"] = serializeAws_json1_1BranchNameList(
      input.branches,
      context
    );
  }
  if (input.customData !== undefined) {
    bodyParams["customData"] = input.customData;
  }
  if (input.destinationArn !== undefined) {
    bodyParams["destinationArn"] = input.destinationArn;
  }
  if (input.events !== undefined) {
    bodyParams["events"] = serializeAws_json1_1RepositoryTriggerEventList(
      input.events,
      context
    );
  }
  if (input.name !== undefined) {
    bodyParams["name"] = input.name;
  }
  return bodyParams;
};

const serializeAws_json1_1RepositoryTriggerEventList = (
  input: Array<RepositoryTriggerEventEnum | string>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry => entry);
};

const serializeAws_json1_1RepositoryTriggersList = (
  input: Array<RepositoryTrigger>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry =>
    serializeAws_json1_1RepositoryTrigger(entry, context)
  );
};

const serializeAws_json1_1SetFileModeEntries = (
  input: Array<SetFileModeEntry>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry =>
    serializeAws_json1_1SetFileModeEntry(entry, context)
  );
};

const serializeAws_json1_1SetFileModeEntry = (
  input: SetFileModeEntry,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.fileMode !== undefined) {
    bodyParams["fileMode"] = input.fileMode;
  }
  if (input.filePath !== undefined) {
    bodyParams["filePath"] = input.filePath;
  }
  return bodyParams;
};

const serializeAws_json1_1SourceFileSpecifier = (
  input: SourceFileSpecifier,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.filePath !== undefined) {
    bodyParams["filePath"] = input.filePath;
  }
  if (input.isMove !== undefined) {
    bodyParams["isMove"] = input.isMove;
  }
  return bodyParams;
};

const serializeAws_json1_1TagKeysList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry => entry);
};

const serializeAws_json1_1TagResourceInput = (
  input: TagResourceInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.resourceArn !== undefined) {
    bodyParams["resourceArn"] = input.resourceArn;
  }
  if (input.tags !== undefined) {
    bodyParams["tags"] = serializeAws_json1_1TagsMap(input.tags, context);
  }
  return bodyParams;
};

const serializeAws_json1_1TagsMap = (
  input: { [key: string]: string },
  context: __SerdeContext
): any => {
  const mapParams: any = {};
  Object.keys(input).forEach(key => {
    mapParams[key] = input[key];
  });
  return mapParams;
};

const serializeAws_json1_1Target = (
  input: Target,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.destinationReference !== undefined) {
    bodyParams["destinationReference"] = input.destinationReference;
  }
  if (input.repositoryName !== undefined) {
    bodyParams["repositoryName"] = input.repositoryName;
  }
  if (input.sourceReference !== undefined) {
    bodyParams["sourceReference"] = input.sourceReference;
  }
  return bodyParams;
};

const serializeAws_json1_1TargetList = (
  input: Array<Target>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry => serializeAws_json1_1Target(entry, context));
};

const serializeAws_json1_1TestRepositoryTriggersInput = (
  input: TestRepositoryTriggersInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.repositoryName !== undefined) {
    bodyParams["repositoryName"] = input.repositoryName;
  }
  if (input.triggers !== undefined) {
    bodyParams["triggers"] = serializeAws_json1_1RepositoryTriggersList(
      input.triggers,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1UntagResourceInput = (
  input: UntagResourceInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.resourceArn !== undefined) {
    bodyParams["resourceArn"] = input.resourceArn;
  }
  if (input.tagKeys !== undefined) {
    bodyParams["tagKeys"] = serializeAws_json1_1TagKeysList(
      input.tagKeys,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1UpdateApprovalRuleTemplateContentInput = (
  input: UpdateApprovalRuleTemplateContentInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.approvalRuleTemplateName !== undefined) {
    bodyParams["approvalRuleTemplateName"] = input.approvalRuleTemplateName;
  }
  if (input.existingRuleContentSha256 !== undefined) {
    bodyParams["existingRuleContentSha256"] = input.existingRuleContentSha256;
  }
  if (input.newRuleContent !== undefined) {
    bodyParams["newRuleContent"] = input.newRuleContent;
  }
  return bodyParams;
};

const serializeAws_json1_1UpdateApprovalRuleTemplateDescriptionInput = (
  input: UpdateApprovalRuleTemplateDescriptionInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.approvalRuleTemplateDescription !== undefined) {
    bodyParams["approvalRuleTemplateDescription"] =
      input.approvalRuleTemplateDescription;
  }
  if (input.approvalRuleTemplateName !== undefined) {
    bodyParams["approvalRuleTemplateName"] = input.approvalRuleTemplateName;
  }
  return bodyParams;
};

const serializeAws_json1_1UpdateApprovalRuleTemplateNameInput = (
  input: UpdateApprovalRuleTemplateNameInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.newApprovalRuleTemplateName !== undefined) {
    bodyParams["newApprovalRuleTemplateName"] =
      input.newApprovalRuleTemplateName;
  }
  if (input.oldApprovalRuleTemplateName !== undefined) {
    bodyParams["oldApprovalRuleTemplateName"] =
      input.oldApprovalRuleTemplateName;
  }
  return bodyParams;
};

const serializeAws_json1_1UpdateCommentInput = (
  input: UpdateCommentInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.commentId !== undefined) {
    bodyParams["commentId"] = input.commentId;
  }
  if (input.content !== undefined) {
    bodyParams["content"] = input.content;
  }
  return bodyParams;
};

const serializeAws_json1_1UpdateDefaultBranchInput = (
  input: UpdateDefaultBranchInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.defaultBranchName !== undefined) {
    bodyParams["defaultBranchName"] = input.defaultBranchName;
  }
  if (input.repositoryName !== undefined) {
    bodyParams["repositoryName"] = input.repositoryName;
  }
  return bodyParams;
};

const serializeAws_json1_1UpdatePullRequestApprovalRuleContentInput = (
  input: UpdatePullRequestApprovalRuleContentInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.approvalRuleName !== undefined) {
    bodyParams["approvalRuleName"] = input.approvalRuleName;
  }
  if (input.existingRuleContentSha256 !== undefined) {
    bodyParams["existingRuleContentSha256"] = input.existingRuleContentSha256;
  }
  if (input.newRuleContent !== undefined) {
    bodyParams["newRuleContent"] = input.newRuleContent;
  }
  if (input.pullRequestId !== undefined) {
    bodyParams["pullRequestId"] = input.pullRequestId;
  }
  return bodyParams;
};

const serializeAws_json1_1UpdatePullRequestApprovalStateInput = (
  input: UpdatePullRequestApprovalStateInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.approvalState !== undefined) {
    bodyParams["approvalState"] = input.approvalState;
  }
  if (input.pullRequestId !== undefined) {
    bodyParams["pullRequestId"] = input.pullRequestId;
  }
  if (input.revisionId !== undefined) {
    bodyParams["revisionId"] = input.revisionId;
  }
  return bodyParams;
};

const serializeAws_json1_1UpdatePullRequestDescriptionInput = (
  input: UpdatePullRequestDescriptionInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.description !== undefined) {
    bodyParams["description"] = input.description;
  }
  if (input.pullRequestId !== undefined) {
    bodyParams["pullRequestId"] = input.pullRequestId;
  }
  return bodyParams;
};

const serializeAws_json1_1UpdatePullRequestStatusInput = (
  input: UpdatePullRequestStatusInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.pullRequestId !== undefined) {
    bodyParams["pullRequestId"] = input.pullRequestId;
  }
  if (input.pullRequestStatus !== undefined) {
    bodyParams["pullRequestStatus"] = input.pullRequestStatus;
  }
  return bodyParams;
};

const serializeAws_json1_1UpdatePullRequestTitleInput = (
  input: UpdatePullRequestTitleInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.pullRequestId !== undefined) {
    bodyParams["pullRequestId"] = input.pullRequestId;
  }
  if (input.title !== undefined) {
    bodyParams["title"] = input.title;
  }
  return bodyParams;
};

const serializeAws_json1_1UpdateRepositoryDescriptionInput = (
  input: UpdateRepositoryDescriptionInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.repositoryDescription !== undefined) {
    bodyParams["repositoryDescription"] = input.repositoryDescription;
  }
  if (input.repositoryName !== undefined) {
    bodyParams["repositoryName"] = input.repositoryName;
  }
  return bodyParams;
};

const serializeAws_json1_1UpdateRepositoryNameInput = (
  input: UpdateRepositoryNameInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.newName !== undefined) {
    bodyParams["newName"] = input.newName;
  }
  if (input.oldName !== undefined) {
    bodyParams["oldName"] = input.oldName;
  }
  return bodyParams;
};

const deserializeAws_json1_1ActorDoesNotExistException = (
  output: any,
  context: __SerdeContext
): ActorDoesNotExistException => {
  let contents: any = {
    __type: "ActorDoesNotExistException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1Approval = (
  output: any,
  context: __SerdeContext
): Approval => {
  let contents: any = {
    __type: "Approval",
    approvalState: undefined,
    userArn: undefined
  };
  if (output.approvalState !== undefined && output.approvalState !== null) {
    contents.approvalState = output.approvalState;
  }
  if (output.userArn !== undefined && output.userArn !== null) {
    contents.userArn = output.userArn;
  }
  return contents;
};

const deserializeAws_json1_1ApprovalList = (
  output: any,
  context: __SerdeContext
): Array<Approval> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1Approval(entry, context)
  );
};

const deserializeAws_json1_1ApprovalRule = (
  output: any,
  context: __SerdeContext
): ApprovalRule => {
  let contents: any = {
    __type: "ApprovalRule",
    approvalRuleContent: undefined,
    approvalRuleId: undefined,
    approvalRuleName: undefined,
    creationDate: undefined,
    lastModifiedDate: undefined,
    lastModifiedUser: undefined,
    originApprovalRuleTemplate: undefined,
    ruleContentSha256: undefined
  };
  if (
    output.approvalRuleContent !== undefined &&
    output.approvalRuleContent !== null
  ) {
    contents.approvalRuleContent = output.approvalRuleContent;
  }
  if (output.approvalRuleId !== undefined && output.approvalRuleId !== null) {
    contents.approvalRuleId = output.approvalRuleId;
  }
  if (
    output.approvalRuleName !== undefined &&
    output.approvalRuleName !== null
  ) {
    contents.approvalRuleName = output.approvalRuleName;
  }
  if (output.creationDate !== undefined && output.creationDate !== null) {
    contents.creationDate = new Date(Math.round(output.creationDate * 1000));
  }
  if (
    output.lastModifiedDate !== undefined &&
    output.lastModifiedDate !== null
  ) {
    contents.lastModifiedDate = new Date(
      Math.round(output.lastModifiedDate * 1000)
    );
  }
  if (
    output.lastModifiedUser !== undefined &&
    output.lastModifiedUser !== null
  ) {
    contents.lastModifiedUser = output.lastModifiedUser;
  }
  if (
    output.originApprovalRuleTemplate !== undefined &&
    output.originApprovalRuleTemplate !== null
  ) {
    contents.originApprovalRuleTemplate = deserializeAws_json1_1OriginApprovalRuleTemplate(
      output.originApprovalRuleTemplate,
      context
    );
  }
  if (
    output.ruleContentSha256 !== undefined &&
    output.ruleContentSha256 !== null
  ) {
    contents.ruleContentSha256 = output.ruleContentSha256;
  }
  return contents;
};

const deserializeAws_json1_1ApprovalRuleContentRequiredException = (
  output: any,
  context: __SerdeContext
): ApprovalRuleContentRequiredException => {
  let contents: any = {
    __type: "ApprovalRuleContentRequiredException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1ApprovalRuleDoesNotExistException = (
  output: any,
  context: __SerdeContext
): ApprovalRuleDoesNotExistException => {
  let contents: any = {
    __type: "ApprovalRuleDoesNotExistException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1ApprovalRuleEventMetadata = (
  output: any,
  context: __SerdeContext
): ApprovalRuleEventMetadata => {
  let contents: any = {
    __type: "ApprovalRuleEventMetadata",
    approvalRuleContent: undefined,
    approvalRuleId: undefined,
    approvalRuleName: undefined
  };
  if (
    output.approvalRuleContent !== undefined &&
    output.approvalRuleContent !== null
  ) {
    contents.approvalRuleContent = output.approvalRuleContent;
  }
  if (output.approvalRuleId !== undefined && output.approvalRuleId !== null) {
    contents.approvalRuleId = output.approvalRuleId;
  }
  if (
    output.approvalRuleName !== undefined &&
    output.approvalRuleName !== null
  ) {
    contents.approvalRuleName = output.approvalRuleName;
  }
  return contents;
};

const deserializeAws_json1_1ApprovalRuleNameAlreadyExistsException = (
  output: any,
  context: __SerdeContext
): ApprovalRuleNameAlreadyExistsException => {
  let contents: any = {
    __type: "ApprovalRuleNameAlreadyExistsException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1ApprovalRuleNameRequiredException = (
  output: any,
  context: __SerdeContext
): ApprovalRuleNameRequiredException => {
  let contents: any = {
    __type: "ApprovalRuleNameRequiredException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1ApprovalRuleOverriddenEventMetadata = (
  output: any,
  context: __SerdeContext
): ApprovalRuleOverriddenEventMetadata => {
  let contents: any = {
    __type: "ApprovalRuleOverriddenEventMetadata",
    overrideStatus: undefined,
    revisionId: undefined
  };
  if (output.overrideStatus !== undefined && output.overrideStatus !== null) {
    contents.overrideStatus = output.overrideStatus;
  }
  if (output.revisionId !== undefined && output.revisionId !== null) {
    contents.revisionId = output.revisionId;
  }
  return contents;
};

const deserializeAws_json1_1ApprovalRuleTemplate = (
  output: any,
  context: __SerdeContext
): ApprovalRuleTemplate => {
  let contents: any = {
    __type: "ApprovalRuleTemplate",
    approvalRuleTemplateContent: undefined,
    approvalRuleTemplateDescription: undefined,
    approvalRuleTemplateId: undefined,
    approvalRuleTemplateName: undefined,
    creationDate: undefined,
    lastModifiedDate: undefined,
    lastModifiedUser: undefined,
    ruleContentSha256: undefined
  };
  if (
    output.approvalRuleTemplateContent !== undefined &&
    output.approvalRuleTemplateContent !== null
  ) {
    contents.approvalRuleTemplateContent = output.approvalRuleTemplateContent;
  }
  if (
    output.approvalRuleTemplateDescription !== undefined &&
    output.approvalRuleTemplateDescription !== null
  ) {
    contents.approvalRuleTemplateDescription =
      output.approvalRuleTemplateDescription;
  }
  if (
    output.approvalRuleTemplateId !== undefined &&
    output.approvalRuleTemplateId !== null
  ) {
    contents.approvalRuleTemplateId = output.approvalRuleTemplateId;
  }
  if (
    output.approvalRuleTemplateName !== undefined &&
    output.approvalRuleTemplateName !== null
  ) {
    contents.approvalRuleTemplateName = output.approvalRuleTemplateName;
  }
  if (output.creationDate !== undefined && output.creationDate !== null) {
    contents.creationDate = new Date(Math.round(output.creationDate * 1000));
  }
  if (
    output.lastModifiedDate !== undefined &&
    output.lastModifiedDate !== null
  ) {
    contents.lastModifiedDate = new Date(
      Math.round(output.lastModifiedDate * 1000)
    );
  }
  if (
    output.lastModifiedUser !== undefined &&
    output.lastModifiedUser !== null
  ) {
    contents.lastModifiedUser = output.lastModifiedUser;
  }
  if (
    output.ruleContentSha256 !== undefined &&
    output.ruleContentSha256 !== null
  ) {
    contents.ruleContentSha256 = output.ruleContentSha256;
  }
  return contents;
};

const deserializeAws_json1_1ApprovalRuleTemplateContentRequiredException = (
  output: any,
  context: __SerdeContext
): ApprovalRuleTemplateContentRequiredException => {
  let contents: any = {
    __type: "ApprovalRuleTemplateContentRequiredException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1ApprovalRuleTemplateDoesNotExistException = (
  output: any,
  context: __SerdeContext
): ApprovalRuleTemplateDoesNotExistException => {
  let contents: any = {
    __type: "ApprovalRuleTemplateDoesNotExistException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1ApprovalRuleTemplateInUseException = (
  output: any,
  context: __SerdeContext
): ApprovalRuleTemplateInUseException => {
  let contents: any = {
    __type: "ApprovalRuleTemplateInUseException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1ApprovalRuleTemplateNameAlreadyExistsException = (
  output: any,
  context: __SerdeContext
): ApprovalRuleTemplateNameAlreadyExistsException => {
  let contents: any = {
    __type: "ApprovalRuleTemplateNameAlreadyExistsException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1ApprovalRuleTemplateNameList = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1ApprovalRuleTemplateNameRequiredException = (
  output: any,
  context: __SerdeContext
): ApprovalRuleTemplateNameRequiredException => {
  let contents: any = {
    __type: "ApprovalRuleTemplateNameRequiredException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1ApprovalRulesList = (
  output: any,
  context: __SerdeContext
): Array<ApprovalRule> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1ApprovalRule(entry, context)
  );
};

const deserializeAws_json1_1ApprovalRulesNotSatisfiedList = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1ApprovalRulesSatisfiedList = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1ApprovalStateChangedEventMetadata = (
  output: any,
  context: __SerdeContext
): ApprovalStateChangedEventMetadata => {
  let contents: any = {
    __type: "ApprovalStateChangedEventMetadata",
    approvalStatus: undefined,
    revisionId: undefined
  };
  if (output.approvalStatus !== undefined && output.approvalStatus !== null) {
    contents.approvalStatus = output.approvalStatus;
  }
  if (output.revisionId !== undefined && output.revisionId !== null) {
    contents.revisionId = output.revisionId;
  }
  return contents;
};

const deserializeAws_json1_1ApprovalStateRequiredException = (
  output: any,
  context: __SerdeContext
): ApprovalStateRequiredException => {
  let contents: any = {
    __type: "ApprovalStateRequiredException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1AuthorDoesNotExistException = (
  output: any,
  context: __SerdeContext
): AuthorDoesNotExistException => {
  let contents: any = {
    __type: "AuthorDoesNotExistException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1BatchAssociateApprovalRuleTemplateWithRepositoriesError = (
  output: any,
  context: __SerdeContext
): BatchAssociateApprovalRuleTemplateWithRepositoriesError => {
  let contents: any = {
    __type: "BatchAssociateApprovalRuleTemplateWithRepositoriesError",
    errorCode: undefined,
    errorMessage: undefined,
    repositoryName: undefined
  };
  if (output.errorCode !== undefined && output.errorCode !== null) {
    contents.errorCode = output.errorCode;
  }
  if (output.errorMessage !== undefined && output.errorMessage !== null) {
    contents.errorMessage = output.errorMessage;
  }
  if (output.repositoryName !== undefined && output.repositoryName !== null) {
    contents.repositoryName = output.repositoryName;
  }
  return contents;
};

const deserializeAws_json1_1BatchAssociateApprovalRuleTemplateWithRepositoriesErrorsList = (
  output: any,
  context: __SerdeContext
): Array<BatchAssociateApprovalRuleTemplateWithRepositoriesError> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1BatchAssociateApprovalRuleTemplateWithRepositoriesError(
      entry,
      context
    )
  );
};

const deserializeAws_json1_1BatchAssociateApprovalRuleTemplateWithRepositoriesOutput = (
  output: any,
  context: __SerdeContext
): BatchAssociateApprovalRuleTemplateWithRepositoriesOutput => {
  let contents: any = {
    __type: "BatchAssociateApprovalRuleTemplateWithRepositoriesOutput",
    associatedRepositoryNames: undefined,
    errors: undefined
  };
  if (
    output.associatedRepositoryNames !== undefined &&
    output.associatedRepositoryNames !== null
  ) {
    contents.associatedRepositoryNames = deserializeAws_json1_1RepositoryNameList(
      output.associatedRepositoryNames,
      context
    );
  }
  if (output.errors !== undefined && output.errors !== null) {
    contents.errors = deserializeAws_json1_1BatchAssociateApprovalRuleTemplateWithRepositoriesErrorsList(
      output.errors,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1BatchDescribeMergeConflictsError = (
  output: any,
  context: __SerdeContext
): BatchDescribeMergeConflictsError => {
  let contents: any = {
    __type: "BatchDescribeMergeConflictsError",
    exceptionName: undefined,
    filePath: undefined,
    message: undefined
  };
  if (output.exceptionName !== undefined && output.exceptionName !== null) {
    contents.exceptionName = output.exceptionName;
  }
  if (output.filePath !== undefined && output.filePath !== null) {
    contents.filePath = output.filePath;
  }
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1BatchDescribeMergeConflictsErrors = (
  output: any,
  context: __SerdeContext
): Array<BatchDescribeMergeConflictsError> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1BatchDescribeMergeConflictsError(entry, context)
  );
};

const deserializeAws_json1_1BatchDescribeMergeConflictsOutput = (
  output: any,
  context: __SerdeContext
): BatchDescribeMergeConflictsOutput => {
  let contents: any = {
    __type: "BatchDescribeMergeConflictsOutput",
    baseCommitId: undefined,
    conflicts: undefined,
    destinationCommitId: undefined,
    errors: undefined,
    nextToken: undefined,
    sourceCommitId: undefined
  };
  if (output.baseCommitId !== undefined && output.baseCommitId !== null) {
    contents.baseCommitId = output.baseCommitId;
  }
  if (output.conflicts !== undefined && output.conflicts !== null) {
    contents.conflicts = deserializeAws_json1_1Conflicts(
      output.conflicts,
      context
    );
  }
  if (
    output.destinationCommitId !== undefined &&
    output.destinationCommitId !== null
  ) {
    contents.destinationCommitId = output.destinationCommitId;
  }
  if (output.errors !== undefined && output.errors !== null) {
    contents.errors = deserializeAws_json1_1BatchDescribeMergeConflictsErrors(
      output.errors,
      context
    );
  }
  if (output.nextToken !== undefined && output.nextToken !== null) {
    contents.nextToken = output.nextToken;
  }
  if (output.sourceCommitId !== undefined && output.sourceCommitId !== null) {
    contents.sourceCommitId = output.sourceCommitId;
  }
  return contents;
};

const deserializeAws_json1_1BatchDisassociateApprovalRuleTemplateFromRepositoriesError = (
  output: any,
  context: __SerdeContext
): BatchDisassociateApprovalRuleTemplateFromRepositoriesError => {
  let contents: any = {
    __type: "BatchDisassociateApprovalRuleTemplateFromRepositoriesError",
    errorCode: undefined,
    errorMessage: undefined,
    repositoryName: undefined
  };
  if (output.errorCode !== undefined && output.errorCode !== null) {
    contents.errorCode = output.errorCode;
  }
  if (output.errorMessage !== undefined && output.errorMessage !== null) {
    contents.errorMessage = output.errorMessage;
  }
  if (output.repositoryName !== undefined && output.repositoryName !== null) {
    contents.repositoryName = output.repositoryName;
  }
  return contents;
};

const deserializeAws_json1_1BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorsList = (
  output: any,
  context: __SerdeContext
): Array<BatchDisassociateApprovalRuleTemplateFromRepositoriesError> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1BatchDisassociateApprovalRuleTemplateFromRepositoriesError(
      entry,
      context
    )
  );
};

const deserializeAws_json1_1BatchDisassociateApprovalRuleTemplateFromRepositoriesOutput = (
  output: any,
  context: __SerdeContext
): BatchDisassociateApprovalRuleTemplateFromRepositoriesOutput => {
  let contents: any = {
    __type: "BatchDisassociateApprovalRuleTemplateFromRepositoriesOutput",
    disassociatedRepositoryNames: undefined,
    errors: undefined
  };
  if (
    output.disassociatedRepositoryNames !== undefined &&
    output.disassociatedRepositoryNames !== null
  ) {
    contents.disassociatedRepositoryNames = deserializeAws_json1_1RepositoryNameList(
      output.disassociatedRepositoryNames,
      context
    );
  }
  if (output.errors !== undefined && output.errors !== null) {
    contents.errors = deserializeAws_json1_1BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorsList(
      output.errors,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1BatchGetCommitsError = (
  output: any,
  context: __SerdeContext
): BatchGetCommitsError => {
  let contents: any = {
    __type: "BatchGetCommitsError",
    commitId: undefined,
    errorCode: undefined,
    errorMessage: undefined
  };
  if (output.commitId !== undefined && output.commitId !== null) {
    contents.commitId = output.commitId;
  }
  if (output.errorCode !== undefined && output.errorCode !== null) {
    contents.errorCode = output.errorCode;
  }
  if (output.errorMessage !== undefined && output.errorMessage !== null) {
    contents.errorMessage = output.errorMessage;
  }
  return contents;
};

const deserializeAws_json1_1BatchGetCommitsErrorsList = (
  output: any,
  context: __SerdeContext
): Array<BatchGetCommitsError> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1BatchGetCommitsError(entry, context)
  );
};

const deserializeAws_json1_1BatchGetCommitsOutput = (
  output: any,
  context: __SerdeContext
): BatchGetCommitsOutput => {
  let contents: any = {
    __type: "BatchGetCommitsOutput",
    commits: undefined,
    errors: undefined
  };
  if (output.commits !== undefined && output.commits !== null) {
    contents.commits = deserializeAws_json1_1CommitObjectsList(
      output.commits,
      context
    );
  }
  if (output.errors !== undefined && output.errors !== null) {
    contents.errors = deserializeAws_json1_1BatchGetCommitsErrorsList(
      output.errors,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1BatchGetRepositoriesOutput = (
  output: any,
  context: __SerdeContext
): BatchGetRepositoriesOutput => {
  let contents: any = {
    __type: "BatchGetRepositoriesOutput",
    repositories: undefined,
    repositoriesNotFound: undefined
  };
  if (output.repositories !== undefined && output.repositories !== null) {
    contents.repositories = deserializeAws_json1_1RepositoryMetadataList(
      output.repositories,
      context
    );
  }
  if (
    output.repositoriesNotFound !== undefined &&
    output.repositoriesNotFound !== null
  ) {
    contents.repositoriesNotFound = deserializeAws_json1_1RepositoryNotFoundList(
      output.repositoriesNotFound,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1BeforeCommitIdAndAfterCommitIdAreSameException = (
  output: any,
  context: __SerdeContext
): BeforeCommitIdAndAfterCommitIdAreSameException => {
  let contents: any = {
    __type: "BeforeCommitIdAndAfterCommitIdAreSameException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1BlobIdDoesNotExistException = (
  output: any,
  context: __SerdeContext
): BlobIdDoesNotExistException => {
  let contents: any = {
    __type: "BlobIdDoesNotExistException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1BlobIdRequiredException = (
  output: any,
  context: __SerdeContext
): BlobIdRequiredException => {
  let contents: any = {
    __type: "BlobIdRequiredException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1BlobMetadata = (
  output: any,
  context: __SerdeContext
): BlobMetadata => {
  let contents: any = {
    __type: "BlobMetadata",
    blobId: undefined,
    mode: undefined,
    path: undefined
  };
  if (output.blobId !== undefined && output.blobId !== null) {
    contents.blobId = output.blobId;
  }
  if (output.mode !== undefined && output.mode !== null) {
    contents.mode = output.mode;
  }
  if (output.path !== undefined && output.path !== null) {
    contents.path = output.path;
  }
  return contents;
};

const deserializeAws_json1_1BranchDoesNotExistException = (
  output: any,
  context: __SerdeContext
): BranchDoesNotExistException => {
  let contents: any = {
    __type: "BranchDoesNotExistException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1BranchInfo = (
  output: any,
  context: __SerdeContext
): BranchInfo => {
  let contents: any = {
    __type: "BranchInfo",
    branchName: undefined,
    commitId: undefined
  };
  if (output.branchName !== undefined && output.branchName !== null) {
    contents.branchName = output.branchName;
  }
  if (output.commitId !== undefined && output.commitId !== null) {
    contents.commitId = output.commitId;
  }
  return contents;
};

const deserializeAws_json1_1BranchNameExistsException = (
  output: any,
  context: __SerdeContext
): BranchNameExistsException => {
  let contents: any = {
    __type: "BranchNameExistsException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1BranchNameIsTagNameException = (
  output: any,
  context: __SerdeContext
): BranchNameIsTagNameException => {
  let contents: any = {
    __type: "BranchNameIsTagNameException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1BranchNameList = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1BranchNameRequiredException = (
  output: any,
  context: __SerdeContext
): BranchNameRequiredException => {
  let contents: any = {
    __type: "BranchNameRequiredException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1CannotDeleteApprovalRuleFromTemplateException = (
  output: any,
  context: __SerdeContext
): CannotDeleteApprovalRuleFromTemplateException => {
  let contents: any = {
    __type: "CannotDeleteApprovalRuleFromTemplateException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1CannotModifyApprovalRuleFromTemplateException = (
  output: any,
  context: __SerdeContext
): CannotModifyApprovalRuleFromTemplateException => {
  let contents: any = {
    __type: "CannotModifyApprovalRuleFromTemplateException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1ClientRequestTokenRequiredException = (
  output: any,
  context: __SerdeContext
): ClientRequestTokenRequiredException => {
  let contents: any = {
    __type: "ClientRequestTokenRequiredException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1Comment = (
  output: any,
  context: __SerdeContext
): Comment => {
  let contents: any = {
    __type: "Comment",
    authorArn: undefined,
    clientRequestToken: undefined,
    commentId: undefined,
    content: undefined,
    creationDate: undefined,
    deleted: undefined,
    inReplyTo: undefined,
    lastModifiedDate: undefined
  };
  if (output.authorArn !== undefined && output.authorArn !== null) {
    contents.authorArn = output.authorArn;
  }
  if (
    output.clientRequestToken !== undefined &&
    output.clientRequestToken !== null
  ) {
    contents.clientRequestToken = output.clientRequestToken;
  }
  if (output.commentId !== undefined && output.commentId !== null) {
    contents.commentId = output.commentId;
  }
  if (output.content !== undefined && output.content !== null) {
    contents.content = output.content;
  }
  if (output.creationDate !== undefined && output.creationDate !== null) {
    contents.creationDate = new Date(Math.round(output.creationDate * 1000));
  }
  if (output.deleted !== undefined && output.deleted !== null) {
    contents.deleted = output.deleted;
  }
  if (output.inReplyTo !== undefined && output.inReplyTo !== null) {
    contents.inReplyTo = output.inReplyTo;
  }
  if (
    output.lastModifiedDate !== undefined &&
    output.lastModifiedDate !== null
  ) {
    contents.lastModifiedDate = new Date(
      Math.round(output.lastModifiedDate * 1000)
    );
  }
  return contents;
};

const deserializeAws_json1_1CommentContentRequiredException = (
  output: any,
  context: __SerdeContext
): CommentContentRequiredException => {
  let contents: any = {
    __type: "CommentContentRequiredException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1CommentContentSizeLimitExceededException = (
  output: any,
  context: __SerdeContext
): CommentContentSizeLimitExceededException => {
  let contents: any = {
    __type: "CommentContentSizeLimitExceededException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1CommentDeletedException = (
  output: any,
  context: __SerdeContext
): CommentDeletedException => {
  let contents: any = {
    __type: "CommentDeletedException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1CommentDoesNotExistException = (
  output: any,
  context: __SerdeContext
): CommentDoesNotExistException => {
  let contents: any = {
    __type: "CommentDoesNotExistException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1CommentIdRequiredException = (
  output: any,
  context: __SerdeContext
): CommentIdRequiredException => {
  let contents: any = {
    __type: "CommentIdRequiredException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1CommentNotCreatedByCallerException = (
  output: any,
  context: __SerdeContext
): CommentNotCreatedByCallerException => {
  let contents: any = {
    __type: "CommentNotCreatedByCallerException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1Comments = (
  output: any,
  context: __SerdeContext
): Array<Comment> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1Comment(entry, context)
  );
};

const deserializeAws_json1_1CommentsForComparedCommit = (
  output: any,
  context: __SerdeContext
): CommentsForComparedCommit => {
  let contents: any = {
    __type: "CommentsForComparedCommit",
    afterBlobId: undefined,
    afterCommitId: undefined,
    beforeBlobId: undefined,
    beforeCommitId: undefined,
    comments: undefined,
    location: undefined,
    repositoryName: undefined
  };
  if (output.afterBlobId !== undefined && output.afterBlobId !== null) {
    contents.afterBlobId = output.afterBlobId;
  }
  if (output.afterCommitId !== undefined && output.afterCommitId !== null) {
    contents.afterCommitId = output.afterCommitId;
  }
  if (output.beforeBlobId !== undefined && output.beforeBlobId !== null) {
    contents.beforeBlobId = output.beforeBlobId;
  }
  if (output.beforeCommitId !== undefined && output.beforeCommitId !== null) {
    contents.beforeCommitId = output.beforeCommitId;
  }
  if (output.comments !== undefined && output.comments !== null) {
    contents.comments = deserializeAws_json1_1Comments(
      output.comments,
      context
    );
  }
  if (output.location !== undefined && output.location !== null) {
    contents.location = deserializeAws_json1_1Location(
      output.location,
      context
    );
  }
  if (output.repositoryName !== undefined && output.repositoryName !== null) {
    contents.repositoryName = output.repositoryName;
  }
  return contents;
};

const deserializeAws_json1_1CommentsForComparedCommitData = (
  output: any,
  context: __SerdeContext
): Array<CommentsForComparedCommit> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1CommentsForComparedCommit(entry, context)
  );
};

const deserializeAws_json1_1CommentsForPullRequest = (
  output: any,
  context: __SerdeContext
): CommentsForPullRequest => {
  let contents: any = {
    __type: "CommentsForPullRequest",
    afterBlobId: undefined,
    afterCommitId: undefined,
    beforeBlobId: undefined,
    beforeCommitId: undefined,
    comments: undefined,
    location: undefined,
    pullRequestId: undefined,
    repositoryName: undefined
  };
  if (output.afterBlobId !== undefined && output.afterBlobId !== null) {
    contents.afterBlobId = output.afterBlobId;
  }
  if (output.afterCommitId !== undefined && output.afterCommitId !== null) {
    contents.afterCommitId = output.afterCommitId;
  }
  if (output.beforeBlobId !== undefined && output.beforeBlobId !== null) {
    contents.beforeBlobId = output.beforeBlobId;
  }
  if (output.beforeCommitId !== undefined && output.beforeCommitId !== null) {
    contents.beforeCommitId = output.beforeCommitId;
  }
  if (output.comments !== undefined && output.comments !== null) {
    contents.comments = deserializeAws_json1_1Comments(
      output.comments,
      context
    );
  }
  if (output.location !== undefined && output.location !== null) {
    contents.location = deserializeAws_json1_1Location(
      output.location,
      context
    );
  }
  if (output.pullRequestId !== undefined && output.pullRequestId !== null) {
    contents.pullRequestId = output.pullRequestId;
  }
  if (output.repositoryName !== undefined && output.repositoryName !== null) {
    contents.repositoryName = output.repositoryName;
  }
  return contents;
};

const deserializeAws_json1_1CommentsForPullRequestData = (
  output: any,
  context: __SerdeContext
): Array<CommentsForPullRequest> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1CommentsForPullRequest(entry, context)
  );
};

const deserializeAws_json1_1Commit = (
  output: any,
  context: __SerdeContext
): Commit => {
  let contents: any = {
    __type: "Commit",
    additionalData: undefined,
    author: undefined,
    commitId: undefined,
    committer: undefined,
    message: undefined,
    parents: undefined,
    treeId: undefined
  };
  if (output.additionalData !== undefined && output.additionalData !== null) {
    contents.additionalData = output.additionalData;
  }
  if (output.author !== undefined && output.author !== null) {
    contents.author = deserializeAws_json1_1UserInfo(output.author, context);
  }
  if (output.commitId !== undefined && output.commitId !== null) {
    contents.commitId = output.commitId;
  }
  if (output.committer !== undefined && output.committer !== null) {
    contents.committer = deserializeAws_json1_1UserInfo(
      output.committer,
      context
    );
  }
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  if (output.parents !== undefined && output.parents !== null) {
    contents.parents = deserializeAws_json1_1ParentList(
      output.parents,
      context
    );
  }
  if (output.treeId !== undefined && output.treeId !== null) {
    contents.treeId = output.treeId;
  }
  return contents;
};

const deserializeAws_json1_1CommitDoesNotExistException = (
  output: any,
  context: __SerdeContext
): CommitDoesNotExistException => {
  let contents: any = {
    __type: "CommitDoesNotExistException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1CommitIdDoesNotExistException = (
  output: any,
  context: __SerdeContext
): CommitIdDoesNotExistException => {
  let contents: any = {
    __type: "CommitIdDoesNotExistException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1CommitIdRequiredException = (
  output: any,
  context: __SerdeContext
): CommitIdRequiredException => {
  let contents: any = {
    __type: "CommitIdRequiredException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1CommitIdsLimitExceededException = (
  output: any,
  context: __SerdeContext
): CommitIdsLimitExceededException => {
  let contents: any = {
    __type: "CommitIdsLimitExceededException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1CommitIdsListRequiredException = (
  output: any,
  context: __SerdeContext
): CommitIdsListRequiredException => {
  let contents: any = {
    __type: "CommitIdsListRequiredException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1CommitMessageLengthExceededException = (
  output: any,
  context: __SerdeContext
): CommitMessageLengthExceededException => {
  let contents: any = {
    __type: "CommitMessageLengthExceededException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1CommitObjectsList = (
  output: any,
  context: __SerdeContext
): Array<Commit> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1Commit(entry, context)
  );
};

const deserializeAws_json1_1CommitRequiredException = (
  output: any,
  context: __SerdeContext
): CommitRequiredException => {
  let contents: any = {
    __type: "CommitRequiredException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1ConcurrentReferenceUpdateException = (
  output: any,
  context: __SerdeContext
): ConcurrentReferenceUpdateException => {
  let contents: any = {
    __type: "ConcurrentReferenceUpdateException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1Conflict = (
  output: any,
  context: __SerdeContext
): Conflict => {
  let contents: any = {
    __type: "Conflict",
    conflictMetadata: undefined,
    mergeHunks: undefined
  };
  if (
    output.conflictMetadata !== undefined &&
    output.conflictMetadata !== null
  ) {
    contents.conflictMetadata = deserializeAws_json1_1ConflictMetadata(
      output.conflictMetadata,
      context
    );
  }
  if (output.mergeHunks !== undefined && output.mergeHunks !== null) {
    contents.mergeHunks = deserializeAws_json1_1MergeHunks(
      output.mergeHunks,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1ConflictMetadata = (
  output: any,
  context: __SerdeContext
): ConflictMetadata => {
  let contents: any = {
    __type: "ConflictMetadata",
    contentConflict: undefined,
    fileModeConflict: undefined,
    fileModes: undefined,
    filePath: undefined,
    fileSizes: undefined,
    isBinaryFile: undefined,
    mergeOperations: undefined,
    numberOfConflicts: undefined,
    objectTypeConflict: undefined,
    objectTypes: undefined
  };
  if (output.contentConflict !== undefined && output.contentConflict !== null) {
    contents.contentConflict = output.contentConflict;
  }
  if (
    output.fileModeConflict !== undefined &&
    output.fileModeConflict !== null
  ) {
    contents.fileModeConflict = output.fileModeConflict;
  }
  if (output.fileModes !== undefined && output.fileModes !== null) {
    contents.fileModes = deserializeAws_json1_1FileModes(
      output.fileModes,
      context
    );
  }
  if (output.filePath !== undefined && output.filePath !== null) {
    contents.filePath = output.filePath;
  }
  if (output.fileSizes !== undefined && output.fileSizes !== null) {
    contents.fileSizes = deserializeAws_json1_1FileSizes(
      output.fileSizes,
      context
    );
  }
  if (output.isBinaryFile !== undefined && output.isBinaryFile !== null) {
    contents.isBinaryFile = deserializeAws_json1_1IsBinaryFile(
      output.isBinaryFile,
      context
    );
  }
  if (output.mergeOperations !== undefined && output.mergeOperations !== null) {
    contents.mergeOperations = deserializeAws_json1_1MergeOperations(
      output.mergeOperations,
      context
    );
  }
  if (
    output.numberOfConflicts !== undefined &&
    output.numberOfConflicts !== null
  ) {
    contents.numberOfConflicts = output.numberOfConflicts;
  }
  if (
    output.objectTypeConflict !== undefined &&
    output.objectTypeConflict !== null
  ) {
    contents.objectTypeConflict = output.objectTypeConflict;
  }
  if (output.objectTypes !== undefined && output.objectTypes !== null) {
    contents.objectTypes = deserializeAws_json1_1ObjectTypes(
      output.objectTypes,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1ConflictMetadataList = (
  output: any,
  context: __SerdeContext
): Array<ConflictMetadata> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1ConflictMetadata(entry, context)
  );
};

const deserializeAws_json1_1Conflicts = (
  output: any,
  context: __SerdeContext
): Array<Conflict> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1Conflict(entry, context)
  );
};

const deserializeAws_json1_1CreateApprovalRuleTemplateOutput = (
  output: any,
  context: __SerdeContext
): CreateApprovalRuleTemplateOutput => {
  let contents: any = {
    __type: "CreateApprovalRuleTemplateOutput",
    approvalRuleTemplate: undefined
  };
  if (
    output.approvalRuleTemplate !== undefined &&
    output.approvalRuleTemplate !== null
  ) {
    contents.approvalRuleTemplate = deserializeAws_json1_1ApprovalRuleTemplate(
      output.approvalRuleTemplate,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1CreateCommitOutput = (
  output: any,
  context: __SerdeContext
): CreateCommitOutput => {
  let contents: any = {
    __type: "CreateCommitOutput",
    commitId: undefined,
    filesAdded: undefined,
    filesDeleted: undefined,
    filesUpdated: undefined,
    treeId: undefined
  };
  if (output.commitId !== undefined && output.commitId !== null) {
    contents.commitId = output.commitId;
  }
  if (output.filesAdded !== undefined && output.filesAdded !== null) {
    contents.filesAdded = deserializeAws_json1_1FilesMetadata(
      output.filesAdded,
      context
    );
  }
  if (output.filesDeleted !== undefined && output.filesDeleted !== null) {
    contents.filesDeleted = deserializeAws_json1_1FilesMetadata(
      output.filesDeleted,
      context
    );
  }
  if (output.filesUpdated !== undefined && output.filesUpdated !== null) {
    contents.filesUpdated = deserializeAws_json1_1FilesMetadata(
      output.filesUpdated,
      context
    );
  }
  if (output.treeId !== undefined && output.treeId !== null) {
    contents.treeId = output.treeId;
  }
  return contents;
};

const deserializeAws_json1_1CreatePullRequestApprovalRuleOutput = (
  output: any,
  context: __SerdeContext
): CreatePullRequestApprovalRuleOutput => {
  let contents: any = {
    __type: "CreatePullRequestApprovalRuleOutput",
    approvalRule: undefined
  };
  if (output.approvalRule !== undefined && output.approvalRule !== null) {
    contents.approvalRule = deserializeAws_json1_1ApprovalRule(
      output.approvalRule,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1CreatePullRequestOutput = (
  output: any,
  context: __SerdeContext
): CreatePullRequestOutput => {
  let contents: any = {
    __type: "CreatePullRequestOutput",
    pullRequest: undefined
  };
  if (output.pullRequest !== undefined && output.pullRequest !== null) {
    contents.pullRequest = deserializeAws_json1_1PullRequest(
      output.pullRequest,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1CreateRepositoryOutput = (
  output: any,
  context: __SerdeContext
): CreateRepositoryOutput => {
  let contents: any = {
    __type: "CreateRepositoryOutput",
    repositoryMetadata: undefined
  };
  if (
    output.repositoryMetadata !== undefined &&
    output.repositoryMetadata !== null
  ) {
    contents.repositoryMetadata = deserializeAws_json1_1RepositoryMetadata(
      output.repositoryMetadata,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1CreateUnreferencedMergeCommitOutput = (
  output: any,
  context: __SerdeContext
): CreateUnreferencedMergeCommitOutput => {
  let contents: any = {
    __type: "CreateUnreferencedMergeCommitOutput",
    commitId: undefined,
    treeId: undefined
  };
  if (output.commitId !== undefined && output.commitId !== null) {
    contents.commitId = output.commitId;
  }
  if (output.treeId !== undefined && output.treeId !== null) {
    contents.treeId = output.treeId;
  }
  return contents;
};

const deserializeAws_json1_1DefaultBranchCannotBeDeletedException = (
  output: any,
  context: __SerdeContext
): DefaultBranchCannotBeDeletedException => {
  let contents: any = {
    __type: "DefaultBranchCannotBeDeletedException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1DeleteApprovalRuleTemplateOutput = (
  output: any,
  context: __SerdeContext
): DeleteApprovalRuleTemplateOutput => {
  let contents: any = {
    __type: "DeleteApprovalRuleTemplateOutput",
    approvalRuleTemplateId: undefined
  };
  if (
    output.approvalRuleTemplateId !== undefined &&
    output.approvalRuleTemplateId !== null
  ) {
    contents.approvalRuleTemplateId = output.approvalRuleTemplateId;
  }
  return contents;
};

const deserializeAws_json1_1DeleteBranchOutput = (
  output: any,
  context: __SerdeContext
): DeleteBranchOutput => {
  let contents: any = {
    __type: "DeleteBranchOutput",
    deletedBranch: undefined
  };
  if (output.deletedBranch !== undefined && output.deletedBranch !== null) {
    contents.deletedBranch = deserializeAws_json1_1BranchInfo(
      output.deletedBranch,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DeleteCommentContentOutput = (
  output: any,
  context: __SerdeContext
): DeleteCommentContentOutput => {
  let contents: any = {
    __type: "DeleteCommentContentOutput",
    comment: undefined
  };
  if (output.comment !== undefined && output.comment !== null) {
    contents.comment = deserializeAws_json1_1Comment(output.comment, context);
  }
  return contents;
};

const deserializeAws_json1_1DeleteFileOutput = (
  output: any,
  context: __SerdeContext
): DeleteFileOutput => {
  let contents: any = {
    __type: "DeleteFileOutput",
    blobId: undefined,
    commitId: undefined,
    filePath: undefined,
    treeId: undefined
  };
  if (output.blobId !== undefined && output.blobId !== null) {
    contents.blobId = output.blobId;
  }
  if (output.commitId !== undefined && output.commitId !== null) {
    contents.commitId = output.commitId;
  }
  if (output.filePath !== undefined && output.filePath !== null) {
    contents.filePath = output.filePath;
  }
  if (output.treeId !== undefined && output.treeId !== null) {
    contents.treeId = output.treeId;
  }
  return contents;
};

const deserializeAws_json1_1DeletePullRequestApprovalRuleOutput = (
  output: any,
  context: __SerdeContext
): DeletePullRequestApprovalRuleOutput => {
  let contents: any = {
    __type: "DeletePullRequestApprovalRuleOutput",
    approvalRuleId: undefined
  };
  if (output.approvalRuleId !== undefined && output.approvalRuleId !== null) {
    contents.approvalRuleId = output.approvalRuleId;
  }
  return contents;
};

const deserializeAws_json1_1DeleteRepositoryOutput = (
  output: any,
  context: __SerdeContext
): DeleteRepositoryOutput => {
  let contents: any = {
    __type: "DeleteRepositoryOutput",
    repositoryId: undefined
  };
  if (output.repositoryId !== undefined && output.repositoryId !== null) {
    contents.repositoryId = output.repositoryId;
  }
  return contents;
};

const deserializeAws_json1_1DescribeMergeConflictsOutput = (
  output: any,
  context: __SerdeContext
): DescribeMergeConflictsOutput => {
  let contents: any = {
    __type: "DescribeMergeConflictsOutput",
    baseCommitId: undefined,
    conflictMetadata: undefined,
    destinationCommitId: undefined,
    mergeHunks: undefined,
    nextToken: undefined,
    sourceCommitId: undefined
  };
  if (output.baseCommitId !== undefined && output.baseCommitId !== null) {
    contents.baseCommitId = output.baseCommitId;
  }
  if (
    output.conflictMetadata !== undefined &&
    output.conflictMetadata !== null
  ) {
    contents.conflictMetadata = deserializeAws_json1_1ConflictMetadata(
      output.conflictMetadata,
      context
    );
  }
  if (
    output.destinationCommitId !== undefined &&
    output.destinationCommitId !== null
  ) {
    contents.destinationCommitId = output.destinationCommitId;
  }
  if (output.mergeHunks !== undefined && output.mergeHunks !== null) {
    contents.mergeHunks = deserializeAws_json1_1MergeHunks(
      output.mergeHunks,
      context
    );
  }
  if (output.nextToken !== undefined && output.nextToken !== null) {
    contents.nextToken = output.nextToken;
  }
  if (output.sourceCommitId !== undefined && output.sourceCommitId !== null) {
    contents.sourceCommitId = output.sourceCommitId;
  }
  return contents;
};

const deserializeAws_json1_1DescribePullRequestEventsOutput = (
  output: any,
  context: __SerdeContext
): DescribePullRequestEventsOutput => {
  let contents: any = {
    __type: "DescribePullRequestEventsOutput",
    nextToken: undefined,
    pullRequestEvents: undefined
  };
  if (output.nextToken !== undefined && output.nextToken !== null) {
    contents.nextToken = output.nextToken;
  }
  if (
    output.pullRequestEvents !== undefined &&
    output.pullRequestEvents !== null
  ) {
    contents.pullRequestEvents = deserializeAws_json1_1PullRequestEventList(
      output.pullRequestEvents,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1Difference = (
  output: any,
  context: __SerdeContext
): Difference => {
  let contents: any = {
    __type: "Difference",
    afterBlob: undefined,
    beforeBlob: undefined,
    changeType: undefined
  };
  if (output.afterBlob !== undefined && output.afterBlob !== null) {
    contents.afterBlob = deserializeAws_json1_1BlobMetadata(
      output.afterBlob,
      context
    );
  }
  if (output.beforeBlob !== undefined && output.beforeBlob !== null) {
    contents.beforeBlob = deserializeAws_json1_1BlobMetadata(
      output.beforeBlob,
      context
    );
  }
  if (output.changeType !== undefined && output.changeType !== null) {
    contents.changeType = output.changeType;
  }
  return contents;
};

const deserializeAws_json1_1DifferenceList = (
  output: any,
  context: __SerdeContext
): Array<Difference> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1Difference(entry, context)
  );
};

const deserializeAws_json1_1DirectoryNameConflictsWithFileNameException = (
  output: any,
  context: __SerdeContext
): DirectoryNameConflictsWithFileNameException => {
  let contents: any = {
    __type: "DirectoryNameConflictsWithFileNameException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1EncryptionIntegrityChecksFailedException = (
  output: any,
  context: __SerdeContext
): EncryptionIntegrityChecksFailedException => {
  let contents: any = {
    __type: "EncryptionIntegrityChecksFailedException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1EncryptionKeyAccessDeniedException = (
  output: any,
  context: __SerdeContext
): EncryptionKeyAccessDeniedException => {
  let contents: any = {
    __type: "EncryptionKeyAccessDeniedException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1EncryptionKeyDisabledException = (
  output: any,
  context: __SerdeContext
): EncryptionKeyDisabledException => {
  let contents: any = {
    __type: "EncryptionKeyDisabledException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1EncryptionKeyNotFoundException = (
  output: any,
  context: __SerdeContext
): EncryptionKeyNotFoundException => {
  let contents: any = {
    __type: "EncryptionKeyNotFoundException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1EncryptionKeyUnavailableException = (
  output: any,
  context: __SerdeContext
): EncryptionKeyUnavailableException => {
  let contents: any = {
    __type: "EncryptionKeyUnavailableException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1EvaluatePullRequestApprovalRulesOutput = (
  output: any,
  context: __SerdeContext
): EvaluatePullRequestApprovalRulesOutput => {
  let contents: any = {
    __type: "EvaluatePullRequestApprovalRulesOutput",
    evaluation: undefined
  };
  if (output.evaluation !== undefined && output.evaluation !== null) {
    contents.evaluation = deserializeAws_json1_1Evaluation(
      output.evaluation,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1Evaluation = (
  output: any,
  context: __SerdeContext
): Evaluation => {
  let contents: any = {
    __type: "Evaluation",
    approvalRulesNotSatisfied: undefined,
    approvalRulesSatisfied: undefined,
    approved: undefined,
    overridden: undefined
  };
  if (
    output.approvalRulesNotSatisfied !== undefined &&
    output.approvalRulesNotSatisfied !== null
  ) {
    contents.approvalRulesNotSatisfied = deserializeAws_json1_1ApprovalRulesNotSatisfiedList(
      output.approvalRulesNotSatisfied,
      context
    );
  }
  if (
    output.approvalRulesSatisfied !== undefined &&
    output.approvalRulesSatisfied !== null
  ) {
    contents.approvalRulesSatisfied = deserializeAws_json1_1ApprovalRulesSatisfiedList(
      output.approvalRulesSatisfied,
      context
    );
  }
  if (output.approved !== undefined && output.approved !== null) {
    contents.approved = output.approved;
  }
  if (output.overridden !== undefined && output.overridden !== null) {
    contents.overridden = output.overridden;
  }
  return contents;
};

const deserializeAws_json1_1File = (
  output: any,
  context: __SerdeContext
): File => {
  let contents: any = {
    __type: "File",
    absolutePath: undefined,
    blobId: undefined,
    fileMode: undefined,
    relativePath: undefined
  };
  if (output.absolutePath !== undefined && output.absolutePath !== null) {
    contents.absolutePath = output.absolutePath;
  }
  if (output.blobId !== undefined && output.blobId !== null) {
    contents.blobId = output.blobId;
  }
  if (output.fileMode !== undefined && output.fileMode !== null) {
    contents.fileMode = output.fileMode;
  }
  if (output.relativePath !== undefined && output.relativePath !== null) {
    contents.relativePath = output.relativePath;
  }
  return contents;
};

const deserializeAws_json1_1FileContentAndSourceFileSpecifiedException = (
  output: any,
  context: __SerdeContext
): FileContentAndSourceFileSpecifiedException => {
  let contents: any = {
    __type: "FileContentAndSourceFileSpecifiedException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1FileContentRequiredException = (
  output: any,
  context: __SerdeContext
): FileContentRequiredException => {
  let contents: any = {
    __type: "FileContentRequiredException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1FileContentSizeLimitExceededException = (
  output: any,
  context: __SerdeContext
): FileContentSizeLimitExceededException => {
  let contents: any = {
    __type: "FileContentSizeLimitExceededException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1FileDoesNotExistException = (
  output: any,
  context: __SerdeContext
): FileDoesNotExistException => {
  let contents: any = {
    __type: "FileDoesNotExistException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1FileEntryRequiredException = (
  output: any,
  context: __SerdeContext
): FileEntryRequiredException => {
  let contents: any = {
    __type: "FileEntryRequiredException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1FileList = (
  output: any,
  context: __SerdeContext
): Array<File> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1File(entry, context)
  );
};

const deserializeAws_json1_1FileMetadata = (
  output: any,
  context: __SerdeContext
): FileMetadata => {
  let contents: any = {
    __type: "FileMetadata",
    absolutePath: undefined,
    blobId: undefined,
    fileMode: undefined
  };
  if (output.absolutePath !== undefined && output.absolutePath !== null) {
    contents.absolutePath = output.absolutePath;
  }
  if (output.blobId !== undefined && output.blobId !== null) {
    contents.blobId = output.blobId;
  }
  if (output.fileMode !== undefined && output.fileMode !== null) {
    contents.fileMode = output.fileMode;
  }
  return contents;
};

const deserializeAws_json1_1FileModeRequiredException = (
  output: any,
  context: __SerdeContext
): FileModeRequiredException => {
  let contents: any = {
    __type: "FileModeRequiredException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1FileModes = (
  output: any,
  context: __SerdeContext
): FileModes => {
  let contents: any = {
    __type: "FileModes",
    base: undefined,
    destination: undefined,
    source: undefined
  };
  if (output.base !== undefined && output.base !== null) {
    contents.base = output.base;
  }
  if (output.destination !== undefined && output.destination !== null) {
    contents.destination = output.destination;
  }
  if (output.source !== undefined && output.source !== null) {
    contents.source = output.source;
  }
  return contents;
};

const deserializeAws_json1_1FileNameConflictsWithDirectoryNameException = (
  output: any,
  context: __SerdeContext
): FileNameConflictsWithDirectoryNameException => {
  let contents: any = {
    __type: "FileNameConflictsWithDirectoryNameException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1FilePathConflictsWithSubmodulePathException = (
  output: any,
  context: __SerdeContext
): FilePathConflictsWithSubmodulePathException => {
  let contents: any = {
    __type: "FilePathConflictsWithSubmodulePathException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1FileSizes = (
  output: any,
  context: __SerdeContext
): FileSizes => {
  let contents: any = {
    __type: "FileSizes",
    base: undefined,
    destination: undefined,
    source: undefined
  };
  if (output.base !== undefined && output.base !== null) {
    contents.base = output.base;
  }
  if (output.destination !== undefined && output.destination !== null) {
    contents.destination = output.destination;
  }
  if (output.source !== undefined && output.source !== null) {
    contents.source = output.source;
  }
  return contents;
};

const deserializeAws_json1_1FileTooLargeException = (
  output: any,
  context: __SerdeContext
): FileTooLargeException => {
  let contents: any = {
    __type: "FileTooLargeException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1FilesMetadata = (
  output: any,
  context: __SerdeContext
): Array<FileMetadata> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1FileMetadata(entry, context)
  );
};

const deserializeAws_json1_1Folder = (
  output: any,
  context: __SerdeContext
): Folder => {
  let contents: any = {
    __type: "Folder",
    absolutePath: undefined,
    relativePath: undefined,
    treeId: undefined
  };
  if (output.absolutePath !== undefined && output.absolutePath !== null) {
    contents.absolutePath = output.absolutePath;
  }
  if (output.relativePath !== undefined && output.relativePath !== null) {
    contents.relativePath = output.relativePath;
  }
  if (output.treeId !== undefined && output.treeId !== null) {
    contents.treeId = output.treeId;
  }
  return contents;
};

const deserializeAws_json1_1FolderContentSizeLimitExceededException = (
  output: any,
  context: __SerdeContext
): FolderContentSizeLimitExceededException => {
  let contents: any = {
    __type: "FolderContentSizeLimitExceededException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1FolderDoesNotExistException = (
  output: any,
  context: __SerdeContext
): FolderDoesNotExistException => {
  let contents: any = {
    __type: "FolderDoesNotExistException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1FolderList = (
  output: any,
  context: __SerdeContext
): Array<Folder> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1Folder(entry, context)
  );
};

const deserializeAws_json1_1GetApprovalRuleTemplateOutput = (
  output: any,
  context: __SerdeContext
): GetApprovalRuleTemplateOutput => {
  let contents: any = {
    __type: "GetApprovalRuleTemplateOutput",
    approvalRuleTemplate: undefined
  };
  if (
    output.approvalRuleTemplate !== undefined &&
    output.approvalRuleTemplate !== null
  ) {
    contents.approvalRuleTemplate = deserializeAws_json1_1ApprovalRuleTemplate(
      output.approvalRuleTemplate,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1GetBlobOutput = (
  output: any,
  context: __SerdeContext
): GetBlobOutput => {
  let contents: any = {
    __type: "GetBlobOutput",
    content: undefined
  };
  if (output.content !== undefined && output.content !== null) {
    contents.content = context.base64Decoder(output.content);
  }
  return contents;
};

const deserializeAws_json1_1GetBranchOutput = (
  output: any,
  context: __SerdeContext
): GetBranchOutput => {
  let contents: any = {
    __type: "GetBranchOutput",
    branch: undefined
  };
  if (output.branch !== undefined && output.branch !== null) {
    contents.branch = deserializeAws_json1_1BranchInfo(output.branch, context);
  }
  return contents;
};

const deserializeAws_json1_1GetCommentOutput = (
  output: any,
  context: __SerdeContext
): GetCommentOutput => {
  let contents: any = {
    __type: "GetCommentOutput",
    comment: undefined
  };
  if (output.comment !== undefined && output.comment !== null) {
    contents.comment = deserializeAws_json1_1Comment(output.comment, context);
  }
  return contents;
};

const deserializeAws_json1_1GetCommentsForComparedCommitOutput = (
  output: any,
  context: __SerdeContext
): GetCommentsForComparedCommitOutput => {
  let contents: any = {
    __type: "GetCommentsForComparedCommitOutput",
    commentsForComparedCommitData: undefined,
    nextToken: undefined
  };
  if (
    output.commentsForComparedCommitData !== undefined &&
    output.commentsForComparedCommitData !== null
  ) {
    contents.commentsForComparedCommitData = deserializeAws_json1_1CommentsForComparedCommitData(
      output.commentsForComparedCommitData,
      context
    );
  }
  if (output.nextToken !== undefined && output.nextToken !== null) {
    contents.nextToken = output.nextToken;
  }
  return contents;
};

const deserializeAws_json1_1GetCommentsForPullRequestOutput = (
  output: any,
  context: __SerdeContext
): GetCommentsForPullRequestOutput => {
  let contents: any = {
    __type: "GetCommentsForPullRequestOutput",
    commentsForPullRequestData: undefined,
    nextToken: undefined
  };
  if (
    output.commentsForPullRequestData !== undefined &&
    output.commentsForPullRequestData !== null
  ) {
    contents.commentsForPullRequestData = deserializeAws_json1_1CommentsForPullRequestData(
      output.commentsForPullRequestData,
      context
    );
  }
  if (output.nextToken !== undefined && output.nextToken !== null) {
    contents.nextToken = output.nextToken;
  }
  return contents;
};

const deserializeAws_json1_1GetCommitOutput = (
  output: any,
  context: __SerdeContext
): GetCommitOutput => {
  let contents: any = {
    __type: "GetCommitOutput",
    commit: undefined
  };
  if (output.commit !== undefined && output.commit !== null) {
    contents.commit = deserializeAws_json1_1Commit(output.commit, context);
  }
  return contents;
};

const deserializeAws_json1_1GetDifferencesOutput = (
  output: any,
  context: __SerdeContext
): GetDifferencesOutput => {
  let contents: any = {
    __type: "GetDifferencesOutput",
    NextToken: undefined,
    differences: undefined
  };
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  if (output.differences !== undefined && output.differences !== null) {
    contents.differences = deserializeAws_json1_1DifferenceList(
      output.differences,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1GetFileOutput = (
  output: any,
  context: __SerdeContext
): GetFileOutput => {
  let contents: any = {
    __type: "GetFileOutput",
    blobId: undefined,
    commitId: undefined,
    fileContent: undefined,
    fileMode: undefined,
    filePath: undefined,
    fileSize: undefined
  };
  if (output.blobId !== undefined && output.blobId !== null) {
    contents.blobId = output.blobId;
  }
  if (output.commitId !== undefined && output.commitId !== null) {
    contents.commitId = output.commitId;
  }
  if (output.fileContent !== undefined && output.fileContent !== null) {
    contents.fileContent = context.base64Decoder(output.fileContent);
  }
  if (output.fileMode !== undefined && output.fileMode !== null) {
    contents.fileMode = output.fileMode;
  }
  if (output.filePath !== undefined && output.filePath !== null) {
    contents.filePath = output.filePath;
  }
  if (output.fileSize !== undefined && output.fileSize !== null) {
    contents.fileSize = output.fileSize;
  }
  return contents;
};

const deserializeAws_json1_1GetFolderOutput = (
  output: any,
  context: __SerdeContext
): GetFolderOutput => {
  let contents: any = {
    __type: "GetFolderOutput",
    commitId: undefined,
    files: undefined,
    folderPath: undefined,
    subFolders: undefined,
    subModules: undefined,
    symbolicLinks: undefined,
    treeId: undefined
  };
  if (output.commitId !== undefined && output.commitId !== null) {
    contents.commitId = output.commitId;
  }
  if (output.files !== undefined && output.files !== null) {
    contents.files = deserializeAws_json1_1FileList(output.files, context);
  }
  if (output.folderPath !== undefined && output.folderPath !== null) {
    contents.folderPath = output.folderPath;
  }
  if (output.subFolders !== undefined && output.subFolders !== null) {
    contents.subFolders = deserializeAws_json1_1FolderList(
      output.subFolders,
      context
    );
  }
  if (output.subModules !== undefined && output.subModules !== null) {
    contents.subModules = deserializeAws_json1_1SubModuleList(
      output.subModules,
      context
    );
  }
  if (output.symbolicLinks !== undefined && output.symbolicLinks !== null) {
    contents.symbolicLinks = deserializeAws_json1_1SymbolicLinkList(
      output.symbolicLinks,
      context
    );
  }
  if (output.treeId !== undefined && output.treeId !== null) {
    contents.treeId = output.treeId;
  }
  return contents;
};

const deserializeAws_json1_1GetMergeCommitOutput = (
  output: any,
  context: __SerdeContext
): GetMergeCommitOutput => {
  let contents: any = {
    __type: "GetMergeCommitOutput",
    baseCommitId: undefined,
    destinationCommitId: undefined,
    mergedCommitId: undefined,
    sourceCommitId: undefined
  };
  if (output.baseCommitId !== undefined && output.baseCommitId !== null) {
    contents.baseCommitId = output.baseCommitId;
  }
  if (
    output.destinationCommitId !== undefined &&
    output.destinationCommitId !== null
  ) {
    contents.destinationCommitId = output.destinationCommitId;
  }
  if (output.mergedCommitId !== undefined && output.mergedCommitId !== null) {
    contents.mergedCommitId = output.mergedCommitId;
  }
  if (output.sourceCommitId !== undefined && output.sourceCommitId !== null) {
    contents.sourceCommitId = output.sourceCommitId;
  }
  return contents;
};

const deserializeAws_json1_1GetMergeConflictsOutput = (
  output: any,
  context: __SerdeContext
): GetMergeConflictsOutput => {
  let contents: any = {
    __type: "GetMergeConflictsOutput",
    baseCommitId: undefined,
    conflictMetadataList: undefined,
    destinationCommitId: undefined,
    mergeable: undefined,
    nextToken: undefined,
    sourceCommitId: undefined
  };
  if (output.baseCommitId !== undefined && output.baseCommitId !== null) {
    contents.baseCommitId = output.baseCommitId;
  }
  if (
    output.conflictMetadataList !== undefined &&
    output.conflictMetadataList !== null
  ) {
    contents.conflictMetadataList = deserializeAws_json1_1ConflictMetadataList(
      output.conflictMetadataList,
      context
    );
  }
  if (
    output.destinationCommitId !== undefined &&
    output.destinationCommitId !== null
  ) {
    contents.destinationCommitId = output.destinationCommitId;
  }
  if (output.mergeable !== undefined && output.mergeable !== null) {
    contents.mergeable = output.mergeable;
  }
  if (output.nextToken !== undefined && output.nextToken !== null) {
    contents.nextToken = output.nextToken;
  }
  if (output.sourceCommitId !== undefined && output.sourceCommitId !== null) {
    contents.sourceCommitId = output.sourceCommitId;
  }
  return contents;
};

const deserializeAws_json1_1GetMergeOptionsOutput = (
  output: any,
  context: __SerdeContext
): GetMergeOptionsOutput => {
  let contents: any = {
    __type: "GetMergeOptionsOutput",
    baseCommitId: undefined,
    destinationCommitId: undefined,
    mergeOptions: undefined,
    sourceCommitId: undefined
  };
  if (output.baseCommitId !== undefined && output.baseCommitId !== null) {
    contents.baseCommitId = output.baseCommitId;
  }
  if (
    output.destinationCommitId !== undefined &&
    output.destinationCommitId !== null
  ) {
    contents.destinationCommitId = output.destinationCommitId;
  }
  if (output.mergeOptions !== undefined && output.mergeOptions !== null) {
    contents.mergeOptions = deserializeAws_json1_1MergeOptions(
      output.mergeOptions,
      context
    );
  }
  if (output.sourceCommitId !== undefined && output.sourceCommitId !== null) {
    contents.sourceCommitId = output.sourceCommitId;
  }
  return contents;
};

const deserializeAws_json1_1GetPullRequestApprovalStatesOutput = (
  output: any,
  context: __SerdeContext
): GetPullRequestApprovalStatesOutput => {
  let contents: any = {
    __type: "GetPullRequestApprovalStatesOutput",
    approvals: undefined
  };
  if (output.approvals !== undefined && output.approvals !== null) {
    contents.approvals = deserializeAws_json1_1ApprovalList(
      output.approvals,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1GetPullRequestOutput = (
  output: any,
  context: __SerdeContext
): GetPullRequestOutput => {
  let contents: any = {
    __type: "GetPullRequestOutput",
    pullRequest: undefined
  };
  if (output.pullRequest !== undefined && output.pullRequest !== null) {
    contents.pullRequest = deserializeAws_json1_1PullRequest(
      output.pullRequest,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1GetPullRequestOverrideStateOutput = (
  output: any,
  context: __SerdeContext
): GetPullRequestOverrideStateOutput => {
  let contents: any = {
    __type: "GetPullRequestOverrideStateOutput",
    overridden: undefined,
    overrider: undefined
  };
  if (output.overridden !== undefined && output.overridden !== null) {
    contents.overridden = output.overridden;
  }
  if (output.overrider !== undefined && output.overrider !== null) {
    contents.overrider = output.overrider;
  }
  return contents;
};

const deserializeAws_json1_1GetRepositoryOutput = (
  output: any,
  context: __SerdeContext
): GetRepositoryOutput => {
  let contents: any = {
    __type: "GetRepositoryOutput",
    repositoryMetadata: undefined
  };
  if (
    output.repositoryMetadata !== undefined &&
    output.repositoryMetadata !== null
  ) {
    contents.repositoryMetadata = deserializeAws_json1_1RepositoryMetadata(
      output.repositoryMetadata,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1GetRepositoryTriggersOutput = (
  output: any,
  context: __SerdeContext
): GetRepositoryTriggersOutput => {
  let contents: any = {
    __type: "GetRepositoryTriggersOutput",
    configurationId: undefined,
    triggers: undefined
  };
  if (output.configurationId !== undefined && output.configurationId !== null) {
    contents.configurationId = output.configurationId;
  }
  if (output.triggers !== undefined && output.triggers !== null) {
    contents.triggers = deserializeAws_json1_1RepositoryTriggersList(
      output.triggers,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1IdempotencyParameterMismatchException = (
  output: any,
  context: __SerdeContext
): IdempotencyParameterMismatchException => {
  let contents: any = {
    __type: "IdempotencyParameterMismatchException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidActorArnException = (
  output: any,
  context: __SerdeContext
): InvalidActorArnException => {
  let contents: any = {
    __type: "InvalidActorArnException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidApprovalRuleContentException = (
  output: any,
  context: __SerdeContext
): InvalidApprovalRuleContentException => {
  let contents: any = {
    __type: "InvalidApprovalRuleContentException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidApprovalRuleNameException = (
  output: any,
  context: __SerdeContext
): InvalidApprovalRuleNameException => {
  let contents: any = {
    __type: "InvalidApprovalRuleNameException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidApprovalRuleTemplateContentException = (
  output: any,
  context: __SerdeContext
): InvalidApprovalRuleTemplateContentException => {
  let contents: any = {
    __type: "InvalidApprovalRuleTemplateContentException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidApprovalRuleTemplateDescriptionException = (
  output: any,
  context: __SerdeContext
): InvalidApprovalRuleTemplateDescriptionException => {
  let contents: any = {
    __type: "InvalidApprovalRuleTemplateDescriptionException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidApprovalRuleTemplateNameException = (
  output: any,
  context: __SerdeContext
): InvalidApprovalRuleTemplateNameException => {
  let contents: any = {
    __type: "InvalidApprovalRuleTemplateNameException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidApprovalStateException = (
  output: any,
  context: __SerdeContext
): InvalidApprovalStateException => {
  let contents: any = {
    __type: "InvalidApprovalStateException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidAuthorArnException = (
  output: any,
  context: __SerdeContext
): InvalidAuthorArnException => {
  let contents: any = {
    __type: "InvalidAuthorArnException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidBlobIdException = (
  output: any,
  context: __SerdeContext
): InvalidBlobIdException => {
  let contents: any = {
    __type: "InvalidBlobIdException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidBranchNameException = (
  output: any,
  context: __SerdeContext
): InvalidBranchNameException => {
  let contents: any = {
    __type: "InvalidBranchNameException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidClientRequestTokenException = (
  output: any,
  context: __SerdeContext
): InvalidClientRequestTokenException => {
  let contents: any = {
    __type: "InvalidClientRequestTokenException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidCommentIdException = (
  output: any,
  context: __SerdeContext
): InvalidCommentIdException => {
  let contents: any = {
    __type: "InvalidCommentIdException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidCommitException = (
  output: any,
  context: __SerdeContext
): InvalidCommitException => {
  let contents: any = {
    __type: "InvalidCommitException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidCommitIdException = (
  output: any,
  context: __SerdeContext
): InvalidCommitIdException => {
  let contents: any = {
    __type: "InvalidCommitIdException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidConflictDetailLevelException = (
  output: any,
  context: __SerdeContext
): InvalidConflictDetailLevelException => {
  let contents: any = {
    __type: "InvalidConflictDetailLevelException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidConflictResolutionException = (
  output: any,
  context: __SerdeContext
): InvalidConflictResolutionException => {
  let contents: any = {
    __type: "InvalidConflictResolutionException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidConflictResolutionStrategyException = (
  output: any,
  context: __SerdeContext
): InvalidConflictResolutionStrategyException => {
  let contents: any = {
    __type: "InvalidConflictResolutionStrategyException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidContinuationTokenException = (
  output: any,
  context: __SerdeContext
): InvalidContinuationTokenException => {
  let contents: any = {
    __type: "InvalidContinuationTokenException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidDeletionParameterException = (
  output: any,
  context: __SerdeContext
): InvalidDeletionParameterException => {
  let contents: any = {
    __type: "InvalidDeletionParameterException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidDescriptionException = (
  output: any,
  context: __SerdeContext
): InvalidDescriptionException => {
  let contents: any = {
    __type: "InvalidDescriptionException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidDestinationCommitSpecifierException = (
  output: any,
  context: __SerdeContext
): InvalidDestinationCommitSpecifierException => {
  let contents: any = {
    __type: "InvalidDestinationCommitSpecifierException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidEmailException = (
  output: any,
  context: __SerdeContext
): InvalidEmailException => {
  let contents: any = {
    __type: "InvalidEmailException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidFileLocationException = (
  output: any,
  context: __SerdeContext
): InvalidFileLocationException => {
  let contents: any = {
    __type: "InvalidFileLocationException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidFileModeException = (
  output: any,
  context: __SerdeContext
): InvalidFileModeException => {
  let contents: any = {
    __type: "InvalidFileModeException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidFilePositionException = (
  output: any,
  context: __SerdeContext
): InvalidFilePositionException => {
  let contents: any = {
    __type: "InvalidFilePositionException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidMaxConflictFilesException = (
  output: any,
  context: __SerdeContext
): InvalidMaxConflictFilesException => {
  let contents: any = {
    __type: "InvalidMaxConflictFilesException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidMaxMergeHunksException = (
  output: any,
  context: __SerdeContext
): InvalidMaxMergeHunksException => {
  let contents: any = {
    __type: "InvalidMaxMergeHunksException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidMaxResultsException = (
  output: any,
  context: __SerdeContext
): InvalidMaxResultsException => {
  let contents: any = {
    __type: "InvalidMaxResultsException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidMergeOptionException = (
  output: any,
  context: __SerdeContext
): InvalidMergeOptionException => {
  let contents: any = {
    __type: "InvalidMergeOptionException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidOrderException = (
  output: any,
  context: __SerdeContext
): InvalidOrderException => {
  let contents: any = {
    __type: "InvalidOrderException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidOverrideStatusException = (
  output: any,
  context: __SerdeContext
): InvalidOverrideStatusException => {
  let contents: any = {
    __type: "InvalidOverrideStatusException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidParentCommitIdException = (
  output: any,
  context: __SerdeContext
): InvalidParentCommitIdException => {
  let contents: any = {
    __type: "InvalidParentCommitIdException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidPathException = (
  output: any,
  context: __SerdeContext
): InvalidPathException => {
  let contents: any = {
    __type: "InvalidPathException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidPullRequestEventTypeException = (
  output: any,
  context: __SerdeContext
): InvalidPullRequestEventTypeException => {
  let contents: any = {
    __type: "InvalidPullRequestEventTypeException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidPullRequestIdException = (
  output: any,
  context: __SerdeContext
): InvalidPullRequestIdException => {
  let contents: any = {
    __type: "InvalidPullRequestIdException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidPullRequestStatusException = (
  output: any,
  context: __SerdeContext
): InvalidPullRequestStatusException => {
  let contents: any = {
    __type: "InvalidPullRequestStatusException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidPullRequestStatusUpdateException = (
  output: any,
  context: __SerdeContext
): InvalidPullRequestStatusUpdateException => {
  let contents: any = {
    __type: "InvalidPullRequestStatusUpdateException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidReferenceNameException = (
  output: any,
  context: __SerdeContext
): InvalidReferenceNameException => {
  let contents: any = {
    __type: "InvalidReferenceNameException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidRelativeFileVersionEnumException = (
  output: any,
  context: __SerdeContext
): InvalidRelativeFileVersionEnumException => {
  let contents: any = {
    __type: "InvalidRelativeFileVersionEnumException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidReplacementContentException = (
  output: any,
  context: __SerdeContext
): InvalidReplacementContentException => {
  let contents: any = {
    __type: "InvalidReplacementContentException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidReplacementTypeException = (
  output: any,
  context: __SerdeContext
): InvalidReplacementTypeException => {
  let contents: any = {
    __type: "InvalidReplacementTypeException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidRepositoryDescriptionException = (
  output: any,
  context: __SerdeContext
): InvalidRepositoryDescriptionException => {
  let contents: any = {
    __type: "InvalidRepositoryDescriptionException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidRepositoryNameException = (
  output: any,
  context: __SerdeContext
): InvalidRepositoryNameException => {
  let contents: any = {
    __type: "InvalidRepositoryNameException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidRepositoryTriggerBranchNameException = (
  output: any,
  context: __SerdeContext
): InvalidRepositoryTriggerBranchNameException => {
  let contents: any = {
    __type: "InvalidRepositoryTriggerBranchNameException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidRepositoryTriggerCustomDataException = (
  output: any,
  context: __SerdeContext
): InvalidRepositoryTriggerCustomDataException => {
  let contents: any = {
    __type: "InvalidRepositoryTriggerCustomDataException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidRepositoryTriggerDestinationArnException = (
  output: any,
  context: __SerdeContext
): InvalidRepositoryTriggerDestinationArnException => {
  let contents: any = {
    __type: "InvalidRepositoryTriggerDestinationArnException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidRepositoryTriggerEventsException = (
  output: any,
  context: __SerdeContext
): InvalidRepositoryTriggerEventsException => {
  let contents: any = {
    __type: "InvalidRepositoryTriggerEventsException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidRepositoryTriggerNameException = (
  output: any,
  context: __SerdeContext
): InvalidRepositoryTriggerNameException => {
  let contents: any = {
    __type: "InvalidRepositoryTriggerNameException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidRepositoryTriggerRegionException = (
  output: any,
  context: __SerdeContext
): InvalidRepositoryTriggerRegionException => {
  let contents: any = {
    __type: "InvalidRepositoryTriggerRegionException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidResourceArnException = (
  output: any,
  context: __SerdeContext
): InvalidResourceArnException => {
  let contents: any = {
    __type: "InvalidResourceArnException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidRevisionIdException = (
  output: any,
  context: __SerdeContext
): InvalidRevisionIdException => {
  let contents: any = {
    __type: "InvalidRevisionIdException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidRuleContentSha256Exception = (
  output: any,
  context: __SerdeContext
): InvalidRuleContentSha256Exception => {
  let contents: any = {
    __type: "InvalidRuleContentSha256Exception",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidSortByException = (
  output: any,
  context: __SerdeContext
): InvalidSortByException => {
  let contents: any = {
    __type: "InvalidSortByException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidSourceCommitSpecifierException = (
  output: any,
  context: __SerdeContext
): InvalidSourceCommitSpecifierException => {
  let contents: any = {
    __type: "InvalidSourceCommitSpecifierException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidSystemTagUsageException = (
  output: any,
  context: __SerdeContext
): InvalidSystemTagUsageException => {
  let contents: any = {
    __type: "InvalidSystemTagUsageException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidTagKeysListException = (
  output: any,
  context: __SerdeContext
): InvalidTagKeysListException => {
  let contents: any = {
    __type: "InvalidTagKeysListException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidTagsMapException = (
  output: any,
  context: __SerdeContext
): InvalidTagsMapException => {
  let contents: any = {
    __type: "InvalidTagsMapException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidTargetBranchException = (
  output: any,
  context: __SerdeContext
): InvalidTargetBranchException => {
  let contents: any = {
    __type: "InvalidTargetBranchException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidTargetException = (
  output: any,
  context: __SerdeContext
): InvalidTargetException => {
  let contents: any = {
    __type: "InvalidTargetException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidTargetsException = (
  output: any,
  context: __SerdeContext
): InvalidTargetsException => {
  let contents: any = {
    __type: "InvalidTargetsException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidTitleException = (
  output: any,
  context: __SerdeContext
): InvalidTitleException => {
  let contents: any = {
    __type: "InvalidTitleException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1IsBinaryFile = (
  output: any,
  context: __SerdeContext
): IsBinaryFile => {
  let contents: any = {
    __type: "IsBinaryFile",
    base: undefined,
    destination: undefined,
    source: undefined
  };
  if (output.base !== undefined && output.base !== null) {
    contents.base = output.base;
  }
  if (output.destination !== undefined && output.destination !== null) {
    contents.destination = output.destination;
  }
  if (output.source !== undefined && output.source !== null) {
    contents.source = output.source;
  }
  return contents;
};

const deserializeAws_json1_1ListApprovalRuleTemplatesOutput = (
  output: any,
  context: __SerdeContext
): ListApprovalRuleTemplatesOutput => {
  let contents: any = {
    __type: "ListApprovalRuleTemplatesOutput",
    approvalRuleTemplateNames: undefined,
    nextToken: undefined
  };
  if (
    output.approvalRuleTemplateNames !== undefined &&
    output.approvalRuleTemplateNames !== null
  ) {
    contents.approvalRuleTemplateNames = deserializeAws_json1_1ApprovalRuleTemplateNameList(
      output.approvalRuleTemplateNames,
      context
    );
  }
  if (output.nextToken !== undefined && output.nextToken !== null) {
    contents.nextToken = output.nextToken;
  }
  return contents;
};

const deserializeAws_json1_1ListAssociatedApprovalRuleTemplatesForRepositoryOutput = (
  output: any,
  context: __SerdeContext
): ListAssociatedApprovalRuleTemplatesForRepositoryOutput => {
  let contents: any = {
    __type: "ListAssociatedApprovalRuleTemplatesForRepositoryOutput",
    approvalRuleTemplateNames: undefined,
    nextToken: undefined
  };
  if (
    output.approvalRuleTemplateNames !== undefined &&
    output.approvalRuleTemplateNames !== null
  ) {
    contents.approvalRuleTemplateNames = deserializeAws_json1_1ApprovalRuleTemplateNameList(
      output.approvalRuleTemplateNames,
      context
    );
  }
  if (output.nextToken !== undefined && output.nextToken !== null) {
    contents.nextToken = output.nextToken;
  }
  return contents;
};

const deserializeAws_json1_1ListBranchesOutput = (
  output: any,
  context: __SerdeContext
): ListBranchesOutput => {
  let contents: any = {
    __type: "ListBranchesOutput",
    branches: undefined,
    nextToken: undefined
  };
  if (output.branches !== undefined && output.branches !== null) {
    contents.branches = deserializeAws_json1_1BranchNameList(
      output.branches,
      context
    );
  }
  if (output.nextToken !== undefined && output.nextToken !== null) {
    contents.nextToken = output.nextToken;
  }
  return contents;
};

const deserializeAws_json1_1ListPullRequestsOutput = (
  output: any,
  context: __SerdeContext
): ListPullRequestsOutput => {
  let contents: any = {
    __type: "ListPullRequestsOutput",
    nextToken: undefined,
    pullRequestIds: undefined
  };
  if (output.nextToken !== undefined && output.nextToken !== null) {
    contents.nextToken = output.nextToken;
  }
  if (output.pullRequestIds !== undefined && output.pullRequestIds !== null) {
    contents.pullRequestIds = deserializeAws_json1_1PullRequestIdList(
      output.pullRequestIds,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1ListRepositoriesForApprovalRuleTemplateOutput = (
  output: any,
  context: __SerdeContext
): ListRepositoriesForApprovalRuleTemplateOutput => {
  let contents: any = {
    __type: "ListRepositoriesForApprovalRuleTemplateOutput",
    nextToken: undefined,
    repositoryNames: undefined
  };
  if (output.nextToken !== undefined && output.nextToken !== null) {
    contents.nextToken = output.nextToken;
  }
  if (output.repositoryNames !== undefined && output.repositoryNames !== null) {
    contents.repositoryNames = deserializeAws_json1_1RepositoryNameList(
      output.repositoryNames,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1ListRepositoriesOutput = (
  output: any,
  context: __SerdeContext
): ListRepositoriesOutput => {
  let contents: any = {
    __type: "ListRepositoriesOutput",
    nextToken: undefined,
    repositories: undefined
  };
  if (output.nextToken !== undefined && output.nextToken !== null) {
    contents.nextToken = output.nextToken;
  }
  if (output.repositories !== undefined && output.repositories !== null) {
    contents.repositories = deserializeAws_json1_1RepositoryNameIdPairList(
      output.repositories,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1ListTagsForResourceOutput = (
  output: any,
  context: __SerdeContext
): ListTagsForResourceOutput => {
  let contents: any = {
    __type: "ListTagsForResourceOutput",
    nextToken: undefined,
    tags: undefined
  };
  if (output.nextToken !== undefined && output.nextToken !== null) {
    contents.nextToken = output.nextToken;
  }
  if (output.tags !== undefined && output.tags !== null) {
    contents.tags = deserializeAws_json1_1TagsMap(output.tags, context);
  }
  return contents;
};

const deserializeAws_json1_1Location = (
  output: any,
  context: __SerdeContext
): Location => {
  let contents: any = {
    __type: "Location",
    filePath: undefined,
    filePosition: undefined,
    relativeFileVersion: undefined
  };
  if (output.filePath !== undefined && output.filePath !== null) {
    contents.filePath = output.filePath;
  }
  if (output.filePosition !== undefined && output.filePosition !== null) {
    contents.filePosition = output.filePosition;
  }
  if (
    output.relativeFileVersion !== undefined &&
    output.relativeFileVersion !== null
  ) {
    contents.relativeFileVersion = output.relativeFileVersion;
  }
  return contents;
};

const deserializeAws_json1_1ManualMergeRequiredException = (
  output: any,
  context: __SerdeContext
): ManualMergeRequiredException => {
  let contents: any = {
    __type: "ManualMergeRequiredException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1MaximumBranchesExceededException = (
  output: any,
  context: __SerdeContext
): MaximumBranchesExceededException => {
  let contents: any = {
    __type: "MaximumBranchesExceededException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1MaximumConflictResolutionEntriesExceededException = (
  output: any,
  context: __SerdeContext
): MaximumConflictResolutionEntriesExceededException => {
  let contents: any = {
    __type: "MaximumConflictResolutionEntriesExceededException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1MaximumFileContentToLoadExceededException = (
  output: any,
  context: __SerdeContext
): MaximumFileContentToLoadExceededException => {
  let contents: any = {
    __type: "MaximumFileContentToLoadExceededException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1MaximumFileEntriesExceededException = (
  output: any,
  context: __SerdeContext
): MaximumFileEntriesExceededException => {
  let contents: any = {
    __type: "MaximumFileEntriesExceededException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1MaximumItemsToCompareExceededException = (
  output: any,
  context: __SerdeContext
): MaximumItemsToCompareExceededException => {
  let contents: any = {
    __type: "MaximumItemsToCompareExceededException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1MaximumNumberOfApprovalsExceededException = (
  output: any,
  context: __SerdeContext
): MaximumNumberOfApprovalsExceededException => {
  let contents: any = {
    __type: "MaximumNumberOfApprovalsExceededException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1MaximumOpenPullRequestsExceededException = (
  output: any,
  context: __SerdeContext
): MaximumOpenPullRequestsExceededException => {
  let contents: any = {
    __type: "MaximumOpenPullRequestsExceededException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1MaximumRepositoryNamesExceededException = (
  output: any,
  context: __SerdeContext
): MaximumRepositoryNamesExceededException => {
  let contents: any = {
    __type: "MaximumRepositoryNamesExceededException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1MaximumRepositoryTriggersExceededException = (
  output: any,
  context: __SerdeContext
): MaximumRepositoryTriggersExceededException => {
  let contents: any = {
    __type: "MaximumRepositoryTriggersExceededException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1MaximumRuleTemplatesAssociatedWithRepositoryException = (
  output: any,
  context: __SerdeContext
): MaximumRuleTemplatesAssociatedWithRepositoryException => {
  let contents: any = {
    __type: "MaximumRuleTemplatesAssociatedWithRepositoryException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1MergeBranchesByFastForwardOutput = (
  output: any,
  context: __SerdeContext
): MergeBranchesByFastForwardOutput => {
  let contents: any = {
    __type: "MergeBranchesByFastForwardOutput",
    commitId: undefined,
    treeId: undefined
  };
  if (output.commitId !== undefined && output.commitId !== null) {
    contents.commitId = output.commitId;
  }
  if (output.treeId !== undefined && output.treeId !== null) {
    contents.treeId = output.treeId;
  }
  return contents;
};

const deserializeAws_json1_1MergeBranchesBySquashOutput = (
  output: any,
  context: __SerdeContext
): MergeBranchesBySquashOutput => {
  let contents: any = {
    __type: "MergeBranchesBySquashOutput",
    commitId: undefined,
    treeId: undefined
  };
  if (output.commitId !== undefined && output.commitId !== null) {
    contents.commitId = output.commitId;
  }
  if (output.treeId !== undefined && output.treeId !== null) {
    contents.treeId = output.treeId;
  }
  return contents;
};

const deserializeAws_json1_1MergeBranchesByThreeWayOutput = (
  output: any,
  context: __SerdeContext
): MergeBranchesByThreeWayOutput => {
  let contents: any = {
    __type: "MergeBranchesByThreeWayOutput",
    commitId: undefined,
    treeId: undefined
  };
  if (output.commitId !== undefined && output.commitId !== null) {
    contents.commitId = output.commitId;
  }
  if (output.treeId !== undefined && output.treeId !== null) {
    contents.treeId = output.treeId;
  }
  return contents;
};

const deserializeAws_json1_1MergeHunk = (
  output: any,
  context: __SerdeContext
): MergeHunk => {
  let contents: any = {
    __type: "MergeHunk",
    base: undefined,
    destination: undefined,
    isConflict: undefined,
    source: undefined
  };
  if (output.base !== undefined && output.base !== null) {
    contents.base = deserializeAws_json1_1MergeHunkDetail(output.base, context);
  }
  if (output.destination !== undefined && output.destination !== null) {
    contents.destination = deserializeAws_json1_1MergeHunkDetail(
      output.destination,
      context
    );
  }
  if (output.isConflict !== undefined && output.isConflict !== null) {
    contents.isConflict = output.isConflict;
  }
  if (output.source !== undefined && output.source !== null) {
    contents.source = deserializeAws_json1_1MergeHunkDetail(
      output.source,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1MergeHunkDetail = (
  output: any,
  context: __SerdeContext
): MergeHunkDetail => {
  let contents: any = {
    __type: "MergeHunkDetail",
    endLine: undefined,
    hunkContent: undefined,
    startLine: undefined
  };
  if (output.endLine !== undefined && output.endLine !== null) {
    contents.endLine = output.endLine;
  }
  if (output.hunkContent !== undefined && output.hunkContent !== null) {
    contents.hunkContent = output.hunkContent;
  }
  if (output.startLine !== undefined && output.startLine !== null) {
    contents.startLine = output.startLine;
  }
  return contents;
};

const deserializeAws_json1_1MergeHunks = (
  output: any,
  context: __SerdeContext
): Array<MergeHunk> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1MergeHunk(entry, context)
  );
};

const deserializeAws_json1_1MergeMetadata = (
  output: any,
  context: __SerdeContext
): MergeMetadata => {
  let contents: any = {
    __type: "MergeMetadata",
    isMerged: undefined,
    mergeCommitId: undefined,
    mergeOption: undefined,
    mergedBy: undefined
  };
  if (output.isMerged !== undefined && output.isMerged !== null) {
    contents.isMerged = output.isMerged;
  }
  if (output.mergeCommitId !== undefined && output.mergeCommitId !== null) {
    contents.mergeCommitId = output.mergeCommitId;
  }
  if (output.mergeOption !== undefined && output.mergeOption !== null) {
    contents.mergeOption = output.mergeOption;
  }
  if (output.mergedBy !== undefined && output.mergedBy !== null) {
    contents.mergedBy = output.mergedBy;
  }
  return contents;
};

const deserializeAws_json1_1MergeOperations = (
  output: any,
  context: __SerdeContext
): MergeOperations => {
  let contents: any = {
    __type: "MergeOperations",
    destination: undefined,
    source: undefined
  };
  if (output.destination !== undefined && output.destination !== null) {
    contents.destination = output.destination;
  }
  if (output.source !== undefined && output.source !== null) {
    contents.source = output.source;
  }
  return contents;
};

const deserializeAws_json1_1MergeOptionRequiredException = (
  output: any,
  context: __SerdeContext
): MergeOptionRequiredException => {
  let contents: any = {
    __type: "MergeOptionRequiredException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1MergeOptions = (
  output: any,
  context: __SerdeContext
): Array<MergeOptionTypeEnum | string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1MergePullRequestByFastForwardOutput = (
  output: any,
  context: __SerdeContext
): MergePullRequestByFastForwardOutput => {
  let contents: any = {
    __type: "MergePullRequestByFastForwardOutput",
    pullRequest: undefined
  };
  if (output.pullRequest !== undefined && output.pullRequest !== null) {
    contents.pullRequest = deserializeAws_json1_1PullRequest(
      output.pullRequest,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1MergePullRequestBySquashOutput = (
  output: any,
  context: __SerdeContext
): MergePullRequestBySquashOutput => {
  let contents: any = {
    __type: "MergePullRequestBySquashOutput",
    pullRequest: undefined
  };
  if (output.pullRequest !== undefined && output.pullRequest !== null) {
    contents.pullRequest = deserializeAws_json1_1PullRequest(
      output.pullRequest,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1MergePullRequestByThreeWayOutput = (
  output: any,
  context: __SerdeContext
): MergePullRequestByThreeWayOutput => {
  let contents: any = {
    __type: "MergePullRequestByThreeWayOutput",
    pullRequest: undefined
  };
  if (output.pullRequest !== undefined && output.pullRequest !== null) {
    contents.pullRequest = deserializeAws_json1_1PullRequest(
      output.pullRequest,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1MultipleConflictResolutionEntriesException = (
  output: any,
  context: __SerdeContext
): MultipleConflictResolutionEntriesException => {
  let contents: any = {
    __type: "MultipleConflictResolutionEntriesException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1MultipleRepositoriesInPullRequestException = (
  output: any,
  context: __SerdeContext
): MultipleRepositoriesInPullRequestException => {
  let contents: any = {
    __type: "MultipleRepositoriesInPullRequestException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1NameLengthExceededException = (
  output: any,
  context: __SerdeContext
): NameLengthExceededException => {
  let contents: any = {
    __type: "NameLengthExceededException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1NoChangeException = (
  output: any,
  context: __SerdeContext
): NoChangeException => {
  let contents: any = {
    __type: "NoChangeException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1NumberOfRuleTemplatesExceededException = (
  output: any,
  context: __SerdeContext
): NumberOfRuleTemplatesExceededException => {
  let contents: any = {
    __type: "NumberOfRuleTemplatesExceededException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1NumberOfRulesExceededException = (
  output: any,
  context: __SerdeContext
): NumberOfRulesExceededException => {
  let contents: any = {
    __type: "NumberOfRulesExceededException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1ObjectTypes = (
  output: any,
  context: __SerdeContext
): ObjectTypes => {
  let contents: any = {
    __type: "ObjectTypes",
    base: undefined,
    destination: undefined,
    source: undefined
  };
  if (output.base !== undefined && output.base !== null) {
    contents.base = output.base;
  }
  if (output.destination !== undefined && output.destination !== null) {
    contents.destination = output.destination;
  }
  if (output.source !== undefined && output.source !== null) {
    contents.source = output.source;
  }
  return contents;
};

const deserializeAws_json1_1OriginApprovalRuleTemplate = (
  output: any,
  context: __SerdeContext
): OriginApprovalRuleTemplate => {
  let contents: any = {
    __type: "OriginApprovalRuleTemplate",
    approvalRuleTemplateId: undefined,
    approvalRuleTemplateName: undefined
  };
  if (
    output.approvalRuleTemplateId !== undefined &&
    output.approvalRuleTemplateId !== null
  ) {
    contents.approvalRuleTemplateId = output.approvalRuleTemplateId;
  }
  if (
    output.approvalRuleTemplateName !== undefined &&
    output.approvalRuleTemplateName !== null
  ) {
    contents.approvalRuleTemplateName = output.approvalRuleTemplateName;
  }
  return contents;
};

const deserializeAws_json1_1OverrideAlreadySetException = (
  output: any,
  context: __SerdeContext
): OverrideAlreadySetException => {
  let contents: any = {
    __type: "OverrideAlreadySetException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1OverrideStatusRequiredException = (
  output: any,
  context: __SerdeContext
): OverrideStatusRequiredException => {
  let contents: any = {
    __type: "OverrideStatusRequiredException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1ParentCommitDoesNotExistException = (
  output: any,
  context: __SerdeContext
): ParentCommitDoesNotExistException => {
  let contents: any = {
    __type: "ParentCommitDoesNotExistException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1ParentCommitIdOutdatedException = (
  output: any,
  context: __SerdeContext
): ParentCommitIdOutdatedException => {
  let contents: any = {
    __type: "ParentCommitIdOutdatedException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1ParentCommitIdRequiredException = (
  output: any,
  context: __SerdeContext
): ParentCommitIdRequiredException => {
  let contents: any = {
    __type: "ParentCommitIdRequiredException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1ParentList = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1PathDoesNotExistException = (
  output: any,
  context: __SerdeContext
): PathDoesNotExistException => {
  let contents: any = {
    __type: "PathDoesNotExistException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1PathRequiredException = (
  output: any,
  context: __SerdeContext
): PathRequiredException => {
  let contents: any = {
    __type: "PathRequiredException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1PostCommentForComparedCommitOutput = (
  output: any,
  context: __SerdeContext
): PostCommentForComparedCommitOutput => {
  let contents: any = {
    __type: "PostCommentForComparedCommitOutput",
    afterBlobId: undefined,
    afterCommitId: undefined,
    beforeBlobId: undefined,
    beforeCommitId: undefined,
    comment: undefined,
    location: undefined,
    repositoryName: undefined
  };
  if (output.afterBlobId !== undefined && output.afterBlobId !== null) {
    contents.afterBlobId = output.afterBlobId;
  }
  if (output.afterCommitId !== undefined && output.afterCommitId !== null) {
    contents.afterCommitId = output.afterCommitId;
  }
  if (output.beforeBlobId !== undefined && output.beforeBlobId !== null) {
    contents.beforeBlobId = output.beforeBlobId;
  }
  if (output.beforeCommitId !== undefined && output.beforeCommitId !== null) {
    contents.beforeCommitId = output.beforeCommitId;
  }
  if (output.comment !== undefined && output.comment !== null) {
    contents.comment = deserializeAws_json1_1Comment(output.comment, context);
  }
  if (output.location !== undefined && output.location !== null) {
    contents.location = deserializeAws_json1_1Location(
      output.location,
      context
    );
  }
  if (output.repositoryName !== undefined && output.repositoryName !== null) {
    contents.repositoryName = output.repositoryName;
  }
  return contents;
};

const deserializeAws_json1_1PostCommentForPullRequestOutput = (
  output: any,
  context: __SerdeContext
): PostCommentForPullRequestOutput => {
  let contents: any = {
    __type: "PostCommentForPullRequestOutput",
    afterBlobId: undefined,
    afterCommitId: undefined,
    beforeBlobId: undefined,
    beforeCommitId: undefined,
    comment: undefined,
    location: undefined,
    pullRequestId: undefined,
    repositoryName: undefined
  };
  if (output.afterBlobId !== undefined && output.afterBlobId !== null) {
    contents.afterBlobId = output.afterBlobId;
  }
  if (output.afterCommitId !== undefined && output.afterCommitId !== null) {
    contents.afterCommitId = output.afterCommitId;
  }
  if (output.beforeBlobId !== undefined && output.beforeBlobId !== null) {
    contents.beforeBlobId = output.beforeBlobId;
  }
  if (output.beforeCommitId !== undefined && output.beforeCommitId !== null) {
    contents.beforeCommitId = output.beforeCommitId;
  }
  if (output.comment !== undefined && output.comment !== null) {
    contents.comment = deserializeAws_json1_1Comment(output.comment, context);
  }
  if (output.location !== undefined && output.location !== null) {
    contents.location = deserializeAws_json1_1Location(
      output.location,
      context
    );
  }
  if (output.pullRequestId !== undefined && output.pullRequestId !== null) {
    contents.pullRequestId = output.pullRequestId;
  }
  if (output.repositoryName !== undefined && output.repositoryName !== null) {
    contents.repositoryName = output.repositoryName;
  }
  return contents;
};

const deserializeAws_json1_1PostCommentReplyOutput = (
  output: any,
  context: __SerdeContext
): PostCommentReplyOutput => {
  let contents: any = {
    __type: "PostCommentReplyOutput",
    comment: undefined
  };
  if (output.comment !== undefined && output.comment !== null) {
    contents.comment = deserializeAws_json1_1Comment(output.comment, context);
  }
  return contents;
};

const deserializeAws_json1_1PullRequest = (
  output: any,
  context: __SerdeContext
): PullRequest => {
  let contents: any = {
    __type: "PullRequest",
    approvalRules: undefined,
    authorArn: undefined,
    clientRequestToken: undefined,
    creationDate: undefined,
    description: undefined,
    lastActivityDate: undefined,
    pullRequestId: undefined,
    pullRequestStatus: undefined,
    pullRequestTargets: undefined,
    revisionId: undefined,
    title: undefined
  };
  if (output.approvalRules !== undefined && output.approvalRules !== null) {
    contents.approvalRules = deserializeAws_json1_1ApprovalRulesList(
      output.approvalRules,
      context
    );
  }
  if (output.authorArn !== undefined && output.authorArn !== null) {
    contents.authorArn = output.authorArn;
  }
  if (
    output.clientRequestToken !== undefined &&
    output.clientRequestToken !== null
  ) {
    contents.clientRequestToken = output.clientRequestToken;
  }
  if (output.creationDate !== undefined && output.creationDate !== null) {
    contents.creationDate = new Date(Math.round(output.creationDate * 1000));
  }
  if (output.description !== undefined && output.description !== null) {
    contents.description = output.description;
  }
  if (
    output.lastActivityDate !== undefined &&
    output.lastActivityDate !== null
  ) {
    contents.lastActivityDate = new Date(
      Math.round(output.lastActivityDate * 1000)
    );
  }
  if (output.pullRequestId !== undefined && output.pullRequestId !== null) {
    contents.pullRequestId = output.pullRequestId;
  }
  if (
    output.pullRequestStatus !== undefined &&
    output.pullRequestStatus !== null
  ) {
    contents.pullRequestStatus = output.pullRequestStatus;
  }
  if (
    output.pullRequestTargets !== undefined &&
    output.pullRequestTargets !== null
  ) {
    contents.pullRequestTargets = deserializeAws_json1_1PullRequestTargetList(
      output.pullRequestTargets,
      context
    );
  }
  if (output.revisionId !== undefined && output.revisionId !== null) {
    contents.revisionId = output.revisionId;
  }
  if (output.title !== undefined && output.title !== null) {
    contents.title = output.title;
  }
  return contents;
};

const deserializeAws_json1_1PullRequestAlreadyClosedException = (
  output: any,
  context: __SerdeContext
): PullRequestAlreadyClosedException => {
  let contents: any = {
    __type: "PullRequestAlreadyClosedException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1PullRequestApprovalRulesNotSatisfiedException = (
  output: any,
  context: __SerdeContext
): PullRequestApprovalRulesNotSatisfiedException => {
  let contents: any = {
    __type: "PullRequestApprovalRulesNotSatisfiedException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1PullRequestCannotBeApprovedByAuthorException = (
  output: any,
  context: __SerdeContext
): PullRequestCannotBeApprovedByAuthorException => {
  let contents: any = {
    __type: "PullRequestCannotBeApprovedByAuthorException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1PullRequestCreatedEventMetadata = (
  output: any,
  context: __SerdeContext
): PullRequestCreatedEventMetadata => {
  let contents: any = {
    __type: "PullRequestCreatedEventMetadata",
    destinationCommitId: undefined,
    mergeBase: undefined,
    repositoryName: undefined,
    sourceCommitId: undefined
  };
  if (
    output.destinationCommitId !== undefined &&
    output.destinationCommitId !== null
  ) {
    contents.destinationCommitId = output.destinationCommitId;
  }
  if (output.mergeBase !== undefined && output.mergeBase !== null) {
    contents.mergeBase = output.mergeBase;
  }
  if (output.repositoryName !== undefined && output.repositoryName !== null) {
    contents.repositoryName = output.repositoryName;
  }
  if (output.sourceCommitId !== undefined && output.sourceCommitId !== null) {
    contents.sourceCommitId = output.sourceCommitId;
  }
  return contents;
};

const deserializeAws_json1_1PullRequestDoesNotExistException = (
  output: any,
  context: __SerdeContext
): PullRequestDoesNotExistException => {
  let contents: any = {
    __type: "PullRequestDoesNotExistException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1PullRequestEvent = (
  output: any,
  context: __SerdeContext
): PullRequestEvent => {
  let contents: any = {
    __type: "PullRequestEvent",
    actorArn: undefined,
    approvalRuleEventMetadata: undefined,
    approvalRuleOverriddenEventMetadata: undefined,
    approvalStateChangedEventMetadata: undefined,
    eventDate: undefined,
    pullRequestCreatedEventMetadata: undefined,
    pullRequestEventType: undefined,
    pullRequestId: undefined,
    pullRequestMergedStateChangedEventMetadata: undefined,
    pullRequestSourceReferenceUpdatedEventMetadata: undefined,
    pullRequestStatusChangedEventMetadata: undefined
  };
  if (output.actorArn !== undefined && output.actorArn !== null) {
    contents.actorArn = output.actorArn;
  }
  if (
    output.approvalRuleEventMetadata !== undefined &&
    output.approvalRuleEventMetadata !== null
  ) {
    contents.approvalRuleEventMetadata = deserializeAws_json1_1ApprovalRuleEventMetadata(
      output.approvalRuleEventMetadata,
      context
    );
  }
  if (
    output.approvalRuleOverriddenEventMetadata !== undefined &&
    output.approvalRuleOverriddenEventMetadata !== null
  ) {
    contents.approvalRuleOverriddenEventMetadata = deserializeAws_json1_1ApprovalRuleOverriddenEventMetadata(
      output.approvalRuleOverriddenEventMetadata,
      context
    );
  }
  if (
    output.approvalStateChangedEventMetadata !== undefined &&
    output.approvalStateChangedEventMetadata !== null
  ) {
    contents.approvalStateChangedEventMetadata = deserializeAws_json1_1ApprovalStateChangedEventMetadata(
      output.approvalStateChangedEventMetadata,
      context
    );
  }
  if (output.eventDate !== undefined && output.eventDate !== null) {
    contents.eventDate = new Date(Math.round(output.eventDate * 1000));
  }
  if (
    output.pullRequestCreatedEventMetadata !== undefined &&
    output.pullRequestCreatedEventMetadata !== null
  ) {
    contents.pullRequestCreatedEventMetadata = deserializeAws_json1_1PullRequestCreatedEventMetadata(
      output.pullRequestCreatedEventMetadata,
      context
    );
  }
  if (
    output.pullRequestEventType !== undefined &&
    output.pullRequestEventType !== null
  ) {
    contents.pullRequestEventType = output.pullRequestEventType;
  }
  if (output.pullRequestId !== undefined && output.pullRequestId !== null) {
    contents.pullRequestId = output.pullRequestId;
  }
  if (
    output.pullRequestMergedStateChangedEventMetadata !== undefined &&
    output.pullRequestMergedStateChangedEventMetadata !== null
  ) {
    contents.pullRequestMergedStateChangedEventMetadata = deserializeAws_json1_1PullRequestMergedStateChangedEventMetadata(
      output.pullRequestMergedStateChangedEventMetadata,
      context
    );
  }
  if (
    output.pullRequestSourceReferenceUpdatedEventMetadata !== undefined &&
    output.pullRequestSourceReferenceUpdatedEventMetadata !== null
  ) {
    contents.pullRequestSourceReferenceUpdatedEventMetadata = deserializeAws_json1_1PullRequestSourceReferenceUpdatedEventMetadata(
      output.pullRequestSourceReferenceUpdatedEventMetadata,
      context
    );
  }
  if (
    output.pullRequestStatusChangedEventMetadata !== undefined &&
    output.pullRequestStatusChangedEventMetadata !== null
  ) {
    contents.pullRequestStatusChangedEventMetadata = deserializeAws_json1_1PullRequestStatusChangedEventMetadata(
      output.pullRequestStatusChangedEventMetadata,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1PullRequestEventList = (
  output: any,
  context: __SerdeContext
): Array<PullRequestEvent> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1PullRequestEvent(entry, context)
  );
};

const deserializeAws_json1_1PullRequestIdList = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1PullRequestIdRequiredException = (
  output: any,
  context: __SerdeContext
): PullRequestIdRequiredException => {
  let contents: any = {
    __type: "PullRequestIdRequiredException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1PullRequestMergedStateChangedEventMetadata = (
  output: any,
  context: __SerdeContext
): PullRequestMergedStateChangedEventMetadata => {
  let contents: any = {
    __type: "PullRequestMergedStateChangedEventMetadata",
    destinationReference: undefined,
    mergeMetadata: undefined,
    repositoryName: undefined
  };
  if (
    output.destinationReference !== undefined &&
    output.destinationReference !== null
  ) {
    contents.destinationReference = output.destinationReference;
  }
  if (output.mergeMetadata !== undefined && output.mergeMetadata !== null) {
    contents.mergeMetadata = deserializeAws_json1_1MergeMetadata(
      output.mergeMetadata,
      context
    );
  }
  if (output.repositoryName !== undefined && output.repositoryName !== null) {
    contents.repositoryName = output.repositoryName;
  }
  return contents;
};

const deserializeAws_json1_1PullRequestSourceReferenceUpdatedEventMetadata = (
  output: any,
  context: __SerdeContext
): PullRequestSourceReferenceUpdatedEventMetadata => {
  let contents: any = {
    __type: "PullRequestSourceReferenceUpdatedEventMetadata",
    afterCommitId: undefined,
    beforeCommitId: undefined,
    mergeBase: undefined,
    repositoryName: undefined
  };
  if (output.afterCommitId !== undefined && output.afterCommitId !== null) {
    contents.afterCommitId = output.afterCommitId;
  }
  if (output.beforeCommitId !== undefined && output.beforeCommitId !== null) {
    contents.beforeCommitId = output.beforeCommitId;
  }
  if (output.mergeBase !== undefined && output.mergeBase !== null) {
    contents.mergeBase = output.mergeBase;
  }
  if (output.repositoryName !== undefined && output.repositoryName !== null) {
    contents.repositoryName = output.repositoryName;
  }
  return contents;
};

const deserializeAws_json1_1PullRequestStatusChangedEventMetadata = (
  output: any,
  context: __SerdeContext
): PullRequestStatusChangedEventMetadata => {
  let contents: any = {
    __type: "PullRequestStatusChangedEventMetadata",
    pullRequestStatus: undefined
  };
  if (
    output.pullRequestStatus !== undefined &&
    output.pullRequestStatus !== null
  ) {
    contents.pullRequestStatus = output.pullRequestStatus;
  }
  return contents;
};

const deserializeAws_json1_1PullRequestStatusRequiredException = (
  output: any,
  context: __SerdeContext
): PullRequestStatusRequiredException => {
  let contents: any = {
    __type: "PullRequestStatusRequiredException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1PullRequestTarget = (
  output: any,
  context: __SerdeContext
): PullRequestTarget => {
  let contents: any = {
    __type: "PullRequestTarget",
    destinationCommit: undefined,
    destinationReference: undefined,
    mergeBase: undefined,
    mergeMetadata: undefined,
    repositoryName: undefined,
    sourceCommit: undefined,
    sourceReference: undefined
  };
  if (
    output.destinationCommit !== undefined &&
    output.destinationCommit !== null
  ) {
    contents.destinationCommit = output.destinationCommit;
  }
  if (
    output.destinationReference !== undefined &&
    output.destinationReference !== null
  ) {
    contents.destinationReference = output.destinationReference;
  }
  if (output.mergeBase !== undefined && output.mergeBase !== null) {
    contents.mergeBase = output.mergeBase;
  }
  if (output.mergeMetadata !== undefined && output.mergeMetadata !== null) {
    contents.mergeMetadata = deserializeAws_json1_1MergeMetadata(
      output.mergeMetadata,
      context
    );
  }
  if (output.repositoryName !== undefined && output.repositoryName !== null) {
    contents.repositoryName = output.repositoryName;
  }
  if (output.sourceCommit !== undefined && output.sourceCommit !== null) {
    contents.sourceCommit = output.sourceCommit;
  }
  if (output.sourceReference !== undefined && output.sourceReference !== null) {
    contents.sourceReference = output.sourceReference;
  }
  return contents;
};

const deserializeAws_json1_1PullRequestTargetList = (
  output: any,
  context: __SerdeContext
): Array<PullRequestTarget> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1PullRequestTarget(entry, context)
  );
};

const deserializeAws_json1_1PutFileEntryConflictException = (
  output: any,
  context: __SerdeContext
): PutFileEntryConflictException => {
  let contents: any = {
    __type: "PutFileEntryConflictException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1PutFileOutput = (
  output: any,
  context: __SerdeContext
): PutFileOutput => {
  let contents: any = {
    __type: "PutFileOutput",
    blobId: undefined,
    commitId: undefined,
    treeId: undefined
  };
  if (output.blobId !== undefined && output.blobId !== null) {
    contents.blobId = output.blobId;
  }
  if (output.commitId !== undefined && output.commitId !== null) {
    contents.commitId = output.commitId;
  }
  if (output.treeId !== undefined && output.treeId !== null) {
    contents.treeId = output.treeId;
  }
  return contents;
};

const deserializeAws_json1_1PutRepositoryTriggersOutput = (
  output: any,
  context: __SerdeContext
): PutRepositoryTriggersOutput => {
  let contents: any = {
    __type: "PutRepositoryTriggersOutput",
    configurationId: undefined
  };
  if (output.configurationId !== undefined && output.configurationId !== null) {
    contents.configurationId = output.configurationId;
  }
  return contents;
};

const deserializeAws_json1_1ReferenceDoesNotExistException = (
  output: any,
  context: __SerdeContext
): ReferenceDoesNotExistException => {
  let contents: any = {
    __type: "ReferenceDoesNotExistException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1ReferenceNameRequiredException = (
  output: any,
  context: __SerdeContext
): ReferenceNameRequiredException => {
  let contents: any = {
    __type: "ReferenceNameRequiredException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1ReferenceTypeNotSupportedException = (
  output: any,
  context: __SerdeContext
): ReferenceTypeNotSupportedException => {
  let contents: any = {
    __type: "ReferenceTypeNotSupportedException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1ReplacementContentRequiredException = (
  output: any,
  context: __SerdeContext
): ReplacementContentRequiredException => {
  let contents: any = {
    __type: "ReplacementContentRequiredException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1ReplacementTypeRequiredException = (
  output: any,
  context: __SerdeContext
): ReplacementTypeRequiredException => {
  let contents: any = {
    __type: "ReplacementTypeRequiredException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1RepositoryDoesNotExistException = (
  output: any,
  context: __SerdeContext
): RepositoryDoesNotExistException => {
  let contents: any = {
    __type: "RepositoryDoesNotExistException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1RepositoryLimitExceededException = (
  output: any,
  context: __SerdeContext
): RepositoryLimitExceededException => {
  let contents: any = {
    __type: "RepositoryLimitExceededException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1RepositoryMetadata = (
  output: any,
  context: __SerdeContext
): RepositoryMetadata => {
  let contents: any = {
    __type: "RepositoryMetadata",
    Arn: undefined,
    accountId: undefined,
    cloneUrlHttp: undefined,
    cloneUrlSsh: undefined,
    creationDate: undefined,
    defaultBranch: undefined,
    lastModifiedDate: undefined,
    repositoryDescription: undefined,
    repositoryId: undefined,
    repositoryName: undefined
  };
  if (output.Arn !== undefined && output.Arn !== null) {
    contents.Arn = output.Arn;
  }
  if (output.accountId !== undefined && output.accountId !== null) {
    contents.accountId = output.accountId;
  }
  if (output.cloneUrlHttp !== undefined && output.cloneUrlHttp !== null) {
    contents.cloneUrlHttp = output.cloneUrlHttp;
  }
  if (output.cloneUrlSsh !== undefined && output.cloneUrlSsh !== null) {
    contents.cloneUrlSsh = output.cloneUrlSsh;
  }
  if (output.creationDate !== undefined && output.creationDate !== null) {
    contents.creationDate = new Date(Math.round(output.creationDate * 1000));
  }
  if (output.defaultBranch !== undefined && output.defaultBranch !== null) {
    contents.defaultBranch = output.defaultBranch;
  }
  if (
    output.lastModifiedDate !== undefined &&
    output.lastModifiedDate !== null
  ) {
    contents.lastModifiedDate = new Date(
      Math.round(output.lastModifiedDate * 1000)
    );
  }
  if (
    output.repositoryDescription !== undefined &&
    output.repositoryDescription !== null
  ) {
    contents.repositoryDescription = output.repositoryDescription;
  }
  if (output.repositoryId !== undefined && output.repositoryId !== null) {
    contents.repositoryId = output.repositoryId;
  }
  if (output.repositoryName !== undefined && output.repositoryName !== null) {
    contents.repositoryName = output.repositoryName;
  }
  return contents;
};

const deserializeAws_json1_1RepositoryMetadataList = (
  output: any,
  context: __SerdeContext
): Array<RepositoryMetadata> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1RepositoryMetadata(entry, context)
  );
};

const deserializeAws_json1_1RepositoryNameExistsException = (
  output: any,
  context: __SerdeContext
): RepositoryNameExistsException => {
  let contents: any = {
    __type: "RepositoryNameExistsException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1RepositoryNameIdPair = (
  output: any,
  context: __SerdeContext
): RepositoryNameIdPair => {
  let contents: any = {
    __type: "RepositoryNameIdPair",
    repositoryId: undefined,
    repositoryName: undefined
  };
  if (output.repositoryId !== undefined && output.repositoryId !== null) {
    contents.repositoryId = output.repositoryId;
  }
  if (output.repositoryName !== undefined && output.repositoryName !== null) {
    contents.repositoryName = output.repositoryName;
  }
  return contents;
};

const deserializeAws_json1_1RepositoryNameIdPairList = (
  output: any,
  context: __SerdeContext
): Array<RepositoryNameIdPair> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1RepositoryNameIdPair(entry, context)
  );
};

const deserializeAws_json1_1RepositoryNameList = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1RepositoryNameRequiredException = (
  output: any,
  context: __SerdeContext
): RepositoryNameRequiredException => {
  let contents: any = {
    __type: "RepositoryNameRequiredException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1RepositoryNamesRequiredException = (
  output: any,
  context: __SerdeContext
): RepositoryNamesRequiredException => {
  let contents: any = {
    __type: "RepositoryNamesRequiredException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1RepositoryNotAssociatedWithPullRequestException = (
  output: any,
  context: __SerdeContext
): RepositoryNotAssociatedWithPullRequestException => {
  let contents: any = {
    __type: "RepositoryNotAssociatedWithPullRequestException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1RepositoryNotFoundList = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1RepositoryTrigger = (
  output: any,
  context: __SerdeContext
): RepositoryTrigger => {
  let contents: any = {
    __type: "RepositoryTrigger",
    branches: undefined,
    customData: undefined,
    destinationArn: undefined,
    events: undefined,
    name: undefined
  };
  if (output.branches !== undefined && output.branches !== null) {
    contents.branches = deserializeAws_json1_1BranchNameList(
      output.branches,
      context
    );
  }
  if (output.customData !== undefined && output.customData !== null) {
    contents.customData = output.customData;
  }
  if (output.destinationArn !== undefined && output.destinationArn !== null) {
    contents.destinationArn = output.destinationArn;
  }
  if (output.events !== undefined && output.events !== null) {
    contents.events = deserializeAws_json1_1RepositoryTriggerEventList(
      output.events,
      context
    );
  }
  if (output.name !== undefined && output.name !== null) {
    contents.name = output.name;
  }
  return contents;
};

const deserializeAws_json1_1RepositoryTriggerBranchNameListRequiredException = (
  output: any,
  context: __SerdeContext
): RepositoryTriggerBranchNameListRequiredException => {
  let contents: any = {
    __type: "RepositoryTriggerBranchNameListRequiredException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1RepositoryTriggerDestinationArnRequiredException = (
  output: any,
  context: __SerdeContext
): RepositoryTriggerDestinationArnRequiredException => {
  let contents: any = {
    __type: "RepositoryTriggerDestinationArnRequiredException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1RepositoryTriggerEventList = (
  output: any,
  context: __SerdeContext
): Array<RepositoryTriggerEventEnum | string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1RepositoryTriggerEventsListRequiredException = (
  output: any,
  context: __SerdeContext
): RepositoryTriggerEventsListRequiredException => {
  let contents: any = {
    __type: "RepositoryTriggerEventsListRequiredException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1RepositoryTriggerExecutionFailure = (
  output: any,
  context: __SerdeContext
): RepositoryTriggerExecutionFailure => {
  let contents: any = {
    __type: "RepositoryTriggerExecutionFailure",
    failureMessage: undefined,
    trigger: undefined
  };
  if (output.failureMessage !== undefined && output.failureMessage !== null) {
    contents.failureMessage = output.failureMessage;
  }
  if (output.trigger !== undefined && output.trigger !== null) {
    contents.trigger = output.trigger;
  }
  return contents;
};

const deserializeAws_json1_1RepositoryTriggerExecutionFailureList = (
  output: any,
  context: __SerdeContext
): Array<RepositoryTriggerExecutionFailure> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1RepositoryTriggerExecutionFailure(entry, context)
  );
};

const deserializeAws_json1_1RepositoryTriggerNameList = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1RepositoryTriggerNameRequiredException = (
  output: any,
  context: __SerdeContext
): RepositoryTriggerNameRequiredException => {
  let contents: any = {
    __type: "RepositoryTriggerNameRequiredException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1RepositoryTriggersList = (
  output: any,
  context: __SerdeContext
): Array<RepositoryTrigger> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1RepositoryTrigger(entry, context)
  );
};

const deserializeAws_json1_1RepositoryTriggersListRequiredException = (
  output: any,
  context: __SerdeContext
): RepositoryTriggersListRequiredException => {
  let contents: any = {
    __type: "RepositoryTriggersListRequiredException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1ResourceArnRequiredException = (
  output: any,
  context: __SerdeContext
): ResourceArnRequiredException => {
  let contents: any = {
    __type: "ResourceArnRequiredException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1RestrictedSourceFileException = (
  output: any,
  context: __SerdeContext
): RestrictedSourceFileException => {
  let contents: any = {
    __type: "RestrictedSourceFileException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1RevisionIdRequiredException = (
  output: any,
  context: __SerdeContext
): RevisionIdRequiredException => {
  let contents: any = {
    __type: "RevisionIdRequiredException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1RevisionNotCurrentException = (
  output: any,
  context: __SerdeContext
): RevisionNotCurrentException => {
  let contents: any = {
    __type: "RevisionNotCurrentException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1SameFileContentException = (
  output: any,
  context: __SerdeContext
): SameFileContentException => {
  let contents: any = {
    __type: "SameFileContentException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1SamePathRequestException = (
  output: any,
  context: __SerdeContext
): SamePathRequestException => {
  let contents: any = {
    __type: "SamePathRequestException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1SourceAndDestinationAreSameException = (
  output: any,
  context: __SerdeContext
): SourceAndDestinationAreSameException => {
  let contents: any = {
    __type: "SourceAndDestinationAreSameException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1SourceFileOrContentRequiredException = (
  output: any,
  context: __SerdeContext
): SourceFileOrContentRequiredException => {
  let contents: any = {
    __type: "SourceFileOrContentRequiredException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1SubModule = (
  output: any,
  context: __SerdeContext
): SubModule => {
  let contents: any = {
    __type: "SubModule",
    absolutePath: undefined,
    commitId: undefined,
    relativePath: undefined
  };
  if (output.absolutePath !== undefined && output.absolutePath !== null) {
    contents.absolutePath = output.absolutePath;
  }
  if (output.commitId !== undefined && output.commitId !== null) {
    contents.commitId = output.commitId;
  }
  if (output.relativePath !== undefined && output.relativePath !== null) {
    contents.relativePath = output.relativePath;
  }
  return contents;
};

const deserializeAws_json1_1SubModuleList = (
  output: any,
  context: __SerdeContext
): Array<SubModule> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1SubModule(entry, context)
  );
};

const deserializeAws_json1_1SymbolicLink = (
  output: any,
  context: __SerdeContext
): SymbolicLink => {
  let contents: any = {
    __type: "SymbolicLink",
    absolutePath: undefined,
    blobId: undefined,
    fileMode: undefined,
    relativePath: undefined
  };
  if (output.absolutePath !== undefined && output.absolutePath !== null) {
    contents.absolutePath = output.absolutePath;
  }
  if (output.blobId !== undefined && output.blobId !== null) {
    contents.blobId = output.blobId;
  }
  if (output.fileMode !== undefined && output.fileMode !== null) {
    contents.fileMode = output.fileMode;
  }
  if (output.relativePath !== undefined && output.relativePath !== null) {
    contents.relativePath = output.relativePath;
  }
  return contents;
};

const deserializeAws_json1_1SymbolicLinkList = (
  output: any,
  context: __SerdeContext
): Array<SymbolicLink> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1SymbolicLink(entry, context)
  );
};

const deserializeAws_json1_1TagKeysListRequiredException = (
  output: any,
  context: __SerdeContext
): TagKeysListRequiredException => {
  let contents: any = {
    __type: "TagKeysListRequiredException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1TagPolicyException = (
  output: any,
  context: __SerdeContext
): TagPolicyException => {
  let contents: any = {
    __type: "TagPolicyException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1TagsMap = (
  output: any,
  context: __SerdeContext
): { [key: string]: string } => {
  const mapParams: any = {};
  Object.keys(output).forEach(key => {
    mapParams[key] = output[key];
  });
  return mapParams;
};

const deserializeAws_json1_1TagsMapRequiredException = (
  output: any,
  context: __SerdeContext
): TagsMapRequiredException => {
  let contents: any = {
    __type: "TagsMapRequiredException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1TargetRequiredException = (
  output: any,
  context: __SerdeContext
): TargetRequiredException => {
  let contents: any = {
    __type: "TargetRequiredException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1TargetsRequiredException = (
  output: any,
  context: __SerdeContext
): TargetsRequiredException => {
  let contents: any = {
    __type: "TargetsRequiredException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1TestRepositoryTriggersOutput = (
  output: any,
  context: __SerdeContext
): TestRepositoryTriggersOutput => {
  let contents: any = {
    __type: "TestRepositoryTriggersOutput",
    failedExecutions: undefined,
    successfulExecutions: undefined
  };
  if (
    output.failedExecutions !== undefined &&
    output.failedExecutions !== null
  ) {
    contents.failedExecutions = deserializeAws_json1_1RepositoryTriggerExecutionFailureList(
      output.failedExecutions,
      context
    );
  }
  if (
    output.successfulExecutions !== undefined &&
    output.successfulExecutions !== null
  ) {
    contents.successfulExecutions = deserializeAws_json1_1RepositoryTriggerNameList(
      output.successfulExecutions,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1TipOfSourceReferenceIsDifferentException = (
  output: any,
  context: __SerdeContext
): TipOfSourceReferenceIsDifferentException => {
  let contents: any = {
    __type: "TipOfSourceReferenceIsDifferentException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1TipsDivergenceExceededException = (
  output: any,
  context: __SerdeContext
): TipsDivergenceExceededException => {
  let contents: any = {
    __type: "TipsDivergenceExceededException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1TitleRequiredException = (
  output: any,
  context: __SerdeContext
): TitleRequiredException => {
  let contents: any = {
    __type: "TitleRequiredException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1TooManyTagsException = (
  output: any,
  context: __SerdeContext
): TooManyTagsException => {
  let contents: any = {
    __type: "TooManyTagsException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1UpdateApprovalRuleTemplateContentOutput = (
  output: any,
  context: __SerdeContext
): UpdateApprovalRuleTemplateContentOutput => {
  let contents: any = {
    __type: "UpdateApprovalRuleTemplateContentOutput",
    approvalRuleTemplate: undefined
  };
  if (
    output.approvalRuleTemplate !== undefined &&
    output.approvalRuleTemplate !== null
  ) {
    contents.approvalRuleTemplate = deserializeAws_json1_1ApprovalRuleTemplate(
      output.approvalRuleTemplate,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1UpdateApprovalRuleTemplateDescriptionOutput = (
  output: any,
  context: __SerdeContext
): UpdateApprovalRuleTemplateDescriptionOutput => {
  let contents: any = {
    __type: "UpdateApprovalRuleTemplateDescriptionOutput",
    approvalRuleTemplate: undefined
  };
  if (
    output.approvalRuleTemplate !== undefined &&
    output.approvalRuleTemplate !== null
  ) {
    contents.approvalRuleTemplate = deserializeAws_json1_1ApprovalRuleTemplate(
      output.approvalRuleTemplate,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1UpdateApprovalRuleTemplateNameOutput = (
  output: any,
  context: __SerdeContext
): UpdateApprovalRuleTemplateNameOutput => {
  let contents: any = {
    __type: "UpdateApprovalRuleTemplateNameOutput",
    approvalRuleTemplate: undefined
  };
  if (
    output.approvalRuleTemplate !== undefined &&
    output.approvalRuleTemplate !== null
  ) {
    contents.approvalRuleTemplate = deserializeAws_json1_1ApprovalRuleTemplate(
      output.approvalRuleTemplate,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1UpdateCommentOutput = (
  output: any,
  context: __SerdeContext
): UpdateCommentOutput => {
  let contents: any = {
    __type: "UpdateCommentOutput",
    comment: undefined
  };
  if (output.comment !== undefined && output.comment !== null) {
    contents.comment = deserializeAws_json1_1Comment(output.comment, context);
  }
  return contents;
};

const deserializeAws_json1_1UpdatePullRequestApprovalRuleContentOutput = (
  output: any,
  context: __SerdeContext
): UpdatePullRequestApprovalRuleContentOutput => {
  let contents: any = {
    __type: "UpdatePullRequestApprovalRuleContentOutput",
    approvalRule: undefined
  };
  if (output.approvalRule !== undefined && output.approvalRule !== null) {
    contents.approvalRule = deserializeAws_json1_1ApprovalRule(
      output.approvalRule,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1UpdatePullRequestDescriptionOutput = (
  output: any,
  context: __SerdeContext
): UpdatePullRequestDescriptionOutput => {
  let contents: any = {
    __type: "UpdatePullRequestDescriptionOutput",
    pullRequest: undefined
  };
  if (output.pullRequest !== undefined && output.pullRequest !== null) {
    contents.pullRequest = deserializeAws_json1_1PullRequest(
      output.pullRequest,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1UpdatePullRequestStatusOutput = (
  output: any,
  context: __SerdeContext
): UpdatePullRequestStatusOutput => {
  let contents: any = {
    __type: "UpdatePullRequestStatusOutput",
    pullRequest: undefined
  };
  if (output.pullRequest !== undefined && output.pullRequest !== null) {
    contents.pullRequest = deserializeAws_json1_1PullRequest(
      output.pullRequest,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1UpdatePullRequestTitleOutput = (
  output: any,
  context: __SerdeContext
): UpdatePullRequestTitleOutput => {
  let contents: any = {
    __type: "UpdatePullRequestTitleOutput",
    pullRequest: undefined
  };
  if (output.pullRequest !== undefined && output.pullRequest !== null) {
    contents.pullRequest = deserializeAws_json1_1PullRequest(
      output.pullRequest,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1UserInfo = (
  output: any,
  context: __SerdeContext
): UserInfo => {
  let contents: any = {
    __type: "UserInfo",
    date: undefined,
    email: undefined,
    name: undefined
  };
  if (output.date !== undefined && output.date !== null) {
    contents.date = output.date;
  }
  if (output.email !== undefined && output.email !== null) {
    contents.email = output.email;
  }
  if (output.name !== undefined && output.name !== null) {
    contents.name = output.name;
  }
  return contents;
};

const deserializeMetadata = (output: __HttpResponse): __ResponseMetadata => ({
  httpStatusCode: output.statusCode,
  httpHeaders: output.headers,
  requestId: output.headers["x-amzn-requestid"]
});

// Collect low-level response body stream to Uint8Array.
const collectBody = (
  streamBody: any,
  context: __SerdeContext
): Promise<Uint8Array> => {
  if (streamBody instanceof Uint8Array) {
    return Promise.resolve(streamBody);
  }
  return (
    context.streamCollector(streamBody) || Promise.resolve(new Uint8Array())
  );
};

// Encode Uint8Array data into string with utf-8.
const collectBodyString = (
  streamBody: any,
  context: __SerdeContext
): Promise<string> => {
  return collectBody(streamBody, context).then(body =>
    context.utf8Encoder(body)
  );
};

const buildHttpRpcRequest = (
  context: __SerdeContext,
  headers: __HeaderBag,
  path: string,
  resolvedHostname: string | undefined,
  body: any
): __HttpRequest => {
  const contents: any = {
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: path,
    headers: headers
  };
  if (resolvedHostname !== undefined) {
    contents.hostname = resolvedHostname;
  }
  if (body !== undefined) {
    contents.body = body;
  }
  return new __HttpRequest(contents);
};

const parseBody = (streamBody: any, context: __SerdeContext): any => {
  return collectBodyString(streamBody, context).then(encoded => {
    if (encoded.length) {
      return JSON.parse(encoded);
    }
    return {};
  });
};
