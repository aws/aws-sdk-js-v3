// smithy-typescript generated code
import { HttpRequest as __HttpRequest, HttpResponse as __HttpResponse } from "@aws-sdk/protocol-http";
import {
  decorateServiceException as __decorateServiceException,
  expectBoolean as __expectBoolean,
  expectInt32 as __expectInt32,
  expectLong as __expectLong,
  expectNonNull as __expectNonNull,
  expectNumber as __expectNumber,
  expectString as __expectString,
  limitedParseDouble as __limitedParseDouble,
  parseEpochTimestamp as __parseEpochTimestamp,
  serializeFloat as __serializeFloat,
  throwDefaultError,
} from "@aws-sdk/smithy-client";
import {
  Endpoint as __Endpoint,
  HeaderBag as __HeaderBag,
  ResponseMetadata as __ResponseMetadata,
  SerdeContext as __SerdeContext,
} from "@aws-sdk/types";

import {
  BatchCreatePartitionCommandInput,
  BatchCreatePartitionCommandOutput,
} from "../commands/BatchCreatePartitionCommand";
import {
  BatchDeleteConnectionCommandInput,
  BatchDeleteConnectionCommandOutput,
} from "../commands/BatchDeleteConnectionCommand";
import {
  BatchDeletePartitionCommandInput,
  BatchDeletePartitionCommandOutput,
} from "../commands/BatchDeletePartitionCommand";
import { BatchDeleteTableCommandInput, BatchDeleteTableCommandOutput } from "../commands/BatchDeleteTableCommand";
import {
  BatchDeleteTableVersionCommandInput,
  BatchDeleteTableVersionCommandOutput,
} from "../commands/BatchDeleteTableVersionCommand";
import { BatchGetBlueprintsCommandInput, BatchGetBlueprintsCommandOutput } from "../commands/BatchGetBlueprintsCommand";
import { BatchGetCrawlersCommandInput, BatchGetCrawlersCommandOutput } from "../commands/BatchGetCrawlersCommand";
import {
  BatchGetCustomEntityTypesCommandInput,
  BatchGetCustomEntityTypesCommandOutput,
} from "../commands/BatchGetCustomEntityTypesCommand";
import {
  BatchGetDataQualityResultCommandInput,
  BatchGetDataQualityResultCommandOutput,
} from "../commands/BatchGetDataQualityResultCommand";
import {
  BatchGetDevEndpointsCommandInput,
  BatchGetDevEndpointsCommandOutput,
} from "../commands/BatchGetDevEndpointsCommand";
import { BatchGetJobsCommandInput, BatchGetJobsCommandOutput } from "../commands/BatchGetJobsCommand";
import { BatchGetPartitionCommandInput, BatchGetPartitionCommandOutput } from "../commands/BatchGetPartitionCommand";
import { BatchGetTriggersCommandInput, BatchGetTriggersCommandOutput } from "../commands/BatchGetTriggersCommand";
import { BatchGetWorkflowsCommandInput, BatchGetWorkflowsCommandOutput } from "../commands/BatchGetWorkflowsCommand";
import { BatchStopJobRunCommandInput, BatchStopJobRunCommandOutput } from "../commands/BatchStopJobRunCommand";
import {
  BatchUpdatePartitionCommandInput,
  BatchUpdatePartitionCommandOutput,
} from "../commands/BatchUpdatePartitionCommand";
import {
  CancelDataQualityRuleRecommendationRunCommandInput,
  CancelDataQualityRuleRecommendationRunCommandOutput,
} from "../commands/CancelDataQualityRuleRecommendationRunCommand";
import {
  CancelDataQualityRulesetEvaluationRunCommandInput,
  CancelDataQualityRulesetEvaluationRunCommandOutput,
} from "../commands/CancelDataQualityRulesetEvaluationRunCommand";
import { CancelMLTaskRunCommandInput, CancelMLTaskRunCommandOutput } from "../commands/CancelMLTaskRunCommand";
import { CancelStatementCommandInput, CancelStatementCommandOutput } from "../commands/CancelStatementCommand";
import {
  CheckSchemaVersionValidityCommandInput,
  CheckSchemaVersionValidityCommandOutput,
} from "../commands/CheckSchemaVersionValidityCommand";
import { CreateBlueprintCommandInput, CreateBlueprintCommandOutput } from "../commands/CreateBlueprintCommand";
import { CreateClassifierCommandInput, CreateClassifierCommandOutput } from "../commands/CreateClassifierCommand";
import { CreateConnectionCommandInput, CreateConnectionCommandOutput } from "../commands/CreateConnectionCommand";
import { CreateCrawlerCommandInput, CreateCrawlerCommandOutput } from "../commands/CreateCrawlerCommand";
import {
  CreateCustomEntityTypeCommandInput,
  CreateCustomEntityTypeCommandOutput,
} from "../commands/CreateCustomEntityTypeCommand";
import { CreateDatabaseCommandInput, CreateDatabaseCommandOutput } from "../commands/CreateDatabaseCommand";
import {
  CreateDataQualityRulesetCommandInput,
  CreateDataQualityRulesetCommandOutput,
} from "../commands/CreateDataQualityRulesetCommand";
import { CreateDevEndpointCommandInput, CreateDevEndpointCommandOutput } from "../commands/CreateDevEndpointCommand";
import { CreateJobCommandInput, CreateJobCommandOutput } from "../commands/CreateJobCommand";
import { CreateMLTransformCommandInput, CreateMLTransformCommandOutput } from "../commands/CreateMLTransformCommand";
import { CreatePartitionCommandInput, CreatePartitionCommandOutput } from "../commands/CreatePartitionCommand";
import {
  CreatePartitionIndexCommandInput,
  CreatePartitionIndexCommandOutput,
} from "../commands/CreatePartitionIndexCommand";
import { CreateRegistryCommandInput, CreateRegistryCommandOutput } from "../commands/CreateRegistryCommand";
import { CreateSchemaCommandInput, CreateSchemaCommandOutput } from "../commands/CreateSchemaCommand";
import { CreateScriptCommandInput, CreateScriptCommandOutput } from "../commands/CreateScriptCommand";
import {
  CreateSecurityConfigurationCommandInput,
  CreateSecurityConfigurationCommandOutput,
} from "../commands/CreateSecurityConfigurationCommand";
import { CreateSessionCommandInput, CreateSessionCommandOutput } from "../commands/CreateSessionCommand";
import { CreateTableCommandInput, CreateTableCommandOutput } from "../commands/CreateTableCommand";
import { CreateTriggerCommandInput, CreateTriggerCommandOutput } from "../commands/CreateTriggerCommand";
import {
  CreateUserDefinedFunctionCommandInput,
  CreateUserDefinedFunctionCommandOutput,
} from "../commands/CreateUserDefinedFunctionCommand";
import { CreateWorkflowCommandInput, CreateWorkflowCommandOutput } from "../commands/CreateWorkflowCommand";
import { DeleteBlueprintCommandInput, DeleteBlueprintCommandOutput } from "../commands/DeleteBlueprintCommand";
import { DeleteClassifierCommandInput, DeleteClassifierCommandOutput } from "../commands/DeleteClassifierCommand";
import {
  DeleteColumnStatisticsForPartitionCommandInput,
  DeleteColumnStatisticsForPartitionCommandOutput,
} from "../commands/DeleteColumnStatisticsForPartitionCommand";
import {
  DeleteColumnStatisticsForTableCommandInput,
  DeleteColumnStatisticsForTableCommandOutput,
} from "../commands/DeleteColumnStatisticsForTableCommand";
import { DeleteConnectionCommandInput, DeleteConnectionCommandOutput } from "../commands/DeleteConnectionCommand";
import { DeleteCrawlerCommandInput, DeleteCrawlerCommandOutput } from "../commands/DeleteCrawlerCommand";
import {
  DeleteCustomEntityTypeCommandInput,
  DeleteCustomEntityTypeCommandOutput,
} from "../commands/DeleteCustomEntityTypeCommand";
import { DeleteDatabaseCommandInput, DeleteDatabaseCommandOutput } from "../commands/DeleteDatabaseCommand";
import {
  DeleteDataQualityRulesetCommandInput,
  DeleteDataQualityRulesetCommandOutput,
} from "../commands/DeleteDataQualityRulesetCommand";
import { DeleteDevEndpointCommandInput, DeleteDevEndpointCommandOutput } from "../commands/DeleteDevEndpointCommand";
import { DeleteJobCommandInput, DeleteJobCommandOutput } from "../commands/DeleteJobCommand";
import { DeleteMLTransformCommandInput, DeleteMLTransformCommandOutput } from "../commands/DeleteMLTransformCommand";
import { DeletePartitionCommandInput, DeletePartitionCommandOutput } from "../commands/DeletePartitionCommand";
import {
  DeletePartitionIndexCommandInput,
  DeletePartitionIndexCommandOutput,
} from "../commands/DeletePartitionIndexCommand";
import { DeleteRegistryCommandInput, DeleteRegistryCommandOutput } from "../commands/DeleteRegistryCommand";
import {
  DeleteResourcePolicyCommandInput,
  DeleteResourcePolicyCommandOutput,
} from "../commands/DeleteResourcePolicyCommand";
import { DeleteSchemaCommandInput, DeleteSchemaCommandOutput } from "../commands/DeleteSchemaCommand";
import {
  DeleteSchemaVersionsCommandInput,
  DeleteSchemaVersionsCommandOutput,
} from "../commands/DeleteSchemaVersionsCommand";
import {
  DeleteSecurityConfigurationCommandInput,
  DeleteSecurityConfigurationCommandOutput,
} from "../commands/DeleteSecurityConfigurationCommand";
import { DeleteSessionCommandInput, DeleteSessionCommandOutput } from "../commands/DeleteSessionCommand";
import { DeleteTableCommandInput, DeleteTableCommandOutput } from "../commands/DeleteTableCommand";
import { DeleteTableVersionCommandInput, DeleteTableVersionCommandOutput } from "../commands/DeleteTableVersionCommand";
import { DeleteTriggerCommandInput, DeleteTriggerCommandOutput } from "../commands/DeleteTriggerCommand";
import {
  DeleteUserDefinedFunctionCommandInput,
  DeleteUserDefinedFunctionCommandOutput,
} from "../commands/DeleteUserDefinedFunctionCommand";
import { DeleteWorkflowCommandInput, DeleteWorkflowCommandOutput } from "../commands/DeleteWorkflowCommand";
import { GetBlueprintCommandInput, GetBlueprintCommandOutput } from "../commands/GetBlueprintCommand";
import { GetBlueprintRunCommandInput, GetBlueprintRunCommandOutput } from "../commands/GetBlueprintRunCommand";
import { GetBlueprintRunsCommandInput, GetBlueprintRunsCommandOutput } from "../commands/GetBlueprintRunsCommand";
import {
  GetCatalogImportStatusCommandInput,
  GetCatalogImportStatusCommandOutput,
} from "../commands/GetCatalogImportStatusCommand";
import { GetClassifierCommandInput, GetClassifierCommandOutput } from "../commands/GetClassifierCommand";
import { GetClassifiersCommandInput, GetClassifiersCommandOutput } from "../commands/GetClassifiersCommand";
import {
  GetColumnStatisticsForPartitionCommandInput,
  GetColumnStatisticsForPartitionCommandOutput,
} from "../commands/GetColumnStatisticsForPartitionCommand";
import {
  GetColumnStatisticsForTableCommandInput,
  GetColumnStatisticsForTableCommandOutput,
} from "../commands/GetColumnStatisticsForTableCommand";
import { GetConnectionCommandInput, GetConnectionCommandOutput } from "../commands/GetConnectionCommand";
import { GetConnectionsCommandInput, GetConnectionsCommandOutput } from "../commands/GetConnectionsCommand";
import { GetCrawlerCommandInput, GetCrawlerCommandOutput } from "../commands/GetCrawlerCommand";
import { GetCrawlerMetricsCommandInput, GetCrawlerMetricsCommandOutput } from "../commands/GetCrawlerMetricsCommand";
import { GetCrawlersCommandInput, GetCrawlersCommandOutput } from "../commands/GetCrawlersCommand";
import {
  GetCustomEntityTypeCommandInput,
  GetCustomEntityTypeCommandOutput,
} from "../commands/GetCustomEntityTypeCommand";
import { GetDatabaseCommandInput, GetDatabaseCommandOutput } from "../commands/GetDatabaseCommand";
import { GetDatabasesCommandInput, GetDatabasesCommandOutput } from "../commands/GetDatabasesCommand";
import {
  GetDataCatalogEncryptionSettingsCommandInput,
  GetDataCatalogEncryptionSettingsCommandOutput,
} from "../commands/GetDataCatalogEncryptionSettingsCommand";
import { GetDataflowGraphCommandInput, GetDataflowGraphCommandOutput } from "../commands/GetDataflowGraphCommand";
import {
  GetDataQualityResultCommandInput,
  GetDataQualityResultCommandOutput,
} from "../commands/GetDataQualityResultCommand";
import {
  GetDataQualityRuleRecommendationRunCommandInput,
  GetDataQualityRuleRecommendationRunCommandOutput,
} from "../commands/GetDataQualityRuleRecommendationRunCommand";
import {
  GetDataQualityRulesetCommandInput,
  GetDataQualityRulesetCommandOutput,
} from "../commands/GetDataQualityRulesetCommand";
import {
  GetDataQualityRulesetEvaluationRunCommandInput,
  GetDataQualityRulesetEvaluationRunCommandOutput,
} from "../commands/GetDataQualityRulesetEvaluationRunCommand";
import { GetDevEndpointCommandInput, GetDevEndpointCommandOutput } from "../commands/GetDevEndpointCommand";
import { GetDevEndpointsCommandInput, GetDevEndpointsCommandOutput } from "../commands/GetDevEndpointsCommand";
import { GetJobBookmarkCommandInput, GetJobBookmarkCommandOutput } from "../commands/GetJobBookmarkCommand";
import { GetJobCommandInput, GetJobCommandOutput } from "../commands/GetJobCommand";
import { GetJobRunCommandInput, GetJobRunCommandOutput } from "../commands/GetJobRunCommand";
import { GetJobRunsCommandInput, GetJobRunsCommandOutput } from "../commands/GetJobRunsCommand";
import { GetJobsCommandInput, GetJobsCommandOutput } from "../commands/GetJobsCommand";
import { GetMappingCommandInput, GetMappingCommandOutput } from "../commands/GetMappingCommand";
import { GetMLTaskRunCommandInput, GetMLTaskRunCommandOutput } from "../commands/GetMLTaskRunCommand";
import { GetMLTaskRunsCommandInput, GetMLTaskRunsCommandOutput } from "../commands/GetMLTaskRunsCommand";
import { GetMLTransformCommandInput, GetMLTransformCommandOutput } from "../commands/GetMLTransformCommand";
import { GetMLTransformsCommandInput, GetMLTransformsCommandOutput } from "../commands/GetMLTransformsCommand";
import { GetPartitionCommandInput, GetPartitionCommandOutput } from "../commands/GetPartitionCommand";
import {
  GetPartitionIndexesCommandInput,
  GetPartitionIndexesCommandOutput,
} from "../commands/GetPartitionIndexesCommand";
import { GetPartitionsCommandInput, GetPartitionsCommandOutput } from "../commands/GetPartitionsCommand";
import { GetPlanCommandInput, GetPlanCommandOutput } from "../commands/GetPlanCommand";
import { GetRegistryCommandInput, GetRegistryCommandOutput } from "../commands/GetRegistryCommand";
import {
  GetResourcePoliciesCommandInput,
  GetResourcePoliciesCommandOutput,
} from "../commands/GetResourcePoliciesCommand";
import { GetResourcePolicyCommandInput, GetResourcePolicyCommandOutput } from "../commands/GetResourcePolicyCommand";
import {
  GetSchemaByDefinitionCommandInput,
  GetSchemaByDefinitionCommandOutput,
} from "../commands/GetSchemaByDefinitionCommand";
import { GetSchemaCommandInput, GetSchemaCommandOutput } from "../commands/GetSchemaCommand";
import { GetSchemaVersionCommandInput, GetSchemaVersionCommandOutput } from "../commands/GetSchemaVersionCommand";
import {
  GetSchemaVersionsDiffCommandInput,
  GetSchemaVersionsDiffCommandOutput,
} from "../commands/GetSchemaVersionsDiffCommand";
import {
  GetSecurityConfigurationCommandInput,
  GetSecurityConfigurationCommandOutput,
} from "../commands/GetSecurityConfigurationCommand";
import {
  GetSecurityConfigurationsCommandInput,
  GetSecurityConfigurationsCommandOutput,
} from "../commands/GetSecurityConfigurationsCommand";
import { GetSessionCommandInput, GetSessionCommandOutput } from "../commands/GetSessionCommand";
import { GetStatementCommandInput, GetStatementCommandOutput } from "../commands/GetStatementCommand";
import { GetTableCommandInput, GetTableCommandOutput } from "../commands/GetTableCommand";
import { GetTablesCommandInput, GetTablesCommandOutput } from "../commands/GetTablesCommand";
import { GetTableVersionCommandInput, GetTableVersionCommandOutput } from "../commands/GetTableVersionCommand";
import { GetTableVersionsCommandInput, GetTableVersionsCommandOutput } from "../commands/GetTableVersionsCommand";
import { GetTagsCommandInput, GetTagsCommandOutput } from "../commands/GetTagsCommand";
import { GetTriggerCommandInput, GetTriggerCommandOutput } from "../commands/GetTriggerCommand";
import { GetTriggersCommandInput, GetTriggersCommandOutput } from "../commands/GetTriggersCommand";
import {
  GetUnfilteredPartitionMetadataCommandInput,
  GetUnfilteredPartitionMetadataCommandOutput,
} from "../commands/GetUnfilteredPartitionMetadataCommand";
import {
  GetUnfilteredPartitionsMetadataCommandInput,
  GetUnfilteredPartitionsMetadataCommandOutput,
} from "../commands/GetUnfilteredPartitionsMetadataCommand";
import {
  GetUnfilteredTableMetadataCommandInput,
  GetUnfilteredTableMetadataCommandOutput,
} from "../commands/GetUnfilteredTableMetadataCommand";
import {
  GetUserDefinedFunctionCommandInput,
  GetUserDefinedFunctionCommandOutput,
} from "../commands/GetUserDefinedFunctionCommand";
import {
  GetUserDefinedFunctionsCommandInput,
  GetUserDefinedFunctionsCommandOutput,
} from "../commands/GetUserDefinedFunctionsCommand";
import { GetWorkflowCommandInput, GetWorkflowCommandOutput } from "../commands/GetWorkflowCommand";
import { GetWorkflowRunCommandInput, GetWorkflowRunCommandOutput } from "../commands/GetWorkflowRunCommand";
import {
  GetWorkflowRunPropertiesCommandInput,
  GetWorkflowRunPropertiesCommandOutput,
} from "../commands/GetWorkflowRunPropertiesCommand";
import { GetWorkflowRunsCommandInput, GetWorkflowRunsCommandOutput } from "../commands/GetWorkflowRunsCommand";
import {
  ImportCatalogToGlueCommandInput,
  ImportCatalogToGlueCommandOutput,
} from "../commands/ImportCatalogToGlueCommand";
import { ListBlueprintsCommandInput, ListBlueprintsCommandOutput } from "../commands/ListBlueprintsCommand";
import { ListCrawlersCommandInput, ListCrawlersCommandOutput } from "../commands/ListCrawlersCommand";
import { ListCrawlsCommandInput, ListCrawlsCommandOutput } from "../commands/ListCrawlsCommand";
import {
  ListCustomEntityTypesCommandInput,
  ListCustomEntityTypesCommandOutput,
} from "../commands/ListCustomEntityTypesCommand";
import {
  ListDataQualityResultsCommandInput,
  ListDataQualityResultsCommandOutput,
} from "../commands/ListDataQualityResultsCommand";
import {
  ListDataQualityRuleRecommendationRunsCommandInput,
  ListDataQualityRuleRecommendationRunsCommandOutput,
} from "../commands/ListDataQualityRuleRecommendationRunsCommand";
import {
  ListDataQualityRulesetEvaluationRunsCommandInput,
  ListDataQualityRulesetEvaluationRunsCommandOutput,
} from "../commands/ListDataQualityRulesetEvaluationRunsCommand";
import {
  ListDataQualityRulesetsCommandInput,
  ListDataQualityRulesetsCommandOutput,
} from "../commands/ListDataQualityRulesetsCommand";
import { ListDevEndpointsCommandInput, ListDevEndpointsCommandOutput } from "../commands/ListDevEndpointsCommand";
import { ListJobsCommandInput, ListJobsCommandOutput } from "../commands/ListJobsCommand";
import { ListMLTransformsCommandInput, ListMLTransformsCommandOutput } from "../commands/ListMLTransformsCommand";
import { ListRegistriesCommandInput, ListRegistriesCommandOutput } from "../commands/ListRegistriesCommand";
import { ListSchemasCommandInput, ListSchemasCommandOutput } from "../commands/ListSchemasCommand";
import { ListSchemaVersionsCommandInput, ListSchemaVersionsCommandOutput } from "../commands/ListSchemaVersionsCommand";
import { ListSessionsCommandInput, ListSessionsCommandOutput } from "../commands/ListSessionsCommand";
import { ListStatementsCommandInput, ListStatementsCommandOutput } from "../commands/ListStatementsCommand";
import { ListTriggersCommandInput, ListTriggersCommandOutput } from "../commands/ListTriggersCommand";
import { ListWorkflowsCommandInput, ListWorkflowsCommandOutput } from "../commands/ListWorkflowsCommand";
import {
  PutDataCatalogEncryptionSettingsCommandInput,
  PutDataCatalogEncryptionSettingsCommandOutput,
} from "../commands/PutDataCatalogEncryptionSettingsCommand";
import { PutResourcePolicyCommandInput, PutResourcePolicyCommandOutput } from "../commands/PutResourcePolicyCommand";
import {
  PutSchemaVersionMetadataCommandInput,
  PutSchemaVersionMetadataCommandOutput,
} from "../commands/PutSchemaVersionMetadataCommand";
import {
  PutWorkflowRunPropertiesCommandInput,
  PutWorkflowRunPropertiesCommandOutput,
} from "../commands/PutWorkflowRunPropertiesCommand";
import {
  QuerySchemaVersionMetadataCommandInput,
  QuerySchemaVersionMetadataCommandOutput,
} from "../commands/QuerySchemaVersionMetadataCommand";
import {
  RegisterSchemaVersionCommandInput,
  RegisterSchemaVersionCommandOutput,
} from "../commands/RegisterSchemaVersionCommand";
import {
  RemoveSchemaVersionMetadataCommandInput,
  RemoveSchemaVersionMetadataCommandOutput,
} from "../commands/RemoveSchemaVersionMetadataCommand";
import { ResetJobBookmarkCommandInput, ResetJobBookmarkCommandOutput } from "../commands/ResetJobBookmarkCommand";
import { ResumeWorkflowRunCommandInput, ResumeWorkflowRunCommandOutput } from "../commands/ResumeWorkflowRunCommand";
import { RunStatementCommandInput, RunStatementCommandOutput } from "../commands/RunStatementCommand";
import { SearchTablesCommandInput, SearchTablesCommandOutput } from "../commands/SearchTablesCommand";
import { StartBlueprintRunCommandInput, StartBlueprintRunCommandOutput } from "../commands/StartBlueprintRunCommand";
import { StartCrawlerCommandInput, StartCrawlerCommandOutput } from "../commands/StartCrawlerCommand";
import {
  StartCrawlerScheduleCommandInput,
  StartCrawlerScheduleCommandOutput,
} from "../commands/StartCrawlerScheduleCommand";
import {
  StartDataQualityRuleRecommendationRunCommandInput,
  StartDataQualityRuleRecommendationRunCommandOutput,
} from "../commands/StartDataQualityRuleRecommendationRunCommand";
import {
  StartDataQualityRulesetEvaluationRunCommandInput,
  StartDataQualityRulesetEvaluationRunCommandOutput,
} from "../commands/StartDataQualityRulesetEvaluationRunCommand";
import {
  StartExportLabelsTaskRunCommandInput,
  StartExportLabelsTaskRunCommandOutput,
} from "../commands/StartExportLabelsTaskRunCommand";
import {
  StartImportLabelsTaskRunCommandInput,
  StartImportLabelsTaskRunCommandOutput,
} from "../commands/StartImportLabelsTaskRunCommand";
import { StartJobRunCommandInput, StartJobRunCommandOutput } from "../commands/StartJobRunCommand";
import {
  StartMLEvaluationTaskRunCommandInput,
  StartMLEvaluationTaskRunCommandOutput,
} from "../commands/StartMLEvaluationTaskRunCommand";
import {
  StartMLLabelingSetGenerationTaskRunCommandInput,
  StartMLLabelingSetGenerationTaskRunCommandOutput,
} from "../commands/StartMLLabelingSetGenerationTaskRunCommand";
import { StartTriggerCommandInput, StartTriggerCommandOutput } from "../commands/StartTriggerCommand";
import { StartWorkflowRunCommandInput, StartWorkflowRunCommandOutput } from "../commands/StartWorkflowRunCommand";
import { StopCrawlerCommandInput, StopCrawlerCommandOutput } from "../commands/StopCrawlerCommand";
import {
  StopCrawlerScheduleCommandInput,
  StopCrawlerScheduleCommandOutput,
} from "../commands/StopCrawlerScheduleCommand";
import { StopSessionCommandInput, StopSessionCommandOutput } from "../commands/StopSessionCommand";
import { StopTriggerCommandInput, StopTriggerCommandOutput } from "../commands/StopTriggerCommand";
import { StopWorkflowRunCommandInput, StopWorkflowRunCommandOutput } from "../commands/StopWorkflowRunCommand";
import { TagResourceCommandInput, TagResourceCommandOutput } from "../commands/TagResourceCommand";
import { UntagResourceCommandInput, UntagResourceCommandOutput } from "../commands/UntagResourceCommand";
import { UpdateBlueprintCommandInput, UpdateBlueprintCommandOutput } from "../commands/UpdateBlueprintCommand";
import { UpdateClassifierCommandInput, UpdateClassifierCommandOutput } from "../commands/UpdateClassifierCommand";
import {
  UpdateColumnStatisticsForPartitionCommandInput,
  UpdateColumnStatisticsForPartitionCommandOutput,
} from "../commands/UpdateColumnStatisticsForPartitionCommand";
import {
  UpdateColumnStatisticsForTableCommandInput,
  UpdateColumnStatisticsForTableCommandOutput,
} from "../commands/UpdateColumnStatisticsForTableCommand";
import { UpdateConnectionCommandInput, UpdateConnectionCommandOutput } from "../commands/UpdateConnectionCommand";
import { UpdateCrawlerCommandInput, UpdateCrawlerCommandOutput } from "../commands/UpdateCrawlerCommand";
import {
  UpdateCrawlerScheduleCommandInput,
  UpdateCrawlerScheduleCommandOutput,
} from "../commands/UpdateCrawlerScheduleCommand";
import { UpdateDatabaseCommandInput, UpdateDatabaseCommandOutput } from "../commands/UpdateDatabaseCommand";
import {
  UpdateDataQualityRulesetCommandInput,
  UpdateDataQualityRulesetCommandOutput,
} from "../commands/UpdateDataQualityRulesetCommand";
import { UpdateDevEndpointCommandInput, UpdateDevEndpointCommandOutput } from "../commands/UpdateDevEndpointCommand";
import { UpdateJobCommandInput, UpdateJobCommandOutput } from "../commands/UpdateJobCommand";
import {
  UpdateJobFromSourceControlCommandInput,
  UpdateJobFromSourceControlCommandOutput,
} from "../commands/UpdateJobFromSourceControlCommand";
import { UpdateMLTransformCommandInput, UpdateMLTransformCommandOutput } from "../commands/UpdateMLTransformCommand";
import { UpdatePartitionCommandInput, UpdatePartitionCommandOutput } from "../commands/UpdatePartitionCommand";
import { UpdateRegistryCommandInput, UpdateRegistryCommandOutput } from "../commands/UpdateRegistryCommand";
import { UpdateSchemaCommandInput, UpdateSchemaCommandOutput } from "../commands/UpdateSchemaCommand";
import {
  UpdateSourceControlFromJobCommandInput,
  UpdateSourceControlFromJobCommandOutput,
} from "../commands/UpdateSourceControlFromJobCommand";
import { UpdateTableCommandInput, UpdateTableCommandOutput } from "../commands/UpdateTableCommand";
import { UpdateTriggerCommandInput, UpdateTriggerCommandOutput } from "../commands/UpdateTriggerCommand";
import {
  UpdateUserDefinedFunctionCommandInput,
  UpdateUserDefinedFunctionCommandOutput,
} from "../commands/UpdateUserDefinedFunctionCommand";
import { UpdateWorkflowCommandInput, UpdateWorkflowCommandOutput } from "../commands/UpdateWorkflowCommand";
import { GlueServiceException as __BaseException } from "../models/GlueServiceException";
import {
  AccessDeniedException,
  Action,
  Aggregate,
  AggregateOperation,
  AlreadyExistsException,
  AthenaConnectorSource,
  AuditContext,
  BasicCatalogTarget,
  BatchCreatePartitionRequest,
  BatchCreatePartitionResponse,
  BatchDeleteConnectionRequest,
  BatchDeleteConnectionResponse,
  BatchDeletePartitionRequest,
  BatchDeletePartitionResponse,
  BatchDeleteTableRequest,
  BatchDeleteTableResponse,
  BatchDeleteTableVersionRequest,
  BatchDeleteTableVersionResponse,
  BatchGetBlueprintsRequest,
  BatchGetBlueprintsResponse,
  BatchGetCrawlersRequest,
  BatchGetCrawlersResponse,
  BatchGetCustomEntityTypesRequest,
  BatchGetCustomEntityTypesResponse,
  BatchGetDataQualityResultRequest,
  BatchGetDataQualityResultResponse,
  BatchGetDevEndpointsRequest,
  BatchGetDevEndpointsResponse,
  BatchGetJobsRequest,
  BatchGetPartitionRequest,
  BatchGetPartitionResponse,
  BatchGetTriggersRequest,
  BatchGetTriggersResponse,
  BatchGetWorkflowsRequest,
  BatchGetWorkflowsResponse,
  BatchStopJobRunError,
  BatchStopJobRunRequest,
  BatchStopJobRunResponse,
  BatchStopJobRunSuccessfulSubmission,
  BatchUpdatePartitionFailureEntry,
  BatchUpdatePartitionRequest,
  BatchUpdatePartitionRequestEntry,
  BatchUpdatePartitionResponse,
  Blueprint,
  BlueprintDetails,
  CancelDataQualityRuleRecommendationRunRequest,
  CancelDataQualityRuleRecommendationRunResponse,
  CancelDataQualityRulesetEvaluationRunRequest,
  CancelDataQualityRulesetEvaluationRunResponse,
  CancelMLTaskRunRequest,
  CancelMLTaskRunResponse,
  CancelStatementRequest,
  CancelStatementResponse,
  CatalogDeltaSource,
  CatalogHudiSource,
  CatalogKafkaSource,
  CatalogKinesisSource,
  CatalogSchemaChangePolicy,
  CatalogSource,
  CatalogTarget,
  CheckSchemaVersionValidityInput,
  CheckSchemaVersionValidityResponse,
  Column,
  ConcurrentModificationException,
  Condition,
  ConnectionInput,
  ConnectionPropertyKey,
  ConnectionsList,
  Crawl,
  Crawler,
  CrawlerNodeDetails,
  CrawlerTargets,
  CreateBlueprintRequest,
  CreateBlueprintResponse,
  CreateClassifierRequest,
  CreateClassifierResponse,
  CreateConnectionRequest,
  CreateConnectionResponse,
  CreateCrawlerRequest,
  CreateCrawlerResponse,
  CreateCsvClassifierRequest,
  CreateCustomEntityTypeRequest,
  CreateCustomEntityTypeResponse,
  CreateDatabaseRequest,
  CreateDatabaseResponse,
  CreateDataQualityRulesetRequest,
  CreateDataQualityRulesetResponse,
  CreateDevEndpointRequest,
  CreateDevEndpointResponse,
  CreateGrokClassifierRequest,
  CreateJobResponse,
  CreateJsonClassifierRequest,
  CreateMLTransformRequest,
  CreateMLTransformResponse,
  CreatePartitionIndexRequest,
  CreatePartitionIndexResponse,
  CreatePartitionRequest,
  CreatePartitionResponse,
  CreateXMLClassifierRequest,
  CustomCode,
  CustomEntityType,
  DatabaseIdentifier,
  DatabaseInput,
  DataLakePrincipal,
  DataQualityResult,
  DataQualityRuleResult,
  DataQualityTargetTable,
  DataSource,
  Datatype,
  DeltaTarget,
  DevEndpoint,
  DirectJDBCSource,
  DirectKafkaSource,
  DirectKinesisSource,
  DirectSchemaChangePolicy,
  DQResultsPublishingOptions,
  DQStopJobOnFailureOptions,
  DropDuplicates,
  DropFields,
  DropNullFields,
  DynamicTransform,
  DynamoDBCatalogSource,
  DynamoDBTarget,
  Edge,
  EntityNotFoundException,
  ErrorDetail,
  EvaluateDataQuality,
  EventBatchingCondition,
  ExecutionProperty,
  FederatedDatabase,
  FederatedResourceAlreadyExistsException,
  FederationSourceException,
  FederationSourceRetryableException,
  FillMissingValues,
  Filter,
  FilterExpression,
  FilterValue,
  FindMatchesParameters,
  GlueEncryptionException,
  GlueRecordType,
  GlueSchema,
  GlueStudioSchemaColumn,
  GlueTable,
  GovernedCatalogSource,
  GovernedCatalogTarget,
  IdempotentParameterMismatchException,
  IllegalSessionStateException,
  InternalServiceException,
  InvalidInputException,
  InvalidStateException,
  JDBCConnectorOptions,
  JDBCConnectorSource,
  JDBCConnectorTarget,
  JDBCDataType,
  JdbcMetadataEntry,
  JdbcTarget,
  JobCommand,
  JobNodeDetails,
  JobRun,
  Join,
  JoinColumn,
  KafkaStreamingSourceOptions,
  KinesisStreamingSourceOptions,
  LakeFormationConfiguration,
  LastActiveDefinition,
  LastCrawlInfo,
  LineageConfiguration,
  Merge,
  MicrosoftSQLServerCatalogSource,
  MicrosoftSQLServerCatalogTarget,
  MLUserDataEncryption,
  MongoDBTarget,
  MySQLCatalogSource,
  MySQLCatalogTarget,
  Node,
  NotificationProperty,
  NullCheckBoxList,
  NullValueField,
  OperationTimeoutException,
  OracleSQLCatalogSource,
  OracleSQLCatalogTarget,
  Order,
  Partition,
  PartitionError,
  PartitionIndex,
  PartitionInput,
  PartitionValueList,
  Permission,
  PhysicalConnectionRequirements,
  PIIDetection,
  PostgreSQLCatalogSource,
  PostgreSQLCatalogTarget,
  Predecessor,
  Predicate,
  PrincipalPermissions,
  RecrawlPolicy,
  RedshiftSource,
  RedshiftTarget,
  RelationalCatalogSource,
  RenameField,
  ResourceNotReadyException,
  ResourceNumberLimitExceededException,
  S3CatalogDeltaSource,
  S3CatalogHudiSource,
  S3CatalogSource,
  S3CatalogTarget,
  S3CsvSource,
  S3DeltaCatalogTarget,
  S3DeltaDirectTarget,
  S3DeltaSource,
  S3DirectSourceAdditionalOptions,
  S3DirectTarget,
  S3GlueParquetTarget,
  S3HudiCatalogTarget,
  S3HudiDirectTarget,
  S3HudiSource,
  S3JsonSource,
  S3ParquetSource,
  S3SourceAdditionalOptions,
  S3Target,
  Schedule,
  SchemaChangePolicy,
  SchemaId,
  SchemaReference,
  SelectFields,
  SelectFromCollection,
  SerDeInfo,
  SkewedInfo,
  SourceControlDetails,
  SparkConnectorSource,
  SparkConnectorTarget,
  SparkSQL,
  Spigot,
  SplitFields,
  SqlAlias,
  StartingEventBatchCondition,
  StorageDescriptor,
  StreamingDataPreviewOptions,
  TableError,
  TableVersionError,
  TransformConfigParameter,
  TransformEncryption,
  TransformParameters,
  Trigger,
  TriggerNodeDetails,
  Union,
  UpsertRedshiftTargetOptions,
  ValidationException,
  Workflow,
  WorkflowGraph,
  WorkflowRun,
  WorkflowRunStatistics,
} from "../models/models_0";
import {
  BackfillError,
  BinaryColumnStatisticsData,
  BlueprintRun,
  BooleanColumnStatisticsData,
  CatalogEntry,
  CatalogImportStatus,
  Classifier,
  CloudWatchEncryption,
  CodeGenEdge,
  CodeGenNode,
  CodeGenNodeArg,
  ColumnError,
  ColumnImportance,
  ColumnRowFilter,
  ColumnStatistics,
  ColumnStatisticsData,
  ConditionCheckFailureException,
  ConflictException,
  ConfusionMatrix,
  Connection,
  ConnectionPasswordEncryption,
  CrawlerMetrics,
  CrawlerRunningException,
  CreateRegistryInput,
  CreateRegistryResponse,
  CreateSchemaInput,
  CreateSchemaResponse,
  CreateScriptRequest,
  CreateScriptResponse,
  CreateSecurityConfigurationRequest,
  CreateSecurityConfigurationResponse,
  CreateSessionRequest,
  CreateSessionResponse,
  CreateTableRequest,
  CreateTableResponse,
  CreateTriggerRequest,
  CreateTriggerResponse,
  CreateUserDefinedFunctionRequest,
  CreateUserDefinedFunctionResponse,
  CreateWorkflowRequest,
  CreateWorkflowResponse,
  CsvClassifier,
  Database,
  DataCatalogEncryptionSettings,
  DataQualityEvaluationRunAdditionalRunOptions,
  DateColumnStatisticsData,
  DecimalColumnStatisticsData,
  DecimalNumber,
  DeleteBlueprintRequest,
  DeleteBlueprintResponse,
  DeleteClassifierRequest,
  DeleteClassifierResponse,
  DeleteColumnStatisticsForPartitionRequest,
  DeleteColumnStatisticsForPartitionResponse,
  DeleteColumnStatisticsForTableRequest,
  DeleteColumnStatisticsForTableResponse,
  DeleteConnectionRequest,
  DeleteConnectionResponse,
  DeleteCrawlerRequest,
  DeleteCrawlerResponse,
  DeleteCustomEntityTypeRequest,
  DeleteCustomEntityTypeResponse,
  DeleteDatabaseRequest,
  DeleteDatabaseResponse,
  DeleteDataQualityRulesetRequest,
  DeleteDataQualityRulesetResponse,
  DeleteDevEndpointRequest,
  DeleteDevEndpointResponse,
  DeleteJobRequest,
  DeleteJobResponse,
  DeleteMLTransformRequest,
  DeleteMLTransformResponse,
  DeletePartitionIndexRequest,
  DeletePartitionIndexResponse,
  DeletePartitionRequest,
  DeletePartitionResponse,
  DeleteRegistryInput,
  DeleteRegistryResponse,
  DeleteResourcePolicyRequest,
  DeleteResourcePolicyResponse,
  DeleteSchemaInput,
  DeleteSchemaResponse,
  DeleteSchemaVersionsInput,
  DeleteSchemaVersionsResponse,
  DeleteSecurityConfigurationRequest,
  DeleteSecurityConfigurationResponse,
  DeleteSessionRequest,
  DeleteSessionResponse,
  DeleteTableRequest,
  DeleteTableResponse,
  DeleteTableVersionRequest,
  DeleteTableVersionResponse,
  DeleteTriggerRequest,
  DeleteTriggerResponse,
  DeleteUserDefinedFunctionRequest,
  DeleteUserDefinedFunctionResponse,
  DeleteWorkflowRequest,
  DeleteWorkflowResponse,
  DoubleColumnStatisticsData,
  EncryptionAtRest,
  EncryptionConfiguration,
  ErrorDetails,
  EvaluationMetrics,
  ExportLabelsTaskRunProperties,
  FederatedTable,
  FindMatchesMetrics,
  FindMatchesTaskRunProperties,
  GetBlueprintRequest,
  GetBlueprintResponse,
  GetBlueprintRunRequest,
  GetBlueprintRunResponse,
  GetBlueprintRunsRequest,
  GetBlueprintRunsResponse,
  GetCatalogImportStatusRequest,
  GetCatalogImportStatusResponse,
  GetClassifierRequest,
  GetClassifierResponse,
  GetClassifiersRequest,
  GetClassifiersResponse,
  GetColumnStatisticsForPartitionRequest,
  GetColumnStatisticsForPartitionResponse,
  GetColumnStatisticsForTableRequest,
  GetColumnStatisticsForTableResponse,
  GetConnectionRequest,
  GetConnectionResponse,
  GetConnectionsFilter,
  GetConnectionsRequest,
  GetConnectionsResponse,
  GetCrawlerMetricsRequest,
  GetCrawlerMetricsResponse,
  GetCrawlerRequest,
  GetCrawlerResponse,
  GetCrawlersRequest,
  GetCrawlersResponse,
  GetCustomEntityTypeRequest,
  GetCustomEntityTypeResponse,
  GetDatabaseRequest,
  GetDatabaseResponse,
  GetDatabasesRequest,
  GetDatabasesResponse,
  GetDataCatalogEncryptionSettingsRequest,
  GetDataCatalogEncryptionSettingsResponse,
  GetDataflowGraphRequest,
  GetDataflowGraphResponse,
  GetDataQualityResultRequest,
  GetDataQualityResultResponse,
  GetDataQualityRuleRecommendationRunRequest,
  GetDataQualityRuleRecommendationRunResponse,
  GetDataQualityRulesetEvaluationRunRequest,
  GetDataQualityRulesetEvaluationRunResponse,
  GetDataQualityRulesetRequest,
  GetDataQualityRulesetResponse,
  GetDevEndpointRequest,
  GetDevEndpointResponse,
  GetDevEndpointsRequest,
  GetDevEndpointsResponse,
  GetJobBookmarkRequest,
  GetJobBookmarkResponse,
  GetJobRequest,
  GetJobRunRequest,
  GetJobRunResponse,
  GetJobRunsRequest,
  GetJobRunsResponse,
  GetJobsRequest,
  GetMappingRequest,
  GetMappingResponse,
  GetMLTaskRunRequest,
  GetMLTaskRunResponse,
  GetMLTaskRunsRequest,
  GetMLTaskRunsResponse,
  GetMLTransformRequest,
  GetMLTransformResponse,
  GetMLTransformsRequest,
  GetMLTransformsResponse,
  GetPartitionIndexesRequest,
  GetPartitionIndexesResponse,
  GetPartitionRequest,
  GetPartitionResponse,
  GetPartitionsRequest,
  GetPartitionsResponse,
  GetPlanRequest,
  GetPlanResponse,
  GetRegistryInput,
  GetRegistryResponse,
  GetResourcePoliciesRequest,
  GetResourcePoliciesResponse,
  GetResourcePolicyRequest,
  GetResourcePolicyResponse,
  GetSchemaByDefinitionInput,
  GetSchemaByDefinitionResponse,
  GetSchemaInput,
  GetSchemaResponse,
  GetSchemaVersionInput,
  GetSchemaVersionResponse,
  GetSchemaVersionsDiffInput,
  GetSchemaVersionsDiffResponse,
  GetSecurityConfigurationRequest,
  GetSecurityConfigurationResponse,
  GetSecurityConfigurationsRequest,
  GetSecurityConfigurationsResponse,
  GetSessionRequest,
  GetSessionResponse,
  GetStatementRequest,
  GetStatementResponse,
  GetTableRequest,
  GetTableResponse,
  GetTablesRequest,
  GetTablesResponse,
  GetTableVersionRequest,
  GetTableVersionResponse,
  GetTableVersionsRequest,
  GetTableVersionsResponse,
  GetTagsRequest,
  GetTagsResponse,
  GetTriggerRequest,
  GetTriggerResponse,
  GetTriggersRequest,
  GetTriggersResponse,
  GetUnfilteredPartitionMetadataRequest,
  GetUnfilteredPartitionMetadataResponse,
  GetUnfilteredPartitionsMetadataRequest,
  GetUnfilteredPartitionsMetadataResponse,
  GetUnfilteredTableMetadataRequest,
  GetUnfilteredTableMetadataResponse,
  GetUserDefinedFunctionRequest,
  GetUserDefinedFunctionResponse,
  GetUserDefinedFunctionsRequest,
  GetUserDefinedFunctionsResponse,
  GetWorkflowRequest,
  GetWorkflowResponse,
  GetWorkflowRunRequest,
  GetWorkflowRunResponse,
  GluePolicy,
  GrokClassifier,
  ImportLabelsTaskRunProperties,
  JobBookmarkEntry,
  JobBookmarksEncryption,
  JsonClassifier,
  KeySchemaElement,
  LabelingSetGenerationTaskRunProperties,
  Location,
  LongColumnStatisticsData,
  MappingEntry,
  MLTransform,
  PartitionIndexDescriptor,
  PermissionType,
  PermissionTypeMismatchException,
  RegistryId,
  ResourceUri,
  S3Encryption,
  SchedulerTransitioningException,
  SchemaColumn,
  SchemaVersionErrorItem,
  SchemaVersionNumber,
  SecurityConfiguration,
  Segment,
  Session,
  SessionCommand,
  Statement,
  StatementOutput,
  StatementOutputData,
  StringColumnStatisticsData,
  Table,
  TableIdentifier,
  TableInput,
  TableVersion,
  TaskRun,
  TaskRunFilterCriteria,
  TaskRunProperties,
  TaskRunSortCriteria,
  TransformFilterCriteria,
  TransformSortCriteria,
  UnfilteredPartition,
  UserDefinedFunction,
  UserDefinedFunctionInput,
  XMLClassifier,
} from "../models/models_1";
import {
  ApplyMapping,
  BatchGetJobsResponse,
  CodeGenConfigurationNode,
  ColumnStatisticsError,
  ConcurrentRunsExceededException,
  CrawlerHistory,
  CrawlerNotRunningException,
  CrawlerStoppingException,
  CrawlsFilter,
  CreateJobRequest,
  DataQualityResultDescription,
  DataQualityResultFilterCriteria,
  DataQualityRuleRecommendationRunDescription,
  DataQualityRuleRecommendationRunFilter,
  DataQualityRulesetEvaluationRunDescription,
  DataQualityRulesetEvaluationRunFilter,
  DataQualityRulesetFilterCriteria,
  DataQualityRulesetListDetails,
  DevEndpointCustomLibraries,
  GetJobResponse,
  GetJobsResponse,
  GetWorkflowRunPropertiesRequest,
  GetWorkflowRunPropertiesResponse,
  GetWorkflowRunsRequest,
  GetWorkflowRunsResponse,
  IllegalBlueprintStateException,
  IllegalWorkflowStateException,
  ImportCatalogToGlueRequest,
  ImportCatalogToGlueResponse,
  Job,
  JobUpdate,
  ListBlueprintsRequest,
  ListBlueprintsResponse,
  ListCrawlersRequest,
  ListCrawlersResponse,
  ListCrawlsRequest,
  ListCrawlsResponse,
  ListCustomEntityTypesRequest,
  ListCustomEntityTypesResponse,
  ListDataQualityResultsRequest,
  ListDataQualityResultsResponse,
  ListDataQualityRuleRecommendationRunsRequest,
  ListDataQualityRuleRecommendationRunsResponse,
  ListDataQualityRulesetEvaluationRunsRequest,
  ListDataQualityRulesetEvaluationRunsResponse,
  ListDataQualityRulesetsRequest,
  ListDataQualityRulesetsResponse,
  ListDevEndpointsRequest,
  ListDevEndpointsResponse,
  ListJobsRequest,
  ListJobsResponse,
  ListMLTransformsRequest,
  ListMLTransformsResponse,
  ListRegistriesInput,
  ListRegistriesResponse,
  ListSchemasInput,
  ListSchemasResponse,
  ListSchemaVersionsInput,
  ListSchemaVersionsResponse,
  ListSessionsRequest,
  ListSessionsResponse,
  ListStatementsRequest,
  ListStatementsResponse,
  ListTriggersRequest,
  ListTriggersResponse,
  ListWorkflowsRequest,
  ListWorkflowsResponse,
  Mapping,
  MetadataInfo,
  MetadataKeyValuePair,
  MLTransformNotReadyException,
  NoScheduleException,
  OtherMetadataValueListItem,
  PropertyPredicate,
  PutDataCatalogEncryptionSettingsRequest,
  PutDataCatalogEncryptionSettingsResponse,
  PutResourcePolicyRequest,
  PutResourcePolicyResponse,
  PutSchemaVersionMetadataInput,
  PutSchemaVersionMetadataResponse,
  PutWorkflowRunPropertiesRequest,
  PutWorkflowRunPropertiesResponse,
  QuerySchemaVersionMetadataInput,
  QuerySchemaVersionMetadataResponse,
  RegisterSchemaVersionInput,
  RegisterSchemaVersionResponse,
  RegistryListItem,
  RemoveSchemaVersionMetadataInput,
  RemoveSchemaVersionMetadataResponse,
  ResetJobBookmarkRequest,
  ResetJobBookmarkResponse,
  ResumeWorkflowRunRequest,
  ResumeWorkflowRunResponse,
  RunStatementRequest,
  RunStatementResponse,
  SchedulerNotRunningException,
  SchedulerRunningException,
  SchemaListItem,
  SchemaVersionListItem,
  SearchTablesRequest,
  SearchTablesResponse,
  SortCriterion,
  StartBlueprintRunRequest,
  StartBlueprintRunResponse,
  StartCrawlerRequest,
  StartCrawlerResponse,
  StartCrawlerScheduleRequest,
  StartCrawlerScheduleResponse,
  StartDataQualityRuleRecommendationRunRequest,
  StartDataQualityRuleRecommendationRunResponse,
  StartDataQualityRulesetEvaluationRunRequest,
  StartDataQualityRulesetEvaluationRunResponse,
  StartExportLabelsTaskRunRequest,
  StartExportLabelsTaskRunResponse,
  StartImportLabelsTaskRunRequest,
  StartImportLabelsTaskRunResponse,
  StartJobRunRequest,
  StartJobRunResponse,
  StartMLEvaluationTaskRunRequest,
  StartMLEvaluationTaskRunResponse,
  StartMLLabelingSetGenerationTaskRunRequest,
  StartMLLabelingSetGenerationTaskRunResponse,
  StartTriggerRequest,
  StartTriggerResponse,
  StartWorkflowRunRequest,
  StartWorkflowRunResponse,
  StopCrawlerRequest,
  StopCrawlerResponse,
  StopCrawlerScheduleRequest,
  StopCrawlerScheduleResponse,
  StopSessionRequest,
  StopSessionResponse,
  StopTriggerRequest,
  StopTriggerResponse,
  StopWorkflowRunRequest,
  StopWorkflowRunResponse,
  TagResourceRequest,
  TagResourceResponse,
  TriggerUpdate,
  UntagResourceRequest,
  UntagResourceResponse,
  UpdateBlueprintRequest,
  UpdateBlueprintResponse,
  UpdateClassifierRequest,
  UpdateClassifierResponse,
  UpdateColumnStatisticsForPartitionRequest,
  UpdateColumnStatisticsForPartitionResponse,
  UpdateColumnStatisticsForTableRequest,
  UpdateColumnStatisticsForTableResponse,
  UpdateConnectionRequest,
  UpdateConnectionResponse,
  UpdateCrawlerRequest,
  UpdateCrawlerResponse,
  UpdateCrawlerScheduleRequest,
  UpdateCrawlerScheduleResponse,
  UpdateCsvClassifierRequest,
  UpdateDatabaseRequest,
  UpdateDatabaseResponse,
  UpdateDataQualityRulesetRequest,
  UpdateDataQualityRulesetResponse,
  UpdateDevEndpointRequest,
  UpdateDevEndpointResponse,
  UpdateGrokClassifierRequest,
  UpdateJobFromSourceControlRequest,
  UpdateJobFromSourceControlResponse,
  UpdateJobRequest,
  UpdateJobResponse,
  UpdateJsonClassifierRequest,
  UpdateMLTransformRequest,
  UpdateMLTransformResponse,
  UpdatePartitionRequest,
  UpdatePartitionResponse,
  UpdateRegistryInput,
  UpdateRegistryResponse,
  UpdateSchemaInput,
  UpdateSchemaResponse,
  UpdateSourceControlFromJobRequest,
  UpdateSourceControlFromJobResponse,
  UpdateTableRequest,
  UpdateTableResponse,
  UpdateTriggerRequest,
  UpdateTriggerResponse,
  UpdateUserDefinedFunctionRequest,
  UpdateUserDefinedFunctionResponse,
  UpdateWorkflowRequest,
  UpdateWorkflowResponse,
  UpdateXMLClassifierRequest,
  VersionMismatchException,
} from "../models/models_2";

/**
 * serializeAws_json1_1BatchCreatePartitionCommand
 */
export const se_BatchCreatePartitionCommand = async (
  input: BatchCreatePartitionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.BatchCreatePartition",
  };
  let body: any;
  body = JSON.stringify(se_BatchCreatePartitionRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1BatchDeleteConnectionCommand
 */
export const se_BatchDeleteConnectionCommand = async (
  input: BatchDeleteConnectionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.BatchDeleteConnection",
  };
  let body: any;
  body = JSON.stringify(se_BatchDeleteConnectionRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1BatchDeletePartitionCommand
 */
export const se_BatchDeletePartitionCommand = async (
  input: BatchDeletePartitionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.BatchDeletePartition",
  };
  let body: any;
  body = JSON.stringify(se_BatchDeletePartitionRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1BatchDeleteTableCommand
 */
export const se_BatchDeleteTableCommand = async (
  input: BatchDeleteTableCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.BatchDeleteTable",
  };
  let body: any;
  body = JSON.stringify(se_BatchDeleteTableRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1BatchDeleteTableVersionCommand
 */
export const se_BatchDeleteTableVersionCommand = async (
  input: BatchDeleteTableVersionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.BatchDeleteTableVersion",
  };
  let body: any;
  body = JSON.stringify(se_BatchDeleteTableVersionRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1BatchGetBlueprintsCommand
 */
export const se_BatchGetBlueprintsCommand = async (
  input: BatchGetBlueprintsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.BatchGetBlueprints",
  };
  let body: any;
  body = JSON.stringify(se_BatchGetBlueprintsRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1BatchGetCrawlersCommand
 */
export const se_BatchGetCrawlersCommand = async (
  input: BatchGetCrawlersCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.BatchGetCrawlers",
  };
  let body: any;
  body = JSON.stringify(se_BatchGetCrawlersRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1BatchGetCustomEntityTypesCommand
 */
export const se_BatchGetCustomEntityTypesCommand = async (
  input: BatchGetCustomEntityTypesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.BatchGetCustomEntityTypes",
  };
  let body: any;
  body = JSON.stringify(se_BatchGetCustomEntityTypesRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1BatchGetDataQualityResultCommand
 */
export const se_BatchGetDataQualityResultCommand = async (
  input: BatchGetDataQualityResultCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.BatchGetDataQualityResult",
  };
  let body: any;
  body = JSON.stringify(se_BatchGetDataQualityResultRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1BatchGetDevEndpointsCommand
 */
export const se_BatchGetDevEndpointsCommand = async (
  input: BatchGetDevEndpointsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.BatchGetDevEndpoints",
  };
  let body: any;
  body = JSON.stringify(se_BatchGetDevEndpointsRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1BatchGetJobsCommand
 */
export const se_BatchGetJobsCommand = async (
  input: BatchGetJobsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.BatchGetJobs",
  };
  let body: any;
  body = JSON.stringify(se_BatchGetJobsRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1BatchGetPartitionCommand
 */
export const se_BatchGetPartitionCommand = async (
  input: BatchGetPartitionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.BatchGetPartition",
  };
  let body: any;
  body = JSON.stringify(se_BatchGetPartitionRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1BatchGetTriggersCommand
 */
export const se_BatchGetTriggersCommand = async (
  input: BatchGetTriggersCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.BatchGetTriggers",
  };
  let body: any;
  body = JSON.stringify(se_BatchGetTriggersRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1BatchGetWorkflowsCommand
 */
export const se_BatchGetWorkflowsCommand = async (
  input: BatchGetWorkflowsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.BatchGetWorkflows",
  };
  let body: any;
  body = JSON.stringify(se_BatchGetWorkflowsRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1BatchStopJobRunCommand
 */
export const se_BatchStopJobRunCommand = async (
  input: BatchStopJobRunCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.BatchStopJobRun",
  };
  let body: any;
  body = JSON.stringify(se_BatchStopJobRunRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1BatchUpdatePartitionCommand
 */
export const se_BatchUpdatePartitionCommand = async (
  input: BatchUpdatePartitionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.BatchUpdatePartition",
  };
  let body: any;
  body = JSON.stringify(se_BatchUpdatePartitionRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1CancelDataQualityRuleRecommendationRunCommand
 */
export const se_CancelDataQualityRuleRecommendationRunCommand = async (
  input: CancelDataQualityRuleRecommendationRunCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.CancelDataQualityRuleRecommendationRun",
  };
  let body: any;
  body = JSON.stringify(se_CancelDataQualityRuleRecommendationRunRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1CancelDataQualityRulesetEvaluationRunCommand
 */
export const se_CancelDataQualityRulesetEvaluationRunCommand = async (
  input: CancelDataQualityRulesetEvaluationRunCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.CancelDataQualityRulesetEvaluationRun",
  };
  let body: any;
  body = JSON.stringify(se_CancelDataQualityRulesetEvaluationRunRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1CancelMLTaskRunCommand
 */
export const se_CancelMLTaskRunCommand = async (
  input: CancelMLTaskRunCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.CancelMLTaskRun",
  };
  let body: any;
  body = JSON.stringify(se_CancelMLTaskRunRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1CancelStatementCommand
 */
export const se_CancelStatementCommand = async (
  input: CancelStatementCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.CancelStatement",
  };
  let body: any;
  body = JSON.stringify(se_CancelStatementRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1CheckSchemaVersionValidityCommand
 */
export const se_CheckSchemaVersionValidityCommand = async (
  input: CheckSchemaVersionValidityCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.CheckSchemaVersionValidity",
  };
  let body: any;
  body = JSON.stringify(se_CheckSchemaVersionValidityInput(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1CreateBlueprintCommand
 */
export const se_CreateBlueprintCommand = async (
  input: CreateBlueprintCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.CreateBlueprint",
  };
  let body: any;
  body = JSON.stringify(se_CreateBlueprintRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1CreateClassifierCommand
 */
export const se_CreateClassifierCommand = async (
  input: CreateClassifierCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.CreateClassifier",
  };
  let body: any;
  body = JSON.stringify(se_CreateClassifierRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1CreateConnectionCommand
 */
export const se_CreateConnectionCommand = async (
  input: CreateConnectionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.CreateConnection",
  };
  let body: any;
  body = JSON.stringify(se_CreateConnectionRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1CreateCrawlerCommand
 */
export const se_CreateCrawlerCommand = async (
  input: CreateCrawlerCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.CreateCrawler",
  };
  let body: any;
  body = JSON.stringify(se_CreateCrawlerRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1CreateCustomEntityTypeCommand
 */
export const se_CreateCustomEntityTypeCommand = async (
  input: CreateCustomEntityTypeCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.CreateCustomEntityType",
  };
  let body: any;
  body = JSON.stringify(se_CreateCustomEntityTypeRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1CreateDatabaseCommand
 */
export const se_CreateDatabaseCommand = async (
  input: CreateDatabaseCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.CreateDatabase",
  };
  let body: any;
  body = JSON.stringify(se_CreateDatabaseRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1CreateDataQualityRulesetCommand
 */
export const se_CreateDataQualityRulesetCommand = async (
  input: CreateDataQualityRulesetCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.CreateDataQualityRuleset",
  };
  let body: any;
  body = JSON.stringify(se_CreateDataQualityRulesetRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1CreateDevEndpointCommand
 */
export const se_CreateDevEndpointCommand = async (
  input: CreateDevEndpointCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.CreateDevEndpoint",
  };
  let body: any;
  body = JSON.stringify(se_CreateDevEndpointRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1CreateJobCommand
 */
export const se_CreateJobCommand = async (
  input: CreateJobCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.CreateJob",
  };
  let body: any;
  body = JSON.stringify(se_CreateJobRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1CreateMLTransformCommand
 */
export const se_CreateMLTransformCommand = async (
  input: CreateMLTransformCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.CreateMLTransform",
  };
  let body: any;
  body = JSON.stringify(se_CreateMLTransformRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1CreatePartitionCommand
 */
export const se_CreatePartitionCommand = async (
  input: CreatePartitionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.CreatePartition",
  };
  let body: any;
  body = JSON.stringify(se_CreatePartitionRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1CreatePartitionIndexCommand
 */
export const se_CreatePartitionIndexCommand = async (
  input: CreatePartitionIndexCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.CreatePartitionIndex",
  };
  let body: any;
  body = JSON.stringify(se_CreatePartitionIndexRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1CreateRegistryCommand
 */
export const se_CreateRegistryCommand = async (
  input: CreateRegistryCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.CreateRegistry",
  };
  let body: any;
  body = JSON.stringify(se_CreateRegistryInput(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1CreateSchemaCommand
 */
export const se_CreateSchemaCommand = async (
  input: CreateSchemaCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.CreateSchema",
  };
  let body: any;
  body = JSON.stringify(se_CreateSchemaInput(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1CreateScriptCommand
 */
export const se_CreateScriptCommand = async (
  input: CreateScriptCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.CreateScript",
  };
  let body: any;
  body = JSON.stringify(se_CreateScriptRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1CreateSecurityConfigurationCommand
 */
export const se_CreateSecurityConfigurationCommand = async (
  input: CreateSecurityConfigurationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.CreateSecurityConfiguration",
  };
  let body: any;
  body = JSON.stringify(se_CreateSecurityConfigurationRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1CreateSessionCommand
 */
export const se_CreateSessionCommand = async (
  input: CreateSessionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.CreateSession",
  };
  let body: any;
  body = JSON.stringify(se_CreateSessionRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1CreateTableCommand
 */
export const se_CreateTableCommand = async (
  input: CreateTableCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.CreateTable",
  };
  let body: any;
  body = JSON.stringify(se_CreateTableRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1CreateTriggerCommand
 */
export const se_CreateTriggerCommand = async (
  input: CreateTriggerCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.CreateTrigger",
  };
  let body: any;
  body = JSON.stringify(se_CreateTriggerRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1CreateUserDefinedFunctionCommand
 */
export const se_CreateUserDefinedFunctionCommand = async (
  input: CreateUserDefinedFunctionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.CreateUserDefinedFunction",
  };
  let body: any;
  body = JSON.stringify(se_CreateUserDefinedFunctionRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1CreateWorkflowCommand
 */
export const se_CreateWorkflowCommand = async (
  input: CreateWorkflowCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.CreateWorkflow",
  };
  let body: any;
  body = JSON.stringify(se_CreateWorkflowRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1DeleteBlueprintCommand
 */
export const se_DeleteBlueprintCommand = async (
  input: DeleteBlueprintCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.DeleteBlueprint",
  };
  let body: any;
  body = JSON.stringify(se_DeleteBlueprintRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1DeleteClassifierCommand
 */
export const se_DeleteClassifierCommand = async (
  input: DeleteClassifierCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.DeleteClassifier",
  };
  let body: any;
  body = JSON.stringify(se_DeleteClassifierRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1DeleteColumnStatisticsForPartitionCommand
 */
export const se_DeleteColumnStatisticsForPartitionCommand = async (
  input: DeleteColumnStatisticsForPartitionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.DeleteColumnStatisticsForPartition",
  };
  let body: any;
  body = JSON.stringify(se_DeleteColumnStatisticsForPartitionRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1DeleteColumnStatisticsForTableCommand
 */
export const se_DeleteColumnStatisticsForTableCommand = async (
  input: DeleteColumnStatisticsForTableCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.DeleteColumnStatisticsForTable",
  };
  let body: any;
  body = JSON.stringify(se_DeleteColumnStatisticsForTableRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1DeleteConnectionCommand
 */
export const se_DeleteConnectionCommand = async (
  input: DeleteConnectionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.DeleteConnection",
  };
  let body: any;
  body = JSON.stringify(se_DeleteConnectionRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1DeleteCrawlerCommand
 */
export const se_DeleteCrawlerCommand = async (
  input: DeleteCrawlerCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.DeleteCrawler",
  };
  let body: any;
  body = JSON.stringify(se_DeleteCrawlerRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1DeleteCustomEntityTypeCommand
 */
export const se_DeleteCustomEntityTypeCommand = async (
  input: DeleteCustomEntityTypeCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.DeleteCustomEntityType",
  };
  let body: any;
  body = JSON.stringify(se_DeleteCustomEntityTypeRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1DeleteDatabaseCommand
 */
export const se_DeleteDatabaseCommand = async (
  input: DeleteDatabaseCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.DeleteDatabase",
  };
  let body: any;
  body = JSON.stringify(se_DeleteDatabaseRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1DeleteDataQualityRulesetCommand
 */
export const se_DeleteDataQualityRulesetCommand = async (
  input: DeleteDataQualityRulesetCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.DeleteDataQualityRuleset",
  };
  let body: any;
  body = JSON.stringify(se_DeleteDataQualityRulesetRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1DeleteDevEndpointCommand
 */
export const se_DeleteDevEndpointCommand = async (
  input: DeleteDevEndpointCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.DeleteDevEndpoint",
  };
  let body: any;
  body = JSON.stringify(se_DeleteDevEndpointRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1DeleteJobCommand
 */
export const se_DeleteJobCommand = async (
  input: DeleteJobCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.DeleteJob",
  };
  let body: any;
  body = JSON.stringify(se_DeleteJobRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1DeleteMLTransformCommand
 */
export const se_DeleteMLTransformCommand = async (
  input: DeleteMLTransformCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.DeleteMLTransform",
  };
  let body: any;
  body = JSON.stringify(se_DeleteMLTransformRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1DeletePartitionCommand
 */
export const se_DeletePartitionCommand = async (
  input: DeletePartitionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.DeletePartition",
  };
  let body: any;
  body = JSON.stringify(se_DeletePartitionRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1DeletePartitionIndexCommand
 */
export const se_DeletePartitionIndexCommand = async (
  input: DeletePartitionIndexCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.DeletePartitionIndex",
  };
  let body: any;
  body = JSON.stringify(se_DeletePartitionIndexRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1DeleteRegistryCommand
 */
export const se_DeleteRegistryCommand = async (
  input: DeleteRegistryCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.DeleteRegistry",
  };
  let body: any;
  body = JSON.stringify(se_DeleteRegistryInput(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1DeleteResourcePolicyCommand
 */
export const se_DeleteResourcePolicyCommand = async (
  input: DeleteResourcePolicyCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.DeleteResourcePolicy",
  };
  let body: any;
  body = JSON.stringify(se_DeleteResourcePolicyRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1DeleteSchemaCommand
 */
export const se_DeleteSchemaCommand = async (
  input: DeleteSchemaCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.DeleteSchema",
  };
  let body: any;
  body = JSON.stringify(se_DeleteSchemaInput(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1DeleteSchemaVersionsCommand
 */
export const se_DeleteSchemaVersionsCommand = async (
  input: DeleteSchemaVersionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.DeleteSchemaVersions",
  };
  let body: any;
  body = JSON.stringify(se_DeleteSchemaVersionsInput(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1DeleteSecurityConfigurationCommand
 */
export const se_DeleteSecurityConfigurationCommand = async (
  input: DeleteSecurityConfigurationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.DeleteSecurityConfiguration",
  };
  let body: any;
  body = JSON.stringify(se_DeleteSecurityConfigurationRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1DeleteSessionCommand
 */
export const se_DeleteSessionCommand = async (
  input: DeleteSessionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.DeleteSession",
  };
  let body: any;
  body = JSON.stringify(se_DeleteSessionRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1DeleteTableCommand
 */
export const se_DeleteTableCommand = async (
  input: DeleteTableCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.DeleteTable",
  };
  let body: any;
  body = JSON.stringify(se_DeleteTableRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1DeleteTableVersionCommand
 */
export const se_DeleteTableVersionCommand = async (
  input: DeleteTableVersionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.DeleteTableVersion",
  };
  let body: any;
  body = JSON.stringify(se_DeleteTableVersionRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1DeleteTriggerCommand
 */
export const se_DeleteTriggerCommand = async (
  input: DeleteTriggerCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.DeleteTrigger",
  };
  let body: any;
  body = JSON.stringify(se_DeleteTriggerRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1DeleteUserDefinedFunctionCommand
 */
export const se_DeleteUserDefinedFunctionCommand = async (
  input: DeleteUserDefinedFunctionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.DeleteUserDefinedFunction",
  };
  let body: any;
  body = JSON.stringify(se_DeleteUserDefinedFunctionRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1DeleteWorkflowCommand
 */
export const se_DeleteWorkflowCommand = async (
  input: DeleteWorkflowCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.DeleteWorkflow",
  };
  let body: any;
  body = JSON.stringify(se_DeleteWorkflowRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1GetBlueprintCommand
 */
export const se_GetBlueprintCommand = async (
  input: GetBlueprintCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.GetBlueprint",
  };
  let body: any;
  body = JSON.stringify(se_GetBlueprintRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1GetBlueprintRunCommand
 */
export const se_GetBlueprintRunCommand = async (
  input: GetBlueprintRunCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.GetBlueprintRun",
  };
  let body: any;
  body = JSON.stringify(se_GetBlueprintRunRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1GetBlueprintRunsCommand
 */
export const se_GetBlueprintRunsCommand = async (
  input: GetBlueprintRunsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.GetBlueprintRuns",
  };
  let body: any;
  body = JSON.stringify(se_GetBlueprintRunsRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1GetCatalogImportStatusCommand
 */
export const se_GetCatalogImportStatusCommand = async (
  input: GetCatalogImportStatusCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.GetCatalogImportStatus",
  };
  let body: any;
  body = JSON.stringify(se_GetCatalogImportStatusRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1GetClassifierCommand
 */
export const se_GetClassifierCommand = async (
  input: GetClassifierCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.GetClassifier",
  };
  let body: any;
  body = JSON.stringify(se_GetClassifierRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1GetClassifiersCommand
 */
export const se_GetClassifiersCommand = async (
  input: GetClassifiersCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.GetClassifiers",
  };
  let body: any;
  body = JSON.stringify(se_GetClassifiersRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1GetColumnStatisticsForPartitionCommand
 */
export const se_GetColumnStatisticsForPartitionCommand = async (
  input: GetColumnStatisticsForPartitionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.GetColumnStatisticsForPartition",
  };
  let body: any;
  body = JSON.stringify(se_GetColumnStatisticsForPartitionRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1GetColumnStatisticsForTableCommand
 */
export const se_GetColumnStatisticsForTableCommand = async (
  input: GetColumnStatisticsForTableCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.GetColumnStatisticsForTable",
  };
  let body: any;
  body = JSON.stringify(se_GetColumnStatisticsForTableRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1GetConnectionCommand
 */
export const se_GetConnectionCommand = async (
  input: GetConnectionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.GetConnection",
  };
  let body: any;
  body = JSON.stringify(se_GetConnectionRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1GetConnectionsCommand
 */
export const se_GetConnectionsCommand = async (
  input: GetConnectionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.GetConnections",
  };
  let body: any;
  body = JSON.stringify(se_GetConnectionsRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1GetCrawlerCommand
 */
export const se_GetCrawlerCommand = async (
  input: GetCrawlerCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.GetCrawler",
  };
  let body: any;
  body = JSON.stringify(se_GetCrawlerRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1GetCrawlerMetricsCommand
 */
export const se_GetCrawlerMetricsCommand = async (
  input: GetCrawlerMetricsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.GetCrawlerMetrics",
  };
  let body: any;
  body = JSON.stringify(se_GetCrawlerMetricsRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1GetCrawlersCommand
 */
export const se_GetCrawlersCommand = async (
  input: GetCrawlersCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.GetCrawlers",
  };
  let body: any;
  body = JSON.stringify(se_GetCrawlersRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1GetCustomEntityTypeCommand
 */
export const se_GetCustomEntityTypeCommand = async (
  input: GetCustomEntityTypeCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.GetCustomEntityType",
  };
  let body: any;
  body = JSON.stringify(se_GetCustomEntityTypeRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1GetDatabaseCommand
 */
export const se_GetDatabaseCommand = async (
  input: GetDatabaseCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.GetDatabase",
  };
  let body: any;
  body = JSON.stringify(se_GetDatabaseRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1GetDatabasesCommand
 */
export const se_GetDatabasesCommand = async (
  input: GetDatabasesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.GetDatabases",
  };
  let body: any;
  body = JSON.stringify(se_GetDatabasesRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1GetDataCatalogEncryptionSettingsCommand
 */
export const se_GetDataCatalogEncryptionSettingsCommand = async (
  input: GetDataCatalogEncryptionSettingsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.GetDataCatalogEncryptionSettings",
  };
  let body: any;
  body = JSON.stringify(se_GetDataCatalogEncryptionSettingsRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1GetDataflowGraphCommand
 */
export const se_GetDataflowGraphCommand = async (
  input: GetDataflowGraphCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.GetDataflowGraph",
  };
  let body: any;
  body = JSON.stringify(se_GetDataflowGraphRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1GetDataQualityResultCommand
 */
export const se_GetDataQualityResultCommand = async (
  input: GetDataQualityResultCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.GetDataQualityResult",
  };
  let body: any;
  body = JSON.stringify(se_GetDataQualityResultRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1GetDataQualityRuleRecommendationRunCommand
 */
export const se_GetDataQualityRuleRecommendationRunCommand = async (
  input: GetDataQualityRuleRecommendationRunCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.GetDataQualityRuleRecommendationRun",
  };
  let body: any;
  body = JSON.stringify(se_GetDataQualityRuleRecommendationRunRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1GetDataQualityRulesetCommand
 */
export const se_GetDataQualityRulesetCommand = async (
  input: GetDataQualityRulesetCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.GetDataQualityRuleset",
  };
  let body: any;
  body = JSON.stringify(se_GetDataQualityRulesetRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1GetDataQualityRulesetEvaluationRunCommand
 */
export const se_GetDataQualityRulesetEvaluationRunCommand = async (
  input: GetDataQualityRulesetEvaluationRunCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.GetDataQualityRulesetEvaluationRun",
  };
  let body: any;
  body = JSON.stringify(se_GetDataQualityRulesetEvaluationRunRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1GetDevEndpointCommand
 */
export const se_GetDevEndpointCommand = async (
  input: GetDevEndpointCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.GetDevEndpoint",
  };
  let body: any;
  body = JSON.stringify(se_GetDevEndpointRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1GetDevEndpointsCommand
 */
export const se_GetDevEndpointsCommand = async (
  input: GetDevEndpointsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.GetDevEndpoints",
  };
  let body: any;
  body = JSON.stringify(se_GetDevEndpointsRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1GetJobCommand
 */
export const se_GetJobCommand = async (input: GetJobCommandInput, context: __SerdeContext): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.GetJob",
  };
  let body: any;
  body = JSON.stringify(se_GetJobRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1GetJobBookmarkCommand
 */
export const se_GetJobBookmarkCommand = async (
  input: GetJobBookmarkCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.GetJobBookmark",
  };
  let body: any;
  body = JSON.stringify(se_GetJobBookmarkRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1GetJobRunCommand
 */
export const se_GetJobRunCommand = async (
  input: GetJobRunCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.GetJobRun",
  };
  let body: any;
  body = JSON.stringify(se_GetJobRunRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1GetJobRunsCommand
 */
export const se_GetJobRunsCommand = async (
  input: GetJobRunsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.GetJobRuns",
  };
  let body: any;
  body = JSON.stringify(se_GetJobRunsRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1GetJobsCommand
 */
export const se_GetJobsCommand = async (
  input: GetJobsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.GetJobs",
  };
  let body: any;
  body = JSON.stringify(se_GetJobsRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1GetMappingCommand
 */
export const se_GetMappingCommand = async (
  input: GetMappingCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.GetMapping",
  };
  let body: any;
  body = JSON.stringify(se_GetMappingRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1GetMLTaskRunCommand
 */
export const se_GetMLTaskRunCommand = async (
  input: GetMLTaskRunCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.GetMLTaskRun",
  };
  let body: any;
  body = JSON.stringify(se_GetMLTaskRunRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1GetMLTaskRunsCommand
 */
export const se_GetMLTaskRunsCommand = async (
  input: GetMLTaskRunsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.GetMLTaskRuns",
  };
  let body: any;
  body = JSON.stringify(se_GetMLTaskRunsRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1GetMLTransformCommand
 */
export const se_GetMLTransformCommand = async (
  input: GetMLTransformCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.GetMLTransform",
  };
  let body: any;
  body = JSON.stringify(se_GetMLTransformRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1GetMLTransformsCommand
 */
export const se_GetMLTransformsCommand = async (
  input: GetMLTransformsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.GetMLTransforms",
  };
  let body: any;
  body = JSON.stringify(se_GetMLTransformsRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1GetPartitionCommand
 */
export const se_GetPartitionCommand = async (
  input: GetPartitionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.GetPartition",
  };
  let body: any;
  body = JSON.stringify(se_GetPartitionRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1GetPartitionIndexesCommand
 */
export const se_GetPartitionIndexesCommand = async (
  input: GetPartitionIndexesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.GetPartitionIndexes",
  };
  let body: any;
  body = JSON.stringify(se_GetPartitionIndexesRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1GetPartitionsCommand
 */
export const se_GetPartitionsCommand = async (
  input: GetPartitionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.GetPartitions",
  };
  let body: any;
  body = JSON.stringify(se_GetPartitionsRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1GetPlanCommand
 */
export const se_GetPlanCommand = async (
  input: GetPlanCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.GetPlan",
  };
  let body: any;
  body = JSON.stringify(se_GetPlanRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1GetRegistryCommand
 */
export const se_GetRegistryCommand = async (
  input: GetRegistryCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.GetRegistry",
  };
  let body: any;
  body = JSON.stringify(se_GetRegistryInput(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1GetResourcePoliciesCommand
 */
export const se_GetResourcePoliciesCommand = async (
  input: GetResourcePoliciesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.GetResourcePolicies",
  };
  let body: any;
  body = JSON.stringify(se_GetResourcePoliciesRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1GetResourcePolicyCommand
 */
export const se_GetResourcePolicyCommand = async (
  input: GetResourcePolicyCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.GetResourcePolicy",
  };
  let body: any;
  body = JSON.stringify(se_GetResourcePolicyRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1GetSchemaCommand
 */
export const se_GetSchemaCommand = async (
  input: GetSchemaCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.GetSchema",
  };
  let body: any;
  body = JSON.stringify(se_GetSchemaInput(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1GetSchemaByDefinitionCommand
 */
export const se_GetSchemaByDefinitionCommand = async (
  input: GetSchemaByDefinitionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.GetSchemaByDefinition",
  };
  let body: any;
  body = JSON.stringify(se_GetSchemaByDefinitionInput(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1GetSchemaVersionCommand
 */
export const se_GetSchemaVersionCommand = async (
  input: GetSchemaVersionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.GetSchemaVersion",
  };
  let body: any;
  body = JSON.stringify(se_GetSchemaVersionInput(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1GetSchemaVersionsDiffCommand
 */
export const se_GetSchemaVersionsDiffCommand = async (
  input: GetSchemaVersionsDiffCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.GetSchemaVersionsDiff",
  };
  let body: any;
  body = JSON.stringify(se_GetSchemaVersionsDiffInput(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1GetSecurityConfigurationCommand
 */
export const se_GetSecurityConfigurationCommand = async (
  input: GetSecurityConfigurationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.GetSecurityConfiguration",
  };
  let body: any;
  body = JSON.stringify(se_GetSecurityConfigurationRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1GetSecurityConfigurationsCommand
 */
export const se_GetSecurityConfigurationsCommand = async (
  input: GetSecurityConfigurationsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.GetSecurityConfigurations",
  };
  let body: any;
  body = JSON.stringify(se_GetSecurityConfigurationsRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1GetSessionCommand
 */
export const se_GetSessionCommand = async (
  input: GetSessionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.GetSession",
  };
  let body: any;
  body = JSON.stringify(se_GetSessionRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1GetStatementCommand
 */
export const se_GetStatementCommand = async (
  input: GetStatementCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.GetStatement",
  };
  let body: any;
  body = JSON.stringify(se_GetStatementRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1GetTableCommand
 */
export const se_GetTableCommand = async (
  input: GetTableCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.GetTable",
  };
  let body: any;
  body = JSON.stringify(se_GetTableRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1GetTablesCommand
 */
export const se_GetTablesCommand = async (
  input: GetTablesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.GetTables",
  };
  let body: any;
  body = JSON.stringify(se_GetTablesRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1GetTableVersionCommand
 */
export const se_GetTableVersionCommand = async (
  input: GetTableVersionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.GetTableVersion",
  };
  let body: any;
  body = JSON.stringify(se_GetTableVersionRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1GetTableVersionsCommand
 */
export const se_GetTableVersionsCommand = async (
  input: GetTableVersionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.GetTableVersions",
  };
  let body: any;
  body = JSON.stringify(se_GetTableVersionsRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1GetTagsCommand
 */
export const se_GetTagsCommand = async (
  input: GetTagsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.GetTags",
  };
  let body: any;
  body = JSON.stringify(se_GetTagsRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1GetTriggerCommand
 */
export const se_GetTriggerCommand = async (
  input: GetTriggerCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.GetTrigger",
  };
  let body: any;
  body = JSON.stringify(se_GetTriggerRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1GetTriggersCommand
 */
export const se_GetTriggersCommand = async (
  input: GetTriggersCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.GetTriggers",
  };
  let body: any;
  body = JSON.stringify(se_GetTriggersRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1GetUnfilteredPartitionMetadataCommand
 */
export const se_GetUnfilteredPartitionMetadataCommand = async (
  input: GetUnfilteredPartitionMetadataCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.GetUnfilteredPartitionMetadata",
  };
  let body: any;
  body = JSON.stringify(se_GetUnfilteredPartitionMetadataRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1GetUnfilteredPartitionsMetadataCommand
 */
export const se_GetUnfilteredPartitionsMetadataCommand = async (
  input: GetUnfilteredPartitionsMetadataCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.GetUnfilteredPartitionsMetadata",
  };
  let body: any;
  body = JSON.stringify(se_GetUnfilteredPartitionsMetadataRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1GetUnfilteredTableMetadataCommand
 */
export const se_GetUnfilteredTableMetadataCommand = async (
  input: GetUnfilteredTableMetadataCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.GetUnfilteredTableMetadata",
  };
  let body: any;
  body = JSON.stringify(se_GetUnfilteredTableMetadataRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1GetUserDefinedFunctionCommand
 */
export const se_GetUserDefinedFunctionCommand = async (
  input: GetUserDefinedFunctionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.GetUserDefinedFunction",
  };
  let body: any;
  body = JSON.stringify(se_GetUserDefinedFunctionRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1GetUserDefinedFunctionsCommand
 */
export const se_GetUserDefinedFunctionsCommand = async (
  input: GetUserDefinedFunctionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.GetUserDefinedFunctions",
  };
  let body: any;
  body = JSON.stringify(se_GetUserDefinedFunctionsRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1GetWorkflowCommand
 */
export const se_GetWorkflowCommand = async (
  input: GetWorkflowCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.GetWorkflow",
  };
  let body: any;
  body = JSON.stringify(se_GetWorkflowRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1GetWorkflowRunCommand
 */
export const se_GetWorkflowRunCommand = async (
  input: GetWorkflowRunCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.GetWorkflowRun",
  };
  let body: any;
  body = JSON.stringify(se_GetWorkflowRunRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1GetWorkflowRunPropertiesCommand
 */
export const se_GetWorkflowRunPropertiesCommand = async (
  input: GetWorkflowRunPropertiesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.GetWorkflowRunProperties",
  };
  let body: any;
  body = JSON.stringify(se_GetWorkflowRunPropertiesRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1GetWorkflowRunsCommand
 */
export const se_GetWorkflowRunsCommand = async (
  input: GetWorkflowRunsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.GetWorkflowRuns",
  };
  let body: any;
  body = JSON.stringify(se_GetWorkflowRunsRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1ImportCatalogToGlueCommand
 */
export const se_ImportCatalogToGlueCommand = async (
  input: ImportCatalogToGlueCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.ImportCatalogToGlue",
  };
  let body: any;
  body = JSON.stringify(se_ImportCatalogToGlueRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1ListBlueprintsCommand
 */
export const se_ListBlueprintsCommand = async (
  input: ListBlueprintsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.ListBlueprints",
  };
  let body: any;
  body = JSON.stringify(se_ListBlueprintsRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1ListCrawlersCommand
 */
export const se_ListCrawlersCommand = async (
  input: ListCrawlersCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.ListCrawlers",
  };
  let body: any;
  body = JSON.stringify(se_ListCrawlersRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1ListCrawlsCommand
 */
export const se_ListCrawlsCommand = async (
  input: ListCrawlsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.ListCrawls",
  };
  let body: any;
  body = JSON.stringify(se_ListCrawlsRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1ListCustomEntityTypesCommand
 */
export const se_ListCustomEntityTypesCommand = async (
  input: ListCustomEntityTypesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.ListCustomEntityTypes",
  };
  let body: any;
  body = JSON.stringify(se_ListCustomEntityTypesRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1ListDataQualityResultsCommand
 */
export const se_ListDataQualityResultsCommand = async (
  input: ListDataQualityResultsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.ListDataQualityResults",
  };
  let body: any;
  body = JSON.stringify(se_ListDataQualityResultsRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1ListDataQualityRuleRecommendationRunsCommand
 */
export const se_ListDataQualityRuleRecommendationRunsCommand = async (
  input: ListDataQualityRuleRecommendationRunsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.ListDataQualityRuleRecommendationRuns",
  };
  let body: any;
  body = JSON.stringify(se_ListDataQualityRuleRecommendationRunsRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1ListDataQualityRulesetEvaluationRunsCommand
 */
export const se_ListDataQualityRulesetEvaluationRunsCommand = async (
  input: ListDataQualityRulesetEvaluationRunsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.ListDataQualityRulesetEvaluationRuns",
  };
  let body: any;
  body = JSON.stringify(se_ListDataQualityRulesetEvaluationRunsRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1ListDataQualityRulesetsCommand
 */
export const se_ListDataQualityRulesetsCommand = async (
  input: ListDataQualityRulesetsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.ListDataQualityRulesets",
  };
  let body: any;
  body = JSON.stringify(se_ListDataQualityRulesetsRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1ListDevEndpointsCommand
 */
export const se_ListDevEndpointsCommand = async (
  input: ListDevEndpointsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.ListDevEndpoints",
  };
  let body: any;
  body = JSON.stringify(se_ListDevEndpointsRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1ListJobsCommand
 */
export const se_ListJobsCommand = async (
  input: ListJobsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.ListJobs",
  };
  let body: any;
  body = JSON.stringify(se_ListJobsRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1ListMLTransformsCommand
 */
export const se_ListMLTransformsCommand = async (
  input: ListMLTransformsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.ListMLTransforms",
  };
  let body: any;
  body = JSON.stringify(se_ListMLTransformsRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1ListRegistriesCommand
 */
export const se_ListRegistriesCommand = async (
  input: ListRegistriesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.ListRegistries",
  };
  let body: any;
  body = JSON.stringify(se_ListRegistriesInput(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1ListSchemasCommand
 */
export const se_ListSchemasCommand = async (
  input: ListSchemasCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.ListSchemas",
  };
  let body: any;
  body = JSON.stringify(se_ListSchemasInput(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1ListSchemaVersionsCommand
 */
export const se_ListSchemaVersionsCommand = async (
  input: ListSchemaVersionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.ListSchemaVersions",
  };
  let body: any;
  body = JSON.stringify(se_ListSchemaVersionsInput(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1ListSessionsCommand
 */
export const se_ListSessionsCommand = async (
  input: ListSessionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.ListSessions",
  };
  let body: any;
  body = JSON.stringify(se_ListSessionsRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1ListStatementsCommand
 */
export const se_ListStatementsCommand = async (
  input: ListStatementsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.ListStatements",
  };
  let body: any;
  body = JSON.stringify(se_ListStatementsRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1ListTriggersCommand
 */
export const se_ListTriggersCommand = async (
  input: ListTriggersCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.ListTriggers",
  };
  let body: any;
  body = JSON.stringify(se_ListTriggersRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1ListWorkflowsCommand
 */
export const se_ListWorkflowsCommand = async (
  input: ListWorkflowsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.ListWorkflows",
  };
  let body: any;
  body = JSON.stringify(se_ListWorkflowsRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1PutDataCatalogEncryptionSettingsCommand
 */
export const se_PutDataCatalogEncryptionSettingsCommand = async (
  input: PutDataCatalogEncryptionSettingsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.PutDataCatalogEncryptionSettings",
  };
  let body: any;
  body = JSON.stringify(se_PutDataCatalogEncryptionSettingsRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1PutResourcePolicyCommand
 */
export const se_PutResourcePolicyCommand = async (
  input: PutResourcePolicyCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.PutResourcePolicy",
  };
  let body: any;
  body = JSON.stringify(se_PutResourcePolicyRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1PutSchemaVersionMetadataCommand
 */
export const se_PutSchemaVersionMetadataCommand = async (
  input: PutSchemaVersionMetadataCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.PutSchemaVersionMetadata",
  };
  let body: any;
  body = JSON.stringify(se_PutSchemaVersionMetadataInput(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1PutWorkflowRunPropertiesCommand
 */
export const se_PutWorkflowRunPropertiesCommand = async (
  input: PutWorkflowRunPropertiesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.PutWorkflowRunProperties",
  };
  let body: any;
  body = JSON.stringify(se_PutWorkflowRunPropertiesRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1QuerySchemaVersionMetadataCommand
 */
export const se_QuerySchemaVersionMetadataCommand = async (
  input: QuerySchemaVersionMetadataCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.QuerySchemaVersionMetadata",
  };
  let body: any;
  body = JSON.stringify(se_QuerySchemaVersionMetadataInput(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1RegisterSchemaVersionCommand
 */
export const se_RegisterSchemaVersionCommand = async (
  input: RegisterSchemaVersionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.RegisterSchemaVersion",
  };
  let body: any;
  body = JSON.stringify(se_RegisterSchemaVersionInput(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1RemoveSchemaVersionMetadataCommand
 */
export const se_RemoveSchemaVersionMetadataCommand = async (
  input: RemoveSchemaVersionMetadataCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.RemoveSchemaVersionMetadata",
  };
  let body: any;
  body = JSON.stringify(se_RemoveSchemaVersionMetadataInput(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1ResetJobBookmarkCommand
 */
export const se_ResetJobBookmarkCommand = async (
  input: ResetJobBookmarkCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.ResetJobBookmark",
  };
  let body: any;
  body = JSON.stringify(se_ResetJobBookmarkRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1ResumeWorkflowRunCommand
 */
export const se_ResumeWorkflowRunCommand = async (
  input: ResumeWorkflowRunCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.ResumeWorkflowRun",
  };
  let body: any;
  body = JSON.stringify(se_ResumeWorkflowRunRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1RunStatementCommand
 */
export const se_RunStatementCommand = async (
  input: RunStatementCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.RunStatement",
  };
  let body: any;
  body = JSON.stringify(se_RunStatementRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1SearchTablesCommand
 */
export const se_SearchTablesCommand = async (
  input: SearchTablesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.SearchTables",
  };
  let body: any;
  body = JSON.stringify(se_SearchTablesRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1StartBlueprintRunCommand
 */
export const se_StartBlueprintRunCommand = async (
  input: StartBlueprintRunCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.StartBlueprintRun",
  };
  let body: any;
  body = JSON.stringify(se_StartBlueprintRunRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1StartCrawlerCommand
 */
export const se_StartCrawlerCommand = async (
  input: StartCrawlerCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.StartCrawler",
  };
  let body: any;
  body = JSON.stringify(se_StartCrawlerRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1StartCrawlerScheduleCommand
 */
export const se_StartCrawlerScheduleCommand = async (
  input: StartCrawlerScheduleCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.StartCrawlerSchedule",
  };
  let body: any;
  body = JSON.stringify(se_StartCrawlerScheduleRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1StartDataQualityRuleRecommendationRunCommand
 */
export const se_StartDataQualityRuleRecommendationRunCommand = async (
  input: StartDataQualityRuleRecommendationRunCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.StartDataQualityRuleRecommendationRun",
  };
  let body: any;
  body = JSON.stringify(se_StartDataQualityRuleRecommendationRunRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1StartDataQualityRulesetEvaluationRunCommand
 */
export const se_StartDataQualityRulesetEvaluationRunCommand = async (
  input: StartDataQualityRulesetEvaluationRunCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.StartDataQualityRulesetEvaluationRun",
  };
  let body: any;
  body = JSON.stringify(se_StartDataQualityRulesetEvaluationRunRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1StartExportLabelsTaskRunCommand
 */
export const se_StartExportLabelsTaskRunCommand = async (
  input: StartExportLabelsTaskRunCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.StartExportLabelsTaskRun",
  };
  let body: any;
  body = JSON.stringify(se_StartExportLabelsTaskRunRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1StartImportLabelsTaskRunCommand
 */
export const se_StartImportLabelsTaskRunCommand = async (
  input: StartImportLabelsTaskRunCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.StartImportLabelsTaskRun",
  };
  let body: any;
  body = JSON.stringify(se_StartImportLabelsTaskRunRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1StartJobRunCommand
 */
export const se_StartJobRunCommand = async (
  input: StartJobRunCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.StartJobRun",
  };
  let body: any;
  body = JSON.stringify(se_StartJobRunRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1StartMLEvaluationTaskRunCommand
 */
export const se_StartMLEvaluationTaskRunCommand = async (
  input: StartMLEvaluationTaskRunCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.StartMLEvaluationTaskRun",
  };
  let body: any;
  body = JSON.stringify(se_StartMLEvaluationTaskRunRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1StartMLLabelingSetGenerationTaskRunCommand
 */
export const se_StartMLLabelingSetGenerationTaskRunCommand = async (
  input: StartMLLabelingSetGenerationTaskRunCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.StartMLLabelingSetGenerationTaskRun",
  };
  let body: any;
  body = JSON.stringify(se_StartMLLabelingSetGenerationTaskRunRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1StartTriggerCommand
 */
export const se_StartTriggerCommand = async (
  input: StartTriggerCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.StartTrigger",
  };
  let body: any;
  body = JSON.stringify(se_StartTriggerRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1StartWorkflowRunCommand
 */
export const se_StartWorkflowRunCommand = async (
  input: StartWorkflowRunCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.StartWorkflowRun",
  };
  let body: any;
  body = JSON.stringify(se_StartWorkflowRunRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1StopCrawlerCommand
 */
export const se_StopCrawlerCommand = async (
  input: StopCrawlerCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.StopCrawler",
  };
  let body: any;
  body = JSON.stringify(se_StopCrawlerRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1StopCrawlerScheduleCommand
 */
export const se_StopCrawlerScheduleCommand = async (
  input: StopCrawlerScheduleCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.StopCrawlerSchedule",
  };
  let body: any;
  body = JSON.stringify(se_StopCrawlerScheduleRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1StopSessionCommand
 */
export const se_StopSessionCommand = async (
  input: StopSessionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.StopSession",
  };
  let body: any;
  body = JSON.stringify(se_StopSessionRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1StopTriggerCommand
 */
export const se_StopTriggerCommand = async (
  input: StopTriggerCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.StopTrigger",
  };
  let body: any;
  body = JSON.stringify(se_StopTriggerRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1StopWorkflowRunCommand
 */
export const se_StopWorkflowRunCommand = async (
  input: StopWorkflowRunCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.StopWorkflowRun",
  };
  let body: any;
  body = JSON.stringify(se_StopWorkflowRunRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1TagResourceCommand
 */
export const se_TagResourceCommand = async (
  input: TagResourceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.TagResource",
  };
  let body: any;
  body = JSON.stringify(se_TagResourceRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1UntagResourceCommand
 */
export const se_UntagResourceCommand = async (
  input: UntagResourceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.UntagResource",
  };
  let body: any;
  body = JSON.stringify(se_UntagResourceRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1UpdateBlueprintCommand
 */
export const se_UpdateBlueprintCommand = async (
  input: UpdateBlueprintCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.UpdateBlueprint",
  };
  let body: any;
  body = JSON.stringify(se_UpdateBlueprintRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1UpdateClassifierCommand
 */
export const se_UpdateClassifierCommand = async (
  input: UpdateClassifierCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.UpdateClassifier",
  };
  let body: any;
  body = JSON.stringify(se_UpdateClassifierRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1UpdateColumnStatisticsForPartitionCommand
 */
export const se_UpdateColumnStatisticsForPartitionCommand = async (
  input: UpdateColumnStatisticsForPartitionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.UpdateColumnStatisticsForPartition",
  };
  let body: any;
  body = JSON.stringify(se_UpdateColumnStatisticsForPartitionRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1UpdateColumnStatisticsForTableCommand
 */
export const se_UpdateColumnStatisticsForTableCommand = async (
  input: UpdateColumnStatisticsForTableCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.UpdateColumnStatisticsForTable",
  };
  let body: any;
  body = JSON.stringify(se_UpdateColumnStatisticsForTableRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1UpdateConnectionCommand
 */
export const se_UpdateConnectionCommand = async (
  input: UpdateConnectionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.UpdateConnection",
  };
  let body: any;
  body = JSON.stringify(se_UpdateConnectionRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1UpdateCrawlerCommand
 */
export const se_UpdateCrawlerCommand = async (
  input: UpdateCrawlerCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.UpdateCrawler",
  };
  let body: any;
  body = JSON.stringify(se_UpdateCrawlerRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1UpdateCrawlerScheduleCommand
 */
export const se_UpdateCrawlerScheduleCommand = async (
  input: UpdateCrawlerScheduleCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.UpdateCrawlerSchedule",
  };
  let body: any;
  body = JSON.stringify(se_UpdateCrawlerScheduleRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1UpdateDatabaseCommand
 */
export const se_UpdateDatabaseCommand = async (
  input: UpdateDatabaseCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.UpdateDatabase",
  };
  let body: any;
  body = JSON.stringify(se_UpdateDatabaseRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1UpdateDataQualityRulesetCommand
 */
export const se_UpdateDataQualityRulesetCommand = async (
  input: UpdateDataQualityRulesetCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.UpdateDataQualityRuleset",
  };
  let body: any;
  body = JSON.stringify(se_UpdateDataQualityRulesetRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1UpdateDevEndpointCommand
 */
export const se_UpdateDevEndpointCommand = async (
  input: UpdateDevEndpointCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.UpdateDevEndpoint",
  };
  let body: any;
  body = JSON.stringify(se_UpdateDevEndpointRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1UpdateJobCommand
 */
export const se_UpdateJobCommand = async (
  input: UpdateJobCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.UpdateJob",
  };
  let body: any;
  body = JSON.stringify(se_UpdateJobRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1UpdateJobFromSourceControlCommand
 */
export const se_UpdateJobFromSourceControlCommand = async (
  input: UpdateJobFromSourceControlCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.UpdateJobFromSourceControl",
  };
  let body: any;
  body = JSON.stringify(se_UpdateJobFromSourceControlRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1UpdateMLTransformCommand
 */
export const se_UpdateMLTransformCommand = async (
  input: UpdateMLTransformCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.UpdateMLTransform",
  };
  let body: any;
  body = JSON.stringify(se_UpdateMLTransformRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1UpdatePartitionCommand
 */
export const se_UpdatePartitionCommand = async (
  input: UpdatePartitionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.UpdatePartition",
  };
  let body: any;
  body = JSON.stringify(se_UpdatePartitionRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1UpdateRegistryCommand
 */
export const se_UpdateRegistryCommand = async (
  input: UpdateRegistryCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.UpdateRegistry",
  };
  let body: any;
  body = JSON.stringify(se_UpdateRegistryInput(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1UpdateSchemaCommand
 */
export const se_UpdateSchemaCommand = async (
  input: UpdateSchemaCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.UpdateSchema",
  };
  let body: any;
  body = JSON.stringify(se_UpdateSchemaInput(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1UpdateSourceControlFromJobCommand
 */
export const se_UpdateSourceControlFromJobCommand = async (
  input: UpdateSourceControlFromJobCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.UpdateSourceControlFromJob",
  };
  let body: any;
  body = JSON.stringify(se_UpdateSourceControlFromJobRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1UpdateTableCommand
 */
export const se_UpdateTableCommand = async (
  input: UpdateTableCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.UpdateTable",
  };
  let body: any;
  body = JSON.stringify(se_UpdateTableRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1UpdateTriggerCommand
 */
export const se_UpdateTriggerCommand = async (
  input: UpdateTriggerCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.UpdateTrigger",
  };
  let body: any;
  body = JSON.stringify(se_UpdateTriggerRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1UpdateUserDefinedFunctionCommand
 */
export const se_UpdateUserDefinedFunctionCommand = async (
  input: UpdateUserDefinedFunctionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.UpdateUserDefinedFunction",
  };
  let body: any;
  body = JSON.stringify(se_UpdateUserDefinedFunctionRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * serializeAws_json1_1UpdateWorkflowCommand
 */
export const se_UpdateWorkflowCommand = async (
  input: UpdateWorkflowCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "AWSGlue.UpdateWorkflow",
  };
  let body: any;
  body = JSON.stringify(se_UpdateWorkflowRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

/**
 * deserializeAws_json1_1BatchCreatePartitionCommand
 */
export const de_BatchCreatePartitionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchCreatePartitionCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_BatchCreatePartitionCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_BatchCreatePartitionResponse(data, context);
  const response: BatchCreatePartitionCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1BatchCreatePartitionCommandError
 */
const de_BatchCreatePartitionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchCreatePartitionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AlreadyExistsException":
    case "com.amazonaws.glue#AlreadyExistsException":
      throw await de_AlreadyExistsExceptionRes(parsedOutput, context);
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "GlueEncryptionException":
    case "com.amazonaws.glue#GlueEncryptionException":
      throw await de_GlueEncryptionExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    case "ResourceNumberLimitExceededException":
    case "com.amazonaws.glue#ResourceNumberLimitExceededException":
      throw await de_ResourceNumberLimitExceededExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1BatchDeleteConnectionCommand
 */
export const de_BatchDeleteConnectionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchDeleteConnectionCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_BatchDeleteConnectionCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_BatchDeleteConnectionResponse(data, context);
  const response: BatchDeleteConnectionCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1BatchDeleteConnectionCommandError
 */
const de_BatchDeleteConnectionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchDeleteConnectionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1BatchDeletePartitionCommand
 */
export const de_BatchDeletePartitionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchDeletePartitionCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_BatchDeletePartitionCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_BatchDeletePartitionResponse(data, context);
  const response: BatchDeletePartitionCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1BatchDeletePartitionCommandError
 */
const de_BatchDeletePartitionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchDeletePartitionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1BatchDeleteTableCommand
 */
export const de_BatchDeleteTableCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchDeleteTableCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_BatchDeleteTableCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_BatchDeleteTableResponse(data, context);
  const response: BatchDeleteTableCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1BatchDeleteTableCommandError
 */
const de_BatchDeleteTableCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchDeleteTableCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "GlueEncryptionException":
    case "com.amazonaws.glue#GlueEncryptionException":
      throw await de_GlueEncryptionExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    case "ResourceNotReadyException":
    case "com.amazonaws.glue#ResourceNotReadyException":
      throw await de_ResourceNotReadyExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1BatchDeleteTableVersionCommand
 */
export const de_BatchDeleteTableVersionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchDeleteTableVersionCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_BatchDeleteTableVersionCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_BatchDeleteTableVersionResponse(data, context);
  const response: BatchDeleteTableVersionCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1BatchDeleteTableVersionCommandError
 */
const de_BatchDeleteTableVersionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchDeleteTableVersionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1BatchGetBlueprintsCommand
 */
export const de_BatchGetBlueprintsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchGetBlueprintsCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_BatchGetBlueprintsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_BatchGetBlueprintsResponse(data, context);
  const response: BatchGetBlueprintsCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1BatchGetBlueprintsCommandError
 */
const de_BatchGetBlueprintsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchGetBlueprintsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1BatchGetCrawlersCommand
 */
export const de_BatchGetCrawlersCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchGetCrawlersCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_BatchGetCrawlersCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_BatchGetCrawlersResponse(data, context);
  const response: BatchGetCrawlersCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1BatchGetCrawlersCommandError
 */
const de_BatchGetCrawlersCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchGetCrawlersCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1BatchGetCustomEntityTypesCommand
 */
export const de_BatchGetCustomEntityTypesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchGetCustomEntityTypesCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_BatchGetCustomEntityTypesCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_BatchGetCustomEntityTypesResponse(data, context);
  const response: BatchGetCustomEntityTypesCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1BatchGetCustomEntityTypesCommandError
 */
const de_BatchGetCustomEntityTypesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchGetCustomEntityTypesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1BatchGetDataQualityResultCommand
 */
export const de_BatchGetDataQualityResultCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchGetDataQualityResultCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_BatchGetDataQualityResultCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_BatchGetDataQualityResultResponse(data, context);
  const response: BatchGetDataQualityResultCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1BatchGetDataQualityResultCommandError
 */
const de_BatchGetDataQualityResultCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchGetDataQualityResultCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1BatchGetDevEndpointsCommand
 */
export const de_BatchGetDevEndpointsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchGetDevEndpointsCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_BatchGetDevEndpointsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_BatchGetDevEndpointsResponse(data, context);
  const response: BatchGetDevEndpointsCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1BatchGetDevEndpointsCommandError
 */
const de_BatchGetDevEndpointsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchGetDevEndpointsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.glue#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1BatchGetJobsCommand
 */
export const de_BatchGetJobsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchGetJobsCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_BatchGetJobsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_BatchGetJobsResponse(data, context);
  const response: BatchGetJobsCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1BatchGetJobsCommandError
 */
const de_BatchGetJobsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchGetJobsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1BatchGetPartitionCommand
 */
export const de_BatchGetPartitionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchGetPartitionCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_BatchGetPartitionCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_BatchGetPartitionResponse(data, context);
  const response: BatchGetPartitionCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1BatchGetPartitionCommandError
 */
const de_BatchGetPartitionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchGetPartitionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "FederationSourceException":
    case "com.amazonaws.glue#FederationSourceException":
      throw await de_FederationSourceExceptionRes(parsedOutput, context);
    case "FederationSourceRetryableException":
    case "com.amazonaws.glue#FederationSourceRetryableException":
      throw await de_FederationSourceRetryableExceptionRes(parsedOutput, context);
    case "GlueEncryptionException":
    case "com.amazonaws.glue#GlueEncryptionException":
      throw await de_GlueEncryptionExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "InvalidStateException":
    case "com.amazonaws.glue#InvalidStateException":
      throw await de_InvalidStateExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1BatchGetTriggersCommand
 */
export const de_BatchGetTriggersCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchGetTriggersCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_BatchGetTriggersCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_BatchGetTriggersResponse(data, context);
  const response: BatchGetTriggersCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1BatchGetTriggersCommandError
 */
const de_BatchGetTriggersCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchGetTriggersCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1BatchGetWorkflowsCommand
 */
export const de_BatchGetWorkflowsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchGetWorkflowsCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_BatchGetWorkflowsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_BatchGetWorkflowsResponse(data, context);
  const response: BatchGetWorkflowsCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1BatchGetWorkflowsCommandError
 */
const de_BatchGetWorkflowsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchGetWorkflowsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1BatchStopJobRunCommand
 */
export const de_BatchStopJobRunCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchStopJobRunCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_BatchStopJobRunCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_BatchStopJobRunResponse(data, context);
  const response: BatchStopJobRunCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1BatchStopJobRunCommandError
 */
const de_BatchStopJobRunCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchStopJobRunCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1BatchUpdatePartitionCommand
 */
export const de_BatchUpdatePartitionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchUpdatePartitionCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_BatchUpdatePartitionCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_BatchUpdatePartitionResponse(data, context);
  const response: BatchUpdatePartitionCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1BatchUpdatePartitionCommandError
 */
const de_BatchUpdatePartitionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchUpdatePartitionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "GlueEncryptionException":
    case "com.amazonaws.glue#GlueEncryptionException":
      throw await de_GlueEncryptionExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1CancelDataQualityRuleRecommendationRunCommand
 */
export const de_CancelDataQualityRuleRecommendationRunCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CancelDataQualityRuleRecommendationRunCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_CancelDataQualityRuleRecommendationRunCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_CancelDataQualityRuleRecommendationRunResponse(data, context);
  const response: CancelDataQualityRuleRecommendationRunCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1CancelDataQualityRuleRecommendationRunCommandError
 */
const de_CancelDataQualityRuleRecommendationRunCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CancelDataQualityRuleRecommendationRunCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1CancelDataQualityRulesetEvaluationRunCommand
 */
export const de_CancelDataQualityRulesetEvaluationRunCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CancelDataQualityRulesetEvaluationRunCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_CancelDataQualityRulesetEvaluationRunCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_CancelDataQualityRulesetEvaluationRunResponse(data, context);
  const response: CancelDataQualityRulesetEvaluationRunCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1CancelDataQualityRulesetEvaluationRunCommandError
 */
const de_CancelDataQualityRulesetEvaluationRunCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CancelDataQualityRulesetEvaluationRunCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1CancelMLTaskRunCommand
 */
export const de_CancelMLTaskRunCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CancelMLTaskRunCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_CancelMLTaskRunCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_CancelMLTaskRunResponse(data, context);
  const response: CancelMLTaskRunCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1CancelMLTaskRunCommandError
 */
const de_CancelMLTaskRunCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CancelMLTaskRunCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1CancelStatementCommand
 */
export const de_CancelStatementCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CancelStatementCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_CancelStatementCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_CancelStatementResponse(data, context);
  const response: CancelStatementCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1CancelStatementCommandError
 */
const de_CancelStatementCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CancelStatementCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.glue#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "IllegalSessionStateException":
    case "com.amazonaws.glue#IllegalSessionStateException":
      throw await de_IllegalSessionStateExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1CheckSchemaVersionValidityCommand
 */
export const de_CheckSchemaVersionValidityCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CheckSchemaVersionValidityCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_CheckSchemaVersionValidityCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_CheckSchemaVersionValidityResponse(data, context);
  const response: CheckSchemaVersionValidityCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1CheckSchemaVersionValidityCommandError
 */
const de_CheckSchemaVersionValidityCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CheckSchemaVersionValidityCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.glue#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1CreateBlueprintCommand
 */
export const de_CreateBlueprintCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateBlueprintCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_CreateBlueprintCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_CreateBlueprintResponse(data, context);
  const response: CreateBlueprintCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1CreateBlueprintCommandError
 */
const de_CreateBlueprintCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateBlueprintCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AlreadyExistsException":
    case "com.amazonaws.glue#AlreadyExistsException":
      throw await de_AlreadyExistsExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    case "ResourceNumberLimitExceededException":
    case "com.amazonaws.glue#ResourceNumberLimitExceededException":
      throw await de_ResourceNumberLimitExceededExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1CreateClassifierCommand
 */
export const de_CreateClassifierCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateClassifierCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_CreateClassifierCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_CreateClassifierResponse(data, context);
  const response: CreateClassifierCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1CreateClassifierCommandError
 */
const de_CreateClassifierCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateClassifierCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AlreadyExistsException":
    case "com.amazonaws.glue#AlreadyExistsException":
      throw await de_AlreadyExistsExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1CreateConnectionCommand
 */
export const de_CreateConnectionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateConnectionCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_CreateConnectionCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_CreateConnectionResponse(data, context);
  const response: CreateConnectionCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1CreateConnectionCommandError
 */
const de_CreateConnectionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateConnectionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AlreadyExistsException":
    case "com.amazonaws.glue#AlreadyExistsException":
      throw await de_AlreadyExistsExceptionRes(parsedOutput, context);
    case "GlueEncryptionException":
    case "com.amazonaws.glue#GlueEncryptionException":
      throw await de_GlueEncryptionExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    case "ResourceNumberLimitExceededException":
    case "com.amazonaws.glue#ResourceNumberLimitExceededException":
      throw await de_ResourceNumberLimitExceededExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1CreateCrawlerCommand
 */
export const de_CreateCrawlerCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateCrawlerCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_CreateCrawlerCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_CreateCrawlerResponse(data, context);
  const response: CreateCrawlerCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1CreateCrawlerCommandError
 */
const de_CreateCrawlerCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateCrawlerCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AlreadyExistsException":
    case "com.amazonaws.glue#AlreadyExistsException":
      throw await de_AlreadyExistsExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    case "ResourceNumberLimitExceededException":
    case "com.amazonaws.glue#ResourceNumberLimitExceededException":
      throw await de_ResourceNumberLimitExceededExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1CreateCustomEntityTypeCommand
 */
export const de_CreateCustomEntityTypeCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateCustomEntityTypeCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_CreateCustomEntityTypeCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_CreateCustomEntityTypeResponse(data, context);
  const response: CreateCustomEntityTypeCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1CreateCustomEntityTypeCommandError
 */
const de_CreateCustomEntityTypeCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateCustomEntityTypeCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.glue#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "AlreadyExistsException":
    case "com.amazonaws.glue#AlreadyExistsException":
      throw await de_AlreadyExistsExceptionRes(parsedOutput, context);
    case "IdempotentParameterMismatchException":
    case "com.amazonaws.glue#IdempotentParameterMismatchException":
      throw await de_IdempotentParameterMismatchExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    case "ResourceNumberLimitExceededException":
    case "com.amazonaws.glue#ResourceNumberLimitExceededException":
      throw await de_ResourceNumberLimitExceededExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1CreateDatabaseCommand
 */
export const de_CreateDatabaseCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDatabaseCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_CreateDatabaseCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_CreateDatabaseResponse(data, context);
  const response: CreateDatabaseCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1CreateDatabaseCommandError
 */
const de_CreateDatabaseCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDatabaseCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AlreadyExistsException":
    case "com.amazonaws.glue#AlreadyExistsException":
      throw await de_AlreadyExistsExceptionRes(parsedOutput, context);
    case "ConcurrentModificationException":
    case "com.amazonaws.glue#ConcurrentModificationException":
      throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
    case "FederatedResourceAlreadyExistsException":
    case "com.amazonaws.glue#FederatedResourceAlreadyExistsException":
      throw await de_FederatedResourceAlreadyExistsExceptionRes(parsedOutput, context);
    case "GlueEncryptionException":
    case "com.amazonaws.glue#GlueEncryptionException":
      throw await de_GlueEncryptionExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    case "ResourceNumberLimitExceededException":
    case "com.amazonaws.glue#ResourceNumberLimitExceededException":
      throw await de_ResourceNumberLimitExceededExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1CreateDataQualityRulesetCommand
 */
export const de_CreateDataQualityRulesetCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDataQualityRulesetCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_CreateDataQualityRulesetCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_CreateDataQualityRulesetResponse(data, context);
  const response: CreateDataQualityRulesetCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1CreateDataQualityRulesetCommandError
 */
const de_CreateDataQualityRulesetCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDataQualityRulesetCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AlreadyExistsException":
    case "com.amazonaws.glue#AlreadyExistsException":
      throw await de_AlreadyExistsExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    case "ResourceNumberLimitExceededException":
    case "com.amazonaws.glue#ResourceNumberLimitExceededException":
      throw await de_ResourceNumberLimitExceededExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1CreateDevEndpointCommand
 */
export const de_CreateDevEndpointCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDevEndpointCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_CreateDevEndpointCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_CreateDevEndpointResponse(data, context);
  const response: CreateDevEndpointCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1CreateDevEndpointCommandError
 */
const de_CreateDevEndpointCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDevEndpointCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.glue#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "AlreadyExistsException":
    case "com.amazonaws.glue#AlreadyExistsException":
      throw await de_AlreadyExistsExceptionRes(parsedOutput, context);
    case "IdempotentParameterMismatchException":
    case "com.amazonaws.glue#IdempotentParameterMismatchException":
      throw await de_IdempotentParameterMismatchExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    case "ResourceNumberLimitExceededException":
    case "com.amazonaws.glue#ResourceNumberLimitExceededException":
      throw await de_ResourceNumberLimitExceededExceptionRes(parsedOutput, context);
    case "ValidationException":
    case "com.amazonaws.glue#ValidationException":
      throw await de_ValidationExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1CreateJobCommand
 */
export const de_CreateJobCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateJobCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_CreateJobCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_CreateJobResponse(data, context);
  const response: CreateJobCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1CreateJobCommandError
 */
const de_CreateJobCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateJobCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AlreadyExistsException":
    case "com.amazonaws.glue#AlreadyExistsException":
      throw await de_AlreadyExistsExceptionRes(parsedOutput, context);
    case "ConcurrentModificationException":
    case "com.amazonaws.glue#ConcurrentModificationException":
      throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
    case "IdempotentParameterMismatchException":
    case "com.amazonaws.glue#IdempotentParameterMismatchException":
      throw await de_IdempotentParameterMismatchExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    case "ResourceNumberLimitExceededException":
    case "com.amazonaws.glue#ResourceNumberLimitExceededException":
      throw await de_ResourceNumberLimitExceededExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1CreateMLTransformCommand
 */
export const de_CreateMLTransformCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateMLTransformCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_CreateMLTransformCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_CreateMLTransformResponse(data, context);
  const response: CreateMLTransformCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1CreateMLTransformCommandError
 */
const de_CreateMLTransformCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateMLTransformCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.glue#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "AlreadyExistsException":
    case "com.amazonaws.glue#AlreadyExistsException":
      throw await de_AlreadyExistsExceptionRes(parsedOutput, context);
    case "IdempotentParameterMismatchException":
    case "com.amazonaws.glue#IdempotentParameterMismatchException":
      throw await de_IdempotentParameterMismatchExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    case "ResourceNumberLimitExceededException":
    case "com.amazonaws.glue#ResourceNumberLimitExceededException":
      throw await de_ResourceNumberLimitExceededExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1CreatePartitionCommand
 */
export const de_CreatePartitionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreatePartitionCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_CreatePartitionCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_CreatePartitionResponse(data, context);
  const response: CreatePartitionCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1CreatePartitionCommandError
 */
const de_CreatePartitionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreatePartitionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AlreadyExistsException":
    case "com.amazonaws.glue#AlreadyExistsException":
      throw await de_AlreadyExistsExceptionRes(parsedOutput, context);
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "GlueEncryptionException":
    case "com.amazonaws.glue#GlueEncryptionException":
      throw await de_GlueEncryptionExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    case "ResourceNumberLimitExceededException":
    case "com.amazonaws.glue#ResourceNumberLimitExceededException":
      throw await de_ResourceNumberLimitExceededExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1CreatePartitionIndexCommand
 */
export const de_CreatePartitionIndexCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreatePartitionIndexCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_CreatePartitionIndexCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_CreatePartitionIndexResponse(data, context);
  const response: CreatePartitionIndexCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1CreatePartitionIndexCommandError
 */
const de_CreatePartitionIndexCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreatePartitionIndexCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AlreadyExistsException":
    case "com.amazonaws.glue#AlreadyExistsException":
      throw await de_AlreadyExistsExceptionRes(parsedOutput, context);
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "GlueEncryptionException":
    case "com.amazonaws.glue#GlueEncryptionException":
      throw await de_GlueEncryptionExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    case "ResourceNumberLimitExceededException":
    case "com.amazonaws.glue#ResourceNumberLimitExceededException":
      throw await de_ResourceNumberLimitExceededExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1CreateRegistryCommand
 */
export const de_CreateRegistryCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateRegistryCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_CreateRegistryCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_CreateRegistryResponse(data, context);
  const response: CreateRegistryCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1CreateRegistryCommandError
 */
const de_CreateRegistryCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateRegistryCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.glue#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "AlreadyExistsException":
    case "com.amazonaws.glue#AlreadyExistsException":
      throw await de_AlreadyExistsExceptionRes(parsedOutput, context);
    case "ConcurrentModificationException":
    case "com.amazonaws.glue#ConcurrentModificationException":
      throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "ResourceNumberLimitExceededException":
    case "com.amazonaws.glue#ResourceNumberLimitExceededException":
      throw await de_ResourceNumberLimitExceededExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1CreateSchemaCommand
 */
export const de_CreateSchemaCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateSchemaCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_CreateSchemaCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_CreateSchemaResponse(data, context);
  const response: CreateSchemaCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1CreateSchemaCommandError
 */
const de_CreateSchemaCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateSchemaCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.glue#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "AlreadyExistsException":
    case "com.amazonaws.glue#AlreadyExistsException":
      throw await de_AlreadyExistsExceptionRes(parsedOutput, context);
    case "ConcurrentModificationException":
    case "com.amazonaws.glue#ConcurrentModificationException":
      throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "ResourceNumberLimitExceededException":
    case "com.amazonaws.glue#ResourceNumberLimitExceededException":
      throw await de_ResourceNumberLimitExceededExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1CreateScriptCommand
 */
export const de_CreateScriptCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateScriptCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_CreateScriptCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_CreateScriptResponse(data, context);
  const response: CreateScriptCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1CreateScriptCommandError
 */
const de_CreateScriptCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateScriptCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1CreateSecurityConfigurationCommand
 */
export const de_CreateSecurityConfigurationCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateSecurityConfigurationCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_CreateSecurityConfigurationCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_CreateSecurityConfigurationResponse(data, context);
  const response: CreateSecurityConfigurationCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1CreateSecurityConfigurationCommandError
 */
const de_CreateSecurityConfigurationCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateSecurityConfigurationCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AlreadyExistsException":
    case "com.amazonaws.glue#AlreadyExistsException":
      throw await de_AlreadyExistsExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    case "ResourceNumberLimitExceededException":
    case "com.amazonaws.glue#ResourceNumberLimitExceededException":
      throw await de_ResourceNumberLimitExceededExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1CreateSessionCommand
 */
export const de_CreateSessionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateSessionCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_CreateSessionCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_CreateSessionResponse(data, context);
  const response: CreateSessionCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1CreateSessionCommandError
 */
const de_CreateSessionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateSessionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.glue#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "AlreadyExistsException":
    case "com.amazonaws.glue#AlreadyExistsException":
      throw await de_AlreadyExistsExceptionRes(parsedOutput, context);
    case "IdempotentParameterMismatchException":
    case "com.amazonaws.glue#IdempotentParameterMismatchException":
      throw await de_IdempotentParameterMismatchExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    case "ResourceNumberLimitExceededException":
    case "com.amazonaws.glue#ResourceNumberLimitExceededException":
      throw await de_ResourceNumberLimitExceededExceptionRes(parsedOutput, context);
    case "ValidationException":
    case "com.amazonaws.glue#ValidationException":
      throw await de_ValidationExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1CreateTableCommand
 */
export const de_CreateTableCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateTableCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_CreateTableCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_CreateTableResponse(data, context);
  const response: CreateTableCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1CreateTableCommandError
 */
const de_CreateTableCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateTableCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AlreadyExistsException":
    case "com.amazonaws.glue#AlreadyExistsException":
      throw await de_AlreadyExistsExceptionRes(parsedOutput, context);
    case "ConcurrentModificationException":
    case "com.amazonaws.glue#ConcurrentModificationException":
      throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "GlueEncryptionException":
    case "com.amazonaws.glue#GlueEncryptionException":
      throw await de_GlueEncryptionExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    case "ResourceNotReadyException":
    case "com.amazonaws.glue#ResourceNotReadyException":
      throw await de_ResourceNotReadyExceptionRes(parsedOutput, context);
    case "ResourceNumberLimitExceededException":
    case "com.amazonaws.glue#ResourceNumberLimitExceededException":
      throw await de_ResourceNumberLimitExceededExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1CreateTriggerCommand
 */
export const de_CreateTriggerCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateTriggerCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_CreateTriggerCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_CreateTriggerResponse(data, context);
  const response: CreateTriggerCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1CreateTriggerCommandError
 */
const de_CreateTriggerCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateTriggerCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AlreadyExistsException":
    case "com.amazonaws.glue#AlreadyExistsException":
      throw await de_AlreadyExistsExceptionRes(parsedOutput, context);
    case "ConcurrentModificationException":
    case "com.amazonaws.glue#ConcurrentModificationException":
      throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "IdempotentParameterMismatchException":
    case "com.amazonaws.glue#IdempotentParameterMismatchException":
      throw await de_IdempotentParameterMismatchExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    case "ResourceNumberLimitExceededException":
    case "com.amazonaws.glue#ResourceNumberLimitExceededException":
      throw await de_ResourceNumberLimitExceededExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1CreateUserDefinedFunctionCommand
 */
export const de_CreateUserDefinedFunctionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateUserDefinedFunctionCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_CreateUserDefinedFunctionCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_CreateUserDefinedFunctionResponse(data, context);
  const response: CreateUserDefinedFunctionCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1CreateUserDefinedFunctionCommandError
 */
const de_CreateUserDefinedFunctionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateUserDefinedFunctionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AlreadyExistsException":
    case "com.amazonaws.glue#AlreadyExistsException":
      throw await de_AlreadyExistsExceptionRes(parsedOutput, context);
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "GlueEncryptionException":
    case "com.amazonaws.glue#GlueEncryptionException":
      throw await de_GlueEncryptionExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    case "ResourceNumberLimitExceededException":
    case "com.amazonaws.glue#ResourceNumberLimitExceededException":
      throw await de_ResourceNumberLimitExceededExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1CreateWorkflowCommand
 */
export const de_CreateWorkflowCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateWorkflowCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_CreateWorkflowCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_CreateWorkflowResponse(data, context);
  const response: CreateWorkflowCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1CreateWorkflowCommandError
 */
const de_CreateWorkflowCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateWorkflowCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AlreadyExistsException":
    case "com.amazonaws.glue#AlreadyExistsException":
      throw await de_AlreadyExistsExceptionRes(parsedOutput, context);
    case "ConcurrentModificationException":
    case "com.amazonaws.glue#ConcurrentModificationException":
      throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    case "ResourceNumberLimitExceededException":
    case "com.amazonaws.glue#ResourceNumberLimitExceededException":
      throw await de_ResourceNumberLimitExceededExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1DeleteBlueprintCommand
 */
export const de_DeleteBlueprintCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteBlueprintCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_DeleteBlueprintCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_DeleteBlueprintResponse(data, context);
  const response: DeleteBlueprintCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1DeleteBlueprintCommandError
 */
const de_DeleteBlueprintCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteBlueprintCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1DeleteClassifierCommand
 */
export const de_DeleteClassifierCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteClassifierCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_DeleteClassifierCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_DeleteClassifierResponse(data, context);
  const response: DeleteClassifierCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1DeleteClassifierCommandError
 */
const de_DeleteClassifierCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteClassifierCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1DeleteColumnStatisticsForPartitionCommand
 */
export const de_DeleteColumnStatisticsForPartitionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteColumnStatisticsForPartitionCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_DeleteColumnStatisticsForPartitionCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_DeleteColumnStatisticsForPartitionResponse(data, context);
  const response: DeleteColumnStatisticsForPartitionCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1DeleteColumnStatisticsForPartitionCommandError
 */
const de_DeleteColumnStatisticsForPartitionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteColumnStatisticsForPartitionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "GlueEncryptionException":
    case "com.amazonaws.glue#GlueEncryptionException":
      throw await de_GlueEncryptionExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1DeleteColumnStatisticsForTableCommand
 */
export const de_DeleteColumnStatisticsForTableCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteColumnStatisticsForTableCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_DeleteColumnStatisticsForTableCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_DeleteColumnStatisticsForTableResponse(data, context);
  const response: DeleteColumnStatisticsForTableCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1DeleteColumnStatisticsForTableCommandError
 */
const de_DeleteColumnStatisticsForTableCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteColumnStatisticsForTableCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "GlueEncryptionException":
    case "com.amazonaws.glue#GlueEncryptionException":
      throw await de_GlueEncryptionExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1DeleteConnectionCommand
 */
export const de_DeleteConnectionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteConnectionCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_DeleteConnectionCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_DeleteConnectionResponse(data, context);
  const response: DeleteConnectionCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1DeleteConnectionCommandError
 */
const de_DeleteConnectionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteConnectionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1DeleteCrawlerCommand
 */
export const de_DeleteCrawlerCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteCrawlerCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_DeleteCrawlerCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_DeleteCrawlerResponse(data, context);
  const response: DeleteCrawlerCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1DeleteCrawlerCommandError
 */
const de_DeleteCrawlerCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteCrawlerCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "CrawlerRunningException":
    case "com.amazonaws.glue#CrawlerRunningException":
      throw await de_CrawlerRunningExceptionRes(parsedOutput, context);
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    case "SchedulerTransitioningException":
    case "com.amazonaws.glue#SchedulerTransitioningException":
      throw await de_SchedulerTransitioningExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1DeleteCustomEntityTypeCommand
 */
export const de_DeleteCustomEntityTypeCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteCustomEntityTypeCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_DeleteCustomEntityTypeCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_DeleteCustomEntityTypeResponse(data, context);
  const response: DeleteCustomEntityTypeCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1DeleteCustomEntityTypeCommandError
 */
const de_DeleteCustomEntityTypeCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteCustomEntityTypeCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.glue#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1DeleteDatabaseCommand
 */
export const de_DeleteDatabaseCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteDatabaseCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_DeleteDatabaseCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_DeleteDatabaseResponse(data, context);
  const response: DeleteDatabaseCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1DeleteDatabaseCommandError
 */
const de_DeleteDatabaseCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteDatabaseCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ConcurrentModificationException":
    case "com.amazonaws.glue#ConcurrentModificationException":
      throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1DeleteDataQualityRulesetCommand
 */
export const de_DeleteDataQualityRulesetCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteDataQualityRulesetCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_DeleteDataQualityRulesetCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_DeleteDataQualityRulesetResponse(data, context);
  const response: DeleteDataQualityRulesetCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1DeleteDataQualityRulesetCommandError
 */
const de_DeleteDataQualityRulesetCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteDataQualityRulesetCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1DeleteDevEndpointCommand
 */
export const de_DeleteDevEndpointCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteDevEndpointCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_DeleteDevEndpointCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_DeleteDevEndpointResponse(data, context);
  const response: DeleteDevEndpointCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1DeleteDevEndpointCommandError
 */
const de_DeleteDevEndpointCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteDevEndpointCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1DeleteJobCommand
 */
export const de_DeleteJobCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteJobCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_DeleteJobCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_DeleteJobResponse(data, context);
  const response: DeleteJobCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1DeleteJobCommandError
 */
const de_DeleteJobCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteJobCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1DeleteMLTransformCommand
 */
export const de_DeleteMLTransformCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteMLTransformCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_DeleteMLTransformCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_DeleteMLTransformResponse(data, context);
  const response: DeleteMLTransformCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1DeleteMLTransformCommandError
 */
const de_DeleteMLTransformCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteMLTransformCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1DeletePartitionCommand
 */
export const de_DeletePartitionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeletePartitionCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_DeletePartitionCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_DeletePartitionResponse(data, context);
  const response: DeletePartitionCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1DeletePartitionCommandError
 */
const de_DeletePartitionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeletePartitionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1DeletePartitionIndexCommand
 */
export const de_DeletePartitionIndexCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeletePartitionIndexCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_DeletePartitionIndexCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_DeletePartitionIndexResponse(data, context);
  const response: DeletePartitionIndexCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1DeletePartitionIndexCommandError
 */
const de_DeletePartitionIndexCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeletePartitionIndexCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ConflictException":
    case "com.amazonaws.glue#ConflictException":
      throw await de_ConflictExceptionRes(parsedOutput, context);
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "GlueEncryptionException":
    case "com.amazonaws.glue#GlueEncryptionException":
      throw await de_GlueEncryptionExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1DeleteRegistryCommand
 */
export const de_DeleteRegistryCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteRegistryCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_DeleteRegistryCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_DeleteRegistryResponse(data, context);
  const response: DeleteRegistryCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1DeleteRegistryCommandError
 */
const de_DeleteRegistryCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteRegistryCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.glue#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "ConcurrentModificationException":
    case "com.amazonaws.glue#ConcurrentModificationException":
      throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1DeleteResourcePolicyCommand
 */
export const de_DeleteResourcePolicyCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteResourcePolicyCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_DeleteResourcePolicyCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_DeleteResourcePolicyResponse(data, context);
  const response: DeleteResourcePolicyCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1DeleteResourcePolicyCommandError
 */
const de_DeleteResourcePolicyCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteResourcePolicyCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ConditionCheckFailureException":
    case "com.amazonaws.glue#ConditionCheckFailureException":
      throw await de_ConditionCheckFailureExceptionRes(parsedOutput, context);
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1DeleteSchemaCommand
 */
export const de_DeleteSchemaCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteSchemaCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_DeleteSchemaCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_DeleteSchemaResponse(data, context);
  const response: DeleteSchemaCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1DeleteSchemaCommandError
 */
const de_DeleteSchemaCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteSchemaCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.glue#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "ConcurrentModificationException":
    case "com.amazonaws.glue#ConcurrentModificationException":
      throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1DeleteSchemaVersionsCommand
 */
export const de_DeleteSchemaVersionsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteSchemaVersionsCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_DeleteSchemaVersionsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_DeleteSchemaVersionsResponse(data, context);
  const response: DeleteSchemaVersionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1DeleteSchemaVersionsCommandError
 */
const de_DeleteSchemaVersionsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteSchemaVersionsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.glue#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "ConcurrentModificationException":
    case "com.amazonaws.glue#ConcurrentModificationException":
      throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1DeleteSecurityConfigurationCommand
 */
export const de_DeleteSecurityConfigurationCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteSecurityConfigurationCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_DeleteSecurityConfigurationCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_DeleteSecurityConfigurationResponse(data, context);
  const response: DeleteSecurityConfigurationCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1DeleteSecurityConfigurationCommandError
 */
const de_DeleteSecurityConfigurationCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteSecurityConfigurationCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1DeleteSessionCommand
 */
export const de_DeleteSessionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteSessionCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_DeleteSessionCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_DeleteSessionResponse(data, context);
  const response: DeleteSessionCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1DeleteSessionCommandError
 */
const de_DeleteSessionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteSessionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.glue#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "ConcurrentModificationException":
    case "com.amazonaws.glue#ConcurrentModificationException":
      throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
    case "IllegalSessionStateException":
    case "com.amazonaws.glue#IllegalSessionStateException":
      throw await de_IllegalSessionStateExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1DeleteTableCommand
 */
export const de_DeleteTableCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteTableCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_DeleteTableCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_DeleteTableResponse(data, context);
  const response: DeleteTableCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1DeleteTableCommandError
 */
const de_DeleteTableCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteTableCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ConcurrentModificationException":
    case "com.amazonaws.glue#ConcurrentModificationException":
      throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    case "ResourceNotReadyException":
    case "com.amazonaws.glue#ResourceNotReadyException":
      throw await de_ResourceNotReadyExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1DeleteTableVersionCommand
 */
export const de_DeleteTableVersionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteTableVersionCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_DeleteTableVersionCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_DeleteTableVersionResponse(data, context);
  const response: DeleteTableVersionCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1DeleteTableVersionCommandError
 */
const de_DeleteTableVersionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteTableVersionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1DeleteTriggerCommand
 */
export const de_DeleteTriggerCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteTriggerCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_DeleteTriggerCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_DeleteTriggerResponse(data, context);
  const response: DeleteTriggerCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1DeleteTriggerCommandError
 */
const de_DeleteTriggerCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteTriggerCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ConcurrentModificationException":
    case "com.amazonaws.glue#ConcurrentModificationException":
      throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1DeleteUserDefinedFunctionCommand
 */
export const de_DeleteUserDefinedFunctionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteUserDefinedFunctionCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_DeleteUserDefinedFunctionCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_DeleteUserDefinedFunctionResponse(data, context);
  const response: DeleteUserDefinedFunctionCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1DeleteUserDefinedFunctionCommandError
 */
const de_DeleteUserDefinedFunctionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteUserDefinedFunctionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1DeleteWorkflowCommand
 */
export const de_DeleteWorkflowCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteWorkflowCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_DeleteWorkflowCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_DeleteWorkflowResponse(data, context);
  const response: DeleteWorkflowCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1DeleteWorkflowCommandError
 */
const de_DeleteWorkflowCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteWorkflowCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ConcurrentModificationException":
    case "com.amazonaws.glue#ConcurrentModificationException":
      throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1GetBlueprintCommand
 */
export const de_GetBlueprintCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetBlueprintCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_GetBlueprintCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_GetBlueprintResponse(data, context);
  const response: GetBlueprintCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1GetBlueprintCommandError
 */
const de_GetBlueprintCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetBlueprintCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1GetBlueprintRunCommand
 */
export const de_GetBlueprintRunCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetBlueprintRunCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_GetBlueprintRunCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_GetBlueprintRunResponse(data, context);
  const response: GetBlueprintRunCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1GetBlueprintRunCommandError
 */
const de_GetBlueprintRunCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetBlueprintRunCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1GetBlueprintRunsCommand
 */
export const de_GetBlueprintRunsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetBlueprintRunsCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_GetBlueprintRunsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_GetBlueprintRunsResponse(data, context);
  const response: GetBlueprintRunsCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1GetBlueprintRunsCommandError
 */
const de_GetBlueprintRunsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetBlueprintRunsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1GetCatalogImportStatusCommand
 */
export const de_GetCatalogImportStatusCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetCatalogImportStatusCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_GetCatalogImportStatusCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_GetCatalogImportStatusResponse(data, context);
  const response: GetCatalogImportStatusCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1GetCatalogImportStatusCommandError
 */
const de_GetCatalogImportStatusCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetCatalogImportStatusCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1GetClassifierCommand
 */
export const de_GetClassifierCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetClassifierCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_GetClassifierCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_GetClassifierResponse(data, context);
  const response: GetClassifierCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1GetClassifierCommandError
 */
const de_GetClassifierCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetClassifierCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1GetClassifiersCommand
 */
export const de_GetClassifiersCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetClassifiersCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_GetClassifiersCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_GetClassifiersResponse(data, context);
  const response: GetClassifiersCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1GetClassifiersCommandError
 */
const de_GetClassifiersCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetClassifiersCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1GetColumnStatisticsForPartitionCommand
 */
export const de_GetColumnStatisticsForPartitionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetColumnStatisticsForPartitionCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_GetColumnStatisticsForPartitionCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_GetColumnStatisticsForPartitionResponse(data, context);
  const response: GetColumnStatisticsForPartitionCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1GetColumnStatisticsForPartitionCommandError
 */
const de_GetColumnStatisticsForPartitionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetColumnStatisticsForPartitionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "GlueEncryptionException":
    case "com.amazonaws.glue#GlueEncryptionException":
      throw await de_GlueEncryptionExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1GetColumnStatisticsForTableCommand
 */
export const de_GetColumnStatisticsForTableCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetColumnStatisticsForTableCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_GetColumnStatisticsForTableCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_GetColumnStatisticsForTableResponse(data, context);
  const response: GetColumnStatisticsForTableCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1GetColumnStatisticsForTableCommandError
 */
const de_GetColumnStatisticsForTableCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetColumnStatisticsForTableCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "GlueEncryptionException":
    case "com.amazonaws.glue#GlueEncryptionException":
      throw await de_GlueEncryptionExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1GetConnectionCommand
 */
export const de_GetConnectionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetConnectionCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_GetConnectionCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_GetConnectionResponse(data, context);
  const response: GetConnectionCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1GetConnectionCommandError
 */
const de_GetConnectionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetConnectionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "GlueEncryptionException":
    case "com.amazonaws.glue#GlueEncryptionException":
      throw await de_GlueEncryptionExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1GetConnectionsCommand
 */
export const de_GetConnectionsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetConnectionsCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_GetConnectionsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_GetConnectionsResponse(data, context);
  const response: GetConnectionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1GetConnectionsCommandError
 */
const de_GetConnectionsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetConnectionsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "GlueEncryptionException":
    case "com.amazonaws.glue#GlueEncryptionException":
      throw await de_GlueEncryptionExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1GetCrawlerCommand
 */
export const de_GetCrawlerCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetCrawlerCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_GetCrawlerCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_GetCrawlerResponse(data, context);
  const response: GetCrawlerCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1GetCrawlerCommandError
 */
const de_GetCrawlerCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetCrawlerCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1GetCrawlerMetricsCommand
 */
export const de_GetCrawlerMetricsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetCrawlerMetricsCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_GetCrawlerMetricsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_GetCrawlerMetricsResponse(data, context);
  const response: GetCrawlerMetricsCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1GetCrawlerMetricsCommandError
 */
const de_GetCrawlerMetricsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetCrawlerMetricsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1GetCrawlersCommand
 */
export const de_GetCrawlersCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetCrawlersCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_GetCrawlersCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_GetCrawlersResponse(data, context);
  const response: GetCrawlersCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1GetCrawlersCommandError
 */
const de_GetCrawlersCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetCrawlersCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1GetCustomEntityTypeCommand
 */
export const de_GetCustomEntityTypeCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetCustomEntityTypeCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_GetCustomEntityTypeCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_GetCustomEntityTypeResponse(data, context);
  const response: GetCustomEntityTypeCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1GetCustomEntityTypeCommandError
 */
const de_GetCustomEntityTypeCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetCustomEntityTypeCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.glue#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1GetDatabaseCommand
 */
export const de_GetDatabaseCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetDatabaseCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_GetDatabaseCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_GetDatabaseResponse(data, context);
  const response: GetDatabaseCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1GetDatabaseCommandError
 */
const de_GetDatabaseCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetDatabaseCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "FederationSourceException":
    case "com.amazonaws.glue#FederationSourceException":
      throw await de_FederationSourceExceptionRes(parsedOutput, context);
    case "GlueEncryptionException":
    case "com.amazonaws.glue#GlueEncryptionException":
      throw await de_GlueEncryptionExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1GetDatabasesCommand
 */
export const de_GetDatabasesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetDatabasesCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_GetDatabasesCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_GetDatabasesResponse(data, context);
  const response: GetDatabasesCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1GetDatabasesCommandError
 */
const de_GetDatabasesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetDatabasesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "GlueEncryptionException":
    case "com.amazonaws.glue#GlueEncryptionException":
      throw await de_GlueEncryptionExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1GetDataCatalogEncryptionSettingsCommand
 */
export const de_GetDataCatalogEncryptionSettingsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetDataCatalogEncryptionSettingsCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_GetDataCatalogEncryptionSettingsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_GetDataCatalogEncryptionSettingsResponse(data, context);
  const response: GetDataCatalogEncryptionSettingsCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1GetDataCatalogEncryptionSettingsCommandError
 */
const de_GetDataCatalogEncryptionSettingsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetDataCatalogEncryptionSettingsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1GetDataflowGraphCommand
 */
export const de_GetDataflowGraphCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetDataflowGraphCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_GetDataflowGraphCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_GetDataflowGraphResponse(data, context);
  const response: GetDataflowGraphCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1GetDataflowGraphCommandError
 */
const de_GetDataflowGraphCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetDataflowGraphCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1GetDataQualityResultCommand
 */
export const de_GetDataQualityResultCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetDataQualityResultCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_GetDataQualityResultCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_GetDataQualityResultResponse(data, context);
  const response: GetDataQualityResultCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1GetDataQualityResultCommandError
 */
const de_GetDataQualityResultCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetDataQualityResultCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1GetDataQualityRuleRecommendationRunCommand
 */
export const de_GetDataQualityRuleRecommendationRunCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetDataQualityRuleRecommendationRunCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_GetDataQualityRuleRecommendationRunCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_GetDataQualityRuleRecommendationRunResponse(data, context);
  const response: GetDataQualityRuleRecommendationRunCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1GetDataQualityRuleRecommendationRunCommandError
 */
const de_GetDataQualityRuleRecommendationRunCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetDataQualityRuleRecommendationRunCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1GetDataQualityRulesetCommand
 */
export const de_GetDataQualityRulesetCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetDataQualityRulesetCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_GetDataQualityRulesetCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_GetDataQualityRulesetResponse(data, context);
  const response: GetDataQualityRulesetCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1GetDataQualityRulesetCommandError
 */
const de_GetDataQualityRulesetCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetDataQualityRulesetCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1GetDataQualityRulesetEvaluationRunCommand
 */
export const de_GetDataQualityRulesetEvaluationRunCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetDataQualityRulesetEvaluationRunCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_GetDataQualityRulesetEvaluationRunCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_GetDataQualityRulesetEvaluationRunResponse(data, context);
  const response: GetDataQualityRulesetEvaluationRunCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1GetDataQualityRulesetEvaluationRunCommandError
 */
const de_GetDataQualityRulesetEvaluationRunCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetDataQualityRulesetEvaluationRunCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1GetDevEndpointCommand
 */
export const de_GetDevEndpointCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetDevEndpointCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_GetDevEndpointCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_GetDevEndpointResponse(data, context);
  const response: GetDevEndpointCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1GetDevEndpointCommandError
 */
const de_GetDevEndpointCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetDevEndpointCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1GetDevEndpointsCommand
 */
export const de_GetDevEndpointsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetDevEndpointsCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_GetDevEndpointsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_GetDevEndpointsResponse(data, context);
  const response: GetDevEndpointsCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1GetDevEndpointsCommandError
 */
const de_GetDevEndpointsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetDevEndpointsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1GetJobCommand
 */
export const de_GetJobCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetJobCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_GetJobCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_GetJobResponse(data, context);
  const response: GetJobCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1GetJobCommandError
 */
const de_GetJobCommandError = async (output: __HttpResponse, context: __SerdeContext): Promise<GetJobCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1GetJobBookmarkCommand
 */
export const de_GetJobBookmarkCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetJobBookmarkCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_GetJobBookmarkCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_GetJobBookmarkResponse(data, context);
  const response: GetJobBookmarkCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1GetJobBookmarkCommandError
 */
const de_GetJobBookmarkCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetJobBookmarkCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    case "ValidationException":
    case "com.amazonaws.glue#ValidationException":
      throw await de_ValidationExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1GetJobRunCommand
 */
export const de_GetJobRunCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetJobRunCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_GetJobRunCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_GetJobRunResponse(data, context);
  const response: GetJobRunCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1GetJobRunCommandError
 */
const de_GetJobRunCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetJobRunCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1GetJobRunsCommand
 */
export const de_GetJobRunsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetJobRunsCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_GetJobRunsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_GetJobRunsResponse(data, context);
  const response: GetJobRunsCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1GetJobRunsCommandError
 */
const de_GetJobRunsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetJobRunsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1GetJobsCommand
 */
export const de_GetJobsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetJobsCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_GetJobsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_GetJobsResponse(data, context);
  const response: GetJobsCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1GetJobsCommandError
 */
const de_GetJobsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetJobsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1GetMappingCommand
 */
export const de_GetMappingCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetMappingCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_GetMappingCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_GetMappingResponse(data, context);
  const response: GetMappingCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1GetMappingCommandError
 */
const de_GetMappingCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetMappingCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1GetMLTaskRunCommand
 */
export const de_GetMLTaskRunCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetMLTaskRunCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_GetMLTaskRunCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_GetMLTaskRunResponse(data, context);
  const response: GetMLTaskRunCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1GetMLTaskRunCommandError
 */
const de_GetMLTaskRunCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetMLTaskRunCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1GetMLTaskRunsCommand
 */
export const de_GetMLTaskRunsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetMLTaskRunsCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_GetMLTaskRunsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_GetMLTaskRunsResponse(data, context);
  const response: GetMLTaskRunsCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1GetMLTaskRunsCommandError
 */
const de_GetMLTaskRunsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetMLTaskRunsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1GetMLTransformCommand
 */
export const de_GetMLTransformCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetMLTransformCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_GetMLTransformCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_GetMLTransformResponse(data, context);
  const response: GetMLTransformCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1GetMLTransformCommandError
 */
const de_GetMLTransformCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetMLTransformCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1GetMLTransformsCommand
 */
export const de_GetMLTransformsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetMLTransformsCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_GetMLTransformsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_GetMLTransformsResponse(data, context);
  const response: GetMLTransformsCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1GetMLTransformsCommandError
 */
const de_GetMLTransformsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetMLTransformsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1GetPartitionCommand
 */
export const de_GetPartitionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetPartitionCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_GetPartitionCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_GetPartitionResponse(data, context);
  const response: GetPartitionCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1GetPartitionCommandError
 */
const de_GetPartitionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetPartitionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "FederationSourceException":
    case "com.amazonaws.glue#FederationSourceException":
      throw await de_FederationSourceExceptionRes(parsedOutput, context);
    case "FederationSourceRetryableException":
    case "com.amazonaws.glue#FederationSourceRetryableException":
      throw await de_FederationSourceRetryableExceptionRes(parsedOutput, context);
    case "GlueEncryptionException":
    case "com.amazonaws.glue#GlueEncryptionException":
      throw await de_GlueEncryptionExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1GetPartitionIndexesCommand
 */
export const de_GetPartitionIndexesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetPartitionIndexesCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_GetPartitionIndexesCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_GetPartitionIndexesResponse(data, context);
  const response: GetPartitionIndexesCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1GetPartitionIndexesCommandError
 */
const de_GetPartitionIndexesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetPartitionIndexesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ConflictException":
    case "com.amazonaws.glue#ConflictException":
      throw await de_ConflictExceptionRes(parsedOutput, context);
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1GetPartitionsCommand
 */
export const de_GetPartitionsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetPartitionsCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_GetPartitionsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_GetPartitionsResponse(data, context);
  const response: GetPartitionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1GetPartitionsCommandError
 */
const de_GetPartitionsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetPartitionsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "FederationSourceException":
    case "com.amazonaws.glue#FederationSourceException":
      throw await de_FederationSourceExceptionRes(parsedOutput, context);
    case "FederationSourceRetryableException":
    case "com.amazonaws.glue#FederationSourceRetryableException":
      throw await de_FederationSourceRetryableExceptionRes(parsedOutput, context);
    case "GlueEncryptionException":
    case "com.amazonaws.glue#GlueEncryptionException":
      throw await de_GlueEncryptionExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "InvalidStateException":
    case "com.amazonaws.glue#InvalidStateException":
      throw await de_InvalidStateExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    case "ResourceNotReadyException":
    case "com.amazonaws.glue#ResourceNotReadyException":
      throw await de_ResourceNotReadyExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1GetPlanCommand
 */
export const de_GetPlanCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetPlanCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_GetPlanCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_GetPlanResponse(data, context);
  const response: GetPlanCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1GetPlanCommandError
 */
const de_GetPlanCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetPlanCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1GetRegistryCommand
 */
export const de_GetRegistryCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetRegistryCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_GetRegistryCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_GetRegistryResponse(data, context);
  const response: GetRegistryCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1GetRegistryCommandError
 */
const de_GetRegistryCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetRegistryCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.glue#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1GetResourcePoliciesCommand
 */
export const de_GetResourcePoliciesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetResourcePoliciesCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_GetResourcePoliciesCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_GetResourcePoliciesResponse(data, context);
  const response: GetResourcePoliciesCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1GetResourcePoliciesCommandError
 */
const de_GetResourcePoliciesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetResourcePoliciesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "GlueEncryptionException":
    case "com.amazonaws.glue#GlueEncryptionException":
      throw await de_GlueEncryptionExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1GetResourcePolicyCommand
 */
export const de_GetResourcePolicyCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetResourcePolicyCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_GetResourcePolicyCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_GetResourcePolicyResponse(data, context);
  const response: GetResourcePolicyCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1GetResourcePolicyCommandError
 */
const de_GetResourcePolicyCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetResourcePolicyCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1GetSchemaCommand
 */
export const de_GetSchemaCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetSchemaCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_GetSchemaCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_GetSchemaResponse(data, context);
  const response: GetSchemaCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1GetSchemaCommandError
 */
const de_GetSchemaCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetSchemaCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.glue#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1GetSchemaByDefinitionCommand
 */
export const de_GetSchemaByDefinitionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetSchemaByDefinitionCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_GetSchemaByDefinitionCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_GetSchemaByDefinitionResponse(data, context);
  const response: GetSchemaByDefinitionCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1GetSchemaByDefinitionCommandError
 */
const de_GetSchemaByDefinitionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetSchemaByDefinitionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.glue#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1GetSchemaVersionCommand
 */
export const de_GetSchemaVersionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetSchemaVersionCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_GetSchemaVersionCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_GetSchemaVersionResponse(data, context);
  const response: GetSchemaVersionCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1GetSchemaVersionCommandError
 */
const de_GetSchemaVersionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetSchemaVersionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.glue#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1GetSchemaVersionsDiffCommand
 */
export const de_GetSchemaVersionsDiffCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetSchemaVersionsDiffCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_GetSchemaVersionsDiffCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_GetSchemaVersionsDiffResponse(data, context);
  const response: GetSchemaVersionsDiffCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1GetSchemaVersionsDiffCommandError
 */
const de_GetSchemaVersionsDiffCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetSchemaVersionsDiffCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.glue#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1GetSecurityConfigurationCommand
 */
export const de_GetSecurityConfigurationCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetSecurityConfigurationCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_GetSecurityConfigurationCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_GetSecurityConfigurationResponse(data, context);
  const response: GetSecurityConfigurationCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1GetSecurityConfigurationCommandError
 */
const de_GetSecurityConfigurationCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetSecurityConfigurationCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1GetSecurityConfigurationsCommand
 */
export const de_GetSecurityConfigurationsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetSecurityConfigurationsCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_GetSecurityConfigurationsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_GetSecurityConfigurationsResponse(data, context);
  const response: GetSecurityConfigurationsCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1GetSecurityConfigurationsCommandError
 */
const de_GetSecurityConfigurationsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetSecurityConfigurationsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1GetSessionCommand
 */
export const de_GetSessionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetSessionCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_GetSessionCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_GetSessionResponse(data, context);
  const response: GetSessionCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1GetSessionCommandError
 */
const de_GetSessionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetSessionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.glue#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1GetStatementCommand
 */
export const de_GetStatementCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetStatementCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_GetStatementCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_GetStatementResponse(data, context);
  const response: GetStatementCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1GetStatementCommandError
 */
const de_GetStatementCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetStatementCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.glue#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "IllegalSessionStateException":
    case "com.amazonaws.glue#IllegalSessionStateException":
      throw await de_IllegalSessionStateExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1GetTableCommand
 */
export const de_GetTableCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetTableCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_GetTableCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_GetTableResponse(data, context);
  const response: GetTableCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1GetTableCommandError
 */
const de_GetTableCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetTableCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "FederationSourceException":
    case "com.amazonaws.glue#FederationSourceException":
      throw await de_FederationSourceExceptionRes(parsedOutput, context);
    case "FederationSourceRetryableException":
    case "com.amazonaws.glue#FederationSourceRetryableException":
      throw await de_FederationSourceRetryableExceptionRes(parsedOutput, context);
    case "GlueEncryptionException":
    case "com.amazonaws.glue#GlueEncryptionException":
      throw await de_GlueEncryptionExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    case "ResourceNotReadyException":
    case "com.amazonaws.glue#ResourceNotReadyException":
      throw await de_ResourceNotReadyExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1GetTablesCommand
 */
export const de_GetTablesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetTablesCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_GetTablesCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_GetTablesResponse(data, context);
  const response: GetTablesCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1GetTablesCommandError
 */
const de_GetTablesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetTablesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "FederationSourceException":
    case "com.amazonaws.glue#FederationSourceException":
      throw await de_FederationSourceExceptionRes(parsedOutput, context);
    case "FederationSourceRetryableException":
    case "com.amazonaws.glue#FederationSourceRetryableException":
      throw await de_FederationSourceRetryableExceptionRes(parsedOutput, context);
    case "GlueEncryptionException":
    case "com.amazonaws.glue#GlueEncryptionException":
      throw await de_GlueEncryptionExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1GetTableVersionCommand
 */
export const de_GetTableVersionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetTableVersionCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_GetTableVersionCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_GetTableVersionResponse(data, context);
  const response: GetTableVersionCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1GetTableVersionCommandError
 */
const de_GetTableVersionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetTableVersionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "GlueEncryptionException":
    case "com.amazonaws.glue#GlueEncryptionException":
      throw await de_GlueEncryptionExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1GetTableVersionsCommand
 */
export const de_GetTableVersionsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetTableVersionsCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_GetTableVersionsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_GetTableVersionsResponse(data, context);
  const response: GetTableVersionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1GetTableVersionsCommandError
 */
const de_GetTableVersionsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetTableVersionsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "GlueEncryptionException":
    case "com.amazonaws.glue#GlueEncryptionException":
      throw await de_GlueEncryptionExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1GetTagsCommand
 */
export const de_GetTagsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetTagsCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_GetTagsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_GetTagsResponse(data, context);
  const response: GetTagsCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1GetTagsCommandError
 */
const de_GetTagsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetTagsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1GetTriggerCommand
 */
export const de_GetTriggerCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetTriggerCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_GetTriggerCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_GetTriggerResponse(data, context);
  const response: GetTriggerCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1GetTriggerCommandError
 */
const de_GetTriggerCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetTriggerCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1GetTriggersCommand
 */
export const de_GetTriggersCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetTriggersCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_GetTriggersCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_GetTriggersResponse(data, context);
  const response: GetTriggersCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1GetTriggersCommandError
 */
const de_GetTriggersCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetTriggersCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1GetUnfilteredPartitionMetadataCommand
 */
export const de_GetUnfilteredPartitionMetadataCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetUnfilteredPartitionMetadataCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_GetUnfilteredPartitionMetadataCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_GetUnfilteredPartitionMetadataResponse(data, context);
  const response: GetUnfilteredPartitionMetadataCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1GetUnfilteredPartitionMetadataCommandError
 */
const de_GetUnfilteredPartitionMetadataCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetUnfilteredPartitionMetadataCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "FederationSourceException":
    case "com.amazonaws.glue#FederationSourceException":
      throw await de_FederationSourceExceptionRes(parsedOutput, context);
    case "FederationSourceRetryableException":
    case "com.amazonaws.glue#FederationSourceRetryableException":
      throw await de_FederationSourceRetryableExceptionRes(parsedOutput, context);
    case "GlueEncryptionException":
    case "com.amazonaws.glue#GlueEncryptionException":
      throw await de_GlueEncryptionExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    case "PermissionTypeMismatchException":
    case "com.amazonaws.glue#PermissionTypeMismatchException":
      throw await de_PermissionTypeMismatchExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1GetUnfilteredPartitionsMetadataCommand
 */
export const de_GetUnfilteredPartitionsMetadataCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetUnfilteredPartitionsMetadataCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_GetUnfilteredPartitionsMetadataCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_GetUnfilteredPartitionsMetadataResponse(data, context);
  const response: GetUnfilteredPartitionsMetadataCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1GetUnfilteredPartitionsMetadataCommandError
 */
const de_GetUnfilteredPartitionsMetadataCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetUnfilteredPartitionsMetadataCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "FederationSourceException":
    case "com.amazonaws.glue#FederationSourceException":
      throw await de_FederationSourceExceptionRes(parsedOutput, context);
    case "FederationSourceRetryableException":
    case "com.amazonaws.glue#FederationSourceRetryableException":
      throw await de_FederationSourceRetryableExceptionRes(parsedOutput, context);
    case "GlueEncryptionException":
    case "com.amazonaws.glue#GlueEncryptionException":
      throw await de_GlueEncryptionExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    case "PermissionTypeMismatchException":
    case "com.amazonaws.glue#PermissionTypeMismatchException":
      throw await de_PermissionTypeMismatchExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1GetUnfilteredTableMetadataCommand
 */
export const de_GetUnfilteredTableMetadataCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetUnfilteredTableMetadataCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_GetUnfilteredTableMetadataCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_GetUnfilteredTableMetadataResponse(data, context);
  const response: GetUnfilteredTableMetadataCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1GetUnfilteredTableMetadataCommandError
 */
const de_GetUnfilteredTableMetadataCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetUnfilteredTableMetadataCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "FederationSourceException":
    case "com.amazonaws.glue#FederationSourceException":
      throw await de_FederationSourceExceptionRes(parsedOutput, context);
    case "FederationSourceRetryableException":
    case "com.amazonaws.glue#FederationSourceRetryableException":
      throw await de_FederationSourceRetryableExceptionRes(parsedOutput, context);
    case "GlueEncryptionException":
    case "com.amazonaws.glue#GlueEncryptionException":
      throw await de_GlueEncryptionExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    case "PermissionTypeMismatchException":
    case "com.amazonaws.glue#PermissionTypeMismatchException":
      throw await de_PermissionTypeMismatchExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1GetUserDefinedFunctionCommand
 */
export const de_GetUserDefinedFunctionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetUserDefinedFunctionCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_GetUserDefinedFunctionCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_GetUserDefinedFunctionResponse(data, context);
  const response: GetUserDefinedFunctionCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1GetUserDefinedFunctionCommandError
 */
const de_GetUserDefinedFunctionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetUserDefinedFunctionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "GlueEncryptionException":
    case "com.amazonaws.glue#GlueEncryptionException":
      throw await de_GlueEncryptionExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1GetUserDefinedFunctionsCommand
 */
export const de_GetUserDefinedFunctionsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetUserDefinedFunctionsCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_GetUserDefinedFunctionsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_GetUserDefinedFunctionsResponse(data, context);
  const response: GetUserDefinedFunctionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1GetUserDefinedFunctionsCommandError
 */
const de_GetUserDefinedFunctionsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetUserDefinedFunctionsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "GlueEncryptionException":
    case "com.amazonaws.glue#GlueEncryptionException":
      throw await de_GlueEncryptionExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1GetWorkflowCommand
 */
export const de_GetWorkflowCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetWorkflowCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_GetWorkflowCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_GetWorkflowResponse(data, context);
  const response: GetWorkflowCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1GetWorkflowCommandError
 */
const de_GetWorkflowCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetWorkflowCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1GetWorkflowRunCommand
 */
export const de_GetWorkflowRunCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetWorkflowRunCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_GetWorkflowRunCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_GetWorkflowRunResponse(data, context);
  const response: GetWorkflowRunCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1GetWorkflowRunCommandError
 */
const de_GetWorkflowRunCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetWorkflowRunCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1GetWorkflowRunPropertiesCommand
 */
export const de_GetWorkflowRunPropertiesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetWorkflowRunPropertiesCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_GetWorkflowRunPropertiesCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_GetWorkflowRunPropertiesResponse(data, context);
  const response: GetWorkflowRunPropertiesCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1GetWorkflowRunPropertiesCommandError
 */
const de_GetWorkflowRunPropertiesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetWorkflowRunPropertiesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1GetWorkflowRunsCommand
 */
export const de_GetWorkflowRunsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetWorkflowRunsCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_GetWorkflowRunsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_GetWorkflowRunsResponse(data, context);
  const response: GetWorkflowRunsCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1GetWorkflowRunsCommandError
 */
const de_GetWorkflowRunsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetWorkflowRunsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1ImportCatalogToGlueCommand
 */
export const de_ImportCatalogToGlueCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ImportCatalogToGlueCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_ImportCatalogToGlueCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_ImportCatalogToGlueResponse(data, context);
  const response: ImportCatalogToGlueCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1ImportCatalogToGlueCommandError
 */
const de_ImportCatalogToGlueCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ImportCatalogToGlueCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1ListBlueprintsCommand
 */
export const de_ListBlueprintsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListBlueprintsCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_ListBlueprintsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_ListBlueprintsResponse(data, context);
  const response: ListBlueprintsCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1ListBlueprintsCommandError
 */
const de_ListBlueprintsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListBlueprintsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1ListCrawlersCommand
 */
export const de_ListCrawlersCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListCrawlersCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_ListCrawlersCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_ListCrawlersResponse(data, context);
  const response: ListCrawlersCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1ListCrawlersCommandError
 */
const de_ListCrawlersCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListCrawlersCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1ListCrawlsCommand
 */
export const de_ListCrawlsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListCrawlsCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_ListCrawlsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_ListCrawlsResponse(data, context);
  const response: ListCrawlsCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1ListCrawlsCommandError
 */
const de_ListCrawlsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListCrawlsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1ListCustomEntityTypesCommand
 */
export const de_ListCustomEntityTypesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListCustomEntityTypesCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_ListCustomEntityTypesCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_ListCustomEntityTypesResponse(data, context);
  const response: ListCustomEntityTypesCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1ListCustomEntityTypesCommandError
 */
const de_ListCustomEntityTypesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListCustomEntityTypesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1ListDataQualityResultsCommand
 */
export const de_ListDataQualityResultsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListDataQualityResultsCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_ListDataQualityResultsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_ListDataQualityResultsResponse(data, context);
  const response: ListDataQualityResultsCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1ListDataQualityResultsCommandError
 */
const de_ListDataQualityResultsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListDataQualityResultsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1ListDataQualityRuleRecommendationRunsCommand
 */
export const de_ListDataQualityRuleRecommendationRunsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListDataQualityRuleRecommendationRunsCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_ListDataQualityRuleRecommendationRunsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_ListDataQualityRuleRecommendationRunsResponse(data, context);
  const response: ListDataQualityRuleRecommendationRunsCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1ListDataQualityRuleRecommendationRunsCommandError
 */
const de_ListDataQualityRuleRecommendationRunsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListDataQualityRuleRecommendationRunsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1ListDataQualityRulesetEvaluationRunsCommand
 */
export const de_ListDataQualityRulesetEvaluationRunsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListDataQualityRulesetEvaluationRunsCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_ListDataQualityRulesetEvaluationRunsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_ListDataQualityRulesetEvaluationRunsResponse(data, context);
  const response: ListDataQualityRulesetEvaluationRunsCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1ListDataQualityRulesetEvaluationRunsCommandError
 */
const de_ListDataQualityRulesetEvaluationRunsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListDataQualityRulesetEvaluationRunsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1ListDataQualityRulesetsCommand
 */
export const de_ListDataQualityRulesetsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListDataQualityRulesetsCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_ListDataQualityRulesetsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_ListDataQualityRulesetsResponse(data, context);
  const response: ListDataQualityRulesetsCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1ListDataQualityRulesetsCommandError
 */
const de_ListDataQualityRulesetsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListDataQualityRulesetsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1ListDevEndpointsCommand
 */
export const de_ListDevEndpointsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListDevEndpointsCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_ListDevEndpointsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_ListDevEndpointsResponse(data, context);
  const response: ListDevEndpointsCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1ListDevEndpointsCommandError
 */
const de_ListDevEndpointsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListDevEndpointsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1ListJobsCommand
 */
export const de_ListJobsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListJobsCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_ListJobsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_ListJobsResponse(data, context);
  const response: ListJobsCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1ListJobsCommandError
 */
const de_ListJobsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListJobsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1ListMLTransformsCommand
 */
export const de_ListMLTransformsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListMLTransformsCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_ListMLTransformsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_ListMLTransformsResponse(data, context);
  const response: ListMLTransformsCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1ListMLTransformsCommandError
 */
const de_ListMLTransformsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListMLTransformsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1ListRegistriesCommand
 */
export const de_ListRegistriesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListRegistriesCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_ListRegistriesCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_ListRegistriesResponse(data, context);
  const response: ListRegistriesCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1ListRegistriesCommandError
 */
const de_ListRegistriesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListRegistriesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.glue#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1ListSchemasCommand
 */
export const de_ListSchemasCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListSchemasCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_ListSchemasCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_ListSchemasResponse(data, context);
  const response: ListSchemasCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1ListSchemasCommandError
 */
const de_ListSchemasCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListSchemasCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.glue#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1ListSchemaVersionsCommand
 */
export const de_ListSchemaVersionsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListSchemaVersionsCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_ListSchemaVersionsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_ListSchemaVersionsResponse(data, context);
  const response: ListSchemaVersionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1ListSchemaVersionsCommandError
 */
const de_ListSchemaVersionsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListSchemaVersionsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.glue#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1ListSessionsCommand
 */
export const de_ListSessionsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListSessionsCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_ListSessionsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_ListSessionsResponse(data, context);
  const response: ListSessionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1ListSessionsCommandError
 */
const de_ListSessionsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListSessionsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.glue#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1ListStatementsCommand
 */
export const de_ListStatementsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListStatementsCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_ListStatementsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_ListStatementsResponse(data, context);
  const response: ListStatementsCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1ListStatementsCommandError
 */
const de_ListStatementsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListStatementsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.glue#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "IllegalSessionStateException":
    case "com.amazonaws.glue#IllegalSessionStateException":
      throw await de_IllegalSessionStateExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1ListTriggersCommand
 */
export const de_ListTriggersCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTriggersCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_ListTriggersCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_ListTriggersResponse(data, context);
  const response: ListTriggersCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1ListTriggersCommandError
 */
const de_ListTriggersCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTriggersCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1ListWorkflowsCommand
 */
export const de_ListWorkflowsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListWorkflowsCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_ListWorkflowsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_ListWorkflowsResponse(data, context);
  const response: ListWorkflowsCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1ListWorkflowsCommandError
 */
const de_ListWorkflowsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListWorkflowsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1PutDataCatalogEncryptionSettingsCommand
 */
export const de_PutDataCatalogEncryptionSettingsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutDataCatalogEncryptionSettingsCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_PutDataCatalogEncryptionSettingsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_PutDataCatalogEncryptionSettingsResponse(data, context);
  const response: PutDataCatalogEncryptionSettingsCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1PutDataCatalogEncryptionSettingsCommandError
 */
const de_PutDataCatalogEncryptionSettingsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutDataCatalogEncryptionSettingsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1PutResourcePolicyCommand
 */
export const de_PutResourcePolicyCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutResourcePolicyCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_PutResourcePolicyCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_PutResourcePolicyResponse(data, context);
  const response: PutResourcePolicyCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1PutResourcePolicyCommandError
 */
const de_PutResourcePolicyCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutResourcePolicyCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ConditionCheckFailureException":
    case "com.amazonaws.glue#ConditionCheckFailureException":
      throw await de_ConditionCheckFailureExceptionRes(parsedOutput, context);
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1PutSchemaVersionMetadataCommand
 */
export const de_PutSchemaVersionMetadataCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutSchemaVersionMetadataCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_PutSchemaVersionMetadataCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_PutSchemaVersionMetadataResponse(data, context);
  const response: PutSchemaVersionMetadataCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1PutSchemaVersionMetadataCommandError
 */
const de_PutSchemaVersionMetadataCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutSchemaVersionMetadataCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.glue#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "AlreadyExistsException":
    case "com.amazonaws.glue#AlreadyExistsException":
      throw await de_AlreadyExistsExceptionRes(parsedOutput, context);
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "ResourceNumberLimitExceededException":
    case "com.amazonaws.glue#ResourceNumberLimitExceededException":
      throw await de_ResourceNumberLimitExceededExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1PutWorkflowRunPropertiesCommand
 */
export const de_PutWorkflowRunPropertiesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutWorkflowRunPropertiesCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_PutWorkflowRunPropertiesCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_PutWorkflowRunPropertiesResponse(data, context);
  const response: PutWorkflowRunPropertiesCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1PutWorkflowRunPropertiesCommandError
 */
const de_PutWorkflowRunPropertiesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutWorkflowRunPropertiesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AlreadyExistsException":
    case "com.amazonaws.glue#AlreadyExistsException":
      throw await de_AlreadyExistsExceptionRes(parsedOutput, context);
    case "ConcurrentModificationException":
    case "com.amazonaws.glue#ConcurrentModificationException":
      throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    case "ResourceNumberLimitExceededException":
    case "com.amazonaws.glue#ResourceNumberLimitExceededException":
      throw await de_ResourceNumberLimitExceededExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1QuerySchemaVersionMetadataCommand
 */
export const de_QuerySchemaVersionMetadataCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<QuerySchemaVersionMetadataCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_QuerySchemaVersionMetadataCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_QuerySchemaVersionMetadataResponse(data, context);
  const response: QuerySchemaVersionMetadataCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1QuerySchemaVersionMetadataCommandError
 */
const de_QuerySchemaVersionMetadataCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<QuerySchemaVersionMetadataCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.glue#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1RegisterSchemaVersionCommand
 */
export const de_RegisterSchemaVersionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RegisterSchemaVersionCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_RegisterSchemaVersionCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_RegisterSchemaVersionResponse(data, context);
  const response: RegisterSchemaVersionCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1RegisterSchemaVersionCommandError
 */
const de_RegisterSchemaVersionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RegisterSchemaVersionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.glue#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "ConcurrentModificationException":
    case "com.amazonaws.glue#ConcurrentModificationException":
      throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "ResourceNumberLimitExceededException":
    case "com.amazonaws.glue#ResourceNumberLimitExceededException":
      throw await de_ResourceNumberLimitExceededExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1RemoveSchemaVersionMetadataCommand
 */
export const de_RemoveSchemaVersionMetadataCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RemoveSchemaVersionMetadataCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_RemoveSchemaVersionMetadataCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_RemoveSchemaVersionMetadataResponse(data, context);
  const response: RemoveSchemaVersionMetadataCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1RemoveSchemaVersionMetadataCommandError
 */
const de_RemoveSchemaVersionMetadataCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RemoveSchemaVersionMetadataCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.glue#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1ResetJobBookmarkCommand
 */
export const de_ResetJobBookmarkCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ResetJobBookmarkCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_ResetJobBookmarkCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_ResetJobBookmarkResponse(data, context);
  const response: ResetJobBookmarkCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1ResetJobBookmarkCommandError
 */
const de_ResetJobBookmarkCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ResetJobBookmarkCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1ResumeWorkflowRunCommand
 */
export const de_ResumeWorkflowRunCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ResumeWorkflowRunCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_ResumeWorkflowRunCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_ResumeWorkflowRunResponse(data, context);
  const response: ResumeWorkflowRunCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1ResumeWorkflowRunCommandError
 */
const de_ResumeWorkflowRunCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ResumeWorkflowRunCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ConcurrentRunsExceededException":
    case "com.amazonaws.glue#ConcurrentRunsExceededException":
      throw await de_ConcurrentRunsExceededExceptionRes(parsedOutput, context);
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "IllegalWorkflowStateException":
    case "com.amazonaws.glue#IllegalWorkflowStateException":
      throw await de_IllegalWorkflowStateExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1RunStatementCommand
 */
export const de_RunStatementCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RunStatementCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_RunStatementCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_RunStatementResponse(data, context);
  const response: RunStatementCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1RunStatementCommandError
 */
const de_RunStatementCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RunStatementCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.glue#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "IllegalSessionStateException":
    case "com.amazonaws.glue#IllegalSessionStateException":
      throw await de_IllegalSessionStateExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    case "ResourceNumberLimitExceededException":
    case "com.amazonaws.glue#ResourceNumberLimitExceededException":
      throw await de_ResourceNumberLimitExceededExceptionRes(parsedOutput, context);
    case "ValidationException":
    case "com.amazonaws.glue#ValidationException":
      throw await de_ValidationExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1SearchTablesCommand
 */
export const de_SearchTablesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<SearchTablesCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_SearchTablesCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_SearchTablesResponse(data, context);
  const response: SearchTablesCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1SearchTablesCommandError
 */
const de_SearchTablesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<SearchTablesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1StartBlueprintRunCommand
 */
export const de_StartBlueprintRunCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartBlueprintRunCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_StartBlueprintRunCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_StartBlueprintRunResponse(data, context);
  const response: StartBlueprintRunCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1StartBlueprintRunCommandError
 */
const de_StartBlueprintRunCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartBlueprintRunCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "IllegalBlueprintStateException":
    case "com.amazonaws.glue#IllegalBlueprintStateException":
      throw await de_IllegalBlueprintStateExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    case "ResourceNumberLimitExceededException":
    case "com.amazonaws.glue#ResourceNumberLimitExceededException":
      throw await de_ResourceNumberLimitExceededExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1StartCrawlerCommand
 */
export const de_StartCrawlerCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartCrawlerCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_StartCrawlerCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_StartCrawlerResponse(data, context);
  const response: StartCrawlerCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1StartCrawlerCommandError
 */
const de_StartCrawlerCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartCrawlerCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "CrawlerRunningException":
    case "com.amazonaws.glue#CrawlerRunningException":
      throw await de_CrawlerRunningExceptionRes(parsedOutput, context);
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1StartCrawlerScheduleCommand
 */
export const de_StartCrawlerScheduleCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartCrawlerScheduleCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_StartCrawlerScheduleCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_StartCrawlerScheduleResponse(data, context);
  const response: StartCrawlerScheduleCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1StartCrawlerScheduleCommandError
 */
const de_StartCrawlerScheduleCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartCrawlerScheduleCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "NoScheduleException":
    case "com.amazonaws.glue#NoScheduleException":
      throw await de_NoScheduleExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    case "SchedulerRunningException":
    case "com.amazonaws.glue#SchedulerRunningException":
      throw await de_SchedulerRunningExceptionRes(parsedOutput, context);
    case "SchedulerTransitioningException":
    case "com.amazonaws.glue#SchedulerTransitioningException":
      throw await de_SchedulerTransitioningExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1StartDataQualityRuleRecommendationRunCommand
 */
export const de_StartDataQualityRuleRecommendationRunCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartDataQualityRuleRecommendationRunCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_StartDataQualityRuleRecommendationRunCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_StartDataQualityRuleRecommendationRunResponse(data, context);
  const response: StartDataQualityRuleRecommendationRunCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1StartDataQualityRuleRecommendationRunCommandError
 */
const de_StartDataQualityRuleRecommendationRunCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartDataQualityRuleRecommendationRunCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ConflictException":
    case "com.amazonaws.glue#ConflictException":
      throw await de_ConflictExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1StartDataQualityRulesetEvaluationRunCommand
 */
export const de_StartDataQualityRulesetEvaluationRunCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartDataQualityRulesetEvaluationRunCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_StartDataQualityRulesetEvaluationRunCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_StartDataQualityRulesetEvaluationRunResponse(data, context);
  const response: StartDataQualityRulesetEvaluationRunCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1StartDataQualityRulesetEvaluationRunCommandError
 */
const de_StartDataQualityRulesetEvaluationRunCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartDataQualityRulesetEvaluationRunCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ConflictException":
    case "com.amazonaws.glue#ConflictException":
      throw await de_ConflictExceptionRes(parsedOutput, context);
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1StartExportLabelsTaskRunCommand
 */
export const de_StartExportLabelsTaskRunCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartExportLabelsTaskRunCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_StartExportLabelsTaskRunCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_StartExportLabelsTaskRunResponse(data, context);
  const response: StartExportLabelsTaskRunCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1StartExportLabelsTaskRunCommandError
 */
const de_StartExportLabelsTaskRunCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartExportLabelsTaskRunCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1StartImportLabelsTaskRunCommand
 */
export const de_StartImportLabelsTaskRunCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartImportLabelsTaskRunCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_StartImportLabelsTaskRunCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_StartImportLabelsTaskRunResponse(data, context);
  const response: StartImportLabelsTaskRunCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1StartImportLabelsTaskRunCommandError
 */
const de_StartImportLabelsTaskRunCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartImportLabelsTaskRunCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    case "ResourceNumberLimitExceededException":
    case "com.amazonaws.glue#ResourceNumberLimitExceededException":
      throw await de_ResourceNumberLimitExceededExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1StartJobRunCommand
 */
export const de_StartJobRunCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartJobRunCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_StartJobRunCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_StartJobRunResponse(data, context);
  const response: StartJobRunCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1StartJobRunCommandError
 */
const de_StartJobRunCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartJobRunCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ConcurrentRunsExceededException":
    case "com.amazonaws.glue#ConcurrentRunsExceededException":
      throw await de_ConcurrentRunsExceededExceptionRes(parsedOutput, context);
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    case "ResourceNumberLimitExceededException":
    case "com.amazonaws.glue#ResourceNumberLimitExceededException":
      throw await de_ResourceNumberLimitExceededExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1StartMLEvaluationTaskRunCommand
 */
export const de_StartMLEvaluationTaskRunCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartMLEvaluationTaskRunCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_StartMLEvaluationTaskRunCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_StartMLEvaluationTaskRunResponse(data, context);
  const response: StartMLEvaluationTaskRunCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1StartMLEvaluationTaskRunCommandError
 */
const de_StartMLEvaluationTaskRunCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartMLEvaluationTaskRunCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ConcurrentRunsExceededException":
    case "com.amazonaws.glue#ConcurrentRunsExceededException":
      throw await de_ConcurrentRunsExceededExceptionRes(parsedOutput, context);
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "MLTransformNotReadyException":
    case "com.amazonaws.glue#MLTransformNotReadyException":
      throw await de_MLTransformNotReadyExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1StartMLLabelingSetGenerationTaskRunCommand
 */
export const de_StartMLLabelingSetGenerationTaskRunCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartMLLabelingSetGenerationTaskRunCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_StartMLLabelingSetGenerationTaskRunCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_StartMLLabelingSetGenerationTaskRunResponse(data, context);
  const response: StartMLLabelingSetGenerationTaskRunCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1StartMLLabelingSetGenerationTaskRunCommandError
 */
const de_StartMLLabelingSetGenerationTaskRunCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartMLLabelingSetGenerationTaskRunCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ConcurrentRunsExceededException":
    case "com.amazonaws.glue#ConcurrentRunsExceededException":
      throw await de_ConcurrentRunsExceededExceptionRes(parsedOutput, context);
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1StartTriggerCommand
 */
export const de_StartTriggerCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartTriggerCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_StartTriggerCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_StartTriggerResponse(data, context);
  const response: StartTriggerCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1StartTriggerCommandError
 */
const de_StartTriggerCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartTriggerCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ConcurrentRunsExceededException":
    case "com.amazonaws.glue#ConcurrentRunsExceededException":
      throw await de_ConcurrentRunsExceededExceptionRes(parsedOutput, context);
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    case "ResourceNumberLimitExceededException":
    case "com.amazonaws.glue#ResourceNumberLimitExceededException":
      throw await de_ResourceNumberLimitExceededExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1StartWorkflowRunCommand
 */
export const de_StartWorkflowRunCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartWorkflowRunCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_StartWorkflowRunCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_StartWorkflowRunResponse(data, context);
  const response: StartWorkflowRunCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1StartWorkflowRunCommandError
 */
const de_StartWorkflowRunCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartWorkflowRunCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ConcurrentRunsExceededException":
    case "com.amazonaws.glue#ConcurrentRunsExceededException":
      throw await de_ConcurrentRunsExceededExceptionRes(parsedOutput, context);
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    case "ResourceNumberLimitExceededException":
    case "com.amazonaws.glue#ResourceNumberLimitExceededException":
      throw await de_ResourceNumberLimitExceededExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1StopCrawlerCommand
 */
export const de_StopCrawlerCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StopCrawlerCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_StopCrawlerCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_StopCrawlerResponse(data, context);
  const response: StopCrawlerCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1StopCrawlerCommandError
 */
const de_StopCrawlerCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StopCrawlerCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "CrawlerNotRunningException":
    case "com.amazonaws.glue#CrawlerNotRunningException":
      throw await de_CrawlerNotRunningExceptionRes(parsedOutput, context);
    case "CrawlerStoppingException":
    case "com.amazonaws.glue#CrawlerStoppingException":
      throw await de_CrawlerStoppingExceptionRes(parsedOutput, context);
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1StopCrawlerScheduleCommand
 */
export const de_StopCrawlerScheduleCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StopCrawlerScheduleCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_StopCrawlerScheduleCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_StopCrawlerScheduleResponse(data, context);
  const response: StopCrawlerScheduleCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1StopCrawlerScheduleCommandError
 */
const de_StopCrawlerScheduleCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StopCrawlerScheduleCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    case "SchedulerNotRunningException":
    case "com.amazonaws.glue#SchedulerNotRunningException":
      throw await de_SchedulerNotRunningExceptionRes(parsedOutput, context);
    case "SchedulerTransitioningException":
    case "com.amazonaws.glue#SchedulerTransitioningException":
      throw await de_SchedulerTransitioningExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1StopSessionCommand
 */
export const de_StopSessionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StopSessionCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_StopSessionCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_StopSessionResponse(data, context);
  const response: StopSessionCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1StopSessionCommandError
 */
const de_StopSessionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StopSessionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.glue#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "ConcurrentModificationException":
    case "com.amazonaws.glue#ConcurrentModificationException":
      throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
    case "IllegalSessionStateException":
    case "com.amazonaws.glue#IllegalSessionStateException":
      throw await de_IllegalSessionStateExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1StopTriggerCommand
 */
export const de_StopTriggerCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StopTriggerCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_StopTriggerCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_StopTriggerResponse(data, context);
  const response: StopTriggerCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1StopTriggerCommandError
 */
const de_StopTriggerCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StopTriggerCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ConcurrentModificationException":
    case "com.amazonaws.glue#ConcurrentModificationException":
      throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1StopWorkflowRunCommand
 */
export const de_StopWorkflowRunCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StopWorkflowRunCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_StopWorkflowRunCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_StopWorkflowRunResponse(data, context);
  const response: StopWorkflowRunCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1StopWorkflowRunCommandError
 */
const de_StopWorkflowRunCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StopWorkflowRunCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "IllegalWorkflowStateException":
    case "com.amazonaws.glue#IllegalWorkflowStateException":
      throw await de_IllegalWorkflowStateExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1TagResourceCommand
 */
export const de_TagResourceCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<TagResourceCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_TagResourceCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_TagResourceResponse(data, context);
  const response: TagResourceCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1TagResourceCommandError
 */
const de_TagResourceCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<TagResourceCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1UntagResourceCommand
 */
export const de_UntagResourceCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UntagResourceCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_UntagResourceCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_UntagResourceResponse(data, context);
  const response: UntagResourceCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1UntagResourceCommandError
 */
const de_UntagResourceCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UntagResourceCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1UpdateBlueprintCommand
 */
export const de_UpdateBlueprintCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateBlueprintCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_UpdateBlueprintCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_UpdateBlueprintResponse(data, context);
  const response: UpdateBlueprintCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1UpdateBlueprintCommandError
 */
const de_UpdateBlueprintCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateBlueprintCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ConcurrentModificationException":
    case "com.amazonaws.glue#ConcurrentModificationException":
      throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "IllegalBlueprintStateException":
    case "com.amazonaws.glue#IllegalBlueprintStateException":
      throw await de_IllegalBlueprintStateExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1UpdateClassifierCommand
 */
export const de_UpdateClassifierCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateClassifierCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_UpdateClassifierCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_UpdateClassifierResponse(data, context);
  const response: UpdateClassifierCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1UpdateClassifierCommandError
 */
const de_UpdateClassifierCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateClassifierCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    case "VersionMismatchException":
    case "com.amazonaws.glue#VersionMismatchException":
      throw await de_VersionMismatchExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1UpdateColumnStatisticsForPartitionCommand
 */
export const de_UpdateColumnStatisticsForPartitionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateColumnStatisticsForPartitionCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_UpdateColumnStatisticsForPartitionCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_UpdateColumnStatisticsForPartitionResponse(data, context);
  const response: UpdateColumnStatisticsForPartitionCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1UpdateColumnStatisticsForPartitionCommandError
 */
const de_UpdateColumnStatisticsForPartitionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateColumnStatisticsForPartitionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "GlueEncryptionException":
    case "com.amazonaws.glue#GlueEncryptionException":
      throw await de_GlueEncryptionExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1UpdateColumnStatisticsForTableCommand
 */
export const de_UpdateColumnStatisticsForTableCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateColumnStatisticsForTableCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_UpdateColumnStatisticsForTableCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_UpdateColumnStatisticsForTableResponse(data, context);
  const response: UpdateColumnStatisticsForTableCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1UpdateColumnStatisticsForTableCommandError
 */
const de_UpdateColumnStatisticsForTableCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateColumnStatisticsForTableCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "GlueEncryptionException":
    case "com.amazonaws.glue#GlueEncryptionException":
      throw await de_GlueEncryptionExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1UpdateConnectionCommand
 */
export const de_UpdateConnectionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateConnectionCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_UpdateConnectionCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_UpdateConnectionResponse(data, context);
  const response: UpdateConnectionCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1UpdateConnectionCommandError
 */
const de_UpdateConnectionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateConnectionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "GlueEncryptionException":
    case "com.amazonaws.glue#GlueEncryptionException":
      throw await de_GlueEncryptionExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1UpdateCrawlerCommand
 */
export const de_UpdateCrawlerCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateCrawlerCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_UpdateCrawlerCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_UpdateCrawlerResponse(data, context);
  const response: UpdateCrawlerCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1UpdateCrawlerCommandError
 */
const de_UpdateCrawlerCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateCrawlerCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "CrawlerRunningException":
    case "com.amazonaws.glue#CrawlerRunningException":
      throw await de_CrawlerRunningExceptionRes(parsedOutput, context);
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    case "VersionMismatchException":
    case "com.amazonaws.glue#VersionMismatchException":
      throw await de_VersionMismatchExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1UpdateCrawlerScheduleCommand
 */
export const de_UpdateCrawlerScheduleCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateCrawlerScheduleCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_UpdateCrawlerScheduleCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_UpdateCrawlerScheduleResponse(data, context);
  const response: UpdateCrawlerScheduleCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1UpdateCrawlerScheduleCommandError
 */
const de_UpdateCrawlerScheduleCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateCrawlerScheduleCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    case "SchedulerTransitioningException":
    case "com.amazonaws.glue#SchedulerTransitioningException":
      throw await de_SchedulerTransitioningExceptionRes(parsedOutput, context);
    case "VersionMismatchException":
    case "com.amazonaws.glue#VersionMismatchException":
      throw await de_VersionMismatchExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1UpdateDatabaseCommand
 */
export const de_UpdateDatabaseCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateDatabaseCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_UpdateDatabaseCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_UpdateDatabaseResponse(data, context);
  const response: UpdateDatabaseCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1UpdateDatabaseCommandError
 */
const de_UpdateDatabaseCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateDatabaseCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ConcurrentModificationException":
    case "com.amazonaws.glue#ConcurrentModificationException":
      throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "GlueEncryptionException":
    case "com.amazonaws.glue#GlueEncryptionException":
      throw await de_GlueEncryptionExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1UpdateDataQualityRulesetCommand
 */
export const de_UpdateDataQualityRulesetCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateDataQualityRulesetCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_UpdateDataQualityRulesetCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_UpdateDataQualityRulesetResponse(data, context);
  const response: UpdateDataQualityRulesetCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1UpdateDataQualityRulesetCommandError
 */
const de_UpdateDataQualityRulesetCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateDataQualityRulesetCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AlreadyExistsException":
    case "com.amazonaws.glue#AlreadyExistsException":
      throw await de_AlreadyExistsExceptionRes(parsedOutput, context);
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "IdempotentParameterMismatchException":
    case "com.amazonaws.glue#IdempotentParameterMismatchException":
      throw await de_IdempotentParameterMismatchExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    case "ResourceNumberLimitExceededException":
    case "com.amazonaws.glue#ResourceNumberLimitExceededException":
      throw await de_ResourceNumberLimitExceededExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1UpdateDevEndpointCommand
 */
export const de_UpdateDevEndpointCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateDevEndpointCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_UpdateDevEndpointCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_UpdateDevEndpointResponse(data, context);
  const response: UpdateDevEndpointCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1UpdateDevEndpointCommandError
 */
const de_UpdateDevEndpointCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateDevEndpointCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    case "ValidationException":
    case "com.amazonaws.glue#ValidationException":
      throw await de_ValidationExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1UpdateJobCommand
 */
export const de_UpdateJobCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateJobCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_UpdateJobCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_UpdateJobResponse(data, context);
  const response: UpdateJobCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1UpdateJobCommandError
 */
const de_UpdateJobCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateJobCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ConcurrentModificationException":
    case "com.amazonaws.glue#ConcurrentModificationException":
      throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1UpdateJobFromSourceControlCommand
 */
export const de_UpdateJobFromSourceControlCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateJobFromSourceControlCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_UpdateJobFromSourceControlCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_UpdateJobFromSourceControlResponse(data, context);
  const response: UpdateJobFromSourceControlCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1UpdateJobFromSourceControlCommandError
 */
const de_UpdateJobFromSourceControlCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateJobFromSourceControlCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.glue#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "AlreadyExistsException":
    case "com.amazonaws.glue#AlreadyExistsException":
      throw await de_AlreadyExistsExceptionRes(parsedOutput, context);
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    case "ValidationException":
    case "com.amazonaws.glue#ValidationException":
      throw await de_ValidationExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1UpdateMLTransformCommand
 */
export const de_UpdateMLTransformCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateMLTransformCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_UpdateMLTransformCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_UpdateMLTransformResponse(data, context);
  const response: UpdateMLTransformCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1UpdateMLTransformCommandError
 */
const de_UpdateMLTransformCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateMLTransformCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.glue#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1UpdatePartitionCommand
 */
export const de_UpdatePartitionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdatePartitionCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_UpdatePartitionCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_UpdatePartitionResponse(data, context);
  const response: UpdatePartitionCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1UpdatePartitionCommandError
 */
const de_UpdatePartitionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdatePartitionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "GlueEncryptionException":
    case "com.amazonaws.glue#GlueEncryptionException":
      throw await de_GlueEncryptionExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1UpdateRegistryCommand
 */
export const de_UpdateRegistryCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateRegistryCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_UpdateRegistryCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_UpdateRegistryResponse(data, context);
  const response: UpdateRegistryCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1UpdateRegistryCommandError
 */
const de_UpdateRegistryCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateRegistryCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.glue#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "ConcurrentModificationException":
    case "com.amazonaws.glue#ConcurrentModificationException":
      throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1UpdateSchemaCommand
 */
export const de_UpdateSchemaCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateSchemaCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_UpdateSchemaCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_UpdateSchemaResponse(data, context);
  const response: UpdateSchemaCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1UpdateSchemaCommandError
 */
const de_UpdateSchemaCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateSchemaCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.glue#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "ConcurrentModificationException":
    case "com.amazonaws.glue#ConcurrentModificationException":
      throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1UpdateSourceControlFromJobCommand
 */
export const de_UpdateSourceControlFromJobCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateSourceControlFromJobCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_UpdateSourceControlFromJobCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_UpdateSourceControlFromJobResponse(data, context);
  const response: UpdateSourceControlFromJobCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1UpdateSourceControlFromJobCommandError
 */
const de_UpdateSourceControlFromJobCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateSourceControlFromJobCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.glue#AccessDeniedException":
      throw await de_AccessDeniedExceptionRes(parsedOutput, context);
    case "AlreadyExistsException":
    case "com.amazonaws.glue#AlreadyExistsException":
      throw await de_AlreadyExistsExceptionRes(parsedOutput, context);
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    case "ValidationException":
    case "com.amazonaws.glue#ValidationException":
      throw await de_ValidationExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1UpdateTableCommand
 */
export const de_UpdateTableCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateTableCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_UpdateTableCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_UpdateTableResponse(data, context);
  const response: UpdateTableCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1UpdateTableCommandError
 */
const de_UpdateTableCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateTableCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ConcurrentModificationException":
    case "com.amazonaws.glue#ConcurrentModificationException":
      throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "GlueEncryptionException":
    case "com.amazonaws.glue#GlueEncryptionException":
      throw await de_GlueEncryptionExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    case "ResourceNotReadyException":
    case "com.amazonaws.glue#ResourceNotReadyException":
      throw await de_ResourceNotReadyExceptionRes(parsedOutput, context);
    case "ResourceNumberLimitExceededException":
    case "com.amazonaws.glue#ResourceNumberLimitExceededException":
      throw await de_ResourceNumberLimitExceededExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1UpdateTriggerCommand
 */
export const de_UpdateTriggerCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateTriggerCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_UpdateTriggerCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_UpdateTriggerResponse(data, context);
  const response: UpdateTriggerCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1UpdateTriggerCommandError
 */
const de_UpdateTriggerCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateTriggerCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ConcurrentModificationException":
    case "com.amazonaws.glue#ConcurrentModificationException":
      throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1UpdateUserDefinedFunctionCommand
 */
export const de_UpdateUserDefinedFunctionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateUserDefinedFunctionCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_UpdateUserDefinedFunctionCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_UpdateUserDefinedFunctionResponse(data, context);
  const response: UpdateUserDefinedFunctionCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1UpdateUserDefinedFunctionCommandError
 */
const de_UpdateUserDefinedFunctionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateUserDefinedFunctionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "GlueEncryptionException":
    case "com.amazonaws.glue#GlueEncryptionException":
      throw await de_GlueEncryptionExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1UpdateWorkflowCommand
 */
export const de_UpdateWorkflowCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateWorkflowCommandOutput> => {
  if (output.statusCode >= 300) {
    return de_UpdateWorkflowCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = de_UpdateWorkflowResponse(data, context);
  const response: UpdateWorkflowCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

/**
 * deserializeAws_json1_1UpdateWorkflowCommandError
 */
const de_UpdateWorkflowCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateWorkflowCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseErrorBody(output.body, context),
  };
  const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ConcurrentModificationException":
    case "com.amazonaws.glue#ConcurrentModificationException":
      throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      throw await de_EntityNotFoundExceptionRes(parsedOutput, context);
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      throw await de_InternalServiceExceptionRes(parsedOutput, context);
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      throw await de_InvalidInputExceptionRes(parsedOutput, context);
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      throw await de_OperationTimeoutExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      throwDefaultError({
        output,
        parsedBody,
        exceptionCtor: __BaseException,
        errorCode,
      });
  }
};

/**
 * deserializeAws_json1_1AccessDeniedExceptionRes
 */
const de_AccessDeniedExceptionRes = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<AccessDeniedException> => {
  const body = parsedOutput.body;
  const deserialized: any = de_AccessDeniedException(body, context);
  const exception = new AccessDeniedException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized,
  });
  return __decorateServiceException(exception, body);
};

/**
 * deserializeAws_json1_1AlreadyExistsExceptionRes
 */
const de_AlreadyExistsExceptionRes = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<AlreadyExistsException> => {
  const body = parsedOutput.body;
  const deserialized: any = de_AlreadyExistsException(body, context);
  const exception = new AlreadyExistsException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized,
  });
  return __decorateServiceException(exception, body);
};

/**
 * deserializeAws_json1_1ConcurrentModificationExceptionRes
 */
const de_ConcurrentModificationExceptionRes = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ConcurrentModificationException> => {
  const body = parsedOutput.body;
  const deserialized: any = de_ConcurrentModificationException(body, context);
  const exception = new ConcurrentModificationException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized,
  });
  return __decorateServiceException(exception, body);
};

/**
 * deserializeAws_json1_1ConcurrentRunsExceededExceptionRes
 */
const de_ConcurrentRunsExceededExceptionRes = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ConcurrentRunsExceededException> => {
  const body = parsedOutput.body;
  const deserialized: any = de_ConcurrentRunsExceededException(body, context);
  const exception = new ConcurrentRunsExceededException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized,
  });
  return __decorateServiceException(exception, body);
};

/**
 * deserializeAws_json1_1ConditionCheckFailureExceptionRes
 */
const de_ConditionCheckFailureExceptionRes = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ConditionCheckFailureException> => {
  const body = parsedOutput.body;
  const deserialized: any = de_ConditionCheckFailureException(body, context);
  const exception = new ConditionCheckFailureException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized,
  });
  return __decorateServiceException(exception, body);
};

/**
 * deserializeAws_json1_1ConflictExceptionRes
 */
const de_ConflictExceptionRes = async (parsedOutput: any, context: __SerdeContext): Promise<ConflictException> => {
  const body = parsedOutput.body;
  const deserialized: any = de_ConflictException(body, context);
  const exception = new ConflictException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized,
  });
  return __decorateServiceException(exception, body);
};

/**
 * deserializeAws_json1_1CrawlerNotRunningExceptionRes
 */
const de_CrawlerNotRunningExceptionRes = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<CrawlerNotRunningException> => {
  const body = parsedOutput.body;
  const deserialized: any = de_CrawlerNotRunningException(body, context);
  const exception = new CrawlerNotRunningException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized,
  });
  return __decorateServiceException(exception, body);
};

/**
 * deserializeAws_json1_1CrawlerRunningExceptionRes
 */
const de_CrawlerRunningExceptionRes = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<CrawlerRunningException> => {
  const body = parsedOutput.body;
  const deserialized: any = de_CrawlerRunningException(body, context);
  const exception = new CrawlerRunningException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized,
  });
  return __decorateServiceException(exception, body);
};

/**
 * deserializeAws_json1_1CrawlerStoppingExceptionRes
 */
const de_CrawlerStoppingExceptionRes = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<CrawlerStoppingException> => {
  const body = parsedOutput.body;
  const deserialized: any = de_CrawlerStoppingException(body, context);
  const exception = new CrawlerStoppingException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized,
  });
  return __decorateServiceException(exception, body);
};

/**
 * deserializeAws_json1_1EntityNotFoundExceptionRes
 */
const de_EntityNotFoundExceptionRes = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<EntityNotFoundException> => {
  const body = parsedOutput.body;
  const deserialized: any = de_EntityNotFoundException(body, context);
  const exception = new EntityNotFoundException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized,
  });
  return __decorateServiceException(exception, body);
};

/**
 * deserializeAws_json1_1FederatedResourceAlreadyExistsExceptionRes
 */
const de_FederatedResourceAlreadyExistsExceptionRes = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<FederatedResourceAlreadyExistsException> => {
  const body = parsedOutput.body;
  const deserialized: any = de_FederatedResourceAlreadyExistsException(body, context);
  const exception = new FederatedResourceAlreadyExistsException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized,
  });
  return __decorateServiceException(exception, body);
};

/**
 * deserializeAws_json1_1FederationSourceExceptionRes
 */
const de_FederationSourceExceptionRes = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<FederationSourceException> => {
  const body = parsedOutput.body;
  const deserialized: any = de_FederationSourceException(body, context);
  const exception = new FederationSourceException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized,
  });
  return __decorateServiceException(exception, body);
};

/**
 * deserializeAws_json1_1FederationSourceRetryableExceptionRes
 */
const de_FederationSourceRetryableExceptionRes = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<FederationSourceRetryableException> => {
  const body = parsedOutput.body;
  const deserialized: any = de_FederationSourceRetryableException(body, context);
  const exception = new FederationSourceRetryableException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized,
  });
  return __decorateServiceException(exception, body);
};

/**
 * deserializeAws_json1_1GlueEncryptionExceptionRes
 */
const de_GlueEncryptionExceptionRes = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<GlueEncryptionException> => {
  const body = parsedOutput.body;
  const deserialized: any = de_GlueEncryptionException(body, context);
  const exception = new GlueEncryptionException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized,
  });
  return __decorateServiceException(exception, body);
};

/**
 * deserializeAws_json1_1IdempotentParameterMismatchExceptionRes
 */
const de_IdempotentParameterMismatchExceptionRes = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<IdempotentParameterMismatchException> => {
  const body = parsedOutput.body;
  const deserialized: any = de_IdempotentParameterMismatchException(body, context);
  const exception = new IdempotentParameterMismatchException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized,
  });
  return __decorateServiceException(exception, body);
};

/**
 * deserializeAws_json1_1IllegalBlueprintStateExceptionRes
 */
const de_IllegalBlueprintStateExceptionRes = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<IllegalBlueprintStateException> => {
  const body = parsedOutput.body;
  const deserialized: any = de_IllegalBlueprintStateException(body, context);
  const exception = new IllegalBlueprintStateException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized,
  });
  return __decorateServiceException(exception, body);
};

/**
 * deserializeAws_json1_1IllegalSessionStateExceptionRes
 */
const de_IllegalSessionStateExceptionRes = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<IllegalSessionStateException> => {
  const body = parsedOutput.body;
  const deserialized: any = de_IllegalSessionStateException(body, context);
  const exception = new IllegalSessionStateException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized,
  });
  return __decorateServiceException(exception, body);
};

/**
 * deserializeAws_json1_1IllegalWorkflowStateExceptionRes
 */
const de_IllegalWorkflowStateExceptionRes = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<IllegalWorkflowStateException> => {
  const body = parsedOutput.body;
  const deserialized: any = de_IllegalWorkflowStateException(body, context);
  const exception = new IllegalWorkflowStateException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized,
  });
  return __decorateServiceException(exception, body);
};

/**
 * deserializeAws_json1_1InternalServiceExceptionRes
 */
const de_InternalServiceExceptionRes = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InternalServiceException> => {
  const body = parsedOutput.body;
  const deserialized: any = de_InternalServiceException(body, context);
  const exception = new InternalServiceException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized,
  });
  return __decorateServiceException(exception, body);
};

/**
 * deserializeAws_json1_1InvalidInputExceptionRes
 */
const de_InvalidInputExceptionRes = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidInputException> => {
  const body = parsedOutput.body;
  const deserialized: any = de_InvalidInputException(body, context);
  const exception = new InvalidInputException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized,
  });
  return __decorateServiceException(exception, body);
};

/**
 * deserializeAws_json1_1InvalidStateExceptionRes
 */
const de_InvalidStateExceptionRes = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidStateException> => {
  const body = parsedOutput.body;
  const deserialized: any = de_InvalidStateException(body, context);
  const exception = new InvalidStateException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized,
  });
  return __decorateServiceException(exception, body);
};

/**
 * deserializeAws_json1_1MLTransformNotReadyExceptionRes
 */
const de_MLTransformNotReadyExceptionRes = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<MLTransformNotReadyException> => {
  const body = parsedOutput.body;
  const deserialized: any = de_MLTransformNotReadyException(body, context);
  const exception = new MLTransformNotReadyException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized,
  });
  return __decorateServiceException(exception, body);
};

/**
 * deserializeAws_json1_1NoScheduleExceptionRes
 */
const de_NoScheduleExceptionRes = async (parsedOutput: any, context: __SerdeContext): Promise<NoScheduleException> => {
  const body = parsedOutput.body;
  const deserialized: any = de_NoScheduleException(body, context);
  const exception = new NoScheduleException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized,
  });
  return __decorateServiceException(exception, body);
};

/**
 * deserializeAws_json1_1OperationTimeoutExceptionRes
 */
const de_OperationTimeoutExceptionRes = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<OperationTimeoutException> => {
  const body = parsedOutput.body;
  const deserialized: any = de_OperationTimeoutException(body, context);
  const exception = new OperationTimeoutException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized,
  });
  return __decorateServiceException(exception, body);
};

/**
 * deserializeAws_json1_1PermissionTypeMismatchExceptionRes
 */
const de_PermissionTypeMismatchExceptionRes = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<PermissionTypeMismatchException> => {
  const body = parsedOutput.body;
  const deserialized: any = de_PermissionTypeMismatchException(body, context);
  const exception = new PermissionTypeMismatchException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized,
  });
  return __decorateServiceException(exception, body);
};

/**
 * deserializeAws_json1_1ResourceNotReadyExceptionRes
 */
const de_ResourceNotReadyExceptionRes = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ResourceNotReadyException> => {
  const body = parsedOutput.body;
  const deserialized: any = de_ResourceNotReadyException(body, context);
  const exception = new ResourceNotReadyException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized,
  });
  return __decorateServiceException(exception, body);
};

/**
 * deserializeAws_json1_1ResourceNumberLimitExceededExceptionRes
 */
const de_ResourceNumberLimitExceededExceptionRes = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ResourceNumberLimitExceededException> => {
  const body = parsedOutput.body;
  const deserialized: any = de_ResourceNumberLimitExceededException(body, context);
  const exception = new ResourceNumberLimitExceededException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized,
  });
  return __decorateServiceException(exception, body);
};

/**
 * deserializeAws_json1_1SchedulerNotRunningExceptionRes
 */
const de_SchedulerNotRunningExceptionRes = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<SchedulerNotRunningException> => {
  const body = parsedOutput.body;
  const deserialized: any = de_SchedulerNotRunningException(body, context);
  const exception = new SchedulerNotRunningException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized,
  });
  return __decorateServiceException(exception, body);
};

/**
 * deserializeAws_json1_1SchedulerRunningExceptionRes
 */
const de_SchedulerRunningExceptionRes = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<SchedulerRunningException> => {
  const body = parsedOutput.body;
  const deserialized: any = de_SchedulerRunningException(body, context);
  const exception = new SchedulerRunningException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized,
  });
  return __decorateServiceException(exception, body);
};

/**
 * deserializeAws_json1_1SchedulerTransitioningExceptionRes
 */
const de_SchedulerTransitioningExceptionRes = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<SchedulerTransitioningException> => {
  const body = parsedOutput.body;
  const deserialized: any = de_SchedulerTransitioningException(body, context);
  const exception = new SchedulerTransitioningException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized,
  });
  return __decorateServiceException(exception, body);
};

/**
 * deserializeAws_json1_1ValidationExceptionRes
 */
const de_ValidationExceptionRes = async (parsedOutput: any, context: __SerdeContext): Promise<ValidationException> => {
  const body = parsedOutput.body;
  const deserialized: any = de_ValidationException(body, context);
  const exception = new ValidationException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized,
  });
  return __decorateServiceException(exception, body);
};

/**
 * deserializeAws_json1_1VersionMismatchExceptionRes
 */
const de_VersionMismatchExceptionRes = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<VersionMismatchException> => {
  const body = parsedOutput.body;
  const deserialized: any = de_VersionMismatchException(body, context);
  const exception = new VersionMismatchException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized,
  });
  return __decorateServiceException(exception, body);
};

/**
 * serializeAws_json1_1Action
 */
const se_Action = (input: Action, context: __SerdeContext): any => {
  return {
    ...(input.Arguments != null && { Arguments: se_GenericMap(input.Arguments, context) }),
    ...(input.CrawlerName != null && { CrawlerName: input.CrawlerName }),
    ...(input.JobName != null && { JobName: input.JobName }),
    ...(input.NotificationProperty != null && {
      NotificationProperty: se_NotificationProperty(input.NotificationProperty, context),
    }),
    ...(input.SecurityConfiguration != null && { SecurityConfiguration: input.SecurityConfiguration }),
    ...(input.Timeout != null && { Timeout: input.Timeout }),
  };
};

/**
 * serializeAws_json1_1ActionList
 */
const se_ActionList = (input: Action[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      return se_Action(entry, context);
    });
};

/**
 * serializeAws_json1_1AdditionalOptions
 */
const se_AdditionalOptions = (input: Record<string, string>, context: __SerdeContext): any => {
  return Object.entries(input).reduce((acc: Record<string, any>, [key, value]: [string, any]) => {
    if (value === null) {
      return acc;
    }
    acc[key] = value;
    return acc;
  }, {});
};

/**
 * serializeAws_json1_1AdditionalPlanOptionsMap
 */
const se_AdditionalPlanOptionsMap = (input: Record<string, string>, context: __SerdeContext): any => {
  return Object.entries(input).reduce((acc: Record<string, any>, [key, value]: [string, any]) => {
    if (value === null) {
      return acc;
    }
    acc[key] = value;
    return acc;
  }, {});
};

/**
 * serializeAws_json1_1Aggregate
 */
const se_Aggregate = (input: Aggregate, context: __SerdeContext): any => {
  return {
    ...(input.Aggs != null && { Aggs: se_AggregateOperations(input.Aggs, context) }),
    ...(input.Groups != null && { Groups: se_GlueStudioPathList(input.Groups, context) }),
    ...(input.Inputs != null && { Inputs: se_OneInput(input.Inputs, context) }),
    ...(input.Name != null && { Name: input.Name }),
  };
};

/**
 * serializeAws_json1_1AggregateOperation
 */
const se_AggregateOperation = (input: AggregateOperation, context: __SerdeContext): any => {
  return {
    ...(input.AggFunc != null && { AggFunc: input.AggFunc }),
    ...(input.Column != null && { Column: se_EnclosedInStringProperties(input.Column, context) }),
  };
};

/**
 * serializeAws_json1_1AggregateOperations
 */
const se_AggregateOperations = (input: AggregateOperation[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      return se_AggregateOperation(entry, context);
    });
};

/**
 * serializeAws_json1_1ApplyMapping
 */
const se_ApplyMapping = (input: ApplyMapping, context: __SerdeContext): any => {
  return {
    ...(input.Inputs != null && { Inputs: se_OneInput(input.Inputs, context) }),
    ...(input.Mapping != null && { Mapping: se_Mappings(input.Mapping, context) }),
    ...(input.Name != null && { Name: input.Name }),
  };
};

/**
 * serializeAws_json1_1AthenaConnectorSource
 */
const se_AthenaConnectorSource = (input: AthenaConnectorSource, context: __SerdeContext): any => {
  return {
    ...(input.ConnectionName != null && { ConnectionName: input.ConnectionName }),
    ...(input.ConnectionTable != null && { ConnectionTable: input.ConnectionTable }),
    ...(input.ConnectionType != null && { ConnectionType: input.ConnectionType }),
    ...(input.ConnectorName != null && { ConnectorName: input.ConnectorName }),
    ...(input.Name != null && { Name: input.Name }),
    ...(input.OutputSchemas != null && { OutputSchemas: se_GlueSchemas(input.OutputSchemas, context) }),
    ...(input.SchemaName != null && { SchemaName: input.SchemaName }),
  };
};

/**
 * serializeAws_json1_1AuditColumnNamesList
 */
const se_AuditColumnNamesList = (input: string[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      return entry;
    });
};

/**
 * serializeAws_json1_1AuditContext
 */
const se_AuditContext = (input: AuditContext, context: __SerdeContext): any => {
  return {
    ...(input.AdditionalAuditContext != null && { AdditionalAuditContext: input.AdditionalAuditContext }),
    ...(input.AllColumnsRequested != null && { AllColumnsRequested: input.AllColumnsRequested }),
    ...(input.RequestedColumns != null && {
      RequestedColumns: se_AuditColumnNamesList(input.RequestedColumns, context),
    }),
  };
};

/**
 * serializeAws_json1_1BasicCatalogTarget
 */
const se_BasicCatalogTarget = (input: BasicCatalogTarget, context: __SerdeContext): any => {
  return {
    ...(input.Database != null && { Database: input.Database }),
    ...(input.Inputs != null && { Inputs: se_OneInput(input.Inputs, context) }),
    ...(input.Name != null && { Name: input.Name }),
    ...(input.Table != null && { Table: input.Table }),
  };
};

/**
 * serializeAws_json1_1BatchCreatePartitionRequest
 */
const se_BatchCreatePartitionRequest = (input: BatchCreatePartitionRequest, context: __SerdeContext): any => {
  return {
    ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
    ...(input.DatabaseName != null && { DatabaseName: input.DatabaseName }),
    ...(input.PartitionInputList != null && {
      PartitionInputList: se_PartitionInputList(input.PartitionInputList, context),
    }),
    ...(input.TableName != null && { TableName: input.TableName }),
  };
};

/**
 * serializeAws_json1_1BatchDeleteConnectionRequest
 */
const se_BatchDeleteConnectionRequest = (input: BatchDeleteConnectionRequest, context: __SerdeContext): any => {
  return {
    ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
    ...(input.ConnectionNameList != null && {
      ConnectionNameList: se_DeleteConnectionNameList(input.ConnectionNameList, context),
    }),
  };
};

/**
 * serializeAws_json1_1BatchDeletePartitionRequest
 */
const se_BatchDeletePartitionRequest = (input: BatchDeletePartitionRequest, context: __SerdeContext): any => {
  return {
    ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
    ...(input.DatabaseName != null && { DatabaseName: input.DatabaseName }),
    ...(input.PartitionsToDelete != null && {
      PartitionsToDelete: se_BatchDeletePartitionValueList(input.PartitionsToDelete, context),
    }),
    ...(input.TableName != null && { TableName: input.TableName }),
  };
};

/**
 * serializeAws_json1_1BatchDeletePartitionValueList
 */
const se_BatchDeletePartitionValueList = (input: PartitionValueList[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      return se_PartitionValueList(entry, context);
    });
};

/**
 * serializeAws_json1_1BatchDeleteTableNameList
 */
const se_BatchDeleteTableNameList = (input: string[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      return entry;
    });
};

/**
 * serializeAws_json1_1BatchDeleteTableRequest
 */
const se_BatchDeleteTableRequest = (input: BatchDeleteTableRequest, context: __SerdeContext): any => {
  return {
    ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
    ...(input.DatabaseName != null && { DatabaseName: input.DatabaseName }),
    ...(input.TablesToDelete != null && { TablesToDelete: se_BatchDeleteTableNameList(input.TablesToDelete, context) }),
    ...(input.TransactionId != null && { TransactionId: input.TransactionId }),
  };
};

/**
 * serializeAws_json1_1BatchDeleteTableVersionList
 */
const se_BatchDeleteTableVersionList = (input: string[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      return entry;
    });
};

/**
 * serializeAws_json1_1BatchDeleteTableVersionRequest
 */
const se_BatchDeleteTableVersionRequest = (input: BatchDeleteTableVersionRequest, context: __SerdeContext): any => {
  return {
    ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
    ...(input.DatabaseName != null && { DatabaseName: input.DatabaseName }),
    ...(input.TableName != null && { TableName: input.TableName }),
    ...(input.VersionIds != null && { VersionIds: se_BatchDeleteTableVersionList(input.VersionIds, context) }),
  };
};

/**
 * serializeAws_json1_1BatchGetBlueprintNames
 */
const se_BatchGetBlueprintNames = (input: string[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      return entry;
    });
};

/**
 * serializeAws_json1_1BatchGetBlueprintsRequest
 */
const se_BatchGetBlueprintsRequest = (input: BatchGetBlueprintsRequest, context: __SerdeContext): any => {
  return {
    ...(input.IncludeBlueprint != null && { IncludeBlueprint: input.IncludeBlueprint }),
    ...(input.IncludeParameterSpec != null && { IncludeParameterSpec: input.IncludeParameterSpec }),
    ...(input.Names != null && { Names: se_BatchGetBlueprintNames(input.Names, context) }),
  };
};

/**
 * serializeAws_json1_1BatchGetCrawlersRequest
 */
const se_BatchGetCrawlersRequest = (input: BatchGetCrawlersRequest, context: __SerdeContext): any => {
  return {
    ...(input.CrawlerNames != null && { CrawlerNames: se_CrawlerNameList(input.CrawlerNames, context) }),
  };
};

/**
 * serializeAws_json1_1BatchGetCustomEntityTypesRequest
 */
const se_BatchGetCustomEntityTypesRequest = (input: BatchGetCustomEntityTypesRequest, context: __SerdeContext): any => {
  return {
    ...(input.Names != null && { Names: se_CustomEntityTypeNames(input.Names, context) }),
  };
};

/**
 * serializeAws_json1_1BatchGetDataQualityResultRequest
 */
const se_BatchGetDataQualityResultRequest = (input: BatchGetDataQualityResultRequest, context: __SerdeContext): any => {
  return {
    ...(input.ResultIds != null && { ResultIds: se_DataQualityResultIds(input.ResultIds, context) }),
  };
};

/**
 * serializeAws_json1_1BatchGetDevEndpointsRequest
 */
const se_BatchGetDevEndpointsRequest = (input: BatchGetDevEndpointsRequest, context: __SerdeContext): any => {
  return {
    ...(input.DevEndpointNames != null && { DevEndpointNames: se_DevEndpointNames(input.DevEndpointNames, context) }),
  };
};

/**
 * serializeAws_json1_1BatchGetJobsRequest
 */
const se_BatchGetJobsRequest = (input: BatchGetJobsRequest, context: __SerdeContext): any => {
  return {
    ...(input.JobNames != null && { JobNames: se_JobNameList(input.JobNames, context) }),
  };
};

/**
 * serializeAws_json1_1BatchGetPartitionRequest
 */
const se_BatchGetPartitionRequest = (input: BatchGetPartitionRequest, context: __SerdeContext): any => {
  return {
    ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
    ...(input.DatabaseName != null && { DatabaseName: input.DatabaseName }),
    ...(input.PartitionsToGet != null && {
      PartitionsToGet: se_BatchGetPartitionValueList(input.PartitionsToGet, context),
    }),
    ...(input.TableName != null && { TableName: input.TableName }),
  };
};

/**
 * serializeAws_json1_1BatchGetPartitionValueList
 */
const se_BatchGetPartitionValueList = (input: PartitionValueList[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      return se_PartitionValueList(entry, context);
    });
};

/**
 * serializeAws_json1_1BatchGetTriggersRequest
 */
const se_BatchGetTriggersRequest = (input: BatchGetTriggersRequest, context: __SerdeContext): any => {
  return {
    ...(input.TriggerNames != null && { TriggerNames: se_TriggerNameList(input.TriggerNames, context) }),
  };
};

/**
 * serializeAws_json1_1BatchGetWorkflowsRequest
 */
const se_BatchGetWorkflowsRequest = (input: BatchGetWorkflowsRequest, context: __SerdeContext): any => {
  return {
    ...(input.IncludeGraph != null && { IncludeGraph: input.IncludeGraph }),
    ...(input.Names != null && { Names: se_WorkflowNames(input.Names, context) }),
  };
};

/**
 * serializeAws_json1_1BatchStopJobRunJobRunIdList
 */
const se_BatchStopJobRunJobRunIdList = (input: string[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      return entry;
    });
};

/**
 * serializeAws_json1_1BatchStopJobRunRequest
 */
const se_BatchStopJobRunRequest = (input: BatchStopJobRunRequest, context: __SerdeContext): any => {
  return {
    ...(input.JobName != null && { JobName: input.JobName }),
    ...(input.JobRunIds != null && { JobRunIds: se_BatchStopJobRunJobRunIdList(input.JobRunIds, context) }),
  };
};

/**
 * serializeAws_json1_1BatchUpdatePartitionRequest
 */
const se_BatchUpdatePartitionRequest = (input: BatchUpdatePartitionRequest, context: __SerdeContext): any => {
  return {
    ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
    ...(input.DatabaseName != null && { DatabaseName: input.DatabaseName }),
    ...(input.Entries != null && { Entries: se_BatchUpdatePartitionRequestEntryList(input.Entries, context) }),
    ...(input.TableName != null && { TableName: input.TableName }),
  };
};

/**
 * serializeAws_json1_1BatchUpdatePartitionRequestEntry
 */
const se_BatchUpdatePartitionRequestEntry = (input: BatchUpdatePartitionRequestEntry, context: __SerdeContext): any => {
  return {
    ...(input.PartitionInput != null && { PartitionInput: se_PartitionInput(input.PartitionInput, context) }),
    ...(input.PartitionValueList != null && {
      PartitionValueList: se_BoundedPartitionValueList(input.PartitionValueList, context),
    }),
  };
};

/**
 * serializeAws_json1_1BatchUpdatePartitionRequestEntryList
 */
const se_BatchUpdatePartitionRequestEntryList = (
  input: BatchUpdatePartitionRequestEntry[],
  context: __SerdeContext
): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      return se_BatchUpdatePartitionRequestEntry(entry, context);
    });
};

/**
 * serializeAws_json1_1BinaryColumnStatisticsData
 */
const se_BinaryColumnStatisticsData = (input: BinaryColumnStatisticsData, context: __SerdeContext): any => {
  return {
    ...(input.AverageLength != null && { AverageLength: __serializeFloat(input.AverageLength) }),
    ...(input.MaximumLength != null && { MaximumLength: input.MaximumLength }),
    ...(input.NumberOfNulls != null && { NumberOfNulls: input.NumberOfNulls }),
  };
};

/**
 * serializeAws_json1_1BooleanColumnStatisticsData
 */
const se_BooleanColumnStatisticsData = (input: BooleanColumnStatisticsData, context: __SerdeContext): any => {
  return {
    ...(input.NumberOfFalses != null && { NumberOfFalses: input.NumberOfFalses }),
    ...(input.NumberOfNulls != null && { NumberOfNulls: input.NumberOfNulls }),
    ...(input.NumberOfTrues != null && { NumberOfTrues: input.NumberOfTrues }),
  };
};

/**
 * serializeAws_json1_1BoundedPartitionValueList
 */
const se_BoundedPartitionValueList = (input: string[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      return entry;
    });
};

/**
 * serializeAws_json1_1CancelDataQualityRuleRecommendationRunRequest
 */
const se_CancelDataQualityRuleRecommendationRunRequest = (
  input: CancelDataQualityRuleRecommendationRunRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.RunId != null && { RunId: input.RunId }),
  };
};

/**
 * serializeAws_json1_1CancelDataQualityRulesetEvaluationRunRequest
 */
const se_CancelDataQualityRulesetEvaluationRunRequest = (
  input: CancelDataQualityRulesetEvaluationRunRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.RunId != null && { RunId: input.RunId }),
  };
};

/**
 * serializeAws_json1_1CancelMLTaskRunRequest
 */
const se_CancelMLTaskRunRequest = (input: CancelMLTaskRunRequest, context: __SerdeContext): any => {
  return {
    ...(input.TaskRunId != null && { TaskRunId: input.TaskRunId }),
    ...(input.TransformId != null && { TransformId: input.TransformId }),
  };
};

/**
 * serializeAws_json1_1CancelStatementRequest
 */
const se_CancelStatementRequest = (input: CancelStatementRequest, context: __SerdeContext): any => {
  return {
    ...(input.Id != null && { Id: input.Id }),
    ...(input.RequestOrigin != null && { RequestOrigin: input.RequestOrigin }),
    ...(input.SessionId != null && { SessionId: input.SessionId }),
  };
};

/**
 * serializeAws_json1_1CatalogDeltaSource
 */
const se_CatalogDeltaSource = (input: CatalogDeltaSource, context: __SerdeContext): any => {
  return {
    ...(input.AdditionalDeltaOptions != null && {
      AdditionalDeltaOptions: se_AdditionalOptions(input.AdditionalDeltaOptions, context),
    }),
    ...(input.Database != null && { Database: input.Database }),
    ...(input.Name != null && { Name: input.Name }),
    ...(input.OutputSchemas != null && { OutputSchemas: se_GlueSchemas(input.OutputSchemas, context) }),
    ...(input.Table != null && { Table: input.Table }),
  };
};

/**
 * serializeAws_json1_1CatalogEntries
 */
const se_CatalogEntries = (input: CatalogEntry[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      return se_CatalogEntry(entry, context);
    });
};

/**
 * serializeAws_json1_1CatalogEntry
 */
const se_CatalogEntry = (input: CatalogEntry, context: __SerdeContext): any => {
  return {
    ...(input.DatabaseName != null && { DatabaseName: input.DatabaseName }),
    ...(input.TableName != null && { TableName: input.TableName }),
  };
};

/**
 * serializeAws_json1_1CatalogHudiSource
 */
const se_CatalogHudiSource = (input: CatalogHudiSource, context: __SerdeContext): any => {
  return {
    ...(input.AdditionalHudiOptions != null && {
      AdditionalHudiOptions: se_AdditionalOptions(input.AdditionalHudiOptions, context),
    }),
    ...(input.Database != null && { Database: input.Database }),
    ...(input.Name != null && { Name: input.Name }),
    ...(input.OutputSchemas != null && { OutputSchemas: se_GlueSchemas(input.OutputSchemas, context) }),
    ...(input.Table != null && { Table: input.Table }),
  };
};

/**
 * serializeAws_json1_1CatalogKafkaSource
 */
const se_CatalogKafkaSource = (input: CatalogKafkaSource, context: __SerdeContext): any => {
  return {
    ...(input.DataPreviewOptions != null && {
      DataPreviewOptions: se_StreamingDataPreviewOptions(input.DataPreviewOptions, context),
    }),
    ...(input.Database != null && { Database: input.Database }),
    ...(input.DetectSchema != null && { DetectSchema: input.DetectSchema }),
    ...(input.Name != null && { Name: input.Name }),
    ...(input.StreamingOptions != null && {
      StreamingOptions: se_KafkaStreamingSourceOptions(input.StreamingOptions, context),
    }),
    ...(input.Table != null && { Table: input.Table }),
    ...(input.WindowSize != null && { WindowSize: input.WindowSize }),
  };
};

/**
 * serializeAws_json1_1CatalogKinesisSource
 */
const se_CatalogKinesisSource = (input: CatalogKinesisSource, context: __SerdeContext): any => {
  return {
    ...(input.DataPreviewOptions != null && {
      DataPreviewOptions: se_StreamingDataPreviewOptions(input.DataPreviewOptions, context),
    }),
    ...(input.Database != null && { Database: input.Database }),
    ...(input.DetectSchema != null && { DetectSchema: input.DetectSchema }),
    ...(input.Name != null && { Name: input.Name }),
    ...(input.StreamingOptions != null && {
      StreamingOptions: se_KinesisStreamingSourceOptions(input.StreamingOptions, context),
    }),
    ...(input.Table != null && { Table: input.Table }),
    ...(input.WindowSize != null && { WindowSize: input.WindowSize }),
  };
};

/**
 * serializeAws_json1_1CatalogSchemaChangePolicy
 */
const se_CatalogSchemaChangePolicy = (input: CatalogSchemaChangePolicy, context: __SerdeContext): any => {
  return {
    ...(input.EnableUpdateCatalog != null && { EnableUpdateCatalog: input.EnableUpdateCatalog }),
    ...(input.UpdateBehavior != null && { UpdateBehavior: input.UpdateBehavior }),
  };
};

/**
 * serializeAws_json1_1CatalogSource
 */
const se_CatalogSource = (input: CatalogSource, context: __SerdeContext): any => {
  return {
    ...(input.Database != null && { Database: input.Database }),
    ...(input.Name != null && { Name: input.Name }),
    ...(input.Table != null && { Table: input.Table }),
  };
};

/**
 * serializeAws_json1_1CatalogTablesList
 */
const se_CatalogTablesList = (input: string[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      return entry;
    });
};

/**
 * serializeAws_json1_1CatalogTarget
 */
const se_CatalogTarget = (input: CatalogTarget, context: __SerdeContext): any => {
  return {
    ...(input.ConnectionName != null && { ConnectionName: input.ConnectionName }),
    ...(input.DatabaseName != null && { DatabaseName: input.DatabaseName }),
    ...(input.DlqEventQueueArn != null && { DlqEventQueueArn: input.DlqEventQueueArn }),
    ...(input.EventQueueArn != null && { EventQueueArn: input.EventQueueArn }),
    ...(input.Tables != null && { Tables: se_CatalogTablesList(input.Tables, context) }),
  };
};

/**
 * serializeAws_json1_1CatalogTargetList
 */
const se_CatalogTargetList = (input: CatalogTarget[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      return se_CatalogTarget(entry, context);
    });
};

/**
 * serializeAws_json1_1CheckSchemaVersionValidityInput
 */
const se_CheckSchemaVersionValidityInput = (input: CheckSchemaVersionValidityInput, context: __SerdeContext): any => {
  return {
    ...(input.DataFormat != null && { DataFormat: input.DataFormat }),
    ...(input.SchemaDefinition != null && { SchemaDefinition: input.SchemaDefinition }),
  };
};

/**
 * serializeAws_json1_1ClassifierNameList
 */
const se_ClassifierNameList = (input: string[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      return entry;
    });
};

/**
 * serializeAws_json1_1CloudWatchEncryption
 */
const se_CloudWatchEncryption = (input: CloudWatchEncryption, context: __SerdeContext): any => {
  return {
    ...(input.CloudWatchEncryptionMode != null && { CloudWatchEncryptionMode: input.CloudWatchEncryptionMode }),
    ...(input.KmsKeyArn != null && { KmsKeyArn: input.KmsKeyArn }),
  };
};

/**
 * serializeAws_json1_1CodeGenConfigurationNode
 */
const se_CodeGenConfigurationNode = (input: CodeGenConfigurationNode, context: __SerdeContext): any => {
  return {
    ...(input.Aggregate != null && { Aggregate: se_Aggregate(input.Aggregate, context) }),
    ...(input.ApplyMapping != null && { ApplyMapping: se_ApplyMapping(input.ApplyMapping, context) }),
    ...(input.AthenaConnectorSource != null && {
      AthenaConnectorSource: se_AthenaConnectorSource(input.AthenaConnectorSource, context),
    }),
    ...(input.CatalogDeltaSource != null && {
      CatalogDeltaSource: se_CatalogDeltaSource(input.CatalogDeltaSource, context),
    }),
    ...(input.CatalogHudiSource != null && {
      CatalogHudiSource: se_CatalogHudiSource(input.CatalogHudiSource, context),
    }),
    ...(input.CatalogKafkaSource != null && {
      CatalogKafkaSource: se_CatalogKafkaSource(input.CatalogKafkaSource, context),
    }),
    ...(input.CatalogKinesisSource != null && {
      CatalogKinesisSource: se_CatalogKinesisSource(input.CatalogKinesisSource, context),
    }),
    ...(input.CatalogSource != null && { CatalogSource: se_CatalogSource(input.CatalogSource, context) }),
    ...(input.CatalogTarget != null && { CatalogTarget: se_BasicCatalogTarget(input.CatalogTarget, context) }),
    ...(input.CustomCode != null && { CustomCode: se_CustomCode(input.CustomCode, context) }),
    ...(input.DirectJDBCSource != null && { DirectJDBCSource: se_DirectJDBCSource(input.DirectJDBCSource, context) }),
    ...(input.DirectKafkaSource != null && {
      DirectKafkaSource: se_DirectKafkaSource(input.DirectKafkaSource, context),
    }),
    ...(input.DirectKinesisSource != null && {
      DirectKinesisSource: se_DirectKinesisSource(input.DirectKinesisSource, context),
    }),
    ...(input.DropDuplicates != null && { DropDuplicates: se_DropDuplicates(input.DropDuplicates, context) }),
    ...(input.DropFields != null && { DropFields: se_DropFields(input.DropFields, context) }),
    ...(input.DropNullFields != null && { DropNullFields: se_DropNullFields(input.DropNullFields, context) }),
    ...(input.DynamicTransform != null && { DynamicTransform: se_DynamicTransform(input.DynamicTransform, context) }),
    ...(input.DynamoDBCatalogSource != null && {
      DynamoDBCatalogSource: se_DynamoDBCatalogSource(input.DynamoDBCatalogSource, context),
    }),
    ...(input.EvaluateDataQuality != null && {
      EvaluateDataQuality: se_EvaluateDataQuality(input.EvaluateDataQuality, context),
    }),
    ...(input.FillMissingValues != null && {
      FillMissingValues: se_FillMissingValues(input.FillMissingValues, context),
    }),
    ...(input.Filter != null && { Filter: se_Filter(input.Filter, context) }),
    ...(input.GovernedCatalogSource != null && {
      GovernedCatalogSource: se_GovernedCatalogSource(input.GovernedCatalogSource, context),
    }),
    ...(input.GovernedCatalogTarget != null && {
      GovernedCatalogTarget: se_GovernedCatalogTarget(input.GovernedCatalogTarget, context),
    }),
    ...(input.JDBCConnectorSource != null && {
      JDBCConnectorSource: se_JDBCConnectorSource(input.JDBCConnectorSource, context),
    }),
    ...(input.JDBCConnectorTarget != null && {
      JDBCConnectorTarget: se_JDBCConnectorTarget(input.JDBCConnectorTarget, context),
    }),
    ...(input.Join != null && { Join: se_Join(input.Join, context) }),
    ...(input.Merge != null && { Merge: se_Merge(input.Merge, context) }),
    ...(input.MicrosoftSQLServerCatalogSource != null && {
      MicrosoftSQLServerCatalogSource: se_MicrosoftSQLServerCatalogSource(
        input.MicrosoftSQLServerCatalogSource,
        context
      ),
    }),
    ...(input.MicrosoftSQLServerCatalogTarget != null && {
      MicrosoftSQLServerCatalogTarget: se_MicrosoftSQLServerCatalogTarget(
        input.MicrosoftSQLServerCatalogTarget,
        context
      ),
    }),
    ...(input.MySQLCatalogSource != null && {
      MySQLCatalogSource: se_MySQLCatalogSource(input.MySQLCatalogSource, context),
    }),
    ...(input.MySQLCatalogTarget != null && {
      MySQLCatalogTarget: se_MySQLCatalogTarget(input.MySQLCatalogTarget, context),
    }),
    ...(input.OracleSQLCatalogSource != null && {
      OracleSQLCatalogSource: se_OracleSQLCatalogSource(input.OracleSQLCatalogSource, context),
    }),
    ...(input.OracleSQLCatalogTarget != null && {
      OracleSQLCatalogTarget: se_OracleSQLCatalogTarget(input.OracleSQLCatalogTarget, context),
    }),
    ...(input.PIIDetection != null && { PIIDetection: se_PIIDetection(input.PIIDetection, context) }),
    ...(input.PostgreSQLCatalogSource != null && {
      PostgreSQLCatalogSource: se_PostgreSQLCatalogSource(input.PostgreSQLCatalogSource, context),
    }),
    ...(input.PostgreSQLCatalogTarget != null && {
      PostgreSQLCatalogTarget: se_PostgreSQLCatalogTarget(input.PostgreSQLCatalogTarget, context),
    }),
    ...(input.RedshiftSource != null && { RedshiftSource: se_RedshiftSource(input.RedshiftSource, context) }),
    ...(input.RedshiftTarget != null && { RedshiftTarget: se_RedshiftTarget(input.RedshiftTarget, context) }),
    ...(input.RelationalCatalogSource != null && {
      RelationalCatalogSource: se_RelationalCatalogSource(input.RelationalCatalogSource, context),
    }),
    ...(input.RenameField != null && { RenameField: se_RenameField(input.RenameField, context) }),
    ...(input.S3CatalogDeltaSource != null && {
      S3CatalogDeltaSource: se_S3CatalogDeltaSource(input.S3CatalogDeltaSource, context),
    }),
    ...(input.S3CatalogHudiSource != null && {
      S3CatalogHudiSource: se_S3CatalogHudiSource(input.S3CatalogHudiSource, context),
    }),
    ...(input.S3CatalogSource != null && { S3CatalogSource: se_S3CatalogSource(input.S3CatalogSource, context) }),
    ...(input.S3CatalogTarget != null && { S3CatalogTarget: se_S3CatalogTarget(input.S3CatalogTarget, context) }),
    ...(input.S3CsvSource != null && { S3CsvSource: se_S3CsvSource(input.S3CsvSource, context) }),
    ...(input.S3DeltaCatalogTarget != null && {
      S3DeltaCatalogTarget: se_S3DeltaCatalogTarget(input.S3DeltaCatalogTarget, context),
    }),
    ...(input.S3DeltaDirectTarget != null && {
      S3DeltaDirectTarget: se_S3DeltaDirectTarget(input.S3DeltaDirectTarget, context),
    }),
    ...(input.S3DeltaSource != null && { S3DeltaSource: se_S3DeltaSource(input.S3DeltaSource, context) }),
    ...(input.S3DirectTarget != null && { S3DirectTarget: se_S3DirectTarget(input.S3DirectTarget, context) }),
    ...(input.S3GlueParquetTarget != null && {
      S3GlueParquetTarget: se_S3GlueParquetTarget(input.S3GlueParquetTarget, context),
    }),
    ...(input.S3HudiCatalogTarget != null && {
      S3HudiCatalogTarget: se_S3HudiCatalogTarget(input.S3HudiCatalogTarget, context),
    }),
    ...(input.S3HudiDirectTarget != null && {
      S3HudiDirectTarget: se_S3HudiDirectTarget(input.S3HudiDirectTarget, context),
    }),
    ...(input.S3HudiSource != null && { S3HudiSource: se_S3HudiSource(input.S3HudiSource, context) }),
    ...(input.S3JsonSource != null && { S3JsonSource: se_S3JsonSource(input.S3JsonSource, context) }),
    ...(input.S3ParquetSource != null && { S3ParquetSource: se_S3ParquetSource(input.S3ParquetSource, context) }),
    ...(input.SelectFields != null && { SelectFields: se_SelectFields(input.SelectFields, context) }),
    ...(input.SelectFromCollection != null && {
      SelectFromCollection: se_SelectFromCollection(input.SelectFromCollection, context),
    }),
    ...(input.SparkConnectorSource != null && {
      SparkConnectorSource: se_SparkConnectorSource(input.SparkConnectorSource, context),
    }),
    ...(input.SparkConnectorTarget != null && {
      SparkConnectorTarget: se_SparkConnectorTarget(input.SparkConnectorTarget, context),
    }),
    ...(input.SparkSQL != null && { SparkSQL: se_SparkSQL(input.SparkSQL, context) }),
    ...(input.Spigot != null && { Spigot: se_Spigot(input.Spigot, context) }),
    ...(input.SplitFields != null && { SplitFields: se_SplitFields(input.SplitFields, context) }),
    ...(input.Union != null && { Union: se_Union(input.Union, context) }),
  };
};

/**
 * serializeAws_json1_1CodeGenConfigurationNodes
 */
const se_CodeGenConfigurationNodes = (
  input: Record<string, CodeGenConfigurationNode>,
  context: __SerdeContext
): any => {
  return Object.entries(input).reduce((acc: Record<string, any>, [key, value]: [string, any]) => {
    if (value === null) {
      return acc;
    }
    acc[key] = se_CodeGenConfigurationNode(value, context);
    return acc;
  }, {});
};

/**
 * serializeAws_json1_1CodeGenEdge
 */
const se_CodeGenEdge = (input: CodeGenEdge, context: __SerdeContext): any => {
  return {
    ...(input.Source != null && { Source: input.Source }),
    ...(input.Target != null && { Target: input.Target }),
    ...(input.TargetParameter != null && { TargetParameter: input.TargetParameter }),
  };
};

/**
 * serializeAws_json1_1CodeGenNode
 */
const se_CodeGenNode = (input: CodeGenNode, context: __SerdeContext): any => {
  return {
    ...(input.Args != null && { Args: se_CodeGenNodeArgs(input.Args, context) }),
    ...(input.Id != null && { Id: input.Id }),
    ...(input.LineNumber != null && { LineNumber: input.LineNumber }),
    ...(input.NodeType != null && { NodeType: input.NodeType }),
  };
};

/**
 * serializeAws_json1_1CodeGenNodeArg
 */
const se_CodeGenNodeArg = (input: CodeGenNodeArg, context: __SerdeContext): any => {
  return {
    ...(input.Name != null && { Name: input.Name }),
    ...(input.Param != null && { Param: input.Param }),
    ...(input.Value != null && { Value: input.Value }),
  };
};

/**
 * serializeAws_json1_1CodeGenNodeArgs
 */
const se_CodeGenNodeArgs = (input: CodeGenNodeArg[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      return se_CodeGenNodeArg(entry, context);
    });
};

/**
 * serializeAws_json1_1Column
 */
const se_Column = (input: Column, context: __SerdeContext): any => {
  return {
    ...(input.Comment != null && { Comment: input.Comment }),
    ...(input.Name != null && { Name: input.Name }),
    ...(input.Parameters != null && { Parameters: se_ParametersMap(input.Parameters, context) }),
    ...(input.Type != null && { Type: input.Type }),
  };
};

/**
 * serializeAws_json1_1ColumnList
 */
const se_ColumnList = (input: Column[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      return se_Column(entry, context);
    });
};

/**
 * serializeAws_json1_1ColumnStatistics
 */
const se_ColumnStatistics = (input: ColumnStatistics, context: __SerdeContext): any => {
  return {
    ...(input.AnalyzedTime != null && { AnalyzedTime: Math.round(input.AnalyzedTime.getTime() / 1000) }),
    ...(input.ColumnName != null && { ColumnName: input.ColumnName }),
    ...(input.ColumnType != null && { ColumnType: input.ColumnType }),
    ...(input.StatisticsData != null && { StatisticsData: se_ColumnStatisticsData(input.StatisticsData, context) }),
  };
};

/**
 * serializeAws_json1_1ColumnStatisticsData
 */
const se_ColumnStatisticsData = (input: ColumnStatisticsData, context: __SerdeContext): any => {
  return {
    ...(input.BinaryColumnStatisticsData != null && {
      BinaryColumnStatisticsData: se_BinaryColumnStatisticsData(input.BinaryColumnStatisticsData, context),
    }),
    ...(input.BooleanColumnStatisticsData != null && {
      BooleanColumnStatisticsData: se_BooleanColumnStatisticsData(input.BooleanColumnStatisticsData, context),
    }),
    ...(input.DateColumnStatisticsData != null && {
      DateColumnStatisticsData: se_DateColumnStatisticsData(input.DateColumnStatisticsData, context),
    }),
    ...(input.DecimalColumnStatisticsData != null && {
      DecimalColumnStatisticsData: se_DecimalColumnStatisticsData(input.DecimalColumnStatisticsData, context),
    }),
    ...(input.DoubleColumnStatisticsData != null && {
      DoubleColumnStatisticsData: se_DoubleColumnStatisticsData(input.DoubleColumnStatisticsData, context),
    }),
    ...(input.LongColumnStatisticsData != null && {
      LongColumnStatisticsData: se_LongColumnStatisticsData(input.LongColumnStatisticsData, context),
    }),
    ...(input.StringColumnStatisticsData != null && {
      StringColumnStatisticsData: se_StringColumnStatisticsData(input.StringColumnStatisticsData, context),
    }),
    ...(input.Type != null && { Type: input.Type }),
  };
};

/**
 * serializeAws_json1_1ColumnValueStringList
 */
const se_ColumnValueStringList = (input: string[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      return entry;
    });
};

/**
 * serializeAws_json1_1Condition
 */
const se_Condition = (input: Condition, context: __SerdeContext): any => {
  return {
    ...(input.CrawlState != null && { CrawlState: input.CrawlState }),
    ...(input.CrawlerName != null && { CrawlerName: input.CrawlerName }),
    ...(input.JobName != null && { JobName: input.JobName }),
    ...(input.LogicalOperator != null && { LogicalOperator: input.LogicalOperator }),
    ...(input.State != null && { State: input.State }),
  };
};

/**
 * serializeAws_json1_1ConditionList
 */
const se_ConditionList = (input: Condition[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      return se_Condition(entry, context);
    });
};

/**
 * serializeAws_json1_1ConnectionInput
 */
const se_ConnectionInput = (input: ConnectionInput, context: __SerdeContext): any => {
  return {
    ...(input.ConnectionProperties != null && {
      ConnectionProperties: se_ConnectionProperties(input.ConnectionProperties, context),
    }),
    ...(input.ConnectionType != null && { ConnectionType: input.ConnectionType }),
    ...(input.Description != null && { Description: input.Description }),
    ...(input.MatchCriteria != null && { MatchCriteria: se_MatchCriteria(input.MatchCriteria, context) }),
    ...(input.Name != null && { Name: input.Name }),
    ...(input.PhysicalConnectionRequirements != null && {
      PhysicalConnectionRequirements: se_PhysicalConnectionRequirements(input.PhysicalConnectionRequirements, context),
    }),
  };
};

/**
 * serializeAws_json1_1ConnectionPasswordEncryption
 */
const se_ConnectionPasswordEncryption = (input: ConnectionPasswordEncryption, context: __SerdeContext): any => {
  return {
    ...(input.AwsKmsKeyId != null && { AwsKmsKeyId: input.AwsKmsKeyId }),
    ...(input.ReturnConnectionPasswordEncrypted != null && {
      ReturnConnectionPasswordEncrypted: input.ReturnConnectionPasswordEncrypted,
    }),
  };
};

/**
 * serializeAws_json1_1ConnectionProperties
 */
const se_ConnectionProperties = (input: Record<string, string>, context: __SerdeContext): any => {
  return Object.entries(input).reduce(
    (acc: Record<string, any>, [key, value]: [ConnectionPropertyKey | string, any]) => {
      if (value === null) {
        return acc;
      }
      acc[key] = value;
      return acc;
    },
    {}
  );
};

/**
 * serializeAws_json1_1ConnectionsList
 */
const se_ConnectionsList = (input: ConnectionsList, context: __SerdeContext): any => {
  return {
    ...(input.Connections != null && { Connections: se_OrchestrationStringList(input.Connections, context) }),
  };
};

/**
 * serializeAws_json1_1ContextWords
 */
const se_ContextWords = (input: string[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      return entry;
    });
};

/**
 * serializeAws_json1_1CrawlerNameList
 */
const se_CrawlerNameList = (input: string[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      return entry;
    });
};

/**
 * serializeAws_json1_1CrawlerTargets
 */
const se_CrawlerTargets = (input: CrawlerTargets, context: __SerdeContext): any => {
  return {
    ...(input.CatalogTargets != null && { CatalogTargets: se_CatalogTargetList(input.CatalogTargets, context) }),
    ...(input.DeltaTargets != null && { DeltaTargets: se_DeltaTargetList(input.DeltaTargets, context) }),
    ...(input.DynamoDBTargets != null && { DynamoDBTargets: se_DynamoDBTargetList(input.DynamoDBTargets, context) }),
    ...(input.JdbcTargets != null && { JdbcTargets: se_JdbcTargetList(input.JdbcTargets, context) }),
    ...(input.MongoDBTargets != null && { MongoDBTargets: se_MongoDBTargetList(input.MongoDBTargets, context) }),
    ...(input.S3Targets != null && { S3Targets: se_S3TargetList(input.S3Targets, context) }),
  };
};

/**
 * serializeAws_json1_1CrawlsFilter
 */
const se_CrawlsFilter = (input: CrawlsFilter, context: __SerdeContext): any => {
  return {
    ...(input.FieldName != null && { FieldName: input.FieldName }),
    ...(input.FieldValue != null && { FieldValue: input.FieldValue }),
    ...(input.FilterOperator != null && { FilterOperator: input.FilterOperator }),
  };
};

/**
 * serializeAws_json1_1CrawlsFilterList
 */
const se_CrawlsFilterList = (input: CrawlsFilter[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      return se_CrawlsFilter(entry, context);
    });
};

/**
 * serializeAws_json1_1CreateBlueprintRequest
 */
const se_CreateBlueprintRequest = (input: CreateBlueprintRequest, context: __SerdeContext): any => {
  return {
    ...(input.BlueprintLocation != null && { BlueprintLocation: input.BlueprintLocation }),
    ...(input.Description != null && { Description: input.Description }),
    ...(input.Name != null && { Name: input.Name }),
    ...(input.Tags != null && { Tags: se_TagsMap(input.Tags, context) }),
  };
};

/**
 * serializeAws_json1_1CreateClassifierRequest
 */
const se_CreateClassifierRequest = (input: CreateClassifierRequest, context: __SerdeContext): any => {
  return {
    ...(input.CsvClassifier != null && { CsvClassifier: se_CreateCsvClassifierRequest(input.CsvClassifier, context) }),
    ...(input.GrokClassifier != null && {
      GrokClassifier: se_CreateGrokClassifierRequest(input.GrokClassifier, context),
    }),
    ...(input.JsonClassifier != null && {
      JsonClassifier: se_CreateJsonClassifierRequest(input.JsonClassifier, context),
    }),
    ...(input.XMLClassifier != null && { XMLClassifier: se_CreateXMLClassifierRequest(input.XMLClassifier, context) }),
  };
};

/**
 * serializeAws_json1_1CreateConnectionRequest
 */
const se_CreateConnectionRequest = (input: CreateConnectionRequest, context: __SerdeContext): any => {
  return {
    ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
    ...(input.ConnectionInput != null && { ConnectionInput: se_ConnectionInput(input.ConnectionInput, context) }),
    ...(input.Tags != null && { Tags: se_TagsMap(input.Tags, context) }),
  };
};

/**
 * serializeAws_json1_1CreateCrawlerRequest
 */
const se_CreateCrawlerRequest = (input: CreateCrawlerRequest, context: __SerdeContext): any => {
  return {
    ...(input.Classifiers != null && { Classifiers: se_ClassifierNameList(input.Classifiers, context) }),
    ...(input.Configuration != null && { Configuration: input.Configuration }),
    ...(input.CrawlerSecurityConfiguration != null && {
      CrawlerSecurityConfiguration: input.CrawlerSecurityConfiguration,
    }),
    ...(input.DatabaseName != null && { DatabaseName: input.DatabaseName }),
    ...(input.Description != null && { Description: input.Description }),
    ...(input.LakeFormationConfiguration != null && {
      LakeFormationConfiguration: se_LakeFormationConfiguration(input.LakeFormationConfiguration, context),
    }),
    ...(input.LineageConfiguration != null && {
      LineageConfiguration: se_LineageConfiguration(input.LineageConfiguration, context),
    }),
    ...(input.Name != null && { Name: input.Name }),
    ...(input.RecrawlPolicy != null && { RecrawlPolicy: se_RecrawlPolicy(input.RecrawlPolicy, context) }),
    ...(input.Role != null && { Role: input.Role }),
    ...(input.Schedule != null && { Schedule: input.Schedule }),
    ...(input.SchemaChangePolicy != null && {
      SchemaChangePolicy: se_SchemaChangePolicy(input.SchemaChangePolicy, context),
    }),
    ...(input.TablePrefix != null && { TablePrefix: input.TablePrefix }),
    ...(input.Tags != null && { Tags: se_TagsMap(input.Tags, context) }),
    ...(input.Targets != null && { Targets: se_CrawlerTargets(input.Targets, context) }),
  };
};

/**
 * serializeAws_json1_1CreateCsvClassifierRequest
 */
const se_CreateCsvClassifierRequest = (input: CreateCsvClassifierRequest, context: __SerdeContext): any => {
  return {
    ...(input.AllowSingleColumn != null && { AllowSingleColumn: input.AllowSingleColumn }),
    ...(input.ContainsHeader != null && { ContainsHeader: input.ContainsHeader }),
    ...(input.CustomDatatypeConfigured != null && { CustomDatatypeConfigured: input.CustomDatatypeConfigured }),
    ...(input.CustomDatatypes != null && { CustomDatatypes: se_CustomDatatypes(input.CustomDatatypes, context) }),
    ...(input.Delimiter != null && { Delimiter: input.Delimiter }),
    ...(input.DisableValueTrimming != null && { DisableValueTrimming: input.DisableValueTrimming }),
    ...(input.Header != null && { Header: se_CsvHeader(input.Header, context) }),
    ...(input.Name != null && { Name: input.Name }),
    ...(input.QuoteSymbol != null && { QuoteSymbol: input.QuoteSymbol }),
  };
};

/**
 * serializeAws_json1_1CreateCustomEntityTypeRequest
 */
const se_CreateCustomEntityTypeRequest = (input: CreateCustomEntityTypeRequest, context: __SerdeContext): any => {
  return {
    ...(input.ContextWords != null && { ContextWords: se_ContextWords(input.ContextWords, context) }),
    ...(input.Name != null && { Name: input.Name }),
    ...(input.RegexString != null && { RegexString: input.RegexString }),
  };
};

/**
 * serializeAws_json1_1CreateDatabaseRequest
 */
const se_CreateDatabaseRequest = (input: CreateDatabaseRequest, context: __SerdeContext): any => {
  return {
    ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
    ...(input.DatabaseInput != null && { DatabaseInput: se_DatabaseInput(input.DatabaseInput, context) }),
    ...(input.Tags != null && { Tags: se_TagsMap(input.Tags, context) }),
  };
};

/**
 * serializeAws_json1_1CreateDataQualityRulesetRequest
 */
const se_CreateDataQualityRulesetRequest = (input: CreateDataQualityRulesetRequest, context: __SerdeContext): any => {
  return {
    ...(input.ClientToken != null && { ClientToken: input.ClientToken }),
    ...(input.Description != null && { Description: input.Description }),
    ...(input.Name != null && { Name: input.Name }),
    ...(input.Ruleset != null && { Ruleset: input.Ruleset }),
    ...(input.Tags != null && { Tags: se_TagsMap(input.Tags, context) }),
    ...(input.TargetTable != null && { TargetTable: se_DataQualityTargetTable(input.TargetTable, context) }),
  };
};

/**
 * serializeAws_json1_1CreateDevEndpointRequest
 */
const se_CreateDevEndpointRequest = (input: CreateDevEndpointRequest, context: __SerdeContext): any => {
  return {
    ...(input.Arguments != null && { Arguments: se_MapValue(input.Arguments, context) }),
    ...(input.EndpointName != null && { EndpointName: input.EndpointName }),
    ...(input.ExtraJarsS3Path != null && { ExtraJarsS3Path: input.ExtraJarsS3Path }),
    ...(input.ExtraPythonLibsS3Path != null && { ExtraPythonLibsS3Path: input.ExtraPythonLibsS3Path }),
    ...(input.GlueVersion != null && { GlueVersion: input.GlueVersion }),
    ...(input.NumberOfNodes != null && { NumberOfNodes: input.NumberOfNodes }),
    ...(input.NumberOfWorkers != null && { NumberOfWorkers: input.NumberOfWorkers }),
    ...(input.PublicKey != null && { PublicKey: input.PublicKey }),
    ...(input.PublicKeys != null && { PublicKeys: se_PublicKeysList(input.PublicKeys, context) }),
    ...(input.RoleArn != null && { RoleArn: input.RoleArn }),
    ...(input.SecurityConfiguration != null && { SecurityConfiguration: input.SecurityConfiguration }),
    ...(input.SecurityGroupIds != null && { SecurityGroupIds: se_StringList(input.SecurityGroupIds, context) }),
    ...(input.SubnetId != null && { SubnetId: input.SubnetId }),
    ...(input.Tags != null && { Tags: se_TagsMap(input.Tags, context) }),
    ...(input.WorkerType != null && { WorkerType: input.WorkerType }),
  };
};

/**
 * serializeAws_json1_1CreateGrokClassifierRequest
 */
const se_CreateGrokClassifierRequest = (input: CreateGrokClassifierRequest, context: __SerdeContext): any => {
  return {
    ...(input.Classification != null && { Classification: input.Classification }),
    ...(input.CustomPatterns != null && { CustomPatterns: input.CustomPatterns }),
    ...(input.GrokPattern != null && { GrokPattern: input.GrokPattern }),
    ...(input.Name != null && { Name: input.Name }),
  };
};

/**
 * serializeAws_json1_1CreateJobRequest
 */
const se_CreateJobRequest = (input: CreateJobRequest, context: __SerdeContext): any => {
  return {
    ...(input.AllocatedCapacity != null && { AllocatedCapacity: input.AllocatedCapacity }),
    ...(input.CodeGenConfigurationNodes != null && {
      CodeGenConfigurationNodes: se_CodeGenConfigurationNodes(input.CodeGenConfigurationNodes, context),
    }),
    ...(input.Command != null && { Command: se_JobCommand(input.Command, context) }),
    ...(input.Connections != null && { Connections: se_ConnectionsList(input.Connections, context) }),
    ...(input.DefaultArguments != null && { DefaultArguments: se_GenericMap(input.DefaultArguments, context) }),
    ...(input.Description != null && { Description: input.Description }),
    ...(input.ExecutionClass != null && { ExecutionClass: input.ExecutionClass }),
    ...(input.ExecutionProperty != null && {
      ExecutionProperty: se_ExecutionProperty(input.ExecutionProperty, context),
    }),
    ...(input.GlueVersion != null && { GlueVersion: input.GlueVersion }),
    ...(input.LogUri != null && { LogUri: input.LogUri }),
    ...(input.MaxCapacity != null && { MaxCapacity: __serializeFloat(input.MaxCapacity) }),
    ...(input.MaxRetries != null && { MaxRetries: input.MaxRetries }),
    ...(input.Name != null && { Name: input.Name }),
    ...(input.NonOverridableArguments != null && {
      NonOverridableArguments: se_GenericMap(input.NonOverridableArguments, context),
    }),
    ...(input.NotificationProperty != null && {
      NotificationProperty: se_NotificationProperty(input.NotificationProperty, context),
    }),
    ...(input.NumberOfWorkers != null && { NumberOfWorkers: input.NumberOfWorkers }),
    ...(input.Role != null && { Role: input.Role }),
    ...(input.SecurityConfiguration != null && { SecurityConfiguration: input.SecurityConfiguration }),
    ...(input.SourceControlDetails != null && {
      SourceControlDetails: se_SourceControlDetails(input.SourceControlDetails, context),
    }),
    ...(input.Tags != null && { Tags: se_TagsMap(input.Tags, context) }),
    ...(input.Timeout != null && { Timeout: input.Timeout }),
    ...(input.WorkerType != null && { WorkerType: input.WorkerType }),
  };
};

/**
 * serializeAws_json1_1CreateJsonClassifierRequest
 */
const se_CreateJsonClassifierRequest = (input: CreateJsonClassifierRequest, context: __SerdeContext): any => {
  return {
    ...(input.JsonPath != null && { JsonPath: input.JsonPath }),
    ...(input.Name != null && { Name: input.Name }),
  };
};

/**
 * serializeAws_json1_1CreateMLTransformRequest
 */
const se_CreateMLTransformRequest = (input: CreateMLTransformRequest, context: __SerdeContext): any => {
  return {
    ...(input.Description != null && { Description: input.Description }),
    ...(input.GlueVersion != null && { GlueVersion: input.GlueVersion }),
    ...(input.InputRecordTables != null && { InputRecordTables: se_GlueTables(input.InputRecordTables, context) }),
    ...(input.MaxCapacity != null && { MaxCapacity: __serializeFloat(input.MaxCapacity) }),
    ...(input.MaxRetries != null && { MaxRetries: input.MaxRetries }),
    ...(input.Name != null && { Name: input.Name }),
    ...(input.NumberOfWorkers != null && { NumberOfWorkers: input.NumberOfWorkers }),
    ...(input.Parameters != null && { Parameters: se_TransformParameters(input.Parameters, context) }),
    ...(input.Role != null && { Role: input.Role }),
    ...(input.Tags != null && { Tags: se_TagsMap(input.Tags, context) }),
    ...(input.Timeout != null && { Timeout: input.Timeout }),
    ...(input.TransformEncryption != null && {
      TransformEncryption: se_TransformEncryption(input.TransformEncryption, context),
    }),
    ...(input.WorkerType != null && { WorkerType: input.WorkerType }),
  };
};

/**
 * serializeAws_json1_1CreatePartitionIndexRequest
 */
const se_CreatePartitionIndexRequest = (input: CreatePartitionIndexRequest, context: __SerdeContext): any => {
  return {
    ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
    ...(input.DatabaseName != null && { DatabaseName: input.DatabaseName }),
    ...(input.PartitionIndex != null && { PartitionIndex: se_PartitionIndex(input.PartitionIndex, context) }),
    ...(input.TableName != null && { TableName: input.TableName }),
  };
};

/**
 * serializeAws_json1_1CreatePartitionRequest
 */
const se_CreatePartitionRequest = (input: CreatePartitionRequest, context: __SerdeContext): any => {
  return {
    ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
    ...(input.DatabaseName != null && { DatabaseName: input.DatabaseName }),
    ...(input.PartitionInput != null && { PartitionInput: se_PartitionInput(input.PartitionInput, context) }),
    ...(input.TableName != null && { TableName: input.TableName }),
  };
};

/**
 * serializeAws_json1_1CreateRegistryInput
 */
const se_CreateRegistryInput = (input: CreateRegistryInput, context: __SerdeContext): any => {
  return {
    ...(input.Description != null && { Description: input.Description }),
    ...(input.RegistryName != null && { RegistryName: input.RegistryName }),
    ...(input.Tags != null && { Tags: se_TagsMap(input.Tags, context) }),
  };
};

/**
 * serializeAws_json1_1CreateSchemaInput
 */
const se_CreateSchemaInput = (input: CreateSchemaInput, context: __SerdeContext): any => {
  return {
    ...(input.Compatibility != null && { Compatibility: input.Compatibility }),
    ...(input.DataFormat != null && { DataFormat: input.DataFormat }),
    ...(input.Description != null && { Description: input.Description }),
    ...(input.RegistryId != null && { RegistryId: se_RegistryId(input.RegistryId, context) }),
    ...(input.SchemaDefinition != null && { SchemaDefinition: input.SchemaDefinition }),
    ...(input.SchemaName != null && { SchemaName: input.SchemaName }),
    ...(input.Tags != null && { Tags: se_TagsMap(input.Tags, context) }),
  };
};

/**
 * serializeAws_json1_1CreateScriptRequest
 */
const se_CreateScriptRequest = (input: CreateScriptRequest, context: __SerdeContext): any => {
  return {
    ...(input.DagEdges != null && { DagEdges: se_DagEdges(input.DagEdges, context) }),
    ...(input.DagNodes != null && { DagNodes: se_DagNodes(input.DagNodes, context) }),
    ...(input.Language != null && { Language: input.Language }),
  };
};

/**
 * serializeAws_json1_1CreateSecurityConfigurationRequest
 */
const se_CreateSecurityConfigurationRequest = (
  input: CreateSecurityConfigurationRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.EncryptionConfiguration != null && {
      EncryptionConfiguration: se_EncryptionConfiguration(input.EncryptionConfiguration, context),
    }),
    ...(input.Name != null && { Name: input.Name }),
  };
};

/**
 * serializeAws_json1_1CreateSessionRequest
 */
const se_CreateSessionRequest = (input: CreateSessionRequest, context: __SerdeContext): any => {
  return {
    ...(input.Command != null && { Command: se_SessionCommand(input.Command, context) }),
    ...(input.Connections != null && { Connections: se_ConnectionsList(input.Connections, context) }),
    ...(input.DefaultArguments != null && {
      DefaultArguments: se_OrchestrationArgumentsMap(input.DefaultArguments, context),
    }),
    ...(input.Description != null && { Description: input.Description }),
    ...(input.GlueVersion != null && { GlueVersion: input.GlueVersion }),
    ...(input.Id != null && { Id: input.Id }),
    ...(input.IdleTimeout != null && { IdleTimeout: input.IdleTimeout }),
    ...(input.MaxCapacity != null && { MaxCapacity: __serializeFloat(input.MaxCapacity) }),
    ...(input.NumberOfWorkers != null && { NumberOfWorkers: input.NumberOfWorkers }),
    ...(input.RequestOrigin != null && { RequestOrigin: input.RequestOrigin }),
    ...(input.Role != null && { Role: input.Role }),
    ...(input.SecurityConfiguration != null && { SecurityConfiguration: input.SecurityConfiguration }),
    ...(input.Tags != null && { Tags: se_TagsMap(input.Tags, context) }),
    ...(input.Timeout != null && { Timeout: input.Timeout }),
    ...(input.WorkerType != null && { WorkerType: input.WorkerType }),
  };
};

/**
 * serializeAws_json1_1CreateTableRequest
 */
const se_CreateTableRequest = (input: CreateTableRequest, context: __SerdeContext): any => {
  return {
    ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
    ...(input.DatabaseName != null && { DatabaseName: input.DatabaseName }),
    ...(input.PartitionIndexes != null && { PartitionIndexes: se_PartitionIndexList(input.PartitionIndexes, context) }),
    ...(input.TableInput != null && { TableInput: se_TableInput(input.TableInput, context) }),
    ...(input.TransactionId != null && { TransactionId: input.TransactionId }),
  };
};

/**
 * serializeAws_json1_1CreateTriggerRequest
 */
const se_CreateTriggerRequest = (input: CreateTriggerRequest, context: __SerdeContext): any => {
  return {
    ...(input.Actions != null && { Actions: se_ActionList(input.Actions, context) }),
    ...(input.Description != null && { Description: input.Description }),
    ...(input.EventBatchingCondition != null && {
      EventBatchingCondition: se_EventBatchingCondition(input.EventBatchingCondition, context),
    }),
    ...(input.Name != null && { Name: input.Name }),
    ...(input.Predicate != null && { Predicate: se_Predicate(input.Predicate, context) }),
    ...(input.Schedule != null && { Schedule: input.Schedule }),
    ...(input.StartOnCreation != null && { StartOnCreation: input.StartOnCreation }),
    ...(input.Tags != null && { Tags: se_TagsMap(input.Tags, context) }),
    ...(input.Type != null && { Type: input.Type }),
    ...(input.WorkflowName != null && { WorkflowName: input.WorkflowName }),
  };
};

/**
 * serializeAws_json1_1CreateUserDefinedFunctionRequest
 */
const se_CreateUserDefinedFunctionRequest = (input: CreateUserDefinedFunctionRequest, context: __SerdeContext): any => {
  return {
    ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
    ...(input.DatabaseName != null && { DatabaseName: input.DatabaseName }),
    ...(input.FunctionInput != null && { FunctionInput: se_UserDefinedFunctionInput(input.FunctionInput, context) }),
  };
};

/**
 * serializeAws_json1_1CreateWorkflowRequest
 */
const se_CreateWorkflowRequest = (input: CreateWorkflowRequest, context: __SerdeContext): any => {
  return {
    ...(input.DefaultRunProperties != null && {
      DefaultRunProperties: se_WorkflowRunProperties(input.DefaultRunProperties, context),
    }),
    ...(input.Description != null && { Description: input.Description }),
    ...(input.MaxConcurrentRuns != null && { MaxConcurrentRuns: input.MaxConcurrentRuns }),
    ...(input.Name != null && { Name: input.Name }),
    ...(input.Tags != null && { Tags: se_TagsMap(input.Tags, context) }),
  };
};

/**
 * serializeAws_json1_1CreateXMLClassifierRequest
 */
const se_CreateXMLClassifierRequest = (input: CreateXMLClassifierRequest, context: __SerdeContext): any => {
  return {
    ...(input.Classification != null && { Classification: input.Classification }),
    ...(input.Name != null && { Name: input.Name }),
    ...(input.RowTag != null && { RowTag: input.RowTag }),
  };
};

/**
 * serializeAws_json1_1CsvHeader
 */
const se_CsvHeader = (input: string[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      return entry;
    });
};

/**
 * serializeAws_json1_1CustomCode
 */
const se_CustomCode = (input: CustomCode, context: __SerdeContext): any => {
  return {
    ...(input.ClassName != null && { ClassName: input.ClassName }),
    ...(input.Code != null && { Code: input.Code }),
    ...(input.Inputs != null && { Inputs: se_ManyInputs(input.Inputs, context) }),
    ...(input.Name != null && { Name: input.Name }),
    ...(input.OutputSchemas != null && { OutputSchemas: se_GlueSchemas(input.OutputSchemas, context) }),
  };
};

/**
 * serializeAws_json1_1CustomDatatypes
 */
const se_CustomDatatypes = (input: string[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      return entry;
    });
};

/**
 * serializeAws_json1_1CustomEntityTypeNames
 */
const se_CustomEntityTypeNames = (input: string[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      return entry;
    });
};

/**
 * serializeAws_json1_1DagEdges
 */
const se_DagEdges = (input: CodeGenEdge[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      return se_CodeGenEdge(entry, context);
    });
};

/**
 * serializeAws_json1_1DagNodes
 */
const se_DagNodes = (input: CodeGenNode[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      return se_CodeGenNode(entry, context);
    });
};

/**
 * serializeAws_json1_1DatabaseIdentifier
 */
const se_DatabaseIdentifier = (input: DatabaseIdentifier, context: __SerdeContext): any => {
  return {
    ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
    ...(input.DatabaseName != null && { DatabaseName: input.DatabaseName }),
  };
};

/**
 * serializeAws_json1_1DatabaseInput
 */
const se_DatabaseInput = (input: DatabaseInput, context: __SerdeContext): any => {
  return {
    ...(input.CreateTableDefaultPermissions != null && {
      CreateTableDefaultPermissions: se_PrincipalPermissionsList(input.CreateTableDefaultPermissions, context),
    }),
    ...(input.Description != null && { Description: input.Description }),
    ...(input.FederatedDatabase != null && {
      FederatedDatabase: se_FederatedDatabase(input.FederatedDatabase, context),
    }),
    ...(input.LocationUri != null && { LocationUri: input.LocationUri }),
    ...(input.Name != null && { Name: input.Name }),
    ...(input.Parameters != null && { Parameters: se_ParametersMap(input.Parameters, context) }),
    ...(input.TargetDatabase != null && { TargetDatabase: se_DatabaseIdentifier(input.TargetDatabase, context) }),
  };
};

/**
 * serializeAws_json1_1DataCatalogEncryptionSettings
 */
const se_DataCatalogEncryptionSettings = (input: DataCatalogEncryptionSettings, context: __SerdeContext): any => {
  return {
    ...(input.ConnectionPasswordEncryption != null && {
      ConnectionPasswordEncryption: se_ConnectionPasswordEncryption(input.ConnectionPasswordEncryption, context),
    }),
    ...(input.EncryptionAtRest != null && { EncryptionAtRest: se_EncryptionAtRest(input.EncryptionAtRest, context) }),
  };
};

/**
 * serializeAws_json1_1DataLakePrincipal
 */
const se_DataLakePrincipal = (input: DataLakePrincipal, context: __SerdeContext): any => {
  return {
    ...(input.DataLakePrincipalIdentifier != null && {
      DataLakePrincipalIdentifier: input.DataLakePrincipalIdentifier,
    }),
  };
};

/**
 * serializeAws_json1_1DataQualityEvaluationRunAdditionalRunOptions
 */
const se_DataQualityEvaluationRunAdditionalRunOptions = (
  input: DataQualityEvaluationRunAdditionalRunOptions,
  context: __SerdeContext
): any => {
  return {
    ...(input.CloudWatchMetricsEnabled != null && { CloudWatchMetricsEnabled: input.CloudWatchMetricsEnabled }),
    ...(input.ResultsS3Prefix != null && { ResultsS3Prefix: input.ResultsS3Prefix }),
  };
};

/**
 * serializeAws_json1_1DataQualityResultFilterCriteria
 */
const se_DataQualityResultFilterCriteria = (input: DataQualityResultFilterCriteria, context: __SerdeContext): any => {
  return {
    ...(input.DataSource != null && { DataSource: se_DataSource(input.DataSource, context) }),
    ...(input.JobName != null && { JobName: input.JobName }),
    ...(input.JobRunId != null && { JobRunId: input.JobRunId }),
    ...(input.StartedAfter != null && { StartedAfter: Math.round(input.StartedAfter.getTime() / 1000) }),
    ...(input.StartedBefore != null && { StartedBefore: Math.round(input.StartedBefore.getTime() / 1000) }),
  };
};

/**
 * serializeAws_json1_1DataQualityResultIds
 */
const se_DataQualityResultIds = (input: string[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      return entry;
    });
};

/**
 * serializeAws_json1_1DataQualityRuleRecommendationRunFilter
 */
const se_DataQualityRuleRecommendationRunFilter = (
  input: DataQualityRuleRecommendationRunFilter,
  context: __SerdeContext
): any => {
  return {
    ...(input.DataSource != null && { DataSource: se_DataSource(input.DataSource, context) }),
    ...(input.StartedAfter != null && { StartedAfter: Math.round(input.StartedAfter.getTime() / 1000) }),
    ...(input.StartedBefore != null && { StartedBefore: Math.round(input.StartedBefore.getTime() / 1000) }),
  };
};

/**
 * serializeAws_json1_1DataQualityRulesetEvaluationRunFilter
 */
const se_DataQualityRulesetEvaluationRunFilter = (
  input: DataQualityRulesetEvaluationRunFilter,
  context: __SerdeContext
): any => {
  return {
    ...(input.DataSource != null && { DataSource: se_DataSource(input.DataSource, context) }),
    ...(input.StartedAfter != null && { StartedAfter: Math.round(input.StartedAfter.getTime() / 1000) }),
    ...(input.StartedBefore != null && { StartedBefore: Math.round(input.StartedBefore.getTime() / 1000) }),
  };
};

/**
 * serializeAws_json1_1DataQualityRulesetFilterCriteria
 */
const se_DataQualityRulesetFilterCriteria = (input: DataQualityRulesetFilterCriteria, context: __SerdeContext): any => {
  return {
    ...(input.CreatedAfter != null && { CreatedAfter: Math.round(input.CreatedAfter.getTime() / 1000) }),
    ...(input.CreatedBefore != null && { CreatedBefore: Math.round(input.CreatedBefore.getTime() / 1000) }),
    ...(input.Description != null && { Description: input.Description }),
    ...(input.LastModifiedAfter != null && { LastModifiedAfter: Math.round(input.LastModifiedAfter.getTime() / 1000) }),
    ...(input.LastModifiedBefore != null && {
      LastModifiedBefore: Math.round(input.LastModifiedBefore.getTime() / 1000),
    }),
    ...(input.Name != null && { Name: input.Name }),
    ...(input.TargetTable != null && { TargetTable: se_DataQualityTargetTable(input.TargetTable, context) }),
  };
};

/**
 * serializeAws_json1_1DataQualityTargetTable
 */
const se_DataQualityTargetTable = (input: DataQualityTargetTable, context: __SerdeContext): any => {
  return {
    ...(input.DatabaseName != null && { DatabaseName: input.DatabaseName }),
    ...(input.TableName != null && { TableName: input.TableName }),
  };
};

/**
 * serializeAws_json1_1DataSource
 */
const se_DataSource = (input: DataSource, context: __SerdeContext): any => {
  return {
    ...(input.GlueTable != null && { GlueTable: se_GlueTable(input.GlueTable, context) }),
  };
};

/**
 * serializeAws_json1_1Datatype
 */
const se_Datatype = (input: Datatype, context: __SerdeContext): any => {
  return {
    ...(input.Id != null && { Id: input.Id }),
    ...(input.Label != null && { Label: input.Label }),
  };
};

/**
 * serializeAws_json1_1DateColumnStatisticsData
 */
const se_DateColumnStatisticsData = (input: DateColumnStatisticsData, context: __SerdeContext): any => {
  return {
    ...(input.MaximumValue != null && { MaximumValue: Math.round(input.MaximumValue.getTime() / 1000) }),
    ...(input.MinimumValue != null && { MinimumValue: Math.round(input.MinimumValue.getTime() / 1000) }),
    ...(input.NumberOfDistinctValues != null && { NumberOfDistinctValues: input.NumberOfDistinctValues }),
    ...(input.NumberOfNulls != null && { NumberOfNulls: input.NumberOfNulls }),
  };
};

/**
 * serializeAws_json1_1DecimalColumnStatisticsData
 */
const se_DecimalColumnStatisticsData = (input: DecimalColumnStatisticsData, context: __SerdeContext): any => {
  return {
    ...(input.MaximumValue != null && { MaximumValue: se_DecimalNumber(input.MaximumValue, context) }),
    ...(input.MinimumValue != null && { MinimumValue: se_DecimalNumber(input.MinimumValue, context) }),
    ...(input.NumberOfDistinctValues != null && { NumberOfDistinctValues: input.NumberOfDistinctValues }),
    ...(input.NumberOfNulls != null && { NumberOfNulls: input.NumberOfNulls }),
  };
};

/**
 * serializeAws_json1_1DecimalNumber
 */
const se_DecimalNumber = (input: DecimalNumber, context: __SerdeContext): any => {
  return {
    ...(input.Scale != null && { Scale: input.Scale }),
    ...(input.UnscaledValue != null && { UnscaledValue: context.base64Encoder(input.UnscaledValue) }),
  };
};

/**
 * serializeAws_json1_1DeleteBlueprintRequest
 */
const se_DeleteBlueprintRequest = (input: DeleteBlueprintRequest, context: __SerdeContext): any => {
  return {
    ...(input.Name != null && { Name: input.Name }),
  };
};

/**
 * serializeAws_json1_1DeleteClassifierRequest
 */
const se_DeleteClassifierRequest = (input: DeleteClassifierRequest, context: __SerdeContext): any => {
  return {
    ...(input.Name != null && { Name: input.Name }),
  };
};

/**
 * serializeAws_json1_1DeleteColumnStatisticsForPartitionRequest
 */
const se_DeleteColumnStatisticsForPartitionRequest = (
  input: DeleteColumnStatisticsForPartitionRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
    ...(input.ColumnName != null && { ColumnName: input.ColumnName }),
    ...(input.DatabaseName != null && { DatabaseName: input.DatabaseName }),
    ...(input.PartitionValues != null && { PartitionValues: se_ValueStringList(input.PartitionValues, context) }),
    ...(input.TableName != null && { TableName: input.TableName }),
  };
};

/**
 * serializeAws_json1_1DeleteColumnStatisticsForTableRequest
 */
const se_DeleteColumnStatisticsForTableRequest = (
  input: DeleteColumnStatisticsForTableRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
    ...(input.ColumnName != null && { ColumnName: input.ColumnName }),
    ...(input.DatabaseName != null && { DatabaseName: input.DatabaseName }),
    ...(input.TableName != null && { TableName: input.TableName }),
  };
};

/**
 * serializeAws_json1_1DeleteConnectionNameList
 */
const se_DeleteConnectionNameList = (input: string[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      return entry;
    });
};

/**
 * serializeAws_json1_1DeleteConnectionRequest
 */
const se_DeleteConnectionRequest = (input: DeleteConnectionRequest, context: __SerdeContext): any => {
  return {
    ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
    ...(input.ConnectionName != null && { ConnectionName: input.ConnectionName }),
  };
};

/**
 * serializeAws_json1_1DeleteCrawlerRequest
 */
const se_DeleteCrawlerRequest = (input: DeleteCrawlerRequest, context: __SerdeContext): any => {
  return {
    ...(input.Name != null && { Name: input.Name }),
  };
};

/**
 * serializeAws_json1_1DeleteCustomEntityTypeRequest
 */
const se_DeleteCustomEntityTypeRequest = (input: DeleteCustomEntityTypeRequest, context: __SerdeContext): any => {
  return {
    ...(input.Name != null && { Name: input.Name }),
  };
};

/**
 * serializeAws_json1_1DeleteDatabaseRequest
 */
const se_DeleteDatabaseRequest = (input: DeleteDatabaseRequest, context: __SerdeContext): any => {
  return {
    ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
    ...(input.Name != null && { Name: input.Name }),
  };
};

/**
 * serializeAws_json1_1DeleteDataQualityRulesetRequest
 */
const se_DeleteDataQualityRulesetRequest = (input: DeleteDataQualityRulesetRequest, context: __SerdeContext): any => {
  return {
    ...(input.Name != null && { Name: input.Name }),
  };
};

/**
 * serializeAws_json1_1DeleteDevEndpointRequest
 */
const se_DeleteDevEndpointRequest = (input: DeleteDevEndpointRequest, context: __SerdeContext): any => {
  return {
    ...(input.EndpointName != null && { EndpointName: input.EndpointName }),
  };
};

/**
 * serializeAws_json1_1DeleteJobRequest
 */
const se_DeleteJobRequest = (input: DeleteJobRequest, context: __SerdeContext): any => {
  return {
    ...(input.JobName != null && { JobName: input.JobName }),
  };
};

/**
 * serializeAws_json1_1DeleteMLTransformRequest
 */
const se_DeleteMLTransformRequest = (input: DeleteMLTransformRequest, context: __SerdeContext): any => {
  return {
    ...(input.TransformId != null && { TransformId: input.TransformId }),
  };
};

/**
 * serializeAws_json1_1DeletePartitionIndexRequest
 */
const se_DeletePartitionIndexRequest = (input: DeletePartitionIndexRequest, context: __SerdeContext): any => {
  return {
    ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
    ...(input.DatabaseName != null && { DatabaseName: input.DatabaseName }),
    ...(input.IndexName != null && { IndexName: input.IndexName }),
    ...(input.TableName != null && { TableName: input.TableName }),
  };
};

/**
 * serializeAws_json1_1DeletePartitionRequest
 */
const se_DeletePartitionRequest = (input: DeletePartitionRequest, context: __SerdeContext): any => {
  return {
    ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
    ...(input.DatabaseName != null && { DatabaseName: input.DatabaseName }),
    ...(input.PartitionValues != null && { PartitionValues: se_ValueStringList(input.PartitionValues, context) }),
    ...(input.TableName != null && { TableName: input.TableName }),
  };
};

/**
 * serializeAws_json1_1DeleteRegistryInput
 */
const se_DeleteRegistryInput = (input: DeleteRegistryInput, context: __SerdeContext): any => {
  return {
    ...(input.RegistryId != null && { RegistryId: se_RegistryId(input.RegistryId, context) }),
  };
};

/**
 * serializeAws_json1_1DeleteResourcePolicyRequest
 */
const se_DeleteResourcePolicyRequest = (input: DeleteResourcePolicyRequest, context: __SerdeContext): any => {
  return {
    ...(input.PolicyHashCondition != null && { PolicyHashCondition: input.PolicyHashCondition }),
    ...(input.ResourceArn != null && { ResourceArn: input.ResourceArn }),
  };
};

/**
 * serializeAws_json1_1DeleteSchemaInput
 */
const se_DeleteSchemaInput = (input: DeleteSchemaInput, context: __SerdeContext): any => {
  return {
    ...(input.SchemaId != null && { SchemaId: se_SchemaId(input.SchemaId, context) }),
  };
};

/**
 * serializeAws_json1_1DeleteSchemaVersionsInput
 */
const se_DeleteSchemaVersionsInput = (input: DeleteSchemaVersionsInput, context: __SerdeContext): any => {
  return {
    ...(input.SchemaId != null && { SchemaId: se_SchemaId(input.SchemaId, context) }),
    ...(input.Versions != null && { Versions: input.Versions }),
  };
};

/**
 * serializeAws_json1_1DeleteSecurityConfigurationRequest
 */
const se_DeleteSecurityConfigurationRequest = (
  input: DeleteSecurityConfigurationRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.Name != null && { Name: input.Name }),
  };
};

/**
 * serializeAws_json1_1DeleteSessionRequest
 */
const se_DeleteSessionRequest = (input: DeleteSessionRequest, context: __SerdeContext): any => {
  return {
    ...(input.Id != null && { Id: input.Id }),
    ...(input.RequestOrigin != null && { RequestOrigin: input.RequestOrigin }),
  };
};

/**
 * serializeAws_json1_1DeleteTableRequest
 */
const se_DeleteTableRequest = (input: DeleteTableRequest, context: __SerdeContext): any => {
  return {
    ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
    ...(input.DatabaseName != null && { DatabaseName: input.DatabaseName }),
    ...(input.Name != null && { Name: input.Name }),
    ...(input.TransactionId != null && { TransactionId: input.TransactionId }),
  };
};

/**
 * serializeAws_json1_1DeleteTableVersionRequest
 */
const se_DeleteTableVersionRequest = (input: DeleteTableVersionRequest, context: __SerdeContext): any => {
  return {
    ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
    ...(input.DatabaseName != null && { DatabaseName: input.DatabaseName }),
    ...(input.TableName != null && { TableName: input.TableName }),
    ...(input.VersionId != null && { VersionId: input.VersionId }),
  };
};

/**
 * serializeAws_json1_1DeleteTriggerRequest
 */
const se_DeleteTriggerRequest = (input: DeleteTriggerRequest, context: __SerdeContext): any => {
  return {
    ...(input.Name != null && { Name: input.Name }),
  };
};

/**
 * serializeAws_json1_1DeleteUserDefinedFunctionRequest
 */
const se_DeleteUserDefinedFunctionRequest = (input: DeleteUserDefinedFunctionRequest, context: __SerdeContext): any => {
  return {
    ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
    ...(input.DatabaseName != null && { DatabaseName: input.DatabaseName }),
    ...(input.FunctionName != null && { FunctionName: input.FunctionName }),
  };
};

/**
 * serializeAws_json1_1DeleteWorkflowRequest
 */
const se_DeleteWorkflowRequest = (input: DeleteWorkflowRequest, context: __SerdeContext): any => {
  return {
    ...(input.Name != null && { Name: input.Name }),
  };
};

/**
 * serializeAws_json1_1DeltaTarget
 */
const se_DeltaTarget = (input: DeltaTarget, context: __SerdeContext): any => {
  return {
    ...(input.ConnectionName != null && { ConnectionName: input.ConnectionName }),
    ...(input.CreateNativeDeltaTable != null && { CreateNativeDeltaTable: input.CreateNativeDeltaTable }),
    ...(input.DeltaTables != null && { DeltaTables: se_PathList(input.DeltaTables, context) }),
    ...(input.WriteManifest != null && { WriteManifest: input.WriteManifest }),
  };
};

/**
 * serializeAws_json1_1DeltaTargetList
 */
const se_DeltaTargetList = (input: DeltaTarget[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      return se_DeltaTarget(entry, context);
    });
};

/**
 * serializeAws_json1_1DevEndpointCustomLibraries
 */
const se_DevEndpointCustomLibraries = (input: DevEndpointCustomLibraries, context: __SerdeContext): any => {
  return {
    ...(input.ExtraJarsS3Path != null && { ExtraJarsS3Path: input.ExtraJarsS3Path }),
    ...(input.ExtraPythonLibsS3Path != null && { ExtraPythonLibsS3Path: input.ExtraPythonLibsS3Path }),
  };
};

/**
 * serializeAws_json1_1DevEndpointNames
 */
const se_DevEndpointNames = (input: string[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      return entry;
    });
};

/**
 * serializeAws_json1_1DirectJDBCSource
 */
const se_DirectJDBCSource = (input: DirectJDBCSource, context: __SerdeContext): any => {
  return {
    ...(input.ConnectionName != null && { ConnectionName: input.ConnectionName }),
    ...(input.ConnectionType != null && { ConnectionType: input.ConnectionType }),
    ...(input.Database != null && { Database: input.Database }),
    ...(input.Name != null && { Name: input.Name }),
    ...(input.RedshiftTmpDir != null && { RedshiftTmpDir: input.RedshiftTmpDir }),
    ...(input.Table != null && { Table: input.Table }),
  };
};

/**
 * serializeAws_json1_1DirectKafkaSource
 */
const se_DirectKafkaSource = (input: DirectKafkaSource, context: __SerdeContext): any => {
  return {
    ...(input.DataPreviewOptions != null && {
      DataPreviewOptions: se_StreamingDataPreviewOptions(input.DataPreviewOptions, context),
    }),
    ...(input.DetectSchema != null && { DetectSchema: input.DetectSchema }),
    ...(input.Name != null && { Name: input.Name }),
    ...(input.StreamingOptions != null && {
      StreamingOptions: se_KafkaStreamingSourceOptions(input.StreamingOptions, context),
    }),
    ...(input.WindowSize != null && { WindowSize: input.WindowSize }),
  };
};

/**
 * serializeAws_json1_1DirectKinesisSource
 */
const se_DirectKinesisSource = (input: DirectKinesisSource, context: __SerdeContext): any => {
  return {
    ...(input.DataPreviewOptions != null && {
      DataPreviewOptions: se_StreamingDataPreviewOptions(input.DataPreviewOptions, context),
    }),
    ...(input.DetectSchema != null && { DetectSchema: input.DetectSchema }),
    ...(input.Name != null && { Name: input.Name }),
    ...(input.StreamingOptions != null && {
      StreamingOptions: se_KinesisStreamingSourceOptions(input.StreamingOptions, context),
    }),
    ...(input.WindowSize != null && { WindowSize: input.WindowSize }),
  };
};

/**
 * serializeAws_json1_1DirectSchemaChangePolicy
 */
const se_DirectSchemaChangePolicy = (input: DirectSchemaChangePolicy, context: __SerdeContext): any => {
  return {
    ...(input.Database != null && { Database: input.Database }),
    ...(input.EnableUpdateCatalog != null && { EnableUpdateCatalog: input.EnableUpdateCatalog }),
    ...(input.Table != null && { Table: input.Table }),
    ...(input.UpdateBehavior != null && { UpdateBehavior: input.UpdateBehavior }),
  };
};

/**
 * serializeAws_json1_1DoubleColumnStatisticsData
 */
const se_DoubleColumnStatisticsData = (input: DoubleColumnStatisticsData, context: __SerdeContext): any => {
  return {
    ...(input.MaximumValue != null && { MaximumValue: __serializeFloat(input.MaximumValue) }),
    ...(input.MinimumValue != null && { MinimumValue: __serializeFloat(input.MinimumValue) }),
    ...(input.NumberOfDistinctValues != null && { NumberOfDistinctValues: input.NumberOfDistinctValues }),
    ...(input.NumberOfNulls != null && { NumberOfNulls: input.NumberOfNulls }),
  };
};

/**
 * serializeAws_json1_1DQResultsPublishingOptions
 */
const se_DQResultsPublishingOptions = (input: DQResultsPublishingOptions, context: __SerdeContext): any => {
  return {
    ...(input.CloudWatchMetricsEnabled != null && { CloudWatchMetricsEnabled: input.CloudWatchMetricsEnabled }),
    ...(input.EvaluationContext != null && { EvaluationContext: input.EvaluationContext }),
    ...(input.ResultsPublishingEnabled != null && { ResultsPublishingEnabled: input.ResultsPublishingEnabled }),
    ...(input.ResultsS3Prefix != null && { ResultsS3Prefix: input.ResultsS3Prefix }),
  };
};

/**
 * serializeAws_json1_1DQStopJobOnFailureOptions
 */
const se_DQStopJobOnFailureOptions = (input: DQStopJobOnFailureOptions, context: __SerdeContext): any => {
  return {
    ...(input.StopJobOnFailureTiming != null && { StopJobOnFailureTiming: input.StopJobOnFailureTiming }),
  };
};

/**
 * serializeAws_json1_1DropDuplicates
 */
const se_DropDuplicates = (input: DropDuplicates, context: __SerdeContext): any => {
  return {
    ...(input.Columns != null && { Columns: se_LimitedPathList(input.Columns, context) }),
    ...(input.Inputs != null && { Inputs: se_OneInput(input.Inputs, context) }),
    ...(input.Name != null && { Name: input.Name }),
  };
};

/**
 * serializeAws_json1_1DropFields
 */
const se_DropFields = (input: DropFields, context: __SerdeContext): any => {
  return {
    ...(input.Inputs != null && { Inputs: se_OneInput(input.Inputs, context) }),
    ...(input.Name != null && { Name: input.Name }),
    ...(input.Paths != null && { Paths: se_GlueStudioPathList(input.Paths, context) }),
  };
};

/**
 * serializeAws_json1_1DropNullFields
 */
const se_DropNullFields = (input: DropNullFields, context: __SerdeContext): any => {
  return {
    ...(input.Inputs != null && { Inputs: se_OneInput(input.Inputs, context) }),
    ...(input.Name != null && { Name: input.Name }),
    ...(input.NullCheckBoxList != null && { NullCheckBoxList: se_NullCheckBoxList(input.NullCheckBoxList, context) }),
    ...(input.NullTextList != null && { NullTextList: se_NullValueFields(input.NullTextList, context) }),
  };
};

/**
 * serializeAws_json1_1DynamicTransform
 */
const se_DynamicTransform = (input: DynamicTransform, context: __SerdeContext): any => {
  return {
    ...(input.FunctionName != null && { FunctionName: input.FunctionName }),
    ...(input.Inputs != null && { Inputs: se_OneInput(input.Inputs, context) }),
    ...(input.Name != null && { Name: input.Name }),
    ...(input.Parameters != null && { Parameters: se_TransformConfigParameterList(input.Parameters, context) }),
    ...(input.Path != null && { Path: input.Path }),
    ...(input.TransformName != null && { TransformName: input.TransformName }),
    ...(input.Version != null && { Version: input.Version }),
  };
};

/**
 * serializeAws_json1_1DynamoDBCatalogSource
 */
const se_DynamoDBCatalogSource = (input: DynamoDBCatalogSource, context: __SerdeContext): any => {
  return {
    ...(input.Database != null && { Database: input.Database }),
    ...(input.Name != null && { Name: input.Name }),
    ...(input.Table != null && { Table: input.Table }),
  };
};

/**
 * serializeAws_json1_1DynamoDBTarget
 */
const se_DynamoDBTarget = (input: DynamoDBTarget, context: __SerdeContext): any => {
  return {
    ...(input.Path != null && { Path: input.Path }),
    ...(input.scanAll != null && { scanAll: input.scanAll }),
    ...(input.scanRate != null && { scanRate: __serializeFloat(input.scanRate) }),
  };
};

/**
 * serializeAws_json1_1DynamoDBTargetList
 */
const se_DynamoDBTargetList = (input: DynamoDBTarget[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      return se_DynamoDBTarget(entry, context);
    });
};

/**
 * serializeAws_json1_1EnableAdditionalMetadata
 */
const se_EnableAdditionalMetadata = (input: (JdbcMetadataEntry | string)[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      return entry;
    });
};

/**
 * serializeAws_json1_1EnclosedInStringProperties
 */
const se_EnclosedInStringProperties = (input: string[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      return entry;
    });
};

/**
 * serializeAws_json1_1EnclosedInStringPropertiesMinOne
 */
const se_EnclosedInStringPropertiesMinOne = (input: string[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      return entry;
    });
};

/**
 * serializeAws_json1_1EncryptionAtRest
 */
const se_EncryptionAtRest = (input: EncryptionAtRest, context: __SerdeContext): any => {
  return {
    ...(input.CatalogEncryptionMode != null && { CatalogEncryptionMode: input.CatalogEncryptionMode }),
    ...(input.SseAwsKmsKeyId != null && { SseAwsKmsKeyId: input.SseAwsKmsKeyId }),
  };
};

/**
 * serializeAws_json1_1EncryptionConfiguration
 */
const se_EncryptionConfiguration = (input: EncryptionConfiguration, context: __SerdeContext): any => {
  return {
    ...(input.CloudWatchEncryption != null && {
      CloudWatchEncryption: se_CloudWatchEncryption(input.CloudWatchEncryption, context),
    }),
    ...(input.JobBookmarksEncryption != null && {
      JobBookmarksEncryption: se_JobBookmarksEncryption(input.JobBookmarksEncryption, context),
    }),
    ...(input.S3Encryption != null && { S3Encryption: se_S3EncryptionList(input.S3Encryption, context) }),
  };
};

/**
 * serializeAws_json1_1EvaluateDataQuality
 */
const se_EvaluateDataQuality = (input: EvaluateDataQuality, context: __SerdeContext): any => {
  return {
    ...(input.Inputs != null && { Inputs: se_OneInput(input.Inputs, context) }),
    ...(input.Name != null && { Name: input.Name }),
    ...(input.Output != null && { Output: input.Output }),
    ...(input.PublishingOptions != null && {
      PublishingOptions: se_DQResultsPublishingOptions(input.PublishingOptions, context),
    }),
    ...(input.Ruleset != null && { Ruleset: input.Ruleset }),
    ...(input.StopJobOnFailureOptions != null && {
      StopJobOnFailureOptions: se_DQStopJobOnFailureOptions(input.StopJobOnFailureOptions, context),
    }),
  };
};

/**
 * serializeAws_json1_1EventBatchingCondition
 */
const se_EventBatchingCondition = (input: EventBatchingCondition, context: __SerdeContext): any => {
  return {
    ...(input.BatchSize != null && { BatchSize: input.BatchSize }),
    ...(input.BatchWindow != null && { BatchWindow: input.BatchWindow }),
  };
};

/**
 * serializeAws_json1_1ExecutionProperty
 */
const se_ExecutionProperty = (input: ExecutionProperty, context: __SerdeContext): any => {
  return {
    ...(input.MaxConcurrentRuns != null && { MaxConcurrentRuns: input.MaxConcurrentRuns }),
  };
};

/**
 * serializeAws_json1_1FederatedDatabase
 */
const se_FederatedDatabase = (input: FederatedDatabase, context: __SerdeContext): any => {
  return {
    ...(input.ConnectionName != null && { ConnectionName: input.ConnectionName }),
    ...(input.Identifier != null && { Identifier: input.Identifier }),
  };
};

/**
 * serializeAws_json1_1FillMissingValues
 */
const se_FillMissingValues = (input: FillMissingValues, context: __SerdeContext): any => {
  return {
    ...(input.FilledPath != null && { FilledPath: input.FilledPath }),
    ...(input.ImputedPath != null && { ImputedPath: input.ImputedPath }),
    ...(input.Inputs != null && { Inputs: se_OneInput(input.Inputs, context) }),
    ...(input.Name != null && { Name: input.Name }),
  };
};

/**
 * serializeAws_json1_1Filter
 */
const se_Filter = (input: Filter, context: __SerdeContext): any => {
  return {
    ...(input.Filters != null && { Filters: se_FilterExpressions(input.Filters, context) }),
    ...(input.Inputs != null && { Inputs: se_OneInput(input.Inputs, context) }),
    ...(input.LogicalOperator != null && { LogicalOperator: input.LogicalOperator }),
    ...(input.Name != null && { Name: input.Name }),
  };
};

/**
 * serializeAws_json1_1FilterExpression
 */
const se_FilterExpression = (input: FilterExpression, context: __SerdeContext): any => {
  return {
    ...(input.Negated != null && { Negated: input.Negated }),
    ...(input.Operation != null && { Operation: input.Operation }),
    ...(input.Values != null && { Values: se_FilterValues(input.Values, context) }),
  };
};

/**
 * serializeAws_json1_1FilterExpressions
 */
const se_FilterExpressions = (input: FilterExpression[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      return se_FilterExpression(entry, context);
    });
};

/**
 * serializeAws_json1_1FilterValue
 */
const se_FilterValue = (input: FilterValue, context: __SerdeContext): any => {
  return {
    ...(input.Type != null && { Type: input.Type }),
    ...(input.Value != null && { Value: se_EnclosedInStringProperties(input.Value, context) }),
  };
};

/**
 * serializeAws_json1_1FilterValues
 */
const se_FilterValues = (input: FilterValue[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      return se_FilterValue(entry, context);
    });
};

/**
 * serializeAws_json1_1FindMatchesParameters
 */
const se_FindMatchesParameters = (input: FindMatchesParameters, context: __SerdeContext): any => {
  return {
    ...(input.AccuracyCostTradeoff != null && { AccuracyCostTradeoff: __serializeFloat(input.AccuracyCostTradeoff) }),
    ...(input.EnforceProvidedLabels != null && { EnforceProvidedLabels: input.EnforceProvidedLabels }),
    ...(input.PrecisionRecallTradeoff != null && {
      PrecisionRecallTradeoff: __serializeFloat(input.PrecisionRecallTradeoff),
    }),
    ...(input.PrimaryKeyColumnName != null && { PrimaryKeyColumnName: input.PrimaryKeyColumnName }),
  };
};

/**
 * serializeAws_json1_1GenericMap
 */
const se_GenericMap = (input: Record<string, string>, context: __SerdeContext): any => {
  return Object.entries(input).reduce((acc: Record<string, any>, [key, value]: [string, any]) => {
    if (value === null) {
      return acc;
    }
    acc[key] = value;
    return acc;
  }, {});
};

/**
 * serializeAws_json1_1GetBlueprintRequest
 */
const se_GetBlueprintRequest = (input: GetBlueprintRequest, context: __SerdeContext): any => {
  return {
    ...(input.IncludeBlueprint != null && { IncludeBlueprint: input.IncludeBlueprint }),
    ...(input.IncludeParameterSpec != null && { IncludeParameterSpec: input.IncludeParameterSpec }),
    ...(input.Name != null && { Name: input.Name }),
  };
};

/**
 * serializeAws_json1_1GetBlueprintRunRequest
 */
const se_GetBlueprintRunRequest = (input: GetBlueprintRunRequest, context: __SerdeContext): any => {
  return {
    ...(input.BlueprintName != null && { BlueprintName: input.BlueprintName }),
    ...(input.RunId != null && { RunId: input.RunId }),
  };
};

/**
 * serializeAws_json1_1GetBlueprintRunsRequest
 */
const se_GetBlueprintRunsRequest = (input: GetBlueprintRunsRequest, context: __SerdeContext): any => {
  return {
    ...(input.BlueprintName != null && { BlueprintName: input.BlueprintName }),
    ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
    ...(input.NextToken != null && { NextToken: input.NextToken }),
  };
};

/**
 * serializeAws_json1_1GetCatalogImportStatusRequest
 */
const se_GetCatalogImportStatusRequest = (input: GetCatalogImportStatusRequest, context: __SerdeContext): any => {
  return {
    ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
  };
};

/**
 * serializeAws_json1_1GetClassifierRequest
 */
const se_GetClassifierRequest = (input: GetClassifierRequest, context: __SerdeContext): any => {
  return {
    ...(input.Name != null && { Name: input.Name }),
  };
};

/**
 * serializeAws_json1_1GetClassifiersRequest
 */
const se_GetClassifiersRequest = (input: GetClassifiersRequest, context: __SerdeContext): any => {
  return {
    ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
    ...(input.NextToken != null && { NextToken: input.NextToken }),
  };
};

/**
 * serializeAws_json1_1GetColumnNamesList
 */
const se_GetColumnNamesList = (input: string[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      return entry;
    });
};

/**
 * serializeAws_json1_1GetColumnStatisticsForPartitionRequest
 */
const se_GetColumnStatisticsForPartitionRequest = (
  input: GetColumnStatisticsForPartitionRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
    ...(input.ColumnNames != null && { ColumnNames: se_GetColumnNamesList(input.ColumnNames, context) }),
    ...(input.DatabaseName != null && { DatabaseName: input.DatabaseName }),
    ...(input.PartitionValues != null && { PartitionValues: se_ValueStringList(input.PartitionValues, context) }),
    ...(input.TableName != null && { TableName: input.TableName }),
  };
};

/**
 * serializeAws_json1_1GetColumnStatisticsForTableRequest
 */
const se_GetColumnStatisticsForTableRequest = (
  input: GetColumnStatisticsForTableRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
    ...(input.ColumnNames != null && { ColumnNames: se_GetColumnNamesList(input.ColumnNames, context) }),
    ...(input.DatabaseName != null && { DatabaseName: input.DatabaseName }),
    ...(input.TableName != null && { TableName: input.TableName }),
  };
};

/**
 * serializeAws_json1_1GetConnectionRequest
 */
const se_GetConnectionRequest = (input: GetConnectionRequest, context: __SerdeContext): any => {
  return {
    ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
    ...(input.HidePassword != null && { HidePassword: input.HidePassword }),
    ...(input.Name != null && { Name: input.Name }),
  };
};

/**
 * serializeAws_json1_1GetConnectionsFilter
 */
const se_GetConnectionsFilter = (input: GetConnectionsFilter, context: __SerdeContext): any => {
  return {
    ...(input.ConnectionType != null && { ConnectionType: input.ConnectionType }),
    ...(input.MatchCriteria != null && { MatchCriteria: se_MatchCriteria(input.MatchCriteria, context) }),
  };
};

/**
 * serializeAws_json1_1GetConnectionsRequest
 */
const se_GetConnectionsRequest = (input: GetConnectionsRequest, context: __SerdeContext): any => {
  return {
    ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
    ...(input.Filter != null && { Filter: se_GetConnectionsFilter(input.Filter, context) }),
    ...(input.HidePassword != null && { HidePassword: input.HidePassword }),
    ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
    ...(input.NextToken != null && { NextToken: input.NextToken }),
  };
};

/**
 * serializeAws_json1_1GetCrawlerMetricsRequest
 */
const se_GetCrawlerMetricsRequest = (input: GetCrawlerMetricsRequest, context: __SerdeContext): any => {
  return {
    ...(input.CrawlerNameList != null && { CrawlerNameList: se_CrawlerNameList(input.CrawlerNameList, context) }),
    ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
    ...(input.NextToken != null && { NextToken: input.NextToken }),
  };
};

/**
 * serializeAws_json1_1GetCrawlerRequest
 */
const se_GetCrawlerRequest = (input: GetCrawlerRequest, context: __SerdeContext): any => {
  return {
    ...(input.Name != null && { Name: input.Name }),
  };
};

/**
 * serializeAws_json1_1GetCrawlersRequest
 */
const se_GetCrawlersRequest = (input: GetCrawlersRequest, context: __SerdeContext): any => {
  return {
    ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
    ...(input.NextToken != null && { NextToken: input.NextToken }),
  };
};

/**
 * serializeAws_json1_1GetCustomEntityTypeRequest
 */
const se_GetCustomEntityTypeRequest = (input: GetCustomEntityTypeRequest, context: __SerdeContext): any => {
  return {
    ...(input.Name != null && { Name: input.Name }),
  };
};

/**
 * serializeAws_json1_1GetDatabaseRequest
 */
const se_GetDatabaseRequest = (input: GetDatabaseRequest, context: __SerdeContext): any => {
  return {
    ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
    ...(input.Name != null && { Name: input.Name }),
  };
};

/**
 * serializeAws_json1_1GetDatabasesRequest
 */
const se_GetDatabasesRequest = (input: GetDatabasesRequest, context: __SerdeContext): any => {
  return {
    ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
    ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
    ...(input.NextToken != null && { NextToken: input.NextToken }),
    ...(input.ResourceShareType != null && { ResourceShareType: input.ResourceShareType }),
  };
};

/**
 * serializeAws_json1_1GetDataCatalogEncryptionSettingsRequest
 */
const se_GetDataCatalogEncryptionSettingsRequest = (
  input: GetDataCatalogEncryptionSettingsRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
  };
};

/**
 * serializeAws_json1_1GetDataflowGraphRequest
 */
const se_GetDataflowGraphRequest = (input: GetDataflowGraphRequest, context: __SerdeContext): any => {
  return {
    ...(input.PythonScript != null && { PythonScript: input.PythonScript }),
  };
};

/**
 * serializeAws_json1_1GetDataQualityResultRequest
 */
const se_GetDataQualityResultRequest = (input: GetDataQualityResultRequest, context: __SerdeContext): any => {
  return {
    ...(input.ResultId != null && { ResultId: input.ResultId }),
  };
};

/**
 * serializeAws_json1_1GetDataQualityRuleRecommendationRunRequest
 */
const se_GetDataQualityRuleRecommendationRunRequest = (
  input: GetDataQualityRuleRecommendationRunRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.RunId != null && { RunId: input.RunId }),
  };
};

/**
 * serializeAws_json1_1GetDataQualityRulesetEvaluationRunRequest
 */
const se_GetDataQualityRulesetEvaluationRunRequest = (
  input: GetDataQualityRulesetEvaluationRunRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.RunId != null && { RunId: input.RunId }),
  };
};

/**
 * serializeAws_json1_1GetDataQualityRulesetRequest
 */
const se_GetDataQualityRulesetRequest = (input: GetDataQualityRulesetRequest, context: __SerdeContext): any => {
  return {
    ...(input.Name != null && { Name: input.Name }),
  };
};

/**
 * serializeAws_json1_1GetDevEndpointRequest
 */
const se_GetDevEndpointRequest = (input: GetDevEndpointRequest, context: __SerdeContext): any => {
  return {
    ...(input.EndpointName != null && { EndpointName: input.EndpointName }),
  };
};

/**
 * serializeAws_json1_1GetDevEndpointsRequest
 */
const se_GetDevEndpointsRequest = (input: GetDevEndpointsRequest, context: __SerdeContext): any => {
  return {
    ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
    ...(input.NextToken != null && { NextToken: input.NextToken }),
  };
};

/**
 * serializeAws_json1_1GetJobBookmarkRequest
 */
const se_GetJobBookmarkRequest = (input: GetJobBookmarkRequest, context: __SerdeContext): any => {
  return {
    ...(input.JobName != null && { JobName: input.JobName }),
    ...(input.RunId != null && { RunId: input.RunId }),
  };
};

/**
 * serializeAws_json1_1GetJobRequest
 */
const se_GetJobRequest = (input: GetJobRequest, context: __SerdeContext): any => {
  return {
    ...(input.JobName != null && { JobName: input.JobName }),
  };
};

/**
 * serializeAws_json1_1GetJobRunRequest
 */
const se_GetJobRunRequest = (input: GetJobRunRequest, context: __SerdeContext): any => {
  return {
    ...(input.JobName != null && { JobName: input.JobName }),
    ...(input.PredecessorsIncluded != null && { PredecessorsIncluded: input.PredecessorsIncluded }),
    ...(input.RunId != null && { RunId: input.RunId }),
  };
};

/**
 * serializeAws_json1_1GetJobRunsRequest
 */
const se_GetJobRunsRequest = (input: GetJobRunsRequest, context: __SerdeContext): any => {
  return {
    ...(input.JobName != null && { JobName: input.JobName }),
    ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
    ...(input.NextToken != null && { NextToken: input.NextToken }),
  };
};

/**
 * serializeAws_json1_1GetJobsRequest
 */
const se_GetJobsRequest = (input: GetJobsRequest, context: __SerdeContext): any => {
  return {
    ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
    ...(input.NextToken != null && { NextToken: input.NextToken }),
  };
};

/**
 * serializeAws_json1_1GetMappingRequest
 */
const se_GetMappingRequest = (input: GetMappingRequest, context: __SerdeContext): any => {
  return {
    ...(input.Location != null && { Location: se_Location(input.Location, context) }),
    ...(input.Sinks != null && { Sinks: se_CatalogEntries(input.Sinks, context) }),
    ...(input.Source != null && { Source: se_CatalogEntry(input.Source, context) }),
  };
};

/**
 * serializeAws_json1_1GetMLTaskRunRequest
 */
const se_GetMLTaskRunRequest = (input: GetMLTaskRunRequest, context: __SerdeContext): any => {
  return {
    ...(input.TaskRunId != null && { TaskRunId: input.TaskRunId }),
    ...(input.TransformId != null && { TransformId: input.TransformId }),
  };
};

/**
 * serializeAws_json1_1GetMLTaskRunsRequest
 */
const se_GetMLTaskRunsRequest = (input: GetMLTaskRunsRequest, context: __SerdeContext): any => {
  return {
    ...(input.Filter != null && { Filter: se_TaskRunFilterCriteria(input.Filter, context) }),
    ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
    ...(input.NextToken != null && { NextToken: input.NextToken }),
    ...(input.Sort != null && { Sort: se_TaskRunSortCriteria(input.Sort, context) }),
    ...(input.TransformId != null && { TransformId: input.TransformId }),
  };
};

/**
 * serializeAws_json1_1GetMLTransformRequest
 */
const se_GetMLTransformRequest = (input: GetMLTransformRequest, context: __SerdeContext): any => {
  return {
    ...(input.TransformId != null && { TransformId: input.TransformId }),
  };
};

/**
 * serializeAws_json1_1GetMLTransformsRequest
 */
const se_GetMLTransformsRequest = (input: GetMLTransformsRequest, context: __SerdeContext): any => {
  return {
    ...(input.Filter != null && { Filter: se_TransformFilterCriteria(input.Filter, context) }),
    ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
    ...(input.NextToken != null && { NextToken: input.NextToken }),
    ...(input.Sort != null && { Sort: se_TransformSortCriteria(input.Sort, context) }),
  };
};

/**
 * serializeAws_json1_1GetPartitionIndexesRequest
 */
const se_GetPartitionIndexesRequest = (input: GetPartitionIndexesRequest, context: __SerdeContext): any => {
  return {
    ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
    ...(input.DatabaseName != null && { DatabaseName: input.DatabaseName }),
    ...(input.NextToken != null && { NextToken: input.NextToken }),
    ...(input.TableName != null && { TableName: input.TableName }),
  };
};

/**
 * serializeAws_json1_1GetPartitionRequest
 */
const se_GetPartitionRequest = (input: GetPartitionRequest, context: __SerdeContext): any => {
  return {
    ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
    ...(input.DatabaseName != null && { DatabaseName: input.DatabaseName }),
    ...(input.PartitionValues != null && { PartitionValues: se_ValueStringList(input.PartitionValues, context) }),
    ...(input.TableName != null && { TableName: input.TableName }),
  };
};

/**
 * serializeAws_json1_1GetPartitionsRequest
 */
const se_GetPartitionsRequest = (input: GetPartitionsRequest, context: __SerdeContext): any => {
  return {
    ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
    ...(input.DatabaseName != null && { DatabaseName: input.DatabaseName }),
    ...(input.ExcludeColumnSchema != null && { ExcludeColumnSchema: input.ExcludeColumnSchema }),
    ...(input.Expression != null && { Expression: input.Expression }),
    ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
    ...(input.NextToken != null && { NextToken: input.NextToken }),
    ...(input.QueryAsOfTime != null && { QueryAsOfTime: Math.round(input.QueryAsOfTime.getTime() / 1000) }),
    ...(input.Segment != null && { Segment: se_Segment(input.Segment, context) }),
    ...(input.TableName != null && { TableName: input.TableName }),
    ...(input.TransactionId != null && { TransactionId: input.TransactionId }),
  };
};

/**
 * serializeAws_json1_1GetPlanRequest
 */
const se_GetPlanRequest = (input: GetPlanRequest, context: __SerdeContext): any => {
  return {
    ...(input.AdditionalPlanOptionsMap != null && {
      AdditionalPlanOptionsMap: se_AdditionalPlanOptionsMap(input.AdditionalPlanOptionsMap, context),
    }),
    ...(input.Language != null && { Language: input.Language }),
    ...(input.Location != null && { Location: se_Location(input.Location, context) }),
    ...(input.Mapping != null && { Mapping: se_MappingList(input.Mapping, context) }),
    ...(input.Sinks != null && { Sinks: se_CatalogEntries(input.Sinks, context) }),
    ...(input.Source != null && { Source: se_CatalogEntry(input.Source, context) }),
  };
};

/**
 * serializeAws_json1_1GetRegistryInput
 */
const se_GetRegistryInput = (input: GetRegistryInput, context: __SerdeContext): any => {
  return {
    ...(input.RegistryId != null && { RegistryId: se_RegistryId(input.RegistryId, context) }),
  };
};

/**
 * serializeAws_json1_1GetResourcePoliciesRequest
 */
const se_GetResourcePoliciesRequest = (input: GetResourcePoliciesRequest, context: __SerdeContext): any => {
  return {
    ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
    ...(input.NextToken != null && { NextToken: input.NextToken }),
  };
};

/**
 * serializeAws_json1_1GetResourcePolicyRequest
 */
const se_GetResourcePolicyRequest = (input: GetResourcePolicyRequest, context: __SerdeContext): any => {
  return {
    ...(input.ResourceArn != null && { ResourceArn: input.ResourceArn }),
  };
};

/**
 * serializeAws_json1_1GetSchemaByDefinitionInput
 */
const se_GetSchemaByDefinitionInput = (input: GetSchemaByDefinitionInput, context: __SerdeContext): any => {
  return {
    ...(input.SchemaDefinition != null && { SchemaDefinition: input.SchemaDefinition }),
    ...(input.SchemaId != null && { SchemaId: se_SchemaId(input.SchemaId, context) }),
  };
};

/**
 * serializeAws_json1_1GetSchemaInput
 */
const se_GetSchemaInput = (input: GetSchemaInput, context: __SerdeContext): any => {
  return {
    ...(input.SchemaId != null && { SchemaId: se_SchemaId(input.SchemaId, context) }),
  };
};

/**
 * serializeAws_json1_1GetSchemaVersionInput
 */
const se_GetSchemaVersionInput = (input: GetSchemaVersionInput, context: __SerdeContext): any => {
  return {
    ...(input.SchemaId != null && { SchemaId: se_SchemaId(input.SchemaId, context) }),
    ...(input.SchemaVersionId != null && { SchemaVersionId: input.SchemaVersionId }),
    ...(input.SchemaVersionNumber != null && {
      SchemaVersionNumber: se_SchemaVersionNumber(input.SchemaVersionNumber, context),
    }),
  };
};

/**
 * serializeAws_json1_1GetSchemaVersionsDiffInput
 */
const se_GetSchemaVersionsDiffInput = (input: GetSchemaVersionsDiffInput, context: __SerdeContext): any => {
  return {
    ...(input.FirstSchemaVersionNumber != null && {
      FirstSchemaVersionNumber: se_SchemaVersionNumber(input.FirstSchemaVersionNumber, context),
    }),
    ...(input.SchemaDiffType != null && { SchemaDiffType: input.SchemaDiffType }),
    ...(input.SchemaId != null && { SchemaId: se_SchemaId(input.SchemaId, context) }),
    ...(input.SecondSchemaVersionNumber != null && {
      SecondSchemaVersionNumber: se_SchemaVersionNumber(input.SecondSchemaVersionNumber, context),
    }),
  };
};

/**
 * serializeAws_json1_1GetSecurityConfigurationRequest
 */
const se_GetSecurityConfigurationRequest = (input: GetSecurityConfigurationRequest, context: __SerdeContext): any => {
  return {
    ...(input.Name != null && { Name: input.Name }),
  };
};

/**
 * serializeAws_json1_1GetSecurityConfigurationsRequest
 */
const se_GetSecurityConfigurationsRequest = (input: GetSecurityConfigurationsRequest, context: __SerdeContext): any => {
  return {
    ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
    ...(input.NextToken != null && { NextToken: input.NextToken }),
  };
};

/**
 * serializeAws_json1_1GetSessionRequest
 */
const se_GetSessionRequest = (input: GetSessionRequest, context: __SerdeContext): any => {
  return {
    ...(input.Id != null && { Id: input.Id }),
    ...(input.RequestOrigin != null && { RequestOrigin: input.RequestOrigin }),
  };
};

/**
 * serializeAws_json1_1GetStatementRequest
 */
const se_GetStatementRequest = (input: GetStatementRequest, context: __SerdeContext): any => {
  return {
    ...(input.Id != null && { Id: input.Id }),
    ...(input.RequestOrigin != null && { RequestOrigin: input.RequestOrigin }),
    ...(input.SessionId != null && { SessionId: input.SessionId }),
  };
};

/**
 * serializeAws_json1_1GetTableRequest
 */
const se_GetTableRequest = (input: GetTableRequest, context: __SerdeContext): any => {
  return {
    ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
    ...(input.DatabaseName != null && { DatabaseName: input.DatabaseName }),
    ...(input.Name != null && { Name: input.Name }),
    ...(input.QueryAsOfTime != null && { QueryAsOfTime: Math.round(input.QueryAsOfTime.getTime() / 1000) }),
    ...(input.TransactionId != null && { TransactionId: input.TransactionId }),
  };
};

/**
 * serializeAws_json1_1GetTablesRequest
 */
const se_GetTablesRequest = (input: GetTablesRequest, context: __SerdeContext): any => {
  return {
    ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
    ...(input.DatabaseName != null && { DatabaseName: input.DatabaseName }),
    ...(input.Expression != null && { Expression: input.Expression }),
    ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
    ...(input.NextToken != null && { NextToken: input.NextToken }),
    ...(input.QueryAsOfTime != null && { QueryAsOfTime: Math.round(input.QueryAsOfTime.getTime() / 1000) }),
    ...(input.TransactionId != null && { TransactionId: input.TransactionId }),
  };
};

/**
 * serializeAws_json1_1GetTableVersionRequest
 */
const se_GetTableVersionRequest = (input: GetTableVersionRequest, context: __SerdeContext): any => {
  return {
    ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
    ...(input.DatabaseName != null && { DatabaseName: input.DatabaseName }),
    ...(input.TableName != null && { TableName: input.TableName }),
    ...(input.VersionId != null && { VersionId: input.VersionId }),
  };
};

/**
 * serializeAws_json1_1GetTableVersionsRequest
 */
const se_GetTableVersionsRequest = (input: GetTableVersionsRequest, context: __SerdeContext): any => {
  return {
    ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
    ...(input.DatabaseName != null && { DatabaseName: input.DatabaseName }),
    ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
    ...(input.NextToken != null && { NextToken: input.NextToken }),
    ...(input.TableName != null && { TableName: input.TableName }),
  };
};

/**
 * serializeAws_json1_1GetTagsRequest
 */
const se_GetTagsRequest = (input: GetTagsRequest, context: __SerdeContext): any => {
  return {
    ...(input.ResourceArn != null && { ResourceArn: input.ResourceArn }),
  };
};

/**
 * serializeAws_json1_1GetTriggerRequest
 */
const se_GetTriggerRequest = (input: GetTriggerRequest, context: __SerdeContext): any => {
  return {
    ...(input.Name != null && { Name: input.Name }),
  };
};

/**
 * serializeAws_json1_1GetTriggersRequest
 */
const se_GetTriggersRequest = (input: GetTriggersRequest, context: __SerdeContext): any => {
  return {
    ...(input.DependentJobName != null && { DependentJobName: input.DependentJobName }),
    ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
    ...(input.NextToken != null && { NextToken: input.NextToken }),
  };
};

/**
 * serializeAws_json1_1GetUnfilteredPartitionMetadataRequest
 */
const se_GetUnfilteredPartitionMetadataRequest = (
  input: GetUnfilteredPartitionMetadataRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.AuditContext != null && { AuditContext: se_AuditContext(input.AuditContext, context) }),
    ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
    ...(input.DatabaseName != null && { DatabaseName: input.DatabaseName }),
    ...(input.PartitionValues != null && { PartitionValues: se_ValueStringList(input.PartitionValues, context) }),
    ...(input.SupportedPermissionTypes != null && {
      SupportedPermissionTypes: se_PermissionTypeList(input.SupportedPermissionTypes, context),
    }),
    ...(input.TableName != null && { TableName: input.TableName }),
  };
};

/**
 * serializeAws_json1_1GetUnfilteredPartitionsMetadataRequest
 */
const se_GetUnfilteredPartitionsMetadataRequest = (
  input: GetUnfilteredPartitionsMetadataRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.AuditContext != null && { AuditContext: se_AuditContext(input.AuditContext, context) }),
    ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
    ...(input.DatabaseName != null && { DatabaseName: input.DatabaseName }),
    ...(input.Expression != null && { Expression: input.Expression }),
    ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
    ...(input.NextToken != null && { NextToken: input.NextToken }),
    ...(input.Segment != null && { Segment: se_Segment(input.Segment, context) }),
    ...(input.SupportedPermissionTypes != null && {
      SupportedPermissionTypes: se_PermissionTypeList(input.SupportedPermissionTypes, context),
    }),
    ...(input.TableName != null && { TableName: input.TableName }),
  };
};

/**
 * serializeAws_json1_1GetUnfilteredTableMetadataRequest
 */
const se_GetUnfilteredTableMetadataRequest = (
  input: GetUnfilteredTableMetadataRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.AuditContext != null && { AuditContext: se_AuditContext(input.AuditContext, context) }),
    ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
    ...(input.DatabaseName != null && { DatabaseName: input.DatabaseName }),
    ...(input.Name != null && { Name: input.Name }),
    ...(input.SupportedPermissionTypes != null && {
      SupportedPermissionTypes: se_PermissionTypeList(input.SupportedPermissionTypes, context),
    }),
  };
};

/**
 * serializeAws_json1_1GetUserDefinedFunctionRequest
 */
const se_GetUserDefinedFunctionRequest = (input: GetUserDefinedFunctionRequest, context: __SerdeContext): any => {
  return {
    ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
    ...(input.DatabaseName != null && { DatabaseName: input.DatabaseName }),
    ...(input.FunctionName != null && { FunctionName: input.FunctionName }),
  };
};

/**
 * serializeAws_json1_1GetUserDefinedFunctionsRequest
 */
const se_GetUserDefinedFunctionsRequest = (input: GetUserDefinedFunctionsRequest, context: __SerdeContext): any => {
  return {
    ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
    ...(input.DatabaseName != null && { DatabaseName: input.DatabaseName }),
    ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
    ...(input.NextToken != null && { NextToken: input.NextToken }),
    ...(input.Pattern != null && { Pattern: input.Pattern }),
  };
};

/**
 * serializeAws_json1_1GetWorkflowRequest
 */
const se_GetWorkflowRequest = (input: GetWorkflowRequest, context: __SerdeContext): any => {
  return {
    ...(input.IncludeGraph != null && { IncludeGraph: input.IncludeGraph }),
    ...(input.Name != null && { Name: input.Name }),
  };
};

/**
 * serializeAws_json1_1GetWorkflowRunPropertiesRequest
 */
const se_GetWorkflowRunPropertiesRequest = (input: GetWorkflowRunPropertiesRequest, context: __SerdeContext): any => {
  return {
    ...(input.Name != null && { Name: input.Name }),
    ...(input.RunId != null && { RunId: input.RunId }),
  };
};

/**
 * serializeAws_json1_1GetWorkflowRunRequest
 */
const se_GetWorkflowRunRequest = (input: GetWorkflowRunRequest, context: __SerdeContext): any => {
  return {
    ...(input.IncludeGraph != null && { IncludeGraph: input.IncludeGraph }),
    ...(input.Name != null && { Name: input.Name }),
    ...(input.RunId != null && { RunId: input.RunId }),
  };
};

/**
 * serializeAws_json1_1GetWorkflowRunsRequest
 */
const se_GetWorkflowRunsRequest = (input: GetWorkflowRunsRequest, context: __SerdeContext): any => {
  return {
    ...(input.IncludeGraph != null && { IncludeGraph: input.IncludeGraph }),
    ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
    ...(input.Name != null && { Name: input.Name }),
    ...(input.NextToken != null && { NextToken: input.NextToken }),
  };
};

/**
 * serializeAws_json1_1GlueSchema
 */
const se_GlueSchema = (input: GlueSchema, context: __SerdeContext): any => {
  return {
    ...(input.Columns != null && { Columns: se_GlueStudioSchemaColumnList(input.Columns, context) }),
  };
};

/**
 * serializeAws_json1_1GlueSchemas
 */
const se_GlueSchemas = (input: GlueSchema[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      return se_GlueSchema(entry, context);
    });
};

/**
 * serializeAws_json1_1GlueStudioPathList
 */
const se_GlueStudioPathList = (input: string[][], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      return se_EnclosedInStringProperties(entry, context);
    });
};

/**
 * serializeAws_json1_1GlueStudioSchemaColumn
 */
const se_GlueStudioSchemaColumn = (input: GlueStudioSchemaColumn, context: __SerdeContext): any => {
  return {
    ...(input.Name != null && { Name: input.Name }),
    ...(input.Type != null && { Type: input.Type }),
  };
};

/**
 * serializeAws_json1_1GlueStudioSchemaColumnList
 */
const se_GlueStudioSchemaColumnList = (input: GlueStudioSchemaColumn[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      return se_GlueStudioSchemaColumn(entry, context);
    });
};

/**
 * serializeAws_json1_1GlueTable
 */
const se_GlueTable = (input: GlueTable, context: __SerdeContext): any => {
  return {
    ...(input.AdditionalOptions != null && {
      AdditionalOptions: se_GlueTableAdditionalOptions(input.AdditionalOptions, context),
    }),
    ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
    ...(input.ConnectionName != null && { ConnectionName: input.ConnectionName }),
    ...(input.DatabaseName != null && { DatabaseName: input.DatabaseName }),
    ...(input.TableName != null && { TableName: input.TableName }),
  };
};

/**
 * serializeAws_json1_1GlueTableAdditionalOptions
 */
const se_GlueTableAdditionalOptions = (input: Record<string, string>, context: __SerdeContext): any => {
  return Object.entries(input).reduce((acc: Record<string, any>, [key, value]: [string, any]) => {
    if (value === null) {
      return acc;
    }
    acc[key] = value;
    return acc;
  }, {});
};

/**
 * serializeAws_json1_1GlueTables
 */
const se_GlueTables = (input: GlueTable[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      return se_GlueTable(entry, context);
    });
};

/**
 * serializeAws_json1_1GovernedCatalogSource
 */
const se_GovernedCatalogSource = (input: GovernedCatalogSource, context: __SerdeContext): any => {
  return {
    ...(input.AdditionalOptions != null && {
      AdditionalOptions: se_S3SourceAdditionalOptions(input.AdditionalOptions, context),
    }),
    ...(input.Database != null && { Database: input.Database }),
    ...(input.Name != null && { Name: input.Name }),
    ...(input.PartitionPredicate != null && { PartitionPredicate: input.PartitionPredicate }),
    ...(input.Table != null && { Table: input.Table }),
  };
};

/**
 * serializeAws_json1_1GovernedCatalogTarget
 */
const se_GovernedCatalogTarget = (input: GovernedCatalogTarget, context: __SerdeContext): any => {
  return {
    ...(input.Database != null && { Database: input.Database }),
    ...(input.Inputs != null && { Inputs: se_OneInput(input.Inputs, context) }),
    ...(input.Name != null && { Name: input.Name }),
    ...(input.PartitionKeys != null && { PartitionKeys: se_GlueStudioPathList(input.PartitionKeys, context) }),
    ...(input.SchemaChangePolicy != null && {
      SchemaChangePolicy: se_CatalogSchemaChangePolicy(input.SchemaChangePolicy, context),
    }),
    ...(input.Table != null && { Table: input.Table }),
  };
};

/**
 * serializeAws_json1_1ImportCatalogToGlueRequest
 */
const se_ImportCatalogToGlueRequest = (input: ImportCatalogToGlueRequest, context: __SerdeContext): any => {
  return {
    ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
  };
};

/**
 * serializeAws_json1_1JDBCConnectorOptions
 */
const se_JDBCConnectorOptions = (input: JDBCConnectorOptions, context: __SerdeContext): any => {
  return {
    ...(input.DataTypeMapping != null && { DataTypeMapping: se_JDBCDataTypeMapping(input.DataTypeMapping, context) }),
    ...(input.FilterPredicate != null && { FilterPredicate: input.FilterPredicate }),
    ...(input.JobBookmarkKeys != null && {
      JobBookmarkKeys: se_EnclosedInStringProperties(input.JobBookmarkKeys, context),
    }),
    ...(input.JobBookmarkKeysSortOrder != null && { JobBookmarkKeysSortOrder: input.JobBookmarkKeysSortOrder }),
    ...(input.LowerBound != null && { LowerBound: input.LowerBound }),
    ...(input.NumPartitions != null && { NumPartitions: input.NumPartitions }),
    ...(input.PartitionColumn != null && { PartitionColumn: input.PartitionColumn }),
    ...(input.UpperBound != null && { UpperBound: input.UpperBound }),
  };
};

/**
 * serializeAws_json1_1JDBCConnectorSource
 */
const se_JDBCConnectorSource = (input: JDBCConnectorSource, context: __SerdeContext): any => {
  return {
    ...(input.AdditionalOptions != null && {
      AdditionalOptions: se_JDBCConnectorOptions(input.AdditionalOptions, context),
    }),
    ...(input.ConnectionName != null && { ConnectionName: input.ConnectionName }),
    ...(input.ConnectionTable != null && { ConnectionTable: input.ConnectionTable }),
    ...(input.ConnectionType != null && { ConnectionType: input.ConnectionType }),
    ...(input.ConnectorName != null && { ConnectorName: input.ConnectorName }),
    ...(input.Name != null && { Name: input.Name }),
    ...(input.OutputSchemas != null && { OutputSchemas: se_GlueSchemas(input.OutputSchemas, context) }),
    ...(input.Query != null && { Query: input.Query }),
  };
};

/**
 * serializeAws_json1_1JDBCConnectorTarget
 */
const se_JDBCConnectorTarget = (input: JDBCConnectorTarget, context: __SerdeContext): any => {
  return {
    ...(input.AdditionalOptions != null && {
      AdditionalOptions: se_AdditionalOptions(input.AdditionalOptions, context),
    }),
    ...(input.ConnectionName != null && { ConnectionName: input.ConnectionName }),
    ...(input.ConnectionTable != null && { ConnectionTable: input.ConnectionTable }),
    ...(input.ConnectionType != null && { ConnectionType: input.ConnectionType }),
    ...(input.ConnectorName != null && { ConnectorName: input.ConnectorName }),
    ...(input.Inputs != null && { Inputs: se_OneInput(input.Inputs, context) }),
    ...(input.Name != null && { Name: input.Name }),
    ...(input.OutputSchemas != null && { OutputSchemas: se_GlueSchemas(input.OutputSchemas, context) }),
  };
};

/**
 * serializeAws_json1_1JDBCDataTypeMapping
 */
const se_JDBCDataTypeMapping = (input: Record<string, GlueRecordType | string>, context: __SerdeContext): any => {
  return Object.entries(input).reduce((acc: Record<string, any>, [key, value]: [JDBCDataType | string, any]) => {
    if (value === null) {
      return acc;
    }
    acc[key] = value;
    return acc;
  }, {});
};

/**
 * serializeAws_json1_1JdbcTarget
 */
const se_JdbcTarget = (input: JdbcTarget, context: __SerdeContext): any => {
  return {
    ...(input.ConnectionName != null && { ConnectionName: input.ConnectionName }),
    ...(input.EnableAdditionalMetadata != null && {
      EnableAdditionalMetadata: se_EnableAdditionalMetadata(input.EnableAdditionalMetadata, context),
    }),
    ...(input.Exclusions != null && { Exclusions: se_PathList(input.Exclusions, context) }),
    ...(input.Path != null && { Path: input.Path }),
  };
};

/**
 * serializeAws_json1_1JdbcTargetList
 */
const se_JdbcTargetList = (input: JdbcTarget[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      return se_JdbcTarget(entry, context);
    });
};

/**
 * serializeAws_json1_1JobBookmarksEncryption
 */
const se_JobBookmarksEncryption = (input: JobBookmarksEncryption, context: __SerdeContext): any => {
  return {
    ...(input.JobBookmarksEncryptionMode != null && { JobBookmarksEncryptionMode: input.JobBookmarksEncryptionMode }),
    ...(input.KmsKeyArn != null && { KmsKeyArn: input.KmsKeyArn }),
  };
};

/**
 * serializeAws_json1_1JobCommand
 */
const se_JobCommand = (input: JobCommand, context: __SerdeContext): any => {
  return {
    ...(input.Name != null && { Name: input.Name }),
    ...(input.PythonVersion != null && { PythonVersion: input.PythonVersion }),
    ...(input.ScriptLocation != null && { ScriptLocation: input.ScriptLocation }),
  };
};

/**
 * serializeAws_json1_1JobNameList
 */
const se_JobNameList = (input: string[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      return entry;
    });
};

/**
 * serializeAws_json1_1JobUpdate
 */
const se_JobUpdate = (input: JobUpdate, context: __SerdeContext): any => {
  return {
    ...(input.AllocatedCapacity != null && { AllocatedCapacity: input.AllocatedCapacity }),
    ...(input.CodeGenConfigurationNodes != null && {
      CodeGenConfigurationNodes: se_CodeGenConfigurationNodes(input.CodeGenConfigurationNodes, context),
    }),
    ...(input.Command != null && { Command: se_JobCommand(input.Command, context) }),
    ...(input.Connections != null && { Connections: se_ConnectionsList(input.Connections, context) }),
    ...(input.DefaultArguments != null && { DefaultArguments: se_GenericMap(input.DefaultArguments, context) }),
    ...(input.Description != null && { Description: input.Description }),
    ...(input.ExecutionClass != null && { ExecutionClass: input.ExecutionClass }),
    ...(input.ExecutionProperty != null && {
      ExecutionProperty: se_ExecutionProperty(input.ExecutionProperty, context),
    }),
    ...(input.GlueVersion != null && { GlueVersion: input.GlueVersion }),
    ...(input.LogUri != null && { LogUri: input.LogUri }),
    ...(input.MaxCapacity != null && { MaxCapacity: __serializeFloat(input.MaxCapacity) }),
    ...(input.MaxRetries != null && { MaxRetries: input.MaxRetries }),
    ...(input.NonOverridableArguments != null && {
      NonOverridableArguments: se_GenericMap(input.NonOverridableArguments, context),
    }),
    ...(input.NotificationProperty != null && {
      NotificationProperty: se_NotificationProperty(input.NotificationProperty, context),
    }),
    ...(input.NumberOfWorkers != null && { NumberOfWorkers: input.NumberOfWorkers }),
    ...(input.Role != null && { Role: input.Role }),
    ...(input.SecurityConfiguration != null && { SecurityConfiguration: input.SecurityConfiguration }),
    ...(input.SourceControlDetails != null && {
      SourceControlDetails: se_SourceControlDetails(input.SourceControlDetails, context),
    }),
    ...(input.Timeout != null && { Timeout: input.Timeout }),
    ...(input.WorkerType != null && { WorkerType: input.WorkerType }),
  };
};

/**
 * serializeAws_json1_1Join
 */
const se_Join = (input: Join, context: __SerdeContext): any => {
  return {
    ...(input.Columns != null && { Columns: se_JoinColumns(input.Columns, context) }),
    ...(input.Inputs != null && { Inputs: se_TwoInputs(input.Inputs, context) }),
    ...(input.JoinType != null && { JoinType: input.JoinType }),
    ...(input.Name != null && { Name: input.Name }),
  };
};

/**
 * serializeAws_json1_1JoinColumn
 */
const se_JoinColumn = (input: JoinColumn, context: __SerdeContext): any => {
  return {
    ...(input.From != null && { From: input.From }),
    ...(input.Keys != null && { Keys: se_GlueStudioPathList(input.Keys, context) }),
  };
};

/**
 * serializeAws_json1_1JoinColumns
 */
const se_JoinColumns = (input: JoinColumn[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      return se_JoinColumn(entry, context);
    });
};

/**
 * serializeAws_json1_1KafkaStreamingSourceOptions
 */
const se_KafkaStreamingSourceOptions = (input: KafkaStreamingSourceOptions, context: __SerdeContext): any => {
  return {
    ...(input.AddRecordTimestamp != null && { AddRecordTimestamp: input.AddRecordTimestamp }),
    ...(input.Assign != null && { Assign: input.Assign }),
    ...(input.BootstrapServers != null && { BootstrapServers: input.BootstrapServers }),
    ...(input.Classification != null && { Classification: input.Classification }),
    ...(input.ConnectionName != null && { ConnectionName: input.ConnectionName }),
    ...(input.Delimiter != null && { Delimiter: input.Delimiter }),
    ...(input.EmitConsumerLagMetrics != null && { EmitConsumerLagMetrics: input.EmitConsumerLagMetrics }),
    ...(input.EndingOffsets != null && { EndingOffsets: input.EndingOffsets }),
    ...(input.IncludeHeaders != null && { IncludeHeaders: input.IncludeHeaders }),
    ...(input.MaxOffsetsPerTrigger != null && { MaxOffsetsPerTrigger: input.MaxOffsetsPerTrigger }),
    ...(input.MinPartitions != null && { MinPartitions: input.MinPartitions }),
    ...(input.NumRetries != null && { NumRetries: input.NumRetries }),
    ...(input.PollTimeoutMs != null && { PollTimeoutMs: input.PollTimeoutMs }),
    ...(input.RetryIntervalMs != null && { RetryIntervalMs: input.RetryIntervalMs }),
    ...(input.SecurityProtocol != null && { SecurityProtocol: input.SecurityProtocol }),
    ...(input.StartingOffsets != null && { StartingOffsets: input.StartingOffsets }),
    ...(input.SubscribePattern != null && { SubscribePattern: input.SubscribePattern }),
    ...(input.TopicName != null && { TopicName: input.TopicName }),
  };
};

/**
 * serializeAws_json1_1KeyList
 */
const se_KeyList = (input: string[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      return entry;
    });
};

/**
 * serializeAws_json1_1KinesisStreamingSourceOptions
 */
const se_KinesisStreamingSourceOptions = (input: KinesisStreamingSourceOptions, context: __SerdeContext): any => {
  return {
    ...(input.AddIdleTimeBetweenReads != null && { AddIdleTimeBetweenReads: input.AddIdleTimeBetweenReads }),
    ...(input.AddRecordTimestamp != null && { AddRecordTimestamp: input.AddRecordTimestamp }),
    ...(input.AvoidEmptyBatches != null && { AvoidEmptyBatches: input.AvoidEmptyBatches }),
    ...(input.Classification != null && { Classification: input.Classification }),
    ...(input.Delimiter != null && { Delimiter: input.Delimiter }),
    ...(input.DescribeShardInterval != null && { DescribeShardInterval: input.DescribeShardInterval }),
    ...(input.EmitConsumerLagMetrics != null && { EmitConsumerLagMetrics: input.EmitConsumerLagMetrics }),
    ...(input.EndpointUrl != null && { EndpointUrl: input.EndpointUrl }),
    ...(input.IdleTimeBetweenReadsInMs != null && { IdleTimeBetweenReadsInMs: input.IdleTimeBetweenReadsInMs }),
    ...(input.MaxFetchRecordsPerShard != null && { MaxFetchRecordsPerShard: input.MaxFetchRecordsPerShard }),
    ...(input.MaxFetchTimeInMs != null && { MaxFetchTimeInMs: input.MaxFetchTimeInMs }),
    ...(input.MaxRecordPerRead != null && { MaxRecordPerRead: input.MaxRecordPerRead }),
    ...(input.MaxRetryIntervalMs != null && { MaxRetryIntervalMs: input.MaxRetryIntervalMs }),
    ...(input.NumRetries != null && { NumRetries: input.NumRetries }),
    ...(input.RetryIntervalMs != null && { RetryIntervalMs: input.RetryIntervalMs }),
    ...(input.RoleArn != null && { RoleArn: input.RoleArn }),
    ...(input.RoleSessionName != null && { RoleSessionName: input.RoleSessionName }),
    ...(input.StartingPosition != null && { StartingPosition: input.StartingPosition }),
    ...(input.StreamArn != null && { StreamArn: input.StreamArn }),
    ...(input.StreamName != null && { StreamName: input.StreamName }),
  };
};

/**
 * serializeAws_json1_1LakeFormationConfiguration
 */
const se_LakeFormationConfiguration = (input: LakeFormationConfiguration, context: __SerdeContext): any => {
  return {
    ...(input.AccountId != null && { AccountId: input.AccountId }),
    ...(input.UseLakeFormationCredentials != null && {
      UseLakeFormationCredentials: input.UseLakeFormationCredentials,
    }),
  };
};

/**
 * serializeAws_json1_1LimitedPathList
 */
const se_LimitedPathList = (input: string[][], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      return se_LimitedStringList(entry, context);
    });
};

/**
 * serializeAws_json1_1LimitedStringList
 */
const se_LimitedStringList = (input: string[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      return entry;
    });
};

/**
 * serializeAws_json1_1LineageConfiguration
 */
const se_LineageConfiguration = (input: LineageConfiguration, context: __SerdeContext): any => {
  return {
    ...(input.CrawlerLineageSettings != null && { CrawlerLineageSettings: input.CrawlerLineageSettings }),
  };
};

/**
 * serializeAws_json1_1ListBlueprintsRequest
 */
const se_ListBlueprintsRequest = (input: ListBlueprintsRequest, context: __SerdeContext): any => {
  return {
    ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
    ...(input.NextToken != null && { NextToken: input.NextToken }),
    ...(input.Tags != null && { Tags: se_TagsMap(input.Tags, context) }),
  };
};

/**
 * serializeAws_json1_1ListCrawlersRequest
 */
const se_ListCrawlersRequest = (input: ListCrawlersRequest, context: __SerdeContext): any => {
  return {
    ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
    ...(input.NextToken != null && { NextToken: input.NextToken }),
    ...(input.Tags != null && { Tags: se_TagsMap(input.Tags, context) }),
  };
};

/**
 * serializeAws_json1_1ListCrawlsRequest
 */
const se_ListCrawlsRequest = (input: ListCrawlsRequest, context: __SerdeContext): any => {
  return {
    ...(input.CrawlerName != null && { CrawlerName: input.CrawlerName }),
    ...(input.Filters != null && { Filters: se_CrawlsFilterList(input.Filters, context) }),
    ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
    ...(input.NextToken != null && { NextToken: input.NextToken }),
  };
};

/**
 * serializeAws_json1_1ListCustomEntityTypesRequest
 */
const se_ListCustomEntityTypesRequest = (input: ListCustomEntityTypesRequest, context: __SerdeContext): any => {
  return {
    ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
    ...(input.NextToken != null && { NextToken: input.NextToken }),
  };
};

/**
 * serializeAws_json1_1ListDataQualityResultsRequest
 */
const se_ListDataQualityResultsRequest = (input: ListDataQualityResultsRequest, context: __SerdeContext): any => {
  return {
    ...(input.Filter != null && { Filter: se_DataQualityResultFilterCriteria(input.Filter, context) }),
    ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
    ...(input.NextToken != null && { NextToken: input.NextToken }),
  };
};

/**
 * serializeAws_json1_1ListDataQualityRuleRecommendationRunsRequest
 */
const se_ListDataQualityRuleRecommendationRunsRequest = (
  input: ListDataQualityRuleRecommendationRunsRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.Filter != null && { Filter: se_DataQualityRuleRecommendationRunFilter(input.Filter, context) }),
    ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
    ...(input.NextToken != null && { NextToken: input.NextToken }),
  };
};

/**
 * serializeAws_json1_1ListDataQualityRulesetEvaluationRunsRequest
 */
const se_ListDataQualityRulesetEvaluationRunsRequest = (
  input: ListDataQualityRulesetEvaluationRunsRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.Filter != null && { Filter: se_DataQualityRulesetEvaluationRunFilter(input.Filter, context) }),
    ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
    ...(input.NextToken != null && { NextToken: input.NextToken }),
  };
};

/**
 * serializeAws_json1_1ListDataQualityRulesetsRequest
 */
const se_ListDataQualityRulesetsRequest = (input: ListDataQualityRulesetsRequest, context: __SerdeContext): any => {
  return {
    ...(input.Filter != null && { Filter: se_DataQualityRulesetFilterCriteria(input.Filter, context) }),
    ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
    ...(input.NextToken != null && { NextToken: input.NextToken }),
    ...(input.Tags != null && { Tags: se_TagsMap(input.Tags, context) }),
  };
};

/**
 * serializeAws_json1_1ListDevEndpointsRequest
 */
const se_ListDevEndpointsRequest = (input: ListDevEndpointsRequest, context: __SerdeContext): any => {
  return {
    ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
    ...(input.NextToken != null && { NextToken: input.NextToken }),
    ...(input.Tags != null && { Tags: se_TagsMap(input.Tags, context) }),
  };
};

/**
 * serializeAws_json1_1ListJobsRequest
 */
const se_ListJobsRequest = (input: ListJobsRequest, context: __SerdeContext): any => {
  return {
    ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
    ...(input.NextToken != null && { NextToken: input.NextToken }),
    ...(input.Tags != null && { Tags: se_TagsMap(input.Tags, context) }),
  };
};

/**
 * serializeAws_json1_1ListMLTransformsRequest
 */
const se_ListMLTransformsRequest = (input: ListMLTransformsRequest, context: __SerdeContext): any => {
  return {
    ...(input.Filter != null && { Filter: se_TransformFilterCriteria(input.Filter, context) }),
    ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
    ...(input.NextToken != null && { NextToken: input.NextToken }),
    ...(input.Sort != null && { Sort: se_TransformSortCriteria(input.Sort, context) }),
    ...(input.Tags != null && { Tags: se_TagsMap(input.Tags, context) }),
  };
};

/**
 * serializeAws_json1_1ListRegistriesInput
 */
const se_ListRegistriesInput = (input: ListRegistriesInput, context: __SerdeContext): any => {
  return {
    ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
    ...(input.NextToken != null && { NextToken: input.NextToken }),
  };
};

/**
 * serializeAws_json1_1ListSchemasInput
 */
const se_ListSchemasInput = (input: ListSchemasInput, context: __SerdeContext): any => {
  return {
    ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
    ...(input.NextToken != null && { NextToken: input.NextToken }),
    ...(input.RegistryId != null && { RegistryId: se_RegistryId(input.RegistryId, context) }),
  };
};

/**
 * serializeAws_json1_1ListSchemaVersionsInput
 */
const se_ListSchemaVersionsInput = (input: ListSchemaVersionsInput, context: __SerdeContext): any => {
  return {
    ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
    ...(input.NextToken != null && { NextToken: input.NextToken }),
    ...(input.SchemaId != null && { SchemaId: se_SchemaId(input.SchemaId, context) }),
  };
};

/**
 * serializeAws_json1_1ListSessionsRequest
 */
const se_ListSessionsRequest = (input: ListSessionsRequest, context: __SerdeContext): any => {
  return {
    ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
    ...(input.NextToken != null && { NextToken: input.NextToken }),
    ...(input.RequestOrigin != null && { RequestOrigin: input.RequestOrigin }),
    ...(input.Tags != null && { Tags: se_TagsMap(input.Tags, context) }),
  };
};

/**
 * serializeAws_json1_1ListStatementsRequest
 */
const se_ListStatementsRequest = (input: ListStatementsRequest, context: __SerdeContext): any => {
  return {
    ...(input.NextToken != null && { NextToken: input.NextToken }),
    ...(input.RequestOrigin != null && { RequestOrigin: input.RequestOrigin }),
    ...(input.SessionId != null && { SessionId: input.SessionId }),
  };
};

/**
 * serializeAws_json1_1ListTriggersRequest
 */
const se_ListTriggersRequest = (input: ListTriggersRequest, context: __SerdeContext): any => {
  return {
    ...(input.DependentJobName != null && { DependentJobName: input.DependentJobName }),
    ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
    ...(input.NextToken != null && { NextToken: input.NextToken }),
    ...(input.Tags != null && { Tags: se_TagsMap(input.Tags, context) }),
  };
};

/**
 * serializeAws_json1_1ListWorkflowsRequest
 */
const se_ListWorkflowsRequest = (input: ListWorkflowsRequest, context: __SerdeContext): any => {
  return {
    ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
    ...(input.NextToken != null && { NextToken: input.NextToken }),
  };
};

/**
 * serializeAws_json1_1Location
 */
const se_Location = (input: Location, context: __SerdeContext): any => {
  return {
    ...(input.DynamoDB != null && { DynamoDB: se_CodeGenNodeArgs(input.DynamoDB, context) }),
    ...(input.Jdbc != null && { Jdbc: se_CodeGenNodeArgs(input.Jdbc, context) }),
    ...(input.S3 != null && { S3: se_CodeGenNodeArgs(input.S3, context) }),
  };
};

/**
 * serializeAws_json1_1LocationMap
 */
const se_LocationMap = (input: Record<string, string>, context: __SerdeContext): any => {
  return Object.entries(input).reduce((acc: Record<string, any>, [key, value]: [string, any]) => {
    if (value === null) {
      return acc;
    }
    acc[key] = value;
    return acc;
  }, {});
};

/**
 * serializeAws_json1_1LocationStringList
 */
const se_LocationStringList = (input: string[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      return entry;
    });
};

/**
 * serializeAws_json1_1LongColumnStatisticsData
 */
const se_LongColumnStatisticsData = (input: LongColumnStatisticsData, context: __SerdeContext): any => {
  return {
    ...(input.MaximumValue != null && { MaximumValue: input.MaximumValue }),
    ...(input.MinimumValue != null && { MinimumValue: input.MinimumValue }),
    ...(input.NumberOfDistinctValues != null && { NumberOfDistinctValues: input.NumberOfDistinctValues }),
    ...(input.NumberOfNulls != null && { NumberOfNulls: input.NumberOfNulls }),
  };
};

/**
 * serializeAws_json1_1ManyInputs
 */
const se_ManyInputs = (input: string[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      return entry;
    });
};

/**
 * serializeAws_json1_1Mapping
 */
const se_Mapping = (input: Mapping, context: __SerdeContext): any => {
  return {
    ...(input.Children != null && { Children: se_Mappings(input.Children, context) }),
    ...(input.Dropped != null && { Dropped: input.Dropped }),
    ...(input.FromPath != null && { FromPath: se_EnclosedInStringProperties(input.FromPath, context) }),
    ...(input.FromType != null && { FromType: input.FromType }),
    ...(input.ToKey != null && { ToKey: input.ToKey }),
    ...(input.ToType != null && { ToType: input.ToType }),
  };
};

/**
 * serializeAws_json1_1MappingEntry
 */
const se_MappingEntry = (input: MappingEntry, context: __SerdeContext): any => {
  return {
    ...(input.SourcePath != null && { SourcePath: input.SourcePath }),
    ...(input.SourceTable != null && { SourceTable: input.SourceTable }),
    ...(input.SourceType != null && { SourceType: input.SourceType }),
    ...(input.TargetPath != null && { TargetPath: input.TargetPath }),
    ...(input.TargetTable != null && { TargetTable: input.TargetTable }),
    ...(input.TargetType != null && { TargetType: input.TargetType }),
  };
};

/**
 * serializeAws_json1_1MappingList
 */
const se_MappingList = (input: MappingEntry[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      return se_MappingEntry(entry, context);
    });
};

/**
 * serializeAws_json1_1Mappings
 */
const se_Mappings = (input: Mapping[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      return se_Mapping(entry, context);
    });
};

/**
 * serializeAws_json1_1MapValue
 */
const se_MapValue = (input: Record<string, string>, context: __SerdeContext): any => {
  return Object.entries(input).reduce((acc: Record<string, any>, [key, value]: [string, any]) => {
    if (value === null) {
      return acc;
    }
    acc[key] = value;
    return acc;
  }, {});
};

/**
 * serializeAws_json1_1MatchCriteria
 */
const se_MatchCriteria = (input: string[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      return entry;
    });
};

/**
 * serializeAws_json1_1Merge
 */
const se_Merge = (input: Merge, context: __SerdeContext): any => {
  return {
    ...(input.Inputs != null && { Inputs: se_TwoInputs(input.Inputs, context) }),
    ...(input.Name != null && { Name: input.Name }),
    ...(input.PrimaryKeys != null && { PrimaryKeys: se_GlueStudioPathList(input.PrimaryKeys, context) }),
    ...(input.Source != null && { Source: input.Source }),
  };
};

/**
 * serializeAws_json1_1MetadataKeyValuePair
 */
const se_MetadataKeyValuePair = (input: MetadataKeyValuePair, context: __SerdeContext): any => {
  return {
    ...(input.MetadataKey != null && { MetadataKey: input.MetadataKey }),
    ...(input.MetadataValue != null && { MetadataValue: input.MetadataValue }),
  };
};

/**
 * serializeAws_json1_1MetadataList
 */
const se_MetadataList = (input: MetadataKeyValuePair[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      return se_MetadataKeyValuePair(entry, context);
    });
};

/**
 * serializeAws_json1_1MicrosoftSQLServerCatalogSource
 */
const se_MicrosoftSQLServerCatalogSource = (input: MicrosoftSQLServerCatalogSource, context: __SerdeContext): any => {
  return {
    ...(input.Database != null && { Database: input.Database }),
    ...(input.Name != null && { Name: input.Name }),
    ...(input.Table != null && { Table: input.Table }),
  };
};

/**
 * serializeAws_json1_1MicrosoftSQLServerCatalogTarget
 */
const se_MicrosoftSQLServerCatalogTarget = (input: MicrosoftSQLServerCatalogTarget, context: __SerdeContext): any => {
  return {
    ...(input.Database != null && { Database: input.Database }),
    ...(input.Inputs != null && { Inputs: se_OneInput(input.Inputs, context) }),
    ...(input.Name != null && { Name: input.Name }),
    ...(input.Table != null && { Table: input.Table }),
  };
};

/**
 * serializeAws_json1_1MLUserDataEncryption
 */
const se_MLUserDataEncryption = (input: MLUserDataEncryption, context: __SerdeContext): any => {
  return {
    ...(input.KmsKeyId != null && { KmsKeyId: input.KmsKeyId }),
    ...(input.MlUserDataEncryptionMode != null && { MlUserDataEncryptionMode: input.MlUserDataEncryptionMode }),
  };
};

/**
 * serializeAws_json1_1MongoDBTarget
 */
const se_MongoDBTarget = (input: MongoDBTarget, context: __SerdeContext): any => {
  return {
    ...(input.ConnectionName != null && { ConnectionName: input.ConnectionName }),
    ...(input.Path != null && { Path: input.Path }),
    ...(input.ScanAll != null && { ScanAll: input.ScanAll }),
  };
};

/**
 * serializeAws_json1_1MongoDBTargetList
 */
const se_MongoDBTargetList = (input: MongoDBTarget[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      return se_MongoDBTarget(entry, context);
    });
};

/**
 * serializeAws_json1_1MySQLCatalogSource
 */
const se_MySQLCatalogSource = (input: MySQLCatalogSource, context: __SerdeContext): any => {
  return {
    ...(input.Database != null && { Database: input.Database }),
    ...(input.Name != null && { Name: input.Name }),
    ...(input.Table != null && { Table: input.Table }),
  };
};

/**
 * serializeAws_json1_1MySQLCatalogTarget
 */
const se_MySQLCatalogTarget = (input: MySQLCatalogTarget, context: __SerdeContext): any => {
  return {
    ...(input.Database != null && { Database: input.Database }),
    ...(input.Inputs != null && { Inputs: se_OneInput(input.Inputs, context) }),
    ...(input.Name != null && { Name: input.Name }),
    ...(input.Table != null && { Table: input.Table }),
  };
};

/**
 * serializeAws_json1_1NameStringList
 */
const se_NameStringList = (input: string[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      return entry;
    });
};

/**
 * serializeAws_json1_1NodeIdList
 */
const se_NodeIdList = (input: string[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      return entry;
    });
};

/**
 * serializeAws_json1_1NotificationProperty
 */
const se_NotificationProperty = (input: NotificationProperty, context: __SerdeContext): any => {
  return {
    ...(input.NotifyDelayAfter != null && { NotifyDelayAfter: input.NotifyDelayAfter }),
  };
};

/**
 * serializeAws_json1_1NullCheckBoxList
 */
const se_NullCheckBoxList = (input: NullCheckBoxList, context: __SerdeContext): any => {
  return {
    ...(input.IsEmpty != null && { IsEmpty: input.IsEmpty }),
    ...(input.IsNegOne != null && { IsNegOne: input.IsNegOne }),
    ...(input.IsNullString != null && { IsNullString: input.IsNullString }),
  };
};

/**
 * serializeAws_json1_1NullValueField
 */
const se_NullValueField = (input: NullValueField, context: __SerdeContext): any => {
  return {
    ...(input.Datatype != null && { Datatype: se_Datatype(input.Datatype, context) }),
    ...(input.Value != null && { Value: input.Value }),
  };
};

/**
 * serializeAws_json1_1NullValueFields
 */
const se_NullValueFields = (input: NullValueField[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      return se_NullValueField(entry, context);
    });
};

/**
 * serializeAws_json1_1OneInput
 */
const se_OneInput = (input: string[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      return entry;
    });
};

/**
 * serializeAws_json1_1OracleSQLCatalogSource
 */
const se_OracleSQLCatalogSource = (input: OracleSQLCatalogSource, context: __SerdeContext): any => {
  return {
    ...(input.Database != null && { Database: input.Database }),
    ...(input.Name != null && { Name: input.Name }),
    ...(input.Table != null && { Table: input.Table }),
  };
};

/**
 * serializeAws_json1_1OracleSQLCatalogTarget
 */
const se_OracleSQLCatalogTarget = (input: OracleSQLCatalogTarget, context: __SerdeContext): any => {
  return {
    ...(input.Database != null && { Database: input.Database }),
    ...(input.Inputs != null && { Inputs: se_OneInput(input.Inputs, context) }),
    ...(input.Name != null && { Name: input.Name }),
    ...(input.Table != null && { Table: input.Table }),
  };
};

/**
 * serializeAws_json1_1OrchestrationArgumentsMap
 */
const se_OrchestrationArgumentsMap = (input: Record<string, string>, context: __SerdeContext): any => {
  return Object.entries(input).reduce((acc: Record<string, any>, [key, value]: [string, any]) => {
    if (value === null) {
      return acc;
    }
    acc[key] = value;
    return acc;
  }, {});
};

/**
 * serializeAws_json1_1OrchestrationStringList
 */
const se_OrchestrationStringList = (input: string[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      return entry;
    });
};

/**
 * serializeAws_json1_1Order
 */
const se_Order = (input: Order, context: __SerdeContext): any => {
  return {
    ...(input.Column != null && { Column: input.Column }),
    ...(input.SortOrder != null && { SortOrder: input.SortOrder }),
  };
};

/**
 * serializeAws_json1_1OrderList
 */
const se_OrderList = (input: Order[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      return se_Order(entry, context);
    });
};

/**
 * serializeAws_json1_1ParametersMap
 */
const se_ParametersMap = (input: Record<string, string>, context: __SerdeContext): any => {
  return Object.entries(input).reduce((acc: Record<string, any>, [key, value]: [string, any]) => {
    if (value === null) {
      return acc;
    }
    acc[key] = value;
    return acc;
  }, {});
};

/**
 * serializeAws_json1_1PartitionIndex
 */
const se_PartitionIndex = (input: PartitionIndex, context: __SerdeContext): any => {
  return {
    ...(input.IndexName != null && { IndexName: input.IndexName }),
    ...(input.Keys != null && { Keys: se_KeyList(input.Keys, context) }),
  };
};

/**
 * serializeAws_json1_1PartitionIndexList
 */
const se_PartitionIndexList = (input: PartitionIndex[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      return se_PartitionIndex(entry, context);
    });
};

/**
 * serializeAws_json1_1PartitionInput
 */
const se_PartitionInput = (input: PartitionInput, context: __SerdeContext): any => {
  return {
    ...(input.LastAccessTime != null && { LastAccessTime: Math.round(input.LastAccessTime.getTime() / 1000) }),
    ...(input.LastAnalyzedTime != null && { LastAnalyzedTime: Math.round(input.LastAnalyzedTime.getTime() / 1000) }),
    ...(input.Parameters != null && { Parameters: se_ParametersMap(input.Parameters, context) }),
    ...(input.StorageDescriptor != null && {
      StorageDescriptor: se_StorageDescriptor(input.StorageDescriptor, context),
    }),
    ...(input.Values != null && { Values: se_ValueStringList(input.Values, context) }),
  };
};

/**
 * serializeAws_json1_1PartitionInputList
 */
const se_PartitionInputList = (input: PartitionInput[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      return se_PartitionInput(entry, context);
    });
};

/**
 * serializeAws_json1_1PartitionValueList
 */
const se_PartitionValueList = (input: PartitionValueList, context: __SerdeContext): any => {
  return {
    ...(input.Values != null && { Values: se_ValueStringList(input.Values, context) }),
  };
};

/**
 * serializeAws_json1_1PathList
 */
const se_PathList = (input: string[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      return entry;
    });
};

/**
 * serializeAws_json1_1PermissionList
 */
const se_PermissionList = (input: (Permission | string)[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      return entry;
    });
};

/**
 * serializeAws_json1_1PermissionTypeList
 */
const se_PermissionTypeList = (input: (PermissionType | string)[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      return entry;
    });
};

/**
 * serializeAws_json1_1PhysicalConnectionRequirements
 */
const se_PhysicalConnectionRequirements = (input: PhysicalConnectionRequirements, context: __SerdeContext): any => {
  return {
    ...(input.AvailabilityZone != null && { AvailabilityZone: input.AvailabilityZone }),
    ...(input.SecurityGroupIdList != null && {
      SecurityGroupIdList: se_SecurityGroupIdList(input.SecurityGroupIdList, context),
    }),
    ...(input.SubnetId != null && { SubnetId: input.SubnetId }),
  };
};

/**
 * serializeAws_json1_1PIIDetection
 */
const se_PIIDetection = (input: PIIDetection, context: __SerdeContext): any => {
  return {
    ...(input.EntityTypesToDetect != null && {
      EntityTypesToDetect: se_EnclosedInStringProperties(input.EntityTypesToDetect, context),
    }),
    ...(input.Inputs != null && { Inputs: se_OneInput(input.Inputs, context) }),
    ...(input.MaskValue != null && { MaskValue: input.MaskValue }),
    ...(input.Name != null && { Name: input.Name }),
    ...(input.OutputColumnName != null && { OutputColumnName: input.OutputColumnName }),
    ...(input.PiiType != null && { PiiType: input.PiiType }),
    ...(input.SampleFraction != null && { SampleFraction: __serializeFloat(input.SampleFraction) }),
    ...(input.ThresholdFraction != null && { ThresholdFraction: __serializeFloat(input.ThresholdFraction) }),
  };
};

/**
 * serializeAws_json1_1PostgreSQLCatalogSource
 */
const se_PostgreSQLCatalogSource = (input: PostgreSQLCatalogSource, context: __SerdeContext): any => {
  return {
    ...(input.Database != null && { Database: input.Database }),
    ...(input.Name != null && { Name: input.Name }),
    ...(input.Table != null && { Table: input.Table }),
  };
};

/**
 * serializeAws_json1_1PostgreSQLCatalogTarget
 */
const se_PostgreSQLCatalogTarget = (input: PostgreSQLCatalogTarget, context: __SerdeContext): any => {
  return {
    ...(input.Database != null && { Database: input.Database }),
    ...(input.Inputs != null && { Inputs: se_OneInput(input.Inputs, context) }),
    ...(input.Name != null && { Name: input.Name }),
    ...(input.Table != null && { Table: input.Table }),
  };
};

/**
 * serializeAws_json1_1Predicate
 */
const se_Predicate = (input: Predicate, context: __SerdeContext): any => {
  return {
    ...(input.Conditions != null && { Conditions: se_ConditionList(input.Conditions, context) }),
    ...(input.Logical != null && { Logical: input.Logical }),
  };
};

/**
 * serializeAws_json1_1PrincipalPermissions
 */
const se_PrincipalPermissions = (input: PrincipalPermissions, context: __SerdeContext): any => {
  return {
    ...(input.Permissions != null && { Permissions: se_PermissionList(input.Permissions, context) }),
    ...(input.Principal != null && { Principal: se_DataLakePrincipal(input.Principal, context) }),
  };
};

/**
 * serializeAws_json1_1PrincipalPermissionsList
 */
const se_PrincipalPermissionsList = (input: PrincipalPermissions[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      return se_PrincipalPermissions(entry, context);
    });
};

/**
 * serializeAws_json1_1PropertyPredicate
 */
const se_PropertyPredicate = (input: PropertyPredicate, context: __SerdeContext): any => {
  return {
    ...(input.Comparator != null && { Comparator: input.Comparator }),
    ...(input.Key != null && { Key: input.Key }),
    ...(input.Value != null && { Value: input.Value }),
  };
};

/**
 * serializeAws_json1_1PublicKeysList
 */
const se_PublicKeysList = (input: string[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      return entry;
    });
};

/**
 * serializeAws_json1_1PutDataCatalogEncryptionSettingsRequest
 */
const se_PutDataCatalogEncryptionSettingsRequest = (
  input: PutDataCatalogEncryptionSettingsRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
    ...(input.DataCatalogEncryptionSettings != null && {
      DataCatalogEncryptionSettings: se_DataCatalogEncryptionSettings(input.DataCatalogEncryptionSettings, context),
    }),
  };
};

/**
 * serializeAws_json1_1PutResourcePolicyRequest
 */
const se_PutResourcePolicyRequest = (input: PutResourcePolicyRequest, context: __SerdeContext): any => {
  return {
    ...(input.EnableHybrid != null && { EnableHybrid: input.EnableHybrid }),
    ...(input.PolicyExistsCondition != null && { PolicyExistsCondition: input.PolicyExistsCondition }),
    ...(input.PolicyHashCondition != null && { PolicyHashCondition: input.PolicyHashCondition }),
    ...(input.PolicyInJson != null && { PolicyInJson: input.PolicyInJson }),
    ...(input.ResourceArn != null && { ResourceArn: input.ResourceArn }),
  };
};

/**
 * serializeAws_json1_1PutSchemaVersionMetadataInput
 */
const se_PutSchemaVersionMetadataInput = (input: PutSchemaVersionMetadataInput, context: __SerdeContext): any => {
  return {
    ...(input.MetadataKeyValue != null && {
      MetadataKeyValue: se_MetadataKeyValuePair(input.MetadataKeyValue, context),
    }),
    ...(input.SchemaId != null && { SchemaId: se_SchemaId(input.SchemaId, context) }),
    ...(input.SchemaVersionId != null && { SchemaVersionId: input.SchemaVersionId }),
    ...(input.SchemaVersionNumber != null && {
      SchemaVersionNumber: se_SchemaVersionNumber(input.SchemaVersionNumber, context),
    }),
  };
};

/**
 * serializeAws_json1_1PutWorkflowRunPropertiesRequest
 */
const se_PutWorkflowRunPropertiesRequest = (input: PutWorkflowRunPropertiesRequest, context: __SerdeContext): any => {
  return {
    ...(input.Name != null && { Name: input.Name }),
    ...(input.RunId != null && { RunId: input.RunId }),
    ...(input.RunProperties != null && { RunProperties: se_WorkflowRunProperties(input.RunProperties, context) }),
  };
};

/**
 * serializeAws_json1_1QuerySchemaVersionMetadataInput
 */
const se_QuerySchemaVersionMetadataInput = (input: QuerySchemaVersionMetadataInput, context: __SerdeContext): any => {
  return {
    ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
    ...(input.MetadataList != null && { MetadataList: se_MetadataList(input.MetadataList, context) }),
    ...(input.NextToken != null && { NextToken: input.NextToken }),
    ...(input.SchemaId != null && { SchemaId: se_SchemaId(input.SchemaId, context) }),
    ...(input.SchemaVersionId != null && { SchemaVersionId: input.SchemaVersionId }),
    ...(input.SchemaVersionNumber != null && {
      SchemaVersionNumber: se_SchemaVersionNumber(input.SchemaVersionNumber, context),
    }),
  };
};

/**
 * serializeAws_json1_1RecrawlPolicy
 */
const se_RecrawlPolicy = (input: RecrawlPolicy, context: __SerdeContext): any => {
  return {
    ...(input.RecrawlBehavior != null && { RecrawlBehavior: input.RecrawlBehavior }),
  };
};

/**
 * serializeAws_json1_1RedshiftSource
 */
const se_RedshiftSource = (input: RedshiftSource, context: __SerdeContext): any => {
  return {
    ...(input.Database != null && { Database: input.Database }),
    ...(input.Name != null && { Name: input.Name }),
    ...(input.RedshiftTmpDir != null && { RedshiftTmpDir: input.RedshiftTmpDir }),
    ...(input.Table != null && { Table: input.Table }),
    ...(input.TmpDirIAMRole != null && { TmpDirIAMRole: input.TmpDirIAMRole }),
  };
};

/**
 * serializeAws_json1_1RedshiftTarget
 */
const se_RedshiftTarget = (input: RedshiftTarget, context: __SerdeContext): any => {
  return {
    ...(input.Database != null && { Database: input.Database }),
    ...(input.Inputs != null && { Inputs: se_OneInput(input.Inputs, context) }),
    ...(input.Name != null && { Name: input.Name }),
    ...(input.RedshiftTmpDir != null && { RedshiftTmpDir: input.RedshiftTmpDir }),
    ...(input.Table != null && { Table: input.Table }),
    ...(input.TmpDirIAMRole != null && { TmpDirIAMRole: input.TmpDirIAMRole }),
    ...(input.UpsertRedshiftOptions != null && {
      UpsertRedshiftOptions: se_UpsertRedshiftTargetOptions(input.UpsertRedshiftOptions, context),
    }),
  };
};

/**
 * serializeAws_json1_1RegisterSchemaVersionInput
 */
const se_RegisterSchemaVersionInput = (input: RegisterSchemaVersionInput, context: __SerdeContext): any => {
  return {
    ...(input.SchemaDefinition != null && { SchemaDefinition: input.SchemaDefinition }),
    ...(input.SchemaId != null && { SchemaId: se_SchemaId(input.SchemaId, context) }),
  };
};

/**
 * serializeAws_json1_1RegistryId
 */
const se_RegistryId = (input: RegistryId, context: __SerdeContext): any => {
  return {
    ...(input.RegistryArn != null && { RegistryArn: input.RegistryArn }),
    ...(input.RegistryName != null && { RegistryName: input.RegistryName }),
  };
};

/**
 * serializeAws_json1_1RelationalCatalogSource
 */
const se_RelationalCatalogSource = (input: RelationalCatalogSource, context: __SerdeContext): any => {
  return {
    ...(input.Database != null && { Database: input.Database }),
    ...(input.Name != null && { Name: input.Name }),
    ...(input.Table != null && { Table: input.Table }),
  };
};

/**
 * serializeAws_json1_1RemoveSchemaVersionMetadataInput
 */
const se_RemoveSchemaVersionMetadataInput = (input: RemoveSchemaVersionMetadataInput, context: __SerdeContext): any => {
  return {
    ...(input.MetadataKeyValue != null && {
      MetadataKeyValue: se_MetadataKeyValuePair(input.MetadataKeyValue, context),
    }),
    ...(input.SchemaId != null && { SchemaId: se_SchemaId(input.SchemaId, context) }),
    ...(input.SchemaVersionId != null && { SchemaVersionId: input.SchemaVersionId }),
    ...(input.SchemaVersionNumber != null && {
      SchemaVersionNumber: se_SchemaVersionNumber(input.SchemaVersionNumber, context),
    }),
  };
};

/**
 * serializeAws_json1_1RenameField
 */
const se_RenameField = (input: RenameField, context: __SerdeContext): any => {
  return {
    ...(input.Inputs != null && { Inputs: se_OneInput(input.Inputs, context) }),
    ...(input.Name != null && { Name: input.Name }),
    ...(input.SourcePath != null && { SourcePath: se_EnclosedInStringProperties(input.SourcePath, context) }),
    ...(input.TargetPath != null && { TargetPath: se_EnclosedInStringProperties(input.TargetPath, context) }),
  };
};

/**
 * serializeAws_json1_1ResetJobBookmarkRequest
 */
const se_ResetJobBookmarkRequest = (input: ResetJobBookmarkRequest, context: __SerdeContext): any => {
  return {
    ...(input.JobName != null && { JobName: input.JobName }),
    ...(input.RunId != null && { RunId: input.RunId }),
  };
};

/**
 * serializeAws_json1_1ResourceUri
 */
const se_ResourceUri = (input: ResourceUri, context: __SerdeContext): any => {
  return {
    ...(input.ResourceType != null && { ResourceType: input.ResourceType }),
    ...(input.Uri != null && { Uri: input.Uri }),
  };
};

/**
 * serializeAws_json1_1ResourceUriList
 */
const se_ResourceUriList = (input: ResourceUri[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      return se_ResourceUri(entry, context);
    });
};

/**
 * serializeAws_json1_1ResumeWorkflowRunRequest
 */
const se_ResumeWorkflowRunRequest = (input: ResumeWorkflowRunRequest, context: __SerdeContext): any => {
  return {
    ...(input.Name != null && { Name: input.Name }),
    ...(input.NodeIds != null && { NodeIds: se_NodeIdList(input.NodeIds, context) }),
    ...(input.RunId != null && { RunId: input.RunId }),
  };
};

/**
 * serializeAws_json1_1RulesetNames
 */
const se_RulesetNames = (input: string[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      return entry;
    });
};

/**
 * serializeAws_json1_1RunStatementRequest
 */
const se_RunStatementRequest = (input: RunStatementRequest, context: __SerdeContext): any => {
  return {
    ...(input.Code != null && { Code: input.Code }),
    ...(input.RequestOrigin != null && { RequestOrigin: input.RequestOrigin }),
    ...(input.SessionId != null && { SessionId: input.SessionId }),
  };
};

/**
 * serializeAws_json1_1S3CatalogDeltaSource
 */
const se_S3CatalogDeltaSource = (input: S3CatalogDeltaSource, context: __SerdeContext): any => {
  return {
    ...(input.AdditionalDeltaOptions != null && {
      AdditionalDeltaOptions: se_AdditionalOptions(input.AdditionalDeltaOptions, context),
    }),
    ...(input.Database != null && { Database: input.Database }),
    ...(input.Name != null && { Name: input.Name }),
    ...(input.OutputSchemas != null && { OutputSchemas: se_GlueSchemas(input.OutputSchemas, context) }),
    ...(input.Table != null && { Table: input.Table }),
  };
};

/**
 * serializeAws_json1_1S3CatalogHudiSource
 */
const se_S3CatalogHudiSource = (input: S3CatalogHudiSource, context: __SerdeContext): any => {
  return {
    ...(input.AdditionalHudiOptions != null && {
      AdditionalHudiOptions: se_AdditionalOptions(input.AdditionalHudiOptions, context),
    }),
    ...(input.Database != null && { Database: input.Database }),
    ...(input.Name != null && { Name: input.Name }),
    ...(input.OutputSchemas != null && { OutputSchemas: se_GlueSchemas(input.OutputSchemas, context) }),
    ...(input.Table != null && { Table: input.Table }),
  };
};

/**
 * serializeAws_json1_1S3CatalogSource
 */
const se_S3CatalogSource = (input: S3CatalogSource, context: __SerdeContext): any => {
  return {
    ...(input.AdditionalOptions != null && {
      AdditionalOptions: se_S3SourceAdditionalOptions(input.AdditionalOptions, context),
    }),
    ...(input.Database != null && { Database: input.Database }),
    ...(input.Name != null && { Name: input.Name }),
    ...(input.PartitionPredicate != null && { PartitionPredicate: input.PartitionPredicate }),
    ...(input.Table != null && { Table: input.Table }),
  };
};

/**
 * serializeAws_json1_1S3CatalogTarget
 */
const se_S3CatalogTarget = (input: S3CatalogTarget, context: __SerdeContext): any => {
  return {
    ...(input.Database != null && { Database: input.Database }),
    ...(input.Inputs != null && { Inputs: se_OneInput(input.Inputs, context) }),
    ...(input.Name != null && { Name: input.Name }),
    ...(input.PartitionKeys != null && { PartitionKeys: se_GlueStudioPathList(input.PartitionKeys, context) }),
    ...(input.SchemaChangePolicy != null && {
      SchemaChangePolicy: se_CatalogSchemaChangePolicy(input.SchemaChangePolicy, context),
    }),
    ...(input.Table != null && { Table: input.Table }),
  };
};

/**
 * serializeAws_json1_1S3CsvSource
 */
const se_S3CsvSource = (input: S3CsvSource, context: __SerdeContext): any => {
  return {
    ...(input.AdditionalOptions != null && {
      AdditionalOptions: se_S3DirectSourceAdditionalOptions(input.AdditionalOptions, context),
    }),
    ...(input.CompressionType != null && { CompressionType: input.CompressionType }),
    ...(input.Escaper != null && { Escaper: input.Escaper }),
    ...(input.Exclusions != null && { Exclusions: se_EnclosedInStringProperties(input.Exclusions, context) }),
    ...(input.GroupFiles != null && { GroupFiles: input.GroupFiles }),
    ...(input.GroupSize != null && { GroupSize: input.GroupSize }),
    ...(input.MaxBand != null && { MaxBand: input.MaxBand }),
    ...(input.MaxFilesInBand != null && { MaxFilesInBand: input.MaxFilesInBand }),
    ...(input.Multiline != null && { Multiline: input.Multiline }),
    ...(input.Name != null && { Name: input.Name }),
    ...(input.OptimizePerformance != null && { OptimizePerformance: input.OptimizePerformance }),
    ...(input.OutputSchemas != null && { OutputSchemas: se_GlueSchemas(input.OutputSchemas, context) }),
    ...(input.Paths != null && { Paths: se_EnclosedInStringProperties(input.Paths, context) }),
    ...(input.QuoteChar != null && { QuoteChar: input.QuoteChar }),
    ...(input.Recurse != null && { Recurse: input.Recurse }),
    ...(input.Separator != null && { Separator: input.Separator }),
    ...(input.SkipFirst != null && { SkipFirst: input.SkipFirst }),
    ...(input.WithHeader != null && { WithHeader: input.WithHeader }),
    ...(input.WriteHeader != null && { WriteHeader: input.WriteHeader }),
  };
};

/**
 * serializeAws_json1_1S3DeltaCatalogTarget
 */
const se_S3DeltaCatalogTarget = (input: S3DeltaCatalogTarget, context: __SerdeContext): any => {
  return {
    ...(input.AdditionalOptions != null && {
      AdditionalOptions: se_AdditionalOptions(input.AdditionalOptions, context),
    }),
    ...(input.Database != null && { Database: input.Database }),
    ...(input.Inputs != null && { Inputs: se_OneInput(input.Inputs, context) }),
    ...(input.Name != null && { Name: input.Name }),
    ...(input.PartitionKeys != null && { PartitionKeys: se_GlueStudioPathList(input.PartitionKeys, context) }),
    ...(input.SchemaChangePolicy != null && {
      SchemaChangePolicy: se_CatalogSchemaChangePolicy(input.SchemaChangePolicy, context),
    }),
    ...(input.Table != null && { Table: input.Table }),
  };
};

/**
 * serializeAws_json1_1S3DeltaDirectTarget
 */
const se_S3DeltaDirectTarget = (input: S3DeltaDirectTarget, context: __SerdeContext): any => {
  return {
    ...(input.AdditionalOptions != null && {
      AdditionalOptions: se_AdditionalOptions(input.AdditionalOptions, context),
    }),
    ...(input.Compression != null && { Compression: input.Compression }),
    ...(input.Format != null && { Format: input.Format }),
    ...(input.Inputs != null && { Inputs: se_OneInput(input.Inputs, context) }),
    ...(input.Name != null && { Name: input.Name }),
    ...(input.PartitionKeys != null && { PartitionKeys: se_GlueStudioPathList(input.PartitionKeys, context) }),
    ...(input.Path != null && { Path: input.Path }),
    ...(input.SchemaChangePolicy != null && {
      SchemaChangePolicy: se_DirectSchemaChangePolicy(input.SchemaChangePolicy, context),
    }),
  };
};

/**
 * serializeAws_json1_1S3DeltaSource
 */
const se_S3DeltaSource = (input: S3DeltaSource, context: __SerdeContext): any => {
  return {
    ...(input.AdditionalDeltaOptions != null && {
      AdditionalDeltaOptions: se_AdditionalOptions(input.AdditionalDeltaOptions, context),
    }),
    ...(input.AdditionalOptions != null && {
      AdditionalOptions: se_S3DirectSourceAdditionalOptions(input.AdditionalOptions, context),
    }),
    ...(input.Name != null && { Name: input.Name }),
    ...(input.OutputSchemas != null && { OutputSchemas: se_GlueSchemas(input.OutputSchemas, context) }),
    ...(input.Paths != null && { Paths: se_EnclosedInStringProperties(input.Paths, context) }),
  };
};

/**
 * serializeAws_json1_1S3DirectSourceAdditionalOptions
 */
const se_S3DirectSourceAdditionalOptions = (input: S3DirectSourceAdditionalOptions, context: __SerdeContext): any => {
  return {
    ...(input.BoundedFiles != null && { BoundedFiles: input.BoundedFiles }),
    ...(input.BoundedSize != null && { BoundedSize: input.BoundedSize }),
    ...(input.EnableSamplePath != null && { EnableSamplePath: input.EnableSamplePath }),
    ...(input.SamplePath != null && { SamplePath: input.SamplePath }),
  };
};

/**
 * serializeAws_json1_1S3DirectTarget
 */
const se_S3DirectTarget = (input: S3DirectTarget, context: __SerdeContext): any => {
  return {
    ...(input.Compression != null && { Compression: input.Compression }),
    ...(input.Format != null && { Format: input.Format }),
    ...(input.Inputs != null && { Inputs: se_OneInput(input.Inputs, context) }),
    ...(input.Name != null && { Name: input.Name }),
    ...(input.PartitionKeys != null && { PartitionKeys: se_GlueStudioPathList(input.PartitionKeys, context) }),
    ...(input.Path != null && { Path: input.Path }),
    ...(input.SchemaChangePolicy != null && {
      SchemaChangePolicy: se_DirectSchemaChangePolicy(input.SchemaChangePolicy, context),
    }),
  };
};

/**
 * serializeAws_json1_1S3Encryption
 */
const se_S3Encryption = (input: S3Encryption, context: __SerdeContext): any => {
  return {
    ...(input.KmsKeyArn != null && { KmsKeyArn: input.KmsKeyArn }),
    ...(input.S3EncryptionMode != null && { S3EncryptionMode: input.S3EncryptionMode }),
  };
};

/**
 * serializeAws_json1_1S3EncryptionList
 */
const se_S3EncryptionList = (input: S3Encryption[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      return se_S3Encryption(entry, context);
    });
};

/**
 * serializeAws_json1_1S3GlueParquetTarget
 */
const se_S3GlueParquetTarget = (input: S3GlueParquetTarget, context: __SerdeContext): any => {
  return {
    ...(input.Compression != null && { Compression: input.Compression }),
    ...(input.Inputs != null && { Inputs: se_OneInput(input.Inputs, context) }),
    ...(input.Name != null && { Name: input.Name }),
    ...(input.PartitionKeys != null && { PartitionKeys: se_GlueStudioPathList(input.PartitionKeys, context) }),
    ...(input.Path != null && { Path: input.Path }),
    ...(input.SchemaChangePolicy != null && {
      SchemaChangePolicy: se_DirectSchemaChangePolicy(input.SchemaChangePolicy, context),
    }),
  };
};

/**
 * serializeAws_json1_1S3HudiCatalogTarget
 */
const se_S3HudiCatalogTarget = (input: S3HudiCatalogTarget, context: __SerdeContext): any => {
  return {
    ...(input.AdditionalOptions != null && {
      AdditionalOptions: se_AdditionalOptions(input.AdditionalOptions, context),
    }),
    ...(input.Database != null && { Database: input.Database }),
    ...(input.Inputs != null && { Inputs: se_OneInput(input.Inputs, context) }),
    ...(input.Name != null && { Name: input.Name }),
    ...(input.PartitionKeys != null && { PartitionKeys: se_GlueStudioPathList(input.PartitionKeys, context) }),
    ...(input.SchemaChangePolicy != null && {
      SchemaChangePolicy: se_CatalogSchemaChangePolicy(input.SchemaChangePolicy, context),
    }),
    ...(input.Table != null && { Table: input.Table }),
  };
};

/**
 * serializeAws_json1_1S3HudiDirectTarget
 */
const se_S3HudiDirectTarget = (input: S3HudiDirectTarget, context: __SerdeContext): any => {
  return {
    ...(input.AdditionalOptions != null && {
      AdditionalOptions: se_AdditionalOptions(input.AdditionalOptions, context),
    }),
    ...(input.Compression != null && { Compression: input.Compression }),
    ...(input.Format != null && { Format: input.Format }),
    ...(input.Inputs != null && { Inputs: se_OneInput(input.Inputs, context) }),
    ...(input.Name != null && { Name: input.Name }),
    ...(input.PartitionKeys != null && { PartitionKeys: se_GlueStudioPathList(input.PartitionKeys, context) }),
    ...(input.Path != null && { Path: input.Path }),
    ...(input.SchemaChangePolicy != null && {
      SchemaChangePolicy: se_DirectSchemaChangePolicy(input.SchemaChangePolicy, context),
    }),
  };
};

/**
 * serializeAws_json1_1S3HudiSource
 */
const se_S3HudiSource = (input: S3HudiSource, context: __SerdeContext): any => {
  return {
    ...(input.AdditionalHudiOptions != null && {
      AdditionalHudiOptions: se_AdditionalOptions(input.AdditionalHudiOptions, context),
    }),
    ...(input.AdditionalOptions != null && {
      AdditionalOptions: se_S3DirectSourceAdditionalOptions(input.AdditionalOptions, context),
    }),
    ...(input.Name != null && { Name: input.Name }),
    ...(input.OutputSchemas != null && { OutputSchemas: se_GlueSchemas(input.OutputSchemas, context) }),
    ...(input.Paths != null && { Paths: se_EnclosedInStringProperties(input.Paths, context) }),
  };
};

/**
 * serializeAws_json1_1S3JsonSource
 */
const se_S3JsonSource = (input: S3JsonSource, context: __SerdeContext): any => {
  return {
    ...(input.AdditionalOptions != null && {
      AdditionalOptions: se_S3DirectSourceAdditionalOptions(input.AdditionalOptions, context),
    }),
    ...(input.CompressionType != null && { CompressionType: input.CompressionType }),
    ...(input.Exclusions != null && { Exclusions: se_EnclosedInStringProperties(input.Exclusions, context) }),
    ...(input.GroupFiles != null && { GroupFiles: input.GroupFiles }),
    ...(input.GroupSize != null && { GroupSize: input.GroupSize }),
    ...(input.JsonPath != null && { JsonPath: input.JsonPath }),
    ...(input.MaxBand != null && { MaxBand: input.MaxBand }),
    ...(input.MaxFilesInBand != null && { MaxFilesInBand: input.MaxFilesInBand }),
    ...(input.Multiline != null && { Multiline: input.Multiline }),
    ...(input.Name != null && { Name: input.Name }),
    ...(input.OutputSchemas != null && { OutputSchemas: se_GlueSchemas(input.OutputSchemas, context) }),
    ...(input.Paths != null && { Paths: se_EnclosedInStringProperties(input.Paths, context) }),
    ...(input.Recurse != null && { Recurse: input.Recurse }),
  };
};

/**
 * serializeAws_json1_1S3ParquetSource
 */
const se_S3ParquetSource = (input: S3ParquetSource, context: __SerdeContext): any => {
  return {
    ...(input.AdditionalOptions != null && {
      AdditionalOptions: se_S3DirectSourceAdditionalOptions(input.AdditionalOptions, context),
    }),
    ...(input.CompressionType != null && { CompressionType: input.CompressionType }),
    ...(input.Exclusions != null && { Exclusions: se_EnclosedInStringProperties(input.Exclusions, context) }),
    ...(input.GroupFiles != null && { GroupFiles: input.GroupFiles }),
    ...(input.GroupSize != null && { GroupSize: input.GroupSize }),
    ...(input.MaxBand != null && { MaxBand: input.MaxBand }),
    ...(input.MaxFilesInBand != null && { MaxFilesInBand: input.MaxFilesInBand }),
    ...(input.Name != null && { Name: input.Name }),
    ...(input.OutputSchemas != null && { OutputSchemas: se_GlueSchemas(input.OutputSchemas, context) }),
    ...(input.Paths != null && { Paths: se_EnclosedInStringProperties(input.Paths, context) }),
    ...(input.Recurse != null && { Recurse: input.Recurse }),
  };
};

/**
 * serializeAws_json1_1S3SourceAdditionalOptions
 */
const se_S3SourceAdditionalOptions = (input: S3SourceAdditionalOptions, context: __SerdeContext): any => {
  return {
    ...(input.BoundedFiles != null && { BoundedFiles: input.BoundedFiles }),
    ...(input.BoundedSize != null && { BoundedSize: input.BoundedSize }),
  };
};

/**
 * serializeAws_json1_1S3Target
 */
const se_S3Target = (input: S3Target, context: __SerdeContext): any => {
  return {
    ...(input.ConnectionName != null && { ConnectionName: input.ConnectionName }),
    ...(input.DlqEventQueueArn != null && { DlqEventQueueArn: input.DlqEventQueueArn }),
    ...(input.EventQueueArn != null && { EventQueueArn: input.EventQueueArn }),
    ...(input.Exclusions != null && { Exclusions: se_PathList(input.Exclusions, context) }),
    ...(input.Path != null && { Path: input.Path }),
    ...(input.SampleSize != null && { SampleSize: input.SampleSize }),
  };
};

/**
 * serializeAws_json1_1S3TargetList
 */
const se_S3TargetList = (input: S3Target[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      return se_S3Target(entry, context);
    });
};

/**
 * serializeAws_json1_1SchemaChangePolicy
 */
const se_SchemaChangePolicy = (input: SchemaChangePolicy, context: __SerdeContext): any => {
  return {
    ...(input.DeleteBehavior != null && { DeleteBehavior: input.DeleteBehavior }),
    ...(input.UpdateBehavior != null && { UpdateBehavior: input.UpdateBehavior }),
  };
};

/**
 * serializeAws_json1_1SchemaColumn
 */
const se_SchemaColumn = (input: SchemaColumn, context: __SerdeContext): any => {
  return {
    ...(input.DataType != null && { DataType: input.DataType }),
    ...(input.Name != null && { Name: input.Name }),
  };
};

/**
 * serializeAws_json1_1SchemaId
 */
const se_SchemaId = (input: SchemaId, context: __SerdeContext): any => {
  return {
    ...(input.RegistryName != null && { RegistryName: input.RegistryName }),
    ...(input.SchemaArn != null && { SchemaArn: input.SchemaArn }),
    ...(input.SchemaName != null && { SchemaName: input.SchemaName }),
  };
};

/**
 * serializeAws_json1_1SchemaReference
 */
const se_SchemaReference = (input: SchemaReference, context: __SerdeContext): any => {
  return {
    ...(input.SchemaId != null && { SchemaId: se_SchemaId(input.SchemaId, context) }),
    ...(input.SchemaVersionId != null && { SchemaVersionId: input.SchemaVersionId }),
    ...(input.SchemaVersionNumber != null && { SchemaVersionNumber: input.SchemaVersionNumber }),
  };
};

/**
 * serializeAws_json1_1SchemaVersionNumber
 */
const se_SchemaVersionNumber = (input: SchemaVersionNumber, context: __SerdeContext): any => {
  return {
    ...(input.LatestVersion != null && { LatestVersion: input.LatestVersion }),
    ...(input.VersionNumber != null && { VersionNumber: input.VersionNumber }),
  };
};

/**
 * serializeAws_json1_1SearchPropertyPredicates
 */
const se_SearchPropertyPredicates = (input: PropertyPredicate[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      return se_PropertyPredicate(entry, context);
    });
};

/**
 * serializeAws_json1_1SearchTablesRequest
 */
const se_SearchTablesRequest = (input: SearchTablesRequest, context: __SerdeContext): any => {
  return {
    ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
    ...(input.Filters != null && { Filters: se_SearchPropertyPredicates(input.Filters, context) }),
    ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
    ...(input.NextToken != null && { NextToken: input.NextToken }),
    ...(input.ResourceShareType != null && { ResourceShareType: input.ResourceShareType }),
    ...(input.SearchText != null && { SearchText: input.SearchText }),
    ...(input.SortCriteria != null && { SortCriteria: se_SortCriteria(input.SortCriteria, context) }),
  };
};

/**
 * serializeAws_json1_1SecurityGroupIdList
 */
const se_SecurityGroupIdList = (input: string[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      return entry;
    });
};

/**
 * serializeAws_json1_1Segment
 */
const se_Segment = (input: Segment, context: __SerdeContext): any => {
  return {
    ...(input.SegmentNumber != null && { SegmentNumber: input.SegmentNumber }),
    ...(input.TotalSegments != null && { TotalSegments: input.TotalSegments }),
  };
};

/**
 * serializeAws_json1_1SelectFields
 */
const se_SelectFields = (input: SelectFields, context: __SerdeContext): any => {
  return {
    ...(input.Inputs != null && { Inputs: se_OneInput(input.Inputs, context) }),
    ...(input.Name != null && { Name: input.Name }),
    ...(input.Paths != null && { Paths: se_GlueStudioPathList(input.Paths, context) }),
  };
};

/**
 * serializeAws_json1_1SelectFromCollection
 */
const se_SelectFromCollection = (input: SelectFromCollection, context: __SerdeContext): any => {
  return {
    ...(input.Index != null && { Index: input.Index }),
    ...(input.Inputs != null && { Inputs: se_OneInput(input.Inputs, context) }),
    ...(input.Name != null && { Name: input.Name }),
  };
};

/**
 * serializeAws_json1_1SerDeInfo
 */
const se_SerDeInfo = (input: SerDeInfo, context: __SerdeContext): any => {
  return {
    ...(input.Name != null && { Name: input.Name }),
    ...(input.Parameters != null && { Parameters: se_ParametersMap(input.Parameters, context) }),
    ...(input.SerializationLibrary != null && { SerializationLibrary: input.SerializationLibrary }),
  };
};

/**
 * serializeAws_json1_1SessionCommand
 */
const se_SessionCommand = (input: SessionCommand, context: __SerdeContext): any => {
  return {
    ...(input.Name != null && { Name: input.Name }),
    ...(input.PythonVersion != null && { PythonVersion: input.PythonVersion }),
  };
};

/**
 * serializeAws_json1_1SkewedInfo
 */
const se_SkewedInfo = (input: SkewedInfo, context: __SerdeContext): any => {
  return {
    ...(input.SkewedColumnNames != null && { SkewedColumnNames: se_NameStringList(input.SkewedColumnNames, context) }),
    ...(input.SkewedColumnValueLocationMaps != null && {
      SkewedColumnValueLocationMaps: se_LocationMap(input.SkewedColumnValueLocationMaps, context),
    }),
    ...(input.SkewedColumnValues != null && {
      SkewedColumnValues: se_ColumnValueStringList(input.SkewedColumnValues, context),
    }),
  };
};

/**
 * serializeAws_json1_1SortCriteria
 */
const se_SortCriteria = (input: SortCriterion[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      return se_SortCriterion(entry, context);
    });
};

/**
 * serializeAws_json1_1SortCriterion
 */
const se_SortCriterion = (input: SortCriterion, context: __SerdeContext): any => {
  return {
    ...(input.FieldName != null && { FieldName: input.FieldName }),
    ...(input.Sort != null && { Sort: input.Sort }),
  };
};

/**
 * serializeAws_json1_1SourceControlDetails
 */
const se_SourceControlDetails = (input: SourceControlDetails, context: __SerdeContext): any => {
  return {
    ...(input.AuthStrategy != null && { AuthStrategy: input.AuthStrategy }),
    ...(input.AuthToken != null && { AuthToken: input.AuthToken }),
    ...(input.Branch != null && { Branch: input.Branch }),
    ...(input.Folder != null && { Folder: input.Folder }),
    ...(input.LastCommitId != null && { LastCommitId: input.LastCommitId }),
    ...(input.Owner != null && { Owner: input.Owner }),
    ...(input.Provider != null && { Provider: input.Provider }),
    ...(input.Repository != null && { Repository: input.Repository }),
  };
};

/**
 * serializeAws_json1_1SparkConnectorSource
 */
const se_SparkConnectorSource = (input: SparkConnectorSource, context: __SerdeContext): any => {
  return {
    ...(input.AdditionalOptions != null && {
      AdditionalOptions: se_AdditionalOptions(input.AdditionalOptions, context),
    }),
    ...(input.ConnectionName != null && { ConnectionName: input.ConnectionName }),
    ...(input.ConnectionType != null && { ConnectionType: input.ConnectionType }),
    ...(input.ConnectorName != null && { ConnectorName: input.ConnectorName }),
    ...(input.Name != null && { Name: input.Name }),
    ...(input.OutputSchemas != null && { OutputSchemas: se_GlueSchemas(input.OutputSchemas, context) }),
  };
};

/**
 * serializeAws_json1_1SparkConnectorTarget
 */
const se_SparkConnectorTarget = (input: SparkConnectorTarget, context: __SerdeContext): any => {
  return {
    ...(input.AdditionalOptions != null && {
      AdditionalOptions: se_AdditionalOptions(input.AdditionalOptions, context),
    }),
    ...(input.ConnectionName != null && { ConnectionName: input.ConnectionName }),
    ...(input.ConnectionType != null && { ConnectionType: input.ConnectionType }),
    ...(input.ConnectorName != null && { ConnectorName: input.ConnectorName }),
    ...(input.Inputs != null && { Inputs: se_OneInput(input.Inputs, context) }),
    ...(input.Name != null && { Name: input.Name }),
    ...(input.OutputSchemas != null && { OutputSchemas: se_GlueSchemas(input.OutputSchemas, context) }),
  };
};

/**
 * serializeAws_json1_1SparkSQL
 */
const se_SparkSQL = (input: SparkSQL, context: __SerdeContext): any => {
  return {
    ...(input.Inputs != null && { Inputs: se_ManyInputs(input.Inputs, context) }),
    ...(input.Name != null && { Name: input.Name }),
    ...(input.OutputSchemas != null && { OutputSchemas: se_GlueSchemas(input.OutputSchemas, context) }),
    ...(input.SqlAliases != null && { SqlAliases: se_SqlAliases(input.SqlAliases, context) }),
    ...(input.SqlQuery != null && { SqlQuery: input.SqlQuery }),
  };
};

/**
 * serializeAws_json1_1Spigot
 */
const se_Spigot = (input: Spigot, context: __SerdeContext): any => {
  return {
    ...(input.Inputs != null && { Inputs: se_OneInput(input.Inputs, context) }),
    ...(input.Name != null && { Name: input.Name }),
    ...(input.Path != null && { Path: input.Path }),
    ...(input.Prob != null && { Prob: __serializeFloat(input.Prob) }),
    ...(input.Topk != null && { Topk: input.Topk }),
  };
};

/**
 * serializeAws_json1_1SplitFields
 */
const se_SplitFields = (input: SplitFields, context: __SerdeContext): any => {
  return {
    ...(input.Inputs != null && { Inputs: se_OneInput(input.Inputs, context) }),
    ...(input.Name != null && { Name: input.Name }),
    ...(input.Paths != null && { Paths: se_GlueStudioPathList(input.Paths, context) }),
  };
};

/**
 * serializeAws_json1_1SqlAlias
 */
const se_SqlAlias = (input: SqlAlias, context: __SerdeContext): any => {
  return {
    ...(input.Alias != null && { Alias: input.Alias }),
    ...(input.From != null && { From: input.From }),
  };
};

/**
 * serializeAws_json1_1SqlAliases
 */
const se_SqlAliases = (input: SqlAlias[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      return se_SqlAlias(entry, context);
    });
};

/**
 * serializeAws_json1_1StartBlueprintRunRequest
 */
const se_StartBlueprintRunRequest = (input: StartBlueprintRunRequest, context: __SerdeContext): any => {
  return {
    ...(input.BlueprintName != null && { BlueprintName: input.BlueprintName }),
    ...(input.Parameters != null && { Parameters: input.Parameters }),
    ...(input.RoleArn != null && { RoleArn: input.RoleArn }),
  };
};

/**
 * serializeAws_json1_1StartCrawlerRequest
 */
const se_StartCrawlerRequest = (input: StartCrawlerRequest, context: __SerdeContext): any => {
  return {
    ...(input.Name != null && { Name: input.Name }),
  };
};

/**
 * serializeAws_json1_1StartCrawlerScheduleRequest
 */
const se_StartCrawlerScheduleRequest = (input: StartCrawlerScheduleRequest, context: __SerdeContext): any => {
  return {
    ...(input.CrawlerName != null && { CrawlerName: input.CrawlerName }),
  };
};

/**
 * serializeAws_json1_1StartDataQualityRuleRecommendationRunRequest
 */
const se_StartDataQualityRuleRecommendationRunRequest = (
  input: StartDataQualityRuleRecommendationRunRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.ClientToken != null && { ClientToken: input.ClientToken }),
    ...(input.CreatedRulesetName != null && { CreatedRulesetName: input.CreatedRulesetName }),
    ...(input.DataSource != null && { DataSource: se_DataSource(input.DataSource, context) }),
    ...(input.NumberOfWorkers != null && { NumberOfWorkers: input.NumberOfWorkers }),
    ...(input.Role != null && { Role: input.Role }),
    ...(input.Timeout != null && { Timeout: input.Timeout }),
  };
};

/**
 * serializeAws_json1_1StartDataQualityRulesetEvaluationRunRequest
 */
const se_StartDataQualityRulesetEvaluationRunRequest = (
  input: StartDataQualityRulesetEvaluationRunRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.AdditionalRunOptions != null && {
      AdditionalRunOptions: se_DataQualityEvaluationRunAdditionalRunOptions(input.AdditionalRunOptions, context),
    }),
    ...(input.ClientToken != null && { ClientToken: input.ClientToken }),
    ...(input.DataSource != null && { DataSource: se_DataSource(input.DataSource, context) }),
    ...(input.NumberOfWorkers != null && { NumberOfWorkers: input.NumberOfWorkers }),
    ...(input.Role != null && { Role: input.Role }),
    ...(input.RulesetNames != null && { RulesetNames: se_RulesetNames(input.RulesetNames, context) }),
    ...(input.Timeout != null && { Timeout: input.Timeout }),
  };
};

/**
 * serializeAws_json1_1StartExportLabelsTaskRunRequest
 */
const se_StartExportLabelsTaskRunRequest = (input: StartExportLabelsTaskRunRequest, context: __SerdeContext): any => {
  return {
    ...(input.OutputS3Path != null && { OutputS3Path: input.OutputS3Path }),
    ...(input.TransformId != null && { TransformId: input.TransformId }),
  };
};

/**
 * serializeAws_json1_1StartImportLabelsTaskRunRequest
 */
const se_StartImportLabelsTaskRunRequest = (input: StartImportLabelsTaskRunRequest, context: __SerdeContext): any => {
  return {
    ...(input.InputS3Path != null && { InputS3Path: input.InputS3Path }),
    ...(input.ReplaceAllLabels != null && { ReplaceAllLabels: input.ReplaceAllLabels }),
    ...(input.TransformId != null && { TransformId: input.TransformId }),
  };
};

/**
 * serializeAws_json1_1StartJobRunRequest
 */
const se_StartJobRunRequest = (input: StartJobRunRequest, context: __SerdeContext): any => {
  return {
    ...(input.AllocatedCapacity != null && { AllocatedCapacity: input.AllocatedCapacity }),
    ...(input.Arguments != null && { Arguments: se_GenericMap(input.Arguments, context) }),
    ...(input.ExecutionClass != null && { ExecutionClass: input.ExecutionClass }),
    ...(input.JobName != null && { JobName: input.JobName }),
    ...(input.JobRunId != null && { JobRunId: input.JobRunId }),
    ...(input.MaxCapacity != null && { MaxCapacity: __serializeFloat(input.MaxCapacity) }),
    ...(input.NotificationProperty != null && {
      NotificationProperty: se_NotificationProperty(input.NotificationProperty, context),
    }),
    ...(input.NumberOfWorkers != null && { NumberOfWorkers: input.NumberOfWorkers }),
    ...(input.SecurityConfiguration != null && { SecurityConfiguration: input.SecurityConfiguration }),
    ...(input.Timeout != null && { Timeout: input.Timeout }),
    ...(input.WorkerType != null && { WorkerType: input.WorkerType }),
  };
};

/**
 * serializeAws_json1_1StartMLEvaluationTaskRunRequest
 */
const se_StartMLEvaluationTaskRunRequest = (input: StartMLEvaluationTaskRunRequest, context: __SerdeContext): any => {
  return {
    ...(input.TransformId != null && { TransformId: input.TransformId }),
  };
};

/**
 * serializeAws_json1_1StartMLLabelingSetGenerationTaskRunRequest
 */
const se_StartMLLabelingSetGenerationTaskRunRequest = (
  input: StartMLLabelingSetGenerationTaskRunRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.OutputS3Path != null && { OutputS3Path: input.OutputS3Path }),
    ...(input.TransformId != null && { TransformId: input.TransformId }),
  };
};

/**
 * serializeAws_json1_1StartTriggerRequest
 */
const se_StartTriggerRequest = (input: StartTriggerRequest, context: __SerdeContext): any => {
  return {
    ...(input.Name != null && { Name: input.Name }),
  };
};

/**
 * serializeAws_json1_1StartWorkflowRunRequest
 */
const se_StartWorkflowRunRequest = (input: StartWorkflowRunRequest, context: __SerdeContext): any => {
  return {
    ...(input.Name != null && { Name: input.Name }),
    ...(input.RunProperties != null && { RunProperties: se_WorkflowRunProperties(input.RunProperties, context) }),
  };
};

/**
 * serializeAws_json1_1StopCrawlerRequest
 */
const se_StopCrawlerRequest = (input: StopCrawlerRequest, context: __SerdeContext): any => {
  return {
    ...(input.Name != null && { Name: input.Name }),
  };
};

/**
 * serializeAws_json1_1StopCrawlerScheduleRequest
 */
const se_StopCrawlerScheduleRequest = (input: StopCrawlerScheduleRequest, context: __SerdeContext): any => {
  return {
    ...(input.CrawlerName != null && { CrawlerName: input.CrawlerName }),
  };
};

/**
 * serializeAws_json1_1StopSessionRequest
 */
const se_StopSessionRequest = (input: StopSessionRequest, context: __SerdeContext): any => {
  return {
    ...(input.Id != null && { Id: input.Id }),
    ...(input.RequestOrigin != null && { RequestOrigin: input.RequestOrigin }),
  };
};

/**
 * serializeAws_json1_1StopTriggerRequest
 */
const se_StopTriggerRequest = (input: StopTriggerRequest, context: __SerdeContext): any => {
  return {
    ...(input.Name != null && { Name: input.Name }),
  };
};

/**
 * serializeAws_json1_1StopWorkflowRunRequest
 */
const se_StopWorkflowRunRequest = (input: StopWorkflowRunRequest, context: __SerdeContext): any => {
  return {
    ...(input.Name != null && { Name: input.Name }),
    ...(input.RunId != null && { RunId: input.RunId }),
  };
};

/**
 * serializeAws_json1_1StorageDescriptor
 */
const se_StorageDescriptor = (input: StorageDescriptor, context: __SerdeContext): any => {
  return {
    ...(input.AdditionalLocations != null && {
      AdditionalLocations: se_LocationStringList(input.AdditionalLocations, context),
    }),
    ...(input.BucketColumns != null && { BucketColumns: se_NameStringList(input.BucketColumns, context) }),
    ...(input.Columns != null && { Columns: se_ColumnList(input.Columns, context) }),
    ...(input.Compressed != null && { Compressed: input.Compressed }),
    ...(input.InputFormat != null && { InputFormat: input.InputFormat }),
    ...(input.Location != null && { Location: input.Location }),
    ...(input.NumberOfBuckets != null && { NumberOfBuckets: input.NumberOfBuckets }),
    ...(input.OutputFormat != null && { OutputFormat: input.OutputFormat }),
    ...(input.Parameters != null && { Parameters: se_ParametersMap(input.Parameters, context) }),
    ...(input.SchemaReference != null && { SchemaReference: se_SchemaReference(input.SchemaReference, context) }),
    ...(input.SerdeInfo != null && { SerdeInfo: se_SerDeInfo(input.SerdeInfo, context) }),
    ...(input.SkewedInfo != null && { SkewedInfo: se_SkewedInfo(input.SkewedInfo, context) }),
    ...(input.SortColumns != null && { SortColumns: se_OrderList(input.SortColumns, context) }),
    ...(input.StoredAsSubDirectories != null && { StoredAsSubDirectories: input.StoredAsSubDirectories }),
  };
};

/**
 * serializeAws_json1_1StreamingDataPreviewOptions
 */
const se_StreamingDataPreviewOptions = (input: StreamingDataPreviewOptions, context: __SerdeContext): any => {
  return {
    ...(input.PollingTime != null && { PollingTime: input.PollingTime }),
    ...(input.RecordPollingLimit != null && { RecordPollingLimit: input.RecordPollingLimit }),
  };
};

/**
 * serializeAws_json1_1StringColumnStatisticsData
 */
const se_StringColumnStatisticsData = (input: StringColumnStatisticsData, context: __SerdeContext): any => {
  return {
    ...(input.AverageLength != null && { AverageLength: __serializeFloat(input.AverageLength) }),
    ...(input.MaximumLength != null && { MaximumLength: input.MaximumLength }),
    ...(input.NumberOfDistinctValues != null && { NumberOfDistinctValues: input.NumberOfDistinctValues }),
    ...(input.NumberOfNulls != null && { NumberOfNulls: input.NumberOfNulls }),
  };
};

/**
 * serializeAws_json1_1StringList
 */
const se_StringList = (input: string[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      return entry;
    });
};

/**
 * serializeAws_json1_1TableIdentifier
 */
const se_TableIdentifier = (input: TableIdentifier, context: __SerdeContext): any => {
  return {
    ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
    ...(input.DatabaseName != null && { DatabaseName: input.DatabaseName }),
    ...(input.Name != null && { Name: input.Name }),
  };
};

/**
 * serializeAws_json1_1TableInput
 */
const se_TableInput = (input: TableInput, context: __SerdeContext): any => {
  return {
    ...(input.Description != null && { Description: input.Description }),
    ...(input.LastAccessTime != null && { LastAccessTime: Math.round(input.LastAccessTime.getTime() / 1000) }),
    ...(input.LastAnalyzedTime != null && { LastAnalyzedTime: Math.round(input.LastAnalyzedTime.getTime() / 1000) }),
    ...(input.Name != null && { Name: input.Name }),
    ...(input.Owner != null && { Owner: input.Owner }),
    ...(input.Parameters != null && { Parameters: se_ParametersMap(input.Parameters, context) }),
    ...(input.PartitionKeys != null && { PartitionKeys: se_ColumnList(input.PartitionKeys, context) }),
    ...(input.Retention != null && { Retention: input.Retention }),
    ...(input.StorageDescriptor != null && {
      StorageDescriptor: se_StorageDescriptor(input.StorageDescriptor, context),
    }),
    ...(input.TableType != null && { TableType: input.TableType }),
    ...(input.TargetTable != null && { TargetTable: se_TableIdentifier(input.TargetTable, context) }),
    ...(input.ViewExpandedText != null && { ViewExpandedText: input.ViewExpandedText }),
    ...(input.ViewOriginalText != null && { ViewOriginalText: input.ViewOriginalText }),
  };
};

/**
 * serializeAws_json1_1TagKeysList
 */
const se_TagKeysList = (input: string[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      return entry;
    });
};

/**
 * serializeAws_json1_1TagResourceRequest
 */
const se_TagResourceRequest = (input: TagResourceRequest, context: __SerdeContext): any => {
  return {
    ...(input.ResourceArn != null && { ResourceArn: input.ResourceArn }),
    ...(input.TagsToAdd != null && { TagsToAdd: se_TagsMap(input.TagsToAdd, context) }),
  };
};

/**
 * serializeAws_json1_1TagsMap
 */
const se_TagsMap = (input: Record<string, string>, context: __SerdeContext): any => {
  return Object.entries(input).reduce((acc: Record<string, any>, [key, value]: [string, any]) => {
    if (value === null) {
      return acc;
    }
    acc[key] = value;
    return acc;
  }, {});
};

/**
 * serializeAws_json1_1TaskRunFilterCriteria
 */
const se_TaskRunFilterCriteria = (input: TaskRunFilterCriteria, context: __SerdeContext): any => {
  return {
    ...(input.StartedAfter != null && { StartedAfter: Math.round(input.StartedAfter.getTime() / 1000) }),
    ...(input.StartedBefore != null && { StartedBefore: Math.round(input.StartedBefore.getTime() / 1000) }),
    ...(input.Status != null && { Status: input.Status }),
    ...(input.TaskRunType != null && { TaskRunType: input.TaskRunType }),
  };
};

/**
 * serializeAws_json1_1TaskRunSortCriteria
 */
const se_TaskRunSortCriteria = (input: TaskRunSortCriteria, context: __SerdeContext): any => {
  return {
    ...(input.Column != null && { Column: input.Column }),
    ...(input.SortDirection != null && { SortDirection: input.SortDirection }),
  };
};

/**
 * serializeAws_json1_1TransformConfigParameter
 */
const se_TransformConfigParameter = (input: TransformConfigParameter, context: __SerdeContext): any => {
  return {
    ...(input.IsOptional != null && { IsOptional: input.IsOptional }),
    ...(input.ListType != null && { ListType: input.ListType }),
    ...(input.Name != null && { Name: input.Name }),
    ...(input.Type != null && { Type: input.Type }),
    ...(input.ValidationMessage != null && { ValidationMessage: input.ValidationMessage }),
    ...(input.ValidationRule != null && { ValidationRule: input.ValidationRule }),
    ...(input.Value != null && { Value: se_EnclosedInStringProperties(input.Value, context) }),
  };
};

/**
 * serializeAws_json1_1TransformConfigParameterList
 */
const se_TransformConfigParameterList = (input: TransformConfigParameter[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      return se_TransformConfigParameter(entry, context);
    });
};

/**
 * serializeAws_json1_1TransformEncryption
 */
const se_TransformEncryption = (input: TransformEncryption, context: __SerdeContext): any => {
  return {
    ...(input.MlUserDataEncryption != null && {
      MlUserDataEncryption: se_MLUserDataEncryption(input.MlUserDataEncryption, context),
    }),
    ...(input.TaskRunSecurityConfigurationName != null && {
      TaskRunSecurityConfigurationName: input.TaskRunSecurityConfigurationName,
    }),
  };
};

/**
 * serializeAws_json1_1TransformFilterCriteria
 */
const se_TransformFilterCriteria = (input: TransformFilterCriteria, context: __SerdeContext): any => {
  return {
    ...(input.CreatedAfter != null && { CreatedAfter: Math.round(input.CreatedAfter.getTime() / 1000) }),
    ...(input.CreatedBefore != null && { CreatedBefore: Math.round(input.CreatedBefore.getTime() / 1000) }),
    ...(input.GlueVersion != null && { GlueVersion: input.GlueVersion }),
    ...(input.LastModifiedAfter != null && { LastModifiedAfter: Math.round(input.LastModifiedAfter.getTime() / 1000) }),
    ...(input.LastModifiedBefore != null && {
      LastModifiedBefore: Math.round(input.LastModifiedBefore.getTime() / 1000),
    }),
    ...(input.Name != null && { Name: input.Name }),
    ...(input.Schema != null && { Schema: se_TransformSchema(input.Schema, context) }),
    ...(input.Status != null && { Status: input.Status }),
    ...(input.TransformType != null && { TransformType: input.TransformType }),
  };
};

/**
 * serializeAws_json1_1TransformParameters
 */
const se_TransformParameters = (input: TransformParameters, context: __SerdeContext): any => {
  return {
    ...(input.FindMatchesParameters != null && {
      FindMatchesParameters: se_FindMatchesParameters(input.FindMatchesParameters, context),
    }),
    ...(input.TransformType != null && { TransformType: input.TransformType }),
  };
};

/**
 * serializeAws_json1_1TransformSchema
 */
const se_TransformSchema = (input: SchemaColumn[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      return se_SchemaColumn(entry, context);
    });
};

/**
 * serializeAws_json1_1TransformSortCriteria
 */
const se_TransformSortCriteria = (input: TransformSortCriteria, context: __SerdeContext): any => {
  return {
    ...(input.Column != null && { Column: input.Column }),
    ...(input.SortDirection != null && { SortDirection: input.SortDirection }),
  };
};

/**
 * serializeAws_json1_1TriggerNameList
 */
const se_TriggerNameList = (input: string[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      return entry;
    });
};

/**
 * serializeAws_json1_1TriggerUpdate
 */
const se_TriggerUpdate = (input: TriggerUpdate, context: __SerdeContext): any => {
  return {
    ...(input.Actions != null && { Actions: se_ActionList(input.Actions, context) }),
    ...(input.Description != null && { Description: input.Description }),
    ...(input.EventBatchingCondition != null && {
      EventBatchingCondition: se_EventBatchingCondition(input.EventBatchingCondition, context),
    }),
    ...(input.Name != null && { Name: input.Name }),
    ...(input.Predicate != null && { Predicate: se_Predicate(input.Predicate, context) }),
    ...(input.Schedule != null && { Schedule: input.Schedule }),
  };
};

/**
 * serializeAws_json1_1TwoInputs
 */
const se_TwoInputs = (input: string[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      return entry;
    });
};

/**
 * serializeAws_json1_1Union
 */
const se_Union = (input: Union, context: __SerdeContext): any => {
  return {
    ...(input.Inputs != null && { Inputs: se_TwoInputs(input.Inputs, context) }),
    ...(input.Name != null && { Name: input.Name }),
    ...(input.UnionType != null && { UnionType: input.UnionType }),
  };
};

/**
 * serializeAws_json1_1UntagResourceRequest
 */
const se_UntagResourceRequest = (input: UntagResourceRequest, context: __SerdeContext): any => {
  return {
    ...(input.ResourceArn != null && { ResourceArn: input.ResourceArn }),
    ...(input.TagsToRemove != null && { TagsToRemove: se_TagKeysList(input.TagsToRemove, context) }),
  };
};

/**
 * serializeAws_json1_1UpdateBlueprintRequest
 */
const se_UpdateBlueprintRequest = (input: UpdateBlueprintRequest, context: __SerdeContext): any => {
  return {
    ...(input.BlueprintLocation != null && { BlueprintLocation: input.BlueprintLocation }),
    ...(input.Description != null && { Description: input.Description }),
    ...(input.Name != null && { Name: input.Name }),
  };
};

/**
 * serializeAws_json1_1UpdateClassifierRequest
 */
const se_UpdateClassifierRequest = (input: UpdateClassifierRequest, context: __SerdeContext): any => {
  return {
    ...(input.CsvClassifier != null && { CsvClassifier: se_UpdateCsvClassifierRequest(input.CsvClassifier, context) }),
    ...(input.GrokClassifier != null && {
      GrokClassifier: se_UpdateGrokClassifierRequest(input.GrokClassifier, context),
    }),
    ...(input.JsonClassifier != null && {
      JsonClassifier: se_UpdateJsonClassifierRequest(input.JsonClassifier, context),
    }),
    ...(input.XMLClassifier != null && { XMLClassifier: se_UpdateXMLClassifierRequest(input.XMLClassifier, context) }),
  };
};

/**
 * serializeAws_json1_1UpdateColumnStatisticsForPartitionRequest
 */
const se_UpdateColumnStatisticsForPartitionRequest = (
  input: UpdateColumnStatisticsForPartitionRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
    ...(input.ColumnStatisticsList != null && {
      ColumnStatisticsList: se_UpdateColumnStatisticsList(input.ColumnStatisticsList, context),
    }),
    ...(input.DatabaseName != null && { DatabaseName: input.DatabaseName }),
    ...(input.PartitionValues != null && { PartitionValues: se_ValueStringList(input.PartitionValues, context) }),
    ...(input.TableName != null && { TableName: input.TableName }),
  };
};

/**
 * serializeAws_json1_1UpdateColumnStatisticsForTableRequest
 */
const se_UpdateColumnStatisticsForTableRequest = (
  input: UpdateColumnStatisticsForTableRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
    ...(input.ColumnStatisticsList != null && {
      ColumnStatisticsList: se_UpdateColumnStatisticsList(input.ColumnStatisticsList, context),
    }),
    ...(input.DatabaseName != null && { DatabaseName: input.DatabaseName }),
    ...(input.TableName != null && { TableName: input.TableName }),
  };
};

/**
 * serializeAws_json1_1UpdateColumnStatisticsList
 */
const se_UpdateColumnStatisticsList = (input: ColumnStatistics[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      return se_ColumnStatistics(entry, context);
    });
};

/**
 * serializeAws_json1_1UpdateConnectionRequest
 */
const se_UpdateConnectionRequest = (input: UpdateConnectionRequest, context: __SerdeContext): any => {
  return {
    ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
    ...(input.ConnectionInput != null && { ConnectionInput: se_ConnectionInput(input.ConnectionInput, context) }),
    ...(input.Name != null && { Name: input.Name }),
  };
};

/**
 * serializeAws_json1_1UpdateCrawlerRequest
 */
const se_UpdateCrawlerRequest = (input: UpdateCrawlerRequest, context: __SerdeContext): any => {
  return {
    ...(input.Classifiers != null && { Classifiers: se_ClassifierNameList(input.Classifiers, context) }),
    ...(input.Configuration != null && { Configuration: input.Configuration }),
    ...(input.CrawlerSecurityConfiguration != null && {
      CrawlerSecurityConfiguration: input.CrawlerSecurityConfiguration,
    }),
    ...(input.DatabaseName != null && { DatabaseName: input.DatabaseName }),
    ...(input.Description != null && { Description: input.Description }),
    ...(input.LakeFormationConfiguration != null && {
      LakeFormationConfiguration: se_LakeFormationConfiguration(input.LakeFormationConfiguration, context),
    }),
    ...(input.LineageConfiguration != null && {
      LineageConfiguration: se_LineageConfiguration(input.LineageConfiguration, context),
    }),
    ...(input.Name != null && { Name: input.Name }),
    ...(input.RecrawlPolicy != null && { RecrawlPolicy: se_RecrawlPolicy(input.RecrawlPolicy, context) }),
    ...(input.Role != null && { Role: input.Role }),
    ...(input.Schedule != null && { Schedule: input.Schedule }),
    ...(input.SchemaChangePolicy != null && {
      SchemaChangePolicy: se_SchemaChangePolicy(input.SchemaChangePolicy, context),
    }),
    ...(input.TablePrefix != null && { TablePrefix: input.TablePrefix }),
    ...(input.Targets != null && { Targets: se_CrawlerTargets(input.Targets, context) }),
  };
};

/**
 * serializeAws_json1_1UpdateCrawlerScheduleRequest
 */
const se_UpdateCrawlerScheduleRequest = (input: UpdateCrawlerScheduleRequest, context: __SerdeContext): any => {
  return {
    ...(input.CrawlerName != null && { CrawlerName: input.CrawlerName }),
    ...(input.Schedule != null && { Schedule: input.Schedule }),
  };
};

/**
 * serializeAws_json1_1UpdateCsvClassifierRequest
 */
const se_UpdateCsvClassifierRequest = (input: UpdateCsvClassifierRequest, context: __SerdeContext): any => {
  return {
    ...(input.AllowSingleColumn != null && { AllowSingleColumn: input.AllowSingleColumn }),
    ...(input.ContainsHeader != null && { ContainsHeader: input.ContainsHeader }),
    ...(input.CustomDatatypeConfigured != null && { CustomDatatypeConfigured: input.CustomDatatypeConfigured }),
    ...(input.CustomDatatypes != null && { CustomDatatypes: se_CustomDatatypes(input.CustomDatatypes, context) }),
    ...(input.Delimiter != null && { Delimiter: input.Delimiter }),
    ...(input.DisableValueTrimming != null && { DisableValueTrimming: input.DisableValueTrimming }),
    ...(input.Header != null && { Header: se_CsvHeader(input.Header, context) }),
    ...(input.Name != null && { Name: input.Name }),
    ...(input.QuoteSymbol != null && { QuoteSymbol: input.QuoteSymbol }),
  };
};

/**
 * serializeAws_json1_1UpdateDatabaseRequest
 */
const se_UpdateDatabaseRequest = (input: UpdateDatabaseRequest, context: __SerdeContext): any => {
  return {
    ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
    ...(input.DatabaseInput != null && { DatabaseInput: se_DatabaseInput(input.DatabaseInput, context) }),
    ...(input.Name != null && { Name: input.Name }),
  };
};

/**
 * serializeAws_json1_1UpdateDataQualityRulesetRequest
 */
const se_UpdateDataQualityRulesetRequest = (input: UpdateDataQualityRulesetRequest, context: __SerdeContext): any => {
  return {
    ...(input.Description != null && { Description: input.Description }),
    ...(input.Name != null && { Name: input.Name }),
    ...(input.Ruleset != null && { Ruleset: input.Ruleset }),
  };
};

/**
 * serializeAws_json1_1UpdateDevEndpointRequest
 */
const se_UpdateDevEndpointRequest = (input: UpdateDevEndpointRequest, context: __SerdeContext): any => {
  return {
    ...(input.AddArguments != null && { AddArguments: se_MapValue(input.AddArguments, context) }),
    ...(input.AddPublicKeys != null && { AddPublicKeys: se_PublicKeysList(input.AddPublicKeys, context) }),
    ...(input.CustomLibraries != null && {
      CustomLibraries: se_DevEndpointCustomLibraries(input.CustomLibraries, context),
    }),
    ...(input.DeleteArguments != null && { DeleteArguments: se_StringList(input.DeleteArguments, context) }),
    ...(input.DeletePublicKeys != null && { DeletePublicKeys: se_PublicKeysList(input.DeletePublicKeys, context) }),
    ...(input.EndpointName != null && { EndpointName: input.EndpointName }),
    ...(input.PublicKey != null && { PublicKey: input.PublicKey }),
    ...(input.UpdateEtlLibraries != null && { UpdateEtlLibraries: input.UpdateEtlLibraries }),
  };
};

/**
 * serializeAws_json1_1UpdateGrokClassifierRequest
 */
const se_UpdateGrokClassifierRequest = (input: UpdateGrokClassifierRequest, context: __SerdeContext): any => {
  return {
    ...(input.Classification != null && { Classification: input.Classification }),
    ...(input.CustomPatterns != null && { CustomPatterns: input.CustomPatterns }),
    ...(input.GrokPattern != null && { GrokPattern: input.GrokPattern }),
    ...(input.Name != null && { Name: input.Name }),
  };
};

/**
 * serializeAws_json1_1UpdateJobFromSourceControlRequest
 */
const se_UpdateJobFromSourceControlRequest = (
  input: UpdateJobFromSourceControlRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.AuthStrategy != null && { AuthStrategy: input.AuthStrategy }),
    ...(input.AuthToken != null && { AuthToken: input.AuthToken }),
    ...(input.BranchName != null && { BranchName: input.BranchName }),
    ...(input.CommitId != null && { CommitId: input.CommitId }),
    ...(input.Folder != null && { Folder: input.Folder }),
    ...(input.JobName != null && { JobName: input.JobName }),
    ...(input.Provider != null && { Provider: input.Provider }),
    ...(input.RepositoryName != null && { RepositoryName: input.RepositoryName }),
    ...(input.RepositoryOwner != null && { RepositoryOwner: input.RepositoryOwner }),
  };
};

/**
 * serializeAws_json1_1UpdateJobRequest
 */
const se_UpdateJobRequest = (input: UpdateJobRequest, context: __SerdeContext): any => {
  return {
    ...(input.JobName != null && { JobName: input.JobName }),
    ...(input.JobUpdate != null && { JobUpdate: se_JobUpdate(input.JobUpdate, context) }),
  };
};

/**
 * serializeAws_json1_1UpdateJsonClassifierRequest
 */
const se_UpdateJsonClassifierRequest = (input: UpdateJsonClassifierRequest, context: __SerdeContext): any => {
  return {
    ...(input.JsonPath != null && { JsonPath: input.JsonPath }),
    ...(input.Name != null && { Name: input.Name }),
  };
};

/**
 * serializeAws_json1_1UpdateMLTransformRequest
 */
const se_UpdateMLTransformRequest = (input: UpdateMLTransformRequest, context: __SerdeContext): any => {
  return {
    ...(input.Description != null && { Description: input.Description }),
    ...(input.GlueVersion != null && { GlueVersion: input.GlueVersion }),
    ...(input.MaxCapacity != null && { MaxCapacity: __serializeFloat(input.MaxCapacity) }),
    ...(input.MaxRetries != null && { MaxRetries: input.MaxRetries }),
    ...(input.Name != null && { Name: input.Name }),
    ...(input.NumberOfWorkers != null && { NumberOfWorkers: input.NumberOfWorkers }),
    ...(input.Parameters != null && { Parameters: se_TransformParameters(input.Parameters, context) }),
    ...(input.Role != null && { Role: input.Role }),
    ...(input.Timeout != null && { Timeout: input.Timeout }),
    ...(input.TransformId != null && { TransformId: input.TransformId }),
    ...(input.WorkerType != null && { WorkerType: input.WorkerType }),
  };
};

/**
 * serializeAws_json1_1UpdatePartitionRequest
 */
const se_UpdatePartitionRequest = (input: UpdatePartitionRequest, context: __SerdeContext): any => {
  return {
    ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
    ...(input.DatabaseName != null && { DatabaseName: input.DatabaseName }),
    ...(input.PartitionInput != null && { PartitionInput: se_PartitionInput(input.PartitionInput, context) }),
    ...(input.PartitionValueList != null && {
      PartitionValueList: se_BoundedPartitionValueList(input.PartitionValueList, context),
    }),
    ...(input.TableName != null && { TableName: input.TableName }),
  };
};

/**
 * serializeAws_json1_1UpdateRegistryInput
 */
const se_UpdateRegistryInput = (input: UpdateRegistryInput, context: __SerdeContext): any => {
  return {
    ...(input.Description != null && { Description: input.Description }),
    ...(input.RegistryId != null && { RegistryId: se_RegistryId(input.RegistryId, context) }),
  };
};

/**
 * serializeAws_json1_1UpdateSchemaInput
 */
const se_UpdateSchemaInput = (input: UpdateSchemaInput, context: __SerdeContext): any => {
  return {
    ...(input.Compatibility != null && { Compatibility: input.Compatibility }),
    ...(input.Description != null && { Description: input.Description }),
    ...(input.SchemaId != null && { SchemaId: se_SchemaId(input.SchemaId, context) }),
    ...(input.SchemaVersionNumber != null && {
      SchemaVersionNumber: se_SchemaVersionNumber(input.SchemaVersionNumber, context),
    }),
  };
};

/**
 * serializeAws_json1_1UpdateSourceControlFromJobRequest
 */
const se_UpdateSourceControlFromJobRequest = (
  input: UpdateSourceControlFromJobRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.AuthStrategy != null && { AuthStrategy: input.AuthStrategy }),
    ...(input.AuthToken != null && { AuthToken: input.AuthToken }),
    ...(input.BranchName != null && { BranchName: input.BranchName }),
    ...(input.CommitId != null && { CommitId: input.CommitId }),
    ...(input.Folder != null && { Folder: input.Folder }),
    ...(input.JobName != null && { JobName: input.JobName }),
    ...(input.Provider != null && { Provider: input.Provider }),
    ...(input.RepositoryName != null && { RepositoryName: input.RepositoryName }),
    ...(input.RepositoryOwner != null && { RepositoryOwner: input.RepositoryOwner }),
  };
};

/**
 * serializeAws_json1_1UpdateTableRequest
 */
const se_UpdateTableRequest = (input: UpdateTableRequest, context: __SerdeContext): any => {
  return {
    ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
    ...(input.DatabaseName != null && { DatabaseName: input.DatabaseName }),
    ...(input.SkipArchive != null && { SkipArchive: input.SkipArchive }),
    ...(input.TableInput != null && { TableInput: se_TableInput(input.TableInput, context) }),
    ...(input.TransactionId != null && { TransactionId: input.TransactionId }),
    ...(input.VersionId != null && { VersionId: input.VersionId }),
  };
};

/**
 * serializeAws_json1_1UpdateTriggerRequest
 */
const se_UpdateTriggerRequest = (input: UpdateTriggerRequest, context: __SerdeContext): any => {
  return {
    ...(input.Name != null && { Name: input.Name }),
    ...(input.TriggerUpdate != null && { TriggerUpdate: se_TriggerUpdate(input.TriggerUpdate, context) }),
  };
};

/**
 * serializeAws_json1_1UpdateUserDefinedFunctionRequest
 */
const se_UpdateUserDefinedFunctionRequest = (input: UpdateUserDefinedFunctionRequest, context: __SerdeContext): any => {
  return {
    ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
    ...(input.DatabaseName != null && { DatabaseName: input.DatabaseName }),
    ...(input.FunctionInput != null && { FunctionInput: se_UserDefinedFunctionInput(input.FunctionInput, context) }),
    ...(input.FunctionName != null && { FunctionName: input.FunctionName }),
  };
};

/**
 * serializeAws_json1_1UpdateWorkflowRequest
 */
const se_UpdateWorkflowRequest = (input: UpdateWorkflowRequest, context: __SerdeContext): any => {
  return {
    ...(input.DefaultRunProperties != null && {
      DefaultRunProperties: se_WorkflowRunProperties(input.DefaultRunProperties, context),
    }),
    ...(input.Description != null && { Description: input.Description }),
    ...(input.MaxConcurrentRuns != null && { MaxConcurrentRuns: input.MaxConcurrentRuns }),
    ...(input.Name != null && { Name: input.Name }),
  };
};

/**
 * serializeAws_json1_1UpdateXMLClassifierRequest
 */
const se_UpdateXMLClassifierRequest = (input: UpdateXMLClassifierRequest, context: __SerdeContext): any => {
  return {
    ...(input.Classification != null && { Classification: input.Classification }),
    ...(input.Name != null && { Name: input.Name }),
    ...(input.RowTag != null && { RowTag: input.RowTag }),
  };
};

/**
 * serializeAws_json1_1UpsertRedshiftTargetOptions
 */
const se_UpsertRedshiftTargetOptions = (input: UpsertRedshiftTargetOptions, context: __SerdeContext): any => {
  return {
    ...(input.ConnectionName != null && { ConnectionName: input.ConnectionName }),
    ...(input.TableLocation != null && { TableLocation: input.TableLocation }),
    ...(input.UpsertKeys != null && { UpsertKeys: se_EnclosedInStringPropertiesMinOne(input.UpsertKeys, context) }),
  };
};

/**
 * serializeAws_json1_1UserDefinedFunctionInput
 */
const se_UserDefinedFunctionInput = (input: UserDefinedFunctionInput, context: __SerdeContext): any => {
  return {
    ...(input.ClassName != null && { ClassName: input.ClassName }),
    ...(input.FunctionName != null && { FunctionName: input.FunctionName }),
    ...(input.OwnerName != null && { OwnerName: input.OwnerName }),
    ...(input.OwnerType != null && { OwnerType: input.OwnerType }),
    ...(input.ResourceUris != null && { ResourceUris: se_ResourceUriList(input.ResourceUris, context) }),
  };
};

/**
 * serializeAws_json1_1ValueStringList
 */
const se_ValueStringList = (input: string[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      return entry;
    });
};

/**
 * serializeAws_json1_1WorkflowNames
 */
const se_WorkflowNames = (input: string[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      return entry;
    });
};

/**
 * serializeAws_json1_1WorkflowRunProperties
 */
const se_WorkflowRunProperties = (input: Record<string, string>, context: __SerdeContext): any => {
  return Object.entries(input).reduce((acc: Record<string, any>, [key, value]: [string, any]) => {
    if (value === null) {
      return acc;
    }
    acc[key] = value;
    return acc;
  }, {});
};

/**
 * deserializeAws_json1_1AccessDeniedException
 */
const de_AccessDeniedException = (output: any, context: __SerdeContext): AccessDeniedException => {
  return {
    Message: __expectString(output.Message),
  } as any;
};

/**
 * deserializeAws_json1_1Action
 */
const de_Action = (output: any, context: __SerdeContext): Action => {
  return {
    Arguments: output.Arguments != null ? de_GenericMap(output.Arguments, context) : undefined,
    CrawlerName: __expectString(output.CrawlerName),
    JobName: __expectString(output.JobName),
    NotificationProperty:
      output.NotificationProperty != null ? de_NotificationProperty(output.NotificationProperty, context) : undefined,
    SecurityConfiguration: __expectString(output.SecurityConfiguration),
    Timeout: __expectInt32(output.Timeout),
  } as any;
};

/**
 * deserializeAws_json1_1ActionList
 */
const de_ActionList = (output: any, context: __SerdeContext): Action[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return de_Action(entry, context);
    });
  return retVal;
};

/**
 * deserializeAws_json1_1AdditionalOptions
 */
const de_AdditionalOptions = (output: any, context: __SerdeContext): Record<string, string> => {
  return Object.entries(output).reduce((acc: Record<string, string>, [key, value]: [string, any]) => {
    if (value === null) {
      return acc;
    }
    acc[key] = __expectString(value) as any;
    return acc;
  }, {});
};

/**
 * deserializeAws_json1_1Aggregate
 */
const de_Aggregate = (output: any, context: __SerdeContext): Aggregate => {
  return {
    Aggs: output.Aggs != null ? de_AggregateOperations(output.Aggs, context) : undefined,
    Groups: output.Groups != null ? de_GlueStudioPathList(output.Groups, context) : undefined,
    Inputs: output.Inputs != null ? de_OneInput(output.Inputs, context) : undefined,
    Name: __expectString(output.Name),
  } as any;
};

/**
 * deserializeAws_json1_1AggregateOperation
 */
const de_AggregateOperation = (output: any, context: __SerdeContext): AggregateOperation => {
  return {
    AggFunc: __expectString(output.AggFunc),
    Column: output.Column != null ? de_EnclosedInStringProperties(output.Column, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1AggregateOperations
 */
const de_AggregateOperations = (output: any, context: __SerdeContext): AggregateOperation[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return de_AggregateOperation(entry, context);
    });
  return retVal;
};

/**
 * deserializeAws_json1_1AlreadyExistsException
 */
const de_AlreadyExistsException = (output: any, context: __SerdeContext): AlreadyExistsException => {
  return {
    Message: __expectString(output.Message),
  } as any;
};

/**
 * deserializeAws_json1_1ApplyMapping
 */
const de_ApplyMapping = (output: any, context: __SerdeContext): ApplyMapping => {
  return {
    Inputs: output.Inputs != null ? de_OneInput(output.Inputs, context) : undefined,
    Mapping: output.Mapping != null ? de_Mappings(output.Mapping, context) : undefined,
    Name: __expectString(output.Name),
  } as any;
};

/**
 * deserializeAws_json1_1AthenaConnectorSource
 */
const de_AthenaConnectorSource = (output: any, context: __SerdeContext): AthenaConnectorSource => {
  return {
    ConnectionName: __expectString(output.ConnectionName),
    ConnectionTable: __expectString(output.ConnectionTable),
    ConnectionType: __expectString(output.ConnectionType),
    ConnectorName: __expectString(output.ConnectorName),
    Name: __expectString(output.Name),
    OutputSchemas: output.OutputSchemas != null ? de_GlueSchemas(output.OutputSchemas, context) : undefined,
    SchemaName: __expectString(output.SchemaName),
  } as any;
};

/**
 * deserializeAws_json1_1BackfillError
 */
const de_BackfillError = (output: any, context: __SerdeContext): BackfillError => {
  return {
    Code: __expectString(output.Code),
    Partitions: output.Partitions != null ? de_BackfillErroredPartitionsList(output.Partitions, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1BackfillErroredPartitionsList
 */
const de_BackfillErroredPartitionsList = (output: any, context: __SerdeContext): PartitionValueList[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return de_PartitionValueList(entry, context);
    });
  return retVal;
};

/**
 * deserializeAws_json1_1BackfillErrors
 */
const de_BackfillErrors = (output: any, context: __SerdeContext): BackfillError[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return de_BackfillError(entry, context);
    });
  return retVal;
};

/**
 * deserializeAws_json1_1BasicCatalogTarget
 */
const de_BasicCatalogTarget = (output: any, context: __SerdeContext): BasicCatalogTarget => {
  return {
    Database: __expectString(output.Database),
    Inputs: output.Inputs != null ? de_OneInput(output.Inputs, context) : undefined,
    Name: __expectString(output.Name),
    Table: __expectString(output.Table),
  } as any;
};

/**
 * deserializeAws_json1_1BatchCreatePartitionResponse
 */
const de_BatchCreatePartitionResponse = (output: any, context: __SerdeContext): BatchCreatePartitionResponse => {
  return {
    Errors: output.Errors != null ? de_PartitionErrors(output.Errors, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1BatchDeleteConnectionResponse
 */
const de_BatchDeleteConnectionResponse = (output: any, context: __SerdeContext): BatchDeleteConnectionResponse => {
  return {
    Errors: output.Errors != null ? de_ErrorByName(output.Errors, context) : undefined,
    Succeeded: output.Succeeded != null ? de_NameStringList(output.Succeeded, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1BatchDeletePartitionResponse
 */
const de_BatchDeletePartitionResponse = (output: any, context: __SerdeContext): BatchDeletePartitionResponse => {
  return {
    Errors: output.Errors != null ? de_PartitionErrors(output.Errors, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1BatchDeleteTableResponse
 */
const de_BatchDeleteTableResponse = (output: any, context: __SerdeContext): BatchDeleteTableResponse => {
  return {
    Errors: output.Errors != null ? de_TableErrors(output.Errors, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1BatchDeleteTableVersionResponse
 */
const de_BatchDeleteTableVersionResponse = (output: any, context: __SerdeContext): BatchDeleteTableVersionResponse => {
  return {
    Errors: output.Errors != null ? de_TableVersionErrors(output.Errors, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1BatchGetBlueprintsResponse
 */
const de_BatchGetBlueprintsResponse = (output: any, context: __SerdeContext): BatchGetBlueprintsResponse => {
  return {
    Blueprints: output.Blueprints != null ? de_Blueprints(output.Blueprints, context) : undefined,
    MissingBlueprints:
      output.MissingBlueprints != null ? de_BlueprintNames(output.MissingBlueprints, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1BatchGetCrawlersResponse
 */
const de_BatchGetCrawlersResponse = (output: any, context: __SerdeContext): BatchGetCrawlersResponse => {
  return {
    Crawlers: output.Crawlers != null ? de_CrawlerList(output.Crawlers, context) : undefined,
    CrawlersNotFound:
      output.CrawlersNotFound != null ? de_CrawlerNameList(output.CrawlersNotFound, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1BatchGetCustomEntityTypesResponse
 */
const de_BatchGetCustomEntityTypesResponse = (
  output: any,
  context: __SerdeContext
): BatchGetCustomEntityTypesResponse => {
  return {
    CustomEntityTypes:
      output.CustomEntityTypes != null ? de_CustomEntityTypes(output.CustomEntityTypes, context) : undefined,
    CustomEntityTypesNotFound:
      output.CustomEntityTypesNotFound != null
        ? de_CustomEntityTypeNames(output.CustomEntityTypesNotFound, context)
        : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1BatchGetDataQualityResultResponse
 */
const de_BatchGetDataQualityResultResponse = (
  output: any,
  context: __SerdeContext
): BatchGetDataQualityResultResponse => {
  return {
    Results: output.Results != null ? de_DataQualityResultsList(output.Results, context) : undefined,
    ResultsNotFound:
      output.ResultsNotFound != null ? de_DataQualityResultIds(output.ResultsNotFound, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1BatchGetDevEndpointsResponse
 */
const de_BatchGetDevEndpointsResponse = (output: any, context: __SerdeContext): BatchGetDevEndpointsResponse => {
  return {
    DevEndpoints: output.DevEndpoints != null ? de_DevEndpointList(output.DevEndpoints, context) : undefined,
    DevEndpointsNotFound:
      output.DevEndpointsNotFound != null ? de_DevEndpointNames(output.DevEndpointsNotFound, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1BatchGetJobsResponse
 */
const de_BatchGetJobsResponse = (output: any, context: __SerdeContext): BatchGetJobsResponse => {
  return {
    Jobs: output.Jobs != null ? de_JobList(output.Jobs, context) : undefined,
    JobsNotFound: output.JobsNotFound != null ? de_JobNameList(output.JobsNotFound, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1BatchGetPartitionResponse
 */
const de_BatchGetPartitionResponse = (output: any, context: __SerdeContext): BatchGetPartitionResponse => {
  return {
    Partitions: output.Partitions != null ? de_PartitionList(output.Partitions, context) : undefined,
    UnprocessedKeys:
      output.UnprocessedKeys != null ? de_BatchGetPartitionValueList(output.UnprocessedKeys, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1BatchGetPartitionValueList
 */
const de_BatchGetPartitionValueList = (output: any, context: __SerdeContext): PartitionValueList[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return de_PartitionValueList(entry, context);
    });
  return retVal;
};

/**
 * deserializeAws_json1_1BatchGetTriggersResponse
 */
const de_BatchGetTriggersResponse = (output: any, context: __SerdeContext): BatchGetTriggersResponse => {
  return {
    Triggers: output.Triggers != null ? de_TriggerList(output.Triggers, context) : undefined,
    TriggersNotFound:
      output.TriggersNotFound != null ? de_TriggerNameList(output.TriggersNotFound, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1BatchGetWorkflowsResponse
 */
const de_BatchGetWorkflowsResponse = (output: any, context: __SerdeContext): BatchGetWorkflowsResponse => {
  return {
    MissingWorkflows: output.MissingWorkflows != null ? de_WorkflowNames(output.MissingWorkflows, context) : undefined,
    Workflows: output.Workflows != null ? de_Workflows(output.Workflows, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1BatchStopJobRunError
 */
const de_BatchStopJobRunError = (output: any, context: __SerdeContext): BatchStopJobRunError => {
  return {
    ErrorDetail: output.ErrorDetail != null ? de_ErrorDetail(output.ErrorDetail, context) : undefined,
    JobName: __expectString(output.JobName),
    JobRunId: __expectString(output.JobRunId),
  } as any;
};

/**
 * deserializeAws_json1_1BatchStopJobRunErrorList
 */
const de_BatchStopJobRunErrorList = (output: any, context: __SerdeContext): BatchStopJobRunError[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return de_BatchStopJobRunError(entry, context);
    });
  return retVal;
};

/**
 * deserializeAws_json1_1BatchStopJobRunResponse
 */
const de_BatchStopJobRunResponse = (output: any, context: __SerdeContext): BatchStopJobRunResponse => {
  return {
    Errors: output.Errors != null ? de_BatchStopJobRunErrorList(output.Errors, context) : undefined,
    SuccessfulSubmissions:
      output.SuccessfulSubmissions != null
        ? de_BatchStopJobRunSuccessfulSubmissionList(output.SuccessfulSubmissions, context)
        : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1BatchStopJobRunSuccessfulSubmission
 */
const de_BatchStopJobRunSuccessfulSubmission = (
  output: any,
  context: __SerdeContext
): BatchStopJobRunSuccessfulSubmission => {
  return {
    JobName: __expectString(output.JobName),
    JobRunId: __expectString(output.JobRunId),
  } as any;
};

/**
 * deserializeAws_json1_1BatchStopJobRunSuccessfulSubmissionList
 */
const de_BatchStopJobRunSuccessfulSubmissionList = (
  output: any,
  context: __SerdeContext
): BatchStopJobRunSuccessfulSubmission[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return de_BatchStopJobRunSuccessfulSubmission(entry, context);
    });
  return retVal;
};

/**
 * deserializeAws_json1_1BatchUpdatePartitionFailureEntry
 */
const de_BatchUpdatePartitionFailureEntry = (
  output: any,
  context: __SerdeContext
): BatchUpdatePartitionFailureEntry => {
  return {
    ErrorDetail: output.ErrorDetail != null ? de_ErrorDetail(output.ErrorDetail, context) : undefined,
    PartitionValueList:
      output.PartitionValueList != null ? de_BoundedPartitionValueList(output.PartitionValueList, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1BatchUpdatePartitionFailureList
 */
const de_BatchUpdatePartitionFailureList = (
  output: any,
  context: __SerdeContext
): BatchUpdatePartitionFailureEntry[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return de_BatchUpdatePartitionFailureEntry(entry, context);
    });
  return retVal;
};

/**
 * deserializeAws_json1_1BatchUpdatePartitionResponse
 */
const de_BatchUpdatePartitionResponse = (output: any, context: __SerdeContext): BatchUpdatePartitionResponse => {
  return {
    Errors: output.Errors != null ? de_BatchUpdatePartitionFailureList(output.Errors, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1BinaryColumnStatisticsData
 */
const de_BinaryColumnStatisticsData = (output: any, context: __SerdeContext): BinaryColumnStatisticsData => {
  return {
    AverageLength: __limitedParseDouble(output.AverageLength),
    MaximumLength: __expectLong(output.MaximumLength),
    NumberOfNulls: __expectLong(output.NumberOfNulls),
  } as any;
};

/**
 * deserializeAws_json1_1Blueprint
 */
const de_Blueprint = (output: any, context: __SerdeContext): Blueprint => {
  return {
    BlueprintLocation: __expectString(output.BlueprintLocation),
    BlueprintServiceLocation: __expectString(output.BlueprintServiceLocation),
    CreatedOn:
      output.CreatedOn != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.CreatedOn))) : undefined,
    Description: __expectString(output.Description),
    ErrorMessage: __expectString(output.ErrorMessage),
    LastActiveDefinition:
      output.LastActiveDefinition != null ? de_LastActiveDefinition(output.LastActiveDefinition, context) : undefined,
    LastModifiedOn:
      output.LastModifiedOn != null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.LastModifiedOn)))
        : undefined,
    Name: __expectString(output.Name),
    ParameterSpec: __expectString(output.ParameterSpec),
    Status: __expectString(output.Status),
  } as any;
};

/**
 * deserializeAws_json1_1BlueprintDetails
 */
const de_BlueprintDetails = (output: any, context: __SerdeContext): BlueprintDetails => {
  return {
    BlueprintName: __expectString(output.BlueprintName),
    RunId: __expectString(output.RunId),
  } as any;
};

/**
 * deserializeAws_json1_1BlueprintNames
 */
const de_BlueprintNames = (output: any, context: __SerdeContext): string[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return __expectString(entry) as any;
    });
  return retVal;
};

/**
 * deserializeAws_json1_1BlueprintRun
 */
const de_BlueprintRun = (output: any, context: __SerdeContext): BlueprintRun => {
  return {
    BlueprintName: __expectString(output.BlueprintName),
    CompletedOn:
      output.CompletedOn != null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.CompletedOn)))
        : undefined,
    ErrorMessage: __expectString(output.ErrorMessage),
    Parameters: __expectString(output.Parameters),
    RoleArn: __expectString(output.RoleArn),
    RollbackErrorMessage: __expectString(output.RollbackErrorMessage),
    RunId: __expectString(output.RunId),
    StartedOn:
      output.StartedOn != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.StartedOn))) : undefined,
    State: __expectString(output.State),
    WorkflowName: __expectString(output.WorkflowName),
  } as any;
};

/**
 * deserializeAws_json1_1BlueprintRuns
 */
const de_BlueprintRuns = (output: any, context: __SerdeContext): BlueprintRun[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return de_BlueprintRun(entry, context);
    });
  return retVal;
};

/**
 * deserializeAws_json1_1Blueprints
 */
const de_Blueprints = (output: any, context: __SerdeContext): Blueprint[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return de_Blueprint(entry, context);
    });
  return retVal;
};

/**
 * deserializeAws_json1_1BooleanColumnStatisticsData
 */
const de_BooleanColumnStatisticsData = (output: any, context: __SerdeContext): BooleanColumnStatisticsData => {
  return {
    NumberOfFalses: __expectLong(output.NumberOfFalses),
    NumberOfNulls: __expectLong(output.NumberOfNulls),
    NumberOfTrues: __expectLong(output.NumberOfTrues),
  } as any;
};

/**
 * deserializeAws_json1_1BoundedPartitionValueList
 */
const de_BoundedPartitionValueList = (output: any, context: __SerdeContext): string[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return __expectString(entry) as any;
    });
  return retVal;
};

/**
 * deserializeAws_json1_1CancelDataQualityRuleRecommendationRunResponse
 */
const de_CancelDataQualityRuleRecommendationRunResponse = (
  output: any,
  context: __SerdeContext
): CancelDataQualityRuleRecommendationRunResponse => {
  return {} as any;
};

/**
 * deserializeAws_json1_1CancelDataQualityRulesetEvaluationRunResponse
 */
const de_CancelDataQualityRulesetEvaluationRunResponse = (
  output: any,
  context: __SerdeContext
): CancelDataQualityRulesetEvaluationRunResponse => {
  return {} as any;
};

/**
 * deserializeAws_json1_1CancelMLTaskRunResponse
 */
const de_CancelMLTaskRunResponse = (output: any, context: __SerdeContext): CancelMLTaskRunResponse => {
  return {
    Status: __expectString(output.Status),
    TaskRunId: __expectString(output.TaskRunId),
    TransformId: __expectString(output.TransformId),
  } as any;
};

/**
 * deserializeAws_json1_1CancelStatementResponse
 */
const de_CancelStatementResponse = (output: any, context: __SerdeContext): CancelStatementResponse => {
  return {} as any;
};

/**
 * deserializeAws_json1_1CatalogDeltaSource
 */
const de_CatalogDeltaSource = (output: any, context: __SerdeContext): CatalogDeltaSource => {
  return {
    AdditionalDeltaOptions:
      output.AdditionalDeltaOptions != null ? de_AdditionalOptions(output.AdditionalDeltaOptions, context) : undefined,
    Database: __expectString(output.Database),
    Name: __expectString(output.Name),
    OutputSchemas: output.OutputSchemas != null ? de_GlueSchemas(output.OutputSchemas, context) : undefined,
    Table: __expectString(output.Table),
  } as any;
};

/**
 * deserializeAws_json1_1CatalogHudiSource
 */
const de_CatalogHudiSource = (output: any, context: __SerdeContext): CatalogHudiSource => {
  return {
    AdditionalHudiOptions:
      output.AdditionalHudiOptions != null ? de_AdditionalOptions(output.AdditionalHudiOptions, context) : undefined,
    Database: __expectString(output.Database),
    Name: __expectString(output.Name),
    OutputSchemas: output.OutputSchemas != null ? de_GlueSchemas(output.OutputSchemas, context) : undefined,
    Table: __expectString(output.Table),
  } as any;
};

/**
 * deserializeAws_json1_1CatalogImportStatus
 */
const de_CatalogImportStatus = (output: any, context: __SerdeContext): CatalogImportStatus => {
  return {
    ImportCompleted: __expectBoolean(output.ImportCompleted),
    ImportTime:
      output.ImportTime != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.ImportTime))) : undefined,
    ImportedBy: __expectString(output.ImportedBy),
  } as any;
};

/**
 * deserializeAws_json1_1CatalogKafkaSource
 */
const de_CatalogKafkaSource = (output: any, context: __SerdeContext): CatalogKafkaSource => {
  return {
    DataPreviewOptions:
      output.DataPreviewOptions != null
        ? de_StreamingDataPreviewOptions(output.DataPreviewOptions, context)
        : undefined,
    Database: __expectString(output.Database),
    DetectSchema: __expectBoolean(output.DetectSchema),
    Name: __expectString(output.Name),
    StreamingOptions:
      output.StreamingOptions != null ? de_KafkaStreamingSourceOptions(output.StreamingOptions, context) : undefined,
    Table: __expectString(output.Table),
    WindowSize: __expectInt32(output.WindowSize),
  } as any;
};

/**
 * deserializeAws_json1_1CatalogKinesisSource
 */
const de_CatalogKinesisSource = (output: any, context: __SerdeContext): CatalogKinesisSource => {
  return {
    DataPreviewOptions:
      output.DataPreviewOptions != null
        ? de_StreamingDataPreviewOptions(output.DataPreviewOptions, context)
        : undefined,
    Database: __expectString(output.Database),
    DetectSchema: __expectBoolean(output.DetectSchema),
    Name: __expectString(output.Name),
    StreamingOptions:
      output.StreamingOptions != null ? de_KinesisStreamingSourceOptions(output.StreamingOptions, context) : undefined,
    Table: __expectString(output.Table),
    WindowSize: __expectInt32(output.WindowSize),
  } as any;
};

/**
 * deserializeAws_json1_1CatalogSchemaChangePolicy
 */
const de_CatalogSchemaChangePolicy = (output: any, context: __SerdeContext): CatalogSchemaChangePolicy => {
  return {
    EnableUpdateCatalog: __expectBoolean(output.EnableUpdateCatalog),
    UpdateBehavior: __expectString(output.UpdateBehavior),
  } as any;
};

/**
 * deserializeAws_json1_1CatalogSource
 */
const de_CatalogSource = (output: any, context: __SerdeContext): CatalogSource => {
  return {
    Database: __expectString(output.Database),
    Name: __expectString(output.Name),
    Table: __expectString(output.Table),
  } as any;
};

/**
 * deserializeAws_json1_1CatalogTablesList
 */
const de_CatalogTablesList = (output: any, context: __SerdeContext): string[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return __expectString(entry) as any;
    });
  return retVal;
};

/**
 * deserializeAws_json1_1CatalogTarget
 */
const de_CatalogTarget = (output: any, context: __SerdeContext): CatalogTarget => {
  return {
    ConnectionName: __expectString(output.ConnectionName),
    DatabaseName: __expectString(output.DatabaseName),
    DlqEventQueueArn: __expectString(output.DlqEventQueueArn),
    EventQueueArn: __expectString(output.EventQueueArn),
    Tables: output.Tables != null ? de_CatalogTablesList(output.Tables, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1CatalogTargetList
 */
const de_CatalogTargetList = (output: any, context: __SerdeContext): CatalogTarget[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return de_CatalogTarget(entry, context);
    });
  return retVal;
};

/**
 * deserializeAws_json1_1CheckSchemaVersionValidityResponse
 */
const de_CheckSchemaVersionValidityResponse = (
  output: any,
  context: __SerdeContext
): CheckSchemaVersionValidityResponse => {
  return {
    Error: __expectString(output.Error),
    Valid: __expectBoolean(output.Valid),
  } as any;
};

/**
 * deserializeAws_json1_1Classifier
 */
const de_Classifier = (output: any, context: __SerdeContext): Classifier => {
  return {
    CsvClassifier: output.CsvClassifier != null ? de_CsvClassifier(output.CsvClassifier, context) : undefined,
    GrokClassifier: output.GrokClassifier != null ? de_GrokClassifier(output.GrokClassifier, context) : undefined,
    JsonClassifier: output.JsonClassifier != null ? de_JsonClassifier(output.JsonClassifier, context) : undefined,
    XMLClassifier: output.XMLClassifier != null ? de_XMLClassifier(output.XMLClassifier, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1ClassifierList
 */
const de_ClassifierList = (output: any, context: __SerdeContext): Classifier[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return de_Classifier(entry, context);
    });
  return retVal;
};

/**
 * deserializeAws_json1_1ClassifierNameList
 */
const de_ClassifierNameList = (output: any, context: __SerdeContext): string[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return __expectString(entry) as any;
    });
  return retVal;
};

/**
 * deserializeAws_json1_1CloudWatchEncryption
 */
const de_CloudWatchEncryption = (output: any, context: __SerdeContext): CloudWatchEncryption => {
  return {
    CloudWatchEncryptionMode: __expectString(output.CloudWatchEncryptionMode),
    KmsKeyArn: __expectString(output.KmsKeyArn),
  } as any;
};

/**
 * deserializeAws_json1_1CodeGenConfigurationNode
 */
const de_CodeGenConfigurationNode = (output: any, context: __SerdeContext): CodeGenConfigurationNode => {
  return {
    Aggregate: output.Aggregate != null ? de_Aggregate(output.Aggregate, context) : undefined,
    ApplyMapping: output.ApplyMapping != null ? de_ApplyMapping(output.ApplyMapping, context) : undefined,
    AthenaConnectorSource:
      output.AthenaConnectorSource != null
        ? de_AthenaConnectorSource(output.AthenaConnectorSource, context)
        : undefined,
    CatalogDeltaSource:
      output.CatalogDeltaSource != null ? de_CatalogDeltaSource(output.CatalogDeltaSource, context) : undefined,
    CatalogHudiSource:
      output.CatalogHudiSource != null ? de_CatalogHudiSource(output.CatalogHudiSource, context) : undefined,
    CatalogKafkaSource:
      output.CatalogKafkaSource != null ? de_CatalogKafkaSource(output.CatalogKafkaSource, context) : undefined,
    CatalogKinesisSource:
      output.CatalogKinesisSource != null ? de_CatalogKinesisSource(output.CatalogKinesisSource, context) : undefined,
    CatalogSource: output.CatalogSource != null ? de_CatalogSource(output.CatalogSource, context) : undefined,
    CatalogTarget: output.CatalogTarget != null ? de_BasicCatalogTarget(output.CatalogTarget, context) : undefined,
    CustomCode: output.CustomCode != null ? de_CustomCode(output.CustomCode, context) : undefined,
    DirectJDBCSource:
      output.DirectJDBCSource != null ? de_DirectJDBCSource(output.DirectJDBCSource, context) : undefined,
    DirectKafkaSource:
      output.DirectKafkaSource != null ? de_DirectKafkaSource(output.DirectKafkaSource, context) : undefined,
    DirectKinesisSource:
      output.DirectKinesisSource != null ? de_DirectKinesisSource(output.DirectKinesisSource, context) : undefined,
    DropDuplicates: output.DropDuplicates != null ? de_DropDuplicates(output.DropDuplicates, context) : undefined,
    DropFields: output.DropFields != null ? de_DropFields(output.DropFields, context) : undefined,
    DropNullFields: output.DropNullFields != null ? de_DropNullFields(output.DropNullFields, context) : undefined,
    DynamicTransform:
      output.DynamicTransform != null ? de_DynamicTransform(output.DynamicTransform, context) : undefined,
    DynamoDBCatalogSource:
      output.DynamoDBCatalogSource != null
        ? de_DynamoDBCatalogSource(output.DynamoDBCatalogSource, context)
        : undefined,
    EvaluateDataQuality:
      output.EvaluateDataQuality != null ? de_EvaluateDataQuality(output.EvaluateDataQuality, context) : undefined,
    FillMissingValues:
      output.FillMissingValues != null ? de_FillMissingValues(output.FillMissingValues, context) : undefined,
    Filter: output.Filter != null ? de_Filter(output.Filter, context) : undefined,
    GovernedCatalogSource:
      output.GovernedCatalogSource != null
        ? de_GovernedCatalogSource(output.GovernedCatalogSource, context)
        : undefined,
    GovernedCatalogTarget:
      output.GovernedCatalogTarget != null
        ? de_GovernedCatalogTarget(output.GovernedCatalogTarget, context)
        : undefined,
    JDBCConnectorSource:
      output.JDBCConnectorSource != null ? de_JDBCConnectorSource(output.JDBCConnectorSource, context) : undefined,
    JDBCConnectorTarget:
      output.JDBCConnectorTarget != null ? de_JDBCConnectorTarget(output.JDBCConnectorTarget, context) : undefined,
    Join: output.Join != null ? de_Join(output.Join, context) : undefined,
    Merge: output.Merge != null ? de_Merge(output.Merge, context) : undefined,
    MicrosoftSQLServerCatalogSource:
      output.MicrosoftSQLServerCatalogSource != null
        ? de_MicrosoftSQLServerCatalogSource(output.MicrosoftSQLServerCatalogSource, context)
        : undefined,
    MicrosoftSQLServerCatalogTarget:
      output.MicrosoftSQLServerCatalogTarget != null
        ? de_MicrosoftSQLServerCatalogTarget(output.MicrosoftSQLServerCatalogTarget, context)
        : undefined,
    MySQLCatalogSource:
      output.MySQLCatalogSource != null ? de_MySQLCatalogSource(output.MySQLCatalogSource, context) : undefined,
    MySQLCatalogTarget:
      output.MySQLCatalogTarget != null ? de_MySQLCatalogTarget(output.MySQLCatalogTarget, context) : undefined,
    OracleSQLCatalogSource:
      output.OracleSQLCatalogSource != null
        ? de_OracleSQLCatalogSource(output.OracleSQLCatalogSource, context)
        : undefined,
    OracleSQLCatalogTarget:
      output.OracleSQLCatalogTarget != null
        ? de_OracleSQLCatalogTarget(output.OracleSQLCatalogTarget, context)
        : undefined,
    PIIDetection: output.PIIDetection != null ? de_PIIDetection(output.PIIDetection, context) : undefined,
    PostgreSQLCatalogSource:
      output.PostgreSQLCatalogSource != null
        ? de_PostgreSQLCatalogSource(output.PostgreSQLCatalogSource, context)
        : undefined,
    PostgreSQLCatalogTarget:
      output.PostgreSQLCatalogTarget != null
        ? de_PostgreSQLCatalogTarget(output.PostgreSQLCatalogTarget, context)
        : undefined,
    RedshiftSource: output.RedshiftSource != null ? de_RedshiftSource(output.RedshiftSource, context) : undefined,
    RedshiftTarget: output.RedshiftTarget != null ? de_RedshiftTarget(output.RedshiftTarget, context) : undefined,
    RelationalCatalogSource:
      output.RelationalCatalogSource != null
        ? de_RelationalCatalogSource(output.RelationalCatalogSource, context)
        : undefined,
    RenameField: output.RenameField != null ? de_RenameField(output.RenameField, context) : undefined,
    S3CatalogDeltaSource:
      output.S3CatalogDeltaSource != null ? de_S3CatalogDeltaSource(output.S3CatalogDeltaSource, context) : undefined,
    S3CatalogHudiSource:
      output.S3CatalogHudiSource != null ? de_S3CatalogHudiSource(output.S3CatalogHudiSource, context) : undefined,
    S3CatalogSource: output.S3CatalogSource != null ? de_S3CatalogSource(output.S3CatalogSource, context) : undefined,
    S3CatalogTarget: output.S3CatalogTarget != null ? de_S3CatalogTarget(output.S3CatalogTarget, context) : undefined,
    S3CsvSource: output.S3CsvSource != null ? de_S3CsvSource(output.S3CsvSource, context) : undefined,
    S3DeltaCatalogTarget:
      output.S3DeltaCatalogTarget != null ? de_S3DeltaCatalogTarget(output.S3DeltaCatalogTarget, context) : undefined,
    S3DeltaDirectTarget:
      output.S3DeltaDirectTarget != null ? de_S3DeltaDirectTarget(output.S3DeltaDirectTarget, context) : undefined,
    S3DeltaSource: output.S3DeltaSource != null ? de_S3DeltaSource(output.S3DeltaSource, context) : undefined,
    S3DirectTarget: output.S3DirectTarget != null ? de_S3DirectTarget(output.S3DirectTarget, context) : undefined,
    S3GlueParquetTarget:
      output.S3GlueParquetTarget != null ? de_S3GlueParquetTarget(output.S3GlueParquetTarget, context) : undefined,
    S3HudiCatalogTarget:
      output.S3HudiCatalogTarget != null ? de_S3HudiCatalogTarget(output.S3HudiCatalogTarget, context) : undefined,
    S3HudiDirectTarget:
      output.S3HudiDirectTarget != null ? de_S3HudiDirectTarget(output.S3HudiDirectTarget, context) : undefined,
    S3HudiSource: output.S3HudiSource != null ? de_S3HudiSource(output.S3HudiSource, context) : undefined,
    S3JsonSource: output.S3JsonSource != null ? de_S3JsonSource(output.S3JsonSource, context) : undefined,
    S3ParquetSource: output.S3ParquetSource != null ? de_S3ParquetSource(output.S3ParquetSource, context) : undefined,
    SelectFields: output.SelectFields != null ? de_SelectFields(output.SelectFields, context) : undefined,
    SelectFromCollection:
      output.SelectFromCollection != null ? de_SelectFromCollection(output.SelectFromCollection, context) : undefined,
    SparkConnectorSource:
      output.SparkConnectorSource != null ? de_SparkConnectorSource(output.SparkConnectorSource, context) : undefined,
    SparkConnectorTarget:
      output.SparkConnectorTarget != null ? de_SparkConnectorTarget(output.SparkConnectorTarget, context) : undefined,
    SparkSQL: output.SparkSQL != null ? de_SparkSQL(output.SparkSQL, context) : undefined,
    Spigot: output.Spigot != null ? de_Spigot(output.Spigot, context) : undefined,
    SplitFields: output.SplitFields != null ? de_SplitFields(output.SplitFields, context) : undefined,
    Union: output.Union != null ? de_Union(output.Union, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1CodeGenConfigurationNodes
 */
const de_CodeGenConfigurationNodes = (
  output: any,
  context: __SerdeContext
): Record<string, CodeGenConfigurationNode> => {
  return Object.entries(output).reduce((acc: Record<string, CodeGenConfigurationNode>, [key, value]: [string, any]) => {
    if (value === null) {
      return acc;
    }
    acc[key] = de_CodeGenConfigurationNode(value, context);
    return acc;
  }, {});
};

/**
 * deserializeAws_json1_1CodeGenEdge
 */
const de_CodeGenEdge = (output: any, context: __SerdeContext): CodeGenEdge => {
  return {
    Source: __expectString(output.Source),
    Target: __expectString(output.Target),
    TargetParameter: __expectString(output.TargetParameter),
  } as any;
};

/**
 * deserializeAws_json1_1CodeGenNode
 */
const de_CodeGenNode = (output: any, context: __SerdeContext): CodeGenNode => {
  return {
    Args: output.Args != null ? de_CodeGenNodeArgs(output.Args, context) : undefined,
    Id: __expectString(output.Id),
    LineNumber: __expectInt32(output.LineNumber),
    NodeType: __expectString(output.NodeType),
  } as any;
};

/**
 * deserializeAws_json1_1CodeGenNodeArg
 */
const de_CodeGenNodeArg = (output: any, context: __SerdeContext): CodeGenNodeArg => {
  return {
    Name: __expectString(output.Name),
    Param: __expectBoolean(output.Param),
    Value: __expectString(output.Value),
  } as any;
};

/**
 * deserializeAws_json1_1CodeGenNodeArgs
 */
const de_CodeGenNodeArgs = (output: any, context: __SerdeContext): CodeGenNodeArg[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return de_CodeGenNodeArg(entry, context);
    });
  return retVal;
};

/**
 * deserializeAws_json1_1Column
 */
const de_Column = (output: any, context: __SerdeContext): Column => {
  return {
    Comment: __expectString(output.Comment),
    Name: __expectString(output.Name),
    Parameters: output.Parameters != null ? de_ParametersMap(output.Parameters, context) : undefined,
    Type: __expectString(output.Type),
  } as any;
};

/**
 * deserializeAws_json1_1ColumnError
 */
const de_ColumnError = (output: any, context: __SerdeContext): ColumnError => {
  return {
    ColumnName: __expectString(output.ColumnName),
    Error: output.Error != null ? de_ErrorDetail(output.Error, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1ColumnErrors
 */
const de_ColumnErrors = (output: any, context: __SerdeContext): ColumnError[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return de_ColumnError(entry, context);
    });
  return retVal;
};

/**
 * deserializeAws_json1_1ColumnImportance
 */
const de_ColumnImportance = (output: any, context: __SerdeContext): ColumnImportance => {
  return {
    ColumnName: __expectString(output.ColumnName),
    Importance: __limitedParseDouble(output.Importance),
  } as any;
};

/**
 * deserializeAws_json1_1ColumnImportanceList
 */
const de_ColumnImportanceList = (output: any, context: __SerdeContext): ColumnImportance[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return de_ColumnImportance(entry, context);
    });
  return retVal;
};

/**
 * deserializeAws_json1_1ColumnList
 */
const de_ColumnList = (output: any, context: __SerdeContext): Column[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return de_Column(entry, context);
    });
  return retVal;
};

/**
 * deserializeAws_json1_1ColumnRowFilter
 */
const de_ColumnRowFilter = (output: any, context: __SerdeContext): ColumnRowFilter => {
  return {
    ColumnName: __expectString(output.ColumnName),
    RowFilterExpression: __expectString(output.RowFilterExpression),
  } as any;
};

/**
 * deserializeAws_json1_1ColumnRowFilterList
 */
const de_ColumnRowFilterList = (output: any, context: __SerdeContext): ColumnRowFilter[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return de_ColumnRowFilter(entry, context);
    });
  return retVal;
};

/**
 * deserializeAws_json1_1ColumnStatistics
 */
const de_ColumnStatistics = (output: any, context: __SerdeContext): ColumnStatistics => {
  return {
    AnalyzedTime:
      output.AnalyzedTime != null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.AnalyzedTime)))
        : undefined,
    ColumnName: __expectString(output.ColumnName),
    ColumnType: __expectString(output.ColumnType),
    StatisticsData: output.StatisticsData != null ? de_ColumnStatisticsData(output.StatisticsData, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1ColumnStatisticsData
 */
const de_ColumnStatisticsData = (output: any, context: __SerdeContext): ColumnStatisticsData => {
  return {
    BinaryColumnStatisticsData:
      output.BinaryColumnStatisticsData != null
        ? de_BinaryColumnStatisticsData(output.BinaryColumnStatisticsData, context)
        : undefined,
    BooleanColumnStatisticsData:
      output.BooleanColumnStatisticsData != null
        ? de_BooleanColumnStatisticsData(output.BooleanColumnStatisticsData, context)
        : undefined,
    DateColumnStatisticsData:
      output.DateColumnStatisticsData != null
        ? de_DateColumnStatisticsData(output.DateColumnStatisticsData, context)
        : undefined,
    DecimalColumnStatisticsData:
      output.DecimalColumnStatisticsData != null
        ? de_DecimalColumnStatisticsData(output.DecimalColumnStatisticsData, context)
        : undefined,
    DoubleColumnStatisticsData:
      output.DoubleColumnStatisticsData != null
        ? de_DoubleColumnStatisticsData(output.DoubleColumnStatisticsData, context)
        : undefined,
    LongColumnStatisticsData:
      output.LongColumnStatisticsData != null
        ? de_LongColumnStatisticsData(output.LongColumnStatisticsData, context)
        : undefined,
    StringColumnStatisticsData:
      output.StringColumnStatisticsData != null
        ? de_StringColumnStatisticsData(output.StringColumnStatisticsData, context)
        : undefined,
    Type: __expectString(output.Type),
  } as any;
};

/**
 * deserializeAws_json1_1ColumnStatisticsError
 */
const de_ColumnStatisticsError = (output: any, context: __SerdeContext): ColumnStatisticsError => {
  return {
    ColumnStatistics:
      output.ColumnStatistics != null ? de_ColumnStatistics(output.ColumnStatistics, context) : undefined,
    Error: output.Error != null ? de_ErrorDetail(output.Error, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1ColumnStatisticsErrors
 */
const de_ColumnStatisticsErrors = (output: any, context: __SerdeContext): ColumnStatisticsError[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return de_ColumnStatisticsError(entry, context);
    });
  return retVal;
};

/**
 * deserializeAws_json1_1ColumnStatisticsList
 */
const de_ColumnStatisticsList = (output: any, context: __SerdeContext): ColumnStatistics[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return de_ColumnStatistics(entry, context);
    });
  return retVal;
};

/**
 * deserializeAws_json1_1ColumnValueStringList
 */
const de_ColumnValueStringList = (output: any, context: __SerdeContext): string[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return __expectString(entry) as any;
    });
  return retVal;
};

/**
 * deserializeAws_json1_1ConcurrentModificationException
 */
const de_ConcurrentModificationException = (output: any, context: __SerdeContext): ConcurrentModificationException => {
  return {
    Message: __expectString(output.Message),
  } as any;
};

/**
 * deserializeAws_json1_1ConcurrentRunsExceededException
 */
const de_ConcurrentRunsExceededException = (output: any, context: __SerdeContext): ConcurrentRunsExceededException => {
  return {
    Message: __expectString(output.Message),
  } as any;
};

/**
 * deserializeAws_json1_1Condition
 */
const de_Condition = (output: any, context: __SerdeContext): Condition => {
  return {
    CrawlState: __expectString(output.CrawlState),
    CrawlerName: __expectString(output.CrawlerName),
    JobName: __expectString(output.JobName),
    LogicalOperator: __expectString(output.LogicalOperator),
    State: __expectString(output.State),
  } as any;
};

/**
 * deserializeAws_json1_1ConditionCheckFailureException
 */
const de_ConditionCheckFailureException = (output: any, context: __SerdeContext): ConditionCheckFailureException => {
  return {
    Message: __expectString(output.Message),
  } as any;
};

/**
 * deserializeAws_json1_1ConditionList
 */
const de_ConditionList = (output: any, context: __SerdeContext): Condition[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return de_Condition(entry, context);
    });
  return retVal;
};

/**
 * deserializeAws_json1_1ConflictException
 */
const de_ConflictException = (output: any, context: __SerdeContext): ConflictException => {
  return {
    Message: __expectString(output.Message),
  } as any;
};

/**
 * deserializeAws_json1_1ConfusionMatrix
 */
const de_ConfusionMatrix = (output: any, context: __SerdeContext): ConfusionMatrix => {
  return {
    NumFalseNegatives: __expectLong(output.NumFalseNegatives),
    NumFalsePositives: __expectLong(output.NumFalsePositives),
    NumTrueNegatives: __expectLong(output.NumTrueNegatives),
    NumTruePositives: __expectLong(output.NumTruePositives),
  } as any;
};

/**
 * deserializeAws_json1_1Connection
 */
const de_Connection = (output: any, context: __SerdeContext): Connection => {
  return {
    ConnectionProperties:
      output.ConnectionProperties != null ? de_ConnectionProperties(output.ConnectionProperties, context) : undefined,
    ConnectionType: __expectString(output.ConnectionType),
    CreationTime:
      output.CreationTime != null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.CreationTime)))
        : undefined,
    Description: __expectString(output.Description),
    LastUpdatedBy: __expectString(output.LastUpdatedBy),
    LastUpdatedTime:
      output.LastUpdatedTime != null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.LastUpdatedTime)))
        : undefined,
    MatchCriteria: output.MatchCriteria != null ? de_MatchCriteria(output.MatchCriteria, context) : undefined,
    Name: __expectString(output.Name),
    PhysicalConnectionRequirements:
      output.PhysicalConnectionRequirements != null
        ? de_PhysicalConnectionRequirements(output.PhysicalConnectionRequirements, context)
        : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1ConnectionList
 */
const de_ConnectionList = (output: any, context: __SerdeContext): Connection[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return de_Connection(entry, context);
    });
  return retVal;
};

/**
 * deserializeAws_json1_1ConnectionPasswordEncryption
 */
const de_ConnectionPasswordEncryption = (output: any, context: __SerdeContext): ConnectionPasswordEncryption => {
  return {
    AwsKmsKeyId: __expectString(output.AwsKmsKeyId),
    ReturnConnectionPasswordEncrypted: __expectBoolean(output.ReturnConnectionPasswordEncrypted),
  } as any;
};

/**
 * deserializeAws_json1_1ConnectionProperties
 */
const de_ConnectionProperties = (output: any, context: __SerdeContext): Record<string, string> => {
  return Object.entries(output).reduce(
    (acc: Record<string, string>, [key, value]: [ConnectionPropertyKey | string, any]) => {
      if (value === null) {
        return acc;
      }
      acc[key] = __expectString(value) as any;
      return acc;
    },
    {}
  );
};

/**
 * deserializeAws_json1_1ConnectionsList
 */
const de_ConnectionsList = (output: any, context: __SerdeContext): ConnectionsList => {
  return {
    Connections: output.Connections != null ? de_OrchestrationStringList(output.Connections, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1ContextWords
 */
const de_ContextWords = (output: any, context: __SerdeContext): string[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return __expectString(entry) as any;
    });
  return retVal;
};

/**
 * deserializeAws_json1_1Crawl
 */
const de_Crawl = (output: any, context: __SerdeContext): Crawl => {
  return {
    CompletedOn:
      output.CompletedOn != null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.CompletedOn)))
        : undefined,
    ErrorMessage: __expectString(output.ErrorMessage),
    LogGroup: __expectString(output.LogGroup),
    LogStream: __expectString(output.LogStream),
    StartedOn:
      output.StartedOn != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.StartedOn))) : undefined,
    State: __expectString(output.State),
  } as any;
};

/**
 * deserializeAws_json1_1Crawler
 */
const de_Crawler = (output: any, context: __SerdeContext): Crawler => {
  return {
    Classifiers: output.Classifiers != null ? de_ClassifierNameList(output.Classifiers, context) : undefined,
    Configuration: __expectString(output.Configuration),
    CrawlElapsedTime: __expectLong(output.CrawlElapsedTime),
    CrawlerSecurityConfiguration: __expectString(output.CrawlerSecurityConfiguration),
    CreationTime:
      output.CreationTime != null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.CreationTime)))
        : undefined,
    DatabaseName: __expectString(output.DatabaseName),
    Description: __expectString(output.Description),
    LakeFormationConfiguration:
      output.LakeFormationConfiguration != null
        ? de_LakeFormationConfiguration(output.LakeFormationConfiguration, context)
        : undefined,
    LastCrawl: output.LastCrawl != null ? de_LastCrawlInfo(output.LastCrawl, context) : undefined,
    LastUpdated:
      output.LastUpdated != null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.LastUpdated)))
        : undefined,
    LineageConfiguration:
      output.LineageConfiguration != null ? de_LineageConfiguration(output.LineageConfiguration, context) : undefined,
    Name: __expectString(output.Name),
    RecrawlPolicy: output.RecrawlPolicy != null ? de_RecrawlPolicy(output.RecrawlPolicy, context) : undefined,
    Role: __expectString(output.Role),
    Schedule: output.Schedule != null ? de_Schedule(output.Schedule, context) : undefined,
    SchemaChangePolicy:
      output.SchemaChangePolicy != null ? de_SchemaChangePolicy(output.SchemaChangePolicy, context) : undefined,
    State: __expectString(output.State),
    TablePrefix: __expectString(output.TablePrefix),
    Targets: output.Targets != null ? de_CrawlerTargets(output.Targets, context) : undefined,
    Version: __expectLong(output.Version),
  } as any;
};

/**
 * deserializeAws_json1_1CrawlerHistory
 */
const de_CrawlerHistory = (output: any, context: __SerdeContext): CrawlerHistory => {
  return {
    CrawlId: __expectString(output.CrawlId),
    DPUHour: __limitedParseDouble(output.DPUHour),
    EndTime:
      output.EndTime != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.EndTime))) : undefined,
    ErrorMessage: __expectString(output.ErrorMessage),
    LogGroup: __expectString(output.LogGroup),
    LogStream: __expectString(output.LogStream),
    MessagePrefix: __expectString(output.MessagePrefix),
    StartTime:
      output.StartTime != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.StartTime))) : undefined,
    State: __expectString(output.State),
    Summary: __expectString(output.Summary),
  } as any;
};

/**
 * deserializeAws_json1_1CrawlerHistoryList
 */
const de_CrawlerHistoryList = (output: any, context: __SerdeContext): CrawlerHistory[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return de_CrawlerHistory(entry, context);
    });
  return retVal;
};

/**
 * deserializeAws_json1_1CrawlerList
 */
const de_CrawlerList = (output: any, context: __SerdeContext): Crawler[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return de_Crawler(entry, context);
    });
  return retVal;
};

/**
 * deserializeAws_json1_1CrawlerMetrics
 */
const de_CrawlerMetrics = (output: any, context: __SerdeContext): CrawlerMetrics => {
  return {
    CrawlerName: __expectString(output.CrawlerName),
    LastRuntimeSeconds: __limitedParseDouble(output.LastRuntimeSeconds),
    MedianRuntimeSeconds: __limitedParseDouble(output.MedianRuntimeSeconds),
    StillEstimating: __expectBoolean(output.StillEstimating),
    TablesCreated: __expectInt32(output.TablesCreated),
    TablesDeleted: __expectInt32(output.TablesDeleted),
    TablesUpdated: __expectInt32(output.TablesUpdated),
    TimeLeftSeconds: __limitedParseDouble(output.TimeLeftSeconds),
  } as any;
};

/**
 * deserializeAws_json1_1CrawlerMetricsList
 */
const de_CrawlerMetricsList = (output: any, context: __SerdeContext): CrawlerMetrics[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return de_CrawlerMetrics(entry, context);
    });
  return retVal;
};

/**
 * deserializeAws_json1_1CrawlerNameList
 */
const de_CrawlerNameList = (output: any, context: __SerdeContext): string[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return __expectString(entry) as any;
    });
  return retVal;
};

/**
 * deserializeAws_json1_1CrawlerNodeDetails
 */
const de_CrawlerNodeDetails = (output: any, context: __SerdeContext): CrawlerNodeDetails => {
  return {
    Crawls: output.Crawls != null ? de_CrawlList(output.Crawls, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1CrawlerNotRunningException
 */
const de_CrawlerNotRunningException = (output: any, context: __SerdeContext): CrawlerNotRunningException => {
  return {
    Message: __expectString(output.Message),
  } as any;
};

/**
 * deserializeAws_json1_1CrawlerRunningException
 */
const de_CrawlerRunningException = (output: any, context: __SerdeContext): CrawlerRunningException => {
  return {
    Message: __expectString(output.Message),
  } as any;
};

/**
 * deserializeAws_json1_1CrawlerStoppingException
 */
const de_CrawlerStoppingException = (output: any, context: __SerdeContext): CrawlerStoppingException => {
  return {
    Message: __expectString(output.Message),
  } as any;
};

/**
 * deserializeAws_json1_1CrawlerTargets
 */
const de_CrawlerTargets = (output: any, context: __SerdeContext): CrawlerTargets => {
  return {
    CatalogTargets: output.CatalogTargets != null ? de_CatalogTargetList(output.CatalogTargets, context) : undefined,
    DeltaTargets: output.DeltaTargets != null ? de_DeltaTargetList(output.DeltaTargets, context) : undefined,
    DynamoDBTargets:
      output.DynamoDBTargets != null ? de_DynamoDBTargetList(output.DynamoDBTargets, context) : undefined,
    JdbcTargets: output.JdbcTargets != null ? de_JdbcTargetList(output.JdbcTargets, context) : undefined,
    MongoDBTargets: output.MongoDBTargets != null ? de_MongoDBTargetList(output.MongoDBTargets, context) : undefined,
    S3Targets: output.S3Targets != null ? de_S3TargetList(output.S3Targets, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1CrawlList
 */
const de_CrawlList = (output: any, context: __SerdeContext): Crawl[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return de_Crawl(entry, context);
    });
  return retVal;
};

/**
 * deserializeAws_json1_1CreateBlueprintResponse
 */
const de_CreateBlueprintResponse = (output: any, context: __SerdeContext): CreateBlueprintResponse => {
  return {
    Name: __expectString(output.Name),
  } as any;
};

/**
 * deserializeAws_json1_1CreateClassifierResponse
 */
const de_CreateClassifierResponse = (output: any, context: __SerdeContext): CreateClassifierResponse => {
  return {} as any;
};

/**
 * deserializeAws_json1_1CreateConnectionResponse
 */
const de_CreateConnectionResponse = (output: any, context: __SerdeContext): CreateConnectionResponse => {
  return {} as any;
};

/**
 * deserializeAws_json1_1CreateCrawlerResponse
 */
const de_CreateCrawlerResponse = (output: any, context: __SerdeContext): CreateCrawlerResponse => {
  return {} as any;
};

/**
 * deserializeAws_json1_1CreateCustomEntityTypeResponse
 */
const de_CreateCustomEntityTypeResponse = (output: any, context: __SerdeContext): CreateCustomEntityTypeResponse => {
  return {
    Name: __expectString(output.Name),
  } as any;
};

/**
 * deserializeAws_json1_1CreateDatabaseResponse
 */
const de_CreateDatabaseResponse = (output: any, context: __SerdeContext): CreateDatabaseResponse => {
  return {} as any;
};

/**
 * deserializeAws_json1_1CreateDataQualityRulesetResponse
 */
const de_CreateDataQualityRulesetResponse = (
  output: any,
  context: __SerdeContext
): CreateDataQualityRulesetResponse => {
  return {
    Name: __expectString(output.Name),
  } as any;
};

/**
 * deserializeAws_json1_1CreateDevEndpointResponse
 */
const de_CreateDevEndpointResponse = (output: any, context: __SerdeContext): CreateDevEndpointResponse => {
  return {
    Arguments: output.Arguments != null ? de_MapValue(output.Arguments, context) : undefined,
    AvailabilityZone: __expectString(output.AvailabilityZone),
    CreatedTimestamp:
      output.CreatedTimestamp != null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.CreatedTimestamp)))
        : undefined,
    EndpointName: __expectString(output.EndpointName),
    ExtraJarsS3Path: __expectString(output.ExtraJarsS3Path),
    ExtraPythonLibsS3Path: __expectString(output.ExtraPythonLibsS3Path),
    FailureReason: __expectString(output.FailureReason),
    GlueVersion: __expectString(output.GlueVersion),
    NumberOfNodes: __expectInt32(output.NumberOfNodes),
    NumberOfWorkers: __expectInt32(output.NumberOfWorkers),
    RoleArn: __expectString(output.RoleArn),
    SecurityConfiguration: __expectString(output.SecurityConfiguration),
    SecurityGroupIds: output.SecurityGroupIds != null ? de_StringList(output.SecurityGroupIds, context) : undefined,
    Status: __expectString(output.Status),
    SubnetId: __expectString(output.SubnetId),
    VpcId: __expectString(output.VpcId),
    WorkerType: __expectString(output.WorkerType),
    YarnEndpointAddress: __expectString(output.YarnEndpointAddress),
    ZeppelinRemoteSparkInterpreterPort: __expectInt32(output.ZeppelinRemoteSparkInterpreterPort),
  } as any;
};

/**
 * deserializeAws_json1_1CreateJobResponse
 */
const de_CreateJobResponse = (output: any, context: __SerdeContext): CreateJobResponse => {
  return {
    Name: __expectString(output.Name),
  } as any;
};

/**
 * deserializeAws_json1_1CreateMLTransformResponse
 */
const de_CreateMLTransformResponse = (output: any, context: __SerdeContext): CreateMLTransformResponse => {
  return {
    TransformId: __expectString(output.TransformId),
  } as any;
};

/**
 * deserializeAws_json1_1CreatePartitionIndexResponse
 */
const de_CreatePartitionIndexResponse = (output: any, context: __SerdeContext): CreatePartitionIndexResponse => {
  return {} as any;
};

/**
 * deserializeAws_json1_1CreatePartitionResponse
 */
const de_CreatePartitionResponse = (output: any, context: __SerdeContext): CreatePartitionResponse => {
  return {} as any;
};

/**
 * deserializeAws_json1_1CreateRegistryResponse
 */
const de_CreateRegistryResponse = (output: any, context: __SerdeContext): CreateRegistryResponse => {
  return {
    Description: __expectString(output.Description),
    RegistryArn: __expectString(output.RegistryArn),
    RegistryName: __expectString(output.RegistryName),
    Tags: output.Tags != null ? de_TagsMap(output.Tags, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1CreateSchemaResponse
 */
const de_CreateSchemaResponse = (output: any, context: __SerdeContext): CreateSchemaResponse => {
  return {
    Compatibility: __expectString(output.Compatibility),
    DataFormat: __expectString(output.DataFormat),
    Description: __expectString(output.Description),
    LatestSchemaVersion: __expectLong(output.LatestSchemaVersion),
    NextSchemaVersion: __expectLong(output.NextSchemaVersion),
    RegistryArn: __expectString(output.RegistryArn),
    RegistryName: __expectString(output.RegistryName),
    SchemaArn: __expectString(output.SchemaArn),
    SchemaCheckpoint: __expectLong(output.SchemaCheckpoint),
    SchemaName: __expectString(output.SchemaName),
    SchemaStatus: __expectString(output.SchemaStatus),
    SchemaVersionId: __expectString(output.SchemaVersionId),
    SchemaVersionStatus: __expectString(output.SchemaVersionStatus),
    Tags: output.Tags != null ? de_TagsMap(output.Tags, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1CreateScriptResponse
 */
const de_CreateScriptResponse = (output: any, context: __SerdeContext): CreateScriptResponse => {
  return {
    PythonScript: __expectString(output.PythonScript),
    ScalaCode: __expectString(output.ScalaCode),
  } as any;
};

/**
 * deserializeAws_json1_1CreateSecurityConfigurationResponse
 */
const de_CreateSecurityConfigurationResponse = (
  output: any,
  context: __SerdeContext
): CreateSecurityConfigurationResponse => {
  return {
    CreatedTimestamp:
      output.CreatedTimestamp != null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.CreatedTimestamp)))
        : undefined,
    Name: __expectString(output.Name),
  } as any;
};

/**
 * deserializeAws_json1_1CreateSessionResponse
 */
const de_CreateSessionResponse = (output: any, context: __SerdeContext): CreateSessionResponse => {
  return {
    Session: output.Session != null ? de_Session(output.Session, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1CreateTableResponse
 */
const de_CreateTableResponse = (output: any, context: __SerdeContext): CreateTableResponse => {
  return {} as any;
};

/**
 * deserializeAws_json1_1CreateTriggerResponse
 */
const de_CreateTriggerResponse = (output: any, context: __SerdeContext): CreateTriggerResponse => {
  return {
    Name: __expectString(output.Name),
  } as any;
};

/**
 * deserializeAws_json1_1CreateUserDefinedFunctionResponse
 */
const de_CreateUserDefinedFunctionResponse = (
  output: any,
  context: __SerdeContext
): CreateUserDefinedFunctionResponse => {
  return {} as any;
};

/**
 * deserializeAws_json1_1CreateWorkflowResponse
 */
const de_CreateWorkflowResponse = (output: any, context: __SerdeContext): CreateWorkflowResponse => {
  return {
    Name: __expectString(output.Name),
  } as any;
};

/**
 * deserializeAws_json1_1CsvClassifier
 */
const de_CsvClassifier = (output: any, context: __SerdeContext): CsvClassifier => {
  return {
    AllowSingleColumn: __expectBoolean(output.AllowSingleColumn),
    ContainsHeader: __expectString(output.ContainsHeader),
    CreationTime:
      output.CreationTime != null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.CreationTime)))
        : undefined,
    CustomDatatypeConfigured: __expectBoolean(output.CustomDatatypeConfigured),
    CustomDatatypes: output.CustomDatatypes != null ? de_CustomDatatypes(output.CustomDatatypes, context) : undefined,
    Delimiter: __expectString(output.Delimiter),
    DisableValueTrimming: __expectBoolean(output.DisableValueTrimming),
    Header: output.Header != null ? de_CsvHeader(output.Header, context) : undefined,
    LastUpdated:
      output.LastUpdated != null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.LastUpdated)))
        : undefined,
    Name: __expectString(output.Name),
    QuoteSymbol: __expectString(output.QuoteSymbol),
    Version: __expectLong(output.Version),
  } as any;
};

/**
 * deserializeAws_json1_1CsvHeader
 */
const de_CsvHeader = (output: any, context: __SerdeContext): string[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return __expectString(entry) as any;
    });
  return retVal;
};

/**
 * deserializeAws_json1_1CustomCode
 */
const de_CustomCode = (output: any, context: __SerdeContext): CustomCode => {
  return {
    ClassName: __expectString(output.ClassName),
    Code: __expectString(output.Code),
    Inputs: output.Inputs != null ? de_ManyInputs(output.Inputs, context) : undefined,
    Name: __expectString(output.Name),
    OutputSchemas: output.OutputSchemas != null ? de_GlueSchemas(output.OutputSchemas, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1CustomDatatypes
 */
const de_CustomDatatypes = (output: any, context: __SerdeContext): string[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return __expectString(entry) as any;
    });
  return retVal;
};

/**
 * deserializeAws_json1_1CustomEntityType
 */
const de_CustomEntityType = (output: any, context: __SerdeContext): CustomEntityType => {
  return {
    ContextWords: output.ContextWords != null ? de_ContextWords(output.ContextWords, context) : undefined,
    Name: __expectString(output.Name),
    RegexString: __expectString(output.RegexString),
  } as any;
};

/**
 * deserializeAws_json1_1CustomEntityTypeNames
 */
const de_CustomEntityTypeNames = (output: any, context: __SerdeContext): string[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return __expectString(entry) as any;
    });
  return retVal;
};

/**
 * deserializeAws_json1_1CustomEntityTypes
 */
const de_CustomEntityTypes = (output: any, context: __SerdeContext): CustomEntityType[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return de_CustomEntityType(entry, context);
    });
  return retVal;
};

/**
 * deserializeAws_json1_1DagEdges
 */
const de_DagEdges = (output: any, context: __SerdeContext): CodeGenEdge[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return de_CodeGenEdge(entry, context);
    });
  return retVal;
};

/**
 * deserializeAws_json1_1DagNodes
 */
const de_DagNodes = (output: any, context: __SerdeContext): CodeGenNode[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return de_CodeGenNode(entry, context);
    });
  return retVal;
};

/**
 * deserializeAws_json1_1Database
 */
const de_Database = (output: any, context: __SerdeContext): Database => {
  return {
    CatalogId: __expectString(output.CatalogId),
    CreateTableDefaultPermissions:
      output.CreateTableDefaultPermissions != null
        ? de_PrincipalPermissionsList(output.CreateTableDefaultPermissions, context)
        : undefined,
    CreateTime:
      output.CreateTime != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.CreateTime))) : undefined,
    Description: __expectString(output.Description),
    FederatedDatabase:
      output.FederatedDatabase != null ? de_FederatedDatabase(output.FederatedDatabase, context) : undefined,
    LocationUri: __expectString(output.LocationUri),
    Name: __expectString(output.Name),
    Parameters: output.Parameters != null ? de_ParametersMap(output.Parameters, context) : undefined,
    TargetDatabase: output.TargetDatabase != null ? de_DatabaseIdentifier(output.TargetDatabase, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1DatabaseIdentifier
 */
const de_DatabaseIdentifier = (output: any, context: __SerdeContext): DatabaseIdentifier => {
  return {
    CatalogId: __expectString(output.CatalogId),
    DatabaseName: __expectString(output.DatabaseName),
  } as any;
};

/**
 * deserializeAws_json1_1DatabaseList
 */
const de_DatabaseList = (output: any, context: __SerdeContext): Database[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return de_Database(entry, context);
    });
  return retVal;
};

/**
 * deserializeAws_json1_1DataCatalogEncryptionSettings
 */
const de_DataCatalogEncryptionSettings = (output: any, context: __SerdeContext): DataCatalogEncryptionSettings => {
  return {
    ConnectionPasswordEncryption:
      output.ConnectionPasswordEncryption != null
        ? de_ConnectionPasswordEncryption(output.ConnectionPasswordEncryption, context)
        : undefined,
    EncryptionAtRest:
      output.EncryptionAtRest != null ? de_EncryptionAtRest(output.EncryptionAtRest, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1DataLakePrincipal
 */
const de_DataLakePrincipal = (output: any, context: __SerdeContext): DataLakePrincipal => {
  return {
    DataLakePrincipalIdentifier: __expectString(output.DataLakePrincipalIdentifier),
  } as any;
};

/**
 * deserializeAws_json1_1DataQualityEvaluationRunAdditionalRunOptions
 */
const de_DataQualityEvaluationRunAdditionalRunOptions = (
  output: any,
  context: __SerdeContext
): DataQualityEvaluationRunAdditionalRunOptions => {
  return {
    CloudWatchMetricsEnabled: __expectBoolean(output.CloudWatchMetricsEnabled),
    ResultsS3Prefix: __expectString(output.ResultsS3Prefix),
  } as any;
};

/**
 * deserializeAws_json1_1DataQualityResult
 */
const de_DataQualityResult = (output: any, context: __SerdeContext): DataQualityResult => {
  return {
    CompletedOn:
      output.CompletedOn != null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.CompletedOn)))
        : undefined,
    DataSource: output.DataSource != null ? de_DataSource(output.DataSource, context) : undefined,
    EvaluationContext: __expectString(output.EvaluationContext),
    JobName: __expectString(output.JobName),
    JobRunId: __expectString(output.JobRunId),
    ResultId: __expectString(output.ResultId),
    RuleResults: output.RuleResults != null ? de_DataQualityRuleResults(output.RuleResults, context) : undefined,
    RulesetEvaluationRunId: __expectString(output.RulesetEvaluationRunId),
    RulesetName: __expectString(output.RulesetName),
    Score: __limitedParseDouble(output.Score),
    StartedOn:
      output.StartedOn != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.StartedOn))) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1DataQualityResultDescription
 */
const de_DataQualityResultDescription = (output: any, context: __SerdeContext): DataQualityResultDescription => {
  return {
    DataSource: output.DataSource != null ? de_DataSource(output.DataSource, context) : undefined,
    JobName: __expectString(output.JobName),
    JobRunId: __expectString(output.JobRunId),
    ResultId: __expectString(output.ResultId),
    StartedOn:
      output.StartedOn != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.StartedOn))) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1DataQualityResultDescriptionList
 */
const de_DataQualityResultDescriptionList = (output: any, context: __SerdeContext): DataQualityResultDescription[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return de_DataQualityResultDescription(entry, context);
    });
  return retVal;
};

/**
 * deserializeAws_json1_1DataQualityResultIdList
 */
const de_DataQualityResultIdList = (output: any, context: __SerdeContext): string[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return __expectString(entry) as any;
    });
  return retVal;
};

/**
 * deserializeAws_json1_1DataQualityResultIds
 */
const de_DataQualityResultIds = (output: any, context: __SerdeContext): string[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return __expectString(entry) as any;
    });
  return retVal;
};

/**
 * deserializeAws_json1_1DataQualityResultsList
 */
const de_DataQualityResultsList = (output: any, context: __SerdeContext): DataQualityResult[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return de_DataQualityResult(entry, context);
    });
  return retVal;
};

/**
 * deserializeAws_json1_1DataQualityRuleRecommendationRunDescription
 */
const de_DataQualityRuleRecommendationRunDescription = (
  output: any,
  context: __SerdeContext
): DataQualityRuleRecommendationRunDescription => {
  return {
    DataSource: output.DataSource != null ? de_DataSource(output.DataSource, context) : undefined,
    RunId: __expectString(output.RunId),
    StartedOn:
      output.StartedOn != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.StartedOn))) : undefined,
    Status: __expectString(output.Status),
  } as any;
};

/**
 * deserializeAws_json1_1DataQualityRuleRecommendationRunList
 */
const de_DataQualityRuleRecommendationRunList = (
  output: any,
  context: __SerdeContext
): DataQualityRuleRecommendationRunDescription[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return de_DataQualityRuleRecommendationRunDescription(entry, context);
    });
  return retVal;
};

/**
 * deserializeAws_json1_1DataQualityRuleResult
 */
const de_DataQualityRuleResult = (output: any, context: __SerdeContext): DataQualityRuleResult => {
  return {
    Description: __expectString(output.Description),
    EvaluationMessage: __expectString(output.EvaluationMessage),
    Name: __expectString(output.Name),
    Result: __expectString(output.Result),
  } as any;
};

/**
 * deserializeAws_json1_1DataQualityRuleResults
 */
const de_DataQualityRuleResults = (output: any, context: __SerdeContext): DataQualityRuleResult[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return de_DataQualityRuleResult(entry, context);
    });
  return retVal;
};

/**
 * deserializeAws_json1_1DataQualityRulesetEvaluationRunDescription
 */
const de_DataQualityRulesetEvaluationRunDescription = (
  output: any,
  context: __SerdeContext
): DataQualityRulesetEvaluationRunDescription => {
  return {
    DataSource: output.DataSource != null ? de_DataSource(output.DataSource, context) : undefined,
    RunId: __expectString(output.RunId),
    StartedOn:
      output.StartedOn != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.StartedOn))) : undefined,
    Status: __expectString(output.Status),
  } as any;
};

/**
 * deserializeAws_json1_1DataQualityRulesetEvaluationRunList
 */
const de_DataQualityRulesetEvaluationRunList = (
  output: any,
  context: __SerdeContext
): DataQualityRulesetEvaluationRunDescription[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return de_DataQualityRulesetEvaluationRunDescription(entry, context);
    });
  return retVal;
};

/**
 * deserializeAws_json1_1DataQualityRulesetList
 */
const de_DataQualityRulesetList = (output: any, context: __SerdeContext): DataQualityRulesetListDetails[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return de_DataQualityRulesetListDetails(entry, context);
    });
  return retVal;
};

/**
 * deserializeAws_json1_1DataQualityRulesetListDetails
 */
const de_DataQualityRulesetListDetails = (output: any, context: __SerdeContext): DataQualityRulesetListDetails => {
  return {
    CreatedOn:
      output.CreatedOn != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.CreatedOn))) : undefined,
    Description: __expectString(output.Description),
    LastModifiedOn:
      output.LastModifiedOn != null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.LastModifiedOn)))
        : undefined,
    Name: __expectString(output.Name),
    RecommendationRunId: __expectString(output.RecommendationRunId),
    RuleCount: __expectInt32(output.RuleCount),
    TargetTable: output.TargetTable != null ? de_DataQualityTargetTable(output.TargetTable, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1DataQualityTargetTable
 */
const de_DataQualityTargetTable = (output: any, context: __SerdeContext): DataQualityTargetTable => {
  return {
    DatabaseName: __expectString(output.DatabaseName),
    TableName: __expectString(output.TableName),
  } as any;
};

/**
 * deserializeAws_json1_1DataSource
 */
const de_DataSource = (output: any, context: __SerdeContext): DataSource => {
  return {
    GlueTable: output.GlueTable != null ? de_GlueTable(output.GlueTable, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1Datatype
 */
const de_Datatype = (output: any, context: __SerdeContext): Datatype => {
  return {
    Id: __expectString(output.Id),
    Label: __expectString(output.Label),
  } as any;
};

/**
 * deserializeAws_json1_1DateColumnStatisticsData
 */
const de_DateColumnStatisticsData = (output: any, context: __SerdeContext): DateColumnStatisticsData => {
  return {
    MaximumValue:
      output.MaximumValue != null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.MaximumValue)))
        : undefined,
    MinimumValue:
      output.MinimumValue != null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.MinimumValue)))
        : undefined,
    NumberOfDistinctValues: __expectLong(output.NumberOfDistinctValues),
    NumberOfNulls: __expectLong(output.NumberOfNulls),
  } as any;
};

/**
 * deserializeAws_json1_1DecimalColumnStatisticsData
 */
const de_DecimalColumnStatisticsData = (output: any, context: __SerdeContext): DecimalColumnStatisticsData => {
  return {
    MaximumValue: output.MaximumValue != null ? de_DecimalNumber(output.MaximumValue, context) : undefined,
    MinimumValue: output.MinimumValue != null ? de_DecimalNumber(output.MinimumValue, context) : undefined,
    NumberOfDistinctValues: __expectLong(output.NumberOfDistinctValues),
    NumberOfNulls: __expectLong(output.NumberOfNulls),
  } as any;
};

/**
 * deserializeAws_json1_1DecimalNumber
 */
const de_DecimalNumber = (output: any, context: __SerdeContext): DecimalNumber => {
  return {
    Scale: __expectInt32(output.Scale),
    UnscaledValue: output.UnscaledValue != null ? context.base64Decoder(output.UnscaledValue) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1DeleteBlueprintResponse
 */
const de_DeleteBlueprintResponse = (output: any, context: __SerdeContext): DeleteBlueprintResponse => {
  return {
    Name: __expectString(output.Name),
  } as any;
};

/**
 * deserializeAws_json1_1DeleteClassifierResponse
 */
const de_DeleteClassifierResponse = (output: any, context: __SerdeContext): DeleteClassifierResponse => {
  return {} as any;
};

/**
 * deserializeAws_json1_1DeleteColumnStatisticsForPartitionResponse
 */
const de_DeleteColumnStatisticsForPartitionResponse = (
  output: any,
  context: __SerdeContext
): DeleteColumnStatisticsForPartitionResponse => {
  return {} as any;
};

/**
 * deserializeAws_json1_1DeleteColumnStatisticsForTableResponse
 */
const de_DeleteColumnStatisticsForTableResponse = (
  output: any,
  context: __SerdeContext
): DeleteColumnStatisticsForTableResponse => {
  return {} as any;
};

/**
 * deserializeAws_json1_1DeleteConnectionResponse
 */
const de_DeleteConnectionResponse = (output: any, context: __SerdeContext): DeleteConnectionResponse => {
  return {} as any;
};

/**
 * deserializeAws_json1_1DeleteCrawlerResponse
 */
const de_DeleteCrawlerResponse = (output: any, context: __SerdeContext): DeleteCrawlerResponse => {
  return {} as any;
};

/**
 * deserializeAws_json1_1DeleteCustomEntityTypeResponse
 */
const de_DeleteCustomEntityTypeResponse = (output: any, context: __SerdeContext): DeleteCustomEntityTypeResponse => {
  return {
    Name: __expectString(output.Name),
  } as any;
};

/**
 * deserializeAws_json1_1DeleteDatabaseResponse
 */
const de_DeleteDatabaseResponse = (output: any, context: __SerdeContext): DeleteDatabaseResponse => {
  return {} as any;
};

/**
 * deserializeAws_json1_1DeleteDataQualityRulesetResponse
 */
const de_DeleteDataQualityRulesetResponse = (
  output: any,
  context: __SerdeContext
): DeleteDataQualityRulesetResponse => {
  return {} as any;
};

/**
 * deserializeAws_json1_1DeleteDevEndpointResponse
 */
const de_DeleteDevEndpointResponse = (output: any, context: __SerdeContext): DeleteDevEndpointResponse => {
  return {} as any;
};

/**
 * deserializeAws_json1_1DeleteJobResponse
 */
const de_DeleteJobResponse = (output: any, context: __SerdeContext): DeleteJobResponse => {
  return {
    JobName: __expectString(output.JobName),
  } as any;
};

/**
 * deserializeAws_json1_1DeleteMLTransformResponse
 */
const de_DeleteMLTransformResponse = (output: any, context: __SerdeContext): DeleteMLTransformResponse => {
  return {
    TransformId: __expectString(output.TransformId),
  } as any;
};

/**
 * deserializeAws_json1_1DeletePartitionIndexResponse
 */
const de_DeletePartitionIndexResponse = (output: any, context: __SerdeContext): DeletePartitionIndexResponse => {
  return {} as any;
};

/**
 * deserializeAws_json1_1DeletePartitionResponse
 */
const de_DeletePartitionResponse = (output: any, context: __SerdeContext): DeletePartitionResponse => {
  return {} as any;
};

/**
 * deserializeAws_json1_1DeleteRegistryResponse
 */
const de_DeleteRegistryResponse = (output: any, context: __SerdeContext): DeleteRegistryResponse => {
  return {
    RegistryArn: __expectString(output.RegistryArn),
    RegistryName: __expectString(output.RegistryName),
    Status: __expectString(output.Status),
  } as any;
};

/**
 * deserializeAws_json1_1DeleteResourcePolicyResponse
 */
const de_DeleteResourcePolicyResponse = (output: any, context: __SerdeContext): DeleteResourcePolicyResponse => {
  return {} as any;
};

/**
 * deserializeAws_json1_1DeleteSchemaResponse
 */
const de_DeleteSchemaResponse = (output: any, context: __SerdeContext): DeleteSchemaResponse => {
  return {
    SchemaArn: __expectString(output.SchemaArn),
    SchemaName: __expectString(output.SchemaName),
    Status: __expectString(output.Status),
  } as any;
};

/**
 * deserializeAws_json1_1DeleteSchemaVersionsResponse
 */
const de_DeleteSchemaVersionsResponse = (output: any, context: __SerdeContext): DeleteSchemaVersionsResponse => {
  return {
    SchemaVersionErrors:
      output.SchemaVersionErrors != null ? de_SchemaVersionErrorList(output.SchemaVersionErrors, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1DeleteSecurityConfigurationResponse
 */
const de_DeleteSecurityConfigurationResponse = (
  output: any,
  context: __SerdeContext
): DeleteSecurityConfigurationResponse => {
  return {} as any;
};

/**
 * deserializeAws_json1_1DeleteSessionResponse
 */
const de_DeleteSessionResponse = (output: any, context: __SerdeContext): DeleteSessionResponse => {
  return {
    Id: __expectString(output.Id),
  } as any;
};

/**
 * deserializeAws_json1_1DeleteTableResponse
 */
const de_DeleteTableResponse = (output: any, context: __SerdeContext): DeleteTableResponse => {
  return {} as any;
};

/**
 * deserializeAws_json1_1DeleteTableVersionResponse
 */
const de_DeleteTableVersionResponse = (output: any, context: __SerdeContext): DeleteTableVersionResponse => {
  return {} as any;
};

/**
 * deserializeAws_json1_1DeleteTriggerResponse
 */
const de_DeleteTriggerResponse = (output: any, context: __SerdeContext): DeleteTriggerResponse => {
  return {
    Name: __expectString(output.Name),
  } as any;
};

/**
 * deserializeAws_json1_1DeleteUserDefinedFunctionResponse
 */
const de_DeleteUserDefinedFunctionResponse = (
  output: any,
  context: __SerdeContext
): DeleteUserDefinedFunctionResponse => {
  return {} as any;
};

/**
 * deserializeAws_json1_1DeleteWorkflowResponse
 */
const de_DeleteWorkflowResponse = (output: any, context: __SerdeContext): DeleteWorkflowResponse => {
  return {
    Name: __expectString(output.Name),
  } as any;
};

/**
 * deserializeAws_json1_1DeltaTarget
 */
const de_DeltaTarget = (output: any, context: __SerdeContext): DeltaTarget => {
  return {
    ConnectionName: __expectString(output.ConnectionName),
    CreateNativeDeltaTable: __expectBoolean(output.CreateNativeDeltaTable),
    DeltaTables: output.DeltaTables != null ? de_PathList(output.DeltaTables, context) : undefined,
    WriteManifest: __expectBoolean(output.WriteManifest),
  } as any;
};

/**
 * deserializeAws_json1_1DeltaTargetList
 */
const de_DeltaTargetList = (output: any, context: __SerdeContext): DeltaTarget[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return de_DeltaTarget(entry, context);
    });
  return retVal;
};

/**
 * deserializeAws_json1_1DevEndpoint
 */
const de_DevEndpoint = (output: any, context: __SerdeContext): DevEndpoint => {
  return {
    Arguments: output.Arguments != null ? de_MapValue(output.Arguments, context) : undefined,
    AvailabilityZone: __expectString(output.AvailabilityZone),
    CreatedTimestamp:
      output.CreatedTimestamp != null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.CreatedTimestamp)))
        : undefined,
    EndpointName: __expectString(output.EndpointName),
    ExtraJarsS3Path: __expectString(output.ExtraJarsS3Path),
    ExtraPythonLibsS3Path: __expectString(output.ExtraPythonLibsS3Path),
    FailureReason: __expectString(output.FailureReason),
    GlueVersion: __expectString(output.GlueVersion),
    LastModifiedTimestamp:
      output.LastModifiedTimestamp != null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.LastModifiedTimestamp)))
        : undefined,
    LastUpdateStatus: __expectString(output.LastUpdateStatus),
    NumberOfNodes: __expectInt32(output.NumberOfNodes),
    NumberOfWorkers: __expectInt32(output.NumberOfWorkers),
    PrivateAddress: __expectString(output.PrivateAddress),
    PublicAddress: __expectString(output.PublicAddress),
    PublicKey: __expectString(output.PublicKey),
    PublicKeys: output.PublicKeys != null ? de_PublicKeysList(output.PublicKeys, context) : undefined,
    RoleArn: __expectString(output.RoleArn),
    SecurityConfiguration: __expectString(output.SecurityConfiguration),
    SecurityGroupIds: output.SecurityGroupIds != null ? de_StringList(output.SecurityGroupIds, context) : undefined,
    Status: __expectString(output.Status),
    SubnetId: __expectString(output.SubnetId),
    VpcId: __expectString(output.VpcId),
    WorkerType: __expectString(output.WorkerType),
    YarnEndpointAddress: __expectString(output.YarnEndpointAddress),
    ZeppelinRemoteSparkInterpreterPort: __expectInt32(output.ZeppelinRemoteSparkInterpreterPort),
  } as any;
};

/**
 * deserializeAws_json1_1DevEndpointList
 */
const de_DevEndpointList = (output: any, context: __SerdeContext): DevEndpoint[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return de_DevEndpoint(entry, context);
    });
  return retVal;
};

/**
 * deserializeAws_json1_1DevEndpointNameList
 */
const de_DevEndpointNameList = (output: any, context: __SerdeContext): string[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return __expectString(entry) as any;
    });
  return retVal;
};

/**
 * deserializeAws_json1_1DevEndpointNames
 */
const de_DevEndpointNames = (output: any, context: __SerdeContext): string[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return __expectString(entry) as any;
    });
  return retVal;
};

/**
 * deserializeAws_json1_1DirectJDBCSource
 */
const de_DirectJDBCSource = (output: any, context: __SerdeContext): DirectJDBCSource => {
  return {
    ConnectionName: __expectString(output.ConnectionName),
    ConnectionType: __expectString(output.ConnectionType),
    Database: __expectString(output.Database),
    Name: __expectString(output.Name),
    RedshiftTmpDir: __expectString(output.RedshiftTmpDir),
    Table: __expectString(output.Table),
  } as any;
};

/**
 * deserializeAws_json1_1DirectKafkaSource
 */
const de_DirectKafkaSource = (output: any, context: __SerdeContext): DirectKafkaSource => {
  return {
    DataPreviewOptions:
      output.DataPreviewOptions != null
        ? de_StreamingDataPreviewOptions(output.DataPreviewOptions, context)
        : undefined,
    DetectSchema: __expectBoolean(output.DetectSchema),
    Name: __expectString(output.Name),
    StreamingOptions:
      output.StreamingOptions != null ? de_KafkaStreamingSourceOptions(output.StreamingOptions, context) : undefined,
    WindowSize: __expectInt32(output.WindowSize),
  } as any;
};

/**
 * deserializeAws_json1_1DirectKinesisSource
 */
const de_DirectKinesisSource = (output: any, context: __SerdeContext): DirectKinesisSource => {
  return {
    DataPreviewOptions:
      output.DataPreviewOptions != null
        ? de_StreamingDataPreviewOptions(output.DataPreviewOptions, context)
        : undefined,
    DetectSchema: __expectBoolean(output.DetectSchema),
    Name: __expectString(output.Name),
    StreamingOptions:
      output.StreamingOptions != null ? de_KinesisStreamingSourceOptions(output.StreamingOptions, context) : undefined,
    WindowSize: __expectInt32(output.WindowSize),
  } as any;
};

/**
 * deserializeAws_json1_1DirectSchemaChangePolicy
 */
const de_DirectSchemaChangePolicy = (output: any, context: __SerdeContext): DirectSchemaChangePolicy => {
  return {
    Database: __expectString(output.Database),
    EnableUpdateCatalog: __expectBoolean(output.EnableUpdateCatalog),
    Table: __expectString(output.Table),
    UpdateBehavior: __expectString(output.UpdateBehavior),
  } as any;
};

/**
 * deserializeAws_json1_1DoubleColumnStatisticsData
 */
const de_DoubleColumnStatisticsData = (output: any, context: __SerdeContext): DoubleColumnStatisticsData => {
  return {
    MaximumValue: __limitedParseDouble(output.MaximumValue),
    MinimumValue: __limitedParseDouble(output.MinimumValue),
    NumberOfDistinctValues: __expectLong(output.NumberOfDistinctValues),
    NumberOfNulls: __expectLong(output.NumberOfNulls),
  } as any;
};

/**
 * deserializeAws_json1_1DQResultsPublishingOptions
 */
const de_DQResultsPublishingOptions = (output: any, context: __SerdeContext): DQResultsPublishingOptions => {
  return {
    CloudWatchMetricsEnabled: __expectBoolean(output.CloudWatchMetricsEnabled),
    EvaluationContext: __expectString(output.EvaluationContext),
    ResultsPublishingEnabled: __expectBoolean(output.ResultsPublishingEnabled),
    ResultsS3Prefix: __expectString(output.ResultsS3Prefix),
  } as any;
};

/**
 * deserializeAws_json1_1DQStopJobOnFailureOptions
 */
const de_DQStopJobOnFailureOptions = (output: any, context: __SerdeContext): DQStopJobOnFailureOptions => {
  return {
    StopJobOnFailureTiming: __expectString(output.StopJobOnFailureTiming),
  } as any;
};

/**
 * deserializeAws_json1_1DropDuplicates
 */
const de_DropDuplicates = (output: any, context: __SerdeContext): DropDuplicates => {
  return {
    Columns: output.Columns != null ? de_LimitedPathList(output.Columns, context) : undefined,
    Inputs: output.Inputs != null ? de_OneInput(output.Inputs, context) : undefined,
    Name: __expectString(output.Name),
  } as any;
};

/**
 * deserializeAws_json1_1DropFields
 */
const de_DropFields = (output: any, context: __SerdeContext): DropFields => {
  return {
    Inputs: output.Inputs != null ? de_OneInput(output.Inputs, context) : undefined,
    Name: __expectString(output.Name),
    Paths: output.Paths != null ? de_GlueStudioPathList(output.Paths, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1DropNullFields
 */
const de_DropNullFields = (output: any, context: __SerdeContext): DropNullFields => {
  return {
    Inputs: output.Inputs != null ? de_OneInput(output.Inputs, context) : undefined,
    Name: __expectString(output.Name),
    NullCheckBoxList:
      output.NullCheckBoxList != null ? de_NullCheckBoxList(output.NullCheckBoxList, context) : undefined,
    NullTextList: output.NullTextList != null ? de_NullValueFields(output.NullTextList, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1DynamicTransform
 */
const de_DynamicTransform = (output: any, context: __SerdeContext): DynamicTransform => {
  return {
    FunctionName: __expectString(output.FunctionName),
    Inputs: output.Inputs != null ? de_OneInput(output.Inputs, context) : undefined,
    Name: __expectString(output.Name),
    Parameters: output.Parameters != null ? de_TransformConfigParameterList(output.Parameters, context) : undefined,
    Path: __expectString(output.Path),
    TransformName: __expectString(output.TransformName),
    Version: __expectString(output.Version),
  } as any;
};

/**
 * deserializeAws_json1_1DynamoDBCatalogSource
 */
const de_DynamoDBCatalogSource = (output: any, context: __SerdeContext): DynamoDBCatalogSource => {
  return {
    Database: __expectString(output.Database),
    Name: __expectString(output.Name),
    Table: __expectString(output.Table),
  } as any;
};

/**
 * deserializeAws_json1_1DynamoDBTarget
 */
const de_DynamoDBTarget = (output: any, context: __SerdeContext): DynamoDBTarget => {
  return {
    Path: __expectString(output.Path),
    scanAll: __expectBoolean(output.scanAll),
    scanRate: __limitedParseDouble(output.scanRate),
  } as any;
};

/**
 * deserializeAws_json1_1DynamoDBTargetList
 */
const de_DynamoDBTargetList = (output: any, context: __SerdeContext): DynamoDBTarget[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return de_DynamoDBTarget(entry, context);
    });
  return retVal;
};

/**
 * deserializeAws_json1_1Edge
 */
const de_Edge = (output: any, context: __SerdeContext): Edge => {
  return {
    DestinationId: __expectString(output.DestinationId),
    SourceId: __expectString(output.SourceId),
  } as any;
};

/**
 * deserializeAws_json1_1EdgeList
 */
const de_EdgeList = (output: any, context: __SerdeContext): Edge[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return de_Edge(entry, context);
    });
  return retVal;
};

/**
 * deserializeAws_json1_1EnableAdditionalMetadata
 */
const de_EnableAdditionalMetadata = (output: any, context: __SerdeContext): (JdbcMetadataEntry | string)[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return __expectString(entry) as any;
    });
  return retVal;
};

/**
 * deserializeAws_json1_1EnclosedInStringProperties
 */
const de_EnclosedInStringProperties = (output: any, context: __SerdeContext): string[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return __expectString(entry) as any;
    });
  return retVal;
};

/**
 * deserializeAws_json1_1EnclosedInStringPropertiesMinOne
 */
const de_EnclosedInStringPropertiesMinOne = (output: any, context: __SerdeContext): string[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return __expectString(entry) as any;
    });
  return retVal;
};

/**
 * deserializeAws_json1_1EncryptionAtRest
 */
const de_EncryptionAtRest = (output: any, context: __SerdeContext): EncryptionAtRest => {
  return {
    CatalogEncryptionMode: __expectString(output.CatalogEncryptionMode),
    SseAwsKmsKeyId: __expectString(output.SseAwsKmsKeyId),
  } as any;
};

/**
 * deserializeAws_json1_1EncryptionConfiguration
 */
const de_EncryptionConfiguration = (output: any, context: __SerdeContext): EncryptionConfiguration => {
  return {
    CloudWatchEncryption:
      output.CloudWatchEncryption != null ? de_CloudWatchEncryption(output.CloudWatchEncryption, context) : undefined,
    JobBookmarksEncryption:
      output.JobBookmarksEncryption != null
        ? de_JobBookmarksEncryption(output.JobBookmarksEncryption, context)
        : undefined,
    S3Encryption: output.S3Encryption != null ? de_S3EncryptionList(output.S3Encryption, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1EntityNotFoundException
 */
const de_EntityNotFoundException = (output: any, context: __SerdeContext): EntityNotFoundException => {
  return {
    FromFederationSource: __expectBoolean(output.FromFederationSource),
    Message: __expectString(output.Message),
  } as any;
};

/**
 * deserializeAws_json1_1ErrorByName
 */
const de_ErrorByName = (output: any, context: __SerdeContext): Record<string, ErrorDetail> => {
  return Object.entries(output).reduce((acc: Record<string, ErrorDetail>, [key, value]: [string, any]) => {
    if (value === null) {
      return acc;
    }
    acc[key] = de_ErrorDetail(value, context);
    return acc;
  }, {});
};

/**
 * deserializeAws_json1_1ErrorDetail
 */
const de_ErrorDetail = (output: any, context: __SerdeContext): ErrorDetail => {
  return {
    ErrorCode: __expectString(output.ErrorCode),
    ErrorMessage: __expectString(output.ErrorMessage),
  } as any;
};

/**
 * deserializeAws_json1_1ErrorDetails
 */
const de_ErrorDetails = (output: any, context: __SerdeContext): ErrorDetails => {
  return {
    ErrorCode: __expectString(output.ErrorCode),
    ErrorMessage: __expectString(output.ErrorMessage),
  } as any;
};

/**
 * deserializeAws_json1_1EvaluateDataQuality
 */
const de_EvaluateDataQuality = (output: any, context: __SerdeContext): EvaluateDataQuality => {
  return {
    Inputs: output.Inputs != null ? de_OneInput(output.Inputs, context) : undefined,
    Name: __expectString(output.Name),
    Output: __expectString(output.Output),
    PublishingOptions:
      output.PublishingOptions != null ? de_DQResultsPublishingOptions(output.PublishingOptions, context) : undefined,
    Ruleset: __expectString(output.Ruleset),
    StopJobOnFailureOptions:
      output.StopJobOnFailureOptions != null
        ? de_DQStopJobOnFailureOptions(output.StopJobOnFailureOptions, context)
        : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1EvaluationMetrics
 */
const de_EvaluationMetrics = (output: any, context: __SerdeContext): EvaluationMetrics => {
  return {
    FindMatchesMetrics:
      output.FindMatchesMetrics != null ? de_FindMatchesMetrics(output.FindMatchesMetrics, context) : undefined,
    TransformType: __expectString(output.TransformType),
  } as any;
};

/**
 * deserializeAws_json1_1EventBatchingCondition
 */
const de_EventBatchingCondition = (output: any, context: __SerdeContext): EventBatchingCondition => {
  return {
    BatchSize: __expectInt32(output.BatchSize),
    BatchWindow: __expectInt32(output.BatchWindow),
  } as any;
};

/**
 * deserializeAws_json1_1ExecutionProperty
 */
const de_ExecutionProperty = (output: any, context: __SerdeContext): ExecutionProperty => {
  return {
    MaxConcurrentRuns: __expectInt32(output.MaxConcurrentRuns),
  } as any;
};

/**
 * deserializeAws_json1_1ExportLabelsTaskRunProperties
 */
const de_ExportLabelsTaskRunProperties = (output: any, context: __SerdeContext): ExportLabelsTaskRunProperties => {
  return {
    OutputS3Path: __expectString(output.OutputS3Path),
  } as any;
};

/**
 * deserializeAws_json1_1FederatedDatabase
 */
const de_FederatedDatabase = (output: any, context: __SerdeContext): FederatedDatabase => {
  return {
    ConnectionName: __expectString(output.ConnectionName),
    Identifier: __expectString(output.Identifier),
  } as any;
};

/**
 * deserializeAws_json1_1FederatedResourceAlreadyExistsException
 */
const de_FederatedResourceAlreadyExistsException = (
  output: any,
  context: __SerdeContext
): FederatedResourceAlreadyExistsException => {
  return {
    AssociatedGlueResource: __expectString(output.AssociatedGlueResource),
    Message: __expectString(output.Message),
  } as any;
};

/**
 * deserializeAws_json1_1FederatedTable
 */
const de_FederatedTable = (output: any, context: __SerdeContext): FederatedTable => {
  return {
    ConnectionName: __expectString(output.ConnectionName),
    DatabaseIdentifier: __expectString(output.DatabaseIdentifier),
    Identifier: __expectString(output.Identifier),
  } as any;
};

/**
 * deserializeAws_json1_1FederationSourceException
 */
const de_FederationSourceException = (output: any, context: __SerdeContext): FederationSourceException => {
  return {
    FederationSourceErrorCode: __expectString(output.FederationSourceErrorCode),
    Message: __expectString(output.Message),
  } as any;
};

/**
 * deserializeAws_json1_1FederationSourceRetryableException
 */
const de_FederationSourceRetryableException = (
  output: any,
  context: __SerdeContext
): FederationSourceRetryableException => {
  return {
    Message: __expectString(output.Message),
  } as any;
};

/**
 * deserializeAws_json1_1FillMissingValues
 */
const de_FillMissingValues = (output: any, context: __SerdeContext): FillMissingValues => {
  return {
    FilledPath: __expectString(output.FilledPath),
    ImputedPath: __expectString(output.ImputedPath),
    Inputs: output.Inputs != null ? de_OneInput(output.Inputs, context) : undefined,
    Name: __expectString(output.Name),
  } as any;
};

/**
 * deserializeAws_json1_1Filter
 */
const de_Filter = (output: any, context: __SerdeContext): Filter => {
  return {
    Filters: output.Filters != null ? de_FilterExpressions(output.Filters, context) : undefined,
    Inputs: output.Inputs != null ? de_OneInput(output.Inputs, context) : undefined,
    LogicalOperator: __expectString(output.LogicalOperator),
    Name: __expectString(output.Name),
  } as any;
};

/**
 * deserializeAws_json1_1FilterExpression
 */
const de_FilterExpression = (output: any, context: __SerdeContext): FilterExpression => {
  return {
    Negated: __expectBoolean(output.Negated),
    Operation: __expectString(output.Operation),
    Values: output.Values != null ? de_FilterValues(output.Values, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1FilterExpressions
 */
const de_FilterExpressions = (output: any, context: __SerdeContext): FilterExpression[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return de_FilterExpression(entry, context);
    });
  return retVal;
};

/**
 * deserializeAws_json1_1FilterValue
 */
const de_FilterValue = (output: any, context: __SerdeContext): FilterValue => {
  return {
    Type: __expectString(output.Type),
    Value: output.Value != null ? de_EnclosedInStringProperties(output.Value, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1FilterValues
 */
const de_FilterValues = (output: any, context: __SerdeContext): FilterValue[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return de_FilterValue(entry, context);
    });
  return retVal;
};

/**
 * deserializeAws_json1_1FindMatchesMetrics
 */
const de_FindMatchesMetrics = (output: any, context: __SerdeContext): FindMatchesMetrics => {
  return {
    AreaUnderPRCurve: __limitedParseDouble(output.AreaUnderPRCurve),
    ColumnImportances:
      output.ColumnImportances != null ? de_ColumnImportanceList(output.ColumnImportances, context) : undefined,
    ConfusionMatrix: output.ConfusionMatrix != null ? de_ConfusionMatrix(output.ConfusionMatrix, context) : undefined,
    F1: __limitedParseDouble(output.F1),
    Precision: __limitedParseDouble(output.Precision),
    Recall: __limitedParseDouble(output.Recall),
  } as any;
};

/**
 * deserializeAws_json1_1FindMatchesParameters
 */
const de_FindMatchesParameters = (output: any, context: __SerdeContext): FindMatchesParameters => {
  return {
    AccuracyCostTradeoff: __limitedParseDouble(output.AccuracyCostTradeoff),
    EnforceProvidedLabels: __expectBoolean(output.EnforceProvidedLabels),
    PrecisionRecallTradeoff: __limitedParseDouble(output.PrecisionRecallTradeoff),
    PrimaryKeyColumnName: __expectString(output.PrimaryKeyColumnName),
  } as any;
};

/**
 * deserializeAws_json1_1FindMatchesTaskRunProperties
 */
const de_FindMatchesTaskRunProperties = (output: any, context: __SerdeContext): FindMatchesTaskRunProperties => {
  return {
    JobId: __expectString(output.JobId),
    JobName: __expectString(output.JobName),
    JobRunId: __expectString(output.JobRunId),
  } as any;
};

/**
 * deserializeAws_json1_1GenericMap
 */
const de_GenericMap = (output: any, context: __SerdeContext): Record<string, string> => {
  return Object.entries(output).reduce((acc: Record<string, string>, [key, value]: [string, any]) => {
    if (value === null) {
      return acc;
    }
    acc[key] = __expectString(value) as any;
    return acc;
  }, {});
};

/**
 * deserializeAws_json1_1GetBlueprintResponse
 */
const de_GetBlueprintResponse = (output: any, context: __SerdeContext): GetBlueprintResponse => {
  return {
    Blueprint: output.Blueprint != null ? de_Blueprint(output.Blueprint, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1GetBlueprintRunResponse
 */
const de_GetBlueprintRunResponse = (output: any, context: __SerdeContext): GetBlueprintRunResponse => {
  return {
    BlueprintRun: output.BlueprintRun != null ? de_BlueprintRun(output.BlueprintRun, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1GetBlueprintRunsResponse
 */
const de_GetBlueprintRunsResponse = (output: any, context: __SerdeContext): GetBlueprintRunsResponse => {
  return {
    BlueprintRuns: output.BlueprintRuns != null ? de_BlueprintRuns(output.BlueprintRuns, context) : undefined,
    NextToken: __expectString(output.NextToken),
  } as any;
};

/**
 * deserializeAws_json1_1GetCatalogImportStatusResponse
 */
const de_GetCatalogImportStatusResponse = (output: any, context: __SerdeContext): GetCatalogImportStatusResponse => {
  return {
    ImportStatus: output.ImportStatus != null ? de_CatalogImportStatus(output.ImportStatus, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1GetClassifierResponse
 */
const de_GetClassifierResponse = (output: any, context: __SerdeContext): GetClassifierResponse => {
  return {
    Classifier: output.Classifier != null ? de_Classifier(output.Classifier, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1GetClassifiersResponse
 */
const de_GetClassifiersResponse = (output: any, context: __SerdeContext): GetClassifiersResponse => {
  return {
    Classifiers: output.Classifiers != null ? de_ClassifierList(output.Classifiers, context) : undefined,
    NextToken: __expectString(output.NextToken),
  } as any;
};

/**
 * deserializeAws_json1_1GetColumnStatisticsForPartitionResponse
 */
const de_GetColumnStatisticsForPartitionResponse = (
  output: any,
  context: __SerdeContext
): GetColumnStatisticsForPartitionResponse => {
  return {
    ColumnStatisticsList:
      output.ColumnStatisticsList != null ? de_ColumnStatisticsList(output.ColumnStatisticsList, context) : undefined,
    Errors: output.Errors != null ? de_ColumnErrors(output.Errors, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1GetColumnStatisticsForTableResponse
 */
const de_GetColumnStatisticsForTableResponse = (
  output: any,
  context: __SerdeContext
): GetColumnStatisticsForTableResponse => {
  return {
    ColumnStatisticsList:
      output.ColumnStatisticsList != null ? de_ColumnStatisticsList(output.ColumnStatisticsList, context) : undefined,
    Errors: output.Errors != null ? de_ColumnErrors(output.Errors, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1GetConnectionResponse
 */
const de_GetConnectionResponse = (output: any, context: __SerdeContext): GetConnectionResponse => {
  return {
    Connection: output.Connection != null ? de_Connection(output.Connection, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1GetConnectionsResponse
 */
const de_GetConnectionsResponse = (output: any, context: __SerdeContext): GetConnectionsResponse => {
  return {
    ConnectionList: output.ConnectionList != null ? de_ConnectionList(output.ConnectionList, context) : undefined,
    NextToken: __expectString(output.NextToken),
  } as any;
};

/**
 * deserializeAws_json1_1GetCrawlerMetricsResponse
 */
const de_GetCrawlerMetricsResponse = (output: any, context: __SerdeContext): GetCrawlerMetricsResponse => {
  return {
    CrawlerMetricsList:
      output.CrawlerMetricsList != null ? de_CrawlerMetricsList(output.CrawlerMetricsList, context) : undefined,
    NextToken: __expectString(output.NextToken),
  } as any;
};

/**
 * deserializeAws_json1_1GetCrawlerResponse
 */
const de_GetCrawlerResponse = (output: any, context: __SerdeContext): GetCrawlerResponse => {
  return {
    Crawler: output.Crawler != null ? de_Crawler(output.Crawler, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1GetCrawlersResponse
 */
const de_GetCrawlersResponse = (output: any, context: __SerdeContext): GetCrawlersResponse => {
  return {
    Crawlers: output.Crawlers != null ? de_CrawlerList(output.Crawlers, context) : undefined,
    NextToken: __expectString(output.NextToken),
  } as any;
};

/**
 * deserializeAws_json1_1GetCustomEntityTypeResponse
 */
const de_GetCustomEntityTypeResponse = (output: any, context: __SerdeContext): GetCustomEntityTypeResponse => {
  return {
    ContextWords: output.ContextWords != null ? de_ContextWords(output.ContextWords, context) : undefined,
    Name: __expectString(output.Name),
    RegexString: __expectString(output.RegexString),
  } as any;
};

/**
 * deserializeAws_json1_1GetDatabaseResponse
 */
const de_GetDatabaseResponse = (output: any, context: __SerdeContext): GetDatabaseResponse => {
  return {
    Database: output.Database != null ? de_Database(output.Database, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1GetDatabasesResponse
 */
const de_GetDatabasesResponse = (output: any, context: __SerdeContext): GetDatabasesResponse => {
  return {
    DatabaseList: output.DatabaseList != null ? de_DatabaseList(output.DatabaseList, context) : undefined,
    NextToken: __expectString(output.NextToken),
  } as any;
};

/**
 * deserializeAws_json1_1GetDataCatalogEncryptionSettingsResponse
 */
const de_GetDataCatalogEncryptionSettingsResponse = (
  output: any,
  context: __SerdeContext
): GetDataCatalogEncryptionSettingsResponse => {
  return {
    DataCatalogEncryptionSettings:
      output.DataCatalogEncryptionSettings != null
        ? de_DataCatalogEncryptionSettings(output.DataCatalogEncryptionSettings, context)
        : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1GetDataflowGraphResponse
 */
const de_GetDataflowGraphResponse = (output: any, context: __SerdeContext): GetDataflowGraphResponse => {
  return {
    DagEdges: output.DagEdges != null ? de_DagEdges(output.DagEdges, context) : undefined,
    DagNodes: output.DagNodes != null ? de_DagNodes(output.DagNodes, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1GetDataQualityResultResponse
 */
const de_GetDataQualityResultResponse = (output: any, context: __SerdeContext): GetDataQualityResultResponse => {
  return {
    CompletedOn:
      output.CompletedOn != null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.CompletedOn)))
        : undefined,
    DataSource: output.DataSource != null ? de_DataSource(output.DataSource, context) : undefined,
    EvaluationContext: __expectString(output.EvaluationContext),
    JobName: __expectString(output.JobName),
    JobRunId: __expectString(output.JobRunId),
    ResultId: __expectString(output.ResultId),
    RuleResults: output.RuleResults != null ? de_DataQualityRuleResults(output.RuleResults, context) : undefined,
    RulesetEvaluationRunId: __expectString(output.RulesetEvaluationRunId),
    RulesetName: __expectString(output.RulesetName),
    Score: __limitedParseDouble(output.Score),
    StartedOn:
      output.StartedOn != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.StartedOn))) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1GetDataQualityRuleRecommendationRunResponse
 */
const de_GetDataQualityRuleRecommendationRunResponse = (
  output: any,
  context: __SerdeContext
): GetDataQualityRuleRecommendationRunResponse => {
  return {
    CompletedOn:
      output.CompletedOn != null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.CompletedOn)))
        : undefined,
    CreatedRulesetName: __expectString(output.CreatedRulesetName),
    DataSource: output.DataSource != null ? de_DataSource(output.DataSource, context) : undefined,
    ErrorString: __expectString(output.ErrorString),
    ExecutionTime: __expectInt32(output.ExecutionTime),
    LastModifiedOn:
      output.LastModifiedOn != null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.LastModifiedOn)))
        : undefined,
    NumberOfWorkers: __expectInt32(output.NumberOfWorkers),
    RecommendedRuleset: __expectString(output.RecommendedRuleset),
    Role: __expectString(output.Role),
    RunId: __expectString(output.RunId),
    StartedOn:
      output.StartedOn != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.StartedOn))) : undefined,
    Status: __expectString(output.Status),
    Timeout: __expectInt32(output.Timeout),
  } as any;
};

/**
 * deserializeAws_json1_1GetDataQualityRulesetEvaluationRunResponse
 */
const de_GetDataQualityRulesetEvaluationRunResponse = (
  output: any,
  context: __SerdeContext
): GetDataQualityRulesetEvaluationRunResponse => {
  return {
    AdditionalRunOptions:
      output.AdditionalRunOptions != null
        ? de_DataQualityEvaluationRunAdditionalRunOptions(output.AdditionalRunOptions, context)
        : undefined,
    CompletedOn:
      output.CompletedOn != null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.CompletedOn)))
        : undefined,
    DataSource: output.DataSource != null ? de_DataSource(output.DataSource, context) : undefined,
    ErrorString: __expectString(output.ErrorString),
    ExecutionTime: __expectInt32(output.ExecutionTime),
    LastModifiedOn:
      output.LastModifiedOn != null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.LastModifiedOn)))
        : undefined,
    NumberOfWorkers: __expectInt32(output.NumberOfWorkers),
    ResultIds: output.ResultIds != null ? de_DataQualityResultIdList(output.ResultIds, context) : undefined,
    Role: __expectString(output.Role),
    RulesetNames: output.RulesetNames != null ? de_RulesetNames(output.RulesetNames, context) : undefined,
    RunId: __expectString(output.RunId),
    StartedOn:
      output.StartedOn != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.StartedOn))) : undefined,
    Status: __expectString(output.Status),
    Timeout: __expectInt32(output.Timeout),
  } as any;
};

/**
 * deserializeAws_json1_1GetDataQualityRulesetResponse
 */
const de_GetDataQualityRulesetResponse = (output: any, context: __SerdeContext): GetDataQualityRulesetResponse => {
  return {
    CreatedOn:
      output.CreatedOn != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.CreatedOn))) : undefined,
    Description: __expectString(output.Description),
    LastModifiedOn:
      output.LastModifiedOn != null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.LastModifiedOn)))
        : undefined,
    Name: __expectString(output.Name),
    RecommendationRunId: __expectString(output.RecommendationRunId),
    Ruleset: __expectString(output.Ruleset),
    TargetTable: output.TargetTable != null ? de_DataQualityTargetTable(output.TargetTable, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1GetDevEndpointResponse
 */
const de_GetDevEndpointResponse = (output: any, context: __SerdeContext): GetDevEndpointResponse => {
  return {
    DevEndpoint: output.DevEndpoint != null ? de_DevEndpoint(output.DevEndpoint, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1GetDevEndpointsResponse
 */
const de_GetDevEndpointsResponse = (output: any, context: __SerdeContext): GetDevEndpointsResponse => {
  return {
    DevEndpoints: output.DevEndpoints != null ? de_DevEndpointList(output.DevEndpoints, context) : undefined,
    NextToken: __expectString(output.NextToken),
  } as any;
};

/**
 * deserializeAws_json1_1GetJobBookmarkResponse
 */
const de_GetJobBookmarkResponse = (output: any, context: __SerdeContext): GetJobBookmarkResponse => {
  return {
    JobBookmarkEntry:
      output.JobBookmarkEntry != null ? de_JobBookmarkEntry(output.JobBookmarkEntry, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1GetJobResponse
 */
const de_GetJobResponse = (output: any, context: __SerdeContext): GetJobResponse => {
  return {
    Job: output.Job != null ? de_Job(output.Job, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1GetJobRunResponse
 */
const de_GetJobRunResponse = (output: any, context: __SerdeContext): GetJobRunResponse => {
  return {
    JobRun: output.JobRun != null ? de_JobRun(output.JobRun, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1GetJobRunsResponse
 */
const de_GetJobRunsResponse = (output: any, context: __SerdeContext): GetJobRunsResponse => {
  return {
    JobRuns: output.JobRuns != null ? de_JobRunList(output.JobRuns, context) : undefined,
    NextToken: __expectString(output.NextToken),
  } as any;
};

/**
 * deserializeAws_json1_1GetJobsResponse
 */
const de_GetJobsResponse = (output: any, context: __SerdeContext): GetJobsResponse => {
  return {
    Jobs: output.Jobs != null ? de_JobList(output.Jobs, context) : undefined,
    NextToken: __expectString(output.NextToken),
  } as any;
};

/**
 * deserializeAws_json1_1GetMappingResponse
 */
const de_GetMappingResponse = (output: any, context: __SerdeContext): GetMappingResponse => {
  return {
    Mapping: output.Mapping != null ? de_MappingList(output.Mapping, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1GetMLTaskRunResponse
 */
const de_GetMLTaskRunResponse = (output: any, context: __SerdeContext): GetMLTaskRunResponse => {
  return {
    CompletedOn:
      output.CompletedOn != null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.CompletedOn)))
        : undefined,
    ErrorString: __expectString(output.ErrorString),
    ExecutionTime: __expectInt32(output.ExecutionTime),
    LastModifiedOn:
      output.LastModifiedOn != null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.LastModifiedOn)))
        : undefined,
    LogGroupName: __expectString(output.LogGroupName),
    Properties: output.Properties != null ? de_TaskRunProperties(output.Properties, context) : undefined,
    StartedOn:
      output.StartedOn != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.StartedOn))) : undefined,
    Status: __expectString(output.Status),
    TaskRunId: __expectString(output.TaskRunId),
    TransformId: __expectString(output.TransformId),
  } as any;
};

/**
 * deserializeAws_json1_1GetMLTaskRunsResponse
 */
const de_GetMLTaskRunsResponse = (output: any, context: __SerdeContext): GetMLTaskRunsResponse => {
  return {
    NextToken: __expectString(output.NextToken),
    TaskRuns: output.TaskRuns != null ? de_TaskRunList(output.TaskRuns, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1GetMLTransformResponse
 */
const de_GetMLTransformResponse = (output: any, context: __SerdeContext): GetMLTransformResponse => {
  return {
    CreatedOn:
      output.CreatedOn != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.CreatedOn))) : undefined,
    Description: __expectString(output.Description),
    EvaluationMetrics:
      output.EvaluationMetrics != null ? de_EvaluationMetrics(output.EvaluationMetrics, context) : undefined,
    GlueVersion: __expectString(output.GlueVersion),
    InputRecordTables: output.InputRecordTables != null ? de_GlueTables(output.InputRecordTables, context) : undefined,
    LabelCount: __expectInt32(output.LabelCount),
    LastModifiedOn:
      output.LastModifiedOn != null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.LastModifiedOn)))
        : undefined,
    MaxCapacity: __limitedParseDouble(output.MaxCapacity),
    MaxRetries: __expectInt32(output.MaxRetries),
    Name: __expectString(output.Name),
    NumberOfWorkers: __expectInt32(output.NumberOfWorkers),
    Parameters: output.Parameters != null ? de_TransformParameters(output.Parameters, context) : undefined,
    Role: __expectString(output.Role),
    Schema: output.Schema != null ? de_TransformSchema(output.Schema, context) : undefined,
    Status: __expectString(output.Status),
    Timeout: __expectInt32(output.Timeout),
    TransformEncryption:
      output.TransformEncryption != null ? de_TransformEncryption(output.TransformEncryption, context) : undefined,
    TransformId: __expectString(output.TransformId),
    WorkerType: __expectString(output.WorkerType),
  } as any;
};

/**
 * deserializeAws_json1_1GetMLTransformsResponse
 */
const de_GetMLTransformsResponse = (output: any, context: __SerdeContext): GetMLTransformsResponse => {
  return {
    NextToken: __expectString(output.NextToken),
    Transforms: output.Transforms != null ? de_TransformList(output.Transforms, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1GetPartitionIndexesResponse
 */
const de_GetPartitionIndexesResponse = (output: any, context: __SerdeContext): GetPartitionIndexesResponse => {
  return {
    NextToken: __expectString(output.NextToken),
    PartitionIndexDescriptorList:
      output.PartitionIndexDescriptorList != null
        ? de_PartitionIndexDescriptorList(output.PartitionIndexDescriptorList, context)
        : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1GetPartitionResponse
 */
const de_GetPartitionResponse = (output: any, context: __SerdeContext): GetPartitionResponse => {
  return {
    Partition: output.Partition != null ? de_Partition(output.Partition, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1GetPartitionsResponse
 */
const de_GetPartitionsResponse = (output: any, context: __SerdeContext): GetPartitionsResponse => {
  return {
    NextToken: __expectString(output.NextToken),
    Partitions: output.Partitions != null ? de_PartitionList(output.Partitions, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1GetPlanResponse
 */
const de_GetPlanResponse = (output: any, context: __SerdeContext): GetPlanResponse => {
  return {
    PythonScript: __expectString(output.PythonScript),
    ScalaCode: __expectString(output.ScalaCode),
  } as any;
};

/**
 * deserializeAws_json1_1GetRegistryResponse
 */
const de_GetRegistryResponse = (output: any, context: __SerdeContext): GetRegistryResponse => {
  return {
    CreatedTime: __expectString(output.CreatedTime),
    Description: __expectString(output.Description),
    RegistryArn: __expectString(output.RegistryArn),
    RegistryName: __expectString(output.RegistryName),
    Status: __expectString(output.Status),
    UpdatedTime: __expectString(output.UpdatedTime),
  } as any;
};

/**
 * deserializeAws_json1_1GetResourcePoliciesResponse
 */
const de_GetResourcePoliciesResponse = (output: any, context: __SerdeContext): GetResourcePoliciesResponse => {
  return {
    GetResourcePoliciesResponseList:
      output.GetResourcePoliciesResponseList != null
        ? de_GetResourcePoliciesResponseList(output.GetResourcePoliciesResponseList, context)
        : undefined,
    NextToken: __expectString(output.NextToken),
  } as any;
};

/**
 * deserializeAws_json1_1GetResourcePoliciesResponseList
 */
const de_GetResourcePoliciesResponseList = (output: any, context: __SerdeContext): GluePolicy[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return de_GluePolicy(entry, context);
    });
  return retVal;
};

/**
 * deserializeAws_json1_1GetResourcePolicyResponse
 */
const de_GetResourcePolicyResponse = (output: any, context: __SerdeContext): GetResourcePolicyResponse => {
  return {
    CreateTime:
      output.CreateTime != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.CreateTime))) : undefined,
    PolicyHash: __expectString(output.PolicyHash),
    PolicyInJson: __expectString(output.PolicyInJson),
    UpdateTime:
      output.UpdateTime != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.UpdateTime))) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1GetSchemaByDefinitionResponse
 */
const de_GetSchemaByDefinitionResponse = (output: any, context: __SerdeContext): GetSchemaByDefinitionResponse => {
  return {
    CreatedTime: __expectString(output.CreatedTime),
    DataFormat: __expectString(output.DataFormat),
    SchemaArn: __expectString(output.SchemaArn),
    SchemaVersionId: __expectString(output.SchemaVersionId),
    Status: __expectString(output.Status),
  } as any;
};

/**
 * deserializeAws_json1_1GetSchemaResponse
 */
const de_GetSchemaResponse = (output: any, context: __SerdeContext): GetSchemaResponse => {
  return {
    Compatibility: __expectString(output.Compatibility),
    CreatedTime: __expectString(output.CreatedTime),
    DataFormat: __expectString(output.DataFormat),
    Description: __expectString(output.Description),
    LatestSchemaVersion: __expectLong(output.LatestSchemaVersion),
    NextSchemaVersion: __expectLong(output.NextSchemaVersion),
    RegistryArn: __expectString(output.RegistryArn),
    RegistryName: __expectString(output.RegistryName),
    SchemaArn: __expectString(output.SchemaArn),
    SchemaCheckpoint: __expectLong(output.SchemaCheckpoint),
    SchemaName: __expectString(output.SchemaName),
    SchemaStatus: __expectString(output.SchemaStatus),
    UpdatedTime: __expectString(output.UpdatedTime),
  } as any;
};

/**
 * deserializeAws_json1_1GetSchemaVersionResponse
 */
const de_GetSchemaVersionResponse = (output: any, context: __SerdeContext): GetSchemaVersionResponse => {
  return {
    CreatedTime: __expectString(output.CreatedTime),
    DataFormat: __expectString(output.DataFormat),
    SchemaArn: __expectString(output.SchemaArn),
    SchemaDefinition: __expectString(output.SchemaDefinition),
    SchemaVersionId: __expectString(output.SchemaVersionId),
    Status: __expectString(output.Status),
    VersionNumber: __expectLong(output.VersionNumber),
  } as any;
};

/**
 * deserializeAws_json1_1GetSchemaVersionsDiffResponse
 */
const de_GetSchemaVersionsDiffResponse = (output: any, context: __SerdeContext): GetSchemaVersionsDiffResponse => {
  return {
    Diff: __expectString(output.Diff),
  } as any;
};

/**
 * deserializeAws_json1_1GetSecurityConfigurationResponse
 */
const de_GetSecurityConfigurationResponse = (
  output: any,
  context: __SerdeContext
): GetSecurityConfigurationResponse => {
  return {
    SecurityConfiguration:
      output.SecurityConfiguration != null
        ? de_SecurityConfiguration(output.SecurityConfiguration, context)
        : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1GetSecurityConfigurationsResponse
 */
const de_GetSecurityConfigurationsResponse = (
  output: any,
  context: __SerdeContext
): GetSecurityConfigurationsResponse => {
  return {
    NextToken: __expectString(output.NextToken),
    SecurityConfigurations:
      output.SecurityConfigurations != null
        ? de_SecurityConfigurationList(output.SecurityConfigurations, context)
        : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1GetSessionResponse
 */
const de_GetSessionResponse = (output: any, context: __SerdeContext): GetSessionResponse => {
  return {
    Session: output.Session != null ? de_Session(output.Session, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1GetStatementResponse
 */
const de_GetStatementResponse = (output: any, context: __SerdeContext): GetStatementResponse => {
  return {
    Statement: output.Statement != null ? de_Statement(output.Statement, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1GetTableResponse
 */
const de_GetTableResponse = (output: any, context: __SerdeContext): GetTableResponse => {
  return {
    Table: output.Table != null ? de_Table(output.Table, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1GetTablesResponse
 */
const de_GetTablesResponse = (output: any, context: __SerdeContext): GetTablesResponse => {
  return {
    NextToken: __expectString(output.NextToken),
    TableList: output.TableList != null ? de_TableList(output.TableList, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1GetTableVersionResponse
 */
const de_GetTableVersionResponse = (output: any, context: __SerdeContext): GetTableVersionResponse => {
  return {
    TableVersion: output.TableVersion != null ? de_TableVersion(output.TableVersion, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1GetTableVersionsList
 */
const de_GetTableVersionsList = (output: any, context: __SerdeContext): TableVersion[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return de_TableVersion(entry, context);
    });
  return retVal;
};

/**
 * deserializeAws_json1_1GetTableVersionsResponse
 */
const de_GetTableVersionsResponse = (output: any, context: __SerdeContext): GetTableVersionsResponse => {
  return {
    NextToken: __expectString(output.NextToken),
    TableVersions: output.TableVersions != null ? de_GetTableVersionsList(output.TableVersions, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1GetTagsResponse
 */
const de_GetTagsResponse = (output: any, context: __SerdeContext): GetTagsResponse => {
  return {
    Tags: output.Tags != null ? de_TagsMap(output.Tags, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1GetTriggerResponse
 */
const de_GetTriggerResponse = (output: any, context: __SerdeContext): GetTriggerResponse => {
  return {
    Trigger: output.Trigger != null ? de_Trigger(output.Trigger, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1GetTriggersResponse
 */
const de_GetTriggersResponse = (output: any, context: __SerdeContext): GetTriggersResponse => {
  return {
    NextToken: __expectString(output.NextToken),
    Triggers: output.Triggers != null ? de_TriggerList(output.Triggers, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1GetUnfilteredPartitionMetadataResponse
 */
const de_GetUnfilteredPartitionMetadataResponse = (
  output: any,
  context: __SerdeContext
): GetUnfilteredPartitionMetadataResponse => {
  return {
    AuthorizedColumns:
      output.AuthorizedColumns != null ? de_NameStringList(output.AuthorizedColumns, context) : undefined,
    IsRegisteredWithLakeFormation: __expectBoolean(output.IsRegisteredWithLakeFormation),
    Partition: output.Partition != null ? de_Partition(output.Partition, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1GetUnfilteredPartitionsMetadataResponse
 */
const de_GetUnfilteredPartitionsMetadataResponse = (
  output: any,
  context: __SerdeContext
): GetUnfilteredPartitionsMetadataResponse => {
  return {
    NextToken: __expectString(output.NextToken),
    UnfilteredPartitions:
      output.UnfilteredPartitions != null
        ? de_UnfilteredPartitionList(output.UnfilteredPartitions, context)
        : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1GetUnfilteredTableMetadataResponse
 */
const de_GetUnfilteredTableMetadataResponse = (
  output: any,
  context: __SerdeContext
): GetUnfilteredTableMetadataResponse => {
  return {
    AuthorizedColumns:
      output.AuthorizedColumns != null ? de_NameStringList(output.AuthorizedColumns, context) : undefined,
    CellFilters: output.CellFilters != null ? de_ColumnRowFilterList(output.CellFilters, context) : undefined,
    IsRegisteredWithLakeFormation: __expectBoolean(output.IsRegisteredWithLakeFormation),
    Table: output.Table != null ? de_Table(output.Table, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1GetUserDefinedFunctionResponse
 */
const de_GetUserDefinedFunctionResponse = (output: any, context: __SerdeContext): GetUserDefinedFunctionResponse => {
  return {
    UserDefinedFunction:
      output.UserDefinedFunction != null ? de_UserDefinedFunction(output.UserDefinedFunction, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1GetUserDefinedFunctionsResponse
 */
const de_GetUserDefinedFunctionsResponse = (output: any, context: __SerdeContext): GetUserDefinedFunctionsResponse => {
  return {
    NextToken: __expectString(output.NextToken),
    UserDefinedFunctions:
      output.UserDefinedFunctions != null
        ? de_UserDefinedFunctionList(output.UserDefinedFunctions, context)
        : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1GetWorkflowResponse
 */
const de_GetWorkflowResponse = (output: any, context: __SerdeContext): GetWorkflowResponse => {
  return {
    Workflow: output.Workflow != null ? de_Workflow(output.Workflow, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1GetWorkflowRunPropertiesResponse
 */
const de_GetWorkflowRunPropertiesResponse = (
  output: any,
  context: __SerdeContext
): GetWorkflowRunPropertiesResponse => {
  return {
    RunProperties: output.RunProperties != null ? de_WorkflowRunProperties(output.RunProperties, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1GetWorkflowRunResponse
 */
const de_GetWorkflowRunResponse = (output: any, context: __SerdeContext): GetWorkflowRunResponse => {
  return {
    Run: output.Run != null ? de_WorkflowRun(output.Run, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1GetWorkflowRunsResponse
 */
const de_GetWorkflowRunsResponse = (output: any, context: __SerdeContext): GetWorkflowRunsResponse => {
  return {
    NextToken: __expectString(output.NextToken),
    Runs: output.Runs != null ? de_WorkflowRuns(output.Runs, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1GlueEncryptionException
 */
const de_GlueEncryptionException = (output: any, context: __SerdeContext): GlueEncryptionException => {
  return {
    Message: __expectString(output.Message),
  } as any;
};

/**
 * deserializeAws_json1_1GluePolicy
 */
const de_GluePolicy = (output: any, context: __SerdeContext): GluePolicy => {
  return {
    CreateTime:
      output.CreateTime != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.CreateTime))) : undefined,
    PolicyHash: __expectString(output.PolicyHash),
    PolicyInJson: __expectString(output.PolicyInJson),
    UpdateTime:
      output.UpdateTime != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.UpdateTime))) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1GlueSchema
 */
const de_GlueSchema = (output: any, context: __SerdeContext): GlueSchema => {
  return {
    Columns: output.Columns != null ? de_GlueStudioSchemaColumnList(output.Columns, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1GlueSchemas
 */
const de_GlueSchemas = (output: any, context: __SerdeContext): GlueSchema[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return de_GlueSchema(entry, context);
    });
  return retVal;
};

/**
 * deserializeAws_json1_1GlueStudioPathList
 */
const de_GlueStudioPathList = (output: any, context: __SerdeContext): string[][] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return de_EnclosedInStringProperties(entry, context);
    });
  return retVal;
};

/**
 * deserializeAws_json1_1GlueStudioSchemaColumn
 */
const de_GlueStudioSchemaColumn = (output: any, context: __SerdeContext): GlueStudioSchemaColumn => {
  return {
    Name: __expectString(output.Name),
    Type: __expectString(output.Type),
  } as any;
};

/**
 * deserializeAws_json1_1GlueStudioSchemaColumnList
 */
const de_GlueStudioSchemaColumnList = (output: any, context: __SerdeContext): GlueStudioSchemaColumn[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return de_GlueStudioSchemaColumn(entry, context);
    });
  return retVal;
};

/**
 * deserializeAws_json1_1GlueTable
 */
const de_GlueTable = (output: any, context: __SerdeContext): GlueTable => {
  return {
    AdditionalOptions:
      output.AdditionalOptions != null ? de_GlueTableAdditionalOptions(output.AdditionalOptions, context) : undefined,
    CatalogId: __expectString(output.CatalogId),
    ConnectionName: __expectString(output.ConnectionName),
    DatabaseName: __expectString(output.DatabaseName),
    TableName: __expectString(output.TableName),
  } as any;
};

/**
 * deserializeAws_json1_1GlueTableAdditionalOptions
 */
const de_GlueTableAdditionalOptions = (output: any, context: __SerdeContext): Record<string, string> => {
  return Object.entries(output).reduce((acc: Record<string, string>, [key, value]: [string, any]) => {
    if (value === null) {
      return acc;
    }
    acc[key] = __expectString(value) as any;
    return acc;
  }, {});
};

/**
 * deserializeAws_json1_1GlueTables
 */
const de_GlueTables = (output: any, context: __SerdeContext): GlueTable[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return de_GlueTable(entry, context);
    });
  return retVal;
};

/**
 * deserializeAws_json1_1GovernedCatalogSource
 */
const de_GovernedCatalogSource = (output: any, context: __SerdeContext): GovernedCatalogSource => {
  return {
    AdditionalOptions:
      output.AdditionalOptions != null ? de_S3SourceAdditionalOptions(output.AdditionalOptions, context) : undefined,
    Database: __expectString(output.Database),
    Name: __expectString(output.Name),
    PartitionPredicate: __expectString(output.PartitionPredicate),
    Table: __expectString(output.Table),
  } as any;
};

/**
 * deserializeAws_json1_1GovernedCatalogTarget
 */
const de_GovernedCatalogTarget = (output: any, context: __SerdeContext): GovernedCatalogTarget => {
  return {
    Database: __expectString(output.Database),
    Inputs: output.Inputs != null ? de_OneInput(output.Inputs, context) : undefined,
    Name: __expectString(output.Name),
    PartitionKeys: output.PartitionKeys != null ? de_GlueStudioPathList(output.PartitionKeys, context) : undefined,
    SchemaChangePolicy:
      output.SchemaChangePolicy != null ? de_CatalogSchemaChangePolicy(output.SchemaChangePolicy, context) : undefined,
    Table: __expectString(output.Table),
  } as any;
};

/**
 * deserializeAws_json1_1GrokClassifier
 */
const de_GrokClassifier = (output: any, context: __SerdeContext): GrokClassifier => {
  return {
    Classification: __expectString(output.Classification),
    CreationTime:
      output.CreationTime != null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.CreationTime)))
        : undefined,
    CustomPatterns: __expectString(output.CustomPatterns),
    GrokPattern: __expectString(output.GrokPattern),
    LastUpdated:
      output.LastUpdated != null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.LastUpdated)))
        : undefined,
    Name: __expectString(output.Name),
    Version: __expectLong(output.Version),
  } as any;
};

/**
 * deserializeAws_json1_1IdempotentParameterMismatchException
 */
const de_IdempotentParameterMismatchException = (
  output: any,
  context: __SerdeContext
): IdempotentParameterMismatchException => {
  return {
    Message: __expectString(output.Message),
  } as any;
};

/**
 * deserializeAws_json1_1IllegalBlueprintStateException
 */
const de_IllegalBlueprintStateException = (output: any, context: __SerdeContext): IllegalBlueprintStateException => {
  return {
    Message: __expectString(output.Message),
  } as any;
};

/**
 * deserializeAws_json1_1IllegalSessionStateException
 */
const de_IllegalSessionStateException = (output: any, context: __SerdeContext): IllegalSessionStateException => {
  return {
    Message: __expectString(output.Message),
  } as any;
};

/**
 * deserializeAws_json1_1IllegalWorkflowStateException
 */
const de_IllegalWorkflowStateException = (output: any, context: __SerdeContext): IllegalWorkflowStateException => {
  return {
    Message: __expectString(output.Message),
  } as any;
};

/**
 * deserializeAws_json1_1ImportCatalogToGlueResponse
 */
const de_ImportCatalogToGlueResponse = (output: any, context: __SerdeContext): ImportCatalogToGlueResponse => {
  return {} as any;
};

/**
 * deserializeAws_json1_1ImportLabelsTaskRunProperties
 */
const de_ImportLabelsTaskRunProperties = (output: any, context: __SerdeContext): ImportLabelsTaskRunProperties => {
  return {
    InputS3Path: __expectString(output.InputS3Path),
    Replace: __expectBoolean(output.Replace),
  } as any;
};

/**
 * deserializeAws_json1_1InternalServiceException
 */
const de_InternalServiceException = (output: any, context: __SerdeContext): InternalServiceException => {
  return {
    Message: __expectString(output.Message),
  } as any;
};

/**
 * deserializeAws_json1_1InvalidInputException
 */
const de_InvalidInputException = (output: any, context: __SerdeContext): InvalidInputException => {
  return {
    FromFederationSource: __expectBoolean(output.FromFederationSource),
    Message: __expectString(output.Message),
  } as any;
};

/**
 * deserializeAws_json1_1InvalidStateException
 */
const de_InvalidStateException = (output: any, context: __SerdeContext): InvalidStateException => {
  return {
    Message: __expectString(output.Message),
  } as any;
};

/**
 * deserializeAws_json1_1JDBCConnectorOptions
 */
const de_JDBCConnectorOptions = (output: any, context: __SerdeContext): JDBCConnectorOptions => {
  return {
    DataTypeMapping:
      output.DataTypeMapping != null ? de_JDBCDataTypeMapping(output.DataTypeMapping, context) : undefined,
    FilterPredicate: __expectString(output.FilterPredicate),
    JobBookmarkKeys:
      output.JobBookmarkKeys != null ? de_EnclosedInStringProperties(output.JobBookmarkKeys, context) : undefined,
    JobBookmarkKeysSortOrder: __expectString(output.JobBookmarkKeysSortOrder),
    LowerBound: __expectLong(output.LowerBound),
    NumPartitions: __expectLong(output.NumPartitions),
    PartitionColumn: __expectString(output.PartitionColumn),
    UpperBound: __expectLong(output.UpperBound),
  } as any;
};

/**
 * deserializeAws_json1_1JDBCConnectorSource
 */
const de_JDBCConnectorSource = (output: any, context: __SerdeContext): JDBCConnectorSource => {
  return {
    AdditionalOptions:
      output.AdditionalOptions != null ? de_JDBCConnectorOptions(output.AdditionalOptions, context) : undefined,
    ConnectionName: __expectString(output.ConnectionName),
    ConnectionTable: __expectString(output.ConnectionTable),
    ConnectionType: __expectString(output.ConnectionType),
    ConnectorName: __expectString(output.ConnectorName),
    Name: __expectString(output.Name),
    OutputSchemas: output.OutputSchemas != null ? de_GlueSchemas(output.OutputSchemas, context) : undefined,
    Query: __expectString(output.Query),
  } as any;
};

/**
 * deserializeAws_json1_1JDBCConnectorTarget
 */
const de_JDBCConnectorTarget = (output: any, context: __SerdeContext): JDBCConnectorTarget => {
  return {
    AdditionalOptions:
      output.AdditionalOptions != null ? de_AdditionalOptions(output.AdditionalOptions, context) : undefined,
    ConnectionName: __expectString(output.ConnectionName),
    ConnectionTable: __expectString(output.ConnectionTable),
    ConnectionType: __expectString(output.ConnectionType),
    ConnectorName: __expectString(output.ConnectorName),
    Inputs: output.Inputs != null ? de_OneInput(output.Inputs, context) : undefined,
    Name: __expectString(output.Name),
    OutputSchemas: output.OutputSchemas != null ? de_GlueSchemas(output.OutputSchemas, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1JDBCDataTypeMapping
 */
const de_JDBCDataTypeMapping = (output: any, context: __SerdeContext): Record<string, GlueRecordType | string> => {
  return Object.entries(output).reduce(
    (acc: Record<string, GlueRecordType | string>, [key, value]: [JDBCDataType | string, any]) => {
      if (value === null) {
        return acc;
      }
      acc[key] = __expectString(value) as any;
      return acc;
    },
    {}
  );
};

/**
 * deserializeAws_json1_1JdbcTarget
 */
const de_JdbcTarget = (output: any, context: __SerdeContext): JdbcTarget => {
  return {
    ConnectionName: __expectString(output.ConnectionName),
    EnableAdditionalMetadata:
      output.EnableAdditionalMetadata != null
        ? de_EnableAdditionalMetadata(output.EnableAdditionalMetadata, context)
        : undefined,
    Exclusions: output.Exclusions != null ? de_PathList(output.Exclusions, context) : undefined,
    Path: __expectString(output.Path),
  } as any;
};

/**
 * deserializeAws_json1_1JdbcTargetList
 */
const de_JdbcTargetList = (output: any, context: __SerdeContext): JdbcTarget[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return de_JdbcTarget(entry, context);
    });
  return retVal;
};

/**
 * deserializeAws_json1_1Job
 */
const de_Job = (output: any, context: __SerdeContext): Job => {
  return {
    AllocatedCapacity: __expectInt32(output.AllocatedCapacity),
    CodeGenConfigurationNodes:
      output.CodeGenConfigurationNodes != null
        ? de_CodeGenConfigurationNodes(output.CodeGenConfigurationNodes, context)
        : undefined,
    Command: output.Command != null ? de_JobCommand(output.Command, context) : undefined,
    Connections: output.Connections != null ? de_ConnectionsList(output.Connections, context) : undefined,
    CreatedOn:
      output.CreatedOn != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.CreatedOn))) : undefined,
    DefaultArguments: output.DefaultArguments != null ? de_GenericMap(output.DefaultArguments, context) : undefined,
    Description: __expectString(output.Description),
    ExecutionClass: __expectString(output.ExecutionClass),
    ExecutionProperty:
      output.ExecutionProperty != null ? de_ExecutionProperty(output.ExecutionProperty, context) : undefined,
    GlueVersion: __expectString(output.GlueVersion),
    LastModifiedOn:
      output.LastModifiedOn != null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.LastModifiedOn)))
        : undefined,
    LogUri: __expectString(output.LogUri),
    MaxCapacity: __limitedParseDouble(output.MaxCapacity),
    MaxRetries: __expectInt32(output.MaxRetries),
    Name: __expectString(output.Name),
    NonOverridableArguments:
      output.NonOverridableArguments != null ? de_GenericMap(output.NonOverridableArguments, context) : undefined,
    NotificationProperty:
      output.NotificationProperty != null ? de_NotificationProperty(output.NotificationProperty, context) : undefined,
    NumberOfWorkers: __expectInt32(output.NumberOfWorkers),
    Role: __expectString(output.Role),
    SecurityConfiguration: __expectString(output.SecurityConfiguration),
    SourceControlDetails:
      output.SourceControlDetails != null ? de_SourceControlDetails(output.SourceControlDetails, context) : undefined,
    Timeout: __expectInt32(output.Timeout),
    WorkerType: __expectString(output.WorkerType),
  } as any;
};

/**
 * deserializeAws_json1_1JobBookmarkEntry
 */
const de_JobBookmarkEntry = (output: any, context: __SerdeContext): JobBookmarkEntry => {
  return {
    Attempt: __expectInt32(output.Attempt),
    JobBookmark: __expectString(output.JobBookmark),
    JobName: __expectString(output.JobName),
    PreviousRunId: __expectString(output.PreviousRunId),
    Run: __expectInt32(output.Run),
    RunId: __expectString(output.RunId),
    Version: __expectInt32(output.Version),
  } as any;
};

/**
 * deserializeAws_json1_1JobBookmarksEncryption
 */
const de_JobBookmarksEncryption = (output: any, context: __SerdeContext): JobBookmarksEncryption => {
  return {
    JobBookmarksEncryptionMode: __expectString(output.JobBookmarksEncryptionMode),
    KmsKeyArn: __expectString(output.KmsKeyArn),
  } as any;
};

/**
 * deserializeAws_json1_1JobCommand
 */
const de_JobCommand = (output: any, context: __SerdeContext): JobCommand => {
  return {
    Name: __expectString(output.Name),
    PythonVersion: __expectString(output.PythonVersion),
    ScriptLocation: __expectString(output.ScriptLocation),
  } as any;
};

/**
 * deserializeAws_json1_1JobList
 */
const de_JobList = (output: any, context: __SerdeContext): Job[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return de_Job(entry, context);
    });
  return retVal;
};

/**
 * deserializeAws_json1_1JobNameList
 */
const de_JobNameList = (output: any, context: __SerdeContext): string[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return __expectString(entry) as any;
    });
  return retVal;
};

/**
 * deserializeAws_json1_1JobNodeDetails
 */
const de_JobNodeDetails = (output: any, context: __SerdeContext): JobNodeDetails => {
  return {
    JobRuns: output.JobRuns != null ? de_JobRunList(output.JobRuns, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1JobRun
 */
const de_JobRun = (output: any, context: __SerdeContext): JobRun => {
  return {
    AllocatedCapacity: __expectInt32(output.AllocatedCapacity),
    Arguments: output.Arguments != null ? de_GenericMap(output.Arguments, context) : undefined,
    Attempt: __expectInt32(output.Attempt),
    CompletedOn:
      output.CompletedOn != null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.CompletedOn)))
        : undefined,
    DPUSeconds: __limitedParseDouble(output.DPUSeconds),
    ErrorMessage: __expectString(output.ErrorMessage),
    ExecutionClass: __expectString(output.ExecutionClass),
    ExecutionTime: __expectInt32(output.ExecutionTime),
    GlueVersion: __expectString(output.GlueVersion),
    Id: __expectString(output.Id),
    JobName: __expectString(output.JobName),
    JobRunState: __expectString(output.JobRunState),
    LastModifiedOn:
      output.LastModifiedOn != null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.LastModifiedOn)))
        : undefined,
    LogGroupName: __expectString(output.LogGroupName),
    MaxCapacity: __limitedParseDouble(output.MaxCapacity),
    NotificationProperty:
      output.NotificationProperty != null ? de_NotificationProperty(output.NotificationProperty, context) : undefined,
    NumberOfWorkers: __expectInt32(output.NumberOfWorkers),
    PredecessorRuns: output.PredecessorRuns != null ? de_PredecessorList(output.PredecessorRuns, context) : undefined,
    PreviousRunId: __expectString(output.PreviousRunId),
    SecurityConfiguration: __expectString(output.SecurityConfiguration),
    StartedOn:
      output.StartedOn != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.StartedOn))) : undefined,
    Timeout: __expectInt32(output.Timeout),
    TriggerName: __expectString(output.TriggerName),
    WorkerType: __expectString(output.WorkerType),
  } as any;
};

/**
 * deserializeAws_json1_1JobRunList
 */
const de_JobRunList = (output: any, context: __SerdeContext): JobRun[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return de_JobRun(entry, context);
    });
  return retVal;
};

/**
 * deserializeAws_json1_1Join
 */
const de_Join = (output: any, context: __SerdeContext): Join => {
  return {
    Columns: output.Columns != null ? de_JoinColumns(output.Columns, context) : undefined,
    Inputs: output.Inputs != null ? de_TwoInputs(output.Inputs, context) : undefined,
    JoinType: __expectString(output.JoinType),
    Name: __expectString(output.Name),
  } as any;
};

/**
 * deserializeAws_json1_1JoinColumn
 */
const de_JoinColumn = (output: any, context: __SerdeContext): JoinColumn => {
  return {
    From: __expectString(output.From),
    Keys: output.Keys != null ? de_GlueStudioPathList(output.Keys, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1JoinColumns
 */
const de_JoinColumns = (output: any, context: __SerdeContext): JoinColumn[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return de_JoinColumn(entry, context);
    });
  return retVal;
};

/**
 * deserializeAws_json1_1JsonClassifier
 */
const de_JsonClassifier = (output: any, context: __SerdeContext): JsonClassifier => {
  return {
    CreationTime:
      output.CreationTime != null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.CreationTime)))
        : undefined,
    JsonPath: __expectString(output.JsonPath),
    LastUpdated:
      output.LastUpdated != null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.LastUpdated)))
        : undefined,
    Name: __expectString(output.Name),
    Version: __expectLong(output.Version),
  } as any;
};

/**
 * deserializeAws_json1_1KafkaStreamingSourceOptions
 */
const de_KafkaStreamingSourceOptions = (output: any, context: __SerdeContext): KafkaStreamingSourceOptions => {
  return {
    AddRecordTimestamp: __expectString(output.AddRecordTimestamp),
    Assign: __expectString(output.Assign),
    BootstrapServers: __expectString(output.BootstrapServers),
    Classification: __expectString(output.Classification),
    ConnectionName: __expectString(output.ConnectionName),
    Delimiter: __expectString(output.Delimiter),
    EmitConsumerLagMetrics: __expectString(output.EmitConsumerLagMetrics),
    EndingOffsets: __expectString(output.EndingOffsets),
    IncludeHeaders: __expectBoolean(output.IncludeHeaders),
    MaxOffsetsPerTrigger: __expectLong(output.MaxOffsetsPerTrigger),
    MinPartitions: __expectInt32(output.MinPartitions),
    NumRetries: __expectInt32(output.NumRetries),
    PollTimeoutMs: __expectLong(output.PollTimeoutMs),
    RetryIntervalMs: __expectLong(output.RetryIntervalMs),
    SecurityProtocol: __expectString(output.SecurityProtocol),
    StartingOffsets: __expectString(output.StartingOffsets),
    SubscribePattern: __expectString(output.SubscribePattern),
    TopicName: __expectString(output.TopicName),
  } as any;
};

/**
 * deserializeAws_json1_1KeySchemaElement
 */
const de_KeySchemaElement = (output: any, context: __SerdeContext): KeySchemaElement => {
  return {
    Name: __expectString(output.Name),
    Type: __expectString(output.Type),
  } as any;
};

/**
 * deserializeAws_json1_1KeySchemaElementList
 */
const de_KeySchemaElementList = (output: any, context: __SerdeContext): KeySchemaElement[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return de_KeySchemaElement(entry, context);
    });
  return retVal;
};

/**
 * deserializeAws_json1_1KinesisStreamingSourceOptions
 */
const de_KinesisStreamingSourceOptions = (output: any, context: __SerdeContext): KinesisStreamingSourceOptions => {
  return {
    AddIdleTimeBetweenReads: __expectBoolean(output.AddIdleTimeBetweenReads),
    AddRecordTimestamp: __expectString(output.AddRecordTimestamp),
    AvoidEmptyBatches: __expectBoolean(output.AvoidEmptyBatches),
    Classification: __expectString(output.Classification),
    Delimiter: __expectString(output.Delimiter),
    DescribeShardInterval: __expectLong(output.DescribeShardInterval),
    EmitConsumerLagMetrics: __expectString(output.EmitConsumerLagMetrics),
    EndpointUrl: __expectString(output.EndpointUrl),
    IdleTimeBetweenReadsInMs: __expectLong(output.IdleTimeBetweenReadsInMs),
    MaxFetchRecordsPerShard: __expectLong(output.MaxFetchRecordsPerShard),
    MaxFetchTimeInMs: __expectLong(output.MaxFetchTimeInMs),
    MaxRecordPerRead: __expectLong(output.MaxRecordPerRead),
    MaxRetryIntervalMs: __expectLong(output.MaxRetryIntervalMs),
    NumRetries: __expectInt32(output.NumRetries),
    RetryIntervalMs: __expectLong(output.RetryIntervalMs),
    RoleArn: __expectString(output.RoleArn),
    RoleSessionName: __expectString(output.RoleSessionName),
    StartingPosition: __expectString(output.StartingPosition),
    StreamArn: __expectString(output.StreamArn),
    StreamName: __expectString(output.StreamName),
  } as any;
};

/**
 * deserializeAws_json1_1LabelingSetGenerationTaskRunProperties
 */
const de_LabelingSetGenerationTaskRunProperties = (
  output: any,
  context: __SerdeContext
): LabelingSetGenerationTaskRunProperties => {
  return {
    OutputS3Path: __expectString(output.OutputS3Path),
  } as any;
};

/**
 * deserializeAws_json1_1LakeFormationConfiguration
 */
const de_LakeFormationConfiguration = (output: any, context: __SerdeContext): LakeFormationConfiguration => {
  return {
    AccountId: __expectString(output.AccountId),
    UseLakeFormationCredentials: __expectBoolean(output.UseLakeFormationCredentials),
  } as any;
};

/**
 * deserializeAws_json1_1LastActiveDefinition
 */
const de_LastActiveDefinition = (output: any, context: __SerdeContext): LastActiveDefinition => {
  return {
    BlueprintLocation: __expectString(output.BlueprintLocation),
    BlueprintServiceLocation: __expectString(output.BlueprintServiceLocation),
    Description: __expectString(output.Description),
    LastModifiedOn:
      output.LastModifiedOn != null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.LastModifiedOn)))
        : undefined,
    ParameterSpec: __expectString(output.ParameterSpec),
  } as any;
};

/**
 * deserializeAws_json1_1LastCrawlInfo
 */
const de_LastCrawlInfo = (output: any, context: __SerdeContext): LastCrawlInfo => {
  return {
    ErrorMessage: __expectString(output.ErrorMessage),
    LogGroup: __expectString(output.LogGroup),
    LogStream: __expectString(output.LogStream),
    MessagePrefix: __expectString(output.MessagePrefix),
    StartTime:
      output.StartTime != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.StartTime))) : undefined,
    Status: __expectString(output.Status),
  } as any;
};

/**
 * deserializeAws_json1_1LimitedPathList
 */
const de_LimitedPathList = (output: any, context: __SerdeContext): string[][] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return de_LimitedStringList(entry, context);
    });
  return retVal;
};

/**
 * deserializeAws_json1_1LimitedStringList
 */
const de_LimitedStringList = (output: any, context: __SerdeContext): string[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return __expectString(entry) as any;
    });
  return retVal;
};

/**
 * deserializeAws_json1_1LineageConfiguration
 */
const de_LineageConfiguration = (output: any, context: __SerdeContext): LineageConfiguration => {
  return {
    CrawlerLineageSettings: __expectString(output.CrawlerLineageSettings),
  } as any;
};

/**
 * deserializeAws_json1_1ListBlueprintsResponse
 */
const de_ListBlueprintsResponse = (output: any, context: __SerdeContext): ListBlueprintsResponse => {
  return {
    Blueprints: output.Blueprints != null ? de_BlueprintNames(output.Blueprints, context) : undefined,
    NextToken: __expectString(output.NextToken),
  } as any;
};

/**
 * deserializeAws_json1_1ListCrawlersResponse
 */
const de_ListCrawlersResponse = (output: any, context: __SerdeContext): ListCrawlersResponse => {
  return {
    CrawlerNames: output.CrawlerNames != null ? de_CrawlerNameList(output.CrawlerNames, context) : undefined,
    NextToken: __expectString(output.NextToken),
  } as any;
};

/**
 * deserializeAws_json1_1ListCrawlsResponse
 */
const de_ListCrawlsResponse = (output: any, context: __SerdeContext): ListCrawlsResponse => {
  return {
    Crawls: output.Crawls != null ? de_CrawlerHistoryList(output.Crawls, context) : undefined,
    NextToken: __expectString(output.NextToken),
  } as any;
};

/**
 * deserializeAws_json1_1ListCustomEntityTypesResponse
 */
const de_ListCustomEntityTypesResponse = (output: any, context: __SerdeContext): ListCustomEntityTypesResponse => {
  return {
    CustomEntityTypes:
      output.CustomEntityTypes != null ? de_CustomEntityTypes(output.CustomEntityTypes, context) : undefined,
    NextToken: __expectString(output.NextToken),
  } as any;
};

/**
 * deserializeAws_json1_1ListDataQualityResultsResponse
 */
const de_ListDataQualityResultsResponse = (output: any, context: __SerdeContext): ListDataQualityResultsResponse => {
  return {
    NextToken: __expectString(output.NextToken),
    Results: output.Results != null ? de_DataQualityResultDescriptionList(output.Results, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1ListDataQualityRuleRecommendationRunsResponse
 */
const de_ListDataQualityRuleRecommendationRunsResponse = (
  output: any,
  context: __SerdeContext
): ListDataQualityRuleRecommendationRunsResponse => {
  return {
    NextToken: __expectString(output.NextToken),
    Runs: output.Runs != null ? de_DataQualityRuleRecommendationRunList(output.Runs, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1ListDataQualityRulesetEvaluationRunsResponse
 */
const de_ListDataQualityRulesetEvaluationRunsResponse = (
  output: any,
  context: __SerdeContext
): ListDataQualityRulesetEvaluationRunsResponse => {
  return {
    NextToken: __expectString(output.NextToken),
    Runs: output.Runs != null ? de_DataQualityRulesetEvaluationRunList(output.Runs, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1ListDataQualityRulesetsResponse
 */
const de_ListDataQualityRulesetsResponse = (output: any, context: __SerdeContext): ListDataQualityRulesetsResponse => {
  return {
    NextToken: __expectString(output.NextToken),
    Rulesets: output.Rulesets != null ? de_DataQualityRulesetList(output.Rulesets, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1ListDevEndpointsResponse
 */
const de_ListDevEndpointsResponse = (output: any, context: __SerdeContext): ListDevEndpointsResponse => {
  return {
    DevEndpointNames:
      output.DevEndpointNames != null ? de_DevEndpointNameList(output.DevEndpointNames, context) : undefined,
    NextToken: __expectString(output.NextToken),
  } as any;
};

/**
 * deserializeAws_json1_1ListJobsResponse
 */
const de_ListJobsResponse = (output: any, context: __SerdeContext): ListJobsResponse => {
  return {
    JobNames: output.JobNames != null ? de_JobNameList(output.JobNames, context) : undefined,
    NextToken: __expectString(output.NextToken),
  } as any;
};

/**
 * deserializeAws_json1_1ListMLTransformsResponse
 */
const de_ListMLTransformsResponse = (output: any, context: __SerdeContext): ListMLTransformsResponse => {
  return {
    NextToken: __expectString(output.NextToken),
    TransformIds: output.TransformIds != null ? de_TransformIdList(output.TransformIds, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1ListRegistriesResponse
 */
const de_ListRegistriesResponse = (output: any, context: __SerdeContext): ListRegistriesResponse => {
  return {
    NextToken: __expectString(output.NextToken),
    Registries: output.Registries != null ? de_RegistryListDefinition(output.Registries, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1ListSchemasResponse
 */
const de_ListSchemasResponse = (output: any, context: __SerdeContext): ListSchemasResponse => {
  return {
    NextToken: __expectString(output.NextToken),
    Schemas: output.Schemas != null ? de_SchemaListDefinition(output.Schemas, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1ListSchemaVersionsResponse
 */
const de_ListSchemaVersionsResponse = (output: any, context: __SerdeContext): ListSchemaVersionsResponse => {
  return {
    NextToken: __expectString(output.NextToken),
    Schemas: output.Schemas != null ? de_SchemaVersionList(output.Schemas, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1ListSessionsResponse
 */
const de_ListSessionsResponse = (output: any, context: __SerdeContext): ListSessionsResponse => {
  return {
    Ids: output.Ids != null ? de_SessionIdList(output.Ids, context) : undefined,
    NextToken: __expectString(output.NextToken),
    Sessions: output.Sessions != null ? de_SessionList(output.Sessions, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1ListStatementsResponse
 */
const de_ListStatementsResponse = (output: any, context: __SerdeContext): ListStatementsResponse => {
  return {
    NextToken: __expectString(output.NextToken),
    Statements: output.Statements != null ? de_StatementList(output.Statements, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1ListTriggersResponse
 */
const de_ListTriggersResponse = (output: any, context: __SerdeContext): ListTriggersResponse => {
  return {
    NextToken: __expectString(output.NextToken),
    TriggerNames: output.TriggerNames != null ? de_TriggerNameList(output.TriggerNames, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1ListWorkflowsResponse
 */
const de_ListWorkflowsResponse = (output: any, context: __SerdeContext): ListWorkflowsResponse => {
  return {
    NextToken: __expectString(output.NextToken),
    Workflows: output.Workflows != null ? de_WorkflowNames(output.Workflows, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1LocationMap
 */
const de_LocationMap = (output: any, context: __SerdeContext): Record<string, string> => {
  return Object.entries(output).reduce((acc: Record<string, string>, [key, value]: [string, any]) => {
    if (value === null) {
      return acc;
    }
    acc[key] = __expectString(value) as any;
    return acc;
  }, {});
};

/**
 * deserializeAws_json1_1LocationStringList
 */
const de_LocationStringList = (output: any, context: __SerdeContext): string[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return __expectString(entry) as any;
    });
  return retVal;
};

/**
 * deserializeAws_json1_1LongColumnStatisticsData
 */
const de_LongColumnStatisticsData = (output: any, context: __SerdeContext): LongColumnStatisticsData => {
  return {
    MaximumValue: __expectLong(output.MaximumValue),
    MinimumValue: __expectLong(output.MinimumValue),
    NumberOfDistinctValues: __expectLong(output.NumberOfDistinctValues),
    NumberOfNulls: __expectLong(output.NumberOfNulls),
  } as any;
};

/**
 * deserializeAws_json1_1ManyInputs
 */
const de_ManyInputs = (output: any, context: __SerdeContext): string[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return __expectString(entry) as any;
    });
  return retVal;
};

/**
 * deserializeAws_json1_1Mapping
 */
const de_Mapping = (output: any, context: __SerdeContext): Mapping => {
  return {
    Children: output.Children != null ? de_Mappings(output.Children, context) : undefined,
    Dropped: __expectBoolean(output.Dropped),
    FromPath: output.FromPath != null ? de_EnclosedInStringProperties(output.FromPath, context) : undefined,
    FromType: __expectString(output.FromType),
    ToKey: __expectString(output.ToKey),
    ToType: __expectString(output.ToType),
  } as any;
};

/**
 * deserializeAws_json1_1MappingEntry
 */
const de_MappingEntry = (output: any, context: __SerdeContext): MappingEntry => {
  return {
    SourcePath: __expectString(output.SourcePath),
    SourceTable: __expectString(output.SourceTable),
    SourceType: __expectString(output.SourceType),
    TargetPath: __expectString(output.TargetPath),
    TargetTable: __expectString(output.TargetTable),
    TargetType: __expectString(output.TargetType),
  } as any;
};

/**
 * deserializeAws_json1_1MappingList
 */
const de_MappingList = (output: any, context: __SerdeContext): MappingEntry[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return de_MappingEntry(entry, context);
    });
  return retVal;
};

/**
 * deserializeAws_json1_1Mappings
 */
const de_Mappings = (output: any, context: __SerdeContext): Mapping[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return de_Mapping(entry, context);
    });
  return retVal;
};

/**
 * deserializeAws_json1_1MapValue
 */
const de_MapValue = (output: any, context: __SerdeContext): Record<string, string> => {
  return Object.entries(output).reduce((acc: Record<string, string>, [key, value]: [string, any]) => {
    if (value === null) {
      return acc;
    }
    acc[key] = __expectString(value) as any;
    return acc;
  }, {});
};

/**
 * deserializeAws_json1_1MatchCriteria
 */
const de_MatchCriteria = (output: any, context: __SerdeContext): string[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return __expectString(entry) as any;
    });
  return retVal;
};

/**
 * deserializeAws_json1_1Merge
 */
const de_Merge = (output: any, context: __SerdeContext): Merge => {
  return {
    Inputs: output.Inputs != null ? de_TwoInputs(output.Inputs, context) : undefined,
    Name: __expectString(output.Name),
    PrimaryKeys: output.PrimaryKeys != null ? de_GlueStudioPathList(output.PrimaryKeys, context) : undefined,
    Source: __expectString(output.Source),
  } as any;
};

/**
 * deserializeAws_json1_1MetadataInfo
 */
const de_MetadataInfo = (output: any, context: __SerdeContext): MetadataInfo => {
  return {
    CreatedTime: __expectString(output.CreatedTime),
    MetadataValue: __expectString(output.MetadataValue),
    OtherMetadataValueList:
      output.OtherMetadataValueList != null
        ? de_OtherMetadataValueList(output.OtherMetadataValueList, context)
        : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1MetadataInfoMap
 */
const de_MetadataInfoMap = (output: any, context: __SerdeContext): Record<string, MetadataInfo> => {
  return Object.entries(output).reduce((acc: Record<string, MetadataInfo>, [key, value]: [string, any]) => {
    if (value === null) {
      return acc;
    }
    acc[key] = de_MetadataInfo(value, context);
    return acc;
  }, {});
};

/**
 * deserializeAws_json1_1MicrosoftSQLServerCatalogSource
 */
const de_MicrosoftSQLServerCatalogSource = (output: any, context: __SerdeContext): MicrosoftSQLServerCatalogSource => {
  return {
    Database: __expectString(output.Database),
    Name: __expectString(output.Name),
    Table: __expectString(output.Table),
  } as any;
};

/**
 * deserializeAws_json1_1MicrosoftSQLServerCatalogTarget
 */
const de_MicrosoftSQLServerCatalogTarget = (output: any, context: __SerdeContext): MicrosoftSQLServerCatalogTarget => {
  return {
    Database: __expectString(output.Database),
    Inputs: output.Inputs != null ? de_OneInput(output.Inputs, context) : undefined,
    Name: __expectString(output.Name),
    Table: __expectString(output.Table),
  } as any;
};

/**
 * deserializeAws_json1_1MLTransform
 */
const de_MLTransform = (output: any, context: __SerdeContext): MLTransform => {
  return {
    CreatedOn:
      output.CreatedOn != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.CreatedOn))) : undefined,
    Description: __expectString(output.Description),
    EvaluationMetrics:
      output.EvaluationMetrics != null ? de_EvaluationMetrics(output.EvaluationMetrics, context) : undefined,
    GlueVersion: __expectString(output.GlueVersion),
    InputRecordTables: output.InputRecordTables != null ? de_GlueTables(output.InputRecordTables, context) : undefined,
    LabelCount: __expectInt32(output.LabelCount),
    LastModifiedOn:
      output.LastModifiedOn != null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.LastModifiedOn)))
        : undefined,
    MaxCapacity: __limitedParseDouble(output.MaxCapacity),
    MaxRetries: __expectInt32(output.MaxRetries),
    Name: __expectString(output.Name),
    NumberOfWorkers: __expectInt32(output.NumberOfWorkers),
    Parameters: output.Parameters != null ? de_TransformParameters(output.Parameters, context) : undefined,
    Role: __expectString(output.Role),
    Schema: output.Schema != null ? de_TransformSchema(output.Schema, context) : undefined,
    Status: __expectString(output.Status),
    Timeout: __expectInt32(output.Timeout),
    TransformEncryption:
      output.TransformEncryption != null ? de_TransformEncryption(output.TransformEncryption, context) : undefined,
    TransformId: __expectString(output.TransformId),
    WorkerType: __expectString(output.WorkerType),
  } as any;
};

/**
 * deserializeAws_json1_1MLTransformNotReadyException
 */
const de_MLTransformNotReadyException = (output: any, context: __SerdeContext): MLTransformNotReadyException => {
  return {
    Message: __expectString(output.Message),
  } as any;
};

/**
 * deserializeAws_json1_1MLUserDataEncryption
 */
const de_MLUserDataEncryption = (output: any, context: __SerdeContext): MLUserDataEncryption => {
  return {
    KmsKeyId: __expectString(output.KmsKeyId),
    MlUserDataEncryptionMode: __expectString(output.MlUserDataEncryptionMode),
  } as any;
};

/**
 * deserializeAws_json1_1MongoDBTarget
 */
const de_MongoDBTarget = (output: any, context: __SerdeContext): MongoDBTarget => {
  return {
    ConnectionName: __expectString(output.ConnectionName),
    Path: __expectString(output.Path),
    ScanAll: __expectBoolean(output.ScanAll),
  } as any;
};

/**
 * deserializeAws_json1_1MongoDBTargetList
 */
const de_MongoDBTargetList = (output: any, context: __SerdeContext): MongoDBTarget[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return de_MongoDBTarget(entry, context);
    });
  return retVal;
};

/**
 * deserializeAws_json1_1MySQLCatalogSource
 */
const de_MySQLCatalogSource = (output: any, context: __SerdeContext): MySQLCatalogSource => {
  return {
    Database: __expectString(output.Database),
    Name: __expectString(output.Name),
    Table: __expectString(output.Table),
  } as any;
};

/**
 * deserializeAws_json1_1MySQLCatalogTarget
 */
const de_MySQLCatalogTarget = (output: any, context: __SerdeContext): MySQLCatalogTarget => {
  return {
    Database: __expectString(output.Database),
    Inputs: output.Inputs != null ? de_OneInput(output.Inputs, context) : undefined,
    Name: __expectString(output.Name),
    Table: __expectString(output.Table),
  } as any;
};

/**
 * deserializeAws_json1_1NameStringList
 */
const de_NameStringList = (output: any, context: __SerdeContext): string[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return __expectString(entry) as any;
    });
  return retVal;
};

/**
 * deserializeAws_json1_1Node
 */
const de_Node = (output: any, context: __SerdeContext): Node => {
  return {
    CrawlerDetails: output.CrawlerDetails != null ? de_CrawlerNodeDetails(output.CrawlerDetails, context) : undefined,
    JobDetails: output.JobDetails != null ? de_JobNodeDetails(output.JobDetails, context) : undefined,
    Name: __expectString(output.Name),
    TriggerDetails: output.TriggerDetails != null ? de_TriggerNodeDetails(output.TriggerDetails, context) : undefined,
    Type: __expectString(output.Type),
    UniqueId: __expectString(output.UniqueId),
  } as any;
};

/**
 * deserializeAws_json1_1NodeIdList
 */
const de_NodeIdList = (output: any, context: __SerdeContext): string[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return __expectString(entry) as any;
    });
  return retVal;
};

/**
 * deserializeAws_json1_1NodeList
 */
const de_NodeList = (output: any, context: __SerdeContext): Node[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return de_Node(entry, context);
    });
  return retVal;
};

/**
 * deserializeAws_json1_1NoScheduleException
 */
const de_NoScheduleException = (output: any, context: __SerdeContext): NoScheduleException => {
  return {
    Message: __expectString(output.Message),
  } as any;
};

/**
 * deserializeAws_json1_1NotificationProperty
 */
const de_NotificationProperty = (output: any, context: __SerdeContext): NotificationProperty => {
  return {
    NotifyDelayAfter: __expectInt32(output.NotifyDelayAfter),
  } as any;
};

/**
 * deserializeAws_json1_1NullCheckBoxList
 */
const de_NullCheckBoxList = (output: any, context: __SerdeContext): NullCheckBoxList => {
  return {
    IsEmpty: __expectBoolean(output.IsEmpty),
    IsNegOne: __expectBoolean(output.IsNegOne),
    IsNullString: __expectBoolean(output.IsNullString),
  } as any;
};

/**
 * deserializeAws_json1_1NullValueField
 */
const de_NullValueField = (output: any, context: __SerdeContext): NullValueField => {
  return {
    Datatype: output.Datatype != null ? de_Datatype(output.Datatype, context) : undefined,
    Value: __expectString(output.Value),
  } as any;
};

/**
 * deserializeAws_json1_1NullValueFields
 */
const de_NullValueFields = (output: any, context: __SerdeContext): NullValueField[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return de_NullValueField(entry, context);
    });
  return retVal;
};

/**
 * deserializeAws_json1_1OneInput
 */
const de_OneInput = (output: any, context: __SerdeContext): string[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return __expectString(entry) as any;
    });
  return retVal;
};

/**
 * deserializeAws_json1_1OperationTimeoutException
 */
const de_OperationTimeoutException = (output: any, context: __SerdeContext): OperationTimeoutException => {
  return {
    Message: __expectString(output.Message),
  } as any;
};

/**
 * deserializeAws_json1_1OracleSQLCatalogSource
 */
const de_OracleSQLCatalogSource = (output: any, context: __SerdeContext): OracleSQLCatalogSource => {
  return {
    Database: __expectString(output.Database),
    Name: __expectString(output.Name),
    Table: __expectString(output.Table),
  } as any;
};

/**
 * deserializeAws_json1_1OracleSQLCatalogTarget
 */
const de_OracleSQLCatalogTarget = (output: any, context: __SerdeContext): OracleSQLCatalogTarget => {
  return {
    Database: __expectString(output.Database),
    Inputs: output.Inputs != null ? de_OneInput(output.Inputs, context) : undefined,
    Name: __expectString(output.Name),
    Table: __expectString(output.Table),
  } as any;
};

/**
 * deserializeAws_json1_1OrchestrationArgumentsMap
 */
const de_OrchestrationArgumentsMap = (output: any, context: __SerdeContext): Record<string, string> => {
  return Object.entries(output).reduce((acc: Record<string, string>, [key, value]: [string, any]) => {
    if (value === null) {
      return acc;
    }
    acc[key] = __expectString(value) as any;
    return acc;
  }, {});
};

/**
 * deserializeAws_json1_1OrchestrationStringList
 */
const de_OrchestrationStringList = (output: any, context: __SerdeContext): string[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return __expectString(entry) as any;
    });
  return retVal;
};

/**
 * deserializeAws_json1_1Order
 */
const de_Order = (output: any, context: __SerdeContext): Order => {
  return {
    Column: __expectString(output.Column),
    SortOrder: __expectInt32(output.SortOrder),
  } as any;
};

/**
 * deserializeAws_json1_1OrderList
 */
const de_OrderList = (output: any, context: __SerdeContext): Order[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return de_Order(entry, context);
    });
  return retVal;
};

/**
 * deserializeAws_json1_1OtherMetadataValueList
 */
const de_OtherMetadataValueList = (output: any, context: __SerdeContext): OtherMetadataValueListItem[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return de_OtherMetadataValueListItem(entry, context);
    });
  return retVal;
};

/**
 * deserializeAws_json1_1OtherMetadataValueListItem
 */
const de_OtherMetadataValueListItem = (output: any, context: __SerdeContext): OtherMetadataValueListItem => {
  return {
    CreatedTime: __expectString(output.CreatedTime),
    MetadataValue: __expectString(output.MetadataValue),
  } as any;
};

/**
 * deserializeAws_json1_1ParametersMap
 */
const de_ParametersMap = (output: any, context: __SerdeContext): Record<string, string> => {
  return Object.entries(output).reduce((acc: Record<string, string>, [key, value]: [string, any]) => {
    if (value === null) {
      return acc;
    }
    acc[key] = __expectString(value) as any;
    return acc;
  }, {});
};

/**
 * deserializeAws_json1_1Partition
 */
const de_Partition = (output: any, context: __SerdeContext): Partition => {
  return {
    CatalogId: __expectString(output.CatalogId),
    CreationTime:
      output.CreationTime != null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.CreationTime)))
        : undefined,
    DatabaseName: __expectString(output.DatabaseName),
    LastAccessTime:
      output.LastAccessTime != null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.LastAccessTime)))
        : undefined,
    LastAnalyzedTime:
      output.LastAnalyzedTime != null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.LastAnalyzedTime)))
        : undefined,
    Parameters: output.Parameters != null ? de_ParametersMap(output.Parameters, context) : undefined,
    StorageDescriptor:
      output.StorageDescriptor != null ? de_StorageDescriptor(output.StorageDescriptor, context) : undefined,
    TableName: __expectString(output.TableName),
    Values: output.Values != null ? de_ValueStringList(output.Values, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1PartitionError
 */
const de_PartitionError = (output: any, context: __SerdeContext): PartitionError => {
  return {
    ErrorDetail: output.ErrorDetail != null ? de_ErrorDetail(output.ErrorDetail, context) : undefined,
    PartitionValues: output.PartitionValues != null ? de_ValueStringList(output.PartitionValues, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1PartitionErrors
 */
const de_PartitionErrors = (output: any, context: __SerdeContext): PartitionError[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return de_PartitionError(entry, context);
    });
  return retVal;
};

/**
 * deserializeAws_json1_1PartitionIndexDescriptor
 */
const de_PartitionIndexDescriptor = (output: any, context: __SerdeContext): PartitionIndexDescriptor => {
  return {
    BackfillErrors: output.BackfillErrors != null ? de_BackfillErrors(output.BackfillErrors, context) : undefined,
    IndexName: __expectString(output.IndexName),
    IndexStatus: __expectString(output.IndexStatus),
    Keys: output.Keys != null ? de_KeySchemaElementList(output.Keys, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1PartitionIndexDescriptorList
 */
const de_PartitionIndexDescriptorList = (output: any, context: __SerdeContext): PartitionIndexDescriptor[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return de_PartitionIndexDescriptor(entry, context);
    });
  return retVal;
};

/**
 * deserializeAws_json1_1PartitionList
 */
const de_PartitionList = (output: any, context: __SerdeContext): Partition[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return de_Partition(entry, context);
    });
  return retVal;
};

/**
 * deserializeAws_json1_1PartitionValueList
 */
const de_PartitionValueList = (output: any, context: __SerdeContext): PartitionValueList => {
  return {
    Values: output.Values != null ? de_ValueStringList(output.Values, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1PathList
 */
const de_PathList = (output: any, context: __SerdeContext): string[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return __expectString(entry) as any;
    });
  return retVal;
};

/**
 * deserializeAws_json1_1PermissionList
 */
const de_PermissionList = (output: any, context: __SerdeContext): (Permission | string)[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return __expectString(entry) as any;
    });
  return retVal;
};

/**
 * deserializeAws_json1_1PermissionTypeMismatchException
 */
const de_PermissionTypeMismatchException = (output: any, context: __SerdeContext): PermissionTypeMismatchException => {
  return {
    Message: __expectString(output.Message),
  } as any;
};

/**
 * deserializeAws_json1_1PhysicalConnectionRequirements
 */
const de_PhysicalConnectionRequirements = (output: any, context: __SerdeContext): PhysicalConnectionRequirements => {
  return {
    AvailabilityZone: __expectString(output.AvailabilityZone),
    SecurityGroupIdList:
      output.SecurityGroupIdList != null ? de_SecurityGroupIdList(output.SecurityGroupIdList, context) : undefined,
    SubnetId: __expectString(output.SubnetId),
  } as any;
};

/**
 * deserializeAws_json1_1PIIDetection
 */
const de_PIIDetection = (output: any, context: __SerdeContext): PIIDetection => {
  return {
    EntityTypesToDetect:
      output.EntityTypesToDetect != null
        ? de_EnclosedInStringProperties(output.EntityTypesToDetect, context)
        : undefined,
    Inputs: output.Inputs != null ? de_OneInput(output.Inputs, context) : undefined,
    MaskValue: __expectString(output.MaskValue),
    Name: __expectString(output.Name),
    OutputColumnName: __expectString(output.OutputColumnName),
    PiiType: __expectString(output.PiiType),
    SampleFraction: __limitedParseDouble(output.SampleFraction),
    ThresholdFraction: __limitedParseDouble(output.ThresholdFraction),
  } as any;
};

/**
 * deserializeAws_json1_1PostgreSQLCatalogSource
 */
const de_PostgreSQLCatalogSource = (output: any, context: __SerdeContext): PostgreSQLCatalogSource => {
  return {
    Database: __expectString(output.Database),
    Name: __expectString(output.Name),
    Table: __expectString(output.Table),
  } as any;
};

/**
 * deserializeAws_json1_1PostgreSQLCatalogTarget
 */
const de_PostgreSQLCatalogTarget = (output: any, context: __SerdeContext): PostgreSQLCatalogTarget => {
  return {
    Database: __expectString(output.Database),
    Inputs: output.Inputs != null ? de_OneInput(output.Inputs, context) : undefined,
    Name: __expectString(output.Name),
    Table: __expectString(output.Table),
  } as any;
};

/**
 * deserializeAws_json1_1Predecessor
 */
const de_Predecessor = (output: any, context: __SerdeContext): Predecessor => {
  return {
    JobName: __expectString(output.JobName),
    RunId: __expectString(output.RunId),
  } as any;
};

/**
 * deserializeAws_json1_1PredecessorList
 */
const de_PredecessorList = (output: any, context: __SerdeContext): Predecessor[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return de_Predecessor(entry, context);
    });
  return retVal;
};

/**
 * deserializeAws_json1_1Predicate
 */
const de_Predicate = (output: any, context: __SerdeContext): Predicate => {
  return {
    Conditions: output.Conditions != null ? de_ConditionList(output.Conditions, context) : undefined,
    Logical: __expectString(output.Logical),
  } as any;
};

/**
 * deserializeAws_json1_1PrincipalPermissions
 */
const de_PrincipalPermissions = (output: any, context: __SerdeContext): PrincipalPermissions => {
  return {
    Permissions: output.Permissions != null ? de_PermissionList(output.Permissions, context) : undefined,
    Principal: output.Principal != null ? de_DataLakePrincipal(output.Principal, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1PrincipalPermissionsList
 */
const de_PrincipalPermissionsList = (output: any, context: __SerdeContext): PrincipalPermissions[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return de_PrincipalPermissions(entry, context);
    });
  return retVal;
};

/**
 * deserializeAws_json1_1PublicKeysList
 */
const de_PublicKeysList = (output: any, context: __SerdeContext): string[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return __expectString(entry) as any;
    });
  return retVal;
};

/**
 * deserializeAws_json1_1PutDataCatalogEncryptionSettingsResponse
 */
const de_PutDataCatalogEncryptionSettingsResponse = (
  output: any,
  context: __SerdeContext
): PutDataCatalogEncryptionSettingsResponse => {
  return {} as any;
};

/**
 * deserializeAws_json1_1PutResourcePolicyResponse
 */
const de_PutResourcePolicyResponse = (output: any, context: __SerdeContext): PutResourcePolicyResponse => {
  return {
    PolicyHash: __expectString(output.PolicyHash),
  } as any;
};

/**
 * deserializeAws_json1_1PutSchemaVersionMetadataResponse
 */
const de_PutSchemaVersionMetadataResponse = (
  output: any,
  context: __SerdeContext
): PutSchemaVersionMetadataResponse => {
  return {
    LatestVersion: __expectBoolean(output.LatestVersion),
    MetadataKey: __expectString(output.MetadataKey),
    MetadataValue: __expectString(output.MetadataValue),
    RegistryName: __expectString(output.RegistryName),
    SchemaArn: __expectString(output.SchemaArn),
    SchemaName: __expectString(output.SchemaName),
    SchemaVersionId: __expectString(output.SchemaVersionId),
    VersionNumber: __expectLong(output.VersionNumber),
  } as any;
};

/**
 * deserializeAws_json1_1PutWorkflowRunPropertiesResponse
 */
const de_PutWorkflowRunPropertiesResponse = (
  output: any,
  context: __SerdeContext
): PutWorkflowRunPropertiesResponse => {
  return {} as any;
};

/**
 * deserializeAws_json1_1QuerySchemaVersionMetadataResponse
 */
const de_QuerySchemaVersionMetadataResponse = (
  output: any,
  context: __SerdeContext
): QuerySchemaVersionMetadataResponse => {
  return {
    MetadataInfoMap: output.MetadataInfoMap != null ? de_MetadataInfoMap(output.MetadataInfoMap, context) : undefined,
    NextToken: __expectString(output.NextToken),
    SchemaVersionId: __expectString(output.SchemaVersionId),
  } as any;
};

/**
 * deserializeAws_json1_1RecrawlPolicy
 */
const de_RecrawlPolicy = (output: any, context: __SerdeContext): RecrawlPolicy => {
  return {
    RecrawlBehavior: __expectString(output.RecrawlBehavior),
  } as any;
};

/**
 * deserializeAws_json1_1RedshiftSource
 */
const de_RedshiftSource = (output: any, context: __SerdeContext): RedshiftSource => {
  return {
    Database: __expectString(output.Database),
    Name: __expectString(output.Name),
    RedshiftTmpDir: __expectString(output.RedshiftTmpDir),
    Table: __expectString(output.Table),
    TmpDirIAMRole: __expectString(output.TmpDirIAMRole),
  } as any;
};

/**
 * deserializeAws_json1_1RedshiftTarget
 */
const de_RedshiftTarget = (output: any, context: __SerdeContext): RedshiftTarget => {
  return {
    Database: __expectString(output.Database),
    Inputs: output.Inputs != null ? de_OneInput(output.Inputs, context) : undefined,
    Name: __expectString(output.Name),
    RedshiftTmpDir: __expectString(output.RedshiftTmpDir),
    Table: __expectString(output.Table),
    TmpDirIAMRole: __expectString(output.TmpDirIAMRole),
    UpsertRedshiftOptions:
      output.UpsertRedshiftOptions != null
        ? de_UpsertRedshiftTargetOptions(output.UpsertRedshiftOptions, context)
        : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1RegisterSchemaVersionResponse
 */
const de_RegisterSchemaVersionResponse = (output: any, context: __SerdeContext): RegisterSchemaVersionResponse => {
  return {
    SchemaVersionId: __expectString(output.SchemaVersionId),
    Status: __expectString(output.Status),
    VersionNumber: __expectLong(output.VersionNumber),
  } as any;
};

/**
 * deserializeAws_json1_1RegistryListDefinition
 */
const de_RegistryListDefinition = (output: any, context: __SerdeContext): RegistryListItem[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return de_RegistryListItem(entry, context);
    });
  return retVal;
};

/**
 * deserializeAws_json1_1RegistryListItem
 */
const de_RegistryListItem = (output: any, context: __SerdeContext): RegistryListItem => {
  return {
    CreatedTime: __expectString(output.CreatedTime),
    Description: __expectString(output.Description),
    RegistryArn: __expectString(output.RegistryArn),
    RegistryName: __expectString(output.RegistryName),
    Status: __expectString(output.Status),
    UpdatedTime: __expectString(output.UpdatedTime),
  } as any;
};

/**
 * deserializeAws_json1_1RelationalCatalogSource
 */
const de_RelationalCatalogSource = (output: any, context: __SerdeContext): RelationalCatalogSource => {
  return {
    Database: __expectString(output.Database),
    Name: __expectString(output.Name),
    Table: __expectString(output.Table),
  } as any;
};

/**
 * deserializeAws_json1_1RemoveSchemaVersionMetadataResponse
 */
const de_RemoveSchemaVersionMetadataResponse = (
  output: any,
  context: __SerdeContext
): RemoveSchemaVersionMetadataResponse => {
  return {
    LatestVersion: __expectBoolean(output.LatestVersion),
    MetadataKey: __expectString(output.MetadataKey),
    MetadataValue: __expectString(output.MetadataValue),
    RegistryName: __expectString(output.RegistryName),
    SchemaArn: __expectString(output.SchemaArn),
    SchemaName: __expectString(output.SchemaName),
    SchemaVersionId: __expectString(output.SchemaVersionId),
    VersionNumber: __expectLong(output.VersionNumber),
  } as any;
};

/**
 * deserializeAws_json1_1RenameField
 */
const de_RenameField = (output: any, context: __SerdeContext): RenameField => {
  return {
    Inputs: output.Inputs != null ? de_OneInput(output.Inputs, context) : undefined,
    Name: __expectString(output.Name),
    SourcePath: output.SourcePath != null ? de_EnclosedInStringProperties(output.SourcePath, context) : undefined,
    TargetPath: output.TargetPath != null ? de_EnclosedInStringProperties(output.TargetPath, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1ResetJobBookmarkResponse
 */
const de_ResetJobBookmarkResponse = (output: any, context: __SerdeContext): ResetJobBookmarkResponse => {
  return {
    JobBookmarkEntry:
      output.JobBookmarkEntry != null ? de_JobBookmarkEntry(output.JobBookmarkEntry, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1ResourceNotReadyException
 */
const de_ResourceNotReadyException = (output: any, context: __SerdeContext): ResourceNotReadyException => {
  return {
    Message: __expectString(output.Message),
  } as any;
};

/**
 * deserializeAws_json1_1ResourceNumberLimitExceededException
 */
const de_ResourceNumberLimitExceededException = (
  output: any,
  context: __SerdeContext
): ResourceNumberLimitExceededException => {
  return {
    Message: __expectString(output.Message),
  } as any;
};

/**
 * deserializeAws_json1_1ResourceUri
 */
const de_ResourceUri = (output: any, context: __SerdeContext): ResourceUri => {
  return {
    ResourceType: __expectString(output.ResourceType),
    Uri: __expectString(output.Uri),
  } as any;
};

/**
 * deserializeAws_json1_1ResourceUriList
 */
const de_ResourceUriList = (output: any, context: __SerdeContext): ResourceUri[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return de_ResourceUri(entry, context);
    });
  return retVal;
};

/**
 * deserializeAws_json1_1ResumeWorkflowRunResponse
 */
const de_ResumeWorkflowRunResponse = (output: any, context: __SerdeContext): ResumeWorkflowRunResponse => {
  return {
    NodeIds: output.NodeIds != null ? de_NodeIdList(output.NodeIds, context) : undefined,
    RunId: __expectString(output.RunId),
  } as any;
};

/**
 * deserializeAws_json1_1RulesetNames
 */
const de_RulesetNames = (output: any, context: __SerdeContext): string[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return __expectString(entry) as any;
    });
  return retVal;
};

/**
 * deserializeAws_json1_1RunStatementResponse
 */
const de_RunStatementResponse = (output: any, context: __SerdeContext): RunStatementResponse => {
  return {
    Id: __expectInt32(output.Id),
  } as any;
};

/**
 * deserializeAws_json1_1S3CatalogDeltaSource
 */
const de_S3CatalogDeltaSource = (output: any, context: __SerdeContext): S3CatalogDeltaSource => {
  return {
    AdditionalDeltaOptions:
      output.AdditionalDeltaOptions != null ? de_AdditionalOptions(output.AdditionalDeltaOptions, context) : undefined,
    Database: __expectString(output.Database),
    Name: __expectString(output.Name),
    OutputSchemas: output.OutputSchemas != null ? de_GlueSchemas(output.OutputSchemas, context) : undefined,
    Table: __expectString(output.Table),
  } as any;
};

/**
 * deserializeAws_json1_1S3CatalogHudiSource
 */
const de_S3CatalogHudiSource = (output: any, context: __SerdeContext): S3CatalogHudiSource => {
  return {
    AdditionalHudiOptions:
      output.AdditionalHudiOptions != null ? de_AdditionalOptions(output.AdditionalHudiOptions, context) : undefined,
    Database: __expectString(output.Database),
    Name: __expectString(output.Name),
    OutputSchemas: output.OutputSchemas != null ? de_GlueSchemas(output.OutputSchemas, context) : undefined,
    Table: __expectString(output.Table),
  } as any;
};

/**
 * deserializeAws_json1_1S3CatalogSource
 */
const de_S3CatalogSource = (output: any, context: __SerdeContext): S3CatalogSource => {
  return {
    AdditionalOptions:
      output.AdditionalOptions != null ? de_S3SourceAdditionalOptions(output.AdditionalOptions, context) : undefined,
    Database: __expectString(output.Database),
    Name: __expectString(output.Name),
    PartitionPredicate: __expectString(output.PartitionPredicate),
    Table: __expectString(output.Table),
  } as any;
};

/**
 * deserializeAws_json1_1S3CatalogTarget
 */
const de_S3CatalogTarget = (output: any, context: __SerdeContext): S3CatalogTarget => {
  return {
    Database: __expectString(output.Database),
    Inputs: output.Inputs != null ? de_OneInput(output.Inputs, context) : undefined,
    Name: __expectString(output.Name),
    PartitionKeys: output.PartitionKeys != null ? de_GlueStudioPathList(output.PartitionKeys, context) : undefined,
    SchemaChangePolicy:
      output.SchemaChangePolicy != null ? de_CatalogSchemaChangePolicy(output.SchemaChangePolicy, context) : undefined,
    Table: __expectString(output.Table),
  } as any;
};

/**
 * deserializeAws_json1_1S3CsvSource
 */
const de_S3CsvSource = (output: any, context: __SerdeContext): S3CsvSource => {
  return {
    AdditionalOptions:
      output.AdditionalOptions != null
        ? de_S3DirectSourceAdditionalOptions(output.AdditionalOptions, context)
        : undefined,
    CompressionType: __expectString(output.CompressionType),
    Escaper: __expectString(output.Escaper),
    Exclusions: output.Exclusions != null ? de_EnclosedInStringProperties(output.Exclusions, context) : undefined,
    GroupFiles: __expectString(output.GroupFiles),
    GroupSize: __expectString(output.GroupSize),
    MaxBand: __expectInt32(output.MaxBand),
    MaxFilesInBand: __expectInt32(output.MaxFilesInBand),
    Multiline: __expectBoolean(output.Multiline),
    Name: __expectString(output.Name),
    OptimizePerformance: __expectBoolean(output.OptimizePerformance),
    OutputSchemas: output.OutputSchemas != null ? de_GlueSchemas(output.OutputSchemas, context) : undefined,
    Paths: output.Paths != null ? de_EnclosedInStringProperties(output.Paths, context) : undefined,
    QuoteChar: __expectString(output.QuoteChar),
    Recurse: __expectBoolean(output.Recurse),
    Separator: __expectString(output.Separator),
    SkipFirst: __expectBoolean(output.SkipFirst),
    WithHeader: __expectBoolean(output.WithHeader),
    WriteHeader: __expectBoolean(output.WriteHeader),
  } as any;
};

/**
 * deserializeAws_json1_1S3DeltaCatalogTarget
 */
const de_S3DeltaCatalogTarget = (output: any, context: __SerdeContext): S3DeltaCatalogTarget => {
  return {
    AdditionalOptions:
      output.AdditionalOptions != null ? de_AdditionalOptions(output.AdditionalOptions, context) : undefined,
    Database: __expectString(output.Database),
    Inputs: output.Inputs != null ? de_OneInput(output.Inputs, context) : undefined,
    Name: __expectString(output.Name),
    PartitionKeys: output.PartitionKeys != null ? de_GlueStudioPathList(output.PartitionKeys, context) : undefined,
    SchemaChangePolicy:
      output.SchemaChangePolicy != null ? de_CatalogSchemaChangePolicy(output.SchemaChangePolicy, context) : undefined,
    Table: __expectString(output.Table),
  } as any;
};

/**
 * deserializeAws_json1_1S3DeltaDirectTarget
 */
const de_S3DeltaDirectTarget = (output: any, context: __SerdeContext): S3DeltaDirectTarget => {
  return {
    AdditionalOptions:
      output.AdditionalOptions != null ? de_AdditionalOptions(output.AdditionalOptions, context) : undefined,
    Compression: __expectString(output.Compression),
    Format: __expectString(output.Format),
    Inputs: output.Inputs != null ? de_OneInput(output.Inputs, context) : undefined,
    Name: __expectString(output.Name),
    PartitionKeys: output.PartitionKeys != null ? de_GlueStudioPathList(output.PartitionKeys, context) : undefined,
    Path: __expectString(output.Path),
    SchemaChangePolicy:
      output.SchemaChangePolicy != null ? de_DirectSchemaChangePolicy(output.SchemaChangePolicy, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1S3DeltaSource
 */
const de_S3DeltaSource = (output: any, context: __SerdeContext): S3DeltaSource => {
  return {
    AdditionalDeltaOptions:
      output.AdditionalDeltaOptions != null ? de_AdditionalOptions(output.AdditionalDeltaOptions, context) : undefined,
    AdditionalOptions:
      output.AdditionalOptions != null
        ? de_S3DirectSourceAdditionalOptions(output.AdditionalOptions, context)
        : undefined,
    Name: __expectString(output.Name),
    OutputSchemas: output.OutputSchemas != null ? de_GlueSchemas(output.OutputSchemas, context) : undefined,
    Paths: output.Paths != null ? de_EnclosedInStringProperties(output.Paths, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1S3DirectSourceAdditionalOptions
 */
const de_S3DirectSourceAdditionalOptions = (output: any, context: __SerdeContext): S3DirectSourceAdditionalOptions => {
  return {
    BoundedFiles: __expectLong(output.BoundedFiles),
    BoundedSize: __expectLong(output.BoundedSize),
    EnableSamplePath: __expectBoolean(output.EnableSamplePath),
    SamplePath: __expectString(output.SamplePath),
  } as any;
};

/**
 * deserializeAws_json1_1S3DirectTarget
 */
const de_S3DirectTarget = (output: any, context: __SerdeContext): S3DirectTarget => {
  return {
    Compression: __expectString(output.Compression),
    Format: __expectString(output.Format),
    Inputs: output.Inputs != null ? de_OneInput(output.Inputs, context) : undefined,
    Name: __expectString(output.Name),
    PartitionKeys: output.PartitionKeys != null ? de_GlueStudioPathList(output.PartitionKeys, context) : undefined,
    Path: __expectString(output.Path),
    SchemaChangePolicy:
      output.SchemaChangePolicy != null ? de_DirectSchemaChangePolicy(output.SchemaChangePolicy, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1S3Encryption
 */
const de_S3Encryption = (output: any, context: __SerdeContext): S3Encryption => {
  return {
    KmsKeyArn: __expectString(output.KmsKeyArn),
    S3EncryptionMode: __expectString(output.S3EncryptionMode),
  } as any;
};

/**
 * deserializeAws_json1_1S3EncryptionList
 */
const de_S3EncryptionList = (output: any, context: __SerdeContext): S3Encryption[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return de_S3Encryption(entry, context);
    });
  return retVal;
};

/**
 * deserializeAws_json1_1S3GlueParquetTarget
 */
const de_S3GlueParquetTarget = (output: any, context: __SerdeContext): S3GlueParquetTarget => {
  return {
    Compression: __expectString(output.Compression),
    Inputs: output.Inputs != null ? de_OneInput(output.Inputs, context) : undefined,
    Name: __expectString(output.Name),
    PartitionKeys: output.PartitionKeys != null ? de_GlueStudioPathList(output.PartitionKeys, context) : undefined,
    Path: __expectString(output.Path),
    SchemaChangePolicy:
      output.SchemaChangePolicy != null ? de_DirectSchemaChangePolicy(output.SchemaChangePolicy, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1S3HudiCatalogTarget
 */
const de_S3HudiCatalogTarget = (output: any, context: __SerdeContext): S3HudiCatalogTarget => {
  return {
    AdditionalOptions:
      output.AdditionalOptions != null ? de_AdditionalOptions(output.AdditionalOptions, context) : undefined,
    Database: __expectString(output.Database),
    Inputs: output.Inputs != null ? de_OneInput(output.Inputs, context) : undefined,
    Name: __expectString(output.Name),
    PartitionKeys: output.PartitionKeys != null ? de_GlueStudioPathList(output.PartitionKeys, context) : undefined,
    SchemaChangePolicy:
      output.SchemaChangePolicy != null ? de_CatalogSchemaChangePolicy(output.SchemaChangePolicy, context) : undefined,
    Table: __expectString(output.Table),
  } as any;
};

/**
 * deserializeAws_json1_1S3HudiDirectTarget
 */
const de_S3HudiDirectTarget = (output: any, context: __SerdeContext): S3HudiDirectTarget => {
  return {
    AdditionalOptions:
      output.AdditionalOptions != null ? de_AdditionalOptions(output.AdditionalOptions, context) : undefined,
    Compression: __expectString(output.Compression),
    Format: __expectString(output.Format),
    Inputs: output.Inputs != null ? de_OneInput(output.Inputs, context) : undefined,
    Name: __expectString(output.Name),
    PartitionKeys: output.PartitionKeys != null ? de_GlueStudioPathList(output.PartitionKeys, context) : undefined,
    Path: __expectString(output.Path),
    SchemaChangePolicy:
      output.SchemaChangePolicy != null ? de_DirectSchemaChangePolicy(output.SchemaChangePolicy, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1S3HudiSource
 */
const de_S3HudiSource = (output: any, context: __SerdeContext): S3HudiSource => {
  return {
    AdditionalHudiOptions:
      output.AdditionalHudiOptions != null ? de_AdditionalOptions(output.AdditionalHudiOptions, context) : undefined,
    AdditionalOptions:
      output.AdditionalOptions != null
        ? de_S3DirectSourceAdditionalOptions(output.AdditionalOptions, context)
        : undefined,
    Name: __expectString(output.Name),
    OutputSchemas: output.OutputSchemas != null ? de_GlueSchemas(output.OutputSchemas, context) : undefined,
    Paths: output.Paths != null ? de_EnclosedInStringProperties(output.Paths, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1S3JsonSource
 */
const de_S3JsonSource = (output: any, context: __SerdeContext): S3JsonSource => {
  return {
    AdditionalOptions:
      output.AdditionalOptions != null
        ? de_S3DirectSourceAdditionalOptions(output.AdditionalOptions, context)
        : undefined,
    CompressionType: __expectString(output.CompressionType),
    Exclusions: output.Exclusions != null ? de_EnclosedInStringProperties(output.Exclusions, context) : undefined,
    GroupFiles: __expectString(output.GroupFiles),
    GroupSize: __expectString(output.GroupSize),
    JsonPath: __expectString(output.JsonPath),
    MaxBand: __expectInt32(output.MaxBand),
    MaxFilesInBand: __expectInt32(output.MaxFilesInBand),
    Multiline: __expectBoolean(output.Multiline),
    Name: __expectString(output.Name),
    OutputSchemas: output.OutputSchemas != null ? de_GlueSchemas(output.OutputSchemas, context) : undefined,
    Paths: output.Paths != null ? de_EnclosedInStringProperties(output.Paths, context) : undefined,
    Recurse: __expectBoolean(output.Recurse),
  } as any;
};

/**
 * deserializeAws_json1_1S3ParquetSource
 */
const de_S3ParquetSource = (output: any, context: __SerdeContext): S3ParquetSource => {
  return {
    AdditionalOptions:
      output.AdditionalOptions != null
        ? de_S3DirectSourceAdditionalOptions(output.AdditionalOptions, context)
        : undefined,
    CompressionType: __expectString(output.CompressionType),
    Exclusions: output.Exclusions != null ? de_EnclosedInStringProperties(output.Exclusions, context) : undefined,
    GroupFiles: __expectString(output.GroupFiles),
    GroupSize: __expectString(output.GroupSize),
    MaxBand: __expectInt32(output.MaxBand),
    MaxFilesInBand: __expectInt32(output.MaxFilesInBand),
    Name: __expectString(output.Name),
    OutputSchemas: output.OutputSchemas != null ? de_GlueSchemas(output.OutputSchemas, context) : undefined,
    Paths: output.Paths != null ? de_EnclosedInStringProperties(output.Paths, context) : undefined,
    Recurse: __expectBoolean(output.Recurse),
  } as any;
};

/**
 * deserializeAws_json1_1S3SourceAdditionalOptions
 */
const de_S3SourceAdditionalOptions = (output: any, context: __SerdeContext): S3SourceAdditionalOptions => {
  return {
    BoundedFiles: __expectLong(output.BoundedFiles),
    BoundedSize: __expectLong(output.BoundedSize),
  } as any;
};

/**
 * deserializeAws_json1_1S3Target
 */
const de_S3Target = (output: any, context: __SerdeContext): S3Target => {
  return {
    ConnectionName: __expectString(output.ConnectionName),
    DlqEventQueueArn: __expectString(output.DlqEventQueueArn),
    EventQueueArn: __expectString(output.EventQueueArn),
    Exclusions: output.Exclusions != null ? de_PathList(output.Exclusions, context) : undefined,
    Path: __expectString(output.Path),
    SampleSize: __expectInt32(output.SampleSize),
  } as any;
};

/**
 * deserializeAws_json1_1S3TargetList
 */
const de_S3TargetList = (output: any, context: __SerdeContext): S3Target[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return de_S3Target(entry, context);
    });
  return retVal;
};

/**
 * deserializeAws_json1_1Schedule
 */
const de_Schedule = (output: any, context: __SerdeContext): Schedule => {
  return {
    ScheduleExpression: __expectString(output.ScheduleExpression),
    State: __expectString(output.State),
  } as any;
};

/**
 * deserializeAws_json1_1SchedulerNotRunningException
 */
const de_SchedulerNotRunningException = (output: any, context: __SerdeContext): SchedulerNotRunningException => {
  return {
    Message: __expectString(output.Message),
  } as any;
};

/**
 * deserializeAws_json1_1SchedulerRunningException
 */
const de_SchedulerRunningException = (output: any, context: __SerdeContext): SchedulerRunningException => {
  return {
    Message: __expectString(output.Message),
  } as any;
};

/**
 * deserializeAws_json1_1SchedulerTransitioningException
 */
const de_SchedulerTransitioningException = (output: any, context: __SerdeContext): SchedulerTransitioningException => {
  return {
    Message: __expectString(output.Message),
  } as any;
};

/**
 * deserializeAws_json1_1SchemaChangePolicy
 */
const de_SchemaChangePolicy = (output: any, context: __SerdeContext): SchemaChangePolicy => {
  return {
    DeleteBehavior: __expectString(output.DeleteBehavior),
    UpdateBehavior: __expectString(output.UpdateBehavior),
  } as any;
};

/**
 * deserializeAws_json1_1SchemaColumn
 */
const de_SchemaColumn = (output: any, context: __SerdeContext): SchemaColumn => {
  return {
    DataType: __expectString(output.DataType),
    Name: __expectString(output.Name),
  } as any;
};

/**
 * deserializeAws_json1_1SchemaId
 */
const de_SchemaId = (output: any, context: __SerdeContext): SchemaId => {
  return {
    RegistryName: __expectString(output.RegistryName),
    SchemaArn: __expectString(output.SchemaArn),
    SchemaName: __expectString(output.SchemaName),
  } as any;
};

/**
 * deserializeAws_json1_1SchemaListDefinition
 */
const de_SchemaListDefinition = (output: any, context: __SerdeContext): SchemaListItem[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return de_SchemaListItem(entry, context);
    });
  return retVal;
};

/**
 * deserializeAws_json1_1SchemaListItem
 */
const de_SchemaListItem = (output: any, context: __SerdeContext): SchemaListItem => {
  return {
    CreatedTime: __expectString(output.CreatedTime),
    Description: __expectString(output.Description),
    RegistryName: __expectString(output.RegistryName),
    SchemaArn: __expectString(output.SchemaArn),
    SchemaName: __expectString(output.SchemaName),
    SchemaStatus: __expectString(output.SchemaStatus),
    UpdatedTime: __expectString(output.UpdatedTime),
  } as any;
};

/**
 * deserializeAws_json1_1SchemaReference
 */
const de_SchemaReference = (output: any, context: __SerdeContext): SchemaReference => {
  return {
    SchemaId: output.SchemaId != null ? de_SchemaId(output.SchemaId, context) : undefined,
    SchemaVersionId: __expectString(output.SchemaVersionId),
    SchemaVersionNumber: __expectLong(output.SchemaVersionNumber),
  } as any;
};

/**
 * deserializeAws_json1_1SchemaVersionErrorItem
 */
const de_SchemaVersionErrorItem = (output: any, context: __SerdeContext): SchemaVersionErrorItem => {
  return {
    ErrorDetails: output.ErrorDetails != null ? de_ErrorDetails(output.ErrorDetails, context) : undefined,
    VersionNumber: __expectLong(output.VersionNumber),
  } as any;
};

/**
 * deserializeAws_json1_1SchemaVersionErrorList
 */
const de_SchemaVersionErrorList = (output: any, context: __SerdeContext): SchemaVersionErrorItem[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return de_SchemaVersionErrorItem(entry, context);
    });
  return retVal;
};

/**
 * deserializeAws_json1_1SchemaVersionList
 */
const de_SchemaVersionList = (output: any, context: __SerdeContext): SchemaVersionListItem[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return de_SchemaVersionListItem(entry, context);
    });
  return retVal;
};

/**
 * deserializeAws_json1_1SchemaVersionListItem
 */
const de_SchemaVersionListItem = (output: any, context: __SerdeContext): SchemaVersionListItem => {
  return {
    CreatedTime: __expectString(output.CreatedTime),
    SchemaArn: __expectString(output.SchemaArn),
    SchemaVersionId: __expectString(output.SchemaVersionId),
    Status: __expectString(output.Status),
    VersionNumber: __expectLong(output.VersionNumber),
  } as any;
};

/**
 * deserializeAws_json1_1SearchTablesResponse
 */
const de_SearchTablesResponse = (output: any, context: __SerdeContext): SearchTablesResponse => {
  return {
    NextToken: __expectString(output.NextToken),
    TableList: output.TableList != null ? de_TableList(output.TableList, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1SecurityConfiguration
 */
const de_SecurityConfiguration = (output: any, context: __SerdeContext): SecurityConfiguration => {
  return {
    CreatedTimeStamp:
      output.CreatedTimeStamp != null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.CreatedTimeStamp)))
        : undefined,
    EncryptionConfiguration:
      output.EncryptionConfiguration != null
        ? de_EncryptionConfiguration(output.EncryptionConfiguration, context)
        : undefined,
    Name: __expectString(output.Name),
  } as any;
};

/**
 * deserializeAws_json1_1SecurityConfigurationList
 */
const de_SecurityConfigurationList = (output: any, context: __SerdeContext): SecurityConfiguration[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return de_SecurityConfiguration(entry, context);
    });
  return retVal;
};

/**
 * deserializeAws_json1_1SecurityGroupIdList
 */
const de_SecurityGroupIdList = (output: any, context: __SerdeContext): string[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return __expectString(entry) as any;
    });
  return retVal;
};

/**
 * deserializeAws_json1_1SelectFields
 */
const de_SelectFields = (output: any, context: __SerdeContext): SelectFields => {
  return {
    Inputs: output.Inputs != null ? de_OneInput(output.Inputs, context) : undefined,
    Name: __expectString(output.Name),
    Paths: output.Paths != null ? de_GlueStudioPathList(output.Paths, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1SelectFromCollection
 */
const de_SelectFromCollection = (output: any, context: __SerdeContext): SelectFromCollection => {
  return {
    Index: __expectInt32(output.Index),
    Inputs: output.Inputs != null ? de_OneInput(output.Inputs, context) : undefined,
    Name: __expectString(output.Name),
  } as any;
};

/**
 * deserializeAws_json1_1SerDeInfo
 */
const de_SerDeInfo = (output: any, context: __SerdeContext): SerDeInfo => {
  return {
    Name: __expectString(output.Name),
    Parameters: output.Parameters != null ? de_ParametersMap(output.Parameters, context) : undefined,
    SerializationLibrary: __expectString(output.SerializationLibrary),
  } as any;
};

/**
 * deserializeAws_json1_1Session
 */
const de_Session = (output: any, context: __SerdeContext): Session => {
  return {
    Command: output.Command != null ? de_SessionCommand(output.Command, context) : undefined,
    Connections: output.Connections != null ? de_ConnectionsList(output.Connections, context) : undefined,
    CreatedOn:
      output.CreatedOn != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.CreatedOn))) : undefined,
    DefaultArguments:
      output.DefaultArguments != null ? de_OrchestrationArgumentsMap(output.DefaultArguments, context) : undefined,
    Description: __expectString(output.Description),
    ErrorMessage: __expectString(output.ErrorMessage),
    GlueVersion: __expectString(output.GlueVersion),
    Id: __expectString(output.Id),
    MaxCapacity: __limitedParseDouble(output.MaxCapacity),
    Progress: __limitedParseDouble(output.Progress),
    Role: __expectString(output.Role),
    SecurityConfiguration: __expectString(output.SecurityConfiguration),
    Status: __expectString(output.Status),
  } as any;
};

/**
 * deserializeAws_json1_1SessionCommand
 */
const de_SessionCommand = (output: any, context: __SerdeContext): SessionCommand => {
  return {
    Name: __expectString(output.Name),
    PythonVersion: __expectString(output.PythonVersion),
  } as any;
};

/**
 * deserializeAws_json1_1SessionIdList
 */
const de_SessionIdList = (output: any, context: __SerdeContext): string[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return __expectString(entry) as any;
    });
  return retVal;
};

/**
 * deserializeAws_json1_1SessionList
 */
const de_SessionList = (output: any, context: __SerdeContext): Session[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return de_Session(entry, context);
    });
  return retVal;
};

/**
 * deserializeAws_json1_1SkewedInfo
 */
const de_SkewedInfo = (output: any, context: __SerdeContext): SkewedInfo => {
  return {
    SkewedColumnNames:
      output.SkewedColumnNames != null ? de_NameStringList(output.SkewedColumnNames, context) : undefined,
    SkewedColumnValueLocationMaps:
      output.SkewedColumnValueLocationMaps != null
        ? de_LocationMap(output.SkewedColumnValueLocationMaps, context)
        : undefined,
    SkewedColumnValues:
      output.SkewedColumnValues != null ? de_ColumnValueStringList(output.SkewedColumnValues, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1SourceControlDetails
 */
const de_SourceControlDetails = (output: any, context: __SerdeContext): SourceControlDetails => {
  return {
    AuthStrategy: __expectString(output.AuthStrategy),
    AuthToken: __expectString(output.AuthToken),
    Branch: __expectString(output.Branch),
    Folder: __expectString(output.Folder),
    LastCommitId: __expectString(output.LastCommitId),
    Owner: __expectString(output.Owner),
    Provider: __expectString(output.Provider),
    Repository: __expectString(output.Repository),
  } as any;
};

/**
 * deserializeAws_json1_1SparkConnectorSource
 */
const de_SparkConnectorSource = (output: any, context: __SerdeContext): SparkConnectorSource => {
  return {
    AdditionalOptions:
      output.AdditionalOptions != null ? de_AdditionalOptions(output.AdditionalOptions, context) : undefined,
    ConnectionName: __expectString(output.ConnectionName),
    ConnectionType: __expectString(output.ConnectionType),
    ConnectorName: __expectString(output.ConnectorName),
    Name: __expectString(output.Name),
    OutputSchemas: output.OutputSchemas != null ? de_GlueSchemas(output.OutputSchemas, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1SparkConnectorTarget
 */
const de_SparkConnectorTarget = (output: any, context: __SerdeContext): SparkConnectorTarget => {
  return {
    AdditionalOptions:
      output.AdditionalOptions != null ? de_AdditionalOptions(output.AdditionalOptions, context) : undefined,
    ConnectionName: __expectString(output.ConnectionName),
    ConnectionType: __expectString(output.ConnectionType),
    ConnectorName: __expectString(output.ConnectorName),
    Inputs: output.Inputs != null ? de_OneInput(output.Inputs, context) : undefined,
    Name: __expectString(output.Name),
    OutputSchemas: output.OutputSchemas != null ? de_GlueSchemas(output.OutputSchemas, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1SparkSQL
 */
const de_SparkSQL = (output: any, context: __SerdeContext): SparkSQL => {
  return {
    Inputs: output.Inputs != null ? de_ManyInputs(output.Inputs, context) : undefined,
    Name: __expectString(output.Name),
    OutputSchemas: output.OutputSchemas != null ? de_GlueSchemas(output.OutputSchemas, context) : undefined,
    SqlAliases: output.SqlAliases != null ? de_SqlAliases(output.SqlAliases, context) : undefined,
    SqlQuery: __expectString(output.SqlQuery),
  } as any;
};

/**
 * deserializeAws_json1_1Spigot
 */
const de_Spigot = (output: any, context: __SerdeContext): Spigot => {
  return {
    Inputs: output.Inputs != null ? de_OneInput(output.Inputs, context) : undefined,
    Name: __expectString(output.Name),
    Path: __expectString(output.Path),
    Prob: __limitedParseDouble(output.Prob),
    Topk: __expectInt32(output.Topk),
  } as any;
};

/**
 * deserializeAws_json1_1SplitFields
 */
const de_SplitFields = (output: any, context: __SerdeContext): SplitFields => {
  return {
    Inputs: output.Inputs != null ? de_OneInput(output.Inputs, context) : undefined,
    Name: __expectString(output.Name),
    Paths: output.Paths != null ? de_GlueStudioPathList(output.Paths, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1SqlAlias
 */
const de_SqlAlias = (output: any, context: __SerdeContext): SqlAlias => {
  return {
    Alias: __expectString(output.Alias),
    From: __expectString(output.From),
  } as any;
};

/**
 * deserializeAws_json1_1SqlAliases
 */
const de_SqlAliases = (output: any, context: __SerdeContext): SqlAlias[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return de_SqlAlias(entry, context);
    });
  return retVal;
};

/**
 * deserializeAws_json1_1StartBlueprintRunResponse
 */
const de_StartBlueprintRunResponse = (output: any, context: __SerdeContext): StartBlueprintRunResponse => {
  return {
    RunId: __expectString(output.RunId),
  } as any;
};

/**
 * deserializeAws_json1_1StartCrawlerResponse
 */
const de_StartCrawlerResponse = (output: any, context: __SerdeContext): StartCrawlerResponse => {
  return {} as any;
};

/**
 * deserializeAws_json1_1StartCrawlerScheduleResponse
 */
const de_StartCrawlerScheduleResponse = (output: any, context: __SerdeContext): StartCrawlerScheduleResponse => {
  return {} as any;
};

/**
 * deserializeAws_json1_1StartDataQualityRuleRecommendationRunResponse
 */
const de_StartDataQualityRuleRecommendationRunResponse = (
  output: any,
  context: __SerdeContext
): StartDataQualityRuleRecommendationRunResponse => {
  return {
    RunId: __expectString(output.RunId),
  } as any;
};

/**
 * deserializeAws_json1_1StartDataQualityRulesetEvaluationRunResponse
 */
const de_StartDataQualityRulesetEvaluationRunResponse = (
  output: any,
  context: __SerdeContext
): StartDataQualityRulesetEvaluationRunResponse => {
  return {
    RunId: __expectString(output.RunId),
  } as any;
};

/**
 * deserializeAws_json1_1StartExportLabelsTaskRunResponse
 */
const de_StartExportLabelsTaskRunResponse = (
  output: any,
  context: __SerdeContext
): StartExportLabelsTaskRunResponse => {
  return {
    TaskRunId: __expectString(output.TaskRunId),
  } as any;
};

/**
 * deserializeAws_json1_1StartImportLabelsTaskRunResponse
 */
const de_StartImportLabelsTaskRunResponse = (
  output: any,
  context: __SerdeContext
): StartImportLabelsTaskRunResponse => {
  return {
    TaskRunId: __expectString(output.TaskRunId),
  } as any;
};

/**
 * deserializeAws_json1_1StartingEventBatchCondition
 */
const de_StartingEventBatchCondition = (output: any, context: __SerdeContext): StartingEventBatchCondition => {
  return {
    BatchSize: __expectInt32(output.BatchSize),
    BatchWindow: __expectInt32(output.BatchWindow),
  } as any;
};

/**
 * deserializeAws_json1_1StartJobRunResponse
 */
const de_StartJobRunResponse = (output: any, context: __SerdeContext): StartJobRunResponse => {
  return {
    JobRunId: __expectString(output.JobRunId),
  } as any;
};

/**
 * deserializeAws_json1_1StartMLEvaluationTaskRunResponse
 */
const de_StartMLEvaluationTaskRunResponse = (
  output: any,
  context: __SerdeContext
): StartMLEvaluationTaskRunResponse => {
  return {
    TaskRunId: __expectString(output.TaskRunId),
  } as any;
};

/**
 * deserializeAws_json1_1StartMLLabelingSetGenerationTaskRunResponse
 */
const de_StartMLLabelingSetGenerationTaskRunResponse = (
  output: any,
  context: __SerdeContext
): StartMLLabelingSetGenerationTaskRunResponse => {
  return {
    TaskRunId: __expectString(output.TaskRunId),
  } as any;
};

/**
 * deserializeAws_json1_1StartTriggerResponse
 */
const de_StartTriggerResponse = (output: any, context: __SerdeContext): StartTriggerResponse => {
  return {
    Name: __expectString(output.Name),
  } as any;
};

/**
 * deserializeAws_json1_1StartWorkflowRunResponse
 */
const de_StartWorkflowRunResponse = (output: any, context: __SerdeContext): StartWorkflowRunResponse => {
  return {
    RunId: __expectString(output.RunId),
  } as any;
};

/**
 * deserializeAws_json1_1Statement
 */
const de_Statement = (output: any, context: __SerdeContext): Statement => {
  return {
    Code: __expectString(output.Code),
    CompletedOn: __expectLong(output.CompletedOn),
    Id: __expectInt32(output.Id),
    Output: output.Output != null ? de_StatementOutput(output.Output, context) : undefined,
    Progress: __limitedParseDouble(output.Progress),
    StartedOn: __expectLong(output.StartedOn),
    State: __expectString(output.State),
  } as any;
};

/**
 * deserializeAws_json1_1StatementList
 */
const de_StatementList = (output: any, context: __SerdeContext): Statement[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return de_Statement(entry, context);
    });
  return retVal;
};

/**
 * deserializeAws_json1_1StatementOutput
 */
const de_StatementOutput = (output: any, context: __SerdeContext): StatementOutput => {
  return {
    Data: output.Data != null ? de_StatementOutputData(output.Data, context) : undefined,
    ErrorName: __expectString(output.ErrorName),
    ErrorValue: __expectString(output.ErrorValue),
    ExecutionCount: __expectInt32(output.ExecutionCount),
    Status: __expectString(output.Status),
    Traceback: output.Traceback != null ? de_OrchestrationStringList(output.Traceback, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1StatementOutputData
 */
const de_StatementOutputData = (output: any, context: __SerdeContext): StatementOutputData => {
  return {
    TextPlain: __expectString(output.TextPlain),
  } as any;
};

/**
 * deserializeAws_json1_1StopCrawlerResponse
 */
const de_StopCrawlerResponse = (output: any, context: __SerdeContext): StopCrawlerResponse => {
  return {} as any;
};

/**
 * deserializeAws_json1_1StopCrawlerScheduleResponse
 */
const de_StopCrawlerScheduleResponse = (output: any, context: __SerdeContext): StopCrawlerScheduleResponse => {
  return {} as any;
};

/**
 * deserializeAws_json1_1StopSessionResponse
 */
const de_StopSessionResponse = (output: any, context: __SerdeContext): StopSessionResponse => {
  return {
    Id: __expectString(output.Id),
  } as any;
};

/**
 * deserializeAws_json1_1StopTriggerResponse
 */
const de_StopTriggerResponse = (output: any, context: __SerdeContext): StopTriggerResponse => {
  return {
    Name: __expectString(output.Name),
  } as any;
};

/**
 * deserializeAws_json1_1StopWorkflowRunResponse
 */
const de_StopWorkflowRunResponse = (output: any, context: __SerdeContext): StopWorkflowRunResponse => {
  return {} as any;
};

/**
 * deserializeAws_json1_1StorageDescriptor
 */
const de_StorageDescriptor = (output: any, context: __SerdeContext): StorageDescriptor => {
  return {
    AdditionalLocations:
      output.AdditionalLocations != null ? de_LocationStringList(output.AdditionalLocations, context) : undefined,
    BucketColumns: output.BucketColumns != null ? de_NameStringList(output.BucketColumns, context) : undefined,
    Columns: output.Columns != null ? de_ColumnList(output.Columns, context) : undefined,
    Compressed: __expectBoolean(output.Compressed),
    InputFormat: __expectString(output.InputFormat),
    Location: __expectString(output.Location),
    NumberOfBuckets: __expectInt32(output.NumberOfBuckets),
    OutputFormat: __expectString(output.OutputFormat),
    Parameters: output.Parameters != null ? de_ParametersMap(output.Parameters, context) : undefined,
    SchemaReference: output.SchemaReference != null ? de_SchemaReference(output.SchemaReference, context) : undefined,
    SerdeInfo: output.SerdeInfo != null ? de_SerDeInfo(output.SerdeInfo, context) : undefined,
    SkewedInfo: output.SkewedInfo != null ? de_SkewedInfo(output.SkewedInfo, context) : undefined,
    SortColumns: output.SortColumns != null ? de_OrderList(output.SortColumns, context) : undefined,
    StoredAsSubDirectories: __expectBoolean(output.StoredAsSubDirectories),
  } as any;
};

/**
 * deserializeAws_json1_1StreamingDataPreviewOptions
 */
const de_StreamingDataPreviewOptions = (output: any, context: __SerdeContext): StreamingDataPreviewOptions => {
  return {
    PollingTime: __expectLong(output.PollingTime),
    RecordPollingLimit: __expectLong(output.RecordPollingLimit),
  } as any;
};

/**
 * deserializeAws_json1_1StringColumnStatisticsData
 */
const de_StringColumnStatisticsData = (output: any, context: __SerdeContext): StringColumnStatisticsData => {
  return {
    AverageLength: __limitedParseDouble(output.AverageLength),
    MaximumLength: __expectLong(output.MaximumLength),
    NumberOfDistinctValues: __expectLong(output.NumberOfDistinctValues),
    NumberOfNulls: __expectLong(output.NumberOfNulls),
  } as any;
};

/**
 * deserializeAws_json1_1StringList
 */
const de_StringList = (output: any, context: __SerdeContext): string[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return __expectString(entry) as any;
    });
  return retVal;
};

/**
 * deserializeAws_json1_1Table
 */
const de_Table = (output: any, context: __SerdeContext): Table => {
  return {
    CatalogId: __expectString(output.CatalogId),
    CreateTime:
      output.CreateTime != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.CreateTime))) : undefined,
    CreatedBy: __expectString(output.CreatedBy),
    DatabaseName: __expectString(output.DatabaseName),
    Description: __expectString(output.Description),
    FederatedTable: output.FederatedTable != null ? de_FederatedTable(output.FederatedTable, context) : undefined,
    IsRegisteredWithLakeFormation: __expectBoolean(output.IsRegisteredWithLakeFormation),
    LastAccessTime:
      output.LastAccessTime != null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.LastAccessTime)))
        : undefined,
    LastAnalyzedTime:
      output.LastAnalyzedTime != null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.LastAnalyzedTime)))
        : undefined,
    Name: __expectString(output.Name),
    Owner: __expectString(output.Owner),
    Parameters: output.Parameters != null ? de_ParametersMap(output.Parameters, context) : undefined,
    PartitionKeys: output.PartitionKeys != null ? de_ColumnList(output.PartitionKeys, context) : undefined,
    Retention: __expectInt32(output.Retention),
    StorageDescriptor:
      output.StorageDescriptor != null ? de_StorageDescriptor(output.StorageDescriptor, context) : undefined,
    TableType: __expectString(output.TableType),
    TargetTable: output.TargetTable != null ? de_TableIdentifier(output.TargetTable, context) : undefined,
    UpdateTime:
      output.UpdateTime != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.UpdateTime))) : undefined,
    VersionId: __expectString(output.VersionId),
    ViewExpandedText: __expectString(output.ViewExpandedText),
    ViewOriginalText: __expectString(output.ViewOriginalText),
  } as any;
};

/**
 * deserializeAws_json1_1TableError
 */
const de_TableError = (output: any, context: __SerdeContext): TableError => {
  return {
    ErrorDetail: output.ErrorDetail != null ? de_ErrorDetail(output.ErrorDetail, context) : undefined,
    TableName: __expectString(output.TableName),
  } as any;
};

/**
 * deserializeAws_json1_1TableErrors
 */
const de_TableErrors = (output: any, context: __SerdeContext): TableError[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return de_TableError(entry, context);
    });
  return retVal;
};

/**
 * deserializeAws_json1_1TableIdentifier
 */
const de_TableIdentifier = (output: any, context: __SerdeContext): TableIdentifier => {
  return {
    CatalogId: __expectString(output.CatalogId),
    DatabaseName: __expectString(output.DatabaseName),
    Name: __expectString(output.Name),
  } as any;
};

/**
 * deserializeAws_json1_1TableList
 */
const de_TableList = (output: any, context: __SerdeContext): Table[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return de_Table(entry, context);
    });
  return retVal;
};

/**
 * deserializeAws_json1_1TableVersion
 */
const de_TableVersion = (output: any, context: __SerdeContext): TableVersion => {
  return {
    Table: output.Table != null ? de_Table(output.Table, context) : undefined,
    VersionId: __expectString(output.VersionId),
  } as any;
};

/**
 * deserializeAws_json1_1TableVersionError
 */
const de_TableVersionError = (output: any, context: __SerdeContext): TableVersionError => {
  return {
    ErrorDetail: output.ErrorDetail != null ? de_ErrorDetail(output.ErrorDetail, context) : undefined,
    TableName: __expectString(output.TableName),
    VersionId: __expectString(output.VersionId),
  } as any;
};

/**
 * deserializeAws_json1_1TableVersionErrors
 */
const de_TableVersionErrors = (output: any, context: __SerdeContext): TableVersionError[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return de_TableVersionError(entry, context);
    });
  return retVal;
};

/**
 * deserializeAws_json1_1TagResourceResponse
 */
const de_TagResourceResponse = (output: any, context: __SerdeContext): TagResourceResponse => {
  return {} as any;
};

/**
 * deserializeAws_json1_1TagsMap
 */
const de_TagsMap = (output: any, context: __SerdeContext): Record<string, string> => {
  return Object.entries(output).reduce((acc: Record<string, string>, [key, value]: [string, any]) => {
    if (value === null) {
      return acc;
    }
    acc[key] = __expectString(value) as any;
    return acc;
  }, {});
};

/**
 * deserializeAws_json1_1TaskRun
 */
const de_TaskRun = (output: any, context: __SerdeContext): TaskRun => {
  return {
    CompletedOn:
      output.CompletedOn != null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.CompletedOn)))
        : undefined,
    ErrorString: __expectString(output.ErrorString),
    ExecutionTime: __expectInt32(output.ExecutionTime),
    LastModifiedOn:
      output.LastModifiedOn != null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.LastModifiedOn)))
        : undefined,
    LogGroupName: __expectString(output.LogGroupName),
    Properties: output.Properties != null ? de_TaskRunProperties(output.Properties, context) : undefined,
    StartedOn:
      output.StartedOn != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.StartedOn))) : undefined,
    Status: __expectString(output.Status),
    TaskRunId: __expectString(output.TaskRunId),
    TransformId: __expectString(output.TransformId),
  } as any;
};

/**
 * deserializeAws_json1_1TaskRunList
 */
const de_TaskRunList = (output: any, context: __SerdeContext): TaskRun[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return de_TaskRun(entry, context);
    });
  return retVal;
};

/**
 * deserializeAws_json1_1TaskRunProperties
 */
const de_TaskRunProperties = (output: any, context: __SerdeContext): TaskRunProperties => {
  return {
    ExportLabelsTaskRunProperties:
      output.ExportLabelsTaskRunProperties != null
        ? de_ExportLabelsTaskRunProperties(output.ExportLabelsTaskRunProperties, context)
        : undefined,
    FindMatchesTaskRunProperties:
      output.FindMatchesTaskRunProperties != null
        ? de_FindMatchesTaskRunProperties(output.FindMatchesTaskRunProperties, context)
        : undefined,
    ImportLabelsTaskRunProperties:
      output.ImportLabelsTaskRunProperties != null
        ? de_ImportLabelsTaskRunProperties(output.ImportLabelsTaskRunProperties, context)
        : undefined,
    LabelingSetGenerationTaskRunProperties:
      output.LabelingSetGenerationTaskRunProperties != null
        ? de_LabelingSetGenerationTaskRunProperties(output.LabelingSetGenerationTaskRunProperties, context)
        : undefined,
    TaskType: __expectString(output.TaskType),
  } as any;
};

/**
 * deserializeAws_json1_1TransformConfigParameter
 */
const de_TransformConfigParameter = (output: any, context: __SerdeContext): TransformConfigParameter => {
  return {
    IsOptional: __expectBoolean(output.IsOptional),
    ListType: __expectString(output.ListType),
    Name: __expectString(output.Name),
    Type: __expectString(output.Type),
    ValidationMessage: __expectString(output.ValidationMessage),
    ValidationRule: __expectString(output.ValidationRule),
    Value: output.Value != null ? de_EnclosedInStringProperties(output.Value, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1TransformConfigParameterList
 */
const de_TransformConfigParameterList = (output: any, context: __SerdeContext): TransformConfigParameter[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return de_TransformConfigParameter(entry, context);
    });
  return retVal;
};

/**
 * deserializeAws_json1_1TransformEncryption
 */
const de_TransformEncryption = (output: any, context: __SerdeContext): TransformEncryption => {
  return {
    MlUserDataEncryption:
      output.MlUserDataEncryption != null ? de_MLUserDataEncryption(output.MlUserDataEncryption, context) : undefined,
    TaskRunSecurityConfigurationName: __expectString(output.TaskRunSecurityConfigurationName),
  } as any;
};

/**
 * deserializeAws_json1_1TransformIdList
 */
const de_TransformIdList = (output: any, context: __SerdeContext): string[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return __expectString(entry) as any;
    });
  return retVal;
};

/**
 * deserializeAws_json1_1TransformList
 */
const de_TransformList = (output: any, context: __SerdeContext): MLTransform[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return de_MLTransform(entry, context);
    });
  return retVal;
};

/**
 * deserializeAws_json1_1TransformParameters
 */
const de_TransformParameters = (output: any, context: __SerdeContext): TransformParameters => {
  return {
    FindMatchesParameters:
      output.FindMatchesParameters != null
        ? de_FindMatchesParameters(output.FindMatchesParameters, context)
        : undefined,
    TransformType: __expectString(output.TransformType),
  } as any;
};

/**
 * deserializeAws_json1_1TransformSchema
 */
const de_TransformSchema = (output: any, context: __SerdeContext): SchemaColumn[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return de_SchemaColumn(entry, context);
    });
  return retVal;
};

/**
 * deserializeAws_json1_1Trigger
 */
const de_Trigger = (output: any, context: __SerdeContext): Trigger => {
  return {
    Actions: output.Actions != null ? de_ActionList(output.Actions, context) : undefined,
    Description: __expectString(output.Description),
    EventBatchingCondition:
      output.EventBatchingCondition != null
        ? de_EventBatchingCondition(output.EventBatchingCondition, context)
        : undefined,
    Id: __expectString(output.Id),
    Name: __expectString(output.Name),
    Predicate: output.Predicate != null ? de_Predicate(output.Predicate, context) : undefined,
    Schedule: __expectString(output.Schedule),
    State: __expectString(output.State),
    Type: __expectString(output.Type),
    WorkflowName: __expectString(output.WorkflowName),
  } as any;
};

/**
 * deserializeAws_json1_1TriggerList
 */
const de_TriggerList = (output: any, context: __SerdeContext): Trigger[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return de_Trigger(entry, context);
    });
  return retVal;
};

/**
 * deserializeAws_json1_1TriggerNameList
 */
const de_TriggerNameList = (output: any, context: __SerdeContext): string[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return __expectString(entry) as any;
    });
  return retVal;
};

/**
 * deserializeAws_json1_1TriggerNodeDetails
 */
const de_TriggerNodeDetails = (output: any, context: __SerdeContext): TriggerNodeDetails => {
  return {
    Trigger: output.Trigger != null ? de_Trigger(output.Trigger, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1TwoInputs
 */
const de_TwoInputs = (output: any, context: __SerdeContext): string[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return __expectString(entry) as any;
    });
  return retVal;
};

/**
 * deserializeAws_json1_1UnfilteredPartition
 */
const de_UnfilteredPartition = (output: any, context: __SerdeContext): UnfilteredPartition => {
  return {
    AuthorizedColumns:
      output.AuthorizedColumns != null ? de_NameStringList(output.AuthorizedColumns, context) : undefined,
    IsRegisteredWithLakeFormation: __expectBoolean(output.IsRegisteredWithLakeFormation),
    Partition: output.Partition != null ? de_Partition(output.Partition, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1UnfilteredPartitionList
 */
const de_UnfilteredPartitionList = (output: any, context: __SerdeContext): UnfilteredPartition[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return de_UnfilteredPartition(entry, context);
    });
  return retVal;
};

/**
 * deserializeAws_json1_1Union
 */
const de_Union = (output: any, context: __SerdeContext): Union => {
  return {
    Inputs: output.Inputs != null ? de_TwoInputs(output.Inputs, context) : undefined,
    Name: __expectString(output.Name),
    UnionType: __expectString(output.UnionType),
  } as any;
};

/**
 * deserializeAws_json1_1UntagResourceResponse
 */
const de_UntagResourceResponse = (output: any, context: __SerdeContext): UntagResourceResponse => {
  return {} as any;
};

/**
 * deserializeAws_json1_1UpdateBlueprintResponse
 */
const de_UpdateBlueprintResponse = (output: any, context: __SerdeContext): UpdateBlueprintResponse => {
  return {
    Name: __expectString(output.Name),
  } as any;
};

/**
 * deserializeAws_json1_1UpdateClassifierResponse
 */
const de_UpdateClassifierResponse = (output: any, context: __SerdeContext): UpdateClassifierResponse => {
  return {} as any;
};

/**
 * deserializeAws_json1_1UpdateColumnStatisticsForPartitionResponse
 */
const de_UpdateColumnStatisticsForPartitionResponse = (
  output: any,
  context: __SerdeContext
): UpdateColumnStatisticsForPartitionResponse => {
  return {
    Errors: output.Errors != null ? de_ColumnStatisticsErrors(output.Errors, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1UpdateColumnStatisticsForTableResponse
 */
const de_UpdateColumnStatisticsForTableResponse = (
  output: any,
  context: __SerdeContext
): UpdateColumnStatisticsForTableResponse => {
  return {
    Errors: output.Errors != null ? de_ColumnStatisticsErrors(output.Errors, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1UpdateConnectionResponse
 */
const de_UpdateConnectionResponse = (output: any, context: __SerdeContext): UpdateConnectionResponse => {
  return {} as any;
};

/**
 * deserializeAws_json1_1UpdateCrawlerResponse
 */
const de_UpdateCrawlerResponse = (output: any, context: __SerdeContext): UpdateCrawlerResponse => {
  return {} as any;
};

/**
 * deserializeAws_json1_1UpdateCrawlerScheduleResponse
 */
const de_UpdateCrawlerScheduleResponse = (output: any, context: __SerdeContext): UpdateCrawlerScheduleResponse => {
  return {} as any;
};

/**
 * deserializeAws_json1_1UpdateDatabaseResponse
 */
const de_UpdateDatabaseResponse = (output: any, context: __SerdeContext): UpdateDatabaseResponse => {
  return {} as any;
};

/**
 * deserializeAws_json1_1UpdateDataQualityRulesetResponse
 */
const de_UpdateDataQualityRulesetResponse = (
  output: any,
  context: __SerdeContext
): UpdateDataQualityRulesetResponse => {
  return {
    Description: __expectString(output.Description),
    Name: __expectString(output.Name),
    Ruleset: __expectString(output.Ruleset),
  } as any;
};

/**
 * deserializeAws_json1_1UpdateDevEndpointResponse
 */
const de_UpdateDevEndpointResponse = (output: any, context: __SerdeContext): UpdateDevEndpointResponse => {
  return {} as any;
};

/**
 * deserializeAws_json1_1UpdateJobFromSourceControlResponse
 */
const de_UpdateJobFromSourceControlResponse = (
  output: any,
  context: __SerdeContext
): UpdateJobFromSourceControlResponse => {
  return {
    JobName: __expectString(output.JobName),
  } as any;
};

/**
 * deserializeAws_json1_1UpdateJobResponse
 */
const de_UpdateJobResponse = (output: any, context: __SerdeContext): UpdateJobResponse => {
  return {
    JobName: __expectString(output.JobName),
  } as any;
};

/**
 * deserializeAws_json1_1UpdateMLTransformResponse
 */
const de_UpdateMLTransformResponse = (output: any, context: __SerdeContext): UpdateMLTransformResponse => {
  return {
    TransformId: __expectString(output.TransformId),
  } as any;
};

/**
 * deserializeAws_json1_1UpdatePartitionResponse
 */
const de_UpdatePartitionResponse = (output: any, context: __SerdeContext): UpdatePartitionResponse => {
  return {} as any;
};

/**
 * deserializeAws_json1_1UpdateRegistryResponse
 */
const de_UpdateRegistryResponse = (output: any, context: __SerdeContext): UpdateRegistryResponse => {
  return {
    RegistryArn: __expectString(output.RegistryArn),
    RegistryName: __expectString(output.RegistryName),
  } as any;
};

/**
 * deserializeAws_json1_1UpdateSchemaResponse
 */
const de_UpdateSchemaResponse = (output: any, context: __SerdeContext): UpdateSchemaResponse => {
  return {
    RegistryName: __expectString(output.RegistryName),
    SchemaArn: __expectString(output.SchemaArn),
    SchemaName: __expectString(output.SchemaName),
  } as any;
};

/**
 * deserializeAws_json1_1UpdateSourceControlFromJobResponse
 */
const de_UpdateSourceControlFromJobResponse = (
  output: any,
  context: __SerdeContext
): UpdateSourceControlFromJobResponse => {
  return {
    JobName: __expectString(output.JobName),
  } as any;
};

/**
 * deserializeAws_json1_1UpdateTableResponse
 */
const de_UpdateTableResponse = (output: any, context: __SerdeContext): UpdateTableResponse => {
  return {} as any;
};

/**
 * deserializeAws_json1_1UpdateTriggerResponse
 */
const de_UpdateTriggerResponse = (output: any, context: __SerdeContext): UpdateTriggerResponse => {
  return {
    Trigger: output.Trigger != null ? de_Trigger(output.Trigger, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1UpdateUserDefinedFunctionResponse
 */
const de_UpdateUserDefinedFunctionResponse = (
  output: any,
  context: __SerdeContext
): UpdateUserDefinedFunctionResponse => {
  return {} as any;
};

/**
 * deserializeAws_json1_1UpdateWorkflowResponse
 */
const de_UpdateWorkflowResponse = (output: any, context: __SerdeContext): UpdateWorkflowResponse => {
  return {
    Name: __expectString(output.Name),
  } as any;
};

/**
 * deserializeAws_json1_1UpsertRedshiftTargetOptions
 */
const de_UpsertRedshiftTargetOptions = (output: any, context: __SerdeContext): UpsertRedshiftTargetOptions => {
  return {
    ConnectionName: __expectString(output.ConnectionName),
    TableLocation: __expectString(output.TableLocation),
    UpsertKeys: output.UpsertKeys != null ? de_EnclosedInStringPropertiesMinOne(output.UpsertKeys, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1UserDefinedFunction
 */
const de_UserDefinedFunction = (output: any, context: __SerdeContext): UserDefinedFunction => {
  return {
    CatalogId: __expectString(output.CatalogId),
    ClassName: __expectString(output.ClassName),
    CreateTime:
      output.CreateTime != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.CreateTime))) : undefined,
    DatabaseName: __expectString(output.DatabaseName),
    FunctionName: __expectString(output.FunctionName),
    OwnerName: __expectString(output.OwnerName),
    OwnerType: __expectString(output.OwnerType),
    ResourceUris: output.ResourceUris != null ? de_ResourceUriList(output.ResourceUris, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1UserDefinedFunctionList
 */
const de_UserDefinedFunctionList = (output: any, context: __SerdeContext): UserDefinedFunction[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return de_UserDefinedFunction(entry, context);
    });
  return retVal;
};

/**
 * deserializeAws_json1_1ValidationException
 */
const de_ValidationException = (output: any, context: __SerdeContext): ValidationException => {
  return {
    Message: __expectString(output.Message),
  } as any;
};

/**
 * deserializeAws_json1_1ValueStringList
 */
const de_ValueStringList = (output: any, context: __SerdeContext): string[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return __expectString(entry) as any;
    });
  return retVal;
};

/**
 * deserializeAws_json1_1VersionMismatchException
 */
const de_VersionMismatchException = (output: any, context: __SerdeContext): VersionMismatchException => {
  return {
    Message: __expectString(output.Message),
  } as any;
};

/**
 * deserializeAws_json1_1Workflow
 */
const de_Workflow = (output: any, context: __SerdeContext): Workflow => {
  return {
    BlueprintDetails:
      output.BlueprintDetails != null ? de_BlueprintDetails(output.BlueprintDetails, context) : undefined,
    CreatedOn:
      output.CreatedOn != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.CreatedOn))) : undefined,
    DefaultRunProperties:
      output.DefaultRunProperties != null ? de_WorkflowRunProperties(output.DefaultRunProperties, context) : undefined,
    Description: __expectString(output.Description),
    Graph: output.Graph != null ? de_WorkflowGraph(output.Graph, context) : undefined,
    LastModifiedOn:
      output.LastModifiedOn != null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.LastModifiedOn)))
        : undefined,
    LastRun: output.LastRun != null ? de_WorkflowRun(output.LastRun, context) : undefined,
    MaxConcurrentRuns: __expectInt32(output.MaxConcurrentRuns),
    Name: __expectString(output.Name),
  } as any;
};

/**
 * deserializeAws_json1_1WorkflowGraph
 */
const de_WorkflowGraph = (output: any, context: __SerdeContext): WorkflowGraph => {
  return {
    Edges: output.Edges != null ? de_EdgeList(output.Edges, context) : undefined,
    Nodes: output.Nodes != null ? de_NodeList(output.Nodes, context) : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1WorkflowNames
 */
const de_WorkflowNames = (output: any, context: __SerdeContext): string[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return __expectString(entry) as any;
    });
  return retVal;
};

/**
 * deserializeAws_json1_1WorkflowRun
 */
const de_WorkflowRun = (output: any, context: __SerdeContext): WorkflowRun => {
  return {
    CompletedOn:
      output.CompletedOn != null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.CompletedOn)))
        : undefined,
    ErrorMessage: __expectString(output.ErrorMessage),
    Graph: output.Graph != null ? de_WorkflowGraph(output.Graph, context) : undefined,
    Name: __expectString(output.Name),
    PreviousRunId: __expectString(output.PreviousRunId),
    StartedOn:
      output.StartedOn != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.StartedOn))) : undefined,
    StartingEventBatchCondition:
      output.StartingEventBatchCondition != null
        ? de_StartingEventBatchCondition(output.StartingEventBatchCondition, context)
        : undefined,
    Statistics: output.Statistics != null ? de_WorkflowRunStatistics(output.Statistics, context) : undefined,
    Status: __expectString(output.Status),
    WorkflowRunId: __expectString(output.WorkflowRunId),
    WorkflowRunProperties:
      output.WorkflowRunProperties != null
        ? de_WorkflowRunProperties(output.WorkflowRunProperties, context)
        : undefined,
  } as any;
};

/**
 * deserializeAws_json1_1WorkflowRunProperties
 */
const de_WorkflowRunProperties = (output: any, context: __SerdeContext): Record<string, string> => {
  return Object.entries(output).reduce((acc: Record<string, string>, [key, value]: [string, any]) => {
    if (value === null) {
      return acc;
    }
    acc[key] = __expectString(value) as any;
    return acc;
  }, {});
};

/**
 * deserializeAws_json1_1WorkflowRuns
 */
const de_WorkflowRuns = (output: any, context: __SerdeContext): WorkflowRun[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return de_WorkflowRun(entry, context);
    });
  return retVal;
};

/**
 * deserializeAws_json1_1WorkflowRunStatistics
 */
const de_WorkflowRunStatistics = (output: any, context: __SerdeContext): WorkflowRunStatistics => {
  return {
    ErroredActions: __expectInt32(output.ErroredActions),
    FailedActions: __expectInt32(output.FailedActions),
    RunningActions: __expectInt32(output.RunningActions),
    StoppedActions: __expectInt32(output.StoppedActions),
    SucceededActions: __expectInt32(output.SucceededActions),
    TimeoutActions: __expectInt32(output.TimeoutActions),
    TotalActions: __expectInt32(output.TotalActions),
    WaitingActions: __expectInt32(output.WaitingActions),
  } as any;
};

/**
 * deserializeAws_json1_1Workflows
 */
const de_Workflows = (output: any, context: __SerdeContext): Workflow[] => {
  const retVal = (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return de_Workflow(entry, context);
    });
  return retVal;
};

/**
 * deserializeAws_json1_1XMLClassifier
 */
const de_XMLClassifier = (output: any, context: __SerdeContext): XMLClassifier => {
  return {
    Classification: __expectString(output.Classification),
    CreationTime:
      output.CreationTime != null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.CreationTime)))
        : undefined,
    LastUpdated:
      output.LastUpdated != null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.LastUpdated)))
        : undefined,
    Name: __expectString(output.Name),
    RowTag: __expectString(output.RowTag),
    Version: __expectLong(output.Version),
  } as any;
};

const deserializeMetadata = (output: __HttpResponse): __ResponseMetadata => ({
  httpStatusCode: output.statusCode,
  requestId:
    output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
  extendedRequestId: output.headers["x-amz-id-2"],
  cfId: output.headers["x-amz-cf-id"],
});

// Collect low-level response body stream to Uint8Array.
const collectBody = (streamBody: any = new Uint8Array(), context: __SerdeContext): Promise<Uint8Array> => {
  if (streamBody instanceof Uint8Array) {
    return Promise.resolve(streamBody);
  }
  return context.streamCollector(streamBody) || Promise.resolve(new Uint8Array());
};

// Encode Uint8Array data into string with utf-8.
const collectBodyString = (streamBody: any, context: __SerdeContext): Promise<string> =>
  collectBody(streamBody, context).then((body) => context.utf8Encoder(body));

const buildHttpRpcRequest = async (
  context: __SerdeContext,
  headers: __HeaderBag,
  path: string,
  resolvedHostname: string | undefined,
  body: any
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const contents: any = {
    protocol,
    hostname,
    port,
    method: "POST",
    path: basePath.endsWith("/") ? basePath.slice(0, -1) + path : basePath + path,
    headers,
  };
  if (resolvedHostname !== undefined) {
    contents.hostname = resolvedHostname;
  }
  if (body !== undefined) {
    contents.body = body;
  }
  return new __HttpRequest(contents);
};

const parseBody = (streamBody: any, context: __SerdeContext): any =>
  collectBodyString(streamBody, context).then((encoded) => {
    if (encoded.length) {
      return JSON.parse(encoded);
    }
    return {};
  });

const parseErrorBody = async (errorBody: any, context: __SerdeContext) => {
  const value = await parseBody(errorBody, context);
  value.message = value.message ?? value.Message;
  return value;
};

/**
 * Load an error code for the aws.rest-json-1.1 protocol.
 */
const loadRestJsonErrorCode = (output: __HttpResponse, data: any): string | undefined => {
  const findKey = (object: any, key: string) => Object.keys(object).find((k) => k.toLowerCase() === key.toLowerCase());

  const sanitizeErrorCode = (rawValue: string | number): string => {
    let cleanValue = rawValue;
    if (typeof cleanValue === "number") {
      cleanValue = cleanValue.toString();
    }
    if (cleanValue.indexOf(",") >= 0) {
      cleanValue = cleanValue.split(",")[0];
    }
    if (cleanValue.indexOf(":") >= 0) {
      cleanValue = cleanValue.split(":")[0];
    }
    if (cleanValue.indexOf("#") >= 0) {
      cleanValue = cleanValue.split("#")[1];
    }
    return cleanValue;
  };

  const headerKey = findKey(output.headers, "x-amzn-errortype");
  if (headerKey !== undefined) {
    return sanitizeErrorCode(output.headers[headerKey]);
  }

  if (data.code !== undefined) {
    return sanitizeErrorCode(data.code);
  }

  if (data["__type"] !== undefined) {
    return sanitizeErrorCode(data["__type"]);
  }
};
